// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from esp32s2.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Espressif

//go:build esp && esp32s2

/*
// 32-bit MCU & 2.4 GHz Wi-Fi
*/
//     Copyright 2023 Espressif Systems (Shanghai) PTE LTD Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
package esp

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "ESP32-S2"
	CPU          = "Xtensa LX7"
	FPUPresent   = false
	NVICPrioBits = 0
)

// Interrupt numbers.
const (
	// Interrupt Controller (Core 0)
	IRQ_WIFI_MAC = 0

	// Interrupt Controller (Core 0)
	IRQ_WIFI_NMI = 1

	// Interrupt Controller (Core 0)
	IRQ_WIFI_PWR = 2

	// Interrupt Controller (Core 0)
	IRQ_WIFI_BB = 3

	// Interrupt Controller (Core 0)
	IRQ_BT_MAC = 4

	// Interrupt Controller (Core 0)
	IRQ_BT_BB = 5

	// Interrupt Controller (Core 0)
	IRQ_BT_BB_NMI = 6

	// Interrupt Controller (Core 0)
	IRQ_RWBT = 7

	// Interrupt Controller (Core 0)
	IRQ_RWBLE = 8

	// Interrupt Controller (Core 0)
	IRQ_RWBT_NMI = 9

	// Interrupt Controller (Core 0)
	IRQ_RWBLE_NMI = 10

	// Interrupt Controller (Core 0)
	IRQ_SLC0 = 11

	// Interrupt Controller (Core 0)
	IRQ_SLC1 = 12

	// Universal Host Controller Interface 0
	IRQ_UHCI0 = 13

	// Universal Host Controller Interface 0
	IRQ_UHCI1 = 14

	// Timer Group 0
	IRQ_TG0_T0_LEVEL = 15

	// Timer Group 0
	IRQ_TG0_T1_LEVEL = 16

	// Timer Group 0
	IRQ_TG0_WDT_LEVEL = 17

	// Timer Group 0
	IRQ_TG0_LACT_LEVEL = 18

	// Timer Group 1
	IRQ_TG1_T0_LEVEL = 19

	// Timer Group 1
	IRQ_TG1_T1_LEVEL = 20

	// Timer Group 1
	IRQ_TG1_WDT_LEVEL = 21

	// Timer Group 1
	IRQ_TG1_LACT_LEVEL = 22

	// General Purpose Input/Output
	IRQ_GPIO = 23

	// General Purpose Input/Output
	IRQ_GPIO_NMI = 24

	// General Purpose Input/Output
	IRQ_GPIO_INTR_2 = 25

	// General Purpose Input/Output
	IRQ_GPIO_NMI_2 = 26

	// DEDICATED_GPIO Peripheral
	IRQ_DEDICATED_GPIO = 27

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR0 = 28

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR1 = 29

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR2 = 30

	// Interrupt Controller (Core 0)
	IRQ_FROM_CPU_INTR3 = 31

	// SPI (Serial Peripheral Interface) Controller 1
	IRQ_SPI1 = 32

	// SPI (Serial Peripheral Interface) Controller 2
	IRQ_SPI2 = 33

	// SPI (Serial Peripheral Interface) Controller 3
	IRQ_SPI3 = 34

	// I2S (Inter-IC Sound) Controller 0
	IRQ_I2S0 = 35

	// I2S (Inter-IC Sound) Controller 0
	IRQ_I2S1 = 36

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
	IRQ_UART0 = 37

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
	IRQ_UART1 = 38

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
	IRQ_UART2 = 39

	// Interrupt Controller (Core 0)
	IRQ_SDIO_HOST = 40

	// LED Control PWM (Pulse Width Modulation)
	IRQ_LEDC = 45

	// eFuse Controller
	IRQ_EFUSE = 46

	// Two-Wire Automotive Interface
	IRQ_TWAI0 = 47

	// USB OTG (On-The-Go)
	IRQ_USB = 48

	// Real-Time Clock Control
	IRQ_RTC_CORE = 49

	// Remote Control
	IRQ_RMT = 50

	// Pulse Count Controller
	IRQ_PCNT = 51

	// I2C (Inter-Integrated Circuit) Controller 0
	IRQ_I2C_EXT0 = 52

	// I2C (Inter-Integrated Circuit) Controller 1
	IRQ_I2C_EXT1 = 53

	// RSA (Rivest Shamir Adleman) Accelerator
	IRQ_RSA = 54

	// SHA (Secure Hash Algorithm) Accelerator
	IRQ_SHA = 55

	// AES (Advanced Encryption Standard) Accelerator
	IRQ_AES = 56

	// SPI (Serial Peripheral Interface) Controller 2
	IRQ_SPI2_DMA = 57

	// SPI (Serial Peripheral Interface) Controller 3
	IRQ_SPI3_DMA = 58

	// Interrupt Controller (Core 0)
	IRQ_WDT = 59

	// LED Control PWM (Pulse Width Modulation)
	IRQ_TIMER1 = 60

	// LED Control PWM (Pulse Width Modulation)
	IRQ_TIMER2 = 61

	// Timer Group 0
	IRQ_TG0_T0_EDGE = 62

	// Timer Group 0
	IRQ_TG0_T1_EDGE = 63

	// Timer Group 0
	IRQ_TG0_WDT_EDGE = 64

	// Timer Group 0
	IRQ_TG0_LACT_EDGE = 65

	// Timer Group 1
	IRQ_TG1_T0_EDGE = 66

	// Timer Group 1
	IRQ_TG1_T1_EDGE = 67

	// Timer Group 1
	IRQ_TG1_WDT_EDGE = 68

	// Timer Group 1
	IRQ_TG1_LACT_EDGE = 69

	// Interrupt Controller (Core 0)
	IRQ_CACHE_IA = 70

	// System Timer
	IRQ_SYSTIMER_TARGET0 = 71

	// System Timer
	IRQ_SYSTIMER_TARGET1 = 72

	// System Timer
	IRQ_SYSTIMER_TARGET2 = 73

	// Permissions Controller
	IRQ_PMS_PRO_IRAM0_ILG = 75

	// Permissions Controller
	IRQ_PMS_PRO_DRAM0_ILG = 76

	// Permissions Controller
	IRQ_PMS_PRO_DPORT_ILG = 77

	// Permissions Controller
	IRQ_PMS_PRO_AHB_ILG = 78

	// Permissions Controller
	IRQ_PMS_PRO_CACHE_ILG = 79

	// Permissions Controller
	IRQ_PMS_DMA_APB_I_ILG = 80

	// Permissions Controller
	IRQ_PMS_DMA_RX_I_ILG = 81

	// Permissions Controller
	IRQ_PMS_DMA_TX_I_ILG = 82

	// SPI (Serial Peripheral Interface) Controller 0
	IRQ_SPI0_REJECT_CACHE = 83

	// SPI (Serial Peripheral Interface) Controller 4
	IRQ_SPI4_DMA = 85

	// SPI (Serial Peripheral Interface) Controller 4
	IRQ_SPI4 = 86

	// Interrupt Controller (Core 0)
	IRQ_ICACHE_PRELOAD = 87

	// Interrupt Controller (Core 0)
	IRQ_DCACHE_PRELOAD = 88

	// SAR (Successive Approximation Register) Analog-to-Digital Converter
	IRQ_APB_ADC = 89

	// Interrupt Controller (Core 0)
	IRQ_CPU_PERI_ERR = 91

	// Interrupt Controller (Core 0)
	IRQ_APB_PERI_ERR = 92

	// Interrupt Controller (Core 0)
	IRQ_DCACHE_SYNC = 93

	// Interrupt Controller (Core 0)
	IRQ_ICACHE_SYNC = 94

	// Highest interrupt number on this device.
	IRQ_max = 94
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}
func HandleInterrupt(num int) {
	switch num {
	case IRQ_WIFI_MAC:
		callHandlers(IRQ_WIFI_MAC)
	case IRQ_WIFI_NMI:
		callHandlers(IRQ_WIFI_NMI)
	case IRQ_WIFI_PWR:
		callHandlers(IRQ_WIFI_PWR)
	case IRQ_WIFI_BB:
		callHandlers(IRQ_WIFI_BB)
	case IRQ_BT_MAC:
		callHandlers(IRQ_BT_MAC)
	case IRQ_BT_BB:
		callHandlers(IRQ_BT_BB)
	case IRQ_BT_BB_NMI:
		callHandlers(IRQ_BT_BB_NMI)
	case IRQ_RWBT:
		callHandlers(IRQ_RWBT)
	case IRQ_RWBLE:
		callHandlers(IRQ_RWBLE)
	case IRQ_RWBT_NMI:
		callHandlers(IRQ_RWBT_NMI)
	case IRQ_RWBLE_NMI:
		callHandlers(IRQ_RWBLE_NMI)
	case IRQ_SLC0:
		callHandlers(IRQ_SLC0)
	case IRQ_SLC1:
		callHandlers(IRQ_SLC1)
	case IRQ_UHCI0:
		callHandlers(IRQ_UHCI0)
	case IRQ_UHCI1:
		callHandlers(IRQ_UHCI1)
	case IRQ_TG0_T0_LEVEL:
		callHandlers(IRQ_TG0_T0_LEVEL)
	case IRQ_TG0_T1_LEVEL:
		callHandlers(IRQ_TG0_T1_LEVEL)
	case IRQ_TG0_WDT_LEVEL:
		callHandlers(IRQ_TG0_WDT_LEVEL)
	case IRQ_TG0_LACT_LEVEL:
		callHandlers(IRQ_TG0_LACT_LEVEL)
	case IRQ_TG1_T0_LEVEL:
		callHandlers(IRQ_TG1_T0_LEVEL)
	case IRQ_TG1_T1_LEVEL:
		callHandlers(IRQ_TG1_T1_LEVEL)
	case IRQ_TG1_WDT_LEVEL:
		callHandlers(IRQ_TG1_WDT_LEVEL)
	case IRQ_TG1_LACT_LEVEL:
		callHandlers(IRQ_TG1_LACT_LEVEL)
	case IRQ_GPIO:
		callHandlers(IRQ_GPIO)
	case IRQ_GPIO_NMI:
		callHandlers(IRQ_GPIO_NMI)
	case IRQ_GPIO_INTR_2:
		callHandlers(IRQ_GPIO_INTR_2)
	case IRQ_GPIO_NMI_2:
		callHandlers(IRQ_GPIO_NMI_2)
	case IRQ_DEDICATED_GPIO:
		callHandlers(IRQ_DEDICATED_GPIO)
	case IRQ_FROM_CPU_INTR0:
		callHandlers(IRQ_FROM_CPU_INTR0)
	case IRQ_FROM_CPU_INTR1:
		callHandlers(IRQ_FROM_CPU_INTR1)
	case IRQ_FROM_CPU_INTR2:
		callHandlers(IRQ_FROM_CPU_INTR2)
	case IRQ_FROM_CPU_INTR3:
		callHandlers(IRQ_FROM_CPU_INTR3)
	case IRQ_SPI1:
		callHandlers(IRQ_SPI1)
	case IRQ_SPI2:
		callHandlers(IRQ_SPI2)
	case IRQ_SPI3:
		callHandlers(IRQ_SPI3)
	case IRQ_I2S0:
		callHandlers(IRQ_I2S0)
	case IRQ_I2S1:
		callHandlers(IRQ_I2S1)
	case IRQ_UART0:
		callHandlers(IRQ_UART0)
	case IRQ_UART1:
		callHandlers(IRQ_UART1)
	case IRQ_UART2:
		callHandlers(IRQ_UART2)
	case IRQ_SDIO_HOST:
		callHandlers(IRQ_SDIO_HOST)
	case IRQ_LEDC:
		callHandlers(IRQ_LEDC)
	case IRQ_EFUSE:
		callHandlers(IRQ_EFUSE)
	case IRQ_TWAI0:
		callHandlers(IRQ_TWAI0)
	case IRQ_USB:
		callHandlers(IRQ_USB)
	case IRQ_RTC_CORE:
		callHandlers(IRQ_RTC_CORE)
	case IRQ_RMT:
		callHandlers(IRQ_RMT)
	case IRQ_PCNT:
		callHandlers(IRQ_PCNT)
	case IRQ_I2C_EXT0:
		callHandlers(IRQ_I2C_EXT0)
	case IRQ_I2C_EXT1:
		callHandlers(IRQ_I2C_EXT1)
	case IRQ_RSA:
		callHandlers(IRQ_RSA)
	case IRQ_SHA:
		callHandlers(IRQ_SHA)
	case IRQ_AES:
		callHandlers(IRQ_AES)
	case IRQ_SPI2_DMA:
		callHandlers(IRQ_SPI2_DMA)
	case IRQ_SPI3_DMA:
		callHandlers(IRQ_SPI3_DMA)
	case IRQ_WDT:
		callHandlers(IRQ_WDT)
	case IRQ_TIMER1:
		callHandlers(IRQ_TIMER1)
	case IRQ_TIMER2:
		callHandlers(IRQ_TIMER2)
	case IRQ_TG0_T0_EDGE:
		callHandlers(IRQ_TG0_T0_EDGE)
	case IRQ_TG0_T1_EDGE:
		callHandlers(IRQ_TG0_T1_EDGE)
	case IRQ_TG0_WDT_EDGE:
		callHandlers(IRQ_TG0_WDT_EDGE)
	case IRQ_TG0_LACT_EDGE:
		callHandlers(IRQ_TG0_LACT_EDGE)
	case IRQ_TG1_T0_EDGE:
		callHandlers(IRQ_TG1_T0_EDGE)
	case IRQ_TG1_T1_EDGE:
		callHandlers(IRQ_TG1_T1_EDGE)
	case IRQ_TG1_WDT_EDGE:
		callHandlers(IRQ_TG1_WDT_EDGE)
	case IRQ_TG1_LACT_EDGE:
		callHandlers(IRQ_TG1_LACT_EDGE)
	case IRQ_CACHE_IA:
		callHandlers(IRQ_CACHE_IA)
	case IRQ_SYSTIMER_TARGET0:
		callHandlers(IRQ_SYSTIMER_TARGET0)
	case IRQ_SYSTIMER_TARGET1:
		callHandlers(IRQ_SYSTIMER_TARGET1)
	case IRQ_SYSTIMER_TARGET2:
		callHandlers(IRQ_SYSTIMER_TARGET2)
	case IRQ_PMS_PRO_IRAM0_ILG:
		callHandlers(IRQ_PMS_PRO_IRAM0_ILG)
	case IRQ_PMS_PRO_DRAM0_ILG:
		callHandlers(IRQ_PMS_PRO_DRAM0_ILG)
	case IRQ_PMS_PRO_DPORT_ILG:
		callHandlers(IRQ_PMS_PRO_DPORT_ILG)
	case IRQ_PMS_PRO_AHB_ILG:
		callHandlers(IRQ_PMS_PRO_AHB_ILG)
	case IRQ_PMS_PRO_CACHE_ILG:
		callHandlers(IRQ_PMS_PRO_CACHE_ILG)
	case IRQ_PMS_DMA_APB_I_ILG:
		callHandlers(IRQ_PMS_DMA_APB_I_ILG)
	case IRQ_PMS_DMA_RX_I_ILG:
		callHandlers(IRQ_PMS_DMA_RX_I_ILG)
	case IRQ_PMS_DMA_TX_I_ILG:
		callHandlers(IRQ_PMS_DMA_TX_I_ILG)
	case IRQ_SPI0_REJECT_CACHE:
		callHandlers(IRQ_SPI0_REJECT_CACHE)
	case IRQ_SPI4_DMA:
		callHandlers(IRQ_SPI4_DMA)
	case IRQ_SPI4:
		callHandlers(IRQ_SPI4)
	case IRQ_ICACHE_PRELOAD:
		callHandlers(IRQ_ICACHE_PRELOAD)
	case IRQ_DCACHE_PRELOAD:
		callHandlers(IRQ_DCACHE_PRELOAD)
	case IRQ_APB_ADC:
		callHandlers(IRQ_APB_ADC)
	case IRQ_CPU_PERI_ERR:
		callHandlers(IRQ_CPU_PERI_ERR)
	case IRQ_APB_PERI_ERR:
		callHandlers(IRQ_APB_PERI_ERR)
	case IRQ_DCACHE_SYNC:
		callHandlers(IRQ_DCACHE_SYNC)
	case IRQ_ICACHE_SYNC:
		callHandlers(IRQ_ICACHE_SYNC)
	}
}

// Peripherals.
var (
	// AES (Advanced Encryption Standard) Accelerator
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x6003a000)))

	// SAR (Successive Approximation Register) Analog-to-Digital Converter
	APB_SARADC = (*APB_SARADC_Type)(unsafe.Pointer(uintptr(0x3f440000)))

	// BB Peripheral
	BB = (*BB_Type)(unsafe.Pointer(uintptr(0x3f41d000)))

	// DEDICATED_GPIO Peripheral
	DEDICATED_GPIO = (*DEDIC_GPIO_Type)(unsafe.Pointer(uintptr(0x3f4cf000)))

	// Digital Signature
	DS = (*DS_Type)(unsafe.Pointer(uintptr(0x6003d000)))

	// eFuse Controller
	EFUSE = (*EFUSE_Type)(unsafe.Pointer(uintptr(0x3f41a000)))

	// External Memory
	EXTMEM = (*EXTMEM_Type)(unsafe.Pointer(uintptr(0x61800000)))

	// General Purpose Input/Output
	GPIO = (*GPIO_Type)(unsafe.Pointer(uintptr(0x3f404000)))

	// Sigma-Delta Modulation
	GPIO_SD = (*GPIOSD_Type)(unsafe.Pointer(uintptr(0x3f404f00)))

	// HMAC (Hash-based Message Authentication Code) Accelerator
	HMAC = (*HMAC_Type)(unsafe.Pointer(uintptr(0x6003e000)))

	// I2C (Inter-Integrated Circuit) Controller 0
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x3f413000)))

	// I2S (Inter-IC Sound) Controller 0
	I2S0 = (*I2S_Type)(unsafe.Pointer(uintptr(0x3f40f000)))

	// Interrupt Controller (Core 0)
	INTERRUPT_CORE0 = (*INTERRUPT_CORE0_Type)(unsafe.Pointer(uintptr(0x3f4c2000)))

	// Input/Output Multiplexer
	IO_MUX = (*IO_MUX_Type)(unsafe.Pointer(uintptr(0x3f409000)))

	// LED Control PWM (Pulse Width Modulation)
	LEDC = (*LEDC_Type)(unsafe.Pointer(uintptr(0x3f419000)))

	// Pulse Count Controller
	PCNT = (*PCNT_Type)(unsafe.Pointer(uintptr(0x3f417000)))

	// Permissions Controller
	PMS = (*PMS_Type)(unsafe.Pointer(uintptr(0x3f4c1000)))

	// Remote Control
	RMT = (*RMT_Type)(unsafe.Pointer(uintptr(0x3f416000)))

	// Hardware Random Number Generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x60035000)))

	// RSA (Rivest Shamir Adleman) Accelerator
	RSA = (*RSA_Type)(unsafe.Pointer(uintptr(0x6003c000)))

	// Low-power Input/Output
	RTC_IO = (*RTCIO_Type)(unsafe.Pointer(uintptr(0x3f408400)))

	// Real-Time Clock Control
	RTC_CNTL = (*RTC_CNTL_Type)(unsafe.Pointer(uintptr(0x3f408000)))

	// Low-power I2C (Inter-Integrated Circuit) Controller
	RTC_I2C = (*RTC_I2C_Type)(unsafe.Pointer(uintptr(0x3f408c00)))

	// SENS Peripheral
	SENS = (*SENS_Type)(unsafe.Pointer(uintptr(0x3f408800)))

	// SHA (Secure Hash Algorithm) Accelerator
	SHA = (*SHA_Type)(unsafe.Pointer(uintptr(0x6003b000)))

	// SPI (Serial Peripheral Interface) Controller 0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x3f403000)))

	// SYSCON Peripheral
	SYSCON = (*SYSCON_Type)(unsafe.Pointer(uintptr(0x3f426000)))

	// System Configuration Registers
	SYSTEM = (*SYSTEM_Type)(unsafe.Pointer(uintptr(0x3f4c0000)))

	// System Timer
	SYSTIMER = (*SYSTIMER_Type)(unsafe.Pointer(uintptr(0x3f423000)))

	// Timer Group 0
	TIMG0 = (*TIMG_Type)(unsafe.Pointer(uintptr(0x3f41f000)))

	// Two-Wire Automotive Interface
	TWAI0 = (*TWAI_Type)(unsafe.Pointer(uintptr(0x3f42b000)))

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x3f400000)))

	// Universal Host Controller Interface 0
	UHCI0 = (*UHCI_Type)(unsafe.Pointer(uintptr(0x3f414000)))

	// USB OTG (On-The-Go)
	USB0 = (*USB_Type)(unsafe.Pointer(uintptr(0x60080000)))

	// USB_WRAP Peripheral
	USB_WRAP = (*USB_WRAP_Type)(unsafe.Pointer(uintptr(0x3f439000)))

	// XTS-AES-128 Flash Encryption
	XTS_AES = (*XTS_AES_Type)(unsafe.Pointer(uintptr(0x6003a100)))

	// I2C (Inter-Integrated Circuit) Controller 1
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x3f427000)))

	// SPI (Serial Peripheral Interface) Controller 1
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x3f402000)))

	// SPI (Serial Peripheral Interface) Controller 2
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x3f424000)))

	// SPI (Serial Peripheral Interface) Controller 3
	SPI3 = (*SPI_Type)(unsafe.Pointer(uintptr(0x3f425000)))

	// SPI (Serial Peripheral Interface) Controller 4
	SPI4 = (*SPI_Type)(unsafe.Pointer(uintptr(0x3f437000)))

	// Timer Group 1
	TIMG1 = (*TIMG_Type)(unsafe.Pointer(uintptr(0x3f420000)))

	// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0x3f410000)))
)

// AES (Advanced Encryption Standard) Accelerator
type AES_Type struct {
	KEY_0             volatile.Register32 // 0x0
	KEY_1             volatile.Register32 // 0x4
	KEY_2             volatile.Register32 // 0x8
	KEY_3             volatile.Register32 // 0xC
	KEY_4             volatile.Register32 // 0x10
	KEY_5             volatile.Register32 // 0x14
	KEY_6             volatile.Register32 // 0x18
	KEY_7             volatile.Register32 // 0x1C
	TEXT_IN_0         volatile.Register32 // 0x20
	TEXT_IN_1         volatile.Register32 // 0x24
	TEXT_IN_2         volatile.Register32 // 0x28
	TEXT_IN_3         volatile.Register32 // 0x2C
	TEXT_OUT_0        volatile.Register32 // 0x30
	TEXT_OUT_1        volatile.Register32 // 0x34
	TEXT_OUT_2        volatile.Register32 // 0x38
	TEXT_OUT_3        volatile.Register32 // 0x3C
	MODE              volatile.Register32 // 0x40
	ENDIAN            volatile.Register32 // 0x44
	TRIGGER           volatile.Register32 // 0x48
	STATE             volatile.Register32 // 0x4C
	IV_0              volatile.Register32 // 0x50
	IV_1              volatile.Register32 // 0x54
	IV_2              volatile.Register32 // 0x58
	IV_3              volatile.Register32 // 0x5C
	H_0               volatile.Register32 // 0x60
	H_1               volatile.Register32 // 0x64
	H_2               volatile.Register32 // 0x68
	H_3               volatile.Register32 // 0x6C
	J0_0              volatile.Register32 // 0x70
	J0_1              volatile.Register32 // 0x74
	J0_2              volatile.Register32 // 0x78
	J0_3              volatile.Register32 // 0x7C
	T0_0              volatile.Register32 // 0x80
	T0_1              volatile.Register32 // 0x84
	T0_2              volatile.Register32 // 0x88
	T0_3              volatile.Register32 // 0x8C
	DMA_ENABLE        volatile.Register32 // 0x90
	BLOCK_MODE        volatile.Register32 // 0x94
	BLOCK_NUM         volatile.Register32 // 0x98
	INC_SEL           volatile.Register32 // 0x9C
	AAD_BLOCK_NUM     volatile.Register32 // 0xA0
	REMAINDER_BIT_NUM volatile.Register32 // 0xA4
	CONTINUE_OP       volatile.Register32 // 0xA8
	INT_CLR           volatile.Register32 // 0xAC
	INT_ENA           volatile.Register32 // 0xB0
	DATE              volatile.Register32 // 0xB4
	DMA_EXIT          volatile.Register32 // 0xB8
}

// AES.KEY_0: AES key register %s
func (o *AES_Type) SetKEY_0(value uint32) {
	volatile.StoreUint32(&o.KEY_0.Reg, value)
}
func (o *AES_Type) GetKEY_0() uint32 {
	return volatile.LoadUint32(&o.KEY_0.Reg)
}

// AES.KEY_1: AES key register %s
func (o *AES_Type) SetKEY_1(value uint32) {
	volatile.StoreUint32(&o.KEY_1.Reg, value)
}
func (o *AES_Type) GetKEY_1() uint32 {
	return volatile.LoadUint32(&o.KEY_1.Reg)
}

// AES.KEY_2: AES key register %s
func (o *AES_Type) SetKEY_2(value uint32) {
	volatile.StoreUint32(&o.KEY_2.Reg, value)
}
func (o *AES_Type) GetKEY_2() uint32 {
	return volatile.LoadUint32(&o.KEY_2.Reg)
}

// AES.KEY_3: AES key register %s
func (o *AES_Type) SetKEY_3(value uint32) {
	volatile.StoreUint32(&o.KEY_3.Reg, value)
}
func (o *AES_Type) GetKEY_3() uint32 {
	return volatile.LoadUint32(&o.KEY_3.Reg)
}

// AES.KEY_4: AES key register %s
func (o *AES_Type) SetKEY_4(value uint32) {
	volatile.StoreUint32(&o.KEY_4.Reg, value)
}
func (o *AES_Type) GetKEY_4() uint32 {
	return volatile.LoadUint32(&o.KEY_4.Reg)
}

// AES.KEY_5: AES key register %s
func (o *AES_Type) SetKEY_5(value uint32) {
	volatile.StoreUint32(&o.KEY_5.Reg, value)
}
func (o *AES_Type) GetKEY_5() uint32 {
	return volatile.LoadUint32(&o.KEY_5.Reg)
}

// AES.KEY_6: AES key register %s
func (o *AES_Type) SetKEY_6(value uint32) {
	volatile.StoreUint32(&o.KEY_6.Reg, value)
}
func (o *AES_Type) GetKEY_6() uint32 {
	return volatile.LoadUint32(&o.KEY_6.Reg)
}

// AES.KEY_7: AES key register %s
func (o *AES_Type) SetKEY_7(value uint32) {
	volatile.StoreUint32(&o.KEY_7.Reg, value)
}
func (o *AES_Type) GetKEY_7() uint32 {
	return volatile.LoadUint32(&o.KEY_7.Reg)
}

// AES.TEXT_IN_0: Source data register %s
func (o *AES_Type) SetTEXT_IN_0(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_0.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_0() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_0.Reg)
}

// AES.TEXT_IN_1: Source data register %s
func (o *AES_Type) SetTEXT_IN_1(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_1.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_1() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_1.Reg)
}

// AES.TEXT_IN_2: Source data register %s
func (o *AES_Type) SetTEXT_IN_2(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_2.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_2() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_2.Reg)
}

// AES.TEXT_IN_3: Source data register %s
func (o *AES_Type) SetTEXT_IN_3(value uint32) {
	volatile.StoreUint32(&o.TEXT_IN_3.Reg, value)
}
func (o *AES_Type) GetTEXT_IN_3() uint32 {
	return volatile.LoadUint32(&o.TEXT_IN_3.Reg)
}

// AES.TEXT_OUT_0: Result data register %s
func (o *AES_Type) SetTEXT_OUT_0(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_0.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_0() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_0.Reg)
}

// AES.TEXT_OUT_1: Result data register %s
func (o *AES_Type) SetTEXT_OUT_1(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_1.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_1() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_1.Reg)
}

// AES.TEXT_OUT_2: Result data register %s
func (o *AES_Type) SetTEXT_OUT_2(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_2.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_2() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_2.Reg)
}

// AES.TEXT_OUT_3: Result data register %s
func (o *AES_Type) SetTEXT_OUT_3(value uint32) {
	volatile.StoreUint32(&o.TEXT_OUT_3.Reg, value)
}
func (o *AES_Type) GetTEXT_OUT_3() uint32 {
	return volatile.LoadUint32(&o.TEXT_OUT_3.Reg)
}

// AES.MODE: AES working mode configuration register
func (o *AES_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7)|value)
}
func (o *AES_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7
}

// AES.ENDIAN: Endian configuration register
func (o *AES_Type) SetENDIAN(value uint32) {
	volatile.StoreUint32(&o.ENDIAN.Reg, volatile.LoadUint32(&o.ENDIAN.Reg)&^(0x3f)|value)
}
func (o *AES_Type) GetENDIAN() uint32 {
	return volatile.LoadUint32(&o.ENDIAN.Reg) & 0x3f
}

// AES.TRIGGER: Operation start controlling register
func (o *AES_Type) SetTRIGGER(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetTRIGGER() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}

// AES.STATE: Operation status register
func (o *AES_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x3)|value)
}
func (o *AES_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x3
}

// AES.IV_0: initialization vector
func (o *AES_Type) SetIV_0(value uint32) {
	volatile.StoreUint32(&o.IV_0.Reg, value)
}
func (o *AES_Type) GetIV_0() uint32 {
	return volatile.LoadUint32(&o.IV_0.Reg)
}

// AES.IV_1: initialization vector
func (o *AES_Type) SetIV_1(value uint32) {
	volatile.StoreUint32(&o.IV_1.Reg, value)
}
func (o *AES_Type) GetIV_1() uint32 {
	return volatile.LoadUint32(&o.IV_1.Reg)
}

// AES.IV_2: initialization vector
func (o *AES_Type) SetIV_2(value uint32) {
	volatile.StoreUint32(&o.IV_2.Reg, value)
}
func (o *AES_Type) GetIV_2() uint32 {
	return volatile.LoadUint32(&o.IV_2.Reg)
}

// AES.IV_3: initialization vector
func (o *AES_Type) SetIV_3(value uint32) {
	volatile.StoreUint32(&o.IV_3.Reg, value)
}
func (o *AES_Type) GetIV_3() uint32 {
	return volatile.LoadUint32(&o.IV_3.Reg)
}

// AES.H_0: GCM hash subkey
func (o *AES_Type) SetH_0(value uint32) {
	volatile.StoreUint32(&o.H_0.Reg, value)
}
func (o *AES_Type) GetH_0() uint32 {
	return volatile.LoadUint32(&o.H_0.Reg)
}

// AES.H_1: GCM hash subkey
func (o *AES_Type) SetH_1(value uint32) {
	volatile.StoreUint32(&o.H_1.Reg, value)
}
func (o *AES_Type) GetH_1() uint32 {
	return volatile.LoadUint32(&o.H_1.Reg)
}

// AES.H_2: GCM hash subkey
func (o *AES_Type) SetH_2(value uint32) {
	volatile.StoreUint32(&o.H_2.Reg, value)
}
func (o *AES_Type) GetH_2() uint32 {
	return volatile.LoadUint32(&o.H_2.Reg)
}

// AES.H_3: GCM hash subkey
func (o *AES_Type) SetH_3(value uint32) {
	volatile.StoreUint32(&o.H_3.Reg, value)
}
func (o *AES_Type) GetH_3() uint32 {
	return volatile.LoadUint32(&o.H_3.Reg)
}

// AES.J0_0: J0
func (o *AES_Type) SetJ0_0(value uint32) {
	volatile.StoreUint32(&o.J0_0.Reg, value)
}
func (o *AES_Type) GetJ0_0() uint32 {
	return volatile.LoadUint32(&o.J0_0.Reg)
}

// AES.J0_1: J0
func (o *AES_Type) SetJ0_1(value uint32) {
	volatile.StoreUint32(&o.J0_1.Reg, value)
}
func (o *AES_Type) GetJ0_1() uint32 {
	return volatile.LoadUint32(&o.J0_1.Reg)
}

// AES.J0_2: J0
func (o *AES_Type) SetJ0_2(value uint32) {
	volatile.StoreUint32(&o.J0_2.Reg, value)
}
func (o *AES_Type) GetJ0_2() uint32 {
	return volatile.LoadUint32(&o.J0_2.Reg)
}

// AES.J0_3: J0
func (o *AES_Type) SetJ0_3(value uint32) {
	volatile.StoreUint32(&o.J0_3.Reg, value)
}
func (o *AES_Type) GetJ0_3() uint32 {
	return volatile.LoadUint32(&o.J0_3.Reg)
}

// AES.T0_0: T0
func (o *AES_Type) SetT0_0(value uint32) {
	volatile.StoreUint32(&o.T0_0.Reg, value)
}
func (o *AES_Type) GetT0_0() uint32 {
	return volatile.LoadUint32(&o.T0_0.Reg)
}

// AES.T0_1: T0
func (o *AES_Type) SetT0_1(value uint32) {
	volatile.StoreUint32(&o.T0_1.Reg, value)
}
func (o *AES_Type) GetT0_1() uint32 {
	return volatile.LoadUint32(&o.T0_1.Reg)
}

// AES.T0_2: T0
func (o *AES_Type) SetT0_2(value uint32) {
	volatile.StoreUint32(&o.T0_2.Reg, value)
}
func (o *AES_Type) GetT0_2() uint32 {
	return volatile.LoadUint32(&o.T0_2.Reg)
}

// AES.T0_3: T0
func (o *AES_Type) SetT0_3(value uint32) {
	volatile.StoreUint32(&o.T0_3.Reg, value)
}
func (o *AES_Type) GetT0_3() uint32 {
	return volatile.LoadUint32(&o.T0_3.Reg)
}

// AES.DMA_ENABLE: DMA enable register
func (o *AES_Type) SetDMA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_ENABLE.Reg, volatile.LoadUint32(&o.DMA_ENABLE.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDMA_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA_ENABLE.Reg) & 0x1
}

// AES.BLOCK_MODE: Block operation type register
func (o *AES_Type) SetBLOCK_MODE(value uint32) {
	volatile.StoreUint32(&o.BLOCK_MODE.Reg, volatile.LoadUint32(&o.BLOCK_MODE.Reg)&^(0x7)|value)
}
func (o *AES_Type) GetBLOCK_MODE() uint32 {
	return volatile.LoadUint32(&o.BLOCK_MODE.Reg) & 0x7
}

// AES.BLOCK_NUM: Block number configuration register
func (o *AES_Type) SetBLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.BLOCK_NUM.Reg, value)
}
func (o *AES_Type) GetBLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.BLOCK_NUM.Reg)
}

// AES.INC_SEL: Standard incrementing function register
func (o *AES_Type) SetINC_SEL(value uint32) {
	volatile.StoreUint32(&o.INC_SEL.Reg, volatile.LoadUint32(&o.INC_SEL.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINC_SEL() uint32 {
	return volatile.LoadUint32(&o.INC_SEL.Reg) & 0x1
}

// AES.AAD_BLOCK_NUM: AAD block number configuration register
func (o *AES_Type) SetAAD_BLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.AAD_BLOCK_NUM.Reg, value)
}
func (o *AES_Type) GetAAD_BLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.AAD_BLOCK_NUM.Reg)
}

// AES.REMAINDER_BIT_NUM: Remainder bit number of plaintext/ciphertext
func (o *AES_Type) SetREMAINDER_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.REMAINDER_BIT_NUM.Reg, volatile.LoadUint32(&o.REMAINDER_BIT_NUM.Reg)&^(0x7f)|value)
}
func (o *AES_Type) GetREMAINDER_BIT_NUM() uint32 {
	return volatile.LoadUint32(&o.REMAINDER_BIT_NUM.Reg) & 0x7f
}

// AES.CONTINUE_OP: Operation continue controlling register
func (o *AES_Type) SetCONTINUE_OP(value uint32) {
	volatile.StoreUint32(&o.CONTINUE_OP.Reg, volatile.LoadUint32(&o.CONTINUE_OP.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCONTINUE_OP() uint32 {
	return volatile.LoadUint32(&o.CONTINUE_OP.Reg) & 0x1
}

// AES.INT_CLR: DMA-AES interrupt clear register
func (o *AES_Type) SetINT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}

// AES.INT_ENA: DMA-AES interrupt enable register
func (o *AES_Type) SetINT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// AES.DATE: Version control register
func (o *AES_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *AES_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// AES.DMA_EXIT: Operation exit controlling register
func (o *AES_Type) SetDMA_EXIT(value uint32) {
	volatile.StoreUint32(&o.DMA_EXIT.Reg, volatile.LoadUint32(&o.DMA_EXIT.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDMA_EXIT() uint32 {
	return volatile.LoadUint32(&o.DMA_EXIT.Reg) & 0x1
}

// SAR (Successive Approximation Register) Analog-to-Digital Converter
type APB_SARADC_Type struct {
	CTRL           volatile.Register32 // 0x0
	CTRL2          volatile.Register32 // 0x4
	FSM            volatile.Register32 // 0x8
	FSM_WAIT       volatile.Register32 // 0xC
	SAR1_STATUS    volatile.Register32 // 0x10
	SAR2_STATUS    volatile.Register32 // 0x14
	SAR1_PATT_TAB1 volatile.Register32 // 0x18
	SAR1_PATT_TAB2 volatile.Register32 // 0x1C
	SAR1_PATT_TAB3 volatile.Register32 // 0x20
	SAR1_PATT_TAB4 volatile.Register32 // 0x24
	SAR2_PATT_TAB1 volatile.Register32 // 0x28
	SAR2_PATT_TAB2 volatile.Register32 // 0x2C
	SAR2_PATT_TAB3 volatile.Register32 // 0x30
	SAR2_PATT_TAB4 volatile.Register32 // 0x34
	ARB_CTRL       volatile.Register32 // 0x38
	FILTER_CTRL    volatile.Register32 // 0x3C
	FILTER_STATUS  volatile.Register32 // 0x40
	THRES_CTRL     volatile.Register32 // 0x44
	INT_ENA        volatile.Register32 // 0x48
	INT_RAW        volatile.Register32 // 0x4C
	INT_ST         volatile.Register32 // 0x50
	INT_CLR        volatile.Register32 // 0x54
	DMA_CONF       volatile.Register32 // 0x58
	CLKM_CONF      volatile.Register32 // 0x5C
	APB_DAC_CTRL   volatile.Register32 // 0x60
	_              [920]byte
	APB_CTRL_DATE  volatile.Register32 // 0x3FC
}

// APB_SARADC.CTRL: DIG ADC common configuration
func (o *APB_SARADC_Type) SetCTRL_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetCTRL_START_FORCE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetCTRL_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *APB_SARADC_Type) GetCTRL_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *APB_SARADC_Type) SetCTRL_WORK_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x18)|value<<3)
}
func (o *APB_SARADC_Type) GetCTRL_WORK_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x18) >> 3
}
func (o *APB_SARADC_Type) SetCTRL_SAR_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *APB_SARADC_Type) GetCTRL_SAR_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *APB_SARADC_Type) SetCTRL_SAR_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *APB_SARADC_Type) GetCTRL_SAR_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *APB_SARADC_Type) SetCTRL_SAR_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f80)|value<<7)
}
func (o *APB_SARADC_Type) GetCTRL_SAR_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x7f80) >> 7
}
func (o *APB_SARADC_Type) SetCTRL_SAR1_PATT_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x78000)|value<<15)
}
func (o *APB_SARADC_Type) GetCTRL_SAR1_PATT_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x78000) >> 15
}
func (o *APB_SARADC_Type) SetCTRL_SAR2_PATT_LEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x780000)|value<<19)
}
func (o *APB_SARADC_Type) GetCTRL_SAR2_PATT_LEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x780000) >> 19
}
func (o *APB_SARADC_Type) SetCTRL_SAR1_PATT_P_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *APB_SARADC_Type) GetCTRL_SAR1_PATT_P_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *APB_SARADC_Type) SetCTRL_SAR2_PATT_P_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *APB_SARADC_Type) GetCTRL_SAR2_PATT_P_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *APB_SARADC_Type) SetCTRL_DATA_SAR_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *APB_SARADC_Type) GetCTRL_DATA_SAR_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *APB_SARADC_Type) SetCTRL_DATA_TO_I2S(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *APB_SARADC_Type) GetCTRL_DATA_TO_I2S() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *APB_SARADC_Type) SetCTRL_XPD_SAR_FORCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x18000000)|value<<27)
}
func (o *APB_SARADC_Type) GetCTRL_XPD_SAR_FORCE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x18000000) >> 27
}
func (o *APB_SARADC_Type) SetCTRL_WAIT_ARB_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0000000)|value<<30)
}
func (o *APB_SARADC_Type) GetCTRL_WAIT_ARB_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0000000) >> 30
}

// APB_SARADC.CTRL2: DIG ADC common configuration
func (o *APB_SARADC_Type) SetCTRL2_MEAS_NUM_LIMIT(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetCTRL2_MEAS_NUM_LIMIT() uint32 {
	return volatile.LoadUint32(&o.CTRL2.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetCTRL2_MAX_MEAS_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1fe)|value<<1)
}
func (o *APB_SARADC_Type) GetCTRL2_MAX_MEAS_NUM() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1fe) >> 1
}
func (o *APB_SARADC_Type) SetCTRL2_SAR1_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x200)|value<<9)
}
func (o *APB_SARADC_Type) GetCTRL2_SAR1_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x200) >> 9
}
func (o *APB_SARADC_Type) SetCTRL2_SAR2_INV(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *APB_SARADC_Type) GetCTRL2_SAR2_INV() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x400) >> 10
}
func (o *APB_SARADC_Type) SetCTRL2_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *APB_SARADC_Type) GetCTRL2_TIMER_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x800) >> 11
}
func (o *APB_SARADC_Type) SetCTRL2_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0xfff000)|value<<12)
}
func (o *APB_SARADC_Type) GetCTRL2_TIMER_TARGET() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0xfff000) >> 12
}
func (o *APB_SARADC_Type) SetCTRL2_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1000000)|value<<24)
}
func (o *APB_SARADC_Type) GetCTRL2_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1000000) >> 24
}

// APB_SARADC.FSM: digital adc control register
func (o *APB_SARADC_Type) SetFSM_SAMPLE_NUM(value uint32) {
	volatile.StoreUint32(&o.FSM.Reg, volatile.LoadUint32(&o.FSM.Reg)&^(0xff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFSM_SAMPLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.FSM.Reg) & 0xff0000) >> 16
}
func (o *APB_SARADC_Type) SetFSM_SAMPLE_CYCLE(value uint32) {
	volatile.StoreUint32(&o.FSM.Reg, volatile.LoadUint32(&o.FSM.Reg)&^(0xff000000)|value<<24)
}
func (o *APB_SARADC_Type) GetFSM_SAMPLE_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.FSM.Reg) & 0xff000000) >> 24
}

// APB_SARADC.FSM_WAIT: configure saradc fsm internal parameter base on test
func (o *APB_SARADC_Type) SetFSM_WAIT_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_XPD_WAIT() uint32 {
	return volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetFSM_WAIT_RSTB_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff00)|value<<8)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_RSTB_WAIT() uint32 {
	return (volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff00) >> 8
}
func (o *APB_SARADC_Type) SetFSM_WAIT_STANDBY_WAIT(value uint32) {
	volatile.StoreUint32(&o.FSM_WAIT.Reg, volatile.LoadUint32(&o.FSM_WAIT.Reg)&^(0xff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFSM_WAIT_STANDBY_WAIT() uint32 {
	return (volatile.LoadUint32(&o.FSM_WAIT.Reg) & 0xff0000) >> 16
}

// APB_SARADC.SAR1_STATUS: digital adc1 status
func (o *APB_SARADC_Type) SetSAR1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR1_STATUS.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR1_STATUS.Reg)
}

// APB_SARADC.SAR2_STATUS: digital adc2 status
func (o *APB_SARADC_Type) SetSAR2_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR2_STATUS.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR2_STATUS.Reg)
}

// APB_SARADC.SAR1_PATT_TAB1: item 0 ~ 3 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB1(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB1.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB1() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB1.Reg)
}

// APB_SARADC.SAR1_PATT_TAB2: Item 4 ~ 7 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB2(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB2.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB2() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB2.Reg)
}

// APB_SARADC.SAR1_PATT_TAB3: Item 8 ~ 11 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB3(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB3.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB3() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB3.Reg)
}

// APB_SARADC.SAR1_PATT_TAB4: Item 12 ~ 15 for pattern table 1 (each item one byte)
func (o *APB_SARADC_Type) SetSAR1_PATT_TAB4(value uint32) {
	volatile.StoreUint32(&o.SAR1_PATT_TAB4.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR1_PATT_TAB4() uint32 {
	return volatile.LoadUint32(&o.SAR1_PATT_TAB4.Reg)
}

// APB_SARADC.SAR2_PATT_TAB1: item 0 ~ 3 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB1(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB1.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB1() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB1.Reg)
}

// APB_SARADC.SAR2_PATT_TAB2: Item 4 ~ 7 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB2(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB2.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB2() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB2.Reg)
}

// APB_SARADC.SAR2_PATT_TAB3: Item 8 ~ 11 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB3(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB3.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB3() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB3.Reg)
}

// APB_SARADC.SAR2_PATT_TAB4: Item 12 ~ 15 for pattern table 2 (each item one byte)
func (o *APB_SARADC_Type) SetSAR2_PATT_TAB4(value uint32) {
	volatile.StoreUint32(&o.SAR2_PATT_TAB4.Reg, value)
}
func (o *APB_SARADC_Type) GetSAR2_PATT_TAB4() uint32 {
	return volatile.LoadUint32(&o.SAR2_PATT_TAB4.Reg)
}

// APB_SARADC.ARB_CTRL: Configure the settings of DIG ADC2 arbiter
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_APB_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_APB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x4) >> 2
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_RTC_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_RTC_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x8) >> 3
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_WIFI_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_WIFI_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x10) >> 4
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_GRANT_FORCE(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_GRANT_FORCE() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x20) >> 5
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_APB_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0xc0)|value<<6)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_APB_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0xc0) >> 6
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_RTC_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_RTC_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x300) >> 8
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_WIFI_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_WIFI_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0xc00) >> 10
}
func (o *APB_SARADC_Type) SetARB_CTRL_ADC_ARB_FIX_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.ARB_CTRL.Reg, volatile.LoadUint32(&o.ARB_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *APB_SARADC_Type) GetARB_CTRL_ADC_ARB_FIX_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.ARB_CTRL.Reg) & 0x1000) >> 12
}

// APB_SARADC.FILTER_CTRL: Configure the settings of DIG ADC2 filter
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC2_FILTER_RESET(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC2_FILTER_RESET() uint32 {
	return volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC1_FILTER_RESET(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC1_FILTER_RESET() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x2) >> 1
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC2_FILTER_FACTOR(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x7f0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC2_FILTER_FACTOR() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x7f0000) >> 16
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC1_FILTER_FACTOR(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x3f800000)|value<<23)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC1_FILTER_FACTOR() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x3f800000) >> 23
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC2_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC2_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetFILTER_CTRL_ADC1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.FILTER_CTRL.Reg, volatile.LoadUint32(&o.FILTER_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetFILTER_CTRL_ADC1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.FILTER_CTRL.Reg) & 0x80000000) >> 31
}

// APB_SARADC.FILTER_STATUS: Data status of DIG ADC2 filter
func (o *APB_SARADC_Type) SetFILTER_STATUS_ADC2_FILTER_DATA(value uint32) {
	volatile.StoreUint32(&o.FILTER_STATUS.Reg, volatile.LoadUint32(&o.FILTER_STATUS.Reg)&^(0xffff)|value)
}
func (o *APB_SARADC_Type) GetFILTER_STATUS_ADC2_FILTER_DATA() uint32 {
	return volatile.LoadUint32(&o.FILTER_STATUS.Reg) & 0xffff
}
func (o *APB_SARADC_Type) SetFILTER_STATUS_ADC1_FILTER_DATA(value uint32) {
	volatile.StoreUint32(&o.FILTER_STATUS.Reg, volatile.LoadUint32(&o.FILTER_STATUS.Reg)&^(0xffff0000)|value<<16)
}
func (o *APB_SARADC_Type) GetFILTER_STATUS_ADC1_FILTER_DATA() uint32 {
	return (volatile.LoadUint32(&o.FILTER_STATUS.Reg) & 0xffff0000) >> 16
}

// APB_SARADC.THRES_CTRL: Configure monitor threshold for DIG ADC2
func (o *APB_SARADC_Type) SetTHRES_CTRL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x1)|value)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x1
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC2_THRES_MODE(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC2_THRES_MODE() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x4) >> 2
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC1_THRES_MODE(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC1_THRES_MODE() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x8) >> 3
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC2_THRES(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x1fff0)|value<<4)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC2_THRES() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x1fff0) >> 4
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC1_THRES(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x3ffe0000)|value<<17)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC1_THRES() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x3ffe0000) >> 17
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC2_THRES_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC2_THRES_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetTHRES_CTRL_ADC1_THRES_EN(value uint32) {
	volatile.StoreUint32(&o.THRES_CTRL.Reg, volatile.LoadUint32(&o.THRES_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetTHRES_CTRL_ADC1_THRES_EN() uint32 {
	return (volatile.LoadUint32(&o.THRES_CTRL.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_ENA: Enable DIG ADC interrupts
func (o *APB_SARADC_Type) SetINT_ENA_ADC2_THRES_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC2_THRES_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_ENA_ADC1_THRES_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC1_THRES_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_ENA_ADC2_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC2_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_ENA_ADC1_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_ENA_ADC1_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_RAW: DIG ADC interrupt raw bits
func (o *APB_SARADC_Type) SetINT_RAW_ADC2_THRES_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC2_THRES_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_RAW_ADC1_THRES_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC1_THRES_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_RAW_ADC2_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC2_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_RAW_ADC1_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_RAW_ADC1_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_ST: DIG ADC interrupt status
func (o *APB_SARADC_Type) SetINT_ST_ADC2_THRES_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC2_THRES_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_ST_ADC1_THRES_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC1_THRES_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_ST_ADC2_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC2_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_ST_ADC1_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_ST_ADC1_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000000) >> 31
}

// APB_SARADC.INT_CLR: Clear DIG ADC interrupts
func (o *APB_SARADC_Type) SetINT_CLR_ADC2_THRES_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC2_THRES_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000000) >> 28
}
func (o *APB_SARADC_Type) SetINT_CLR_ADC1_THRES_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC1_THRES_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000000) >> 29
}
func (o *APB_SARADC_Type) SetINT_CLR_ADC2_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC2_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetINT_CLR_ADC1_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetINT_CLR_ADC1_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000000) >> 31
}

// APB_SARADC.DMA_CONF: Configure digital ADC DMA path
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_EOF_NUM(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0xffff)|value)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_EOF_NUM() uint32 {
	return volatile.LoadUint32(&o.DMA_CONF.Reg) & 0xffff
}
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_RESET_FSM(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_RESET_FSM() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40000000) >> 30
}
func (o *APB_SARADC_Type) SetDMA_CONF_APB_ADC_TRANS(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *APB_SARADC_Type) GetDMA_CONF_APB_ADC_TRANS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80000000) >> 31
}

// APB_SARADC.CLKM_CONF: Configure DIG ADC clock
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xff
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_B(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x3f00)|value<<8)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x3f00) >> 8
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLKM_DIV_A(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLKM_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xfc000) >> 14
}
func (o *APB_SARADC_Type) SetCLKM_CONF_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x600000)|value<<21)
}
func (o *APB_SARADC_Type) GetCLKM_CONF_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x600000) >> 21
}

// APB_SARADC.APB_DAC_CTRL: Configure DAC settings
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_DAC_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0xfff)|value)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_DAC_TIMER_TARGET() uint32 {
	return volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0xfff
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_DAC_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_DAC_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x1000) >> 12
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_APB_DAC_ALTER_MODE(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_APB_DAC_ALTER_MODE() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x2000) >> 13
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_APB_DAC_TRANS(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_APB_DAC_TRANS() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x4000) >> 14
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_DAC_RESET_FIFO(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_DAC_RESET_FIFO() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x8000) >> 15
}
func (o *APB_SARADC_Type) SetAPB_DAC_CTRL_APB_DAC_RST(value uint32) {
	volatile.StoreUint32(&o.APB_DAC_CTRL.Reg, volatile.LoadUint32(&o.APB_DAC_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *APB_SARADC_Type) GetAPB_DAC_CTRL_APB_DAC_RST() uint32 {
	return (volatile.LoadUint32(&o.APB_DAC_CTRL.Reg) & 0x10000) >> 16
}

// APB_SARADC.APB_CTRL_DATE: Version control register
func (o *APB_SARADC_Type) SetAPB_CTRL_DATE(value uint32) {
	volatile.StoreUint32(&o.APB_CTRL_DATE.Reg, value)
}
func (o *APB_SARADC_Type) GetAPB_CTRL_DATE() uint32 {
	return volatile.LoadUint32(&o.APB_CTRL_DATE.Reg)
}

// BB Peripheral
type BB_Type struct {
	_         [84]byte
	BBPD_CTRL volatile.Register32 // 0x54
}

// BB.BBPD_CTRL: Baseband control register
func (o *BB_Type) SetBBPD_CTRL_DC_EST_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.BBPD_CTRL.Reg, volatile.LoadUint32(&o.BBPD_CTRL.Reg)&^(0x1)|value)
}
func (o *BB_Type) GetBBPD_CTRL_DC_EST_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.BBPD_CTRL.Reg) & 0x1
}
func (o *BB_Type) SetBBPD_CTRL_DC_EST_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.BBPD_CTRL.Reg, volatile.LoadUint32(&o.BBPD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *BB_Type) GetBBPD_CTRL_DC_EST_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.BBPD_CTRL.Reg) & 0x2) >> 1
}
func (o *BB_Type) SetBBPD_CTRL_FFT_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.BBPD_CTRL.Reg, volatile.LoadUint32(&o.BBPD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *BB_Type) GetBBPD_CTRL_FFT_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.BBPD_CTRL.Reg) & 0x4) >> 2
}
func (o *BB_Type) SetBBPD_CTRL_FFT_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.BBPD_CTRL.Reg, volatile.LoadUint32(&o.BBPD_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *BB_Type) GetBBPD_CTRL_FFT_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.BBPD_CTRL.Reg) & 0x8) >> 3
}

// DEDICATED_GPIO Peripheral
type DEDIC_GPIO_Type struct {
	OUT_DRT   volatile.Register32 // 0x0
	OUT_MSK   volatile.Register32 // 0x4
	OUT_IDV   volatile.Register32 // 0x8
	OUT_SCAN  volatile.Register32 // 0xC
	OUT_CPU   volatile.Register32 // 0x10
	IN_DLY    volatile.Register32 // 0x14
	IN_SCAN   volatile.Register32 // 0x18
	INTR_RCGN volatile.Register32 // 0x1C
	INTR_RAW  volatile.Register32 // 0x20
	INTR_RLS  volatile.Register32 // 0x24
	INTR_ST   volatile.Register32 // 0x28
	INTR_CLR  volatile.Register32 // 0x2C
}

// DEDIC_GPIO.OUT_DRT: Dedicated GPIO directive output register
func (o *DEDIC_GPIO_Type) SetOUT_DRT_VLAUE(value uint32) {
	volatile.StoreUint32(&o.OUT_DRT.Reg, volatile.LoadUint32(&o.OUT_DRT.Reg)&^(0xff)|value)
}
func (o *DEDIC_GPIO_Type) GetOUT_DRT_VLAUE() uint32 {
	return volatile.LoadUint32(&o.OUT_DRT.Reg) & 0xff
}

// DEDIC_GPIO.OUT_MSK: Dedicated GPIO mask output register
func (o *DEDIC_GPIO_Type) SetOUT_MSK_OUT_VALUE(value uint32) {
	volatile.StoreUint32(&o.OUT_MSK.Reg, volatile.LoadUint32(&o.OUT_MSK.Reg)&^(0xff)|value)
}
func (o *DEDIC_GPIO_Type) GetOUT_MSK_OUT_VALUE() uint32 {
	return volatile.LoadUint32(&o.OUT_MSK.Reg) & 0xff
}
func (o *DEDIC_GPIO_Type) SetOUT_MSK(value uint32) {
	volatile.StoreUint32(&o.OUT_MSK.Reg, volatile.LoadUint32(&o.OUT_MSK.Reg)&^(0xff00)|value<<8)
}
func (o *DEDIC_GPIO_Type) GetOUT_MSK() uint32 {
	return (volatile.LoadUint32(&o.OUT_MSK.Reg) & 0xff00) >> 8
}

// DEDIC_GPIO.OUT_IDV: Dedicated GPIO individual output register
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH0(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x3)|value)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH0() uint32 {
	return volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x3
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH1(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH1() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc) >> 2
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH2(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x30)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH2() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x30) >> 4
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH3(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc0)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH3() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc0) >> 6
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH4(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x300)|value<<8)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH4() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x300) >> 8
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH5(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc00)|value<<10)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH5() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc00) >> 10
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH6(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0x3000)|value<<12)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH6() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0x3000) >> 12
}
func (o *DEDIC_GPIO_Type) SetOUT_IDV_CH7(value uint32) {
	volatile.StoreUint32(&o.OUT_IDV.Reg, volatile.LoadUint32(&o.OUT_IDV.Reg)&^(0xc000)|value<<14)
}
func (o *DEDIC_GPIO_Type) GetOUT_IDV_CH7() uint32 {
	return (volatile.LoadUint32(&o.OUT_IDV.Reg) & 0xc000) >> 14
}

// DEDIC_GPIO.OUT_SCAN: Dedicated GPIO output status register
func (o *DEDIC_GPIO_Type) SetOUT_SCAN_OUT_STATUS(value uint32) {
	volatile.StoreUint32(&o.OUT_SCAN.Reg, volatile.LoadUint32(&o.OUT_SCAN.Reg)&^(0xff)|value)
}
func (o *DEDIC_GPIO_Type) GetOUT_SCAN_OUT_STATUS() uint32 {
	return volatile.LoadUint32(&o.OUT_SCAN.Reg) & 0xff
}

// DEDIC_GPIO.OUT_CPU: Dedicated GPIO output mode selection register
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL0(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x1)|value)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL0() uint32 {
	return volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x1
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL1(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x2)|value<<1)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL1() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x2) >> 1
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL2(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x4)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL2() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x4) >> 2
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL3(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x8)|value<<3)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL3() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x8) >> 3
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL4(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x10)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL4() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x10) >> 4
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL5(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x20)|value<<5)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL5() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x20) >> 5
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL6(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x40)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL6() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x40) >> 6
}
func (o *DEDIC_GPIO_Type) SetOUT_CPU_SEL7(value uint32) {
	volatile.StoreUint32(&o.OUT_CPU.Reg, volatile.LoadUint32(&o.OUT_CPU.Reg)&^(0x80)|value<<7)
}
func (o *DEDIC_GPIO_Type) GetOUT_CPU_SEL7() uint32 {
	return (volatile.LoadUint32(&o.OUT_CPU.Reg) & 0x80) >> 7
}

// DEDIC_GPIO.IN_DLY: Dedicated GPIO input delay configuration register
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH0(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x3)|value)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH0() uint32 {
	return volatile.LoadUint32(&o.IN_DLY.Reg) & 0x3
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH1(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH1() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc) >> 2
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH2(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x30)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH2() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0x30) >> 4
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH3(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc0)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH3() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc0) >> 6
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH4(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x300)|value<<8)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH4() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0x300) >> 8
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH5(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc00)|value<<10)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH5() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc00) >> 10
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH6(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0x3000)|value<<12)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH6() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0x3000) >> 12
}
func (o *DEDIC_GPIO_Type) SetIN_DLY_CH7(value uint32) {
	volatile.StoreUint32(&o.IN_DLY.Reg, volatile.LoadUint32(&o.IN_DLY.Reg)&^(0xc000)|value<<14)
}
func (o *DEDIC_GPIO_Type) GetIN_DLY_CH7() uint32 {
	return (volatile.LoadUint32(&o.IN_DLY.Reg) & 0xc000) >> 14
}

// DEDIC_GPIO.IN_SCAN: Dedicated GPIO input status register
func (o *DEDIC_GPIO_Type) SetIN_SCAN_IN_STATUS(value uint32) {
	volatile.StoreUint32(&o.IN_SCAN.Reg, volatile.LoadUint32(&o.IN_SCAN.Reg)&^(0xff)|value)
}
func (o *DEDIC_GPIO_Type) GetIN_SCAN_IN_STATUS() uint32 {
	return volatile.LoadUint32(&o.IN_SCAN.Reg) & 0xff
}

// DEDIC_GPIO.INTR_RCGN: Dedicated GPIO interrupts generation mode register
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH0(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x7)|value)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH0() uint32 {
	return volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x7
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH1(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x38)|value<<3)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH1() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x38) >> 3
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH2(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x1c0)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH2() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x1c0) >> 6
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH3(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0xe00)|value<<9)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH3() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0xe00) >> 9
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH4(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x7000)|value<<12)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH4() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x7000) >> 12
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH5(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x38000)|value<<15)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH5() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x38000) >> 15
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH6(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0x1c0000)|value<<18)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH6() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0x1c0000) >> 18
}
func (o *DEDIC_GPIO_Type) SetINTR_RCGN_INTR_MODE_CH7(value uint32) {
	volatile.StoreUint32(&o.INTR_RCGN.Reg, volatile.LoadUint32(&o.INTR_RCGN.Reg)&^(0xe00000)|value<<21)
}
func (o *DEDIC_GPIO_Type) GetINTR_RCGN_INTR_MODE_CH7() uint32 {
	return (volatile.LoadUint32(&o.INTR_RCGN.Reg) & 0xe00000) >> 21
}

// DEDIC_GPIO.INTR_RAW: Raw interrupt status
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO0(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x1)|value)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO0() uint32 {
	return volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x1
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO1(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x2)|value<<1)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO1() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x2) >> 1
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO2(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x4)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO2() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x4) >> 2
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO3(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x8)|value<<3)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO3() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x8) >> 3
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO4(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x10)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO4() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x10) >> 4
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO5(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x20)|value<<5)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO5() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x20) >> 5
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO6(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x40)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO6() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x40) >> 6
}
func (o *DEDIC_GPIO_Type) SetINTR_RAW_GPIO7(value uint32) {
	volatile.StoreUint32(&o.INTR_RAW.Reg, volatile.LoadUint32(&o.INTR_RAW.Reg)&^(0x80)|value<<7)
}
func (o *DEDIC_GPIO_Type) GetINTR_RAW_GPIO7() uint32 {
	return (volatile.LoadUint32(&o.INTR_RAW.Reg) & 0x80) >> 7
}

// DEDIC_GPIO.INTR_RLS: Interrupt enable bits
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x1)|value)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x1
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x2)|value<<1)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x2) >> 1
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x4)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x4) >> 2
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x8)|value<<3)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x8) >> 3
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x10)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x10) >> 4
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x20)|value<<5)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x20) >> 5
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x40)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x40) >> 6
}
func (o *DEDIC_GPIO_Type) SetINTR_RLS_GPIO7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTR_RLS.Reg, volatile.LoadUint32(&o.INTR_RLS.Reg)&^(0x80)|value<<7)
}
func (o *DEDIC_GPIO_Type) GetINTR_RLS_GPIO7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INTR_RLS.Reg) & 0x80) >> 7
}

// DEDIC_GPIO.INTR_ST: Masked interrupt status
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x1)|value)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INTR_ST.Reg) & 0x1
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x2)|value<<1)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x2) >> 1
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x4)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x4) >> 2
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x8)|value<<3)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x8) >> 3
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x10)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x10) >> 4
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x20)|value<<5)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x20) >> 5
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x40)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x40) >> 6
}
func (o *DEDIC_GPIO_Type) SetINTR_ST_GPIO7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INTR_ST.Reg, volatile.LoadUint32(&o.INTR_ST.Reg)&^(0x80)|value<<7)
}
func (o *DEDIC_GPIO_Type) GetINTR_ST_GPIO7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INTR_ST.Reg) & 0x80) >> 7
}

// DEDIC_GPIO.INTR_CLR: Interrupt clear bits
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x1)|value)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x1
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x2)|value<<1)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x2) >> 1
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x4)|value<<2)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x4) >> 2
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x8)|value<<3)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x8) >> 3
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x10)|value<<4)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x10) >> 4
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x20)|value<<5)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x20) >> 5
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x40)|value<<6)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x40) >> 6
}
func (o *DEDIC_GPIO_Type) SetINTR_CLR_GPIO7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTR_CLR.Reg, volatile.LoadUint32(&o.INTR_CLR.Reg)&^(0x80)|value<<7)
}
func (o *DEDIC_GPIO_Type) GetINTR_CLR_GPIO7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTR_CLR.Reg) & 0x80) >> 7
}

// Digital Signature
type DS_Type struct {
	C_MEM           [1584]volatile.Register8 // 0x0
	IV_0            volatile.Register32      // 0x630
	IV_1            volatile.Register32      // 0x634
	IV_2            volatile.Register32      // 0x638
	IV_3            volatile.Register32      // 0x63C
	_               [448]byte
	X_MEM           [512]volatile.Register8 // 0x800
	Z_MEM           [512]volatile.Register8 // 0xA00
	_               [512]byte
	SET_START       volatile.Register32 // 0xE00
	SET_ME          volatile.Register32 // 0xE04
	SET_FINISH      volatile.Register32 // 0xE08
	QUERY_BUSY      volatile.Register32 // 0xE0C
	QUERY_KEY_WRONG volatile.Register32 // 0xE10
	QUERY_CHECK     volatile.Register32 // 0xE14
	_               [8]byte
	DATE            volatile.Register32 // 0xE20
}

// DS.IV_0: IV block data.
func (o *DS_Type) SetIV_0(value uint32) {
	volatile.StoreUint32(&o.IV_0.Reg, value)
}
func (o *DS_Type) GetIV_0() uint32 {
	return volatile.LoadUint32(&o.IV_0.Reg)
}

// DS.IV_1: IV block data.
func (o *DS_Type) SetIV_1(value uint32) {
	volatile.StoreUint32(&o.IV_1.Reg, value)
}
func (o *DS_Type) GetIV_1() uint32 {
	return volatile.LoadUint32(&o.IV_1.Reg)
}

// DS.IV_2: IV block data.
func (o *DS_Type) SetIV_2(value uint32) {
	volatile.StoreUint32(&o.IV_2.Reg, value)
}
func (o *DS_Type) GetIV_2() uint32 {
	return volatile.LoadUint32(&o.IV_2.Reg)
}

// DS.IV_3: IV block data.
func (o *DS_Type) SetIV_3(value uint32) {
	volatile.StoreUint32(&o.IV_3.Reg, value)
}
func (o *DS_Type) GetIV_3() uint32 {
	return volatile.LoadUint32(&o.IV_3.Reg)
}

// DS.SET_START: Activates the DS peripheral
func (o *DS_Type) SetSET_START(value uint32) {
	volatile.StoreUint32(&o.SET_START.Reg, volatile.LoadUint32(&o.SET_START.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_START() uint32 {
	return volatile.LoadUint32(&o.SET_START.Reg) & 0x1
}

// DS.SET_ME: Starts DS operation
func (o *DS_Type) SetSET_ME(value uint32) {
	volatile.StoreUint32(&o.SET_ME.Reg, volatile.LoadUint32(&o.SET_ME.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_ME() uint32 {
	return volatile.LoadUint32(&o.SET_ME.Reg) & 0x1
}

// DS.SET_FINISH: Ends DS operation
func (o *DS_Type) SetSET_FINISH(value uint32) {
	volatile.StoreUint32(&o.SET_FINISH.Reg, volatile.LoadUint32(&o.SET_FINISH.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetSET_FINISH() uint32 {
	return volatile.LoadUint32(&o.SET_FINISH.Reg) & 0x1
}

// DS.QUERY_BUSY: Status of the DS
func (o *DS_Type) SetQUERY_BUSY(value uint32) {
	volatile.StoreUint32(&o.QUERY_BUSY.Reg, volatile.LoadUint32(&o.QUERY_BUSY.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetQUERY_BUSY() uint32 {
	return volatile.LoadUint32(&o.QUERY_BUSY.Reg) & 0x1
}

// DS.QUERY_KEY_WRONG: Checks the reason why DS_KEY is not ready.
func (o *DS_Type) SetQUERY_KEY_WRONG(value uint32) {
	volatile.StoreUint32(&o.QUERY_KEY_WRONG.Reg, volatile.LoadUint32(&o.QUERY_KEY_WRONG.Reg)&^(0xf)|value)
}
func (o *DS_Type) GetQUERY_KEY_WRONG() uint32 {
	return volatile.LoadUint32(&o.QUERY_KEY_WRONG.Reg) & 0xf
}

// DS.QUERY_CHECK: Queries DS check result
func (o *DS_Type) SetQUERY_CHECK_MD_ERROR(value uint32) {
	volatile.StoreUint32(&o.QUERY_CHECK.Reg, volatile.LoadUint32(&o.QUERY_CHECK.Reg)&^(0x1)|value)
}
func (o *DS_Type) GetQUERY_CHECK_MD_ERROR() uint32 {
	return volatile.LoadUint32(&o.QUERY_CHECK.Reg) & 0x1
}
func (o *DS_Type) SetQUERY_CHECK_PADDING_BAD(value uint32) {
	volatile.StoreUint32(&o.QUERY_CHECK.Reg, volatile.LoadUint32(&o.QUERY_CHECK.Reg)&^(0x2)|value<<1)
}
func (o *DS_Type) GetQUERY_CHECK_PADDING_BAD() uint32 {
	return (volatile.LoadUint32(&o.QUERY_CHECK.Reg) & 0x2) >> 1
}

// DS.DATE: Version control register
func (o *DS_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *DS_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// eFuse Controller
type EFUSE_Type struct {
	PGM_DATA0           volatile.Register32 // 0x0
	PGM_DATA1           volatile.Register32 // 0x4
	PGM_DATA2           volatile.Register32 // 0x8
	PGM_DATA3           volatile.Register32 // 0xC
	PGM_DATA4           volatile.Register32 // 0x10
	PGM_DATA5           volatile.Register32 // 0x14
	PGM_DATA6           volatile.Register32 // 0x18
	PGM_DATA7           volatile.Register32 // 0x1C
	PGM_CHECK_VALUE0    volatile.Register32 // 0x20
	PGM_CHECK_VALUE1    volatile.Register32 // 0x24
	PGM_CHECK_VALUE2    volatile.Register32 // 0x28
	RD_WR_DIS           volatile.Register32 // 0x2C
	RD_REPEAT_DATA0     volatile.Register32 // 0x30
	RD_REPEAT_DATA1     volatile.Register32 // 0x34
	RD_REPEAT_DATA2     volatile.Register32 // 0x38
	RD_REPEAT_DATA3     volatile.Register32 // 0x3C
	RD_REPEAT_DATA4     volatile.Register32 // 0x40
	RD_MAC_SPI_SYS_0    volatile.Register32 // 0x44
	RD_MAC_SPI_SYS_1    volatile.Register32 // 0x48
	RD_MAC_SPI_SYS_2    volatile.Register32 // 0x4C
	RD_MAC_SPI_SYS_3    volatile.Register32 // 0x50
	RD_MAC_SPI_SYS_4    volatile.Register32 // 0x54
	RD_MAC_SPI_SYS_5    volatile.Register32 // 0x58
	RD_SYS_DATA_PART1_0 volatile.Register32 // 0x5C
	RD_SYS_DATA_PART1_1 volatile.Register32 // 0x60
	RD_SYS_DATA_PART1_2 volatile.Register32 // 0x64
	RD_SYS_DATA_PART1_3 volatile.Register32 // 0x68
	RD_SYS_DATA_PART1_4 volatile.Register32 // 0x6C
	RD_SYS_DATA_PART1_5 volatile.Register32 // 0x70
	RD_SYS_DATA_PART1_6 volatile.Register32 // 0x74
	RD_SYS_DATA_PART1_7 volatile.Register32 // 0x78
	RD_USR_DATA0        volatile.Register32 // 0x7C
	RD_USR_DATA1        volatile.Register32 // 0x80
	RD_USR_DATA2        volatile.Register32 // 0x84
	RD_USR_DATA3        volatile.Register32 // 0x88
	RD_USR_DATA4        volatile.Register32 // 0x8C
	RD_USR_DATA5        volatile.Register32 // 0x90
	RD_USR_DATA6        volatile.Register32 // 0x94
	RD_USR_DATA7        volatile.Register32 // 0x98
	RD_KEY0_DATA0       volatile.Register32 // 0x9C
	RD_KEY0_DATA1       volatile.Register32 // 0xA0
	RD_KEY0_DATA2       volatile.Register32 // 0xA4
	RD_KEY0_DATA3       volatile.Register32 // 0xA8
	RD_KEY0_DATA4       volatile.Register32 // 0xAC
	RD_KEY0_DATA5       volatile.Register32 // 0xB0
	RD_KEY0_DATA6       volatile.Register32 // 0xB4
	RD_KEY0_DATA7       volatile.Register32 // 0xB8
	RD_KEY1_DATA0       volatile.Register32 // 0xBC
	RD_KEY1_DATA1       volatile.Register32 // 0xC0
	RD_KEY1_DATA2       volatile.Register32 // 0xC4
	RD_KEY1_DATA3       volatile.Register32 // 0xC8
	RD_KEY1_DATA4       volatile.Register32 // 0xCC
	RD_KEY1_DATA5       volatile.Register32 // 0xD0
	RD_KEY1_DATA6       volatile.Register32 // 0xD4
	RD_KEY1_DATA7       volatile.Register32 // 0xD8
	RD_KEY2_DATA0       volatile.Register32 // 0xDC
	RD_KEY2_DATA1       volatile.Register32 // 0xE0
	RD_KEY2_DATA2       volatile.Register32 // 0xE4
	RD_KEY2_DATA3       volatile.Register32 // 0xE8
	RD_KEY2_DATA4       volatile.Register32 // 0xEC
	RD_KEY2_DATA5       volatile.Register32 // 0xF0
	RD_KEY2_DATA6       volatile.Register32 // 0xF4
	RD_KEY2_DATA7       volatile.Register32 // 0xF8
	RD_KEY3_DATA0       volatile.Register32 // 0xFC
	RD_KEY3_DATA1       volatile.Register32 // 0x100
	RD_KEY3_DATA2       volatile.Register32 // 0x104
	RD_KEY3_DATA3       volatile.Register32 // 0x108
	RD_KEY3_DATA4       volatile.Register32 // 0x10C
	RD_KEY3_DATA5       volatile.Register32 // 0x110
	RD_KEY3_DATA6       volatile.Register32 // 0x114
	RD_KEY3_DATA7       volatile.Register32 // 0x118
	RD_KEY4_DATA0       volatile.Register32 // 0x11C
	RD_KEY4_DATA1       volatile.Register32 // 0x120
	RD_KEY4_DATA2       volatile.Register32 // 0x124
	RD_KEY4_DATA3       volatile.Register32 // 0x128
	RD_KEY4_DATA4       volatile.Register32 // 0x12C
	RD_KEY4_DATA5       volatile.Register32 // 0x130
	RD_KEY4_DATA6       volatile.Register32 // 0x134
	RD_KEY4_DATA7       volatile.Register32 // 0x138
	RD_KEY5_DATA0       volatile.Register32 // 0x13C
	RD_KEY5_DATA1       volatile.Register32 // 0x140
	RD_KEY5_DATA2       volatile.Register32 // 0x144
	RD_KEY5_DATA3       volatile.Register32 // 0x148
	RD_KEY5_DATA4       volatile.Register32 // 0x14C
	RD_KEY5_DATA5       volatile.Register32 // 0x150
	RD_KEY5_DATA6       volatile.Register32 // 0x154
	RD_KEY5_DATA7       volatile.Register32 // 0x158
	RD_SYS_DATA_PART2_0 volatile.Register32 // 0x15C
	RD_SYS_DATA_PART2_1 volatile.Register32 // 0x160
	RD_SYS_DATA_PART2_2 volatile.Register32 // 0x164
	RD_SYS_DATA_PART2_3 volatile.Register32 // 0x168
	RD_SYS_DATA_PART2_4 volatile.Register32 // 0x16C
	RD_SYS_DATA_PART2_5 volatile.Register32 // 0x170
	RD_SYS_DATA_PART2_6 volatile.Register32 // 0x174
	RD_SYS_DATA_PART2_7 volatile.Register32 // 0x178
	RD_REPEAT_ERR0      volatile.Register32 // 0x17C
	RD_REPEAT_ERR1      volatile.Register32 // 0x180
	RD_REPEAT_ERR2      volatile.Register32 // 0x184
	RD_REPEAT_ERR3      volatile.Register32 // 0x188
	_                   [4]byte
	RD_REPEAT_ERR4      volatile.Register32 // 0x190
	_                   [44]byte
	RD_RS_ERR0          volatile.Register32 // 0x1C0
	RD_RS_ERR1          volatile.Register32 // 0x1C4
	CLK                 volatile.Register32 // 0x1C8
	CONF                volatile.Register32 // 0x1CC
	STATUS              volatile.Register32 // 0x1D0
	CMD                 volatile.Register32 // 0x1D4
	INT_RAW             volatile.Register32 // 0x1D8
	INT_ST              volatile.Register32 // 0x1DC
	INT_ENA             volatile.Register32 // 0x1E0
	INT_CLR             volatile.Register32 // 0x1E4
	DAC_CONF            volatile.Register32 // 0x1E8
	RD_TIM_CONF         volatile.Register32 // 0x1EC
	WR_TIM_CONF0        volatile.Register32 // 0x1F0
	WR_TIM_CONF1        volatile.Register32 // 0x1F4
	WR_TIM_CONF2        volatile.Register32 // 0x1F8
	DATE                volatile.Register32 // 0x1FC
}

// EFUSE.PGM_DATA0: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA0(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA0() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA0.Reg)
}

// EFUSE.PGM_DATA1: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA1(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA1() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA1.Reg)
}

// EFUSE.PGM_DATA2: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA2(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA2() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA2.Reg)
}

// EFUSE.PGM_DATA3: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA3(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA3() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA3.Reg)
}

// EFUSE.PGM_DATA4: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA4(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA4() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA4.Reg)
}

// EFUSE.PGM_DATA5: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA5(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA5() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA5.Reg)
}

// EFUSE.PGM_DATA6: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA6(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA6() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA6.Reg)
}

// EFUSE.PGM_DATA7: Register %s that stores data to be programmed.
func (o *EFUSE_Type) SetPGM_DATA7(value uint32) {
	volatile.StoreUint32(&o.PGM_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetPGM_DATA7() uint32 {
	return volatile.LoadUint32(&o.PGM_DATA7.Reg)
}

// EFUSE.PGM_CHECK_VALUE0: Register %s that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE0(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE0.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE0() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE0.Reg)
}

// EFUSE.PGM_CHECK_VALUE1: Register %s that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE1(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE1.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE1() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE1.Reg)
}

// EFUSE.PGM_CHECK_VALUE2: Register %s that stores the RS code to be programmed.
func (o *EFUSE_Type) SetPGM_CHECK_VALUE2(value uint32) {
	volatile.StoreUint32(&o.PGM_CHECK_VALUE2.Reg, value)
}
func (o *EFUSE_Type) GetPGM_CHECK_VALUE2() uint32 {
	return volatile.LoadUint32(&o.PGM_CHECK_VALUE2.Reg)
}

// EFUSE.RD_WR_DIS: Register 0 of BLOCK0.
func (o *EFUSE_Type) SetRD_WR_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_WR_DIS.Reg, value)
}
func (o *EFUSE_Type) GetRD_WR_DIS() uint32 {
	return volatile.LoadUint32(&o.RD_WR_DIS.Reg)
}

// EFUSE.RD_REPEAT_DATA0: Register 1 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RD_DIS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x7f)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RD_DIS() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x7f
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_RTC_RAM_BOOT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_RTC_RAM_BOOT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_ICACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_ICACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DCACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DCACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_USB(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x2000)|value<<13)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_USB() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x2000) >> 13
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_CAN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x4000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_CAN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x4000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_BOOT_REMAP(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_BOOT_REMAP() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x10000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_SOFT_DIS_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_SOFT_DIS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x20000) >> 17
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_HARD_DIS_JTAG(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x40000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_HARD_DIS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x40000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_DREFH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x300000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_DREFH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x300000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_DREFL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0xc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_DREFL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0xc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_EXCHG_PINS(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x1000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_EXCHG_PINS() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x1000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_EXT_PHY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_EXT_PHY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_USB_FORCE_NOPERSIST(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x4000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_USB_FORCE_NOPERSIST() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x4000000) >> 26
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_RPT4_RESERVED0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x18000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_RPT4_RESERVED0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x18000000) >> 27
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_VDD_SPI_MODECURLIM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0x20000000)|value<<29)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_VDD_SPI_MODECURLIM() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0x20000000) >> 29
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA0_VDD_SPI_DREFH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA0.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg)&^(0xc0000000)|value<<30)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA0_VDD_SPI_DREFH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA0.Reg) & 0xc0000000) >> 30
}

// EFUSE.RD_REPEAT_DATA1: Register 2 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DREFM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x3)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DREFM() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x3
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DREFL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xc)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DREFL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xc) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_XPD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_XPD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_TIEH(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_TIEH() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_FORCE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_FORCE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_EN_INIT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_EN_INIT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_ENCURLIM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_ENCURLIM() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DCURLIM(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xe00)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DCURLIM() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xe00) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_INIT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x3000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_INIT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x3000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_VDD_SPI_DCAP(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xc000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_VDD_SPI_DCAP() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xc000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_WDT_DELAY_SEL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_WDT_DELAY_SEL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x1c0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x1c0000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x400000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x400000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_KEY_PURPOSE_0(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xf000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_KEY_PURPOSE_0() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xf000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA1_KEY_PURPOSE_1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA1.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA1_KEY_PURPOSE_1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA1.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_DATA2: Register 3 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_2() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_3(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_3() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf00)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_4() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf00) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_5(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_5() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_KEY_PURPOSE_6(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_KEY_PURPOSE_6() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SECURE_BOOT_EN(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SECURE_BOOT_EN() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_RPT4_RESERVED1(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xfc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_RPT4_RESERVED1() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xfc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA2_FLASH_TPUW(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA2.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA2_FLASH_TPUW() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA2.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_DATA3: Register 4 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_DOWNLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_DOWNLOAD_MODE() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x1
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_UART_PRINT_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_UART_PRINT_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_RPT4_RESERVED3(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_RPT4_RESERVED3() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_UART_PRINT_CONTROL(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0xc0)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_UART_PRINT_CONTROL() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0xc0) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_PIN_POWER_SELECTION(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_PIN_POWER_SELECTION() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_FLASH_TYPE(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_FLASH_TYPE() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_FORCE_SEND_RESUME(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_FORCE_SEND_RESUME() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_SECURE_VERSION(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0x7fff800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_SECURE_VERSION() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0x7fff800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_DATA3_RPT4_RESERVED2(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA3.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg)&^(0xf8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA3_RPT4_RESERVED2() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_DATA3.Reg) & 0xf8000000) >> 27
}

// EFUSE.RD_REPEAT_DATA4: Register 5 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_DATA4_RPT4_RESERVED4(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_DATA4.Reg, volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg)&^(0xffffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_DATA4_RPT4_RESERVED4() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_DATA4.Reg) & 0xffffff
}

// EFUSE.RD_MAC_SPI_SYS_0: Register 0 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_0() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_0.Reg)
}

// EFUSE.RD_MAC_SPI_SYS_1: Register 1 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_1_MAC_1(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_1.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_1_MAC_1() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg) & 0xffff
}
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_1_SPI_PAD_CONF_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_1.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg)&^(0xffff0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_1_SPI_PAD_CONF_0() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SPI_SYS_1.Reg) & 0xffff0000) >> 16
}

// EFUSE.RD_MAC_SPI_SYS_2: Register 2 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_2(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_2.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_2() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_2.Reg)
}

// EFUSE.RD_MAC_SPI_SYS_3: Register 3 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_3_SPI_PAD_CONF_2(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_3.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg)&^(0x3ffff)|value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_3_SPI_PAD_CONF_2() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg) & 0x3ffff
}
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_3_SYS_DATA_PART0_0(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_3.Reg, volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg)&^(0xfffc0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_3_SYS_DATA_PART0_0() uint32 {
	return (volatile.LoadUint32(&o.RD_MAC_SPI_SYS_3.Reg) & 0xfffc0000) >> 18
}

// EFUSE.RD_MAC_SPI_SYS_4: Register 4 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_4(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_4() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_4.Reg)
}

// EFUSE.RD_MAC_SPI_SYS_5: Register 5 of BLOCK1.
func (o *EFUSE_Type) SetRD_MAC_SPI_SYS_5(value uint32) {
	volatile.StoreUint32(&o.RD_MAC_SPI_SYS_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_MAC_SPI_SYS_5() uint32 {
	return volatile.LoadUint32(&o.RD_MAC_SPI_SYS_5.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_0: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_0(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_0() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_0.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_1: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_1(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_1.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_1() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_1.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_2: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_2(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_2.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_2() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_2.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_3: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_3(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_3.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_3() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_3.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_4: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_4(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_4() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_4.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_5: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_5(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_5() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_5.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_6: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_6(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_6.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_6() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_6.Reg)
}

// EFUSE.RD_SYS_DATA_PART1_7: Register %s of BLOCK2 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART1_7(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART1_7.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART1_7() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART1_7.Reg)
}

// EFUSE.RD_USR_DATA0: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA0.Reg)
}

// EFUSE.RD_USR_DATA1: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA1.Reg)
}

// EFUSE.RD_USR_DATA2: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA2.Reg)
}

// EFUSE.RD_USR_DATA3: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA3.Reg)
}

// EFUSE.RD_USR_DATA4: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA4.Reg)
}

// EFUSE.RD_USR_DATA5: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA5.Reg)
}

// EFUSE.RD_USR_DATA6: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA6.Reg)
}

// EFUSE.RD_USR_DATA7: Register %s of BLOCK3 (user).
func (o *EFUSE_Type) SetRD_USR_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_USR_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_USR_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_USR_DATA7.Reg)
}

// EFUSE.RD_KEY0_DATA0: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA0.Reg)
}

// EFUSE.RD_KEY0_DATA1: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA1.Reg)
}

// EFUSE.RD_KEY0_DATA2: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA2.Reg)
}

// EFUSE.RD_KEY0_DATA3: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA3.Reg)
}

// EFUSE.RD_KEY0_DATA4: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA4.Reg)
}

// EFUSE.RD_KEY0_DATA5: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA5.Reg)
}

// EFUSE.RD_KEY0_DATA6: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA6.Reg)
}

// EFUSE.RD_KEY0_DATA7: Register %s of BLOCK4 (KEY0).
func (o *EFUSE_Type) SetRD_KEY0_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY0_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY0_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY0_DATA7.Reg)
}

// EFUSE.RD_KEY1_DATA0: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA0.Reg)
}

// EFUSE.RD_KEY1_DATA1: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA1.Reg)
}

// EFUSE.RD_KEY1_DATA2: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA2.Reg)
}

// EFUSE.RD_KEY1_DATA3: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA3.Reg)
}

// EFUSE.RD_KEY1_DATA4: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA4.Reg)
}

// EFUSE.RD_KEY1_DATA5: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA5.Reg)
}

// EFUSE.RD_KEY1_DATA6: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA6.Reg)
}

// EFUSE.RD_KEY1_DATA7: Register %s of BLOCK5 (KEY1).
func (o *EFUSE_Type) SetRD_KEY1_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY1_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY1_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY1_DATA7.Reg)
}

// EFUSE.RD_KEY2_DATA0: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA0.Reg)
}

// EFUSE.RD_KEY2_DATA1: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA1.Reg)
}

// EFUSE.RD_KEY2_DATA2: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA2.Reg)
}

// EFUSE.RD_KEY2_DATA3: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA3.Reg)
}

// EFUSE.RD_KEY2_DATA4: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA4.Reg)
}

// EFUSE.RD_KEY2_DATA5: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA5.Reg)
}

// EFUSE.RD_KEY2_DATA6: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA6.Reg)
}

// EFUSE.RD_KEY2_DATA7: Register %s of BLOCK6 (KEY2).
func (o *EFUSE_Type) SetRD_KEY2_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY2_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY2_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY2_DATA7.Reg)
}

// EFUSE.RD_KEY3_DATA0: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA0.Reg)
}

// EFUSE.RD_KEY3_DATA1: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA1.Reg)
}

// EFUSE.RD_KEY3_DATA2: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA2.Reg)
}

// EFUSE.RD_KEY3_DATA3: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA3.Reg)
}

// EFUSE.RD_KEY3_DATA4: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA4.Reg)
}

// EFUSE.RD_KEY3_DATA5: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA5.Reg)
}

// EFUSE.RD_KEY3_DATA6: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA6.Reg)
}

// EFUSE.RD_KEY3_DATA7: Register %s of BLOCK7 (KEY3).
func (o *EFUSE_Type) SetRD_KEY3_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY3_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY3_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY3_DATA7.Reg)
}

// EFUSE.RD_KEY4_DATA0: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA0.Reg)
}

// EFUSE.RD_KEY4_DATA1: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA1.Reg)
}

// EFUSE.RD_KEY4_DATA2: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA2.Reg)
}

// EFUSE.RD_KEY4_DATA3: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA3.Reg)
}

// EFUSE.RD_KEY4_DATA4: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA4.Reg)
}

// EFUSE.RD_KEY4_DATA5: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA5.Reg)
}

// EFUSE.RD_KEY4_DATA6: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA6.Reg)
}

// EFUSE.RD_KEY4_DATA7: Register %s of BLOCK8 (KEY4).
func (o *EFUSE_Type) SetRD_KEY4_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY4_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY4_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY4_DATA7.Reg)
}

// EFUSE.RD_KEY5_DATA0: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA0(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA0() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA0.Reg)
}

// EFUSE.RD_KEY5_DATA1: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA1(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA1() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA1.Reg)
}

// EFUSE.RD_KEY5_DATA2: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA2(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA2() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA2.Reg)
}

// EFUSE.RD_KEY5_DATA3: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA3(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA3() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA3.Reg)
}

// EFUSE.RD_KEY5_DATA4: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA4(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA4.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA4() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA4.Reg)
}

// EFUSE.RD_KEY5_DATA5: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA5(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA5.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA5() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA5.Reg)
}

// EFUSE.RD_KEY5_DATA6: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA6(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA6.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA6() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA6.Reg)
}

// EFUSE.RD_KEY5_DATA7: Register %s of BLOCK9 (KEY5).
func (o *EFUSE_Type) SetRD_KEY5_DATA7(value uint32) {
	volatile.StoreUint32(&o.RD_KEY5_DATA7.Reg, value)
}
func (o *EFUSE_Type) GetRD_KEY5_DATA7() uint32 {
	return volatile.LoadUint32(&o.RD_KEY5_DATA7.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_0: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_0(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_0.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_0() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_0.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_1: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_1(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_1.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_1() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_1.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_2: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_2(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_2.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_2() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_2.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_3: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_3(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_3.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_3() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_3.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_4: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_4(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_4.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_4() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_4.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_5: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_5(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_5.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_5() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_5.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_6: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_6(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_6.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_6() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_6.Reg)
}

// EFUSE.RD_SYS_DATA_PART2_7: Register %s of BLOCK10 (system).
func (o *EFUSE_Type) SetRD_SYS_DATA_PART2_7(value uint32) {
	volatile.StoreUint32(&o.RD_SYS_DATA_PART2_7.Reg, value)
}
func (o *EFUSE_Type) GetRD_SYS_DATA_PART2_7() uint32 {
	return volatile.LoadUint32(&o.RD_SYS_DATA_PART2_7.Reg)
}

// EFUSE.RD_REPEAT_ERR0: Programming error record register 0 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RD_DIS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x7f)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RD_DIS_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x7f
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_ICACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_ICACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DCACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DCACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x1000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x1000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_USB_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x2000)|value<<13)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_USB_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x2000) >> 13
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_CAN_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x4000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_CAN_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x4000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED5_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED5_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x10000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x20000) >> 17
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_HARD_DIS_JTAG_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x40000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_HARD_DIS_JTAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x40000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_DREFH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x300000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_DREFH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x300000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_DREFL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0xc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_DREFL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0xc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_EXCHG_PINS_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x1000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_EXCHG_PINS_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x1000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x2000000)|value<<25)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x2000000) >> 25
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x4000000)|value<<26)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x4000000) >> 26
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x18000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_RPT4_RESERVED0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x18000000) >> 27
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0x20000000)|value<<29)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0x20000000) >> 29
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR0_VDD_SPI_DREFH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR0.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg)&^(0xc0000000)|value<<30)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR0_VDD_SPI_DREFH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR0.Reg) & 0xc0000000) >> 30
}

// EFUSE.RD_REPEAT_ERR1: Programming error record register 1 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DREFM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x3)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DREFM_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x3
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DREFL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xc)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DREFL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xc) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_XPD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_XPD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_TIEH_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_TIEH_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_FORCE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_FORCE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xe00)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xe00) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_INIT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x3000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_INIT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x3000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_VDD_SPI_DCAP_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xc000)|value<<14)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_VDD_SPI_DCAP_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xc000) >> 14
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_WDT_DELAY_SEL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x30000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_WDT_DELAY_SEL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x30000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x1c0000)|value<<18)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x1c0000) >> 18
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x400000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x400000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_KEY_PURPOSE_0_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xf000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_KEY_PURPOSE_0_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xf000000) >> 24
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR1_KEY_PURPOSE_1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR1.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR1_KEY_PURPOSE_1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR1.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_ERR2: Programming error record register 2 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_2_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_3_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_3_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_4_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf00)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_4_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf00) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_5_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf000)|value<<12)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_5_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf000) >> 12
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_KEY_PURPOSE_6_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_KEY_PURPOSE_6_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0000) >> 16
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SECURE_BOOT_EN_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x100000)|value<<20)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SECURE_BOOT_EN_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x100000) >> 20
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0x200000)|value<<21)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0x200000) >> 21
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_RPT4_RESERVED1_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xfc00000)|value<<22)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_RPT4_RESERVED1_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xfc00000) >> 22
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR2_FLASH_TPUW_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR2.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR2_FLASH_TPUW_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR2.Reg) & 0xf0000000) >> 28
}

// EFUSE.RD_REPEAT_ERR3: Programming error record register 3 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x1
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_RPT4_RESERVED3_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_RPT4_RESERVED3_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0xc0)|value<<6)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0xc0) >> 6
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_FLASH_TYPE_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_FLASH_TYPE_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x400)|value<<10)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x400) >> 10
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_SECURE_VERSION_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0x7fff800)|value<<11)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_SECURE_VERSION_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0x7fff800) >> 11
}
func (o *EFUSE_Type) SetRD_REPEAT_ERR3_RPT4_RESERVED2_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR3.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg)&^(0xf8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR3_RPT4_RESERVED2_ERR() uint32 {
	return (volatile.LoadUint32(&o.RD_REPEAT_ERR3.Reg) & 0xf8000000) >> 27
}

// EFUSE.RD_REPEAT_ERR4: Programming error record register 4 of BLOCK0.
func (o *EFUSE_Type) SetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR(value uint32) {
	volatile.StoreUint32(&o.RD_REPEAT_ERR4.Reg, volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg)&^(0xffffff)|value)
}
func (o *EFUSE_Type) GetRD_REPEAT_ERR4_RPT4_RESERVED4_ERR() uint32 {
	return volatile.LoadUint32(&o.RD_REPEAT_ERR4.Reg) & 0xffffff
}

// EFUSE.RD_RS_ERR0: Programming error record register 0 of BLOCK1-10.
func (o *EFUSE_Type) SetRD_RS_ERR0_MAC_SPI_8M_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7)|value)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_MAC_SPI_8M_ERR_NUM() uint32 {
	return volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7
}
func (o *EFUSE_Type) SetRD_RS_ERR0_MAC_SPI_8M_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_MAC_SPI_8M_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_RS_ERR0_SYS_PART1_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70)|value<<4)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_SYS_PART1_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70) >> 4
}
func (o *EFUSE_Type) SetRD_RS_ERR0_SYS_PART1_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_SYS_PART1_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetRD_RS_ERR0_USR_DATA_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x700)|value<<8)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_USR_DATA_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x700) >> 8
}
func (o *EFUSE_Type) SetRD_RS_ERR0_USR_DATA_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x800)|value<<11)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_USR_DATA_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x800) >> 11
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY0_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7000)|value<<12)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY0_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7000) >> 12
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY0_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8000)|value<<15)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY0_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8000) >> 15
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY1_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70000)|value<<16)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY1_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70000) >> 16
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY1_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80000)|value<<19)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY1_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80000) >> 19
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY2_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x700000)|value<<20)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY2_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x700000) >> 20
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY2_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x800000)|value<<23)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY2_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x800000) >> 23
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY3_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x7000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY3_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x7000000) >> 24
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY3_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x8000000)|value<<27)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY3_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x8000000) >> 27
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY4_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x70000000)|value<<28)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY4_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x70000000) >> 28
}
func (o *EFUSE_Type) SetRD_RS_ERR0_KEY4_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR0.Reg, volatile.LoadUint32(&o.RD_RS_ERR0.Reg)&^(0x80000000)|value<<31)
}
func (o *EFUSE_Type) GetRD_RS_ERR0_KEY4_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR0.Reg) & 0x80000000) >> 31
}

// EFUSE.RD_RS_ERR1: Programming error record register 1 of BLOCK1-10.
func (o *EFUSE_Type) SetRD_RS_ERR1_KEY5_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x7)|value)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_KEY5_ERR_NUM() uint32 {
	return volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x7
}
func (o *EFUSE_Type) SetRD_RS_ERR1_KEY5_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x8)|value<<3)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_KEY5_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x8) >> 3
}
func (o *EFUSE_Type) SetRD_RS_ERR1_SYS_PART2_ERR_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x70)|value<<4)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_SYS_PART2_ERR_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x70) >> 4
}
func (o *EFUSE_Type) SetRD_RS_ERR1_SYS_PART2_FAIL(value uint32) {
	volatile.StoreUint32(&o.RD_RS_ERR1.Reg, volatile.LoadUint32(&o.RD_RS_ERR1.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetRD_RS_ERR1_SYS_PART2_FAIL() uint32 {
	return (volatile.LoadUint32(&o.RD_RS_ERR1.Reg) & 0x80) >> 7
}

// EFUSE.CLK: eFuse clock configuration register.
func (o *EFUSE_Type) SetCLK_EFUSE_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetCLK_EFUSE_MEM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0x1
}
func (o *EFUSE_Type) SetCLK_MEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetCLK_MEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetCLK_EFUSE_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x4)|value<<2)
}
func (o *EFUSE_Type) GetCLK_EFUSE_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x4) >> 2
}
func (o *EFUSE_Type) SetCLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0x10000)|value<<16)
}
func (o *EFUSE_Type) GetCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0x10000) >> 16
}

// EFUSE.CONF: eFuse operation mode configuration register.
func (o *EFUSE_Type) SetCONF_OP_CODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetCONF_OP_CODE() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0xffff
}

// EFUSE.STATUS: eFuse status register.
func (o *EFUSE_Type) SetSTATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf)|value)
}
func (o *EFUSE_Type) GetSTATUS_STATE() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0xf
}
func (o *EFUSE_Type) SetSTATUS_OTP_LOAD_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *EFUSE_Type) GetSTATUS_OTP_LOAD_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *EFUSE_Type) SetSTATUS_OTP_VDDQ_C_SYNC2(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *EFUSE_Type) GetSTATUS_OTP_VDDQ_C_SYNC2() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *EFUSE_Type) SetSTATUS_OTP_STROBE_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *EFUSE_Type) GetSTATUS_OTP_STROBE_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *EFUSE_Type) SetSTATUS_OTP_CSB_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *EFUSE_Type) GetSTATUS_OTP_CSB_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *EFUSE_Type) SetSTATUS_OTP_PGENB_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetSTATUS_OTP_PGENB_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetSTATUS_OTP_VDDQ_IS_SW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *EFUSE_Type) GetSTATUS_OTP_VDDQ_IS_SW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *EFUSE_Type) SetSTATUS_REPEAT_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3fc00)|value<<10)
}
func (o *EFUSE_Type) GetSTATUS_REPEAT_ERR_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x3fc00) >> 10
}

// EFUSE.CMD: eFuse command register.
func (o *EFUSE_Type) SetCMD_READ_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetCMD_READ_CMD() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x1
}
func (o *EFUSE_Type) SetCMD_PGM_CMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetCMD_PGM_CMD() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2) >> 1
}
func (o *EFUSE_Type) SetCMD_BLK_NUM(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3c)|value<<2)
}
func (o *EFUSE_Type) GetCMD_BLK_NUM() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x3c) >> 2
}

// EFUSE.INT_RAW: eFuse raw interrupt register.
func (o *EFUSE_Type) SetINT_RAW_READ_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_RAW_READ_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_RAW_PGM_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_RAW_PGM_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}

// EFUSE.INT_ST: eFuse interrupt status register.
func (o *EFUSE_Type) SetINT_ST_READ_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_ST_READ_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_ST_PGM_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_ST_PGM_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}

// EFUSE.INT_ENA: eFuse interrupt enable register.
func (o *EFUSE_Type) SetINT_ENA_READ_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_ENA_READ_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_ENA_PGM_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_ENA_PGM_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}

// EFUSE.INT_CLR: eFuse interrupt clear register.
func (o *EFUSE_Type) SetINT_CLR_READ_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *EFUSE_Type) GetINT_CLR_READ_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *EFUSE_Type) SetINT_CLR_PGM_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *EFUSE_Type) GetINT_CLR_PGM_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}

// EFUSE.DAC_CONF: Controls the eFuse programming voltage.
func (o *EFUSE_Type) SetDAC_CONF_DAC_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.DAC_CONF.Reg) & 0xff
}
func (o *EFUSE_Type) SetDAC_CONF_DAC_CLK_PAD_SEL(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x100)|value<<8)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_CLK_PAD_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x100) >> 8
}
func (o *EFUSE_Type) SetDAC_CONF_DAC_NUM(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x1fe00)|value<<9)
}
func (o *EFUSE_Type) GetDAC_CONF_DAC_NUM() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x1fe00) >> 9
}
func (o *EFUSE_Type) SetDAC_CONF_OE_CLR(value uint32) {
	volatile.StoreUint32(&o.DAC_CONF.Reg, volatile.LoadUint32(&o.DAC_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *EFUSE_Type) GetDAC_CONF_OE_CLR() uint32 {
	return (volatile.LoadUint32(&o.DAC_CONF.Reg) & 0x20000) >> 17
}

// EFUSE.RD_TIM_CONF: Configures read timing parameters.
func (o *EFUSE_Type) SetRD_TIM_CONF_THR_A(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_THR_A() uint32 {
	return volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff
}
func (o *EFUSE_Type) SetRD_TIM_CONF_TRD(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_TRD() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff00) >> 8
}
func (o *EFUSE_Type) SetRD_TIM_CONF_TSUR_A(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff0000)|value<<16)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_TSUR_A() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff0000) >> 16
}
func (o *EFUSE_Type) SetRD_TIM_CONF_READ_INIT_NUM(value uint32) {
	volatile.StoreUint32(&o.RD_TIM_CONF.Reg, volatile.LoadUint32(&o.RD_TIM_CONF.Reg)&^(0xff000000)|value<<24)
}
func (o *EFUSE_Type) GetRD_TIM_CONF_READ_INIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.RD_TIM_CONF.Reg) & 0xff000000) >> 24
}

// EFUSE.WR_TIM_CONF0: Configuration register 0 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF0_THP_A(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_THP_A() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF0.Reg) & 0xff
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_TPGM_INACTIVE(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_TPGM_INACTIVE() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0.Reg) & 0xff00) >> 8
}
func (o *EFUSE_Type) SetWR_TIM_CONF0_TPGM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF0.Reg, volatile.LoadUint32(&o.WR_TIM_CONF0.Reg)&^(0xffff0000)|value<<16)
}
func (o *EFUSE_Type) GetWR_TIM_CONF0_TPGM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF0.Reg) & 0xffff0000) >> 16
}

// EFUSE.WR_TIM_CONF1: Configuration register 1 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF1_TSUP_A(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_TSUP_A() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xff
}
func (o *EFUSE_Type) SetWR_TIM_CONF1_PWR_ON_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF1.Reg, volatile.LoadUint32(&o.WR_TIM_CONF1.Reg)&^(0xffff00)|value<<8)
}
func (o *EFUSE_Type) GetWR_TIM_CONF1_PWR_ON_NUM() uint32 {
	return (volatile.LoadUint32(&o.WR_TIM_CONF1.Reg) & 0xffff00) >> 8
}

// EFUSE.WR_TIM_CONF2: Configuration register 2 of eFuse programming timing parameters.
func (o *EFUSE_Type) SetWR_TIM_CONF2_PWR_OFF_NUM(value uint32) {
	volatile.StoreUint32(&o.WR_TIM_CONF2.Reg, volatile.LoadUint32(&o.WR_TIM_CONF2.Reg)&^(0xffff)|value)
}
func (o *EFUSE_Type) GetWR_TIM_CONF2_PWR_OFF_NUM() uint32 {
	return volatile.LoadUint32(&o.WR_TIM_CONF2.Reg) & 0xffff
}

// EFUSE.DATE: Version control register.
func (o *EFUSE_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *EFUSE_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// External Memory
type EXTMEM_Type struct {
	PRO_DCACHE_CTRL                      volatile.Register32 // 0x0
	PRO_DCACHE_CTRL1                     volatile.Register32 // 0x4
	PRO_DCACHE_TAG_POWER_CTRL            volatile.Register32 // 0x8
	PRO_DCACHE_LOCK0_ADDR                volatile.Register32 // 0xC
	PRO_DCACHE_LOCK0_SIZE                volatile.Register32 // 0x10
	PRO_DCACHE_LOCK1_ADDR                volatile.Register32 // 0x14
	PRO_DCACHE_LOCK1_SIZE                volatile.Register32 // 0x18
	PRO_DCACHE_MEM_SYNC0                 volatile.Register32 // 0x1C
	PRO_DCACHE_MEM_SYNC1                 volatile.Register32 // 0x20
	PRO_DCACHE_PRELOAD_ADDR              volatile.Register32 // 0x24
	PRO_DCACHE_PRELOAD_SIZE              volatile.Register32 // 0x28
	PRO_DCACHE_AUTOLOAD_CFG              volatile.Register32 // 0x2C
	PRO_DCACHE_AUTOLOAD_SECTION0_ADDR    volatile.Register32 // 0x30
	PRO_DCACHE_AUTOLOAD_SECTION0_SIZE    volatile.Register32 // 0x34
	PRO_DCACHE_AUTOLOAD_SECTION1_ADDR    volatile.Register32 // 0x38
	PRO_DCACHE_AUTOLOAD_SECTION1_SIZE    volatile.Register32 // 0x3C
	PRO_ICACHE_CTRL                      volatile.Register32 // 0x40
	PRO_ICACHE_CTRL1                     volatile.Register32 // 0x44
	PRO_ICACHE_TAG_POWER_CTRL            volatile.Register32 // 0x48
	PRO_ICACHE_LOCK0_ADDR                volatile.Register32 // 0x4C
	PRO_ICACHE_LOCK0_SIZE                volatile.Register32 // 0x50
	PRO_ICACHE_LOCK1_ADDR                volatile.Register32 // 0x54
	PRO_ICACHE_LOCK1_SIZE                volatile.Register32 // 0x58
	PRO_ICACHE_MEM_SYNC0                 volatile.Register32 // 0x5C
	PRO_ICACHE_MEM_SYNC1                 volatile.Register32 // 0x60
	PRO_ICACHE_PRELOAD_ADDR              volatile.Register32 // 0x64
	PRO_ICACHE_PRELOAD_SIZE              volatile.Register32 // 0x68
	PRO_ICACHE_AUTOLOAD_CFG              volatile.Register32 // 0x6C
	PRO_ICACHE_AUTOLOAD_SECTION0_ADDR    volatile.Register32 // 0x70
	PRO_ICACHE_AUTOLOAD_SECTION0_SIZE    volatile.Register32 // 0x74
	PRO_ICACHE_AUTOLOAD_SECTION1_ADDR    volatile.Register32 // 0x78
	PRO_ICACHE_AUTOLOAD_SECTION1_SIZE    volatile.Register32 // 0x7C
	IC_PRELOAD_CNT                       volatile.Register32 // 0x80
	IC_PRELOAD_MISS_CNT                  volatile.Register32 // 0x84
	IBUS2_ABANDON_CNT                    volatile.Register32 // 0x88
	IBUS1_ABANDON_CNT                    volatile.Register32 // 0x8C
	IBUS0_ABANDON_CNT                    volatile.Register32 // 0x90
	IBUS2_ACS_MISS_CNT                   volatile.Register32 // 0x94
	IBUS1_ACS_MISS_CNT                   volatile.Register32 // 0x98
	IBUS0_ACS_MISS_CNT                   volatile.Register32 // 0x9C
	IBUS2_ACS_CNT                        volatile.Register32 // 0xA0
	IBUS1_ACS_CNT                        volatile.Register32 // 0xA4
	IBUS0_ACS_CNT                        volatile.Register32 // 0xA8
	DC_PRELOAD_CNT                       volatile.Register32 // 0xAC
	DC_PRELOAD_EVICT_CNT                 volatile.Register32 // 0xB0
	DC_PRELOAD_MISS_CNT                  volatile.Register32 // 0xB4
	DBUS2_ABANDON_CNT                    volatile.Register32 // 0xB8
	DBUS1_ABANDON_CNT                    volatile.Register32 // 0xBC
	DBUS0_ABANDON_CNT                    volatile.Register32 // 0xC0
	DBUS2_ACS_WB_CNT                     volatile.Register32 // 0xC4
	DBUS1_ACS_WB_CNT                     volatile.Register32 // 0xC8
	DBUS0_ACS_WB_CNT                     volatile.Register32 // 0xCC
	DBUS2_ACS_MISS_CNT                   volatile.Register32 // 0xD0
	DBUS1_ACS_MISS_CNT                   volatile.Register32 // 0xD4
	DBUS0_ACS_MISS_CNT                   volatile.Register32 // 0xD8
	DBUS2_ACS_CNT                        volatile.Register32 // 0xDC
	DBUS1_ACS_CNT                        volatile.Register32 // 0xE0
	DBUS0_ACS_CNT                        volatile.Register32 // 0xE4
	CACHE_DBG_INT_ENA                    volatile.Register32 // 0xE8
	CACHE_DBG_INT_CLR                    volatile.Register32 // 0xEC
	CACHE_DBG_STATUS0                    volatile.Register32 // 0xF0
	CACHE_DBG_STATUS1                    volatile.Register32 // 0xF4
	PRO_CACHE_ACS_CNT_CLR                volatile.Register32 // 0xF8
	PRO_DCACHE_REJECT_ST                 volatile.Register32 // 0xFC
	PRO_DCACHE_REJECT_VADDR              volatile.Register32 // 0x100
	PRO_ICACHE_REJECT_ST                 volatile.Register32 // 0x104
	PRO_ICACHE_REJECT_VADDR              volatile.Register32 // 0x108
	PRO_CACHE_MMU_FAULT_CONTENT          volatile.Register32 // 0x10C
	PRO_CACHE_MMU_FAULT_VADDR            volatile.Register32 // 0x110
	PRO_CACHE_WRAP_AROUND_CTRL           volatile.Register32 // 0x114
	PRO_CACHE_MMU_POWER_CTRL             volatile.Register32 // 0x118
	PRO_CACHE_STATE                      volatile.Register32 // 0x11C
	CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE volatile.Register32 // 0x120
	CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON   volatile.Register32 // 0x124
	CACHE_BRIDGE_ARBITER_CTRL            volatile.Register32 // 0x128
	CACHE_PRELOAD_INT_CTRL               volatile.Register32 // 0x12C
	CACHE_SYNC_INT_CTRL                  volatile.Register32 // 0x130
	CACHE_CONF_MISC                      volatile.Register32 // 0x134
	CLOCK_GATE                           volatile.Register32 // 0x138
	_                                    [704]byte
	PRO_EXTMEM_REG_DATE                  volatile.Register32 // 0x3FC
}

// EXTMEM.PRO_DCACHE_CTRL: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_ENABLE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_SETSIZE_MODE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_SETSIZE_MODE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_BLOCKSIZE_MODE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_BLOCKSIZE_MODE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x200) >> 9
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x400) >> 10
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x800) >> 11
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x1000) >> 12
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x2000) >> 13
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK0_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK0_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x4000) >> 14
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK1_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK1_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x8000) >> 15
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x40000) >> 18
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x80000) >> 19
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x100000) >> 20
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x200000) >> 21
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x400000) >> 22
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x800000) >> 23
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x1000000) >> 24
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL_PRO_DCACHE_LOCK_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL.Reg) & 0x2000000) >> 25
}

// EXTMEM.PRO_DCACHE_CTRL1: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS0(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL1.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL1.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS0() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_CTRL1.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS1(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL1.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL1.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS1() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL1.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS2(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_CTRL1.Reg, volatile.LoadUint32(&o.PRO_DCACHE_CTRL1.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS2() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_CTRL1.Reg) & 0x4) >> 2
}

// EXTMEM.PRO_DCACHE_TAG_POWER_CTRL: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_ON() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_TAG_POWER_CTRL.Reg) & 0x4) >> 2
}

// EXTMEM.PRO_DCACHE_LOCK0_ADDR: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_LOCK0_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_LOCK0_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_LOCK0_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_LOCK0_ADDR.Reg)
}

// EXTMEM.PRO_DCACHE_LOCK0_SIZE: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_LOCK0_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_LOCK0_SIZE.Reg, volatile.LoadUint32(&o.PRO_DCACHE_LOCK0_SIZE.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_LOCK0_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_LOCK0_SIZE.Reg) & 0xffff
}

// EXTMEM.PRO_DCACHE_LOCK1_ADDR: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_LOCK1_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_LOCK1_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_LOCK1_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_LOCK1_ADDR.Reg)
}

// EXTMEM.PRO_DCACHE_LOCK1_SIZE: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_LOCK1_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_LOCK1_SIZE.Reg, volatile.LoadUint32(&o.PRO_DCACHE_LOCK1_SIZE.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_LOCK1_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_LOCK1_SIZE.Reg) & 0xffff
}

// EXTMEM.PRO_DCACHE_MEM_SYNC0: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_MEM_SYNC0(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_MEM_SYNC0.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_MEM_SYNC0() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_MEM_SYNC0.Reg)
}

// EXTMEM.PRO_DCACHE_MEM_SYNC1: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_MEM_SYNC1_PRO_DCACHE_MEMSYNC_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_MEM_SYNC1.Reg, volatile.LoadUint32(&o.PRO_DCACHE_MEM_SYNC1.Reg)&^(0x7ffff)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_MEM_SYNC1_PRO_DCACHE_MEMSYNC_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_MEM_SYNC1.Reg) & 0x7ffff
}

// EXTMEM.PRO_DCACHE_PRELOAD_ADDR: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_PRELOAD_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_PRELOAD_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_PRELOAD_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_ADDR.Reg)
}

// EXTMEM.PRO_DCACHE_PRELOAD_SIZE: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_PRELOAD_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_PRELOAD_SIZE.Reg, volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_SIZE.Reg)&^(0x3ff)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_PRELOAD_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_SIZE.Reg) & 0x3ff
}
func (o *EXTMEM_Type) SetPRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_ORDER(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_PRELOAD_SIZE.Reg, volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_SIZE.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_ORDER() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_SIZE.Reg) & 0x400) >> 10
}

// EXTMEM.PRO_DCACHE_AUTOLOAD_CFG: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_MODE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_STEP(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0x6)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_STEP() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0x6) >> 1
}
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_ORDER(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_ORDER() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_RQST(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0x30)|value<<4)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_RQST() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0x30) >> 4
}
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0xc0)|value<<6)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SIZE() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0xc0) >> 6
}
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT0_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT0_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT1_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT1_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_CFG.Reg) & 0x200) >> 9
}

// EXTMEM.PRO_DCACHE_AUTOLOAD_SECTION0_ADDR: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_SECTION0_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION0_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_SECTION0_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION0_ADDR.Reg)
}

// EXTMEM.PRO_DCACHE_AUTOLOAD_SECTION0_SIZE: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_SECTION0_SIZE_PRO_DCACHE_AUTOLOAD_SCT0_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION0_SIZE.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION0_SIZE.Reg)&^(0xffffff)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_SECTION0_SIZE_PRO_DCACHE_AUTOLOAD_SCT0_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION0_SIZE.Reg) & 0xffffff
}

// EXTMEM.PRO_DCACHE_AUTOLOAD_SECTION1_ADDR: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_SECTION1_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION1_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_SECTION1_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION1_ADDR.Reg)
}

// EXTMEM.PRO_DCACHE_AUTOLOAD_SECTION1_SIZE: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_AUTOLOAD_SECTION1_SIZE_PRO_DCACHE_AUTOLOAD_SCT1_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION1_SIZE.Reg, volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION1_SIZE.Reg)&^(0xffffff)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_AUTOLOAD_SECTION1_SIZE_PRO_DCACHE_AUTOLOAD_SCT1_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_AUTOLOAD_SECTION1_SIZE.Reg) & 0xffffff
}

// EXTMEM.PRO_ICACHE_CTRL: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_ENABLE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_SETSIZE_MODE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_SETSIZE_MODE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_BLOCKSIZE_MODE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_BLOCKSIZE_MODE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x200) >> 9
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK0_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK0_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x4000) >> 14
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK1_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK1_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x8000) >> 15
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x40000) >> 18
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x80000) >> 19
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x100000) >> 20
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x200000) >> 21
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x400000) >> 22
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x800000) >> 23
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x1000000) >> 24
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK_DONE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL_PRO_ICACHE_LOCK_DONE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL.Reg) & 0x2000000) >> 25
}

// EXTMEM.PRO_ICACHE_CTRL1: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS0(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL1.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL1.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS0() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_CTRL1.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS1(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL1.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL1.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS1() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL1.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS2(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_CTRL1.Reg, volatile.LoadUint32(&o.PRO_ICACHE_CTRL1.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS2() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_CTRL1.Reg) & 0x4) >> 2
}

// EXTMEM.PRO_ICACHE_TAG_POWER_CTRL: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_ON() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_TAG_POWER_CTRL.Reg) & 0x4) >> 2
}

// EXTMEM.PRO_ICACHE_LOCK0_ADDR: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_LOCK0_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_LOCK0_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_LOCK0_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_LOCK0_ADDR.Reg)
}

// EXTMEM.PRO_ICACHE_LOCK0_SIZE: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_LOCK0_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_LOCK0_SIZE.Reg, volatile.LoadUint32(&o.PRO_ICACHE_LOCK0_SIZE.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_LOCK0_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_LOCK0_SIZE.Reg) & 0xffff
}

// EXTMEM.PRO_ICACHE_LOCK1_ADDR: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_LOCK1_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_LOCK1_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_LOCK1_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_LOCK1_ADDR.Reg)
}

// EXTMEM.PRO_ICACHE_LOCK1_SIZE: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_LOCK1_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_LOCK1_SIZE.Reg, volatile.LoadUint32(&o.PRO_ICACHE_LOCK1_SIZE.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_LOCK1_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_LOCK1_SIZE.Reg) & 0xffff
}

// EXTMEM.PRO_ICACHE_MEM_SYNC0: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_MEM_SYNC0(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_MEM_SYNC0.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_MEM_SYNC0() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_MEM_SYNC0.Reg)
}

// EXTMEM.PRO_ICACHE_MEM_SYNC1: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_MEM_SYNC1_PRO_ICACHE_MEMSYNC_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_MEM_SYNC1.Reg, volatile.LoadUint32(&o.PRO_ICACHE_MEM_SYNC1.Reg)&^(0x7ffff)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_MEM_SYNC1_PRO_ICACHE_MEMSYNC_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_MEM_SYNC1.Reg) & 0x7ffff
}

// EXTMEM.PRO_ICACHE_PRELOAD_ADDR: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_PRELOAD_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_PRELOAD_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_PRELOAD_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_ADDR.Reg)
}

// EXTMEM.PRO_ICACHE_PRELOAD_SIZE: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_PRELOAD_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_PRELOAD_SIZE.Reg, volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_SIZE.Reg)&^(0x3ff)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_PRELOAD_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_SIZE.Reg) & 0x3ff
}
func (o *EXTMEM_Type) SetPRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_ORDER(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_PRELOAD_SIZE.Reg, volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_SIZE.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_ORDER() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_SIZE.Reg) & 0x400) >> 10
}

// EXTMEM.PRO_ICACHE_AUTOLOAD_CFG: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_MODE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_MODE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_STEP(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0x6)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_STEP() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0x6) >> 1
}
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_ORDER(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_ORDER() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_RQST(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0x30)|value<<4)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_RQST() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0x30) >> 4
}
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0xc0)|value<<6)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SIZE() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0xc0) >> 6
}
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT0_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT0_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT1_ENA(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT1_ENA() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_CFG.Reg) & 0x200) >> 9
}

// EXTMEM.PRO_ICACHE_AUTOLOAD_SECTION0_ADDR: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_SECTION0_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION0_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_SECTION0_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION0_ADDR.Reg)
}

// EXTMEM.PRO_ICACHE_AUTOLOAD_SECTION0_SIZE: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_SECTION0_SIZE_PRO_ICACHE_AUTOLOAD_SCT0_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION0_SIZE.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION0_SIZE.Reg)&^(0xffffff)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_SECTION0_SIZE_PRO_ICACHE_AUTOLOAD_SCT0_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION0_SIZE.Reg) & 0xffffff
}

// EXTMEM.PRO_ICACHE_AUTOLOAD_SECTION1_ADDR: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_SECTION1_ADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION1_ADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_SECTION1_ADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION1_ADDR.Reg)
}

// EXTMEM.PRO_ICACHE_AUTOLOAD_SECTION1_SIZE: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_AUTOLOAD_SECTION1_SIZE_PRO_ICACHE_AUTOLOAD_SCT1_SIZE(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION1_SIZE.Reg, volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION1_SIZE.Reg)&^(0xffffff)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_AUTOLOAD_SECTION1_SIZE_PRO_ICACHE_AUTOLOAD_SCT1_SIZE() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_AUTOLOAD_SECTION1_SIZE.Reg) & 0xffffff
}

// EXTMEM.IC_PRELOAD_CNT: register description
func (o *EXTMEM_Type) SetIC_PRELOAD_CNT(value uint32) {
	volatile.StoreUint32(&o.IC_PRELOAD_CNT.Reg, volatile.LoadUint32(&o.IC_PRELOAD_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetIC_PRELOAD_CNT() uint32 {
	return volatile.LoadUint32(&o.IC_PRELOAD_CNT.Reg) & 0xffff
}

// EXTMEM.IC_PRELOAD_MISS_CNT: register description
func (o *EXTMEM_Type) SetIC_PRELOAD_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.IC_PRELOAD_MISS_CNT.Reg, volatile.LoadUint32(&o.IC_PRELOAD_MISS_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetIC_PRELOAD_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.IC_PRELOAD_MISS_CNT.Reg) & 0xffff
}

// EXTMEM.IBUS2_ABANDON_CNT: register description
func (o *EXTMEM_Type) SetIBUS2_ABANDON_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS2_ABANDON_CNT.Reg, volatile.LoadUint32(&o.IBUS2_ABANDON_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetIBUS2_ABANDON_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS2_ABANDON_CNT.Reg) & 0xffff
}

// EXTMEM.IBUS1_ABANDON_CNT: register description
func (o *EXTMEM_Type) SetIBUS1_ABANDON_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS1_ABANDON_CNT.Reg, volatile.LoadUint32(&o.IBUS1_ABANDON_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetIBUS1_ABANDON_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS1_ABANDON_CNT.Reg) & 0xffff
}

// EXTMEM.IBUS0_ABANDON_CNT: register description
func (o *EXTMEM_Type) SetIBUS0_ABANDON_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS0_ABANDON_CNT.Reg, volatile.LoadUint32(&o.IBUS0_ABANDON_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetIBUS0_ABANDON_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS0_ABANDON_CNT.Reg) & 0xffff
}

// EXTMEM.IBUS2_ACS_MISS_CNT: register description
func (o *EXTMEM_Type) SetIBUS2_ACS_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS2_ACS_MISS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetIBUS2_ACS_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS2_ACS_MISS_CNT.Reg)
}

// EXTMEM.IBUS1_ACS_MISS_CNT: register description
func (o *EXTMEM_Type) SetIBUS1_ACS_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS1_ACS_MISS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetIBUS1_ACS_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS1_ACS_MISS_CNT.Reg)
}

// EXTMEM.IBUS0_ACS_MISS_CNT: register description
func (o *EXTMEM_Type) SetIBUS0_ACS_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS0_ACS_MISS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetIBUS0_ACS_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS0_ACS_MISS_CNT.Reg)
}

// EXTMEM.IBUS2_ACS_CNT: register description
func (o *EXTMEM_Type) SetIBUS2_ACS_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS2_ACS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetIBUS2_ACS_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS2_ACS_CNT.Reg)
}

// EXTMEM.IBUS1_ACS_CNT: register description
func (o *EXTMEM_Type) SetIBUS1_ACS_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS1_ACS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetIBUS1_ACS_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS1_ACS_CNT.Reg)
}

// EXTMEM.IBUS0_ACS_CNT: register description
func (o *EXTMEM_Type) SetIBUS0_ACS_CNT(value uint32) {
	volatile.StoreUint32(&o.IBUS0_ACS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetIBUS0_ACS_CNT() uint32 {
	return volatile.LoadUint32(&o.IBUS0_ACS_CNT.Reg)
}

// EXTMEM.DC_PRELOAD_CNT: register description
func (o *EXTMEM_Type) SetDC_PRELOAD_CNT(value uint32) {
	volatile.StoreUint32(&o.DC_PRELOAD_CNT.Reg, volatile.LoadUint32(&o.DC_PRELOAD_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetDC_PRELOAD_CNT() uint32 {
	return volatile.LoadUint32(&o.DC_PRELOAD_CNT.Reg) & 0xffff
}

// EXTMEM.DC_PRELOAD_EVICT_CNT: register description
func (o *EXTMEM_Type) SetDC_PRELOAD_EVICT_CNT(value uint32) {
	volatile.StoreUint32(&o.DC_PRELOAD_EVICT_CNT.Reg, volatile.LoadUint32(&o.DC_PRELOAD_EVICT_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetDC_PRELOAD_EVICT_CNT() uint32 {
	return volatile.LoadUint32(&o.DC_PRELOAD_EVICT_CNT.Reg) & 0xffff
}

// EXTMEM.DC_PRELOAD_MISS_CNT: register description
func (o *EXTMEM_Type) SetDC_PRELOAD_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.DC_PRELOAD_MISS_CNT.Reg, volatile.LoadUint32(&o.DC_PRELOAD_MISS_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetDC_PRELOAD_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.DC_PRELOAD_MISS_CNT.Reg) & 0xffff
}

// EXTMEM.DBUS2_ABANDON_CNT: register description
func (o *EXTMEM_Type) SetDBUS2_ABANDON_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS2_ABANDON_CNT.Reg, volatile.LoadUint32(&o.DBUS2_ABANDON_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetDBUS2_ABANDON_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS2_ABANDON_CNT.Reg) & 0xffff
}

// EXTMEM.DBUS1_ABANDON_CNT: register description
func (o *EXTMEM_Type) SetDBUS1_ABANDON_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS1_ABANDON_CNT.Reg, volatile.LoadUint32(&o.DBUS1_ABANDON_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetDBUS1_ABANDON_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS1_ABANDON_CNT.Reg) & 0xffff
}

// EXTMEM.DBUS0_ABANDON_CNT: register description
func (o *EXTMEM_Type) SetDBUS0_ABANDON_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS0_ABANDON_CNT.Reg, volatile.LoadUint32(&o.DBUS0_ABANDON_CNT.Reg)&^(0xffff)|value)
}
func (o *EXTMEM_Type) GetDBUS0_ABANDON_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS0_ABANDON_CNT.Reg) & 0xffff
}

// EXTMEM.DBUS2_ACS_WB_CNT: register description
func (o *EXTMEM_Type) SetDBUS2_ACS_WB_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS2_ACS_WB_CNT.Reg, volatile.LoadUint32(&o.DBUS2_ACS_WB_CNT.Reg)&^(0xfffff)|value)
}
func (o *EXTMEM_Type) GetDBUS2_ACS_WB_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS2_ACS_WB_CNT.Reg) & 0xfffff
}

// EXTMEM.DBUS1_ACS_WB_CNT: register description
func (o *EXTMEM_Type) SetDBUS1_ACS_WB_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS1_ACS_WB_CNT.Reg, volatile.LoadUint32(&o.DBUS1_ACS_WB_CNT.Reg)&^(0xfffff)|value)
}
func (o *EXTMEM_Type) GetDBUS1_ACS_WB_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS1_ACS_WB_CNT.Reg) & 0xfffff
}

// EXTMEM.DBUS0_ACS_WB_CNT: register description
func (o *EXTMEM_Type) SetDBUS0_ACS_WB_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS0_ACS_WB_CNT.Reg, volatile.LoadUint32(&o.DBUS0_ACS_WB_CNT.Reg)&^(0xfffff)|value)
}
func (o *EXTMEM_Type) GetDBUS0_ACS_WB_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS0_ACS_WB_CNT.Reg) & 0xfffff
}

// EXTMEM.DBUS2_ACS_MISS_CNT: register description
func (o *EXTMEM_Type) SetDBUS2_ACS_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS2_ACS_MISS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetDBUS2_ACS_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS2_ACS_MISS_CNT.Reg)
}

// EXTMEM.DBUS1_ACS_MISS_CNT: register description
func (o *EXTMEM_Type) SetDBUS1_ACS_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS1_ACS_MISS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetDBUS1_ACS_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS1_ACS_MISS_CNT.Reg)
}

// EXTMEM.DBUS0_ACS_MISS_CNT: register description
func (o *EXTMEM_Type) SetDBUS0_ACS_MISS_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS0_ACS_MISS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetDBUS0_ACS_MISS_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS0_ACS_MISS_CNT.Reg)
}

// EXTMEM.DBUS2_ACS_CNT: register description
func (o *EXTMEM_Type) SetDBUS2_ACS_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS2_ACS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetDBUS2_ACS_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS2_ACS_CNT.Reg)
}

// EXTMEM.DBUS1_ACS_CNT: register description
func (o *EXTMEM_Type) SetDBUS1_ACS_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS1_ACS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetDBUS1_ACS_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS1_ACS_CNT.Reg)
}

// EXTMEM.DBUS0_ACS_CNT: register description
func (o *EXTMEM_Type) SetDBUS0_ACS_CNT(value uint32) {
	volatile.StoreUint32(&o.DBUS0_ACS_CNT.Reg, value)
}
func (o *EXTMEM_Type) GetDBUS0_ACS_CNT() uint32 {
	return volatile.LoadUint32(&o.DBUS0_ACS_CNT.Reg)
}

// EXTMEM.CACHE_DBG_INT_ENA: register description
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_CACHE_DBG_EN(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_CACHE_DBG_EN() uint32 {
	return volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_IBUS_ACS_MSK_IC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_IBUS_ACS_MSK_IC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_IBUS_CNT_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_IBUS_CNT_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_IC_SYNC_SIZE_FAULT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_IC_SYNC_SIZE_FAULT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x10) >> 4
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_IC_PRELOAD_SIZE_FAULT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_IC_PRELOAD_SIZE_FAULT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x20) >> 5
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_ICACHE_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_ICACHE_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x40) >> 6
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_ICACHE_SET_PRELOAD_ILG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_ICACHE_SET_PRELOAD_ILG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x80) >> 7
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_ICACHE_SET_SYNC_ILG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_ICACHE_SET_SYNC_ILG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_ICACHE_SET_LOCK_ILG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_ICACHE_SET_LOCK_ILG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x200) >> 9
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DBUS_ACS_MSK_DC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DBUS_ACS_MSK_DC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x400) >> 10
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DBUS_CNT_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DBUS_CNT_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x800) >> 11
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DC_SYNC_SIZE_FAULT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DC_SYNC_SIZE_FAULT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x1000) >> 12
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DC_PRELOAD_SIZE_FAULT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DC_PRELOAD_SIZE_FAULT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x2000) >> 13
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DCACHE_WRITE_FLASH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DCACHE_WRITE_FLASH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x4000) >> 14
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DCACHE_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DCACHE_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x8000) >> 15
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DCACHE_SET_PRELOAD_ILG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DCACHE_SET_PRELOAD_ILG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x10000) >> 16
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DCACHE_SET_SYNC_ILG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DCACHE_SET_SYNC_ILG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x20000) >> 17
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_DCACHE_SET_LOCK_ILG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_DCACHE_SET_LOCK_ILG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x40000) >> 18
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_ENA_MMU_ENTRY_FAULT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_ENA.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_ENA_MMU_ENTRY_FAULT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_ENA.Reg) & 0x80000) >> 19
}

// EXTMEM.CACHE_DBG_INT_CLR: register description
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_IBUS_ACS_MSK_IC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_IBUS_ACS_MSK_IC_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_IBUS_CNT_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_IBUS_CNT_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_IC_SYNC_SIZE_FAULT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_IC_SYNC_SIZE_FAULT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_IC_PRELOAD_SIZE_FAULT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_IC_PRELOAD_SIZE_FAULT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_ICACHE_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_ICACHE_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x10) >> 4
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_ICACHE_SET_ILG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_ICACHE_SET_ILG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x20) >> 5
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DBUS_ACS_MSK_DC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DBUS_ACS_MSK_DC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x40) >> 6
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DBUS_CNT_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DBUS_CNT_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x80) >> 7
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DC_SYNC_SIZE_FAULT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DC_SYNC_SIZE_FAULT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DC_PRELOAD_SIZE_FAULT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DC_PRELOAD_SIZE_FAULT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x200) >> 9
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DCACHE_WRITE_FLASH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DCACHE_WRITE_FLASH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x400) >> 10
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DCACHE_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DCACHE_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x800) >> 11
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_DCACHE_SET_ILG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_DCACHE_SET_ILG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x1000) >> 12
}
func (o *EXTMEM_Type) SetCACHE_DBG_INT_CLR_MMU_ENTRY_FAULT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_INT_CLR.Reg, volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *EXTMEM_Type) GetCACHE_DBG_INT_CLR_MMU_ENTRY_FAULT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_INT_CLR.Reg) & 0x2000) >> 13
}

// EXTMEM.CACHE_DBG_STATUS0: register description
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS0_ACS_MSK_ICACHE_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS0_ACS_MSK_ICACHE_ST() uint32 {
	return volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS1_ACS_MSK_ICACHE_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS1_ACS_MSK_ICACHE_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS2_ACS_MSK_ICACHE_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS2_ACS_MSK_ICACHE_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS0_ACS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x10)|value<<4)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS0_ACS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x10) >> 4
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS1_ACS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x20)|value<<5)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS1_ACS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x20) >> 5
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS2_ACS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x40)|value<<6)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS2_ACS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x40) >> 6
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS0_ACS_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS0_ACS_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS1_ACS_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS1_ACS_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x200) >> 9
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS2_ACS_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS2_ACS_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x400) >> 10
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS0_ABANDON_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x1000)|value<<12)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS0_ABANDON_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x1000) >> 12
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS1_ABANDON_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x2000)|value<<13)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS1_ABANDON_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x2000) >> 13
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IBUS2_ABANDON_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x4000)|value<<14)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IBUS2_ABANDON_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x4000) >> 14
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IC_PRELOAD_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x10000)|value<<16)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IC_PRELOAD_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x10000) >> 16
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IC_PRELOAD_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x40000)|value<<18)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IC_PRELOAD_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x40000) >> 18
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IC_SYNC_SIZE_FAULT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x80000)|value<<19)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IC_SYNC_SIZE_FAULT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x80000) >> 19
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_IC_PRELOAD_SIZE_FAULT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x100000)|value<<20)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_IC_PRELOAD_SIZE_FAULT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x100000) >> 20
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_ICACHE_REJECT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x200000)|value<<21)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_ICACHE_REJECT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x200000) >> 21
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_ICACHE_SET_PRELOAD_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x400000)|value<<22)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_ICACHE_SET_PRELOAD_ILG_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x400000) >> 22
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_ICACHE_SET_SYNC_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x800000)|value<<23)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_ICACHE_SET_SYNC_ILG_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x800000) >> 23
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS0_ICACHE_SET_LOCK_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS0.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS0_ICACHE_SET_LOCK_ILG_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS0.Reg) & 0x1000000) >> 24
}

// EXTMEM.CACHE_DBG_STATUS1: register description
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS0_ACS_MSK_DCACHE_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS0_ACS_MSK_DCACHE_ST() uint32 {
	return volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS1_ACS_MSK_DCACHE_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS1_ACS_MSK_DCACHE_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS2_ACS_MSK_DCACHE_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS2_ACS_MSK_DCACHE_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS0_ACS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x10)|value<<4)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS0_ACS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x10) >> 4
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS1_ACS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x20)|value<<5)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS1_ACS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x20) >> 5
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS2_ACS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x40)|value<<6)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS2_ACS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x40) >> 6
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS0_ACS_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x100)|value<<8)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS0_ACS_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x100) >> 8
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS1_ACS_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x200)|value<<9)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS1_ACS_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x200) >> 9
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS2_ACS_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x400)|value<<10)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS2_ACS_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x400) >> 10
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS0_ACS_WB_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS0_ACS_WB_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x1000) >> 12
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS1_ACS_WB_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS1_ACS_WB_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x2000) >> 13
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS2_ACS_WB_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS2_ACS_WB_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x4000) >> 14
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS0_ABANDON_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS0_ABANDON_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x10000) >> 16
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS1_ABANDON_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS1_ABANDON_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x20000) >> 17
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DBUS2_ABANDON_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DBUS2_ABANDON_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x40000) >> 18
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DC_PRELOAD_MISS_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DC_PRELOAD_MISS_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x100000) >> 20
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DC_PRELOAD_EVICT_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DC_PRELOAD_EVICT_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x200000) >> 21
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DC_PRELOAD_CNT_OVF_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DC_PRELOAD_CNT_OVF_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x400000) >> 22
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DC_SYNC_SIZE_FAULT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DC_SYNC_SIZE_FAULT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x800000) >> 23
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DC_PRELOAD_SIZE_FAULT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DC_PRELOAD_SIZE_FAULT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x1000000) >> 24
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DCACHE_WRITE_FLASH_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DCACHE_WRITE_FLASH_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x2000000) >> 25
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DCACHE_REJECT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DCACHE_REJECT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x4000000) >> 26
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DCACHE_SET_PRELOAD_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DCACHE_SET_PRELOAD_ILG_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x8000000) >> 27
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DCACHE_SET_SYNC_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DCACHE_SET_SYNC_ILG_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x10000000) >> 28
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_DCACHE_SET_LOCK_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_DCACHE_SET_LOCK_ILG_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x20000000) >> 29
}
func (o *EXTMEM_Type) SetCACHE_DBG_STATUS1_MMU_ENTRY_FAULT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_DBG_STATUS1.Reg, volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTMEM_Type) GetCACHE_DBG_STATUS1_MMU_ENTRY_FAULT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_DBG_STATUS1.Reg) & 0x40000000) >> 30
}

// EXTMEM.PRO_CACHE_ACS_CNT_CLR: register description
func (o *EXTMEM_Type) SetPRO_CACHE_ACS_CNT_CLR_PRO_DCACHE_ACS_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_ACS_CNT_CLR.Reg, volatile.LoadUint32(&o.PRO_CACHE_ACS_CNT_CLR.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_CACHE_ACS_CNT_CLR_PRO_DCACHE_ACS_CNT_CLR() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_ACS_CNT_CLR.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_CACHE_ACS_CNT_CLR_PRO_ICACHE_ACS_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_ACS_CNT_CLR.Reg, volatile.LoadUint32(&o.PRO_CACHE_ACS_CNT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_CACHE_ACS_CNT_CLR_PRO_ICACHE_ACS_CNT_CLR() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_ACS_CNT_CLR.Reg) & 0x2) >> 1
}

// EXTMEM.PRO_DCACHE_REJECT_ST: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_REJECT_ST_PRO_DCACHE_TAG_ATTR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_REJECT_ST.Reg, volatile.LoadUint32(&o.PRO_DCACHE_REJECT_ST.Reg)&^(0x7)|value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_REJECT_ST_PRO_DCACHE_TAG_ATTR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_REJECT_ST.Reg) & 0x7
}
func (o *EXTMEM_Type) SetPRO_DCACHE_REJECT_ST_PRO_DCACHE_CPU_ATTR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_REJECT_ST.Reg, volatile.LoadUint32(&o.PRO_DCACHE_REJECT_ST.Reg)&^(0x38)|value<<3)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_REJECT_ST_PRO_DCACHE_CPU_ATTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_DCACHE_REJECT_ST.Reg) & 0x38) >> 3
}

// EXTMEM.PRO_DCACHE_REJECT_VADDR: register description
func (o *EXTMEM_Type) SetPRO_DCACHE_REJECT_VADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_REJECT_VADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_DCACHE_REJECT_VADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_REJECT_VADDR.Reg)
}

// EXTMEM.PRO_ICACHE_REJECT_ST: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_REJECT_ST_PRO_ICACHE_TAG_ATTR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_REJECT_ST.Reg, volatile.LoadUint32(&o.PRO_ICACHE_REJECT_ST.Reg)&^(0x7)|value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_REJECT_ST_PRO_ICACHE_TAG_ATTR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_REJECT_ST.Reg) & 0x7
}
func (o *EXTMEM_Type) SetPRO_ICACHE_REJECT_ST_PRO_ICACHE_CPU_ATTR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_REJECT_ST.Reg, volatile.LoadUint32(&o.PRO_ICACHE_REJECT_ST.Reg)&^(0x38)|value<<3)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_REJECT_ST_PRO_ICACHE_CPU_ATTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_ICACHE_REJECT_ST.Reg) & 0x38) >> 3
}

// EXTMEM.PRO_ICACHE_REJECT_VADDR: register description
func (o *EXTMEM_Type) SetPRO_ICACHE_REJECT_VADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_REJECT_VADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_ICACHE_REJECT_VADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_REJECT_VADDR.Reg)
}

// EXTMEM.PRO_CACHE_MMU_FAULT_CONTENT: register description
func (o *EXTMEM_Type) SetPRO_CACHE_MMU_FAULT_CONTENT(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_MMU_FAULT_CONTENT.Reg, volatile.LoadUint32(&o.PRO_CACHE_MMU_FAULT_CONTENT.Reg)&^(0x1ffff)|value)
}
func (o *EXTMEM_Type) GetPRO_CACHE_MMU_FAULT_CONTENT() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_MMU_FAULT_CONTENT.Reg) & 0x1ffff
}
func (o *EXTMEM_Type) SetPRO_CACHE_MMU_FAULT_CONTENT_PRO_CACHE_MMU_FAULT_CODE(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_MMU_FAULT_CONTENT.Reg, volatile.LoadUint32(&o.PRO_CACHE_MMU_FAULT_CONTENT.Reg)&^(0xe0000)|value<<17)
}
func (o *EXTMEM_Type) GetPRO_CACHE_MMU_FAULT_CONTENT_PRO_CACHE_MMU_FAULT_CODE() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_MMU_FAULT_CONTENT.Reg) & 0xe0000) >> 17
}

// EXTMEM.PRO_CACHE_MMU_FAULT_VADDR: register description
func (o *EXTMEM_Type) SetPRO_CACHE_MMU_FAULT_VADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_MMU_FAULT_VADDR.Reg, value)
}
func (o *EXTMEM_Type) GetPRO_CACHE_MMU_FAULT_VADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_MMU_FAULT_VADDR.Reg)
}

// EXTMEM.PRO_CACHE_WRAP_AROUND_CTRL: register description
func (o *EXTMEM_Type) SetPRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_FLASH_WRAP_AROUND(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_WRAP_AROUND_CTRL.Reg, volatile.LoadUint32(&o.PRO_CACHE_WRAP_AROUND_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_FLASH_WRAP_AROUND() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_WRAP_AROUND_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_SRAM_RD_WRAP_AROUND(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_WRAP_AROUND_CTRL.Reg, volatile.LoadUint32(&o.PRO_CACHE_WRAP_AROUND_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_SRAM_RD_WRAP_AROUND() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_WRAP_AROUND_CTRL.Reg) & 0x2) >> 1
}

// EXTMEM.PRO_CACHE_MMU_POWER_CTRL: register description
func (o *EXTMEM_Type) SetPRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetPRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_ON() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetPRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetPRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetPRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg, volatile.LoadUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetPRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_MMU_POWER_CTRL.Reg) & 0x4) >> 2
}

// EXTMEM.PRO_CACHE_STATE: register description
func (o *EXTMEM_Type) SetPRO_CACHE_STATE_PRO_ICACHE_STATE(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_STATE.Reg, volatile.LoadUint32(&o.PRO_CACHE_STATE.Reg)&^(0xfff)|value)
}
func (o *EXTMEM_Type) GetPRO_CACHE_STATE_PRO_ICACHE_STATE() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_STATE.Reg) & 0xfff
}
func (o *EXTMEM_Type) SetPRO_CACHE_STATE_PRO_DCACHE_STATE(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_STATE.Reg, volatile.LoadUint32(&o.PRO_CACHE_STATE.Reg)&^(0xfff000)|value<<12)
}
func (o *EXTMEM_Type) GetPRO_CACHE_STATE_PRO_DCACHE_STATE() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_STATE.Reg) & 0xfff000) >> 12
}

// EXTMEM.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE: register description
func (o *EXTMEM_Type) SetCACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_DB_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE.Reg, volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_DB_ENCRYPT() uint32 {
	return volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_G0CB_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE.Reg, volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_G0CB_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE.Reg) & 0x2) >> 1
}

// EXTMEM.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON: register description
func (o *EXTMEM_Type) SetCACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_DB_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg, volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_DB_ENCRYPT() uint32 {
	return volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_G0CB_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg, volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_G0CB_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetCACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg, volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON.Reg) & 0x4) >> 2
}

// EXTMEM.CACHE_BRIDGE_ARBITER_CTRL: register description
func (o *EXTMEM_Type) SetCACHE_BRIDGE_ARBITER_CTRL_ALLOC_WB_HOLD_ARBITER(value uint32) {
	volatile.StoreUint32(&o.CACHE_BRIDGE_ARBITER_CTRL.Reg, volatile.LoadUint32(&o.CACHE_BRIDGE_ARBITER_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_BRIDGE_ARBITER_CTRL_ALLOC_WB_HOLD_ARBITER() uint32 {
	return volatile.LoadUint32(&o.CACHE_BRIDGE_ARBITER_CTRL.Reg) & 0x1
}

// EXTMEM.CACHE_PRELOAD_INT_CTRL: register description
func (o *EXTMEM_Type) SetCACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ST() uint32 {
	return volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetCACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetCACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetCACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetCACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *EXTMEM_Type) GetCACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg) & 0x10) >> 4
}
func (o *EXTMEM_Type) SetCACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *EXTMEM_Type) GetCACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_PRELOAD_INT_CTRL.Reg) & 0x20) >> 5
}

// EXTMEM.CACHE_SYNC_INT_CTRL: register description
func (o *EXTMEM_Type) SetCACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_SYNC_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ST() uint32 {
	return volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_SYNC_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg) & 0x2) >> 1
}
func (o *EXTMEM_Type) SetCACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_SYNC_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EXTMEM_Type) GetCACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg) & 0x4) >> 2
}
func (o *EXTMEM_Type) SetCACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.CACHE_SYNC_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EXTMEM_Type) GetCACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg) & 0x8) >> 3
}
func (o *EXTMEM_Type) SetCACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.CACHE_SYNC_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *EXTMEM_Type) GetCACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg) & 0x10) >> 4
}
func (o *EXTMEM_Type) SetCACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.CACHE_SYNC_INT_CTRL.Reg, volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *EXTMEM_Type) GetCACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SYNC_INT_CTRL.Reg) & 0x20) >> 5
}

// EXTMEM.CACHE_CONF_MISC: register description
func (o *EXTMEM_Type) SetCACHE_CONF_MISC_PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONF_MISC.Reg, volatile.LoadUint32(&o.CACHE_CONF_MISC.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCACHE_CONF_MISC_PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT() uint32 {
	return volatile.LoadUint32(&o.CACHE_CONF_MISC.Reg) & 0x1
}
func (o *EXTMEM_Type) SetCACHE_CONF_MISC_PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONF_MISC.Reg, volatile.LoadUint32(&o.CACHE_CONF_MISC.Reg)&^(0x2)|value<<1)
}
func (o *EXTMEM_Type) GetCACHE_CONF_MISC_PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT() uint32 {
	return (volatile.LoadUint32(&o.CACHE_CONF_MISC.Reg) & 0x2) >> 1
}

// EXTMEM.CLOCK_GATE: register description
func (o *EXTMEM_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *EXTMEM_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// EXTMEM.PRO_EXTMEM_REG_DATE: register description
func (o *EXTMEM_Type) SetPRO_EXTMEM_REG_DATE(value uint32) {
	volatile.StoreUint32(&o.PRO_EXTMEM_REG_DATE.Reg, volatile.LoadUint32(&o.PRO_EXTMEM_REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *EXTMEM_Type) GetPRO_EXTMEM_REG_DATE() uint32 {
	return volatile.LoadUint32(&o.PRO_EXTMEM_REG_DATE.Reg) & 0xfffffff
}

// General Purpose Input/Output
type GPIO_Type struct {
	BT_SELECT          volatile.Register32 // 0x0
	OUT                volatile.Register32 // 0x4
	OUT_W1TS           volatile.Register32 // 0x8
	OUT_W1TC           volatile.Register32 // 0xC
	OUT1               volatile.Register32 // 0x10
	OUT1_W1TS          volatile.Register32 // 0x14
	OUT1_W1TC          volatile.Register32 // 0x18
	SDIO_SELECT        volatile.Register32 // 0x1C
	ENABLE             volatile.Register32 // 0x20
	ENABLE_W1TS        volatile.Register32 // 0x24
	ENABLE_W1TC        volatile.Register32 // 0x28
	ENABLE1            volatile.Register32 // 0x2C
	ENABLE1_W1TS       volatile.Register32 // 0x30
	ENABLE1_W1TC       volatile.Register32 // 0x34
	STRAP              volatile.Register32 // 0x38
	IN                 volatile.Register32 // 0x3C
	IN1                volatile.Register32 // 0x40
	STATUS             volatile.Register32 // 0x44
	STATUS_W1TS        volatile.Register32 // 0x48
	STATUS_W1TC        volatile.Register32 // 0x4C
	STATUS1            volatile.Register32 // 0x50
	STATUS1_W1TS       volatile.Register32 // 0x54
	STATUS1_W1TC       volatile.Register32 // 0x58
	PCPU_INT           volatile.Register32 // 0x5C
	PCPU_NMI_INT       volatile.Register32 // 0x60
	CPUSDIO_INT        volatile.Register32 // 0x64
	PCPU_INT1          volatile.Register32 // 0x68
	PCPU_NMI_INT1      volatile.Register32 // 0x6C
	CPUSDIO_INT1       volatile.Register32 // 0x70
	PIN0               volatile.Register32 // 0x74
	PIN1               volatile.Register32 // 0x78
	PIN2               volatile.Register32 // 0x7C
	PIN3               volatile.Register32 // 0x80
	PIN4               volatile.Register32 // 0x84
	PIN5               volatile.Register32 // 0x88
	PIN6               volatile.Register32 // 0x8C
	PIN7               volatile.Register32 // 0x90
	PIN8               volatile.Register32 // 0x94
	PIN9               volatile.Register32 // 0x98
	PIN10              volatile.Register32 // 0x9C
	PIN11              volatile.Register32 // 0xA0
	PIN12              volatile.Register32 // 0xA4
	PIN13              volatile.Register32 // 0xA8
	PIN14              volatile.Register32 // 0xAC
	PIN15              volatile.Register32 // 0xB0
	PIN16              volatile.Register32 // 0xB4
	PIN17              volatile.Register32 // 0xB8
	PIN18              volatile.Register32 // 0xBC
	PIN19              volatile.Register32 // 0xC0
	PIN20              volatile.Register32 // 0xC4
	PIN21              volatile.Register32 // 0xC8
	PIN22              volatile.Register32 // 0xCC
	PIN23              volatile.Register32 // 0xD0
	PIN24              volatile.Register32 // 0xD4
	PIN25              volatile.Register32 // 0xD8
	PIN26              volatile.Register32 // 0xDC
	PIN27              volatile.Register32 // 0xE0
	PIN28              volatile.Register32 // 0xE4
	PIN29              volatile.Register32 // 0xE8
	PIN30              volatile.Register32 // 0xEC
	PIN31              volatile.Register32 // 0xF0
	PIN32              volatile.Register32 // 0xF4
	PIN33              volatile.Register32 // 0xF8
	PIN34              volatile.Register32 // 0xFC
	PIN35              volatile.Register32 // 0x100
	PIN36              volatile.Register32 // 0x104
	PIN37              volatile.Register32 // 0x108
	PIN38              volatile.Register32 // 0x10C
	PIN39              volatile.Register32 // 0x110
	PIN40              volatile.Register32 // 0x114
	PIN41              volatile.Register32 // 0x118
	PIN42              volatile.Register32 // 0x11C
	PIN43              volatile.Register32 // 0x120
	PIN44              volatile.Register32 // 0x124
	PIN45              volatile.Register32 // 0x128
	PIN46              volatile.Register32 // 0x12C
	PIN47              volatile.Register32 // 0x130
	PIN48              volatile.Register32 // 0x134
	PIN49              volatile.Register32 // 0x138
	PIN50              volatile.Register32 // 0x13C
	PIN51              volatile.Register32 // 0x140
	PIN52              volatile.Register32 // 0x144
	PIN53              volatile.Register32 // 0x148
	STATUS_NEXT        volatile.Register32 // 0x14C
	STATUS_NEXT1       volatile.Register32 // 0x150
	FUNC0_IN_SEL_CFG   volatile.Register32 // 0x154
	FUNC1_IN_SEL_CFG   volatile.Register32 // 0x158
	FUNC2_IN_SEL_CFG   volatile.Register32 // 0x15C
	FUNC3_IN_SEL_CFG   volatile.Register32 // 0x160
	FUNC4_IN_SEL_CFG   volatile.Register32 // 0x164
	FUNC5_IN_SEL_CFG   volatile.Register32 // 0x168
	FUNC6_IN_SEL_CFG   volatile.Register32 // 0x16C
	FUNC7_IN_SEL_CFG   volatile.Register32 // 0x170
	FUNC8_IN_SEL_CFG   volatile.Register32 // 0x174
	FUNC9_IN_SEL_CFG   volatile.Register32 // 0x178
	FUNC10_IN_SEL_CFG  volatile.Register32 // 0x17C
	FUNC11_IN_SEL_CFG  volatile.Register32 // 0x180
	FUNC12_IN_SEL_CFG  volatile.Register32 // 0x184
	FUNC13_IN_SEL_CFG  volatile.Register32 // 0x188
	FUNC14_IN_SEL_CFG  volatile.Register32 // 0x18C
	FUNC15_IN_SEL_CFG  volatile.Register32 // 0x190
	FUNC16_IN_SEL_CFG  volatile.Register32 // 0x194
	FUNC17_IN_SEL_CFG  volatile.Register32 // 0x198
	FUNC18_IN_SEL_CFG  volatile.Register32 // 0x19C
	FUNC19_IN_SEL_CFG  volatile.Register32 // 0x1A0
	FUNC20_IN_SEL_CFG  volatile.Register32 // 0x1A4
	FUNC21_IN_SEL_CFG  volatile.Register32 // 0x1A8
	FUNC22_IN_SEL_CFG  volatile.Register32 // 0x1AC
	FUNC23_IN_SEL_CFG  volatile.Register32 // 0x1B0
	FUNC24_IN_SEL_CFG  volatile.Register32 // 0x1B4
	FUNC25_IN_SEL_CFG  volatile.Register32 // 0x1B8
	FUNC26_IN_SEL_CFG  volatile.Register32 // 0x1BC
	FUNC27_IN_SEL_CFG  volatile.Register32 // 0x1C0
	FUNC28_IN_SEL_CFG  volatile.Register32 // 0x1C4
	FUNC29_IN_SEL_CFG  volatile.Register32 // 0x1C8
	FUNC30_IN_SEL_CFG  volatile.Register32 // 0x1CC
	FUNC31_IN_SEL_CFG  volatile.Register32 // 0x1D0
	FUNC32_IN_SEL_CFG  volatile.Register32 // 0x1D4
	FUNC33_IN_SEL_CFG  volatile.Register32 // 0x1D8
	FUNC34_IN_SEL_CFG  volatile.Register32 // 0x1DC
	FUNC35_IN_SEL_CFG  volatile.Register32 // 0x1E0
	FUNC36_IN_SEL_CFG  volatile.Register32 // 0x1E4
	FUNC37_IN_SEL_CFG  volatile.Register32 // 0x1E8
	FUNC38_IN_SEL_CFG  volatile.Register32 // 0x1EC
	FUNC39_IN_SEL_CFG  volatile.Register32 // 0x1F0
	FUNC40_IN_SEL_CFG  volatile.Register32 // 0x1F4
	FUNC41_IN_SEL_CFG  volatile.Register32 // 0x1F8
	FUNC42_IN_SEL_CFG  volatile.Register32 // 0x1FC
	FUNC43_IN_SEL_CFG  volatile.Register32 // 0x200
	FUNC44_IN_SEL_CFG  volatile.Register32 // 0x204
	FUNC45_IN_SEL_CFG  volatile.Register32 // 0x208
	FUNC46_IN_SEL_CFG  volatile.Register32 // 0x20C
	FUNC47_IN_SEL_CFG  volatile.Register32 // 0x210
	FUNC48_IN_SEL_CFG  volatile.Register32 // 0x214
	FUNC49_IN_SEL_CFG  volatile.Register32 // 0x218
	FUNC50_IN_SEL_CFG  volatile.Register32 // 0x21C
	FUNC51_IN_SEL_CFG  volatile.Register32 // 0x220
	FUNC52_IN_SEL_CFG  volatile.Register32 // 0x224
	FUNC53_IN_SEL_CFG  volatile.Register32 // 0x228
	FUNC54_IN_SEL_CFG  volatile.Register32 // 0x22C
	FUNC55_IN_SEL_CFG  volatile.Register32 // 0x230
	FUNC56_IN_SEL_CFG  volatile.Register32 // 0x234
	FUNC57_IN_SEL_CFG  volatile.Register32 // 0x238
	FUNC58_IN_SEL_CFG  volatile.Register32 // 0x23C
	FUNC59_IN_SEL_CFG  volatile.Register32 // 0x240
	FUNC60_IN_SEL_CFG  volatile.Register32 // 0x244
	FUNC61_IN_SEL_CFG  volatile.Register32 // 0x248
	FUNC62_IN_SEL_CFG  volatile.Register32 // 0x24C
	FUNC63_IN_SEL_CFG  volatile.Register32 // 0x250
	FUNC64_IN_SEL_CFG  volatile.Register32 // 0x254
	FUNC65_IN_SEL_CFG  volatile.Register32 // 0x258
	FUNC66_IN_SEL_CFG  volatile.Register32 // 0x25C
	FUNC67_IN_SEL_CFG  volatile.Register32 // 0x260
	FUNC68_IN_SEL_CFG  volatile.Register32 // 0x264
	FUNC69_IN_SEL_CFG  volatile.Register32 // 0x268
	FUNC70_IN_SEL_CFG  volatile.Register32 // 0x26C
	FUNC71_IN_SEL_CFG  volatile.Register32 // 0x270
	FUNC72_IN_SEL_CFG  volatile.Register32 // 0x274
	FUNC73_IN_SEL_CFG  volatile.Register32 // 0x278
	FUNC74_IN_SEL_CFG  volatile.Register32 // 0x27C
	FUNC75_IN_SEL_CFG  volatile.Register32 // 0x280
	FUNC76_IN_SEL_CFG  volatile.Register32 // 0x284
	FUNC77_IN_SEL_CFG  volatile.Register32 // 0x288
	FUNC78_IN_SEL_CFG  volatile.Register32 // 0x28C
	FUNC79_IN_SEL_CFG  volatile.Register32 // 0x290
	FUNC80_IN_SEL_CFG  volatile.Register32 // 0x294
	FUNC81_IN_SEL_CFG  volatile.Register32 // 0x298
	FUNC82_IN_SEL_CFG  volatile.Register32 // 0x29C
	FUNC83_IN_SEL_CFG  volatile.Register32 // 0x2A0
	FUNC84_IN_SEL_CFG  volatile.Register32 // 0x2A4
	FUNC85_IN_SEL_CFG  volatile.Register32 // 0x2A8
	FUNC86_IN_SEL_CFG  volatile.Register32 // 0x2AC
	FUNC87_IN_SEL_CFG  volatile.Register32 // 0x2B0
	FUNC88_IN_SEL_CFG  volatile.Register32 // 0x2B4
	FUNC89_IN_SEL_CFG  volatile.Register32 // 0x2B8
	FUNC90_IN_SEL_CFG  volatile.Register32 // 0x2BC
	FUNC91_IN_SEL_CFG  volatile.Register32 // 0x2C0
	FUNC92_IN_SEL_CFG  volatile.Register32 // 0x2C4
	FUNC93_IN_SEL_CFG  volatile.Register32 // 0x2C8
	FUNC94_IN_SEL_CFG  volatile.Register32 // 0x2CC
	FUNC95_IN_SEL_CFG  volatile.Register32 // 0x2D0
	FUNC96_IN_SEL_CFG  volatile.Register32 // 0x2D4
	FUNC97_IN_SEL_CFG  volatile.Register32 // 0x2D8
	FUNC98_IN_SEL_CFG  volatile.Register32 // 0x2DC
	FUNC99_IN_SEL_CFG  volatile.Register32 // 0x2E0
	FUNC100_IN_SEL_CFG volatile.Register32 // 0x2E4
	FUNC101_IN_SEL_CFG volatile.Register32 // 0x2E8
	FUNC102_IN_SEL_CFG volatile.Register32 // 0x2EC
	FUNC103_IN_SEL_CFG volatile.Register32 // 0x2F0
	FUNC104_IN_SEL_CFG volatile.Register32 // 0x2F4
	FUNC105_IN_SEL_CFG volatile.Register32 // 0x2F8
	FUNC106_IN_SEL_CFG volatile.Register32 // 0x2FC
	FUNC107_IN_SEL_CFG volatile.Register32 // 0x300
	FUNC108_IN_SEL_CFG volatile.Register32 // 0x304
	FUNC109_IN_SEL_CFG volatile.Register32 // 0x308
	FUNC110_IN_SEL_CFG volatile.Register32 // 0x30C
	FUNC111_IN_SEL_CFG volatile.Register32 // 0x310
	FUNC112_IN_SEL_CFG volatile.Register32 // 0x314
	FUNC113_IN_SEL_CFG volatile.Register32 // 0x318
	FUNC114_IN_SEL_CFG volatile.Register32 // 0x31C
	FUNC115_IN_SEL_CFG volatile.Register32 // 0x320
	FUNC116_IN_SEL_CFG volatile.Register32 // 0x324
	FUNC117_IN_SEL_CFG volatile.Register32 // 0x328
	FUNC118_IN_SEL_CFG volatile.Register32 // 0x32C
	FUNC119_IN_SEL_CFG volatile.Register32 // 0x330
	FUNC120_IN_SEL_CFG volatile.Register32 // 0x334
	FUNC121_IN_SEL_CFG volatile.Register32 // 0x338
	FUNC122_IN_SEL_CFG volatile.Register32 // 0x33C
	FUNC123_IN_SEL_CFG volatile.Register32 // 0x340
	FUNC124_IN_SEL_CFG volatile.Register32 // 0x344
	FUNC125_IN_SEL_CFG volatile.Register32 // 0x348
	FUNC126_IN_SEL_CFG volatile.Register32 // 0x34C
	FUNC127_IN_SEL_CFG volatile.Register32 // 0x350
	FUNC128_IN_SEL_CFG volatile.Register32 // 0x354
	FUNC129_IN_SEL_CFG volatile.Register32 // 0x358
	FUNC130_IN_SEL_CFG volatile.Register32 // 0x35C
	FUNC131_IN_SEL_CFG volatile.Register32 // 0x360
	FUNC132_IN_SEL_CFG volatile.Register32 // 0x364
	FUNC133_IN_SEL_CFG volatile.Register32 // 0x368
	FUNC134_IN_SEL_CFG volatile.Register32 // 0x36C
	FUNC135_IN_SEL_CFG volatile.Register32 // 0x370
	FUNC136_IN_SEL_CFG volatile.Register32 // 0x374
	FUNC137_IN_SEL_CFG volatile.Register32 // 0x378
	FUNC138_IN_SEL_CFG volatile.Register32 // 0x37C
	FUNC139_IN_SEL_CFG volatile.Register32 // 0x380
	FUNC140_IN_SEL_CFG volatile.Register32 // 0x384
	FUNC141_IN_SEL_CFG volatile.Register32 // 0x388
	FUNC142_IN_SEL_CFG volatile.Register32 // 0x38C
	FUNC143_IN_SEL_CFG volatile.Register32 // 0x390
	FUNC144_IN_SEL_CFG volatile.Register32 // 0x394
	FUNC145_IN_SEL_CFG volatile.Register32 // 0x398
	FUNC146_IN_SEL_CFG volatile.Register32 // 0x39C
	FUNC147_IN_SEL_CFG volatile.Register32 // 0x3A0
	FUNC148_IN_SEL_CFG volatile.Register32 // 0x3A4
	FUNC149_IN_SEL_CFG volatile.Register32 // 0x3A8
	FUNC150_IN_SEL_CFG volatile.Register32 // 0x3AC
	FUNC151_IN_SEL_CFG volatile.Register32 // 0x3B0
	FUNC152_IN_SEL_CFG volatile.Register32 // 0x3B4
	FUNC153_IN_SEL_CFG volatile.Register32 // 0x3B8
	FUNC154_IN_SEL_CFG volatile.Register32 // 0x3BC
	FUNC155_IN_SEL_CFG volatile.Register32 // 0x3C0
	FUNC156_IN_SEL_CFG volatile.Register32 // 0x3C4
	FUNC157_IN_SEL_CFG volatile.Register32 // 0x3C8
	FUNC158_IN_SEL_CFG volatile.Register32 // 0x3CC
	FUNC159_IN_SEL_CFG volatile.Register32 // 0x3D0
	FUNC160_IN_SEL_CFG volatile.Register32 // 0x3D4
	FUNC161_IN_SEL_CFG volatile.Register32 // 0x3D8
	FUNC162_IN_SEL_CFG volatile.Register32 // 0x3DC
	FUNC163_IN_SEL_CFG volatile.Register32 // 0x3E0
	FUNC164_IN_SEL_CFG volatile.Register32 // 0x3E4
	FUNC165_IN_SEL_CFG volatile.Register32 // 0x3E8
	FUNC166_IN_SEL_CFG volatile.Register32 // 0x3EC
	FUNC167_IN_SEL_CFG volatile.Register32 // 0x3F0
	FUNC168_IN_SEL_CFG volatile.Register32 // 0x3F4
	FUNC169_IN_SEL_CFG volatile.Register32 // 0x3F8
	FUNC170_IN_SEL_CFG volatile.Register32 // 0x3FC
	FUNC171_IN_SEL_CFG volatile.Register32 // 0x400
	FUNC172_IN_SEL_CFG volatile.Register32 // 0x404
	FUNC173_IN_SEL_CFG volatile.Register32 // 0x408
	FUNC174_IN_SEL_CFG volatile.Register32 // 0x40C
	FUNC175_IN_SEL_CFG volatile.Register32 // 0x410
	FUNC176_IN_SEL_CFG volatile.Register32 // 0x414
	FUNC177_IN_SEL_CFG volatile.Register32 // 0x418
	FUNC178_IN_SEL_CFG volatile.Register32 // 0x41C
	FUNC179_IN_SEL_CFG volatile.Register32 // 0x420
	FUNC180_IN_SEL_CFG volatile.Register32 // 0x424
	FUNC181_IN_SEL_CFG volatile.Register32 // 0x428
	FUNC182_IN_SEL_CFG volatile.Register32 // 0x42C
	FUNC183_IN_SEL_CFG volatile.Register32 // 0x430
	FUNC184_IN_SEL_CFG volatile.Register32 // 0x434
	FUNC185_IN_SEL_CFG volatile.Register32 // 0x438
	FUNC186_IN_SEL_CFG volatile.Register32 // 0x43C
	FUNC187_IN_SEL_CFG volatile.Register32 // 0x440
	FUNC188_IN_SEL_CFG volatile.Register32 // 0x444
	FUNC189_IN_SEL_CFG volatile.Register32 // 0x448
	FUNC190_IN_SEL_CFG volatile.Register32 // 0x44C
	FUNC191_IN_SEL_CFG volatile.Register32 // 0x450
	FUNC192_IN_SEL_CFG volatile.Register32 // 0x454
	FUNC193_IN_SEL_CFG volatile.Register32 // 0x458
	FUNC194_IN_SEL_CFG volatile.Register32 // 0x45C
	FUNC195_IN_SEL_CFG volatile.Register32 // 0x460
	FUNC196_IN_SEL_CFG volatile.Register32 // 0x464
	FUNC197_IN_SEL_CFG volatile.Register32 // 0x468
	FUNC198_IN_SEL_CFG volatile.Register32 // 0x46C
	FUNC199_IN_SEL_CFG volatile.Register32 // 0x470
	FUNC200_IN_SEL_CFG volatile.Register32 // 0x474
	FUNC201_IN_SEL_CFG volatile.Register32 // 0x478
	FUNC202_IN_SEL_CFG volatile.Register32 // 0x47C
	FUNC203_IN_SEL_CFG volatile.Register32 // 0x480
	FUNC204_IN_SEL_CFG volatile.Register32 // 0x484
	FUNC205_IN_SEL_CFG volatile.Register32 // 0x488
	FUNC206_IN_SEL_CFG volatile.Register32 // 0x48C
	FUNC207_IN_SEL_CFG volatile.Register32 // 0x490
	FUNC208_IN_SEL_CFG volatile.Register32 // 0x494
	FUNC209_IN_SEL_CFG volatile.Register32 // 0x498
	FUNC210_IN_SEL_CFG volatile.Register32 // 0x49C
	FUNC211_IN_SEL_CFG volatile.Register32 // 0x4A0
	FUNC212_IN_SEL_CFG volatile.Register32 // 0x4A4
	FUNC213_IN_SEL_CFG volatile.Register32 // 0x4A8
	FUNC214_IN_SEL_CFG volatile.Register32 // 0x4AC
	FUNC215_IN_SEL_CFG volatile.Register32 // 0x4B0
	FUNC216_IN_SEL_CFG volatile.Register32 // 0x4B4
	FUNC217_IN_SEL_CFG volatile.Register32 // 0x4B8
	FUNC218_IN_SEL_CFG volatile.Register32 // 0x4BC
	FUNC219_IN_SEL_CFG volatile.Register32 // 0x4C0
	FUNC220_IN_SEL_CFG volatile.Register32 // 0x4C4
	FUNC221_IN_SEL_CFG volatile.Register32 // 0x4C8
	FUNC222_IN_SEL_CFG volatile.Register32 // 0x4CC
	FUNC223_IN_SEL_CFG volatile.Register32 // 0x4D0
	FUNC224_IN_SEL_CFG volatile.Register32 // 0x4D4
	FUNC225_IN_SEL_CFG volatile.Register32 // 0x4D8
	FUNC226_IN_SEL_CFG volatile.Register32 // 0x4DC
	FUNC227_IN_SEL_CFG volatile.Register32 // 0x4E0
	FUNC228_IN_SEL_CFG volatile.Register32 // 0x4E4
	FUNC229_IN_SEL_CFG volatile.Register32 // 0x4E8
	FUNC230_IN_SEL_CFG volatile.Register32 // 0x4EC
	FUNC231_IN_SEL_CFG volatile.Register32 // 0x4F0
	FUNC232_IN_SEL_CFG volatile.Register32 // 0x4F4
	FUNC233_IN_SEL_CFG volatile.Register32 // 0x4F8
	FUNC234_IN_SEL_CFG volatile.Register32 // 0x4FC
	FUNC235_IN_SEL_CFG volatile.Register32 // 0x500
	FUNC236_IN_SEL_CFG volatile.Register32 // 0x504
	FUNC237_IN_SEL_CFG volatile.Register32 // 0x508
	FUNC238_IN_SEL_CFG volatile.Register32 // 0x50C
	FUNC239_IN_SEL_CFG volatile.Register32 // 0x510
	FUNC240_IN_SEL_CFG volatile.Register32 // 0x514
	FUNC241_IN_SEL_CFG volatile.Register32 // 0x518
	FUNC242_IN_SEL_CFG volatile.Register32 // 0x51C
	FUNC243_IN_SEL_CFG volatile.Register32 // 0x520
	FUNC244_IN_SEL_CFG volatile.Register32 // 0x524
	FUNC245_IN_SEL_CFG volatile.Register32 // 0x528
	FUNC246_IN_SEL_CFG volatile.Register32 // 0x52C
	FUNC247_IN_SEL_CFG volatile.Register32 // 0x530
	FUNC248_IN_SEL_CFG volatile.Register32 // 0x534
	FUNC249_IN_SEL_CFG volatile.Register32 // 0x538
	FUNC250_IN_SEL_CFG volatile.Register32 // 0x53C
	FUNC251_IN_SEL_CFG volatile.Register32 // 0x540
	FUNC252_IN_SEL_CFG volatile.Register32 // 0x544
	FUNC253_IN_SEL_CFG volatile.Register32 // 0x548
	FUNC254_IN_SEL_CFG volatile.Register32 // 0x54C
	FUNC255_IN_SEL_CFG volatile.Register32 // 0x550
	FUNC0_OUT_SEL_CFG  volatile.Register32 // 0x554
	FUNC1_OUT_SEL_CFG  volatile.Register32 // 0x558
	FUNC2_OUT_SEL_CFG  volatile.Register32 // 0x55C
	FUNC3_OUT_SEL_CFG  volatile.Register32 // 0x560
	FUNC4_OUT_SEL_CFG  volatile.Register32 // 0x564
	FUNC5_OUT_SEL_CFG  volatile.Register32 // 0x568
	FUNC6_OUT_SEL_CFG  volatile.Register32 // 0x56C
	FUNC7_OUT_SEL_CFG  volatile.Register32 // 0x570
	FUNC8_OUT_SEL_CFG  volatile.Register32 // 0x574
	FUNC9_OUT_SEL_CFG  volatile.Register32 // 0x578
	FUNC10_OUT_SEL_CFG volatile.Register32 // 0x57C
	FUNC11_OUT_SEL_CFG volatile.Register32 // 0x580
	FUNC12_OUT_SEL_CFG volatile.Register32 // 0x584
	FUNC13_OUT_SEL_CFG volatile.Register32 // 0x588
	FUNC14_OUT_SEL_CFG volatile.Register32 // 0x58C
	FUNC15_OUT_SEL_CFG volatile.Register32 // 0x590
	FUNC16_OUT_SEL_CFG volatile.Register32 // 0x594
	FUNC17_OUT_SEL_CFG volatile.Register32 // 0x598
	FUNC18_OUT_SEL_CFG volatile.Register32 // 0x59C
	FUNC19_OUT_SEL_CFG volatile.Register32 // 0x5A0
	FUNC20_OUT_SEL_CFG volatile.Register32 // 0x5A4
	FUNC21_OUT_SEL_CFG volatile.Register32 // 0x5A8
	FUNC22_OUT_SEL_CFG volatile.Register32 // 0x5AC
	FUNC23_OUT_SEL_CFG volatile.Register32 // 0x5B0
	FUNC24_OUT_SEL_CFG volatile.Register32 // 0x5B4
	FUNC25_OUT_SEL_CFG volatile.Register32 // 0x5B8
	FUNC26_OUT_SEL_CFG volatile.Register32 // 0x5BC
	FUNC27_OUT_SEL_CFG volatile.Register32 // 0x5C0
	FUNC28_OUT_SEL_CFG volatile.Register32 // 0x5C4
	FUNC29_OUT_SEL_CFG volatile.Register32 // 0x5C8
	FUNC30_OUT_SEL_CFG volatile.Register32 // 0x5CC
	FUNC31_OUT_SEL_CFG volatile.Register32 // 0x5D0
	FUNC32_OUT_SEL_CFG volatile.Register32 // 0x5D4
	FUNC33_OUT_SEL_CFG volatile.Register32 // 0x5D8
	FUNC34_OUT_SEL_CFG volatile.Register32 // 0x5DC
	FUNC35_OUT_SEL_CFG volatile.Register32 // 0x5E0
	FUNC36_OUT_SEL_CFG volatile.Register32 // 0x5E4
	FUNC37_OUT_SEL_CFG volatile.Register32 // 0x5E8
	FUNC38_OUT_SEL_CFG volatile.Register32 // 0x5EC
	FUNC39_OUT_SEL_CFG volatile.Register32 // 0x5F0
	FUNC40_OUT_SEL_CFG volatile.Register32 // 0x5F4
	FUNC41_OUT_SEL_CFG volatile.Register32 // 0x5F8
	FUNC42_OUT_SEL_CFG volatile.Register32 // 0x5FC
	FUNC43_OUT_SEL_CFG volatile.Register32 // 0x600
	FUNC44_OUT_SEL_CFG volatile.Register32 // 0x604
	FUNC45_OUT_SEL_CFG volatile.Register32 // 0x608
	FUNC46_OUT_SEL_CFG volatile.Register32 // 0x60C
	FUNC47_OUT_SEL_CFG volatile.Register32 // 0x610
	FUNC48_OUT_SEL_CFG volatile.Register32 // 0x614
	FUNC49_OUT_SEL_CFG volatile.Register32 // 0x618
	FUNC50_OUT_SEL_CFG volatile.Register32 // 0x61C
	FUNC51_OUT_SEL_CFG volatile.Register32 // 0x620
	FUNC52_OUT_SEL_CFG volatile.Register32 // 0x624
	FUNC53_OUT_SEL_CFG volatile.Register32 // 0x628
	CLOCK_GATE         volatile.Register32 // 0x62C
	_                  [204]byte
	REG_DATE           volatile.Register32 // 0x6FC
}

// GPIO.BT_SELECT: GPIO bit select register
func (o *GPIO_Type) SetBT_SELECT(value uint32) {
	volatile.StoreUint32(&o.BT_SELECT.Reg, value)
}
func (o *GPIO_Type) GetBT_SELECT() uint32 {
	return volatile.LoadUint32(&o.BT_SELECT.Reg)
}

// GPIO.OUT: GPIO0 ~ 31 output register
func (o *GPIO_Type) SetOUT(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, value)
}
func (o *GPIO_Type) GetOUT() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg)
}

// GPIO.OUT_W1TS: GPIO0 ~ 31 output bit set register
func (o *GPIO_Type) SetOUT_W1TS(value uint32) {
	volatile.StoreUint32(&o.OUT_W1TS.Reg, value)
}
func (o *GPIO_Type) GetOUT_W1TS() uint32 {
	return volatile.LoadUint32(&o.OUT_W1TS.Reg)
}

// GPIO.OUT_W1TC: GPIO0 ~ 31 output bit clear register
func (o *GPIO_Type) SetOUT_W1TC(value uint32) {
	volatile.StoreUint32(&o.OUT_W1TC.Reg, value)
}
func (o *GPIO_Type) GetOUT_W1TC() uint32 {
	return volatile.LoadUint32(&o.OUT_W1TC.Reg)
}

// GPIO.OUT1: GPIO32 ~ 53 output register
func (o *GPIO_Type) SetOUT1_DATA_ORIG(value uint32) {
	volatile.StoreUint32(&o.OUT1.Reg, volatile.LoadUint32(&o.OUT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetOUT1_DATA_ORIG() uint32 {
	return volatile.LoadUint32(&o.OUT1.Reg) & 0x3fffff
}

// GPIO.OUT1_W1TS: GPIO32 ~ 53 output bit set register
func (o *GPIO_Type) SetOUT1_W1TS(value uint32) {
	volatile.StoreUint32(&o.OUT1_W1TS.Reg, volatile.LoadUint32(&o.OUT1_W1TS.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetOUT1_W1TS() uint32 {
	return volatile.LoadUint32(&o.OUT1_W1TS.Reg) & 0x3fffff
}

// GPIO.OUT1_W1TC: GPIO32 ~ 53 output bit clear register
func (o *GPIO_Type) SetOUT1_W1TC(value uint32) {
	volatile.StoreUint32(&o.OUT1_W1TC.Reg, volatile.LoadUint32(&o.OUT1_W1TC.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetOUT1_W1TC() uint32 {
	return volatile.LoadUint32(&o.OUT1_W1TC.Reg) & 0x3fffff
}

// GPIO.SDIO_SELECT: GPIO SDIO selection register
func (o *GPIO_Type) SetSDIO_SELECT_SDIO_SEL(value uint32) {
	volatile.StoreUint32(&o.SDIO_SELECT.Reg, volatile.LoadUint32(&o.SDIO_SELECT.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetSDIO_SELECT_SDIO_SEL() uint32 {
	return volatile.LoadUint32(&o.SDIO_SELECT.Reg) & 0xff
}

// GPIO.ENABLE: GPIO0 ~ 31 output enable register
func (o *GPIO_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, value)
}
func (o *GPIO_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg)
}

// GPIO.ENABLE_W1TS: GPIO0 ~ 31 output enable bit set register
func (o *GPIO_Type) SetENABLE_W1TS(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TS.Reg, value)
}
func (o *GPIO_Type) GetENABLE_W1TS() uint32 {
	return volatile.LoadUint32(&o.ENABLE_W1TS.Reg)
}

// GPIO.ENABLE_W1TC: GPIO0 ~ 31 output enable bit clear register
func (o *GPIO_Type) SetENABLE_W1TC(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TC.Reg, value)
}
func (o *GPIO_Type) GetENABLE_W1TC() uint32 {
	return volatile.LoadUint32(&o.ENABLE_W1TC.Reg)
}

// GPIO.ENABLE1: GPIO32 ~ 53 output enable register
func (o *GPIO_Type) SetENABLE1_DATA(value uint32) {
	volatile.StoreUint32(&o.ENABLE1.Reg, volatile.LoadUint32(&o.ENABLE1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetENABLE1_DATA() uint32 {
	return volatile.LoadUint32(&o.ENABLE1.Reg) & 0x3fffff
}

// GPIO.ENABLE1_W1TS: GPIO32 ~ 53 output enable bit set register
func (o *GPIO_Type) SetENABLE1_W1TS(value uint32) {
	volatile.StoreUint32(&o.ENABLE1_W1TS.Reg, volatile.LoadUint32(&o.ENABLE1_W1TS.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetENABLE1_W1TS() uint32 {
	return volatile.LoadUint32(&o.ENABLE1_W1TS.Reg) & 0x3fffff
}

// GPIO.ENABLE1_W1TC: GPIO32 ~ 53 output enable bit clear register
func (o *GPIO_Type) SetENABLE1_W1TC(value uint32) {
	volatile.StoreUint32(&o.ENABLE1_W1TC.Reg, volatile.LoadUint32(&o.ENABLE1_W1TC.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetENABLE1_W1TC() uint32 {
	return volatile.LoadUint32(&o.ENABLE1_W1TC.Reg) & 0x3fffff
}

// GPIO.STRAP: Bootstrap pin value register
func (o *GPIO_Type) SetSTRAP_STRAPPING(value uint32) {
	volatile.StoreUint32(&o.STRAP.Reg, volatile.LoadUint32(&o.STRAP.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetSTRAP_STRAPPING() uint32 {
	return volatile.LoadUint32(&o.STRAP.Reg) & 0xffff
}

// GPIO.IN: GPIO0 ~ 31 input register
func (o *GPIO_Type) SetIN(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, value)
}
func (o *GPIO_Type) GetIN() uint32 {
	return volatile.LoadUint32(&o.IN.Reg)
}

// GPIO.IN1: GPIO32 ~ 53 input register
func (o *GPIO_Type) SetIN1_IN_DATA1_NEXT(value uint32) {
	volatile.StoreUint32(&o.IN1.Reg, volatile.LoadUint32(&o.IN1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetIN1_IN_DATA1_NEXT() uint32 {
	return volatile.LoadUint32(&o.IN1.Reg) & 0x3fffff
}

// GPIO.STATUS: GPIO0 ~ 31 interrupt status register
func (o *GPIO_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, value)
}
func (o *GPIO_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg)
}

// GPIO.STATUS_W1TS: GPIO0 ~ 31 interrupt status bit set register
func (o *GPIO_Type) SetSTATUS_W1TS(value uint32) {
	volatile.StoreUint32(&o.STATUS_W1TS.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_W1TS() uint32 {
	return volatile.LoadUint32(&o.STATUS_W1TS.Reg)
}

// GPIO.STATUS_W1TC: GPIO0 ~ 31 interrupt status bit clear register
func (o *GPIO_Type) SetSTATUS_W1TC(value uint32) {
	volatile.StoreUint32(&o.STATUS_W1TC.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_W1TC() uint32 {
	return volatile.LoadUint32(&o.STATUS_W1TC.Reg)
}

// GPIO.STATUS1: GPIO32 ~ 53 interrupt status register
func (o *GPIO_Type) SetSTATUS1_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.STATUS1.Reg, volatile.LoadUint32(&o.STATUS1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS1_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.STATUS1.Reg) & 0x3fffff
}

// GPIO.STATUS1_W1TS: GPIO32 ~ 53 interrupt status bit set register
func (o *GPIO_Type) SetSTATUS1_W1TS(value uint32) {
	volatile.StoreUint32(&o.STATUS1_W1TS.Reg, volatile.LoadUint32(&o.STATUS1_W1TS.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS1_W1TS() uint32 {
	return volatile.LoadUint32(&o.STATUS1_W1TS.Reg) & 0x3fffff
}

// GPIO.STATUS1_W1TC: GPIO32 ~ 53 interrupt status bit clear register
func (o *GPIO_Type) SetSTATUS1_W1TC(value uint32) {
	volatile.StoreUint32(&o.STATUS1_W1TC.Reg, volatile.LoadUint32(&o.STATUS1_W1TC.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS1_W1TC() uint32 {
	return volatile.LoadUint32(&o.STATUS1_W1TC.Reg) & 0x3fffff
}

// GPIO.PCPU_INT: GPIO0 ~ 31 PRO_CPU interrupt status register
func (o *GPIO_Type) SetPCPU_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_INT.Reg, value)
}
func (o *GPIO_Type) GetPCPU_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_INT.Reg)
}

// GPIO.PCPU_NMI_INT: GPIO0 ~ 31 PRO_CPU non-maskable interrupt status register
func (o *GPIO_Type) SetPCPU_NMI_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_NMI_INT.Reg, value)
}
func (o *GPIO_Type) GetPCPU_NMI_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_NMI_INT.Reg)
}

// GPIO.CPUSDIO_INT: GPIO0 ~ 31 CPU SDIO interrupt status register
func (o *GPIO_Type) SetCPUSDIO_INT(value uint32) {
	volatile.StoreUint32(&o.CPUSDIO_INT.Reg, value)
}
func (o *GPIO_Type) GetCPUSDIO_INT() uint32 {
	return volatile.LoadUint32(&o.CPUSDIO_INT.Reg)
}

// GPIO.PCPU_INT1: GPIO32 ~ 53 PRO_CPU interrupt status register
func (o *GPIO_Type) SetPCPU_INT1_PROCPU1_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_INT1.Reg, volatile.LoadUint32(&o.PCPU_INT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetPCPU_INT1_PROCPU1_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_INT1.Reg) & 0x3fffff
}

// GPIO.PCPU_NMI_INT1: GPIO32 ~ 53 PRO_CPU non-maskable interrupt status register
func (o *GPIO_Type) SetPCPU_NMI_INT1_PROCPU_NMI1_INT(value uint32) {
	volatile.StoreUint32(&o.PCPU_NMI_INT1.Reg, volatile.LoadUint32(&o.PCPU_NMI_INT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetPCPU_NMI_INT1_PROCPU_NMI1_INT() uint32 {
	return volatile.LoadUint32(&o.PCPU_NMI_INT1.Reg) & 0x3fffff
}

// GPIO.CPUSDIO_INT1: GPIO32 ~ 53 CPU SDIO interrupt status register
func (o *GPIO_Type) SetCPUSDIO_INT1_SDIO1_INT(value uint32) {
	volatile.StoreUint32(&o.CPUSDIO_INT1.Reg, volatile.LoadUint32(&o.CPUSDIO_INT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetCPUSDIO_INT1_SDIO1_INT() uint32 {
	return volatile.LoadUint32(&o.CPUSDIO_INT1.Reg) & 0x3fffff
}

// GPIO.PIN0: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN0_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN0_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN0.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN0_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN0_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN0_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN0_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x3e000) >> 13
}

// GPIO.PIN1: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN1_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN1_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN1.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN1_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN1_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN1_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN1_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN1_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN1_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN1_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN1_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN1_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN1_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x3e000) >> 13
}

// GPIO.PIN2: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN2_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN2_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN2.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN2_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN2_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN2_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN2_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN2_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN2_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN2_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN2_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN2_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN2_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x3e000) >> 13
}

// GPIO.PIN3: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN3_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN3_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN3.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN3_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN3_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN3_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN3_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN3_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN3_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN3_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN3_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN3_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN3_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x3e000) >> 13
}

// GPIO.PIN4: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN4_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN4_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN4.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN4_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN4_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN4_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN4_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN4_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN4_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN4_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN4_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN4_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN4_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x3e000) >> 13
}

// GPIO.PIN5: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN5_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN5_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN5.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN5_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN5_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN5_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN5_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN5_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN5_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN5_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN5_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN5_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN5_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x3e000) >> 13
}

// GPIO.PIN6: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN6_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN6_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN6.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN6_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN6_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN6_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN6_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN6_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN6_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN6_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN6_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN6_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN6_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x3e000) >> 13
}

// GPIO.PIN7: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN7_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN7_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN7.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN7_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN7_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN7_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN7_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN7_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN7_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN7_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN7_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN7_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN7_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x3e000) >> 13
}

// GPIO.PIN8: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN8_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN8_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN8.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN8_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN8_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN8_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN8_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN8_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN8_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN8_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN8_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN8_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN8_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN8_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN8_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x3e000) >> 13
}

// GPIO.PIN9: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN9_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN9_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN9.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN9_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN9_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN9_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN9_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN9_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN9_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN9_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN9_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN9_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN9_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN9_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN9_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x3e000) >> 13
}

// GPIO.PIN10: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN10_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN10_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN10.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN10_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN10_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN10_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN10_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN10_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN10_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN10_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN10_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN10_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN10_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN10_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN10_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x3e000) >> 13
}

// GPIO.PIN11: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN11_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN11_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN11.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN11_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN11_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN11_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN11_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN11_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN11_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN11_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN11_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN11_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN11_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN11_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN11_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x3e000) >> 13
}

// GPIO.PIN12: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN12_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN12_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN12.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN12_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN12_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN12_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN12_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN12_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN12_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN12_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN12_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN12_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN12_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN12_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN12_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x3e000) >> 13
}

// GPIO.PIN13: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN13_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN13_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN13.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN13_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN13_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN13_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN13_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN13_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN13_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN13_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN13_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN13_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN13_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN13_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN13_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x3e000) >> 13
}

// GPIO.PIN14: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN14_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN14_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN14.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN14_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN14_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN14_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN14_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN14_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN14_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN14_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN14_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN14_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN14_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN14_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN14_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x3e000) >> 13
}

// GPIO.PIN15: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN15_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN15_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN15.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN15_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN15_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN15_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN15_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN15_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN15_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN15_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN15_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN15_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN15_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN15_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN15_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x3e000) >> 13
}

// GPIO.PIN16: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN16_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN16_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN16.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN16_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN16_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN16_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN16_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN16_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN16_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN16_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN16_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN16_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN16_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN16_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN16_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x3e000) >> 13
}

// GPIO.PIN17: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN17_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN17_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN17.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN17_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN17_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN17_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN17_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN17_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN17_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN17_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN17_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN17_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN17_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN17_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN17_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x3e000) >> 13
}

// GPIO.PIN18: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN18_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN18_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN18.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN18_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN18_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN18_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN18_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN18_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN18_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN18_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN18_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN18_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN18_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN18_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN18_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x3e000) >> 13
}

// GPIO.PIN19: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN19_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN19_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN19.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN19_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN19_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN19_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN19_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN19_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN19_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN19_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN19_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN19_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN19_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN19_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN19_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x3e000) >> 13
}

// GPIO.PIN20: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN20_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN20_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN20.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN20_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN20_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN20_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN20_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN20_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN20_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN20_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN20_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN20_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN20_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN20_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN20_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x3e000) >> 13
}

// GPIO.PIN21: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN21_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN21_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN21.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN21_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN21_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN21_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN21_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN21_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN21_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN21_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN21_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN21_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN21_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN21_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN21_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x3e000) >> 13
}

// GPIO.PIN22: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN22_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN22_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN22.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN22_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN22_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN22_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN22_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN22_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN22_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN22_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN22_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN22_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN22_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN22_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN22.Reg, volatile.LoadUint32(&o.PIN22.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN22_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN22.Reg) & 0x3e000) >> 13
}

// GPIO.PIN23: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN23_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN23_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN23.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN23_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN23_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN23_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN23_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN23_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN23_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN23_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN23_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN23_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN23_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN23_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN23.Reg, volatile.LoadUint32(&o.PIN23.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN23_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN23.Reg) & 0x3e000) >> 13
}

// GPIO.PIN24: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN24_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN24_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN24.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN24_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN24_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN24_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN24_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN24_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN24_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN24_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN24_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN24_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN24_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN24_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN24.Reg, volatile.LoadUint32(&o.PIN24.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN24_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN24.Reg) & 0x3e000) >> 13
}

// GPIO.PIN25: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN25_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN25_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN25.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN25_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN25_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN25_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN25_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN25_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN25_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN25_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN25_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN25_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN25_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN25_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN25.Reg, volatile.LoadUint32(&o.PIN25.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN25_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN25.Reg) & 0x3e000) >> 13
}

// GPIO.PIN26: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN26_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN26_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN26.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN26_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN26_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN26_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN26_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN26_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN26_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN26_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN26_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN26_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN26_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN26_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN26.Reg, volatile.LoadUint32(&o.PIN26.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN26_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN26.Reg) & 0x3e000) >> 13
}

// GPIO.PIN27: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN27_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN27_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN27.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN27_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN27_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN27_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN27_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN27_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN27_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN27_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN27_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN27_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN27_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN27_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN27.Reg, volatile.LoadUint32(&o.PIN27.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN27_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN27.Reg) & 0x3e000) >> 13
}

// GPIO.PIN28: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN28_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN28_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN28.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN28_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN28_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN28_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN28_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN28_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN28_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN28_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN28_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN28_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN28_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN28_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN28.Reg, volatile.LoadUint32(&o.PIN28.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN28_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN28.Reg) & 0x3e000) >> 13
}

// GPIO.PIN29: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN29_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN29_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN29.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN29_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN29_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN29_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN29_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN29_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN29_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN29_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN29_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN29_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN29_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN29_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN29.Reg, volatile.LoadUint32(&o.PIN29.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN29_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN29.Reg) & 0x3e000) >> 13
}

// GPIO.PIN30: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN30_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN30_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN30.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN30_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN30_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN30_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN30_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN30_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN30_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN30_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN30_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN30_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN30_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN30_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN30.Reg, volatile.LoadUint32(&o.PIN30.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN30_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN30.Reg) & 0x3e000) >> 13
}

// GPIO.PIN31: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN31_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN31_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN31.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN31_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN31_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN31_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN31_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN31_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN31_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN31_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN31_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN31_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN31_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN31_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN31.Reg, volatile.LoadUint32(&o.PIN31.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN31_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN31.Reg) & 0x3e000) >> 13
}

// GPIO.PIN32: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN32_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN32_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN32.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN32_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN32_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN32_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN32_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN32_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN32_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN32_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN32_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN32_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN32_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN32_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN32.Reg, volatile.LoadUint32(&o.PIN32.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN32_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN32.Reg) & 0x3e000) >> 13
}

// GPIO.PIN33: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN33_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN33_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN33.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN33_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN33_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN33_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN33_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN33_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN33_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN33_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN33_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN33_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN33_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN33_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN33.Reg, volatile.LoadUint32(&o.PIN33.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN33_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN33.Reg) & 0x3e000) >> 13
}

// GPIO.PIN34: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN34_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN34_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN34.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN34_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN34_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN34_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN34_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN34_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN34_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN34_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN34_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN34_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN34_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN34_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN34.Reg, volatile.LoadUint32(&o.PIN34.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN34_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN34.Reg) & 0x3e000) >> 13
}

// GPIO.PIN35: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN35_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN35_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN35.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN35_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN35_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN35_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN35_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN35_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN35_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN35_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN35_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN35_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN35_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN35_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN35.Reg, volatile.LoadUint32(&o.PIN35.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN35_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN35.Reg) & 0x3e000) >> 13
}

// GPIO.PIN36: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN36_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN36_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN36.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN36_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN36_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN36_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN36_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN36_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN36_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN36_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN36_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN36_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN36_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN36_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN36.Reg, volatile.LoadUint32(&o.PIN36.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN36_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN36.Reg) & 0x3e000) >> 13
}

// GPIO.PIN37: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN37_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN37_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN37.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN37_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN37_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN37_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN37_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN37_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN37_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN37_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN37_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN37_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN37_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN37_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN37.Reg, volatile.LoadUint32(&o.PIN37.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN37_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN37.Reg) & 0x3e000) >> 13
}

// GPIO.PIN38: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN38_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN38_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN38.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN38_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN38_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN38_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN38_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN38_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN38_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN38_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN38_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN38_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN38_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN38_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN38.Reg, volatile.LoadUint32(&o.PIN38.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN38_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN38.Reg) & 0x3e000) >> 13
}

// GPIO.PIN39: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN39_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN39_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN39.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN39_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN39_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN39_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN39_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN39_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN39_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN39_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN39_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN39_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN39_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN39_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN39.Reg, volatile.LoadUint32(&o.PIN39.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN39_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN39.Reg) & 0x3e000) >> 13
}

// GPIO.PIN40: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN40_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN40_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN40.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN40_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN40_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN40_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN40_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN40_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN40_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN40_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN40_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN40_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN40_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN40_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN40.Reg, volatile.LoadUint32(&o.PIN40.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN40_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN40.Reg) & 0x3e000) >> 13
}

// GPIO.PIN41: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN41_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN41_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN41.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN41_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN41_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN41_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN41_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN41_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN41_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN41_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN41_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN41_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN41_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN41_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN41.Reg, volatile.LoadUint32(&o.PIN41.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN41_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN41.Reg) & 0x3e000) >> 13
}

// GPIO.PIN42: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN42_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN42_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN42.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN42_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN42_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN42_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN42_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN42_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN42_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN42_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN42_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN42_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN42_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN42_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN42.Reg, volatile.LoadUint32(&o.PIN42.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN42_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN42.Reg) & 0x3e000) >> 13
}

// GPIO.PIN43: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN43_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN43_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN43.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN43_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN43_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN43_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN43_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN43_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN43_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN43_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN43_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN43_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN43_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN43_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN43.Reg, volatile.LoadUint32(&o.PIN43.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN43_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN43.Reg) & 0x3e000) >> 13
}

// GPIO.PIN44: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN44_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN44_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN44.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN44_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN44_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN44_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN44_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN44_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN44_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN44_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN44_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN44_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN44_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN44_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN44.Reg, volatile.LoadUint32(&o.PIN44.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN44_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN44.Reg) & 0x3e000) >> 13
}

// GPIO.PIN45: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN45_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN45_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN45.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN45_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN45_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN45_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN45_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN45_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN45_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN45_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN45_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN45_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN45_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN45_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN45.Reg, volatile.LoadUint32(&o.PIN45.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN45_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN45.Reg) & 0x3e000) >> 13
}

// GPIO.PIN46: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN46_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN46_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN46.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN46_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN46_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN46_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN46_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN46_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN46_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN46_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN46_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN46_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN46_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN46_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN46.Reg, volatile.LoadUint32(&o.PIN46.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN46_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN46.Reg) & 0x3e000) >> 13
}

// GPIO.PIN47: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN47_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN47_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN47.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN47_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN47_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN47_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN47_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN47_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN47_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN47_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN47_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN47_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN47_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN47_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN47.Reg, volatile.LoadUint32(&o.PIN47.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN47_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN47.Reg) & 0x3e000) >> 13
}

// GPIO.PIN48: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN48_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN48_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN48.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN48_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN48_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN48_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN48_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN48_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN48_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN48_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN48_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN48_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN48_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN48_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN48.Reg, volatile.LoadUint32(&o.PIN48.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN48_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN48.Reg) & 0x3e000) >> 13
}

// GPIO.PIN49: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN49_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN49_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN49.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN49_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN49_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN49_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN49_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN49_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN49_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN49_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN49_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN49_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN49_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN49_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN49.Reg, volatile.LoadUint32(&o.PIN49.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN49_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN49.Reg) & 0x3e000) >> 13
}

// GPIO.PIN50: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN50_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN50_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN50.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN50_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN50_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN50_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN50_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN50_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN50_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN50_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN50_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN50_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN50_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN50_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN50.Reg, volatile.LoadUint32(&o.PIN50.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN50_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN50.Reg) & 0x3e000) >> 13
}

// GPIO.PIN51: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN51_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN51_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN51.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN51_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN51_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN51_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN51_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN51_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN51_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN51_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN51_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN51_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN51_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN51_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN51.Reg, volatile.LoadUint32(&o.PIN51.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN51_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN51.Reg) & 0x3e000) >> 13
}

// GPIO.PIN52: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN52_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN52_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN52.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN52_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN52_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN52_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN52_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN52_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN52_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN52_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN52_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN52_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN52_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN52_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN52.Reg, volatile.LoadUint32(&o.PIN52.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN52_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN52.Reg) & 0x3e000) >> 13
}

// GPIO.PIN53: Configuration for GPIO pin %s
func (o *GPIO_Type) SetPIN53_SYNC2_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPIN53_SYNC2_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PIN53.Reg) & 0x3
}
func (o *GPIO_Type) SetPIN53_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN53_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN53_SYNC1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x18)|value<<3)
}
func (o *GPIO_Type) GetPIN53_SYNC1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x18) >> 3
}
func (o *GPIO_Type) SetPIN53_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetPIN53_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetPIN53_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN53_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN53_CONFIG(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x1800)|value<<11)
}
func (o *GPIO_Type) GetPIN53_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x1800) >> 11
}
func (o *GPIO_Type) SetPIN53_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.PIN53.Reg, volatile.LoadUint32(&o.PIN53.Reg)&^(0x3e000)|value<<13)
}
func (o *GPIO_Type) GetPIN53_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.PIN53.Reg) & 0x3e000) >> 13
}

// GPIO.STATUS_NEXT: GPIO0 ~ 31 interrupt source register
func (o *GPIO_Type) SetSTATUS_NEXT(value uint32) {
	volatile.StoreUint32(&o.STATUS_NEXT.Reg, value)
}
func (o *GPIO_Type) GetSTATUS_NEXT() uint32 {
	return volatile.LoadUint32(&o.STATUS_NEXT.Reg)
}

// GPIO.STATUS_NEXT1: GPIO32 ~ 53 interrupt source register
func (o *GPIO_Type) SetSTATUS_NEXT1_STATUS1_INTERRUPT_NEXT(value uint32) {
	volatile.StoreUint32(&o.STATUS_NEXT1.Reg, volatile.LoadUint32(&o.STATUS_NEXT1.Reg)&^(0x3fffff)|value)
}
func (o *GPIO_Type) GetSTATUS_NEXT1_STATUS1_INTERRUPT_NEXT() uint32 {
	return volatile.LoadUint32(&o.STATUS_NEXT1.Reg) & 0x3fffff
}

// GPIO.FUNC0_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC0_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC0_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC1_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC1_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC1_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC2_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC2_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC2_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC3_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC3_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC3_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC4_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC4_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC4_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC5_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC5_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC5_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC6_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC6_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC6_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC7_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC7_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC7_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC8_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC8_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC8_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC9_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC9_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC9_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC10_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC10_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC10_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC11_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC11_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC11_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC12_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC12_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC12_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC13_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC13_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC13_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC14_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC14_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC14_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC15_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC15_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC15_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC16_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC16_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC16_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC17_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC17_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC17_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC18_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC18_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC18_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC19_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC19_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC19_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC20_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC20_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC20_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC21_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC21_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC21_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC22_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC22_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC22_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC23_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC23_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC23_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC24_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC24_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC24_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC25_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC25_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC25_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC26_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC26_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC26_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC27_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC27_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC27_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC28_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC28_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC28_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC29_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC29_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC29_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC30_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC30_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC30_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC31_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC31_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC31_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC32_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC32_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC32_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC33_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC33_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC33_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC34_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC34_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC34_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC35_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC35_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC35_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC36_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC36_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC36_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC37_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC37_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC37_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC38_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC38_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC38_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC39_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC39_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC39_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC40_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC40_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC40_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC41_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC41_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC41_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC42_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC42_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC42_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC43_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC43_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC43_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC44_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC44_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC44_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC45_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC45_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC45_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC46_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC46_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC46_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC47_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC47_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC47_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC48_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC48_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC48_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC49_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC49_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC49_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC50_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC50_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC50_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC51_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC51_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC51_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC52_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC52_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC52_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC53_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC53_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC53_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC54_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC54_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC54_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC54_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC54_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC55_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC55_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC55_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC55_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC55_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC56_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC56_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC56_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC56_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC56_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC57_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC57_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC57_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC57_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC57_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC58_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC58_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC58_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC58_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC58_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC59_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC59_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC59_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC59_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC59_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC60_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC60_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC60_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC60_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC60_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC61_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC61_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC61_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC61_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC61_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC62_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC62_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC62_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC62_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC62_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC63_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC63_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC63_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC63_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC63_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC64_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC64_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC64_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC64_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC64_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC65_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC65_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC65_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC65_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC65_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC66_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC66_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC66_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC66_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC66_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC67_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC67_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC67_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC67_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC67_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC68_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC68_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC68_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC68_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC68_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC69_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC69_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC69_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC69_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC69_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC70_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC70_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC70_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC70_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC70_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC71_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC71_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC71_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC71_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC71_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC72_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC72_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC72_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC72_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC72_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC73_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC73_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC73_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC73_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC73_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC74_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC74_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC74_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC74_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC74_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC75_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC75_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC75_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC75_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC75_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC76_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC76_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC76_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC76_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC76_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC77_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC77_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC77_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC77_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC77_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC78_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC78_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC78_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC78_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC78_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC79_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC79_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC79_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC79_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC79_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC80_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC80_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC80_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC80_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC80_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC81_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC81_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC81_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC81_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC81_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC82_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC82_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC82_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC82_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC82_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC83_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC83_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC83_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC83_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC83_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC84_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC84_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC84_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC84_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC84_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC85_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC85_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC85_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC85_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC85_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC86_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC86_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC86_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC86_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC86_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC87_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC87_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC87_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC87_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC87_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC88_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC88_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC88_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC88_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC88_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC89_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC89_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC89_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC89_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC89_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC90_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC90_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC90_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC90_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC90_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC91_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC91_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC91_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC91_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC91_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC92_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC92_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC92_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC92_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC92_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC93_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC93_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC93_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC93_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC93_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC94_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC94_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC94_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC94_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC94_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC95_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC95_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC95_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC95_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC95_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC96_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC96_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC96_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC96_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC96_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC97_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC97_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC97_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC97_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC97_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC98_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC98_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC98_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC98_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC98_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC99_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC99_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC99_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC99_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC99_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC100_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC100_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC100_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC100_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC100_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC101_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC101_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC101_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC101_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC101_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC102_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC102_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC102_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC102_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC102_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC103_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC103_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC103_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC103_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC103_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC104_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC104_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC104_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC104_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC104_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC105_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC105_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC105_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC105_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC105_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC106_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC106_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC106_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC106_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC106_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC107_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC107_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC107_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC107_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC107_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC108_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC108_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC108_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC108_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC108_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC109_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC109_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC109_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC109_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC109_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC110_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC110_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC110_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC110_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC110_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC111_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC111_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC111_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC111_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC111_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC112_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC112_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC112_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC112_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC112_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC113_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC113_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC113_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC113_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC113_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC114_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC114_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC114_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC114_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC114_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC115_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC115_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC115_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC115_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC115_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC116_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC116_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC116_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC116_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC116_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC117_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC117_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC117_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC117_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC117_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC118_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC118_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC118_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC118_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC118_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC119_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC119_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC119_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC119_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC119_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC120_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC120_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC120_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC120_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC120_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC121_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC121_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC121_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC121_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC121_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC122_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC122_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC122_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC122_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC122_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC123_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC123_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC123_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC123_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC123_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC124_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC124_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC124_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC124_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC124_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC125_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC125_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC125_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC125_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC125_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC126_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC126_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC126_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC126_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC126_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC127_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC127_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC127_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC127_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC127_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC128_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC128_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC128_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC128_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC128_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC128_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC128_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC128_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC128_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC128_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC128_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC129_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC129_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC129_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC129_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC129_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC129_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC129_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC129_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC129_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC129_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC129_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC130_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC130_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC130_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC130_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC130_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC130_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC130_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC130_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC130_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC130_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC130_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC131_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC131_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC131_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC131_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC131_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC131_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC131_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC131_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC131_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC131_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC131_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC132_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC132_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC132_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC132_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC132_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC132_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC132_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC132_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC132_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC132_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC132_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC133_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC133_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC133_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC133_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC133_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC133_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC133_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC133_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC133_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC133_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC133_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC134_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC134_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC134_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC134_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC134_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC134_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC134_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC134_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC134_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC134_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC134_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC135_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC135_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC135_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC135_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC135_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC135_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC135_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC135_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC135_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC135_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC135_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC136_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC136_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC136_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC136_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC136_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC136_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC136_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC136_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC136_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC136_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC136_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC137_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC137_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC137_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC137_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC137_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC137_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC137_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC137_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC137_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC137_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC137_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC138_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC138_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC138_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC138_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC138_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC138_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC138_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC138_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC138_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC138_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC138_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC139_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC139_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC139_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC139_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC139_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC139_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC139_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC139_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC139_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC139_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC139_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC140_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC140_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC140_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC140_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC140_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC140_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC140_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC140_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC140_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC140_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC140_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC141_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC141_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC141_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC141_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC141_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC141_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC141_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC141_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC141_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC141_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC141_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC142_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC142_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC142_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC142_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC142_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC142_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC142_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC142_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC142_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC142_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC142_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC143_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC143_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC143_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC143_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC143_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC143_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC143_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC143_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC143_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC143_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC143_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC144_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC144_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC144_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC144_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC144_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC144_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC144_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC144_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC144_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC144_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC144_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC145_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC145_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC145_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC145_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC145_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC145_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC145_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC145_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC145_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC145_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC145_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC146_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC146_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC146_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC146_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC146_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC146_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC146_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC146_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC146_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC146_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC146_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC147_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC147_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC147_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC147_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC147_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC147_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC147_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC147_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC147_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC147_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC147_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC148_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC148_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC148_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC148_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC148_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC148_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC148_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC148_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC148_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC148_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC148_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC149_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC149_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC149_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC149_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC149_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC149_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC149_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC149_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC149_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC149_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC149_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC150_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC150_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC150_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC150_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC150_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC150_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC150_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC150_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC150_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC150_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC150_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC151_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC151_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC151_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC151_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC151_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC151_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC151_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC151_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC151_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC151_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC151_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC152_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC152_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC152_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC152_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC152_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC152_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC152_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC152_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC152_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC152_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC152_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC153_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC153_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC153_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC153_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC153_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC153_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC153_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC153_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC153_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC153_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC153_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC154_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC154_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC154_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC154_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC154_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC154_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC154_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC154_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC154_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC154_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC154_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC155_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC155_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC155_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC155_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC155_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC155_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC155_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC155_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC155_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC155_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC155_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC156_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC156_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC156_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC156_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC156_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC156_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC156_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC156_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC156_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC156_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC156_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC157_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC157_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC157_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC157_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC157_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC157_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC157_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC157_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC157_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC157_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC157_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC158_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC158_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC158_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC158_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC158_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC158_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC158_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC158_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC158_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC158_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC158_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC159_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC159_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC159_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC159_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC159_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC159_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC159_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC159_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC159_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC159_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC159_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC160_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC160_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC160_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC160_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC160_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC160_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC160_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC160_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC160_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC160_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC160_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC161_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC161_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC161_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC161_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC161_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC161_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC161_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC161_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC161_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC161_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC161_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC162_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC162_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC162_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC162_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC162_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC162_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC162_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC162_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC162_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC162_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC162_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC163_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC163_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC163_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC163_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC163_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC163_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC163_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC163_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC163_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC163_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC163_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC164_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC164_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC164_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC164_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC164_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC164_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC164_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC164_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC164_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC164_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC164_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC165_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC165_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC165_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC165_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC165_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC165_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC165_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC165_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC165_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC165_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC165_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC166_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC166_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC166_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC166_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC166_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC166_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC166_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC166_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC166_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC166_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC166_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC167_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC167_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC167_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC167_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC167_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC167_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC167_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC167_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC167_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC167_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC167_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC168_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC168_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC168_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC168_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC168_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC168_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC168_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC168_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC168_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC168_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC168_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC169_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC169_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC169_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC169_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC169_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC169_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC169_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC169_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC169_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC169_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC169_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC170_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC170_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC170_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC170_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC170_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC170_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC170_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC170_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC170_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC170_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC170_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC171_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC171_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC171_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC171_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC171_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC171_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC171_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC171_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC171_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC171_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC171_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC172_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC172_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC172_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC172_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC172_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC172_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC172_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC172_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC172_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC172_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC172_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC173_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC173_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC173_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC173_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC173_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC173_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC173_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC173_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC173_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC173_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC173_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC174_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC174_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC174_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC174_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC174_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC174_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC174_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC174_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC174_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC174_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC174_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC175_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC175_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC175_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC175_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC175_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC175_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC175_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC175_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC175_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC175_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC175_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC176_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC176_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC176_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC176_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC176_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC176_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC176_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC176_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC176_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC176_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC176_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC177_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC177_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC177_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC177_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC177_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC177_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC177_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC177_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC177_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC177_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC177_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC178_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC178_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC178_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC178_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC178_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC178_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC178_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC178_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC178_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC178_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC178_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC179_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC179_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC179_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC179_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC179_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC179_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC179_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC179_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC179_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC179_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC179_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC180_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC180_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC180_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC180_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC180_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC180_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC180_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC180_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC180_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC180_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC180_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC181_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC181_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC181_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC181_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC181_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC181_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC181_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC181_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC181_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC181_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC181_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC182_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC182_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC182_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC182_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC182_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC182_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC182_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC182_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC182_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC182_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC182_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC183_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC183_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC183_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC183_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC183_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC183_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC183_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC183_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC183_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC183_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC183_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC184_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC184_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC184_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC184_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC184_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC184_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC184_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC184_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC184_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC184_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC184_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC185_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC185_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC185_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC185_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC185_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC185_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC185_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC185_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC185_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC185_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC185_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC186_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC186_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC186_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC186_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC186_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC186_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC186_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC186_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC186_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC186_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC186_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC187_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC187_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC187_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC187_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC187_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC187_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC187_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC187_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC187_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC187_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC187_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC188_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC188_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC188_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC188_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC188_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC188_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC188_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC188_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC188_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC188_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC188_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC189_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC189_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC189_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC189_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC189_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC189_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC189_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC189_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC189_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC189_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC189_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC190_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC190_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC190_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC190_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC190_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC190_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC190_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC190_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC190_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC190_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC190_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC191_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC191_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC191_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC191_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC191_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC191_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC191_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC191_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC191_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC191_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC191_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC192_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC192_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC192_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC192_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC192_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC192_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC192_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC192_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC192_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC192_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC192_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC193_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC193_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC193_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC193_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC193_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC193_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC193_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC193_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC193_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC193_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC193_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC194_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC194_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC194_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC194_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC194_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC194_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC194_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC194_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC194_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC194_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC194_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC195_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC195_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC195_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC195_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC195_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC195_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC195_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC195_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC195_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC195_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC195_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC196_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC196_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC196_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC196_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC196_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC196_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC196_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC196_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC196_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC196_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC196_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC197_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC197_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC197_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC197_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC197_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC197_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC197_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC197_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC197_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC197_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC197_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC198_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC198_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC198_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC198_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC198_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC198_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC198_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC198_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC198_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC198_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC198_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC199_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC199_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC199_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC199_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC199_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC199_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC199_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC199_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC199_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC199_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC199_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC200_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC200_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC200_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC200_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC200_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC200_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC200_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC200_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC200_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC200_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC200_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC201_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC201_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC201_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC201_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC201_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC201_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC201_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC201_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC201_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC201_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC201_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC202_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC202_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC202_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC202_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC202_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC202_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC202_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC202_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC202_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC202_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC202_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC203_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC203_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC203_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC203_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC203_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC203_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC203_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC203_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC203_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC203_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC203_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC204_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC204_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC204_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC204_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC204_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC204_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC204_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC204_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC204_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC204_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC204_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC205_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC205_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC205_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC205_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC205_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC205_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC205_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC205_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC205_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC205_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC205_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC206_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC206_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC206_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC206_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC206_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC206_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC206_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC206_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC206_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC206_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC206_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC207_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC207_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC207_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC207_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC207_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC207_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC207_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC207_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC207_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC207_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC207_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC208_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC208_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC208_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC208_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC208_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC208_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC208_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC208_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC208_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC208_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC208_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC209_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC209_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC209_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC209_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC209_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC209_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC209_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC209_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC209_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC209_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC209_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC210_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC210_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC210_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC210_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC210_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC210_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC210_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC210_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC210_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC210_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC210_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC211_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC211_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC211_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC211_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC211_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC211_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC211_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC211_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC211_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC211_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC211_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC212_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC212_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC212_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC212_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC212_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC212_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC212_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC212_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC212_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC212_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC212_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC213_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC213_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC213_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC213_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC213_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC213_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC213_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC213_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC213_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC213_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC213_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC214_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC214_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC214_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC214_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC214_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC214_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC214_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC214_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC214_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC214_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC214_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC215_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC215_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC215_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC215_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC215_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC215_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC215_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC215_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC215_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC215_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC215_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC216_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC216_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC216_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC216_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC216_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC216_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC216_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC216_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC216_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC216_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC216_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC217_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC217_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC217_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC217_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC217_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC217_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC217_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC217_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC217_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC217_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC217_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC218_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC218_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC218_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC218_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC218_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC218_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC218_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC218_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC218_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC218_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC218_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC219_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC219_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC219_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC219_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC219_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC219_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC219_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC219_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC219_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC219_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC219_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC220_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC220_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC220_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC220_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC220_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC220_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC220_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC220_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC220_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC220_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC220_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC221_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC221_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC221_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC221_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC221_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC221_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC221_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC221_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC221_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC221_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC221_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC222_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC222_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC222_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC222_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC222_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC222_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC222_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC222_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC222_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC222_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC222_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC223_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC223_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC223_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC223_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC223_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC223_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC223_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC223_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC223_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC223_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC223_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC224_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC224_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC224_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC224_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC224_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC224_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC224_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC224_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC224_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC224_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC224_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC225_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC225_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC225_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC225_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC225_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC225_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC225_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC225_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC225_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC225_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC225_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC226_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC226_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC226_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC226_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC226_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC226_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC226_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC226_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC226_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC226_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC226_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC227_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC227_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC227_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC227_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC227_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC227_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC227_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC227_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC227_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC227_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC227_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC228_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC228_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC228_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC228_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC228_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC228_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC228_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC228_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC228_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC228_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC228_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC229_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC229_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC229_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC229_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC229_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC229_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC229_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC229_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC229_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC229_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC229_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC230_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC230_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC230_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC230_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC230_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC230_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC230_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC230_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC230_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC230_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC230_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC231_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC231_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC231_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC231_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC231_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC231_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC231_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC231_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC231_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC231_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC231_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC232_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC232_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC232_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC232_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC232_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC232_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC232_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC232_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC232_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC232_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC232_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC233_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC233_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC233_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC233_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC233_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC233_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC233_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC233_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC233_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC233_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC233_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC234_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC234_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC234_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC234_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC234_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC234_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC234_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC234_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC234_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC234_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC234_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC235_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC235_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC235_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC235_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC235_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC235_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC235_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC235_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC235_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC235_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC235_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC236_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC236_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC236_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC236_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC236_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC236_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC236_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC236_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC236_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC236_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC236_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC237_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC237_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC237_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC237_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC237_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC237_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC237_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC237_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC237_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC237_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC237_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC238_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC238_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC238_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC238_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC238_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC238_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC238_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC238_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC238_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC238_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC238_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC239_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC239_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC239_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC239_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC239_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC239_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC239_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC239_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC239_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC239_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC239_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC240_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC240_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC240_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC240_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC240_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC240_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC240_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC240_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC240_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC240_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC240_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC241_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC241_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC241_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC241_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC241_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC241_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC241_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC241_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC241_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC241_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC241_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC242_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC242_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC242_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC242_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC242_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC242_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC242_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC242_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC242_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC242_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC242_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC243_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC243_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC243_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC243_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC243_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC243_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC243_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC243_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC243_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC243_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC243_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC244_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC244_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC244_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC244_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC244_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC244_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC244_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC244_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC244_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC244_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC244_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC245_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC245_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC245_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC245_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC245_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC245_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC245_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC245_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC245_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC245_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC245_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC246_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC246_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC246_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC246_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC246_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC246_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC246_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC246_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC246_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC246_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC246_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC247_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC247_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC247_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC247_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC247_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC247_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC247_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC247_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC247_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC247_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC247_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC248_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC248_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC248_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC248_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC248_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC248_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC248_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC248_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC248_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC248_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC248_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC249_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC249_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC249_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC249_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC249_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC249_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC249_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC249_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC249_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC249_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC249_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC250_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC250_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC250_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC250_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC250_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC250_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC250_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC250_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC250_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC250_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC250_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC251_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC251_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC251_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC251_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC251_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC251_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC251_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC251_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC251_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC251_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC251_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC252_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC252_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC252_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC252_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC252_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC252_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC252_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC252_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC252_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC252_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC252_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC253_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC253_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC253_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC253_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC253_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC253_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC253_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC253_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC253_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC253_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC253_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC254_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC254_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC254_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC254_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC254_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC254_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC254_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC254_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC254_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC254_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC254_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC255_IN_SEL_CFG: Peripheral function %s input selection register
func (o *GPIO_Type) SetFUNC255_IN_SEL_CFG_IN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC255_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg)&^(0x3f)|value)
}
func (o *GPIO_Type) GetFUNC255_IN_SEL_CFG_IN_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg) & 0x3f
}
func (o *GPIO_Type) SetFUNC255_IN_SEL_CFG_IN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC255_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetFUNC255_IN_SEL_CFG_IN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetFUNC255_IN_SEL_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC255_IN_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetFUNC255_IN_SEL_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC255_IN_SEL_CFG.Reg) & 0x80) >> 7
}

// GPIO.FUNC0_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC0_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC0_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC0_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC0_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC1_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC1_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC1_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC1_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC1_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC2_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC2_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC2_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC2_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC2_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC3_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC3_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC3_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC3_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC3_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC4_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC4_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC4_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC4_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC4_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC5_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC5_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC5_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC5_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC5_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC6_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC6_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC6_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC6_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC6_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC7_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC7_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC7_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC7_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC7_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC8_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC8_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC8_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC8_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC8_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC9_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC9_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC9_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC9_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC9_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC10_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC10_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC10_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC10_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC10_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC11_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC11_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC11_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC11_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC11_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC12_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC12_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC12_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC12_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC12_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC13_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC13_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC13_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC13_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC13_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC14_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC14_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC14_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC14_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC14_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC15_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC15_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC15_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC15_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC15_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC16_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC16_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC16_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC16_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC16_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC17_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC17_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC17_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC17_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC17_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC18_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC18_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC18_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC18_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC18_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC19_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC19_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC19_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC19_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC19_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC20_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC20_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC20_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC20_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC20_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC21_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC21_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC21_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC21_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC21_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC22_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC22_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC22_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC22_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC22_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC23_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC23_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC23_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC23_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC23_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC24_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC24_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC24_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC24_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC24_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC25_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC25_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC25_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC25_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC25_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC26_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC26_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC26_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC26_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC26_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC27_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC27_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC27_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC27_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC27_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC28_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC28_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC28_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC28_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC28_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC29_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC29_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC29_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC29_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC29_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC30_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC30_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC30_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC30_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC30_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC31_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC31_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC31_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC31_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC31_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC32_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC32_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC32_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC32_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC32_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC33_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC33_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC33_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC33_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC33_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC34_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC34_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC34_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC34_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC34_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC35_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC35_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC35_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC35_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC35_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC36_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC36_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC36_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC36_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC36_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC37_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC37_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC37_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC37_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC37_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC38_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC38_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC38_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC38_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC38_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC39_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC39_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC39_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC39_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC39_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC40_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC40_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC40_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC40_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC40_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC41_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC41_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC41_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC41_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC41_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC42_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC42_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC42_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC42_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC42_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC43_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC43_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC43_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC43_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC43_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC44_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC44_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC44_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC44_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC44_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC45_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC45_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC45_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC45_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC45_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC46_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC46_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC46_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC46_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC46_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC47_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC47_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC47_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC47_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC47_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC48_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC48_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC48_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC48_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC48_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC49_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC49_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC49_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC49_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC49_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC50_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC50_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC50_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC50_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC50_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC51_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC51_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC51_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC51_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC51_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC52_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC52_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC52_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC52_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC52_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.FUNC53_OUT_SEL_CFG: Peripheral output selection for GPIO %s
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x1ff)|value)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_OUT_SEL() uint32 {
	return volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x1ff
}
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_OEN_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_OEN_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetFUNC53_OUT_SEL_CFG_OEN_INV_SEL(value uint32) {
	volatile.StoreUint32(&o.FUNC53_OUT_SEL_CFG.Reg, volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetFUNC53_OUT_SEL_CFG_OEN_INV_SEL() uint32 {
	return (volatile.LoadUint32(&o.FUNC53_OUT_SEL_CFG.Reg) & 0x800) >> 11
}

// GPIO.CLOCK_GATE: GPIO clock gating register
func (o *GPIO_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// GPIO.REG_DATE: Version control register
func (o *GPIO_Type) SetREG_DATE_DATE(value uint32) {
	volatile.StoreUint32(&o.REG_DATE.Reg, volatile.LoadUint32(&o.REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *GPIO_Type) GetREG_DATE_DATE() uint32 {
	return volatile.LoadUint32(&o.REG_DATE.Reg) & 0xfffffff
}

// Sigma-Delta Modulation
type GPIOSD_Type struct {
	SIGMADELTA0        volatile.Register32 // 0x0
	SIGMADELTA1        volatile.Register32 // 0x4
	SIGMADELTA2        volatile.Register32 // 0x8
	SIGMADELTA3        volatile.Register32 // 0xC
	SIGMADELTA4        volatile.Register32 // 0x10
	SIGMADELTA5        volatile.Register32 // 0x14
	SIGMADELTA6        volatile.Register32 // 0x18
	SIGMADELTA7        volatile.Register32 // 0x1C
	SIGMADELTA_CG      volatile.Register32 // 0x20
	SIGMADELTA_MISC    volatile.Register32 // 0x24
	SIGMADELTA_VERSION volatile.Register32 // 0x28
}

// GPIOSD.SIGMADELTA0: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA0_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA0.Reg, volatile.LoadUint32(&o.SIGMADELTA0.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA0_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA0.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA0_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA0.Reg, volatile.LoadUint32(&o.SIGMADELTA0.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA0_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA0.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA1: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA1_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA1.Reg, volatile.LoadUint32(&o.SIGMADELTA1.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA1_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA1.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA1_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA1.Reg, volatile.LoadUint32(&o.SIGMADELTA1.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA1_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA1.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA2: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA2_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA2.Reg, volatile.LoadUint32(&o.SIGMADELTA2.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA2_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA2.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA2_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA2.Reg, volatile.LoadUint32(&o.SIGMADELTA2.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA2_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA2.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA3: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA3_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA3.Reg, volatile.LoadUint32(&o.SIGMADELTA3.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA3_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA3.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA3_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA3.Reg, volatile.LoadUint32(&o.SIGMADELTA3.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA3_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA3.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA4: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA4_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA4.Reg, volatile.LoadUint32(&o.SIGMADELTA4.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA4_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA4.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA4_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA4.Reg, volatile.LoadUint32(&o.SIGMADELTA4.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA4_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA4.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA5: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA5_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA5.Reg, volatile.LoadUint32(&o.SIGMADELTA5.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA5_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA5.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA5_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA5.Reg, volatile.LoadUint32(&o.SIGMADELTA5.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA5_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA5.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA6: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA6_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA6.Reg, volatile.LoadUint32(&o.SIGMADELTA6.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA6_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA6.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA6_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA6.Reg, volatile.LoadUint32(&o.SIGMADELTA6.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA6_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA6.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA7: Duty-cycle configuration register of SDM%s
func (o *GPIOSD_Type) SetSIGMADELTA7_SD_IN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA7.Reg, volatile.LoadUint32(&o.SIGMADELTA7.Reg)&^(0xff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA7_SD_IN() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA7.Reg) & 0xff
}
func (o *GPIOSD_Type) SetSIGMADELTA7_SD_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA7.Reg, volatile.LoadUint32(&o.SIGMADELTA7.Reg)&^(0xff00)|value<<8)
}
func (o *GPIOSD_Type) GetSIGMADELTA7_SD_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA7.Reg) & 0xff00) >> 8
}

// GPIOSD.SIGMADELTA_CG: Clock gating configuration register
func (o *GPIOSD_Type) SetSIGMADELTA_CG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_CG.Reg, volatile.LoadUint32(&o.SIGMADELTA_CG.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOSD_Type) GetSIGMADELTA_CG_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_CG.Reg) & 0x80000000) >> 31
}

// GPIOSD.SIGMADELTA_MISC: MISC register
func (o *GPIOSD_Type) SetSIGMADELTA_MISC_FUNCTION_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_MISC.Reg, volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOSD_Type) GetSIGMADELTA_MISC_FUNCTION_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg) & 0x40000000) >> 30
}
func (o *GPIOSD_Type) SetSIGMADELTA_MISC_SPI_SWAP(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_MISC.Reg, volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOSD_Type) GetSIGMADELTA_MISC_SPI_SWAP() uint32 {
	return (volatile.LoadUint32(&o.SIGMADELTA_MISC.Reg) & 0x80000000) >> 31
}

// GPIOSD.SIGMADELTA_VERSION: Version control register
func (o *GPIOSD_Type) SetSIGMADELTA_VERSION_GPIO_SD_DATE(value uint32) {
	volatile.StoreUint32(&o.SIGMADELTA_VERSION.Reg, volatile.LoadUint32(&o.SIGMADELTA_VERSION.Reg)&^(0xfffffff)|value)
}
func (o *GPIOSD_Type) GetSIGMADELTA_VERSION_GPIO_SD_DATE() uint32 {
	return volatile.LoadUint32(&o.SIGMADELTA_VERSION.Reg) & 0xfffffff
}

// HMAC (Hash-based Message Authentication Code) Accelerator
type HMAC_Type struct {
	_                   [64]byte
	SET_START           volatile.Register32 // 0x40
	SET_PARA_PURPOSE    volatile.Register32 // 0x44
	SET_PARA_KEY        volatile.Register32 // 0x48
	SET_PARA_FINISH     volatile.Register32 // 0x4C
	SET_MESSAGE_ONE     volatile.Register32 // 0x50
	SET_MESSAGE_ING     volatile.Register32 // 0x54
	SET_MESSAGE_END     volatile.Register32 // 0x58
	SET_RESULT_FINISH   volatile.Register32 // 0x5C
	SET_INVALIDATE_JTAG volatile.Register32 // 0x60
	SET_INVALIDATE_DS   volatile.Register32 // 0x64
	QUERY_ERROR         volatile.Register32 // 0x68
	QUERY_BUSY          volatile.Register32 // 0x6C
	_                   [16]byte
	WR_MESSAGE_0        volatile.Register32 // 0x80
	WR_MESSAGE_1        volatile.Register32 // 0x84
	WR_MESSAGE_2        volatile.Register32 // 0x88
	WR_MESSAGE_3        volatile.Register32 // 0x8C
	WR_MESSAGE_4        volatile.Register32 // 0x90
	WR_MESSAGE_5        volatile.Register32 // 0x94
	WR_MESSAGE_6        volatile.Register32 // 0x98
	WR_MESSAGE_7        volatile.Register32 // 0x9C
	WR_MESSAGE_8        volatile.Register32 // 0xA0
	WR_MESSAGE_9        volatile.Register32 // 0xA4
	WR_MESSAGE_10       volatile.Register32 // 0xA8
	WR_MESSAGE_11       volatile.Register32 // 0xAC
	WR_MESSAGE_12       volatile.Register32 // 0xB0
	WR_MESSAGE_13       volatile.Register32 // 0xB4
	WR_MESSAGE_14       volatile.Register32 // 0xB8
	WR_MESSAGE_15       volatile.Register32 // 0xBC
	RD_RESULT_0         volatile.Register32 // 0xC0
	RD_RESULT_1         volatile.Register32 // 0xC4
	RD_RESULT_2         volatile.Register32 // 0xC8
	RD_RESULT_3         volatile.Register32 // 0xCC
	RD_RESULT_4         volatile.Register32 // 0xD0
	RD_RESULT_5         volatile.Register32 // 0xD4
	RD_RESULT_6         volatile.Register32 // 0xD8
	RD_RESULT_7         volatile.Register32 // 0xDC
	_                   [16]byte
	SET_MESSAGE_PAD     volatile.Register32 // 0xF0
	ONE_BLOCK           volatile.Register32 // 0xF4
	DATE                volatile.Register32 // 0xF8
}

// HMAC.SET_START: HMAC start control register
func (o *HMAC_Type) SetSET_START(value uint32) {
	volatile.StoreUint32(&o.SET_START.Reg, volatile.LoadUint32(&o.SET_START.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_START() uint32 {
	return volatile.LoadUint32(&o.SET_START.Reg) & 0x1
}

// HMAC.SET_PARA_PURPOSE: HMAC parameter configuration register
func (o *HMAC_Type) SetSET_PARA_PURPOSE_PURPOSE_SET(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_PURPOSE.Reg, volatile.LoadUint32(&o.SET_PARA_PURPOSE.Reg)&^(0xf)|value)
}
func (o *HMAC_Type) GetSET_PARA_PURPOSE_PURPOSE_SET() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_PURPOSE.Reg) & 0xf
}

// HMAC.SET_PARA_KEY: HMAC key configuration register
func (o *HMAC_Type) SetSET_PARA_KEY_KEY_SET(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_KEY.Reg, volatile.LoadUint32(&o.SET_PARA_KEY.Reg)&^(0x7)|value)
}
func (o *HMAC_Type) GetSET_PARA_KEY_KEY_SET() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_KEY.Reg) & 0x7
}

// HMAC.SET_PARA_FINISH: HMAC configuration completion register
func (o *HMAC_Type) SetSET_PARA_FINISH_SET_PARA_END(value uint32) {
	volatile.StoreUint32(&o.SET_PARA_FINISH.Reg, volatile.LoadUint32(&o.SET_PARA_FINISH.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_PARA_FINISH_SET_PARA_END() uint32 {
	return volatile.LoadUint32(&o.SET_PARA_FINISH.Reg) & 0x1
}

// HMAC.SET_MESSAGE_ONE: HMAC one message control register
func (o *HMAC_Type) SetSET_MESSAGE_ONE_SET_TEXT_ONE(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_ONE.Reg, volatile.LoadUint32(&o.SET_MESSAGE_ONE.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_ONE_SET_TEXT_ONE() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_ONE.Reg) & 0x1
}

// HMAC.SET_MESSAGE_ING: HMAC message continue register
func (o *HMAC_Type) SetSET_MESSAGE_ING_SET_TEXT_ING(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_ING.Reg, volatile.LoadUint32(&o.SET_MESSAGE_ING.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_ING_SET_TEXT_ING() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_ING.Reg) & 0x1
}

// HMAC.SET_MESSAGE_END: HMAC message end register
func (o *HMAC_Type) SetSET_MESSAGE_END_SET_TEXT_END(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_END.Reg, volatile.LoadUint32(&o.SET_MESSAGE_END.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_END_SET_TEXT_END() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_END.Reg) & 0x1
}

// HMAC.SET_RESULT_FINISH: HMAC read result completion register
func (o *HMAC_Type) SetSET_RESULT_FINISH_SET_RESULT_END(value uint32) {
	volatile.StoreUint32(&o.SET_RESULT_FINISH.Reg, volatile.LoadUint32(&o.SET_RESULT_FINISH.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_RESULT_FINISH_SET_RESULT_END() uint32 {
	return volatile.LoadUint32(&o.SET_RESULT_FINISH.Reg) & 0x1
}

// HMAC.SET_INVALIDATE_JTAG: Invalidate JTAG result register
func (o *HMAC_Type) SetSET_INVALIDATE_JTAG(value uint32) {
	volatile.StoreUint32(&o.SET_INVALIDATE_JTAG.Reg, volatile.LoadUint32(&o.SET_INVALIDATE_JTAG.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_INVALIDATE_JTAG() uint32 {
	return volatile.LoadUint32(&o.SET_INVALIDATE_JTAG.Reg) & 0x1
}

// HMAC.SET_INVALIDATE_DS: Invalidate digital signature result register
func (o *HMAC_Type) SetSET_INVALIDATE_DS(value uint32) {
	volatile.StoreUint32(&o.SET_INVALIDATE_DS.Reg, volatile.LoadUint32(&o.SET_INVALIDATE_DS.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_INVALIDATE_DS() uint32 {
	return volatile.LoadUint32(&o.SET_INVALIDATE_DS.Reg) & 0x1
}

// HMAC.QUERY_ERROR: The matching result between key and purpose user configured
func (o *HMAC_Type) SetQUERY_ERROR_QUERY_CHECK(value uint32) {
	volatile.StoreUint32(&o.QUERY_ERROR.Reg, volatile.LoadUint32(&o.QUERY_ERROR.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetQUERY_ERROR_QUERY_CHECK() uint32 {
	return volatile.LoadUint32(&o.QUERY_ERROR.Reg) & 0x1
}

// HMAC.QUERY_BUSY: The busy state of HMAC module
func (o *HMAC_Type) SetQUERY_BUSY_BUSY_STATE(value uint32) {
	volatile.StoreUint32(&o.QUERY_BUSY.Reg, volatile.LoadUint32(&o.QUERY_BUSY.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetQUERY_BUSY_BUSY_STATE() uint32 {
	return volatile.LoadUint32(&o.QUERY_BUSY.Reg) & 0x1
}

// HMAC.WR_MESSAGE_0: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_0(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_0.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_0() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_0.Reg)
}

// HMAC.WR_MESSAGE_1: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_1(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_1.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_1() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_1.Reg)
}

// HMAC.WR_MESSAGE_2: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_2(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_2.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_2() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_2.Reg)
}

// HMAC.WR_MESSAGE_3: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_3(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_3.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_3() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_3.Reg)
}

// HMAC.WR_MESSAGE_4: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_4(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_4.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_4() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_4.Reg)
}

// HMAC.WR_MESSAGE_5: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_5(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_5.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_5() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_5.Reg)
}

// HMAC.WR_MESSAGE_6: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_6(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_6.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_6() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_6.Reg)
}

// HMAC.WR_MESSAGE_7: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_7(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_7.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_7() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_7.Reg)
}

// HMAC.WR_MESSAGE_8: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_8(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_8.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_8() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_8.Reg)
}

// HMAC.WR_MESSAGE_9: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_9(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_9.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_9() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_9.Reg)
}

// HMAC.WR_MESSAGE_10: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_10(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_10.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_10() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_10.Reg)
}

// HMAC.WR_MESSAGE_11: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_11(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_11.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_11() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_11.Reg)
}

// HMAC.WR_MESSAGE_12: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_12(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_12.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_12() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_12.Reg)
}

// HMAC.WR_MESSAGE_13: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_13(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_13.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_13() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_13.Reg)
}

// HMAC.WR_MESSAGE_14: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_14(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_14.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_14() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_14.Reg)
}

// HMAC.WR_MESSAGE_15: Message register %s
func (o *HMAC_Type) SetWR_MESSAGE_15(value uint32) {
	volatile.StoreUint32(&o.WR_MESSAGE_15.Reg, value)
}
func (o *HMAC_Type) GetWR_MESSAGE_15() uint32 {
	return volatile.LoadUint32(&o.WR_MESSAGE_15.Reg)
}

// HMAC.RD_RESULT_0: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_0(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_0.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_0() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_0.Reg)
}

// HMAC.RD_RESULT_1: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_1(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_1.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_1() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_1.Reg)
}

// HMAC.RD_RESULT_2: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_2(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_2.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_2() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_2.Reg)
}

// HMAC.RD_RESULT_3: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_3(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_3.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_3() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_3.Reg)
}

// HMAC.RD_RESULT_4: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_4(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_4.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_4() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_4.Reg)
}

// HMAC.RD_RESULT_5: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_5(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_5.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_5() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_5.Reg)
}

// HMAC.RD_RESULT_6: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_6(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_6.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_6() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_6.Reg)
}

// HMAC.RD_RESULT_7: Hash result register %s
func (o *HMAC_Type) SetRD_RESULT_7(value uint32) {
	volatile.StoreUint32(&o.RD_RESULT_7.Reg, value)
}
func (o *HMAC_Type) GetRD_RESULT_7() uint32 {
	return volatile.LoadUint32(&o.RD_RESULT_7.Reg)
}

// HMAC.SET_MESSAGE_PAD: Software padding register
func (o *HMAC_Type) SetSET_MESSAGE_PAD_SET_TEXT_PAD(value uint32) {
	volatile.StoreUint32(&o.SET_MESSAGE_PAD.Reg, volatile.LoadUint32(&o.SET_MESSAGE_PAD.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetSET_MESSAGE_PAD_SET_TEXT_PAD() uint32 {
	return volatile.LoadUint32(&o.SET_MESSAGE_PAD.Reg) & 0x1
}

// HMAC.ONE_BLOCK: One block message register.
func (o *HMAC_Type) SetONE_BLOCK_SET_ONE_BLOCK(value uint32) {
	volatile.StoreUint32(&o.ONE_BLOCK.Reg, volatile.LoadUint32(&o.ONE_BLOCK.Reg)&^(0x1)|value)
}
func (o *HMAC_Type) GetONE_BLOCK_SET_ONE_BLOCK() uint32 {
	return volatile.LoadUint32(&o.ONE_BLOCK.Reg) & 0x1
}

// HMAC.DATE: Version control register
func (o *HMAC_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *HMAC_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// I2C (Inter-Integrated Circuit) Controller 0
type I2C_Type struct {
	SCL_LOW_PERIOD       volatile.Register32 // 0x0
	CTR                  volatile.Register32 // 0x4
	SR                   volatile.Register32 // 0x8
	TO                   volatile.Register32 // 0xC
	SLAVE_ADDR           volatile.Register32 // 0x10
	FIFO_ST              volatile.Register32 // 0x14
	FIFO_CONF            volatile.Register32 // 0x18
	DATA                 volatile.Register32 // 0x1C
	INT_RAW              volatile.Register32 // 0x20
	INT_CLR              volatile.Register32 // 0x24
	INT_ENA              volatile.Register32 // 0x28
	INT_STATUS           volatile.Register32 // 0x2C
	SDA_HOLD             volatile.Register32 // 0x30
	SDA_SAMPLE           volatile.Register32 // 0x34
	SCL_HIGH_PERIOD      volatile.Register32 // 0x38
	_                    [4]byte
	SCL_START_HOLD       volatile.Register32 // 0x40
	SCL_RSTART_SETUP     volatile.Register32 // 0x44
	SCL_STOP_HOLD        volatile.Register32 // 0x48
	SCL_STOP_SETUP       volatile.Register32 // 0x4C
	SCL_FILTER_CFG       volatile.Register32 // 0x50
	SDA_FILTER_CFG       volatile.Register32 // 0x54
	COMD0                volatile.Register32 // 0x58
	COMD1                volatile.Register32 // 0x5C
	COMD2                volatile.Register32 // 0x60
	COMD3                volatile.Register32 // 0x64
	COMD4                volatile.Register32 // 0x68
	COMD5                volatile.Register32 // 0x6C
	COMD6                volatile.Register32 // 0x70
	COMD7                volatile.Register32 // 0x74
	COMD8                volatile.Register32 // 0x78
	COMD9                volatile.Register32 // 0x7C
	COMD10               volatile.Register32 // 0x80
	COMD11               volatile.Register32 // 0x84
	COMD12               volatile.Register32 // 0x88
	COMD13               volatile.Register32 // 0x8C
	COMD14               volatile.Register32 // 0x90
	COMD15               volatile.Register32 // 0x94
	SCL_ST_TIME_OUT      volatile.Register32 // 0x98
	SCL_MAIN_ST_TIME_OUT volatile.Register32 // 0x9C
	SCL_SP_CONF          volatile.Register32 // 0xA0
	SCL_STRETCH_CONF     volatile.Register32 // 0xA4
	_                    [80]byte
	DATE                 volatile.Register32 // 0xF8
}

// I2C.SCL_LOW_PERIOD: Configures the low level width of the SCL clock
func (o *I2C_Type) SetSCL_LOW_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_LOW_PERIOD.Reg, volatile.LoadUint32(&o.SCL_LOW_PERIOD.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetSCL_LOW_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_LOW_PERIOD.Reg) & 0x3fff
}

// I2C.CTR: Transmission setting
func (o *I2C_Type) SetCTR_SDA_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCTR_SDA_FORCE_OUT() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0x1
}
func (o *I2C_Type) SetCTR_SCL_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCTR_SCL_FORCE_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCTR_SAMPLE_SCL_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCTR_SAMPLE_SCL_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCTR_RX_FULL_ACK_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCTR_RX_FULL_ACK_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCTR_MS_MODE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCTR_MS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCTR_TRANS_START(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCTR_TRANS_START() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCTR_TX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCTR_TX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCTR_RX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCTR_RX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCTR_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetCTR_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetCTR_ARBITRATION_EN(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetCTR_ARBITRATION_EN() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetCTR_FSM_RST(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCTR_FSM_RST() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCTR_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCTR_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0x800) >> 11
}

// I2C.SR: Describe I2C work status
func (o *I2C_Type) SetSR_RESP_REC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSR_RESP_REC() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *I2C_Type) SetSR_SLAVE_RW(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetSR_SLAVE_RW() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetSR_TIME_OUT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetSR_TIME_OUT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetSR_ARB_LOST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetSR_ARB_LOST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetSR_BUS_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSR_BUS_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetSR_SLAVE_ADDRESSED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetSR_SLAVE_ADDRESSED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetSR_BYTE_TRANS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSR_BYTE_TRANS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSR_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x3f00)|value<<8)
}
func (o *I2C_Type) GetSR_RXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x3f00) >> 8
}
func (o *I2C_Type) SetSR_STRETCH_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xc000)|value<<14)
}
func (o *I2C_Type) GetSR_STRETCH_CAUSE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xc000) >> 14
}
func (o *I2C_Type) SetSR_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xfc0000)|value<<18)
}
func (o *I2C_Type) GetSR_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xfc0000) >> 18
}
func (o *I2C_Type) SetSR_SCL_MAIN_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x7000000)|value<<24)
}
func (o *I2C_Type) GetSR_SCL_MAIN_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x7000000) >> 24
}
func (o *I2C_Type) SetSR_SCL_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x70000000)|value<<28)
}
func (o *I2C_Type) GetSR_SCL_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x70000000) >> 28
}

// I2C.TO: Setting time out control for receiving data
func (o *I2C_Type) SetTO_TIME_OUT_VALUE(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0xffffff)|value)
}
func (o *I2C_Type) GetTO_TIME_OUT_VALUE() uint32 {
	return volatile.LoadUint32(&o.TO.Reg) & 0xffffff
}
func (o *I2C_Type) SetTO_TIME_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetTO_TIME_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TO.Reg) & 0x1000000) >> 24
}

// I2C.SLAVE_ADDR: Local slave address setting
func (o *I2C_Type) SetSLAVE_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x7fff)|value)
}
func (o *I2C_Type) GetSLAVE_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x7fff
}
func (o *I2C_Type) SetSLAVE_ADDR_ADDR_10BIT_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetSLAVE_ADDR_ADDR_10BIT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x80000000) >> 31
}

// I2C.FIFO_ST: FIFO status register
func (o *I2C_Type) SetFIFO_ST_RXFIFO_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetFIFO_ST_RXFIFO_START_ADDR() uint32 {
	return volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x1f
}
func (o *I2C_Type) SetFIFO_ST_RXFIFO_END_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x3e0)|value<<5)
}
func (o *I2C_Type) GetFIFO_ST_RXFIFO_END_ADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x3e0) >> 5
}
func (o *I2C_Type) SetFIFO_ST_TXFIFO_START_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x7c00)|value<<10)
}
func (o *I2C_Type) GetFIFO_ST_TXFIFO_START_ADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x7c00) >> 10
}
func (o *I2C_Type) SetFIFO_ST_TXFIFO_END_ADDR(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0xf8000)|value<<15)
}
func (o *I2C_Type) GetFIFO_ST_TXFIFO_END_ADDR() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0xf8000) >> 15
}
func (o *I2C_Type) SetFIFO_ST_RX_UPDATE(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetFIFO_ST_RX_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetFIFO_ST_TX_UPDATE(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetFIFO_ST_TX_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x200000) >> 21
}
func (o *I2C_Type) SetFIFO_ST_SLAVE_RW_POINT(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x3fc00000)|value<<22)
}
func (o *I2C_Type) GetFIFO_ST_SLAVE_RW_POINT() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x3fc00000) >> 22
}

// I2C.FIFO_CONF: FIFO configuration register
func (o *I2C_Type) SetFIFO_CONF_RXFIFO_WM_THRHD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1f)|value)
}
func (o *I2C_Type) GetFIFO_CONF_RXFIFO_WM_THRHD() uint32 {
	return volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1f
}
func (o *I2C_Type) SetFIFO_CONF_TXFIFO_WM_THRHD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3e0)|value<<5)
}
func (o *I2C_Type) GetFIFO_CONF_TXFIFO_WM_THRHD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3e0) >> 5
}
func (o *I2C_Type) SetFIFO_CONF_NONFIFO_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetFIFO_CONF_NONFIFO_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetFIFO_CONF_FIFO_ADDR_CFG_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetFIFO_CONF_FIFO_ADDR_CFG_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetFIFO_CONF_RX_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetFIFO_CONF_RX_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetFIFO_CONF_TX_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetFIFO_CONF_TX_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetFIFO_CONF_NONFIFO_RX_THRES(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *I2C_Type) GetFIFO_CONF_NONFIFO_RX_THRES() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0xfc000) >> 14
}
func (o *I2C_Type) SetFIFO_CONF_NONFIFO_TX_THRES(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3f00000)|value<<20)
}
func (o *I2C_Type) GetFIFO_CONF_NONFIFO_TX_THRES() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3f00000) >> 20
}
func (o *I2C_Type) SetFIFO_CONF_FIFO_PRT_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C_Type) GetFIFO_CONF_FIFO_PRT_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x4000000) >> 26
}

// I2C.DATA: RX FIFO read data
func (o *I2C_Type) SetDATA_FIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDATA_FIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xff
}

// I2C.INT_RAW: Raw interrupt status
func (o *I2C_Type) SetINT_RAW_RXFIFO_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_RAW_RXFIFO_WM_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *I2C_Type) SetINT_RAW_TXFIFO_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_RAW_TXFIFO_WM_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_RAW_END_DETECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_RAW_END_DETECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_RAW_BYTE_TRANS_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_RAW_BYTE_TRANS_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_RAW_ARBITRATION_LOST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_RAW_ARBITRATION_LOST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_RAW_MST_TXFIFO_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_RAW_MST_TXFIFO_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_RAW_TRANS_COMPLETE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_RAW_TRANS_COMPLETE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_RAW_TIME_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_RAW_TIME_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_RAW_TRANS_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_RAW_TRANS_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_RAW_NACK_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_RAW_NACK_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_RAW_TXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_RAW_TXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_RAW_RXFIFO_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_RAW_RXFIFO_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_RAW_SCL_ST_TO_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_RAW_SCL_ST_TO_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_RAW_SCL_MAIN_ST_TO_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_RAW_SCL_MAIN_ST_TO_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_RAW_DET_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_RAW_DET_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_RAW_SLAVE_STRETCH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_RAW_SLAVE_STRETCH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}

// I2C.INT_CLR: Interrupt clear bits
func (o *I2C_Type) SetINT_CLR_RXFIFO_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_CLR_RXFIFO_WM_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *I2C_Type) SetINT_CLR_TXFIFO_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_CLR_TXFIFO_WM_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_CLR_END_DETECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_CLR_END_DETECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_CLR_BYTE_TRANS_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_CLR_BYTE_TRANS_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_CLR_ARBITRATION_LOST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_CLR_ARBITRATION_LOST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_CLR_MST_TXFIFO_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_CLR_MST_TXFIFO_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_CLR_TRANS_COMPLETE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_CLR_TRANS_COMPLETE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_CLR_TIME_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_CLR_TIME_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_CLR_TRANS_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_CLR_TRANS_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_CLR_NACK_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_CLR_NACK_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_CLR_TXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_CLR_TXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_CLR_RXFIFO_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_CLR_RXFIFO_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_CLR_SCL_ST_TO_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_CLR_SCL_ST_TO_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_CLR_SCL_MAIN_ST_TO_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_CLR_SCL_MAIN_ST_TO_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_CLR_DET_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_CLR_DET_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_CLR_SLAVE_STRETCH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_CLR_SLAVE_STRETCH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}

// I2C.INT_ENA: Interrupt enable bits
func (o *I2C_Type) SetINT_ENA_RXFIFO_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_ENA_RXFIFO_WM_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *I2C_Type) SetINT_ENA_TXFIFO_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_ENA_TXFIFO_WM_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_ENA_END_DETECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_ENA_END_DETECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_ENA_BYTE_TRANS_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_ENA_BYTE_TRANS_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_ENA_ARBITRATION_LOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_ENA_ARBITRATION_LOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_ENA_MST_TXFIFO_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_ENA_MST_TXFIFO_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_ENA_TRANS_COMPLETE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_ENA_TRANS_COMPLETE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_ENA_TIME_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_ENA_TIME_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_ENA_TRANS_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_ENA_TRANS_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_ENA_NACK_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_ENA_NACK_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_ENA_TXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_ENA_TXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_ENA_RXFIFO_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_ENA_RXFIFO_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_ENA_SCL_ST_TO_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_ENA_SCL_ST_TO_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_ENA_SCL_MAIN_ST_TO_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_ENA_SCL_MAIN_ST_TO_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_ENA_DET_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_ENA_DET_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_ENA_SLAVE_STRETCH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_ENA_SLAVE_STRETCH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}

// I2C.INT_STATUS: Status of captured I2C communication events
func (o *I2C_Type) SetINT_STATUS_RXFIFO_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetINT_STATUS_RXFIFO_WM_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1
}
func (o *I2C_Type) SetINT_STATUS_TXFIFO_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetINT_STATUS_TXFIFO_WM_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetINT_STATUS_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetINT_STATUS_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetINT_STATUS_END_DETECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetINT_STATUS_END_DETECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetINT_STATUS_BYTE_TRANS_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetINT_STATUS_BYTE_TRANS_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetINT_STATUS_ARBITRATION_LOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetINT_STATUS_ARBITRATION_LOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetINT_STATUS_MST_TXFIFO_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetINT_STATUS_MST_TXFIFO_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetINT_STATUS_TRANS_COMPLETE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetINT_STATUS_TRANS_COMPLETE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetINT_STATUS_TIME_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetINT_STATUS_TIME_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetINT_STATUS_TRANS_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetINT_STATUS_TRANS_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetINT_STATUS_NACK_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetINT_STATUS_NACK_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetINT_STATUS_TXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetINT_STATUS_TXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetINT_STATUS_RXFIFO_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetINT_STATUS_RXFIFO_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetINT_STATUS_SCL_ST_TO_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetINT_STATUS_SCL_ST_TO_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetINT_STATUS_SCL_MAIN_ST_TO_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetINT_STATUS_SCL_MAIN_ST_TO_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetINT_STATUS_DET_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetINT_STATUS_DET_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetINT_STATUS_SLAVE_STRETCH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetINT_STATUS_SLAVE_STRETCH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10000) >> 16
}

// I2C.SDA_HOLD: Configures the hold time after a negative SCL edge
func (o *I2C_Type) SetSDA_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SDA_HOLD.Reg, volatile.LoadUint32(&o.SDA_HOLD.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSDA_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SDA_HOLD.Reg) & 0x3ff
}

// I2C.SDA_SAMPLE: Configures the sample time after a positive SCL edge
func (o *I2C_Type) SetSDA_SAMPLE_TIME(value uint32) {
	volatile.StoreUint32(&o.SDA_SAMPLE.Reg, volatile.LoadUint32(&o.SDA_SAMPLE.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSDA_SAMPLE_TIME() uint32 {
	return volatile.LoadUint32(&o.SDA_SAMPLE.Reg) & 0x3ff
}

// I2C.SCL_HIGH_PERIOD: Configures the high level width of the SCL clock
func (o *I2C_Type) SetSCL_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH_PERIOD.Reg, volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetSCL_HIGH_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg) & 0x3fff
}
func (o *I2C_Type) SetSCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH_PERIOD.Reg, volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg)&^(0xfffc000)|value<<14)
}
func (o *I2C_Type) GetSCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.SCL_HIGH_PERIOD.Reg) & 0xfffc000) >> 14
}

// I2C.SCL_START_HOLD: Configures the interval between pulling SDA low and pulling SCL low when the master generates a START condition
func (o *I2C_Type) SetSCL_START_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_START_HOLD.Reg, volatile.LoadUint32(&o.SCL_START_HOLD.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSCL_START_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_START_HOLD.Reg) & 0x3ff
}

// I2C.SCL_RSTART_SETUP: Configures the interval between the positive edge of SCL and the negative edge of SDA
func (o *I2C_Type) SetSCL_RSTART_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_RSTART_SETUP.Reg, volatile.LoadUint32(&o.SCL_RSTART_SETUP.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSCL_RSTART_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_RSTART_SETUP.Reg) & 0x3ff
}

// I2C.SCL_STOP_HOLD: Configures the delay after the SCL clock edge for a stop condition
func (o *I2C_Type) SetSCL_STOP_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_HOLD.Reg, volatile.LoadUint32(&o.SCL_STOP_HOLD.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetSCL_STOP_HOLD_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_HOLD.Reg) & 0x3fff
}

// I2C.SCL_STOP_SETUP: Configures the delay between the SDA and SCL positive edge for a stop condition
func (o *I2C_Type) SetSCL_STOP_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_SETUP.Reg, volatile.LoadUint32(&o.SCL_STOP_SETUP.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSCL_STOP_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_SETUP.Reg) & 0x3ff
}

// I2C.SCL_FILTER_CFG: SCL filter configuration register
func (o *I2C_Type) SetSCL_FILTER_CFG_SCL_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.SCL_FILTER_CFG.Reg, volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg)&^(0xf)|value)
}
func (o *I2C_Type) GetSCL_FILTER_CFG_SCL_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg) & 0xf
}
func (o *I2C_Type) SetSCL_FILTER_CFG_SCL_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_FILTER_CFG.Reg, volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSCL_FILTER_CFG_SCL_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_FILTER_CFG.Reg) & 0x10) >> 4
}

// I2C.SDA_FILTER_CFG: SDA filter configuration register
func (o *I2C_Type) SetSDA_FILTER_CFG_SDA_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.SDA_FILTER_CFG.Reg, volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg)&^(0xf)|value)
}
func (o *I2C_Type) GetSDA_FILTER_CFG_SDA_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg) & 0xf
}
func (o *I2C_Type) SetSDA_FILTER_CFG_SDA_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.SDA_FILTER_CFG.Reg, volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetSDA_FILTER_CFG_SDA_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.SDA_FILTER_CFG.Reg) & 0x10) >> 4
}

// I2C.COMD0: I2C command register %s
func (o *I2C_Type) SetCOMD0_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD0.Reg, volatile.LoadUint32(&o.COMD0.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD0_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD0.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD0_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD0.Reg, volatile.LoadUint32(&o.COMD0.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD0_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD0.Reg) & 0x80000000) >> 31
}

// I2C.COMD1: I2C command register %s
func (o *I2C_Type) SetCOMD1_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD1.Reg, volatile.LoadUint32(&o.COMD1.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD1_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD1.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD1_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD1.Reg, volatile.LoadUint32(&o.COMD1.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD1_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD1.Reg) & 0x80000000) >> 31
}

// I2C.COMD2: I2C command register %s
func (o *I2C_Type) SetCOMD2_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD2.Reg, volatile.LoadUint32(&o.COMD2.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD2_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD2.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD2_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD2.Reg, volatile.LoadUint32(&o.COMD2.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD2_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD2.Reg) & 0x80000000) >> 31
}

// I2C.COMD3: I2C command register %s
func (o *I2C_Type) SetCOMD3_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD3.Reg, volatile.LoadUint32(&o.COMD3.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD3_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD3.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD3_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD3.Reg, volatile.LoadUint32(&o.COMD3.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD3_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD3.Reg) & 0x80000000) >> 31
}

// I2C.COMD4: I2C command register %s
func (o *I2C_Type) SetCOMD4_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD4.Reg, volatile.LoadUint32(&o.COMD4.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD4_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD4.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD4_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD4.Reg, volatile.LoadUint32(&o.COMD4.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD4_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD4.Reg) & 0x80000000) >> 31
}

// I2C.COMD5: I2C command register %s
func (o *I2C_Type) SetCOMD5_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD5.Reg, volatile.LoadUint32(&o.COMD5.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD5_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD5.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD5_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD5.Reg, volatile.LoadUint32(&o.COMD5.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD5_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD5.Reg) & 0x80000000) >> 31
}

// I2C.COMD6: I2C command register %s
func (o *I2C_Type) SetCOMD6_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD6.Reg, volatile.LoadUint32(&o.COMD6.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD6_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD6.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD6_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD6.Reg, volatile.LoadUint32(&o.COMD6.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD6_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD6.Reg) & 0x80000000) >> 31
}

// I2C.COMD7: I2C command register %s
func (o *I2C_Type) SetCOMD7_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD7.Reg, volatile.LoadUint32(&o.COMD7.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD7_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD7.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD7_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD7.Reg, volatile.LoadUint32(&o.COMD7.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD7_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD7.Reg) & 0x80000000) >> 31
}

// I2C.COMD8: I2C command register %s
func (o *I2C_Type) SetCOMD8_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD8.Reg, volatile.LoadUint32(&o.COMD8.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD8_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD8.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD8_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD8.Reg, volatile.LoadUint32(&o.COMD8.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD8_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD8.Reg) & 0x80000000) >> 31
}

// I2C.COMD9: I2C command register %s
func (o *I2C_Type) SetCOMD9_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD9.Reg, volatile.LoadUint32(&o.COMD9.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD9_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD9.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD9_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD9.Reg, volatile.LoadUint32(&o.COMD9.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD9_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD9.Reg) & 0x80000000) >> 31
}

// I2C.COMD10: I2C command register %s
func (o *I2C_Type) SetCOMD10_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD10.Reg, volatile.LoadUint32(&o.COMD10.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD10_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD10.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD10_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD10.Reg, volatile.LoadUint32(&o.COMD10.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD10_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD10.Reg) & 0x80000000) >> 31
}

// I2C.COMD11: I2C command register %s
func (o *I2C_Type) SetCOMD11_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD11.Reg, volatile.LoadUint32(&o.COMD11.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD11_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD11.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD11_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD11.Reg, volatile.LoadUint32(&o.COMD11.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD11_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD11.Reg) & 0x80000000) >> 31
}

// I2C.COMD12: I2C command register %s
func (o *I2C_Type) SetCOMD12_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD12.Reg, volatile.LoadUint32(&o.COMD12.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD12_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD12.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD12_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD12.Reg, volatile.LoadUint32(&o.COMD12.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD12_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD12.Reg) & 0x80000000) >> 31
}

// I2C.COMD13: I2C command register %s
func (o *I2C_Type) SetCOMD13_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD13.Reg, volatile.LoadUint32(&o.COMD13.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD13_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD13.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD13_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD13.Reg, volatile.LoadUint32(&o.COMD13.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD13_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD13.Reg) & 0x80000000) >> 31
}

// I2C.COMD14: I2C command register %s
func (o *I2C_Type) SetCOMD14_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD14.Reg, volatile.LoadUint32(&o.COMD14.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD14_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD14.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD14_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD14.Reg, volatile.LoadUint32(&o.COMD14.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD14_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD14.Reg) & 0x80000000) >> 31
}

// I2C.COMD15: I2C command register %s
func (o *I2C_Type) SetCOMD15_COMMAND(value uint32) {
	volatile.StoreUint32(&o.COMD15.Reg, volatile.LoadUint32(&o.COMD15.Reg)&^(0x3fff)|value)
}
func (o *I2C_Type) GetCOMD15_COMMAND() uint32 {
	return volatile.LoadUint32(&o.COMD15.Reg) & 0x3fff
}
func (o *I2C_Type) SetCOMD15_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.COMD15.Reg, volatile.LoadUint32(&o.COMD15.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetCOMD15_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.COMD15.Reg) & 0x80000000) >> 31
}

// I2C.SCL_ST_TIME_OUT: SCL status time out register
func (o *I2C_Type) SetSCL_ST_TIME_OUT_SCL_ST_TO(value uint32) {
	volatile.StoreUint32(&o.SCL_ST_TIME_OUT.Reg, volatile.LoadUint32(&o.SCL_ST_TIME_OUT.Reg)&^(0xffffff)|value)
}
func (o *I2C_Type) GetSCL_ST_TIME_OUT_SCL_ST_TO() uint32 {
	return volatile.LoadUint32(&o.SCL_ST_TIME_OUT.Reg) & 0xffffff
}

// I2C.SCL_MAIN_ST_TIME_OUT: SCL main status time out register
func (o *I2C_Type) SetSCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO(value uint32) {
	volatile.StoreUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg, volatile.LoadUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg)&^(0xffffff)|value)
}
func (o *I2C_Type) GetSCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO() uint32 {
	return volatile.LoadUint32(&o.SCL_MAIN_ST_TIME_OUT.Reg) & 0xffffff
}

// I2C.SCL_SP_CONF: Power configuration register
func (o *I2C_Type) SetSCL_SP_CONF_SCL_RST_SLV_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetSCL_SP_CONF_SCL_RST_SLV_EN() uint32 {
	return volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x1
}
func (o *I2C_Type) SetSCL_SP_CONF_SCL_RST_SLV_NUM(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x3e)|value<<1)
}
func (o *I2C_Type) GetSCL_SP_CONF_SCL_RST_SLV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x3e) >> 1
}
func (o *I2C_Type) SetSCL_SP_CONF_SCL_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetSCL_SP_CONF_SCL_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetSCL_SP_CONF_SDA_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_SP_CONF.Reg, volatile.LoadUint32(&o.SCL_SP_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetSCL_SP_CONF_SDA_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_SP_CONF.Reg) & 0x80) >> 7
}

// I2C.SCL_STRETCH_CONF: Set SCL stretch of I2C slave
func (o *I2C_Type) SetSCL_STRETCH_CONF_STRETCH_PROTECT_NUM(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_STRETCH_PROTECT_NUM() uint32 {
	return volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x3ff
}
func (o *I2C_Type) SetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR(value uint32) {
	volatile.StoreUint32(&o.SCL_STRETCH_CONF.Reg, volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetSCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR() uint32 {
	return (volatile.LoadUint32(&o.SCL_STRETCH_CONF.Reg) & 0x800) >> 11
}

// I2C.DATE: Version control register
func (o *I2C_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *I2C_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// I2S (Inter-IC Sound) Controller 0
type I2S_Type struct {
	_                    [8]byte
	CONF                 volatile.Register32 // 0x8
	INT_RAW              volatile.Register32 // 0xC
	INT_ST               volatile.Register32 // 0x10
	INT_ENA              volatile.Register32 // 0x14
	INT_CLR              volatile.Register32 // 0x18
	TIMING               volatile.Register32 // 0x1C
	FIFO_CONF            volatile.Register32 // 0x20
	RXEOF_NUM            volatile.Register32 // 0x24
	CONF_SIGLE_DATA      volatile.Register32 // 0x28
	CONF_CHAN            volatile.Register32 // 0x2C
	OUT_LINK             volatile.Register32 // 0x30
	IN_LINK              volatile.Register32 // 0x34
	OUT_EOF_DES_ADDR     volatile.Register32 // 0x38
	IN_EOF_DES_ADDR      volatile.Register32 // 0x3C
	OUT_EOF_BFR_DES_ADDR volatile.Register32 // 0x40
	_                    [4]byte
	INLINK_DSCR          volatile.Register32 // 0x48
	INLINK_DSCR_BF0      volatile.Register32 // 0x4C
	INLINK_DSCR_BF1      volatile.Register32 // 0x50
	OUTLINK_DSCR         volatile.Register32 // 0x54
	OUTLINK_DSCR_BF0     volatile.Register32 // 0x58
	OUTLINK_DSCR_BF1     volatile.Register32 // 0x5C
	LC_CONF              volatile.Register32 // 0x60
	OUTFIFO_PUSH         volatile.Register32 // 0x64
	INFIFO_POP           volatile.Register32 // 0x68
	LC_STATE0            volatile.Register32 // 0x6C
	LC_STATE1            volatile.Register32 // 0x70
	LC_HUNG_CONF         volatile.Register32 // 0x74
	_                    [40]byte
	CONF1                volatile.Register32 // 0xA0
	PD_CONF              volatile.Register32 // 0xA4
	CONF2                volatile.Register32 // 0xA8
	CLKM_CONF            volatile.Register32 // 0xAC
	SAMPLE_RATE_CONF     volatile.Register32 // 0xB0
	_                    [8]byte
	STATE                volatile.Register32 // 0xBC
	_                    [60]byte
	DATE                 volatile.Register32 // 0xFC
}

// I2S.CONF: I2S configuration register
func (o *I2S_Type) SetCONF_TX_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetCONF_TX_RESET() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *I2S_Type) SetCONF_RX_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetCONF_RX_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetCONF_TX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetCONF_TX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetCONF_RX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCONF_RX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCONF_TX_START(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetCONF_TX_START() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetCONF_RX_START(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetCONF_RX_START() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetCONF_TX_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetCONF_TX_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetCONF_RX_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCONF_RX_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCONF_TX_RIGHT_FIRST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCONF_TX_RIGHT_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCONF_RX_RIGHT_FIRST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCONF_RX_RIGHT_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetCONF_TX_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetCONF_TX_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetCONF_RX_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetCONF_RX_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetCONF_TX_SHORT_SYNC(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetCONF_TX_SHORT_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetCONF_RX_SHORT_SYNC(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetCONF_RX_SHORT_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetCONF_TX_MONO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetCONF_TX_MONO() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetCONF_RX_MONO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetCONF_RX_MONO() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetCONF_TX_MSB_RIGHT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetCONF_TX_MSB_RIGHT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetCONF_RX_MSB_RIGHT(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetCONF_RX_MSB_RIGHT() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetCONF_TX_LSB_FIRST_DMA(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetCONF_TX_LSB_FIRST_DMA() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetCONF_RX_LSB_FIRST_DMA(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetCONF_RX_LSB_FIRST_DMA() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetCONF_SIG_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetCONF_SIG_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetCONF_TX_FIFO_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetCONF_TX_FIFO_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetCONF_RX_FIFO_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetCONF_RX_FIFO_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetCONF_TX_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetCONF_TX_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x800000) >> 23
}
func (o *I2S_Type) SetCONF_TX_DMA_EQUAL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetCONF_TX_DMA_EQUAL() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetCONF_RX_DMA_EQUAL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetCONF_RX_DMA_EQUAL() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetCONF_PRE_REQ_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S_Type) GetCONF_PRE_REQ_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4000000) >> 26
}
func (o *I2S_Type) SetCONF_TX_BIG_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *I2S_Type) GetCONF_TX_BIG_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8000000) >> 27
}
func (o *I2S_Type) SetCONF_RX_BIG_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetCONF_RX_BIG_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetCONF_RX_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetCONF_RX_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x20000000) >> 29
}

// I2S.INT_RAW: Raw interrupt status
func (o *I2S_Type) SetINT_RAW_RX_TAKE_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_RAW_RX_TAKE_DATA_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *I2S_Type) SetINT_RAW_TX_PUT_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_RAW_TX_PUT_DATA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_RAW_RX_WFULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_RAW_RX_WFULL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_RAW_RX_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_RAW_RX_REMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_RAW_TX_WFULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_RAW_TX_WFULL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_RAW_TX_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_RAW_TX_REMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_RAW_RX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_RAW_RX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_RAW_TX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_RAW_TX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_RAW_IN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_RAW_IN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_RAW_IN_SUC_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_RAW_IN_SUC_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_RAW_IN_ERR_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_RAW_IN_ERR_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_RAW_OUT_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_RAW_OUT_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_RAW_OUT_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_RAW_OUT_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_RAW_IN_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_RAW_IN_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_RAW_OUT_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_RAW_OUT_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_RAW_IN_DSCR_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_RAW_IN_DSCR_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_RAW_OUT_TOTAL_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_RAW_OUT_TOTAL_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_RAW_V_SYNC_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_RAW_V_SYNC_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}

// I2S.INT_ST: Masked interrupt status
func (o *I2S_Type) SetINT_ST_RX_TAKE_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_ST_RX_TAKE_DATA_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *I2S_Type) SetINT_ST_TX_PUT_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_ST_TX_PUT_DATA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_ST_RX_WFULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_ST_RX_WFULL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_ST_RX_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_ST_RX_REMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_ST_TX_WFULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_ST_TX_WFULL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_ST_TX_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_ST_TX_REMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_ST_RX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_ST_RX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_ST_TX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_ST_TX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_ST_IN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_ST_IN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_ST_IN_SUC_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_ST_IN_SUC_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_ST_IN_ERR_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_ST_IN_ERR_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_ST_OUT_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_ST_OUT_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_ST_OUT_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_ST_OUT_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_ST_IN_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_ST_IN_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_ST_OUT_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_ST_OUT_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_ST_IN_DSCR_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_ST_IN_DSCR_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_ST_OUT_TOTAL_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_ST_OUT_TOTAL_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_ST_V_SYNC_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_ST_V_SYNC_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}

// I2S.INT_ENA: Interrupt enable bits
func (o *I2S_Type) SetINT_ENA_RX_TAKE_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_ENA_RX_TAKE_DATA_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *I2S_Type) SetINT_ENA_TX_PUT_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_ENA_TX_PUT_DATA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_ENA_RX_WFULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_ENA_RX_WFULL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_ENA_RX_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_ENA_RX_REMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_ENA_TX_WFULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_ENA_TX_WFULL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_ENA_TX_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_ENA_TX_REMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_ENA_RX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_ENA_RX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_ENA_TX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_ENA_TX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_ENA_IN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_ENA_IN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_ENA_IN_SUC_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_ENA_IN_SUC_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_ENA_IN_ERR_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_ENA_IN_ERR_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_ENA_OUT_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_ENA_OUT_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_ENA_OUT_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_ENA_OUT_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_ENA_IN_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_ENA_IN_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_ENA_OUT_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_ENA_OUT_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_ENA_IN_DSCR_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_ENA_IN_DSCR_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_ENA_OUT_TOTAL_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_ENA_OUT_TOTAL_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_ENA_V_SYNC_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_ENA_V_SYNC_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}

// I2S.INT_CLR: Interrupt clear bits
func (o *I2S_Type) SetINT_CLR_TAKE_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINT_CLR_TAKE_DATA_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *I2S_Type) SetINT_CLR_PUT_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINT_CLR_PUT_DATA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINT_CLR_RX_WFULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetINT_CLR_RX_WFULL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetINT_CLR_RX_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetINT_CLR_RX_REMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetINT_CLR_TX_WFULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINT_CLR_TX_WFULL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINT_CLR_TX_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINT_CLR_TX_REMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINT_CLR_RX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetINT_CLR_RX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetINT_CLR_TX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetINT_CLR_TX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetINT_CLR_IN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINT_CLR_IN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINT_CLR_IN_SUC_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINT_CLR_IN_SUC_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINT_CLR_IN_ERR_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetINT_CLR_IN_ERR_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetINT_CLR_OUT_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetINT_CLR_OUT_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetINT_CLR_OUT_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINT_CLR_OUT_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINT_CLR_IN_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINT_CLR_IN_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetINT_CLR_OUT_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetINT_CLR_OUT_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetINT_CLR_IN_DSCR_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetINT_CLR_IN_DSCR_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetINT_CLR_OUT_TOTAL_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINT_CLR_OUT_TOTAL_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetINT_CLR_V_SYNC_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetINT_CLR_V_SYNC_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}

// I2S.TIMING: I2S timing register
func (o *I2S_Type) SetTIMING_TX_BCK_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetTIMING_TX_BCK_IN_DELAY() uint32 {
	return volatile.LoadUint32(&o.TIMING.Reg) & 0x3
}
func (o *I2S_Type) SetTIMING_TX_WS_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc)|value<<2)
}
func (o *I2S_Type) GetTIMING_TX_WS_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc) >> 2
}
func (o *I2S_Type) SetTIMING_RX_BCK_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x30)|value<<4)
}
func (o *I2S_Type) GetTIMING_RX_BCK_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x30) >> 4
}
func (o *I2S_Type) SetTIMING_RX_WS_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc0)|value<<6)
}
func (o *I2S_Type) GetTIMING_RX_WS_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc0) >> 6
}
func (o *I2S_Type) SetTIMING_RX_SD_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x300)|value<<8)
}
func (o *I2S_Type) GetTIMING_RX_SD_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x300) >> 8
}
func (o *I2S_Type) SetTIMING_TX_BCK_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc00)|value<<10)
}
func (o *I2S_Type) GetTIMING_TX_BCK_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc00) >> 10
}
func (o *I2S_Type) SetTIMING_TX_WS_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x3000)|value<<12)
}
func (o *I2S_Type) GetTIMING_TX_WS_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x3000) >> 12
}
func (o *I2S_Type) SetTIMING_TX_SD_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc000)|value<<14)
}
func (o *I2S_Type) GetTIMING_TX_SD_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc000) >> 14
}
func (o *I2S_Type) SetTIMING_RX_WS_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetTIMING_RX_WS_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetTIMING_RX_BCK_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetTIMING_RX_BCK_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetTIMING_TX_DSYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetTIMING_TX_DSYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetTIMING_RX_DSYNC_SW(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetTIMING_RX_DSYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetTIMING_DATA_ENABLE_DELAY(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0xc00000)|value<<22)
}
func (o *I2S_Type) GetTIMING_DATA_ENABLE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0xc00000) >> 22
}
func (o *I2S_Type) SetTIMING_TX_BCK_IN_INV(value uint32) {
	volatile.StoreUint32(&o.TIMING.Reg, volatile.LoadUint32(&o.TIMING.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetTIMING_TX_BCK_IN_INV() uint32 {
	return (volatile.LoadUint32(&o.TIMING.Reg) & 0x1000000) >> 24
}

// I2S.FIFO_CONF: I2S FIFO configuration register
func (o *I2S_Type) SetFIFO_CONF_RX_DATA_NUM(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetFIFO_CONF_RX_DATA_NUM() uint32 {
	return volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x3f
}
func (o *I2S_Type) SetFIFO_CONF_TX_DATA_NUM(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *I2S_Type) GetFIFO_CONF_TX_DATA_NUM() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0xfc0) >> 6
}
func (o *I2S_Type) SetFIFO_CONF_DSCR_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetFIFO_CONF_DSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetFIFO_CONF_TX_FIFO_MOD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0xe000)|value<<13)
}
func (o *I2S_Type) GetFIFO_CONF_TX_FIFO_MOD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0xe000) >> 13
}
func (o *I2S_Type) SetFIFO_CONF_RX_FIFO_MOD(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x70000)|value<<16)
}
func (o *I2S_Type) GetFIFO_CONF_RX_FIFO_MOD() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x70000) >> 16
}
func (o *I2S_Type) SetFIFO_CONF_TX_FIFO_MOD_FORCE_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetFIFO_CONF_TX_FIFO_MOD_FORCE_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetFIFO_CONF_RX_FIFO_MOD_FORCE_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetFIFO_CONF_RX_FIFO_MOD_FORCE_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetFIFO_CONF_RX_FIFO_SYNC(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetFIFO_CONF_RX_FIFO_SYNC() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetFIFO_CONF_RX_24MSB_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetFIFO_CONF_RX_24MSB_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetFIFO_CONF_TX_24MSB_EN(value uint32) {
	volatile.StoreUint32(&o.FIFO_CONF.Reg, volatile.LoadUint32(&o.FIFO_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetFIFO_CONF_TX_24MSB_EN() uint32 {
	return (volatile.LoadUint32(&o.FIFO_CONF.Reg) & 0x800000) >> 23
}

// I2S.RXEOF_NUM: I2S DMA RX EOF data length
func (o *I2S_Type) SetRXEOF_NUM(value uint32) {
	volatile.StoreUint32(&o.RXEOF_NUM.Reg, value)
}
func (o *I2S_Type) GetRXEOF_NUM() uint32 {
	return volatile.LoadUint32(&o.RXEOF_NUM.Reg)
}

// I2S.CONF_SIGLE_DATA: Constant single channel data
func (o *I2S_Type) SetCONF_SIGLE_DATA(value uint32) {
	volatile.StoreUint32(&o.CONF_SIGLE_DATA.Reg, value)
}
func (o *I2S_Type) GetCONF_SIGLE_DATA() uint32 {
	return volatile.LoadUint32(&o.CONF_SIGLE_DATA.Reg)
}

// I2S.CONF_CHAN: I2S channel configuration register
func (o *I2S_Type) SetCONF_CHAN_TX_CHAN_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF_CHAN.Reg, volatile.LoadUint32(&o.CONF_CHAN.Reg)&^(0x7)|value)
}
func (o *I2S_Type) GetCONF_CHAN_TX_CHAN_MOD() uint32 {
	return volatile.LoadUint32(&o.CONF_CHAN.Reg) & 0x7
}
func (o *I2S_Type) SetCONF_CHAN_RX_CHAN_MOD(value uint32) {
	volatile.StoreUint32(&o.CONF_CHAN.Reg, volatile.LoadUint32(&o.CONF_CHAN.Reg)&^(0x18)|value<<3)
}
func (o *I2S_Type) GetCONF_CHAN_RX_CHAN_MOD() uint32 {
	return (volatile.LoadUint32(&o.CONF_CHAN.Reg) & 0x18) >> 3
}

// I2S.OUT_LINK: I2S DMA TX configuration register
func (o *I2S_Type) SetOUT_LINK_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0xfffff)|value)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_LINK.Reg) & 0xfffff
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetOUT_LINK_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.OUT_LINK.Reg, volatile.LoadUint32(&o.OUT_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetOUT_LINK_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.OUT_LINK.Reg) & 0x80000000) >> 31
}

// I2S.IN_LINK: I2S DMA RX configuration register
func (o *I2S_Type) SetIN_LINK_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0xfffff)|value)
}
func (o *I2S_Type) GetIN_LINK_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_LINK.Reg) & 0xfffff
}
func (o *I2S_Type) SetIN_LINK_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetIN_LINK_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetIN_LINK_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetIN_LINK_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetIN_LINK_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetIN_LINK_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetIN_LINK_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.IN_LINK.Reg, volatile.LoadUint32(&o.IN_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetIN_LINK_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.IN_LINK.Reg) & 0x80000000) >> 31
}

// I2S.OUT_EOF_DES_ADDR: Address of outlink descriptor that produces EOF
func (o *I2S_Type) SetOUT_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_DES_ADDR.Reg, value)
}
func (o *I2S_Type) GetOUT_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_DES_ADDR.Reg)
}

// I2S.IN_EOF_DES_ADDR: Address of inlink descriptor that produces EOF
func (o *I2S_Type) SetIN_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_EOF_DES_ADDR.Reg, value)
}
func (o *I2S_Type) GetIN_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_EOF_DES_ADDR.Reg)
}

// I2S.OUT_EOF_BFR_DES_ADDR: Address of buffer relative to the outlink descriptor that produces EOF
func (o *I2S_Type) SetOUT_EOF_BFR_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_BFR_DES_ADDR.Reg, value)
}
func (o *I2S_Type) GetOUT_EOF_BFR_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_BFR_DES_ADDR.Reg)
}

// I2S.INLINK_DSCR: Address of current inlink descriptor
func (o *I2S_Type) SetINLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR.Reg, value)
}
func (o *I2S_Type) GetINLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR.Reg)
}

// I2S.INLINK_DSCR_BF0: Address of next inlink descriptor
func (o *I2S_Type) SetINLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR_BF0.Reg, value)
}
func (o *I2S_Type) GetINLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR_BF0.Reg)
}

// I2S.INLINK_DSCR_BF1: Address of next inlink data buffer
func (o *I2S_Type) SetINLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR_BF1.Reg, value)
}
func (o *I2S_Type) GetINLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR_BF1.Reg)
}

// I2S.OUTLINK_DSCR: Address of current outlink descriptor
func (o *I2S_Type) SetOUTLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR.Reg, value)
}
func (o *I2S_Type) GetOUTLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR.Reg)
}

// I2S.OUTLINK_DSCR_BF0: Address of next outlink descriptor
func (o *I2S_Type) SetOUTLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR_BF0.Reg, value)
}
func (o *I2S_Type) GetOUTLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR_BF0.Reg)
}

// I2S.OUTLINK_DSCR_BF1: Address of next outlink data buffer
func (o *I2S_Type) SetOUTLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR_BF1.Reg, value)
}
func (o *I2S_Type) GetOUTLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR_BF1.Reg)
}

// I2S.LC_CONF: I2S DMA configuration register
func (o *I2S_Type) SetLC_CONF_IN_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetLC_CONF_IN_RST() uint32 {
	return volatile.LoadUint32(&o.LC_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetLC_CONF_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetLC_CONF_OUT_RST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetLC_CONF_AHBM_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetLC_CONF_AHBM_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetLC_CONF_AHBM_RST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetLC_CONF_AHBM_RST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetLC_CONF_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetLC_CONF_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetLC_CONF_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetLC_CONF_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetLC_CONF_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetLC_CONF_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetLC_CONF_OUT_NO_RESTART_CLR(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetLC_CONF_OUT_NO_RESTART_CLR() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetLC_CONF_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetLC_CONF_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetLC_CONF_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetLC_CONF_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetLC_CONF_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetLC_CONF_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetLC_CONF_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetLC_CONF_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetLC_CONF_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetLC_CONF_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetLC_CONF_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetLC_CONF_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetLC_CONF_EXT_MEM_BK_SIZE(value uint32) {
	volatile.StoreUint32(&o.LC_CONF.Reg, volatile.LoadUint32(&o.LC_CONF.Reg)&^(0xc000)|value<<14)
}
func (o *I2S_Type) GetLC_CONF_EXT_MEM_BK_SIZE() uint32 {
	return (volatile.LoadUint32(&o.LC_CONF.Reg) & 0xc000) >> 14
}

// I2S.OUTFIFO_PUSH: APB out FIFO mode register
func (o *I2S_Type) SetOUTFIFO_PUSH_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_PUSH.Reg, volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg)&^(0x1ff)|value)
}
func (o *I2S_Type) GetOUTFIFO_PUSH_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg) & 0x1ff
}
func (o *I2S_Type) SetOUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.OUTFIFO_PUSH.Reg, volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetOUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.OUTFIFO_PUSH.Reg) & 0x10000) >> 16
}

// I2S.INFIFO_POP: APB in FIFO mode register
func (o *I2S_Type) SetINFIFO_POP_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.INFIFO_POP.Reg, volatile.LoadUint32(&o.INFIFO_POP.Reg)&^(0xfff)|value)
}
func (o *I2S_Type) GetINFIFO_POP_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.INFIFO_POP.Reg) & 0xfff
}
func (o *I2S_Type) SetINFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.INFIFO_POP.Reg, volatile.LoadUint32(&o.INFIFO_POP.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetINFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.INFIFO_POP.Reg) & 0x10000) >> 16
}

// I2S.LC_STATE0: I2S DMA TX status
func (o *I2S_Type) SetLC_STATE0_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x3ffff)|value)
}
func (o *I2S_Type) GetLC_STATE0_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x3ffff
}
func (o *I2S_Type) SetLC_STATE0_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetLC_STATE0_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetLC_STATE0_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x700000)|value<<20)
}
func (o *I2S_Type) GetLC_STATE0_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x700000) >> 20
}
func (o *I2S_Type) SetLC_STATE0_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x3f800000)|value<<23)
}
func (o *I2S_Type) GetLC_STATE0_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x3f800000) >> 23
}
func (o *I2S_Type) SetLC_STATE0_OUT_FULL(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetLC_STATE0_OUT_FULL() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetLC_STATE0_OUT_EMPTY(value uint32) {
	volatile.StoreUint32(&o.LC_STATE0.Reg, volatile.LoadUint32(&o.LC_STATE0.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetLC_STATE0_OUT_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE0.Reg) & 0x80000000) >> 31
}

// I2S.LC_STATE1: I2S DMA RX status
func (o *I2S_Type) SetLC_STATE1_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x3ffff)|value)
}
func (o *I2S_Type) GetLC_STATE1_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x3ffff
}
func (o *I2S_Type) SetLC_STATE1_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetLC_STATE1_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetLC_STATE1_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x700000)|value<<20)
}
func (o *I2S_Type) GetLC_STATE1_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x700000) >> 20
}
func (o *I2S_Type) SetLC_STATE1_INFIFO_CNT_DEBUG(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x3f800000)|value<<23)
}
func (o *I2S_Type) GetLC_STATE1_INFIFO_CNT_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x3f800000) >> 23
}
func (o *I2S_Type) SetLC_STATE1_IN_FULL(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetLC_STATE1_IN_FULL() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetLC_STATE1_IN_EMPTY(value uint32) {
	volatile.StoreUint32(&o.LC_STATE1.Reg, volatile.LoadUint32(&o.LC_STATE1.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetLC_STATE1_IN_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.LC_STATE1.Reg) & 0x80000000) >> 31
}

// I2S.LC_HUNG_CONF: I2S Hung configuration register
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0x700)|value<<8)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0x700) >> 8
}
func (o *I2S_Type) SetLC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.LC_HUNG_CONF.Reg, volatile.LoadUint32(&o.LC_HUNG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetLC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.LC_HUNG_CONF.Reg) & 0x800) >> 11
}

// I2S.CONF1: I2S configuration register 1
func (o *I2S_Type) SetCONF1_TX_PCM_CONF(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x7)|value)
}
func (o *I2S_Type) GetCONF1_TX_PCM_CONF() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x7
}
func (o *I2S_Type) SetCONF1_TX_PCM_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCONF1_TX_PCM_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCONF1_RX_PCM_CONF(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x70)|value<<4)
}
func (o *I2S_Type) GetCONF1_RX_PCM_CONF() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x70) >> 4
}
func (o *I2S_Type) SetCONF1_RX_PCM_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCONF1_RX_PCM_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCONF1_TX_STOP_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCONF1_TX_STOP_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCONF1_TX_ZEROS_RM_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCONF1_TX_ZEROS_RM_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x200) >> 9
}

// I2S.PD_CONF: I2S power-down configuration register
func (o *I2S_Type) SetPD_CONF_FIFO_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetPD_CONF_FIFO_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.PD_CONF.Reg) & 0x1
}
func (o *I2S_Type) SetPD_CONF_FIFO_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetPD_CONF_FIFO_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetPD_CONF_PLC_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetPD_CONF_PLC_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetPD_CONF_PLC_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetPD_CONF_PLC_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetPD_CONF_DMA_RAM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetPD_CONF_DMA_RAM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetPD_CONF_DMA_RAM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetPD_CONF_DMA_RAM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetPD_CONF_DMA_RAM_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.PD_CONF.Reg, volatile.LoadUint32(&o.PD_CONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetPD_CONF_DMA_RAM_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.PD_CONF.Reg) & 0x40) >> 6
}

// I2S.CONF2: I2S configuration register 2
func (o *I2S_Type) SetCONF2_CAMERA_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetCONF2_CAMERA_EN() uint32 {
	return volatile.LoadUint32(&o.CONF2.Reg) & 0x1
}
func (o *I2S_Type) SetCONF2_LCD_TX_WRX2_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetCONF2_LCD_TX_WRX2_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetCONF2_LCD_TX_SDX2_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetCONF2_LCD_TX_SDX2_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetCONF2_DATA_ENABLE_TEST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCONF2_DATA_ENABLE_TEST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCONF2_DATA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetCONF2_DATA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetCONF2_LCD_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetCONF2_LCD_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetCONF2_EXT_ADC_START_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetCONF2_EXT_ADC_START_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetCONF2_INTER_VALID_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCONF2_INTER_VALID_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCONF2_CAM_SYNC_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCONF2_CAM_SYNC_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCONF2_CAM_CLK_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCONF2_CAM_CLK_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetCONF2_VSYNC_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetCONF2_VSYNC_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetCONF2_VSYNC_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CONF2.Reg, volatile.LoadUint32(&o.CONF2.Reg)&^(0x3800)|value<<11)
}
func (o *I2S_Type) GetCONF2_VSYNC_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CONF2.Reg) & 0x3800) >> 11
}

// I2S.CLKM_CONF: I2S module clock configuration register
func (o *I2S_Type) SetCLKM_CONF_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetCLKM_CONF_CLKM_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xff
}
func (o *I2S_Type) SetCLKM_CONF_CLKM_DIV_B(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x3f00)|value<<8)
}
func (o *I2S_Type) GetCLKM_CONF_CLKM_DIV_B() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x3f00) >> 8
}
func (o *I2S_Type) SetCLKM_CONF_CLKM_DIV_A(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0xfc000)|value<<14)
}
func (o *I2S_Type) GetCLKM_CONF_CLKM_DIV_A() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0xfc000) >> 14
}
func (o *I2S_Type) SetCLKM_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetCLKM_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetCLKM_CONF_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CLKM_CONF.Reg, volatile.LoadUint32(&o.CLKM_CONF.Reg)&^(0x600000)|value<<21)
}
func (o *I2S_Type) GetCLKM_CONF_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLKM_CONF.Reg) & 0x600000) >> 21
}

// I2S.SAMPLE_RATE_CONF: I2S sample rate register
func (o *I2S_Type) SetSAMPLE_RATE_CONF_TX_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_TX_BCK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0x3f
}
func (o *I2S_Type) SetSAMPLE_RATE_CONF_RX_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_RX_BCK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0xfc0) >> 6
}
func (o *I2S_Type) SetSAMPLE_RATE_CONF_TX_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0x3f000)|value<<12)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_TX_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0x3f000) >> 12
}
func (o *I2S_Type) SetSAMPLE_RATE_CONF_RX_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.SAMPLE_RATE_CONF.Reg, volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg)&^(0xfc0000)|value<<18)
}
func (o *I2S_Type) GetSAMPLE_RATE_CONF_RX_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.SAMPLE_RATE_CONF.Reg) & 0xfc0000) >> 18
}

// I2S.STATE: I2S TX status register
func (o *I2S_Type) SetSTATE_TX_IDLE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetSTATE_TX_IDLE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1
}

// I2S.DATE: Version control register
func (o *I2S_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *I2S_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Interrupt Controller (Core 0)
type INTERRUPT_CORE0_Type struct {
	PRO_MAC_INTR_MAP               volatile.Register32 // 0x0
	PRO_MAC_NMI_MAP                volatile.Register32 // 0x4
	PRO_PWR_INTR_MAP               volatile.Register32 // 0x8
	PRO_BB_INT_MAP                 volatile.Register32 // 0xC
	PRO_BT_MAC_INT_MAP             volatile.Register32 // 0x10
	PRO_BT_BB_INT_MAP              volatile.Register32 // 0x14
	PRO_BT_BB_NMI_MAP              volatile.Register32 // 0x18
	PRO_RWBT_IRQ_MAP               volatile.Register32 // 0x1C
	PRO_RWBLE_IRQ_MAP              volatile.Register32 // 0x20
	PRO_RWBT_NMI_MAP               volatile.Register32 // 0x24
	PRO_RWBLE_NMI_MAP              volatile.Register32 // 0x28
	PRO_SLC0_INTR_MAP              volatile.Register32 // 0x2C
	PRO_SLC1_INTR_MAP              volatile.Register32 // 0x30
	PRO_UHCI0_INTR_MAP             volatile.Register32 // 0x34
	PRO_UHCI1_INTR_MAP             volatile.Register32 // 0x38
	PRO_TG_T0_LEVEL_INT_MAP        volatile.Register32 // 0x3C
	PRO_TG_T1_LEVEL_INT_MAP        volatile.Register32 // 0x40
	PRO_TG_WDT_LEVEL_INT_MAP       volatile.Register32 // 0x44
	PRO_TG_LACT_LEVEL_INT_MAP      volatile.Register32 // 0x48
	PRO_TG1_T0_LEVEL_INT_MAP       volatile.Register32 // 0x4C
	PRO_TG1_T1_LEVEL_INT_MAP       volatile.Register32 // 0x50
	PRO_TG1_WDT_LEVEL_INT_MAP      volatile.Register32 // 0x54
	PRO_TG1_LACT_LEVEL_INT_MAP     volatile.Register32 // 0x58
	PRO_GPIO_INTERRUPT_PRO_MAP     volatile.Register32 // 0x5C
	PRO_GPIO_INTERRUPT_PRO_NMI_MAP volatile.Register32 // 0x60
	PRO_GPIO_INTERRUPT_APP_MAP     volatile.Register32 // 0x64
	PRO_GPIO_INTERRUPT_APP_NMI_MAP volatile.Register32 // 0x68
	PRO_DEDICATED_GPIO_IN_INTR_MAP volatile.Register32 // 0x6C
	PRO_CPU_INTR_FROM_CPU_0_MAP    volatile.Register32 // 0x70
	PRO_CPU_INTR_FROM_CPU_1_MAP    volatile.Register32 // 0x74
	PRO_CPU_INTR_FROM_CPU_2_MAP    volatile.Register32 // 0x78
	PRO_CPU_INTR_FROM_CPU_3_MAP    volatile.Register32 // 0x7C
	PRO_SPI_INTR_1_MAP             volatile.Register32 // 0x80
	PRO_SPI_INTR_2_MAP             volatile.Register32 // 0x84
	PRO_SPI_INTR_3_MAP             volatile.Register32 // 0x88
	PRO_I2S0_INT_MAP               volatile.Register32 // 0x8C
	PRO_I2S1_INT_MAP               volatile.Register32 // 0x90
	PRO_UART_INTR_MAP              volatile.Register32 // 0x94
	PRO_UART1_INTR_MAP             volatile.Register32 // 0x98
	PRO_UART2_INTR_MAP             volatile.Register32 // 0x9C
	PRO_SDIO_HOST_INTERRUPT_MAP    volatile.Register32 // 0xA0
	PRO_PWM0_INTR_MAP              volatile.Register32 // 0xA4
	PRO_PWM1_INTR_MAP              volatile.Register32 // 0xA8
	PRO_PWM2_INTR_MAP              volatile.Register32 // 0xAC
	PRO_PWM3_INTR_MAP              volatile.Register32 // 0xB0
	PRO_LEDC_INT_MAP               volatile.Register32 // 0xB4
	PRO_EFUSE_INT_MAP              volatile.Register32 // 0xB8
	PRO_CAN_INT_MAP                volatile.Register32 // 0xBC
	PRO_USB_INTR_MAP               volatile.Register32 // 0xC0
	PRO_RTC_CORE_INTR_MAP          volatile.Register32 // 0xC4
	PRO_RMT_INTR_MAP               volatile.Register32 // 0xC8
	PRO_PCNT_INTR_MAP              volatile.Register32 // 0xCC
	PRO_I2C_EXT0_INTR_MAP          volatile.Register32 // 0xD0
	PRO_I2C_EXT1_INTR_MAP          volatile.Register32 // 0xD4
	PRO_RSA_INTR_MAP               volatile.Register32 // 0xD8
	PRO_SHA_INTR_MAP               volatile.Register32 // 0xDC
	PRO_AES_INTR_MAP               volatile.Register32 // 0xE0
	PRO_SPI2_DMA_INT_MAP           volatile.Register32 // 0xE4
	PRO_SPI3_DMA_INT_MAP           volatile.Register32 // 0xE8
	PRO_WDG_INT_MAP                volatile.Register32 // 0xEC
	PRO_TIMER_INT1_MAP             volatile.Register32 // 0xF0
	PRO_TIMER_INT2_MAP             volatile.Register32 // 0xF4
	PRO_TG_T0_EDGE_INT_MAP         volatile.Register32 // 0xF8
	PRO_TG_T1_EDGE_INT_MAP         volatile.Register32 // 0xFC
	PRO_TG_WDT_EDGE_INT_MAP        volatile.Register32 // 0x100
	PRO_TG_LACT_EDGE_INT_MAP       volatile.Register32 // 0x104
	PRO_TG1_T0_EDGE_INT_MAP        volatile.Register32 // 0x108
	PRO_TG1_T1_EDGE_INT_MAP        volatile.Register32 // 0x10C
	PRO_TG1_WDT_EDGE_INT_MAP       volatile.Register32 // 0x110
	PRO_TG1_LACT_EDGE_INT_MAP      volatile.Register32 // 0x114
	PRO_CACHE_IA_INT_MAP           volatile.Register32 // 0x118
	PRO_SYSTIMER_TARGET0_INT_MAP   volatile.Register32 // 0x11C
	PRO_SYSTIMER_TARGET1_INT_MAP   volatile.Register32 // 0x120
	PRO_SYSTIMER_TARGET2_INT_MAP   volatile.Register32 // 0x124
	PRO_ASSIST_DEBUG_INTR_MAP      volatile.Register32 // 0x128
	PRO_PMS_PRO_IRAM0_ILG_INTR_MAP volatile.Register32 // 0x12C
	PRO_PMS_PRO_DRAM0_ILG_INTR_MAP volatile.Register32 // 0x130
	PRO_PMS_PRO_DPORT_ILG_INTR_MAP volatile.Register32 // 0x134
	PRO_PMS_PRO_AHB_ILG_INTR_MAP   volatile.Register32 // 0x138
	PRO_PMS_PRO_CACHE_ILG_INTR_MAP volatile.Register32 // 0x13C
	PRO_PMS_DMA_APB_I_ILG_INTR_MAP volatile.Register32 // 0x140
	PRO_PMS_DMA_RX_I_ILG_INTR_MAP  volatile.Register32 // 0x144
	PRO_PMS_DMA_TX_I_ILG_INTR_MAP  volatile.Register32 // 0x148
	PRO_SPI_MEM_REJECT_INTR_MAP    volatile.Register32 // 0x14C
	PRO_DMA_COPY_INTR_MAP          volatile.Register32 // 0x150
	PRO_SPI4_DMA_INT_MAP           volatile.Register32 // 0x154
	PRO_SPI_INTR_4_MAP             volatile.Register32 // 0x158
	PRO_DCACHE_PRELOAD_INT_MAP     volatile.Register32 // 0x15C
	PRO_ICACHE_PRELOAD_INT_MAP     volatile.Register32 // 0x160
	PRO_APB_ADC_INT_MAP            volatile.Register32 // 0x164
	PRO_CRYPTO_DMA_INT_MAP         volatile.Register32 // 0x168
	PRO_CPU_PERI_ERROR_INT_MAP     volatile.Register32 // 0x16C
	PRO_APB_PERI_ERROR_INT_MAP     volatile.Register32 // 0x170
	PRO_DCACHE_SYNC_INT_MAP        volatile.Register32 // 0x174
	PRO_ICACHE_SYNC_INT_MAP        volatile.Register32 // 0x178
	PRO_INTR_STATUS_0              volatile.Register32 // 0x17C
	PRO_INTR_STATUS_1              volatile.Register32 // 0x180
	PRO_INTR_STATUS_2              volatile.Register32 // 0x184
	CLOCK_GATE                     volatile.Register32 // 0x188
	_                              [3696]byte
	REG_DATE                       volatile.Register32 // 0xFFC
}

// INTERRUPT_CORE0.PRO_MAC_INTR_MAP: MAC_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_MAC_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_MAC_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_MAC_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_MAC_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_MAC_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_MAC_NMI_MAP: MAC_NMI interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_MAC_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_MAC_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_MAC_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_MAC_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_MAC_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PWR_INTR_MAP: PWR_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PWR_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWR_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWR_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PWR_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWR_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_BB_INT_MAP: BB_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_BB_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BB_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_BB_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_BB_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BB_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_BT_MAC_INT_MAP: BT_MAC_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_BT_MAC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BT_MAC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_BT_MAC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_BT_MAC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BT_MAC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_BT_BB_INT_MAP: BT_BB_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_BT_BB_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BT_BB_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_BT_BB_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_BT_BB_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BT_BB_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_BT_BB_NMI_MAP: BT_BB_NMI interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_BT_BB_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BT_BB_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_BT_BB_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_BT_BB_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BT_BB_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RWBT_IRQ_MAP: RWBT_IRQ interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RWBT_IRQ_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBT_IRQ_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBT_IRQ_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RWBT_IRQ_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBT_IRQ_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RWBLE_IRQ_MAP: RWBLE_IRQ interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RWBLE_IRQ_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBLE_IRQ_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBLE_IRQ_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RWBLE_IRQ_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBLE_IRQ_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RWBT_NMI_MAP: RWBT_NMI interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RWBT_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBT_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBT_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RWBT_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBT_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RWBLE_NMI_MAP: RWBLE_NMI interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RWBLE_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RWBLE_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_RWBLE_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RWBLE_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RWBLE_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SLC0_INTR_MAP: SLC0_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SLC0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SLC0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SLC0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SLC0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SLC0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SLC1_INTR_MAP: SLC1_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SLC1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SLC1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SLC1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SLC1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SLC1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_UHCI0_INTR_MAP: UHCI0_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_UHCI0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UHCI0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UHCI0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_UHCI0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UHCI0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_UHCI1_INTR_MAP: UHCI1_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_UHCI1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UHCI1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UHCI1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_UHCI1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UHCI1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_T0_LEVEL_INT_MAP: TG_T0_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_T0_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T0_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T0_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_T0_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T0_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_T1_LEVEL_INT_MAP: TG_T1_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_T1_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T1_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T1_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_T1_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T1_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_WDT_LEVEL_INT_MAP: TG_WDT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_WDT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_WDT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_WDT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_WDT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_WDT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_LACT_LEVEL_INT_MAP: TG_LACT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_LACT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_LACT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_LACT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_LACT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_LACT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_T0_LEVEL_INT_MAP: TG1_T0_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_T0_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T0_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T0_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_T0_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T0_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_T1_LEVEL_INT_MAP: TG1_T1_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_T1_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T1_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T1_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_T1_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T1_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_WDT_LEVEL_INT_MAP: TG1_WDT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_WDT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_WDT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_WDT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_WDT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_WDT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_LACT_LEVEL_INT_MAP: TG1_LACT_LEVEL_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_LACT_LEVEL_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_LACT_LEVEL_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_LACT_LEVEL_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_LACT_LEVEL_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_LACT_LEVEL_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_GPIO_INTERRUPT_PRO_MAP: GPIO_INTERRUPT_PRO interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_GPIO_INTERRUPT_PRO_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_PRO_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_GPIO_INTERRUPT_PRO_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_GPIO_INTERRUPT_PRO_NMI_MAP: GPIO_INTERRUPT_PRO_NMI interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_GPIO_INTERRUPT_PRO_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_PRO_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_GPIO_INTERRUPT_PRO_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_PRO_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_GPIO_INTERRUPT_APP_MAP: GPIO_INTERRUPT_APP interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_GPIO_INTERRUPT_APP_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_APP_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_GPIO_INTERRUPT_APP_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_GPIO_INTERRUPT_APP_NMI_MAP: GPIO_INTERRUPT_APP_NMI interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_GPIO_INTERRUPT_APP_NMI_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_GPIO_INTERRUPT_APP_NMI_MAP.Reg, volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_NMI_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_GPIO_INTERRUPT_APP_NMI_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_GPIO_INTERRUPT_APP_NMI_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_DEDICATED_GPIO_IN_INTR_MAP: DEDICATED_GPIO_IN_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_DEDICATED_GPIO_IN_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DEDICATED_GPIO_IN_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_DEDICATED_GPIO_IN_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_DEDICATED_GPIO_IN_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DEDICATED_GPIO_IN_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CPU_INTR_FROM_CPU_0_MAP: CPU_INTR_FROM_CPU_0 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CPU_INTR_FROM_CPU_0_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_0_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_0_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CPU_INTR_FROM_CPU_0_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_0_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CPU_INTR_FROM_CPU_1_MAP: CPU_INTR_FROM_CPU_1 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CPU_INTR_FROM_CPU_1_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_1_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CPU_INTR_FROM_CPU_1_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_1_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CPU_INTR_FROM_CPU_2_MAP: CPU_INTR_FROM_CPU_2 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CPU_INTR_FROM_CPU_2_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_2_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CPU_INTR_FROM_CPU_2_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_2_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CPU_INTR_FROM_CPU_3_MAP: CPU_INTR_FROM_CPU_3 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CPU_INTR_FROM_CPU_3_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_INTR_FROM_CPU_3_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_3_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CPU_INTR_FROM_CPU_3_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_INTR_FROM_CPU_3_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI_INTR_1_MAP: SPI_INTR_1 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI_INTR_1_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_1_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI_INTR_1_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_1_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI_INTR_2_MAP: SPI_INTR_2 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI_INTR_2_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_2_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI_INTR_2_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_2_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI_INTR_3_MAP: SPI_INTR_3 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI_INTR_3_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_3_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_3_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI_INTR_3_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_3_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_I2S0_INT_MAP: I2S0_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_I2S0_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2S0_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_I2S0_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_I2S0_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2S0_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_I2S1_INT_MAP: I2S1_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_I2S1_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2S1_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_I2S1_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_I2S1_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2S1_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_UART_INTR_MAP: UART_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_UART_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UART_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UART_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_UART_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UART_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_UART1_INTR_MAP: UART1_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_UART1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UART1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UART1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_UART1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UART1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_UART2_INTR_MAP: UART2_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_UART2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_UART2_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_UART2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_UART2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_UART2_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SDIO_HOST_INTERRUPT_MAP: SDIO_HOST_INTERRUPT configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SDIO_HOST_INTERRUPT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SDIO_HOST_INTERRUPT_MAP.Reg, volatile.LoadUint32(&o.PRO_SDIO_HOST_INTERRUPT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SDIO_HOST_INTERRUPT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SDIO_HOST_INTERRUPT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PWM0_INTR_MAP: PWM0_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PWM0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PWM0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PWM1_INTR_MAP: PWM1_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PWM1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PWM1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PWM2_INTR_MAP: PWM2_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PWM2_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM2_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM2_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PWM2_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM2_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PWM3_INTR_MAP: PWM3_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PWM3_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PWM3_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PWM3_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PWM3_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PWM3_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_LEDC_INT_MAP: LEDC_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_LEDC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_LEDC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_LEDC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_LEDC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_LEDC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_EFUSE_INT_MAP: EFUSE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_EFUSE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_EFUSE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_EFUSE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_EFUSE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_EFUSE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CAN_INT_MAP: CAN_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CAN_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CAN_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CAN_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CAN_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CAN_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_USB_INTR_MAP: USB_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_USB_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_USB_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_USB_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_USB_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_USB_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RTC_CORE_INTR_MAP: RTC_CORE_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RTC_CORE_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RTC_CORE_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_RTC_CORE_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RTC_CORE_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RTC_CORE_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RMT_INTR_MAP: RMT_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RMT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RMT_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_RMT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RMT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RMT_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PCNT_INTR_MAP: PCNT_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PCNT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PCNT_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PCNT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PCNT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PCNT_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_I2C_EXT0_INTR_MAP: I2C_EXT0_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_I2C_EXT0_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2C_EXT0_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_I2C_EXT0_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_I2C_EXT0_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2C_EXT0_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_I2C_EXT1_INTR_MAP: I2C_EXT1_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_I2C_EXT1_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_I2C_EXT1_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_I2C_EXT1_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_I2C_EXT1_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_I2C_EXT1_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_RSA_INTR_MAP: RSA_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_RSA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_RSA_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_RSA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_RSA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_RSA_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SHA_INTR_MAP: SHA_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SHA_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SHA_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SHA_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SHA_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SHA_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_AES_INTR_MAP: AES_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_AES_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_AES_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_AES_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_AES_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_AES_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI2_DMA_INT_MAP: SPI2_DMA_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI2_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI2_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI2_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI2_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI2_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI3_DMA_INT_MAP: SPI3_DMA_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI3_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI3_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI3_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI3_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI3_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_WDG_INT_MAP: WDG_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_WDG_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_WDG_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_WDG_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_WDG_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_WDG_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TIMER_INT1_MAP: TIMER_INT1 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TIMER_INT1_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TIMER_INT1_MAP.Reg, volatile.LoadUint32(&o.PRO_TIMER_INT1_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TIMER_INT1_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TIMER_INT1_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TIMER_INT2_MAP: TIMER_INT2 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TIMER_INT2_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TIMER_INT2_MAP.Reg, volatile.LoadUint32(&o.PRO_TIMER_INT2_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TIMER_INT2_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TIMER_INT2_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_T0_EDGE_INT_MAP: TG_T0_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_T0_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T0_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T0_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_T0_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T0_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_T1_EDGE_INT_MAP: TG_T1_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_T1_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_T1_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_T1_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_T1_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_T1_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_WDT_EDGE_INT_MAP: TG_WDT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_WDT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_WDT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_WDT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_WDT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_WDT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG_LACT_EDGE_INT_MAP: TG_LACT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG_LACT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG_LACT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG_LACT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG_LACT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG_LACT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_T0_EDGE_INT_MAP: TG1_T0_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_T0_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T0_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T0_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_T0_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T0_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_T1_EDGE_INT_MAP: TG1_T1_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_T1_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_T1_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_T1_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_T1_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_T1_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_WDT_EDGE_INT_MAP: TG1_WDT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_WDT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_WDT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_WDT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_WDT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_WDT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_TG1_LACT_EDGE_INT_MAP: TG1_LACT_EDGE_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_TG1_LACT_EDGE_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_TG1_LACT_EDGE_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_TG1_LACT_EDGE_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_TG1_LACT_EDGE_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_TG1_LACT_EDGE_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CACHE_IA_INT_MAP: CACHE_IA_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CACHE_IA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_IA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CACHE_IA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CACHE_IA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_IA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SYSTIMER_TARGET0_INT_MAP: SYSTIMER_TARGET0_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SYSTIMER_TARGET0_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SYSTIMER_TARGET0_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET0_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SYSTIMER_TARGET0_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET0_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SYSTIMER_TARGET1_INT_MAP: SYSTIMER_TARGET1_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SYSTIMER_TARGET1_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SYSTIMER_TARGET1_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET1_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SYSTIMER_TARGET1_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET1_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SYSTIMER_TARGET2_INT_MAP: SYSTIMER_TARGET2_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SYSTIMER_TARGET2_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SYSTIMER_TARGET2_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET2_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SYSTIMER_TARGET2_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SYSTIMER_TARGET2_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_ASSIST_DEBUG_INTR_MAP: ASSIST_DEBUG_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_ASSIST_DEBUG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_ASSIST_DEBUG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_ASSIST_DEBUG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_ASSIST_DEBUG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_ASSIST_DEBUG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP: PMS_PRO_IRAM0_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_PRO_IRAM0_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_PRO_IRAM0_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_IRAM0_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP: PMS_PRO_DRAM0_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_PRO_DRAM0_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_PRO_DRAM0_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_DRAM0_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_PRO_DPORT_ILG_INTR_MAP: PMS_PRO_DPORT_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_PRO_DPORT_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_DPORT_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_DPORT_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_PRO_DPORT_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_DPORT_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_PRO_AHB_ILG_INTR_MAP: PMS_PRO_AHB_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_PRO_AHB_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_AHB_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_AHB_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_PRO_AHB_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_AHB_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_PRO_CACHE_ILG_INTR_MAP: PMS_PRO_CACHE_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_PRO_CACHE_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_PRO_CACHE_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_PRO_CACHE_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_PRO_CACHE_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_PRO_CACHE_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_DMA_APB_I_ILG_INTR_MAP: PMS_DMA_APB_I_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_DMA_APB_I_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_DMA_APB_I_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_DMA_APB_I_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_DMA_APB_I_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_DMA_APB_I_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_DMA_RX_I_ILG_INTR_MAP: PMS_DMA_RX_I_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_DMA_RX_I_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_DMA_RX_I_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_DMA_RX_I_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_DMA_RX_I_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_DMA_RX_I_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_PMS_DMA_TX_I_ILG_INTR_MAP: PMS_DMA_TX_I_ILG interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_PMS_DMA_TX_I_ILG_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_PMS_DMA_TX_I_ILG_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_PMS_DMA_TX_I_ILG_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_PMS_DMA_TX_I_ILG_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_PMS_DMA_TX_I_ILG_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI_MEM_REJECT_INTR_MAP: SPI_MEM_REJECT_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI_MEM_REJECT_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_MEM_REJECT_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_MEM_REJECT_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI_MEM_REJECT_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_MEM_REJECT_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_DMA_COPY_INTR_MAP: DMA_COPY_INTR interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_DMA_COPY_INTR_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DMA_COPY_INTR_MAP.Reg, volatile.LoadUint32(&o.PRO_DMA_COPY_INTR_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_DMA_COPY_INTR_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DMA_COPY_INTR_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI4_DMA_INT_MAP: SPI4_DMA_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI4_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI4_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI4_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI4_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI4_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_SPI_INTR_4_MAP: SPI_INTR_4 interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_SPI_INTR_4_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_SPI_INTR_4_MAP.Reg, volatile.LoadUint32(&o.PRO_SPI_INTR_4_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_SPI_INTR_4_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_SPI_INTR_4_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_DCACHE_PRELOAD_INT_MAP: DCACHE_PRELOAD_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_DCACHE_PRELOAD_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_PRELOAD_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_DCACHE_PRELOAD_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_PRELOAD_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_ICACHE_PRELOAD_INT_MAP: ICACHE_PRELOAD_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_ICACHE_PRELOAD_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_PRELOAD_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_ICACHE_PRELOAD_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_PRELOAD_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_APB_ADC_INT_MAP: APB_ADC_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_APB_ADC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_APB_ADC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_APB_ADC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_APB_ADC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_APB_ADC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CRYPTO_DMA_INT_MAP: CRYPTO_DMA_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CRYPTO_DMA_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CRYPTO_DMA_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CRYPTO_DMA_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CRYPTO_DMA_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CRYPTO_DMA_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_CPU_PERI_ERROR_INT_MAP: CPU_PERI_ERROR_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_CPU_PERI_ERROR_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_CPU_PERI_ERROR_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_CPU_PERI_ERROR_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_CPU_PERI_ERROR_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_CPU_PERI_ERROR_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_APB_PERI_ERROR_INT_MAP: APB_PERI_ERROR_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_APB_PERI_ERROR_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_APB_PERI_ERROR_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_APB_PERI_ERROR_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_APB_PERI_ERROR_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_APB_PERI_ERROR_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_DCACHE_SYNC_INT_MAP: DCACHE_SYNC_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_DCACHE_SYNC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_DCACHE_SYNC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_DCACHE_SYNC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_DCACHE_SYNC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_DCACHE_SYNC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_ICACHE_SYNC_INT_MAP: ICACHE_SYNC_INT interrupt configuration register
func (o *INTERRUPT_CORE0_Type) SetPRO_ICACHE_SYNC_INT_MAP(value uint32) {
	volatile.StoreUint32(&o.PRO_ICACHE_SYNC_INT_MAP.Reg, volatile.LoadUint32(&o.PRO_ICACHE_SYNC_INT_MAP.Reg)&^(0x1f)|value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_ICACHE_SYNC_INT_MAP() uint32 {
	return volatile.LoadUint32(&o.PRO_ICACHE_SYNC_INT_MAP.Reg) & 0x1f
}

// INTERRUPT_CORE0.PRO_INTR_STATUS_0: Interrupt status register 0
func (o *INTERRUPT_CORE0_Type) SetPRO_INTR_STATUS_0(value uint32) {
	volatile.StoreUint32(&o.PRO_INTR_STATUS_0.Reg, value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_INTR_STATUS_0() uint32 {
	return volatile.LoadUint32(&o.PRO_INTR_STATUS_0.Reg)
}

// INTERRUPT_CORE0.PRO_INTR_STATUS_1: Interrupt status register 1
func (o *INTERRUPT_CORE0_Type) SetPRO_INTR_STATUS_1(value uint32) {
	volatile.StoreUint32(&o.PRO_INTR_STATUS_1.Reg, value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_INTR_STATUS_1() uint32 {
	return volatile.LoadUint32(&o.PRO_INTR_STATUS_1.Reg)
}

// INTERRUPT_CORE0.PRO_INTR_STATUS_2: Interrupt status register 2
func (o *INTERRUPT_CORE0_Type) SetPRO_INTR_STATUS_2(value uint32) {
	volatile.StoreUint32(&o.PRO_INTR_STATUS_2.Reg, value)
}
func (o *INTERRUPT_CORE0_Type) GetPRO_INTR_STATUS_2() uint32 {
	return volatile.LoadUint32(&o.PRO_INTR_STATUS_2.Reg)
}

// INTERRUPT_CORE0.CLOCK_GATE: NMI interrupt signals mask register
func (o *INTERRUPT_CORE0_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *INTERRUPT_CORE0_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}
func (o *INTERRUPT_CORE0_Type) SetCLOCK_GATE_PRO_NMI_MASK_HW(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x2)|value<<1)
}
func (o *INTERRUPT_CORE0_Type) GetCLOCK_GATE_PRO_NMI_MASK_HW() uint32 {
	return (volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x2) >> 1
}

// INTERRUPT_CORE0.REG_DATE: Version control register
func (o *INTERRUPT_CORE0_Type) SetREG_DATE_INTERRUPT_REG_DATE(value uint32) {
	volatile.StoreUint32(&o.REG_DATE.Reg, volatile.LoadUint32(&o.REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *INTERRUPT_CORE0_Type) GetREG_DATE_INTERRUPT_REG_DATE() uint32 {
	return volatile.LoadUint32(&o.REG_DATE.Reg) & 0xfffffff
}

// Input/Output Multiplexer
type IO_MUX_Type struct {
	PIN_CTRL volatile.Register32 // 0x0
	GPIO0    volatile.Register32 // 0x4
	GPIO1    volatile.Register32 // 0x8
	GPIO2    volatile.Register32 // 0xC
	GPIO3    volatile.Register32 // 0x10
	GPIO4    volatile.Register32 // 0x14
	GPIO5    volatile.Register32 // 0x18
	GPIO6    volatile.Register32 // 0x1C
	GPIO7    volatile.Register32 // 0x20
	GPIO8    volatile.Register32 // 0x24
	GPIO9    volatile.Register32 // 0x28
	GPIO10   volatile.Register32 // 0x2C
	GPIO11   volatile.Register32 // 0x30
	GPIO12   volatile.Register32 // 0x34
	GPIO13   volatile.Register32 // 0x38
	GPIO14   volatile.Register32 // 0x3C
	GPIO15   volatile.Register32 // 0x40
	GPIO16   volatile.Register32 // 0x44
	GPIO17   volatile.Register32 // 0x48
	GPIO18   volatile.Register32 // 0x4C
	GPIO19   volatile.Register32 // 0x50
	GPIO20   volatile.Register32 // 0x54
	GPIO21   volatile.Register32 // 0x58
	_        [16]byte
	GPIO26   volatile.Register32 // 0x6C
	GPIO27   volatile.Register32 // 0x70
	GPIO28   volatile.Register32 // 0x74
	GPIO29   volatile.Register32 // 0x78
	GPIO30   volatile.Register32 // 0x7C
	GPIO31   volatile.Register32 // 0x80
	GPIO32   volatile.Register32 // 0x84
	GPIO33   volatile.Register32 // 0x88
	GPIO34   volatile.Register32 // 0x8C
	GPIO35   volatile.Register32 // 0x90
	GPIO36   volatile.Register32 // 0x94
	GPIO37   volatile.Register32 // 0x98
	GPIO38   volatile.Register32 // 0x9C
	GPIO39   volatile.Register32 // 0xA0
	GPIO40   volatile.Register32 // 0xA4
	GPIO41   volatile.Register32 // 0xA8
	GPIO42   volatile.Register32 // 0xAC
	GPIO43   volatile.Register32 // 0xB0
	GPIO44   volatile.Register32 // 0xB4
	GPIO45   volatile.Register32 // 0xB8
	GPIO46   volatile.Register32 // 0xBC
	_        [60]byte
	DATE     volatile.Register32 // 0xFC
}

// IO_MUX.PIN_CTRL: Clock output configuration register
func (o *IO_MUX_Type) SetPIN_CTRL_PIN_CLK_OUT1(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0xf)|value)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PIN_CLK_OUT1() uint32 {
	return volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0xf
}
func (o *IO_MUX_Type) SetPIN_CTRL_PIN_CLK_OUT2(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0xf0)|value<<4)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PIN_CLK_OUT2() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0xf0) >> 4
}
func (o *IO_MUX_Type) SetPIN_CTRL_PIN_CLK_OUT3(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PIN_CLK_OUT3() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0xf00) >> 8
}
func (o *IO_MUX_Type) SetPIN_CTRL_SWITCH_PRT_NUM(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetPIN_CTRL_SWITCH_PRT_NUM() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetPIN_CTRL_PAD_POWER_CTRL(value uint32) {
	volatile.StoreUint32(&o.PIN_CTRL.Reg, volatile.LoadUint32(&o.PIN_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetPIN_CTRL_PAD_POWER_CTRL() uint32 {
	return (volatile.LoadUint32(&o.PIN_CTRL.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO0: Configuration register for pin GPIO0
func (o *IO_MUX_Type) SetGPIO0_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO0.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO0_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO0_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO0_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO0_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO0_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO0_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO0_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO0_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO0_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO1: Configuration register for pin GPIO1
func (o *IO_MUX_Type) SetGPIO1_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO1.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO1_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO1_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO1_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO1_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO1_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO1_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO1_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO1_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO1_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO1_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO1_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO2: Configuration register for pin GPIO2
func (o *IO_MUX_Type) SetGPIO2_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO2.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO2_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO2_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO2_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO2_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO2_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO2_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO2_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO2_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO2_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO2_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO2_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO3: Configuration register for pin GPIO3
func (o *IO_MUX_Type) SetGPIO3_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO3.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO3_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO3_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO3_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO3_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO3_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO3_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO3_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO3_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO3_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO3_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO3_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO3_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO3_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO3_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO4: Configuration register for pin GPIO4
func (o *IO_MUX_Type) SetGPIO4_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO4.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO4_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO4_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO4_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO4_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO4_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO4_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO4_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO4_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO4_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO4_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO4_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO4_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO4_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO4_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO5: Configuration register for pin GPIO5
func (o *IO_MUX_Type) SetGPIO5_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO5.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO5_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO5_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO5_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO5_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO5_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO5_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO5_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO5_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO5_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO5_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO5_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO5_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO5_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO5_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO6: Configuration register for pin GPIO6
func (o *IO_MUX_Type) SetGPIO6_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO6.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO6_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO6_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO6_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO6_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO6_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO6_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO6_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO6_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO6_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO6_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO6_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO6_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO6_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO6_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO7: Configuration register for pin GPIO7
func (o *IO_MUX_Type) SetGPIO7_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO7.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO7_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO7_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO7_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO7_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO7_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO7_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO7_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO7_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO7_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO7_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO7_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO7_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO7_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO7_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO8: Configuration register for pin GPIO8
func (o *IO_MUX_Type) SetGPIO8_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO8.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO8_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO8_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO8_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO8_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO8_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO8_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO8_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO8_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO8_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO8_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO8_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO8_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO8_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO8_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO9: Configuration register for pin GPIO9
func (o *IO_MUX_Type) SetGPIO9_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO9.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO9_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO9_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO9_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO9_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO9_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO9_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO9_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO9_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO9_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO9_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO9_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO9_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO9_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO9_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO10: Configuration register for pin GPIO10
func (o *IO_MUX_Type) SetGPIO10_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO10.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO10_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO10_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO10_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO10_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO10_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO10_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO10_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO10_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO10_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO10_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO10_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO10_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO10_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO10_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO11: Configuration register for pin GPIO11
func (o *IO_MUX_Type) SetGPIO11_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO11.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO11_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO11_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO11_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO11_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO11_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO11_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO11_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO11_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO11_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO11_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO11_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO11_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO11_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO11_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO12: Configuration register for pin GPIO12
func (o *IO_MUX_Type) SetGPIO12_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO12.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO12_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO12_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO12_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO12_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO12_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO12_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO12_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO12_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO12_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO12_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO12_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO12_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO12_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO12_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO13: Configuration register for pin GPIO13
func (o *IO_MUX_Type) SetGPIO13_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO13.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO13_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO13_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO13_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO13_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO13_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO13_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO13_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO13_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO13_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO13_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO13_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO13_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO13_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO13_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO14: Configuration register for pin GPIO14
func (o *IO_MUX_Type) SetGPIO14_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO14.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO14_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO14_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO14_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO14_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO14_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO14_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO14_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO14_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO14_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO14_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO14_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO14_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO14_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO14_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO15: Configuration register for pin GPIO15
func (o *IO_MUX_Type) SetGPIO15_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO15.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO15_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO15_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO15_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO15_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO15_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO15_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO15_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO15_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO15_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO15_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO15_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO15_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO15_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO15_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO16: Configuration register for pin GPIO16
func (o *IO_MUX_Type) SetGPIO16_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO16.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO16_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO16_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO16_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO16_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO16_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO16_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO16_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO16_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO16_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO16_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO16_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO16_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO16_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO16_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO17: Configuration register for pin GPIO17
func (o *IO_MUX_Type) SetGPIO17_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO17.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO17_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO17_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO17_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO17_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO17_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO17_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO17_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO17_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO17_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO17_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO17_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO17_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO17_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO17_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO18: Configuration register for pin GPIO18
func (o *IO_MUX_Type) SetGPIO18_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO18.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO18_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO18_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO18_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO18_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO18_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO18_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO18_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO18_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO18_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO18_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO18_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO18_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO18_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO18_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO19: Configuration register for pin GPIO19
func (o *IO_MUX_Type) SetGPIO19_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO19.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO19_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO19_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO19_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO19_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO19_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO19_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO19_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO19_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO19_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO19_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO19_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO19_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO19_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO19_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO20: Configuration register for pin GPIO20
func (o *IO_MUX_Type) SetGPIO20_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO20.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO20_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO20_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO20_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO20_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO20_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO20_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO20_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO20_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO20_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO20_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO20_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO20_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO20_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO20_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO21: Configuration register for pin GPIO21
func (o *IO_MUX_Type) SetGPIO21_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO21.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO21_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO21_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO21_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO21_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO21_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO21_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO21_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO21_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO21_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO21_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO21_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO21_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO21_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO21_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO26: Configuration register for pin GPIO26
func (o *IO_MUX_Type) SetGPIO26_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO26.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO26_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO26_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO26_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO26_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO26_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO26_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO26_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO26_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO26_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO26_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO26_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO26_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO26_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO26_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO27: Configuration register for pin GPIO27
func (o *IO_MUX_Type) SetGPIO27_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO27.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO27_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO27_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO27_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO27_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO27_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO27_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO27_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO27_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO27_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO27_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO27_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO27_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO27_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO27_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO28: Configuration register for pin GPIO28
func (o *IO_MUX_Type) SetGPIO28_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO28_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO28.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO28_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO28_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO28_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO28_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO28_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO28_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO28_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO28_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO28_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO28_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO28_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO28_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO28_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO28_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO28_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO28_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO28_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO28_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO28_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO28_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO29: Configuration register for pin GPIO29
func (o *IO_MUX_Type) SetGPIO29_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO29_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO29.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO29_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO29_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO29_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO29_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO29_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO29_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO29_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO29_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO29_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO29_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO29_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO29_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO29_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO29_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO29_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO29_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO29_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO29_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO29_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO29_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO30: Configuration register for pin GPIO30
func (o *IO_MUX_Type) SetGPIO30_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO30_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO30.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO30_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO30_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO30_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO30_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO30_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO30_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO30_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO30_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO30_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO30_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO30_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO30_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO30_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO30_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO30_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO30_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO30_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO30_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO30_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO30.Reg, volatile.LoadUint32(&o.GPIO30.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO30_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO30.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO31: Configuration register for pin GPIO31
func (o *IO_MUX_Type) SetGPIO31_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO31_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO31.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO31_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO31_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO31_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO31_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO31_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO31_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO31_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO31_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO31_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO31_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO31_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO31_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO31_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO31_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO31_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO31_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO31_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO31_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO31_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO31.Reg, volatile.LoadUint32(&o.GPIO31.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO31_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO31.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO32: Configuration register for pin GPIO32
func (o *IO_MUX_Type) SetGPIO32_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO32_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO32.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO32_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO32_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO32_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO32_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO32_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO32_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO32_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO32_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO32_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO32_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO32_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO32_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO32_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO32_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO32_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO32_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO32_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO32_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO32_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO32.Reg, volatile.LoadUint32(&o.GPIO32.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO32_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO32.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO33: Configuration register for pin GPIO33
func (o *IO_MUX_Type) SetGPIO33_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO33_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO33.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO33_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO33_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO33_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO33_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO33_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO33_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO33_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO33_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO33_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO33_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO33_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO33_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO33_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO33_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO33_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO33_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO33_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO33_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO33_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO33.Reg, volatile.LoadUint32(&o.GPIO33.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO33_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO33.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO34: Configuration register for pin GPIO34
func (o *IO_MUX_Type) SetGPIO34_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO34_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO34.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO34_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO34_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO34_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO34_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO34_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO34_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO34_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO34_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO34_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO34_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO34_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO34_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO34_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO34_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO34_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO34_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO34_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO34_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO34_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO34.Reg, volatile.LoadUint32(&o.GPIO34.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO34_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO34.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO35: Configuration register for pin GPIO35
func (o *IO_MUX_Type) SetGPIO35_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO35_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO35.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO35_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO35_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO35_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO35_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO35_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO35_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO35_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO35_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO35_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO35_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO35_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO35_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO35_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO35_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO35_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO35_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO35_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO35_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO35_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO35.Reg, volatile.LoadUint32(&o.GPIO35.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO35_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO35.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO36: Configuration register for pin GPIO36
func (o *IO_MUX_Type) SetGPIO36_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO36_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO36.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO36_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO36_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO36_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO36_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO36_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO36_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO36_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO36_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO36_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO36_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO36_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO36_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO36_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO36_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO36_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO36_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO36_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO36_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO36_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO36.Reg, volatile.LoadUint32(&o.GPIO36.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO36_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO36.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO37: Configuration register for pin GPIO37
func (o *IO_MUX_Type) SetGPIO37_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO37_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO37.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO37_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO37_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO37_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO37_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO37_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO37_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO37_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO37_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO37_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO37_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO37_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO37_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO37_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO37_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO37_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO37_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO37_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO37_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO37_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO37.Reg, volatile.LoadUint32(&o.GPIO37.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO37_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO37.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO38: Configuration register for pin GPIO38
func (o *IO_MUX_Type) SetGPIO38_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO38_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO38.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO38_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO38_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO38_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO38_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO38_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO38_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO38_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO38_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO38_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO38_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO38_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO38_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO38_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO38_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO38_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO38_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO38_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO38_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO38_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO38.Reg, volatile.LoadUint32(&o.GPIO38.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO38_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO38.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO39: Configuration register for pin GPIO39
func (o *IO_MUX_Type) SetGPIO39_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO39_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO39.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO39_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO39_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO39_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO39_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO39_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO39_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO39_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO39_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO39_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO39_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO39_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO39_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO39_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO39_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO39_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO39_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO39_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO39_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO39_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO39.Reg, volatile.LoadUint32(&o.GPIO39.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO39_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO39.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO40: Configuration register for pin GPIO40
func (o *IO_MUX_Type) SetGPIO40_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO40_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO40.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO40_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO40_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO40_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO40_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO40_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO40_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO40_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO40_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO40_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO40_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO40_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO40_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO40_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO40_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO40_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO40_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO40_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO40_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO40_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO40.Reg, volatile.LoadUint32(&o.GPIO40.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO40_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO40.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO41: Configuration register for pin GPIO41
func (o *IO_MUX_Type) SetGPIO41_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO41_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO41.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO41_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO41_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO41_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO41_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO41_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO41_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO41_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO41_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO41_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO41_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO41_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO41_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO41_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO41_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO41_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO41_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO41_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO41_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO41_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO41.Reg, volatile.LoadUint32(&o.GPIO41.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO41_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO41.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO42: Configuration register for pin GPIO42
func (o *IO_MUX_Type) SetGPIO42_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO42_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO42.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO42_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO42_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO42_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO42_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO42_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO42_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO42_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO42_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO42_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO42_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO42_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO42_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO42_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO42_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO42_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO42_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO42_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO42_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO42_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO42.Reg, volatile.LoadUint32(&o.GPIO42.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO42_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO42.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO43: Configuration register for pin GPIO43
func (o *IO_MUX_Type) SetGPIO43_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO43_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO43.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO43_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO43_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO43_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO43_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO43_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO43_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO43_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO43_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO43_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO43_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO43_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO43_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO43_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO43_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO43_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO43_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO43_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO43_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO43_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO43.Reg, volatile.LoadUint32(&o.GPIO43.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO43_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO43.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO44: Configuration register for pin GPIO44
func (o *IO_MUX_Type) SetGPIO44_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO44_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO44.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO44_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO44_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO44_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO44_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO44_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO44_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO44_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO44_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO44_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO44_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO44_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO44_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO44_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO44_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO44_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO44_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO44_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO44_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO44_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO44.Reg, volatile.LoadUint32(&o.GPIO44.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO44_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO44.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO45: Configuration register for pin GPIO45
func (o *IO_MUX_Type) SetGPIO45_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO45_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO45.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO45_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO45_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO45_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO45_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO45_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO45_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO45_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO45_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO45_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO45_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO45_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO45_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO45_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO45_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO45_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO45_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO45_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO45_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO45_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO45.Reg, volatile.LoadUint32(&o.GPIO45.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO45_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO45.Reg) & 0x8000) >> 15
}

// IO_MUX.GPIO46: Configuration register for pin GPIO46
func (o *IO_MUX_Type) SetGPIO46_MCU_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetGPIO46_MCU_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO46.Reg) & 0x1
}
func (o *IO_MUX_Type) SetGPIO46_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x2)|value<<1)
}
func (o *IO_MUX_Type) GetGPIO46_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x2) >> 1
}
func (o *IO_MUX_Type) SetGPIO46_MCU_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x4)|value<<2)
}
func (o *IO_MUX_Type) GetGPIO46_MCU_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x4) >> 2
}
func (o *IO_MUX_Type) SetGPIO46_MCU_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetGPIO46_MCU_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetGPIO46_MCU_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x10)|value<<4)
}
func (o *IO_MUX_Type) GetGPIO46_MCU_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x10) >> 4
}
func (o *IO_MUX_Type) SetGPIO46_FUN_WPD(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetGPIO46_FUN_WPD() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetGPIO46_FUN_WPU(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetGPIO46_FUN_WPU() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetGPIO46_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetGPIO46_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x200) >> 9
}
func (o *IO_MUX_Type) SetGPIO46_FUN_DRV(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0xc00)|value<<10)
}
func (o *IO_MUX_Type) GetGPIO46_FUN_DRV() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0xc00) >> 10
}
func (o *IO_MUX_Type) SetGPIO46_MCU_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x7000)|value<<12)
}
func (o *IO_MUX_Type) GetGPIO46_MCU_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x7000) >> 12
}
func (o *IO_MUX_Type) SetGPIO46_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.GPIO46.Reg, volatile.LoadUint32(&o.GPIO46.Reg)&^(0x8000)|value<<15)
}
func (o *IO_MUX_Type) GetGPIO46_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.GPIO46.Reg) & 0x8000) >> 15
}

// IO_MUX.DATE: Version control register
func (o *IO_MUX_Type) SetDATE_VERSION(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *IO_MUX_Type) GetDATE_VERSION() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// LED Control PWM (Pulse Width Modulation)
type LEDC_Type struct {
	CH0_CONF0    volatile.Register32 // 0x0
	CH0_HPOINT   volatile.Register32 // 0x4
	CH0_DUTY     volatile.Register32 // 0x8
	CH0_CONF1    volatile.Register32 // 0xC
	CH0_DUTY_R   volatile.Register32 // 0x10
	CH1_CONF0    volatile.Register32 // 0x14
	CH1_HPOINT   volatile.Register32 // 0x18
	CH1_DUTY     volatile.Register32 // 0x1C
	CH1_CONF1    volatile.Register32 // 0x20
	CH1_DUTY_R   volatile.Register32 // 0x24
	CH2_CONF0    volatile.Register32 // 0x28
	CH2_HPOINT   volatile.Register32 // 0x2C
	CH2_DUTY     volatile.Register32 // 0x30
	CH2_CONF1    volatile.Register32 // 0x34
	CH2_DUTY_R   volatile.Register32 // 0x38
	CH3_CONF0    volatile.Register32 // 0x3C
	CH3_HPOINT   volatile.Register32 // 0x40
	CH3_DUTY     volatile.Register32 // 0x44
	CH3_CONF1    volatile.Register32 // 0x48
	CH3_DUTY_R   volatile.Register32 // 0x4C
	CH4_CONF0    volatile.Register32 // 0x50
	CH4_HPOINT   volatile.Register32 // 0x54
	CH4_DUTY     volatile.Register32 // 0x58
	CH4_CONF1    volatile.Register32 // 0x5C
	CH4_DUTY_R   volatile.Register32 // 0x60
	CH5_CONF0    volatile.Register32 // 0x64
	CH5_HPOINT   volatile.Register32 // 0x68
	CH5_DUTY     volatile.Register32 // 0x6C
	CH5_CONF1    volatile.Register32 // 0x70
	CH5_DUTY_R   volatile.Register32 // 0x74
	CH6_CONF0    volatile.Register32 // 0x78
	CH6_HPOINT   volatile.Register32 // 0x7C
	CH6_DUTY     volatile.Register32 // 0x80
	CH6_CONF1    volatile.Register32 // 0x84
	CH6_DUTY_R   volatile.Register32 // 0x88
	CH7_CONF0    volatile.Register32 // 0x8C
	CH7_HPOINT   volatile.Register32 // 0x90
	CH7_DUTY     volatile.Register32 // 0x94
	CH7_CONF1    volatile.Register32 // 0x98
	CH7_DUTY_R   volatile.Register32 // 0x9C
	TIMER0_CONF  volatile.Register32 // 0xA0
	TIMER0_VALUE volatile.Register32 // 0xA4
	TIMER1_CONF  volatile.Register32 // 0xA8
	TIMER1_VALUE volatile.Register32 // 0xAC
	TIMER2_CONF  volatile.Register32 // 0xB0
	TIMER2_VALUE volatile.Register32 // 0xB4
	TIMER3_CONF  volatile.Register32 // 0xB8
	TIMER3_VALUE volatile.Register32 // 0xBC
	INT_RAW      volatile.Register32 // 0xC0
	INT_ST       volatile.Register32 // 0xC4
	INT_ENA      volatile.Register32 // 0xC8
	INT_CLR      volatile.Register32 // 0xCC
	CONF         volatile.Register32 // 0xD0
	_            [40]byte
	DATE         volatile.Register32 // 0xFC
}

// LEDC.CH0_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH0_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH0_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH0_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH0_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH0_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH0_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH0_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH0_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH0_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF0.Reg, volatile.LoadUint32(&o.CH0_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH0_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH0_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH0_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH0_HPOINT.Reg, volatile.LoadUint32(&o.CH0_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH0_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH0_HPOINT.Reg) & 0x3fff
}

// LEDC.CH0_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH0_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH0_DUTY.Reg, volatile.LoadUint32(&o.CH0_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH0_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH0_DUTY.Reg) & 0x7ffff
}

// LEDC.CH0_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH0_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH0_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH0_CONF1.Reg, volatile.LoadUint32(&o.CH0_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH0_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH0_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH0_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH0_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH0_DUTY_R.Reg, volatile.LoadUint32(&o.CH0_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH0_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH0_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH1_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH1_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH1_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH1_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH1_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH1_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH1_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH1_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH1_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH1_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF0.Reg, volatile.LoadUint32(&o.CH1_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH1_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH1_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH1_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH1_HPOINT.Reg, volatile.LoadUint32(&o.CH1_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH1_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH1_HPOINT.Reg) & 0x3fff
}

// LEDC.CH1_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH1_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH1_DUTY.Reg, volatile.LoadUint32(&o.CH1_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH1_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH1_DUTY.Reg) & 0x7ffff
}

// LEDC.CH1_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH1_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH1_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH1_CONF1.Reg, volatile.LoadUint32(&o.CH1_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH1_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH1_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH1_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH1_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH1_DUTY_R.Reg, volatile.LoadUint32(&o.CH1_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH1_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH1_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH2_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH2_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH2_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH2_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH2_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH2_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH2_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH2_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH2_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH2_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF0.Reg, volatile.LoadUint32(&o.CH2_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH2_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH2_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH2_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH2_HPOINT.Reg, volatile.LoadUint32(&o.CH2_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH2_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH2_HPOINT.Reg) & 0x3fff
}

// LEDC.CH2_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH2_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH2_DUTY.Reg, volatile.LoadUint32(&o.CH2_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH2_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH2_DUTY.Reg) & 0x7ffff
}

// LEDC.CH2_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH2_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH2_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH2_CONF1.Reg, volatile.LoadUint32(&o.CH2_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH2_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH2_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH2_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH2_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH2_DUTY_R.Reg, volatile.LoadUint32(&o.CH2_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH2_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH2_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH3_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH3_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH3_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH3_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH3_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH3_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH3_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH3_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH3_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH3_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF0.Reg, volatile.LoadUint32(&o.CH3_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH3_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH3_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH3_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH3_HPOINT.Reg, volatile.LoadUint32(&o.CH3_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH3_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH3_HPOINT.Reg) & 0x3fff
}

// LEDC.CH3_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH3_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH3_DUTY.Reg, volatile.LoadUint32(&o.CH3_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH3_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH3_DUTY.Reg) & 0x7ffff
}

// LEDC.CH3_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH3_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH3_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH3_CONF1.Reg, volatile.LoadUint32(&o.CH3_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH3_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH3_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH3_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH3_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH3_DUTY_R.Reg, volatile.LoadUint32(&o.CH3_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH3_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH3_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH4_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH4_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH4_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH4_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH4_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH4_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH4_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH4_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH4_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH4_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF0.Reg, volatile.LoadUint32(&o.CH4_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH4_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH4_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH4_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH4_HPOINT.Reg, volatile.LoadUint32(&o.CH4_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH4_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH4_HPOINT.Reg) & 0x3fff
}

// LEDC.CH4_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH4_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH4_DUTY.Reg, volatile.LoadUint32(&o.CH4_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH4_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH4_DUTY.Reg) & 0x7ffff
}

// LEDC.CH4_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH4_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH4_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH4_CONF1.Reg, volatile.LoadUint32(&o.CH4_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH4_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH4_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH4_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH4_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH4_DUTY_R.Reg, volatile.LoadUint32(&o.CH4_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH4_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH4_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH5_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH5_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH5_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH5_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH5_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH5_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH5_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH5_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH5_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH5_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF0.Reg, volatile.LoadUint32(&o.CH5_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH5_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH5_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH5_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH5_HPOINT.Reg, volatile.LoadUint32(&o.CH5_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH5_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH5_HPOINT.Reg) & 0x3fff
}

// LEDC.CH5_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH5_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH5_DUTY.Reg, volatile.LoadUint32(&o.CH5_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH5_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH5_DUTY.Reg) & 0x7ffff
}

// LEDC.CH5_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH5_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH5_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH5_CONF1.Reg, volatile.LoadUint32(&o.CH5_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH5_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH5_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH5_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH5_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH5_DUTY_R.Reg, volatile.LoadUint32(&o.CH5_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH5_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH5_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH6_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH6_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH6_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH6_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH6_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH6_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH6_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH6_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH6_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH6_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF0.Reg, volatile.LoadUint32(&o.CH6_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH6_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH6_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH6_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH6_HPOINT.Reg, volatile.LoadUint32(&o.CH6_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH6_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH6_HPOINT.Reg) & 0x3fff
}

// LEDC.CH6_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH6_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH6_DUTY.Reg, volatile.LoadUint32(&o.CH6_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH6_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH6_DUTY.Reg) & 0x7ffff
}

// LEDC.CH6_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH6_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH6_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH6_CONF1.Reg, volatile.LoadUint32(&o.CH6_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH6_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH6_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH6_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH6_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH6_DUTY_R.Reg, volatile.LoadUint32(&o.CH6_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH6_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH6_DUTY_R.Reg) & 0x7ffff
}

// LEDC.CH7_CONF0: Configuration register 0 for channel %s
func (o *LEDC_Type) SetCH7_CONF0_TIMER_SEL(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCH7_CONF0_TIMER_SEL() uint32 {
	return volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x3
}
func (o *LEDC_Type) SetCH7_CONF0_SIG_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetCH7_CONF0_SIG_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetCH7_CONF0_IDLE_LV(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetCH7_CONF0_IDLE_LV() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetCH7_CONF0_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetCH7_CONF0_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_NUM(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x7fe0)|value<<5)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x7fe0) >> 5
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_CNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_CNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetCH7_CONF0_OVF_CNT_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF0.Reg, volatile.LoadUint32(&o.CH7_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetCH7_CONF0_OVF_CNT_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF0.Reg) & 0x20000) >> 17
}

// LEDC.CH7_HPOINT: High point register for channel %s
func (o *LEDC_Type) SetCH7_HPOINT_HPOINT(value uint32) {
	volatile.StoreUint32(&o.CH7_HPOINT.Reg, volatile.LoadUint32(&o.CH7_HPOINT.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetCH7_HPOINT_HPOINT() uint32 {
	return volatile.LoadUint32(&o.CH7_HPOINT.Reg) & 0x3fff
}

// LEDC.CH7_DUTY: Initial duty cycle for channel %s
func (o *LEDC_Type) SetCH7_DUTY_DUTY(value uint32) {
	volatile.StoreUint32(&o.CH7_DUTY.Reg, volatile.LoadUint32(&o.CH7_DUTY.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH7_DUTY_DUTY() uint32 {
	return volatile.LoadUint32(&o.CH7_DUTY.Reg) & 0x7ffff
}

// LEDC.CH7_CONF1: Configuration register 1 for channel %s
func (o *LEDC_Type) SetCH7_CONF1_DUTY_SCALE(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x3ff)|value)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_SCALE() uint32 {
	return volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x3ff
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_CYCLE(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0xffc00)|value<<10)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0xffc00) >> 10
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x3ff00000) >> 20
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_INC(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_INC() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x40000000) >> 30
}
func (o *LEDC_Type) SetCH7_CONF1_DUTY_START(value uint32) {
	volatile.StoreUint32(&o.CH7_CONF1.Reg, volatile.LoadUint32(&o.CH7_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCH7_CONF1_DUTY_START() uint32 {
	return (volatile.LoadUint32(&o.CH7_CONF1.Reg) & 0x80000000) >> 31
}

// LEDC.CH7_DUTY_R: Current duty cycle for channel %s
func (o *LEDC_Type) SetCH7_DUTY_R_DUTY_R(value uint32) {
	volatile.StoreUint32(&o.CH7_DUTY_R.Reg, volatile.LoadUint32(&o.CH7_DUTY_R.Reg)&^(0x7ffff)|value)
}
func (o *LEDC_Type) GetCH7_DUTY_R_DUTY_R() uint32 {
	return volatile.LoadUint32(&o.CH7_DUTY_R.Reg) & 0x7ffff
}

// LEDC.TIMER0_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER0_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER0_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER0_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER0_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER0_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER0_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER0_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER0_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER0_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER0_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER0_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER0_CONF.Reg, volatile.LoadUint32(&o.TIMER0_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER0_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER0_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER0_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER0_VALUE_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER0_VALUE.Reg, volatile.LoadUint32(&o.TIMER0_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER0_VALUE_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER0_VALUE.Reg) & 0x3fff
}

// LEDC.TIMER1_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER1_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER1_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER1_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER1_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER1_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER1_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER1_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER1_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER1_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER1_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER1_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER1_CONF.Reg, volatile.LoadUint32(&o.TIMER1_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER1_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER1_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER1_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER1_VALUE_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER1_VALUE.Reg, volatile.LoadUint32(&o.TIMER1_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER1_VALUE_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER1_VALUE.Reg) & 0x3fff
}

// LEDC.TIMER2_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER2_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER2_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER2_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER2_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER2_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER2_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER2_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER2_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER2_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER2_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER2_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER2_CONF.Reg, volatile.LoadUint32(&o.TIMER2_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER2_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER2_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER2_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER2_VALUE_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER2_VALUE.Reg, volatile.LoadUint32(&o.TIMER2_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER2_VALUE_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER2_VALUE.Reg) & 0x3fff
}

// LEDC.TIMER3_CONF: Timer %s configuration
func (o *LEDC_Type) SetTIMER3_CONF_DUTY_RES(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0xf)|value)
}
func (o *LEDC_Type) GetTIMER3_CONF_DUTY_RES() uint32 {
	return volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0xf
}
func (o *LEDC_Type) SetTIMER3_CONF_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x3ffff0)|value<<4)
}
func (o *LEDC_Type) GetTIMER3_CONF_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x3ffff0) >> 4
}
func (o *LEDC_Type) SetTIMER3_CONF_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *LEDC_Type) GetTIMER3_CONF_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x400000) >> 22
}
func (o *LEDC_Type) SetTIMER3_CONF_RST(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *LEDC_Type) GetTIMER3_CONF_RST() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x800000) >> 23
}
func (o *LEDC_Type) SetTIMER3_CONF_TICK_SEL(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *LEDC_Type) GetTIMER3_CONF_TICK_SEL() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x1000000) >> 24
}
func (o *LEDC_Type) SetTIMER3_CONF_PARA_UP(value uint32) {
	volatile.StoreUint32(&o.TIMER3_CONF.Reg, volatile.LoadUint32(&o.TIMER3_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *LEDC_Type) GetTIMER3_CONF_PARA_UP() uint32 {
	return (volatile.LoadUint32(&o.TIMER3_CONF.Reg) & 0x2000000) >> 25
}

// LEDC.TIMER3_VALUE: Timer %s current counter value
func (o *LEDC_Type) SetTIMER3_VALUE_CNT(value uint32) {
	volatile.StoreUint32(&o.TIMER3_VALUE.Reg, volatile.LoadUint32(&o.TIMER3_VALUE.Reg)&^(0x3fff)|value)
}
func (o *LEDC_Type) GetTIMER3_VALUE_CNT() uint32 {
	return volatile.LoadUint32(&o.TIMER3_VALUE.Reg) & 0x3fff
}

// LEDC.INT_RAW: Raw interrupt status
func (o *LEDC_Type) SetINT_RAW_TIMER0_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_RAW_TIMER0_OVF_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_RAW_TIMER1_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_RAW_TIMER1_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_RAW_TIMER2_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_RAW_TIMER2_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_RAW_TIMER3_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_RAW_TIMER3_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH6_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH6_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_RAW_DUTY_CHNG_END_CH7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_RAW_DUTY_CHNG_END_CH7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH6_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH6_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_RAW_OVF_CNT_CH7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_RAW_OVF_CNT_CH7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}

// LEDC.INT_ST: Masked interrupt status
func (o *LEDC_Type) SetINT_ST_TIMER0_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_ST_TIMER0_OVF_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_ST_TIMER1_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_ST_TIMER1_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_ST_TIMER2_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_ST_TIMER2_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_ST_TIMER3_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_ST_TIMER3_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_ST_DUTY_CHNG_END_CH7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_ST_DUTY_CHNG_END_CH7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_ST_OVF_CNT_CH7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_ST_OVF_CNT_CH7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}

// LEDC.INT_ENA: Interrupt enable bits
func (o *LEDC_Type) SetINT_ENA_TIMER0_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_ENA_TIMER0_OVF_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_ENA_TIMER1_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_ENA_TIMER1_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_ENA_TIMER2_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_ENA_TIMER2_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_ENA_TIMER3_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_ENA_TIMER3_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_ENA_DUTY_CHNG_END_CH7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_ENA_DUTY_CHNG_END_CH7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_ENA_OVF_CNT_CH7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_ENA_OVF_CNT_CH7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}

// LEDC.INT_CLR: Interrupt clear bits
func (o *LEDC_Type) SetINT_CLR_TIMER0_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *LEDC_Type) GetINT_CLR_TIMER0_OVF_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *LEDC_Type) SetINT_CLR_TIMER1_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *LEDC_Type) GetINT_CLR_TIMER1_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *LEDC_Type) SetINT_CLR_TIMER2_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *LEDC_Type) GetINT_CLR_TIMER2_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *LEDC_Type) SetINT_CLR_TIMER3_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *LEDC_Type) GetINT_CLR_TIMER3_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *LEDC_Type) SetINT_CLR_DUTY_CHNG_END_CH7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *LEDC_Type) GetINT_CLR_DUTY_CHNG_END_CH7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *LEDC_Type) SetINT_CLR_OVF_CNT_CH7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *LEDC_Type) GetINT_CLR_OVF_CNT_CH7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}

// LEDC.CONF: Global ledc configuration register
func (o *LEDC_Type) SetCONF_APB_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x3)|value)
}
func (o *LEDC_Type) GetCONF_APB_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x3
}
func (o *LEDC_Type) SetCONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *LEDC_Type) GetCONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000000) >> 31
}

// LEDC.DATE: Version control register
func (o *LEDC_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *LEDC_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Pulse Count Controller
type PCNT_Type struct {
	U0_CONF0  volatile.Register32 // 0x0
	U0_CONF1  volatile.Register32 // 0x4
	U0_CONF2  volatile.Register32 // 0x8
	U1_CONF0  volatile.Register32 // 0xC
	U1_CONF1  volatile.Register32 // 0x10
	U1_CONF2  volatile.Register32 // 0x14
	U2_CONF0  volatile.Register32 // 0x18
	U2_CONF1  volatile.Register32 // 0x1C
	U2_CONF2  volatile.Register32 // 0x20
	U3_CONF0  volatile.Register32 // 0x24
	U3_CONF1  volatile.Register32 // 0x28
	U3_CONF2  volatile.Register32 // 0x2C
	U0_CNT    volatile.Register32 // 0x30
	U1_CNT    volatile.Register32 // 0x34
	U2_CNT    volatile.Register32 // 0x38
	U3_CNT    volatile.Register32 // 0x3C
	INT_RAW   volatile.Register32 // 0x40
	INT_ST    volatile.Register32 // 0x44
	INT_ENA   volatile.Register32 // 0x48
	INT_CLR   volatile.Register32 // 0x4C
	U0_STATUS volatile.Register32 // 0x50
	U1_STATUS volatile.Register32 // 0x54
	U2_STATUS volatile.Register32 // 0x58
	U3_STATUS volatile.Register32 // 0x5C
	CTRL      volatile.Register32 // 0x60
	_         [152]byte
	DATE      volatile.Register32 // 0xFC
}

// PCNT.U0_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU0_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU0_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU0_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU0_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU0_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU0_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU0_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU0_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU0_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU0_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU0_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU0_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU0_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU0_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU0_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU0_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU0_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU0_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU0_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU0_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU0_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU0_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU0_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_CONF0.Reg, volatile.LoadUint32(&o.U0_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU0_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U0_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU0_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U0_CONF1.Reg, volatile.LoadUint32(&o.U0_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U0_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU0_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U0_CONF1.Reg, volatile.LoadUint32(&o.U0_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U0_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU0_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_CONF2.Reg, volatile.LoadUint32(&o.U0_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U0_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU0_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_CONF2.Reg, volatile.LoadUint32(&o.U0_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU0_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U0_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U1_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU1_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU1_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU1_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU1_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU1_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU1_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU1_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU1_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU1_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU1_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU1_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU1_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU1_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU1_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU1_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU1_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU1_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU1_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU1_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU1_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU1_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU1_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU1_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_CONF0.Reg, volatile.LoadUint32(&o.U1_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU1_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U1_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU1_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U1_CONF1.Reg, volatile.LoadUint32(&o.U1_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U1_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU1_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U1_CONF1.Reg, volatile.LoadUint32(&o.U1_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U1_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU1_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_CONF2.Reg, volatile.LoadUint32(&o.U1_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U1_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU1_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_CONF2.Reg, volatile.LoadUint32(&o.U1_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU1_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U1_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U2_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU2_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU2_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU2_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU2_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU2_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU2_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU2_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU2_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU2_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU2_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU2_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU2_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU2_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU2_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU2_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU2_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU2_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU2_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU2_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU2_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU2_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU2_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU2_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_CONF0.Reg, volatile.LoadUint32(&o.U2_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU2_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U2_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU2_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U2_CONF1.Reg, volatile.LoadUint32(&o.U2_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U2_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU2_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U2_CONF1.Reg, volatile.LoadUint32(&o.U2_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U2_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU2_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_CONF2.Reg, volatile.LoadUint32(&o.U2_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U2_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU2_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_CONF2.Reg, volatile.LoadUint32(&o.U2_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU2_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U2_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U3_CONF0: Configuration register 0 for unit %s
func (o *PCNT_Type) SetU3_CONF0_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x3ff)|value)
}
func (o *PCNT_Type) GetU3_CONF0_FILTER_THRES() uint32 {
	return volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x3ff
}
func (o *PCNT_Type) SetU3_CONF0_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x400)|value<<10)
}
func (o *PCNT_Type) GetU3_CONF0_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x400) >> 10
}
func (o *PCNT_Type) SetU3_CONF0_THR_ZERO_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x800)|value<<11)
}
func (o *PCNT_Type) GetU3_CONF0_THR_ZERO_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x800) >> 11
}
func (o *PCNT_Type) SetU3_CONF0_THR_H_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *PCNT_Type) GetU3_CONF0_THR_H_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x1000) >> 12
}
func (o *PCNT_Type) SetU3_CONF0_THR_L_LIM_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *PCNT_Type) GetU3_CONF0_THR_L_LIM_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x2000) >> 13
}
func (o *PCNT_Type) SetU3_CONF0_THR_THRES0_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *PCNT_Type) GetU3_CONF0_THR_THRES0_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x4000) >> 14
}
func (o *PCNT_Type) SetU3_CONF0_THR_THRES1_EN(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *PCNT_Type) GetU3_CONF0_THR_THRES1_EN() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x8000) >> 15
}
func (o *PCNT_Type) SetU3_CONF0_CH0_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x30000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x30000) >> 16
}
func (o *PCNT_Type) SetU3_CONF0_CH0_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc0000)|value<<18)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc0000) >> 18
}
func (o *PCNT_Type) SetU3_CONF0_CH0_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x300000)|value<<20)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x300000) >> 20
}
func (o *PCNT_Type) SetU3_CONF0_CH0_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc00000)|value<<22)
}
func (o *PCNT_Type) GetU3_CONF0_CH0_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc00000) >> 22
}
func (o *PCNT_Type) SetU3_CONF0_CH1_NEG_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x3000000)|value<<24)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_NEG_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x3000000) >> 24
}
func (o *PCNT_Type) SetU3_CONF0_CH1_POS_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc000000)|value<<26)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_POS_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc000000) >> 26
}
func (o *PCNT_Type) SetU3_CONF0_CH1_HCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0x30000000)|value<<28)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_HCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0x30000000) >> 28
}
func (o *PCNT_Type) SetU3_CONF0_CH1_LCTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_CONF0.Reg, volatile.LoadUint32(&o.U3_CONF0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCNT_Type) GetU3_CONF0_CH1_LCTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF0.Reg) & 0xc0000000) >> 30
}

// PCNT.U3_CONF1: Configuration register 1 for unit %s
func (o *PCNT_Type) SetU3_CONF1_CNT_THRES0(value uint32) {
	volatile.StoreUint32(&o.U3_CONF1.Reg, volatile.LoadUint32(&o.U3_CONF1.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CONF1_CNT_THRES0() uint32 {
	return volatile.LoadUint32(&o.U3_CONF1.Reg) & 0xffff
}
func (o *PCNT_Type) SetU3_CONF1_CNT_THRES1(value uint32) {
	volatile.StoreUint32(&o.U3_CONF1.Reg, volatile.LoadUint32(&o.U3_CONF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF1_CNT_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF1.Reg) & 0xffff0000) >> 16
}

// PCNT.U3_CONF2: Configuration register 2 for unit %s
func (o *PCNT_Type) SetU3_CONF2_CNT_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_CONF2.Reg, volatile.LoadUint32(&o.U3_CONF2.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CONF2_CNT_H_LIM() uint32 {
	return volatile.LoadUint32(&o.U3_CONF2.Reg) & 0xffff
}
func (o *PCNT_Type) SetU3_CONF2_CNT_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_CONF2.Reg, volatile.LoadUint32(&o.U3_CONF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PCNT_Type) GetU3_CONF2_CNT_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U3_CONF2.Reg) & 0xffff0000) >> 16
}

// PCNT.U0_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU0_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U0_CNT.Reg, volatile.LoadUint32(&o.U0_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU0_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U0_CNT.Reg) & 0xffff
}

// PCNT.U1_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU1_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U1_CNT.Reg, volatile.LoadUint32(&o.U1_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU1_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U1_CNT.Reg) & 0xffff
}

// PCNT.U2_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU2_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U2_CNT.Reg, volatile.LoadUint32(&o.U2_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU2_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U2_CNT.Reg) & 0xffff
}

// PCNT.U3_CNT: Counter value for unit %s
func (o *PCNT_Type) SetU3_CNT_CNT(value uint32) {
	volatile.StoreUint32(&o.U3_CNT.Reg, volatile.LoadUint32(&o.U3_CNT.Reg)&^(0xffff)|value)
}
func (o *PCNT_Type) GetU3_CNT_CNT() uint32 {
	return volatile.LoadUint32(&o.U3_CNT.Reg) & 0xffff
}

// PCNT.INT_RAW: Interrupt raw status register
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_RAW_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_RAW_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}

// PCNT.INT_ST: Interrupt status register
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_ST_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_ST_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}

// PCNT.INT_ENA: Interrupt enable register
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_ENA_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_ENA_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}

// PCNT.INT_CLR: Interrupt clear register
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U0(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U0() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U1(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U1() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U2(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U2() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetINT_CLR_CNT_THR_EVENT_U3(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetINT_CLR_CNT_THR_EVENT_U3() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}

// PCNT.U0_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU0_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU0_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU0_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU0_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU0_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU0_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU0_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU0_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU0_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU0_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU0_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U0_STATUS.Reg, volatile.LoadUint32(&o.U0_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU0_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U0_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U1_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU1_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU1_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU1_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU1_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU1_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU1_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU1_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU1_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU1_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU1_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU1_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U1_STATUS.Reg, volatile.LoadUint32(&o.U1_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU1_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U1_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U2_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU2_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU2_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU2_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU2_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU2_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU2_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU2_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU2_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU2_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU2_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU2_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U2_STATUS.Reg, volatile.LoadUint32(&o.U2_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU2_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U2_STATUS.Reg) & 0x40) >> 6
}

// PCNT.U3_STATUS: PNCT UNIT%s status register
func (o *PCNT_Type) SetU3_STATUS_ZERO_MODE(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x3)|value)
}
func (o *PCNT_Type) GetU3_STATUS_ZERO_MODE() uint32 {
	return volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x3
}
func (o *PCNT_Type) SetU3_STATUS_THRES1(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetU3_STATUS_THRES1() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetU3_STATUS_THRES0(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetU3_STATUS_THRES0() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetU3_STATUS_L_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetU3_STATUS_L_LIM() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetU3_STATUS_H_LIM(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetU3_STATUS_H_LIM() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetU3_STATUS_ZERO(value uint32) {
	volatile.StoreUint32(&o.U3_STATUS.Reg, volatile.LoadUint32(&o.U3_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetU3_STATUS_ZERO() uint32 {
	return (volatile.LoadUint32(&o.U3_STATUS.Reg) & 0x40) >> 6
}

// PCNT.CTRL: Control register for all counters
func (o *PCNT_Type) SetCTRL_CNT_RST_U0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U0() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *PCNT_Type) SetCTRL_CNT_RST_U1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *PCNT_Type) SetCTRL_CNT_RST_U2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *PCNT_Type) SetCTRL_CNT_RST_U3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *PCNT_Type) GetCTRL_CNT_RST_U3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *PCNT_Type) SetCTRL_CNT_PAUSE_U3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PCNT_Type) GetCTRL_CNT_PAUSE_U3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *PCNT_Type) SetCTRL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PCNT_Type) GetCTRL_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}

// PCNT.DATE: PCNT version control register
func (o *PCNT_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *PCNT_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Permissions Controller
type PMS_Type struct {
	SDIO_0                volatile.Register32 // 0x0
	SDIO_1                volatile.Register32 // 0x4
	MAC_DUMP_0            volatile.Register32 // 0x8
	MAC_DUMP_1            volatile.Register32 // 0xC
	PRO_IRAM0_0           volatile.Register32 // 0x10
	PRO_IRAM0_1           volatile.Register32 // 0x14
	PRO_IRAM0_2           volatile.Register32 // 0x18
	PRO_IRAM0_3           volatile.Register32 // 0x1C
	PRO_IRAM0_4           volatile.Register32 // 0x20
	PRO_IRAM0_5           volatile.Register32 // 0x24
	PRO_DRAM0_0           volatile.Register32 // 0x28
	PRO_DRAM0_1           volatile.Register32 // 0x2C
	PRO_DRAM0_2           volatile.Register32 // 0x30
	PRO_DRAM0_3           volatile.Register32 // 0x34
	PRO_DRAM0_4           volatile.Register32 // 0x38
	PRO_DPORT_0           volatile.Register32 // 0x3C
	PRO_DPORT_1           volatile.Register32 // 0x40
	PRO_DPORT_2           volatile.Register32 // 0x44
	PRO_DPORT_3           volatile.Register32 // 0x48
	PRO_DPORT_4           volatile.Register32 // 0x4C
	PRO_DPORT_5           volatile.Register32 // 0x50
	PRO_DPORT_6           volatile.Register32 // 0x54
	PRO_DPORT_7           volatile.Register32 // 0x58
	PRO_AHB_0             volatile.Register32 // 0x5C
	PRO_AHB_1             volatile.Register32 // 0x60
	PRO_AHB_2             volatile.Register32 // 0x64
	PRO_AHB_3             volatile.Register32 // 0x68
	PRO_AHB_4             volatile.Register32 // 0x6C
	PRO_TRACE_0           volatile.Register32 // 0x70
	PRO_TRACE_1           volatile.Register32 // 0x74
	PRO_CACHE_0           volatile.Register32 // 0x78
	PRO_CACHE_1           volatile.Register32 // 0x7C
	PRO_CACHE_2           volatile.Register32 // 0x80
	PRO_CACHE_3           volatile.Register32 // 0x84
	PRO_CACHE_4           volatile.Register32 // 0x88
	DMA_APB_I_0           volatile.Register32 // 0x8C
	DMA_APB_I_1           volatile.Register32 // 0x90
	DMA_APB_I_2           volatile.Register32 // 0x94
	DMA_APB_I_3           volatile.Register32 // 0x98
	DMA_RX_I_0            volatile.Register32 // 0x9C
	DMA_RX_I_1            volatile.Register32 // 0xA0
	DMA_RX_I_2            volatile.Register32 // 0xA4
	DMA_RX_I_3            volatile.Register32 // 0xA8
	DMA_TX_I_0            volatile.Register32 // 0xAC
	DMA_TX_I_1            volatile.Register32 // 0xB0
	DMA_TX_I_2            volatile.Register32 // 0xB4
	DMA_TX_I_3            volatile.Register32 // 0xB8
	PRO_BOOT_LOCATION_0   volatile.Register32 // 0xBC
	PRO_BOOT_LOCATION_1   volatile.Register32 // 0xC0
	CACHE_SOURCE_0        volatile.Register32 // 0xC4
	CACHE_SOURCE_1        volatile.Register32 // 0xC8
	APB_PERIPHERAL_0      volatile.Register32 // 0xCC
	APB_PERIPHERAL_1      volatile.Register32 // 0xD0
	OCCUPY_0              volatile.Register32 // 0xD4
	OCCUPY_1              volatile.Register32 // 0xD8
	OCCUPY_2              volatile.Register32 // 0xDC
	OCCUPY_3              volatile.Register32 // 0xE0
	CACHE_TAG_ACCESS_0    volatile.Register32 // 0xE4
	CACHE_TAG_ACCESS_1    volatile.Register32 // 0xE8
	CACHE_MMU_ACCESS_0    volatile.Register32 // 0xEC
	CACHE_MMU_ACCESS_1    volatile.Register32 // 0xF0
	APB_PERIPHERAL_INTR   volatile.Register32 // 0xF4
	APB_PERIPHERAL_STATUS volatile.Register32 // 0xF8
	CPU_PERIPHERAL_INTR   volatile.Register32 // 0xFC
	CPU_PERIPHERAL_STATUS volatile.Register32 // 0x100
	CLOCK_GATE            volatile.Register32 // 0x104
	_                     [3828]byte
	DATE                  volatile.Register32 // 0xFFC
}

// PMS.SDIO_0: SDIO permission control register 0.
func (o *PMS_Type) SetSDIO_0_SDIO_LOCK(value uint32) {
	volatile.StoreUint32(&o.SDIO_0.Reg, volatile.LoadUint32(&o.SDIO_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetSDIO_0_SDIO_LOCK() uint32 {
	return volatile.LoadUint32(&o.SDIO_0.Reg) & 0x1
}

// PMS.SDIO_1: SDIO permission control register 1.
func (o *PMS_Type) SetSDIO_1_SDIO_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SDIO_1.Reg, volatile.LoadUint32(&o.SDIO_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetSDIO_1_SDIO_DISABLE() uint32 {
	return volatile.LoadUint32(&o.SDIO_1.Reg) & 0x1
}

// PMS.MAC_DUMP_0: MAC dump permission control register 0.
func (o *PMS_Type) SetMAC_DUMP_0_MAC_DUMP_LOCK(value uint32) {
	volatile.StoreUint32(&o.MAC_DUMP_0.Reg, volatile.LoadUint32(&o.MAC_DUMP_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetMAC_DUMP_0_MAC_DUMP_LOCK() uint32 {
	return volatile.LoadUint32(&o.MAC_DUMP_0.Reg) & 0x1
}

// PMS.MAC_DUMP_1: MAC dump permission control register 1.
func (o *PMS_Type) SetMAC_DUMP_1_MAC_DUMP_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MAC_DUMP_1.Reg, volatile.LoadUint32(&o.MAC_DUMP_1.Reg)&^(0xfff)|value)
}
func (o *PMS_Type) GetMAC_DUMP_1_MAC_DUMP_CONNECT() uint32 {
	return volatile.LoadUint32(&o.MAC_DUMP_1.Reg) & 0xfff
}

// PMS.PRO_IRAM0_0: IBUS permission control register 0.
func (o *PMS_Type) SetPRO_IRAM0_0_PRO_IRAM0_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_0.Reg, volatile.LoadUint32(&o.PRO_IRAM0_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_IRAM0_0_PRO_IRAM0_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_IRAM0_0.Reg) & 0x1
}

// PMS.PRO_IRAM0_1: IBUS permission control register 1.
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_0_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_0_F() uint32 {
	return volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_0_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_0_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_0_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_0_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_1_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_1_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x8) >> 3
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_1_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x10)|value<<4)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_1_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x10) >> 4
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_1_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x20)|value<<5)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_1_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x20) >> 5
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_2_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x40)|value<<6)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_2_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x40) >> 6
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_2_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x80)|value<<7)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_2_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x80) >> 7
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_2_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x100)|value<<8)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_2_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x100) >> 8
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_3_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x200)|value<<9)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_3_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x200) >> 9
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_3_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x400)|value<<10)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_3_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x400) >> 10
}
func (o *PMS_Type) SetPRO_IRAM0_1_PRO_IRAM0_SRAM_3_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_1.Reg, volatile.LoadUint32(&o.PRO_IRAM0_1.Reg)&^(0x800)|value<<11)
}
func (o *PMS_Type) GetPRO_IRAM0_1_PRO_IRAM0_SRAM_3_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_1.Reg) & 0x800) >> 11
}

// PMS.PRO_IRAM0_2: IBUS permission control register 2.
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x1ffff)|value)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_SPLTADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x1ffff
}
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x20000)|value<<17)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x20000) >> 17
}
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x40000)|value<<18)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x40000) >> 18
}
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x80000)|value<<19)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x80000) >> 19
}
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x100000)|value<<20)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x100000) >> 20
}
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x200000)|value<<21)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x200000) >> 21
}
func (o *PMS_Type) SetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_2.Reg, volatile.LoadUint32(&o.PRO_IRAM0_2.Reg)&^(0x400000)|value<<22)
}
func (o *PMS_Type) GetPRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_2.Reg) & 0x400000) >> 22
}

// PMS.PRO_IRAM0_3: IBUS permission control register 3.
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x7ff)|value)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_SPLTADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x7ff
}
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x800)|value<<11)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x800) >> 11
}
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x1000)|value<<12)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x1000) >> 12
}
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x2000)|value<<13)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x2000) >> 13
}
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_F(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x4000)|value<<14)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x4000) >> 14
}
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x8000)|value<<15)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x8000) >> 15
}
func (o *PMS_Type) SetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_3.Reg, volatile.LoadUint32(&o.PRO_IRAM0_3.Reg)&^(0x10000)|value<<16)
}
func (o *PMS_Type) GetPRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_3.Reg) & 0x10000) >> 16
}

// PMS.PRO_IRAM0_4: IBUS permission control register 4.
func (o *PMS_Type) SetPRO_IRAM0_4_PRO_IRAM0_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_4.Reg, volatile.LoadUint32(&o.PRO_IRAM0_4.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_IRAM0_4_PRO_IRAM0_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.PRO_IRAM0_4.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_IRAM0_4_PRO_IRAM0_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_4.Reg, volatile.LoadUint32(&o.PRO_IRAM0_4.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_IRAM0_4_PRO_IRAM0_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_4.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_IRAM0_4_PRO_IRAM0_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_4.Reg, volatile.LoadUint32(&o.PRO_IRAM0_4.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_IRAM0_4_PRO_IRAM0_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_IRAM0_4.Reg) & 0x4) >> 2
}

// PMS.PRO_IRAM0_5: IBUS status register.
func (o *PMS_Type) SetPRO_IRAM0_5_PRO_IRAM0_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.PRO_IRAM0_5.Reg, volatile.LoadUint32(&o.PRO_IRAM0_5.Reg)&^(0x3fffff)|value)
}
func (o *PMS_Type) GetPRO_IRAM0_5_PRO_IRAM0_ILG_ST() uint32 {
	return volatile.LoadUint32(&o.PRO_IRAM0_5.Reg) & 0x3fffff
}

// PMS.PRO_DRAM0_0: DBUS permission control register 0.
func (o *PMS_Type) SetPRO_DRAM0_0_PRO_DRAM0_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_0.Reg, volatile.LoadUint32(&o.PRO_DRAM0_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_DRAM0_0_PRO_DRAM0_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_DRAM0_0.Reg) & 0x1
}

// PMS.PRO_DRAM0_1: DBUS permission control register 1.
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_0_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_0_R() uint32 {
	return volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_0_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_0_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_1_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_1_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_1_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_1_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x8) >> 3
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_2_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x10)|value<<4)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_2_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x10) >> 4
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_2_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x20)|value<<5)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_2_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x20) >> 5
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_3_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x40)|value<<6)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_3_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x40) >> 6
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_3_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x80)|value<<7)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_3_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x80) >> 7
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x1ffff00)|value<<8)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_SPLTADDR() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x1ffff00) >> 8
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x2000000) >> 25
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x4000000) >> 26
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x8000000) >> 27
}
func (o *PMS_Type) SetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_1.Reg, volatile.LoadUint32(&o.PRO_DRAM0_1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMS_Type) GetPRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_1.Reg) & 0x10000000) >> 28
}

// PMS.PRO_DRAM0_2: DBUS permission control register 2.
func (o *PMS_Type) SetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_2.Reg, volatile.LoadUint32(&o.PRO_DRAM0_2.Reg)&^(0x7ff)|value)
}
func (o *PMS_Type) GetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_SPLTADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_DRAM0_2.Reg) & 0x7ff
}
func (o *PMS_Type) SetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_2.Reg, volatile.LoadUint32(&o.PRO_DRAM0_2.Reg)&^(0x800)|value<<11)
}
func (o *PMS_Type) GetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_2.Reg) & 0x800) >> 11
}
func (o *PMS_Type) SetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_2.Reg, volatile.LoadUint32(&o.PRO_DRAM0_2.Reg)&^(0x1000)|value<<12)
}
func (o *PMS_Type) GetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_2.Reg) & 0x1000) >> 12
}
func (o *PMS_Type) SetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_2.Reg, volatile.LoadUint32(&o.PRO_DRAM0_2.Reg)&^(0x2000)|value<<13)
}
func (o *PMS_Type) GetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_2.Reg) & 0x2000) >> 13
}
func (o *PMS_Type) SetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_2.Reg, volatile.LoadUint32(&o.PRO_DRAM0_2.Reg)&^(0x4000)|value<<14)
}
func (o *PMS_Type) GetPRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_2.Reg) & 0x4000) >> 14
}

// PMS.PRO_DRAM0_3: DBUS permission control register 3.
func (o *PMS_Type) SetPRO_DRAM0_3_PRO_DRAM0_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_3.Reg, volatile.LoadUint32(&o.PRO_DRAM0_3.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_DRAM0_3_PRO_DRAM0_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.PRO_DRAM0_3.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_DRAM0_3_PRO_DRAM0_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_3.Reg, volatile.LoadUint32(&o.PRO_DRAM0_3.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_DRAM0_3_PRO_DRAM0_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_3.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_DRAM0_3_PRO_DRAM0_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_3.Reg, volatile.LoadUint32(&o.PRO_DRAM0_3.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_DRAM0_3_PRO_DRAM0_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_DRAM0_3.Reg) & 0x4) >> 2
}

// PMS.PRO_DRAM0_4: DBUS status register.
func (o *PMS_Type) SetPRO_DRAM0_4_PRO_DRAM0_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.PRO_DRAM0_4.Reg, volatile.LoadUint32(&o.PRO_DRAM0_4.Reg)&^(0x3ffffff)|value)
}
func (o *PMS_Type) GetPRO_DRAM0_4_PRO_DRAM0_ILG_ST() uint32 {
	return volatile.LoadUint32(&o.PRO_DRAM0_4.Reg) & 0x3ffffff
}

// PMS.PRO_DPORT_0: PeriBus1 permission control register 0.
func (o *PMS_Type) SetPRO_DPORT_0_PRO_DPORT_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_0.Reg, volatile.LoadUint32(&o.PRO_DPORT_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_DPORT_0_PRO_DPORT_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_0.Reg) & 0x1
}

// PMS.PRO_DPORT_1: PeriBus1 permission control register 1.
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_APB_PERIPHERAL_FORBID(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_APB_PERIPHERAL_FORBID() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_RTCSLOW_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0xffe)|value<<1)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_RTCSLOW_SPLTADDR() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0xffe) >> 1
}
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_RTCSLOW_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0x1000)|value<<12)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_RTCSLOW_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0x1000) >> 12
}
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_RTCSLOW_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0x2000)|value<<13)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_RTCSLOW_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0x2000) >> 13
}
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_RTCSLOW_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0x4000)|value<<14)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_RTCSLOW_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0x4000) >> 14
}
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_RTCSLOW_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0x8000)|value<<15)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_RTCSLOW_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0x8000) >> 15
}
func (o *PMS_Type) SetPRO_DPORT_1_PRO_DPORT_RESERVE_FIFO_VALID(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_1.Reg, volatile.LoadUint32(&o.PRO_DPORT_1.Reg)&^(0xf0000)|value<<16)
}
func (o *PMS_Type) GetPRO_DPORT_1_PRO_DPORT_RESERVE_FIFO_VALID() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_1.Reg) & 0xf0000) >> 16
}

// PMS.PRO_DPORT_2: PeriBus1 permission control register 2.
func (o *PMS_Type) SetPRO_DPORT_2_PRO_DPORT_RESERVE_FIFO_0(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_2.Reg, volatile.LoadUint32(&o.PRO_DPORT_2.Reg)&^(0x3ffff)|value)
}
func (o *PMS_Type) GetPRO_DPORT_2_PRO_DPORT_RESERVE_FIFO_0() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_2.Reg) & 0x3ffff
}

// PMS.PRO_DPORT_3: PeriBus1 permission control register 3.
func (o *PMS_Type) SetPRO_DPORT_3_PRO_DPORT_RESERVE_FIFO_1(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_3.Reg, volatile.LoadUint32(&o.PRO_DPORT_3.Reg)&^(0x3ffff)|value)
}
func (o *PMS_Type) GetPRO_DPORT_3_PRO_DPORT_RESERVE_FIFO_1() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_3.Reg) & 0x3ffff
}

// PMS.PRO_DPORT_4: PeriBus1 permission control register 4.
func (o *PMS_Type) SetPRO_DPORT_4_PRO_DPORT_RESERVE_FIFO_2(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_4.Reg, volatile.LoadUint32(&o.PRO_DPORT_4.Reg)&^(0x3ffff)|value)
}
func (o *PMS_Type) GetPRO_DPORT_4_PRO_DPORT_RESERVE_FIFO_2() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_4.Reg) & 0x3ffff
}

// PMS.PRO_DPORT_5: PeriBus1 permission control register 5.
func (o *PMS_Type) SetPRO_DPORT_5_PRO_DPORT_RESERVE_FIFO_3(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_5.Reg, volatile.LoadUint32(&o.PRO_DPORT_5.Reg)&^(0x3ffff)|value)
}
func (o *PMS_Type) GetPRO_DPORT_5_PRO_DPORT_RESERVE_FIFO_3() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_5.Reg) & 0x3ffff
}

// PMS.PRO_DPORT_6: PeriBus1 permission control register 6.
func (o *PMS_Type) SetPRO_DPORT_6_PRO_DPORT_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_6.Reg, volatile.LoadUint32(&o.PRO_DPORT_6.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_DPORT_6_PRO_DPORT_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_6.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_DPORT_6_PRO_DPORT_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_6.Reg, volatile.LoadUint32(&o.PRO_DPORT_6.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_DPORT_6_PRO_DPORT_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_6.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_DPORT_6_PRO_DPORT_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_6.Reg, volatile.LoadUint32(&o.PRO_DPORT_6.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_DPORT_6_PRO_DPORT_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_DPORT_6.Reg) & 0x4) >> 2
}

// PMS.PRO_DPORT_7: PeriBus1 status register.
func (o *PMS_Type) SetPRO_DPORT_7_PRO_DPORT_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.PRO_DPORT_7.Reg, volatile.LoadUint32(&o.PRO_DPORT_7.Reg)&^(0x3ffffff)|value)
}
func (o *PMS_Type) GetPRO_DPORT_7_PRO_DPORT_ILG_ST() uint32 {
	return volatile.LoadUint32(&o.PRO_DPORT_7.Reg) & 0x3ffffff
}

// PMS.PRO_AHB_0: PeriBus2 permission control register 0.
func (o *PMS_Type) SetPRO_AHB_0_PRO_AHB_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_0.Reg, volatile.LoadUint32(&o.PRO_AHB_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_AHB_0_PRO_AHB_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_AHB_0.Reg) & 0x1
}

// PMS.PRO_AHB_1: PeriBus2 permission control register 1.
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x7ff)|value)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_SPLTADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x7ff
}
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_L_F(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x800)|value<<11)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_L_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x800) >> 11
}
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x1000)|value<<12)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x1000) >> 12
}
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x2000)|value<<13)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x2000) >> 13
}
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_H_F(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x4000)|value<<14)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_H_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x4000) >> 14
}
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x8000)|value<<15)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x8000) >> 15
}
func (o *PMS_Type) SetPRO_AHB_1_PRO_AHB_RTCSLOW_0_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_1.Reg, volatile.LoadUint32(&o.PRO_AHB_1.Reg)&^(0x10000)|value<<16)
}
func (o *PMS_Type) GetPRO_AHB_1_PRO_AHB_RTCSLOW_0_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_1.Reg) & 0x10000) >> 16
}

// PMS.PRO_AHB_2: PeriBus2 permission control register 2.
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x7ff)|value)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_SPLTADDR() uint32 {
	return volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x7ff
}
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_L_F(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x800)|value<<11)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_L_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x800) >> 11
}
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_L_R(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x1000)|value<<12)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_L_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x1000) >> 12
}
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_L_W(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x2000)|value<<13)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_L_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x2000) >> 13
}
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_H_F(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x4000)|value<<14)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_H_F() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x4000) >> 14
}
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_H_R(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x8000)|value<<15)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_H_R() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x8000) >> 15
}
func (o *PMS_Type) SetPRO_AHB_2_PRO_AHB_RTCSLOW_1_H_W(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_2.Reg, volatile.LoadUint32(&o.PRO_AHB_2.Reg)&^(0x10000)|value<<16)
}
func (o *PMS_Type) GetPRO_AHB_2_PRO_AHB_RTCSLOW_1_H_W() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_2.Reg) & 0x10000) >> 16
}

// PMS.PRO_AHB_3: PeriBus2 permission control register 3.
func (o *PMS_Type) SetPRO_AHB_3_PRO_AHB_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_3.Reg, volatile.LoadUint32(&o.PRO_AHB_3.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_AHB_3_PRO_AHB_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.PRO_AHB_3.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_AHB_3_PRO_AHB_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_3.Reg, volatile.LoadUint32(&o.PRO_AHB_3.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_AHB_3_PRO_AHB_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_3.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_AHB_3_PRO_AHB_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_3.Reg, volatile.LoadUint32(&o.PRO_AHB_3.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_AHB_3_PRO_AHB_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_AHB_3.Reg) & 0x4) >> 2
}

// PMS.PRO_AHB_4: PeriBus2 status register.
func (o *PMS_Type) SetPRO_AHB_4(value uint32) {
	volatile.StoreUint32(&o.PRO_AHB_4.Reg, value)
}
func (o *PMS_Type) GetPRO_AHB_4() uint32 {
	return volatile.LoadUint32(&o.PRO_AHB_4.Reg)
}

// PMS.PRO_TRACE_0: Trace memory permission control register 0.
func (o *PMS_Type) SetPRO_TRACE_0_PRO_TRACE_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_TRACE_0.Reg, volatile.LoadUint32(&o.PRO_TRACE_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_TRACE_0_PRO_TRACE_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_TRACE_0.Reg) & 0x1
}

// PMS.PRO_TRACE_1: Trace memory permission control register 1.
func (o *PMS_Type) SetPRO_TRACE_1_PRO_TRACE_DISABLE(value uint32) {
	volatile.StoreUint32(&o.PRO_TRACE_1.Reg, volatile.LoadUint32(&o.PRO_TRACE_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_TRACE_1_PRO_TRACE_DISABLE() uint32 {
	return volatile.LoadUint32(&o.PRO_TRACE_1.Reg) & 0x1
}

// PMS.PRO_CACHE_0: Cache permission control register 0.
func (o *PMS_Type) SetPRO_CACHE_0_PRO_CACHE_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_0.Reg, volatile.LoadUint32(&o.PRO_CACHE_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_CACHE_0_PRO_CACHE_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_0.Reg) & 0x1
}

// PMS.PRO_CACHE_1: Cache permission control register 1.
func (o *PMS_Type) SetPRO_CACHE_1_PRO_CACHE_CONNECT(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_1.Reg, volatile.LoadUint32(&o.PRO_CACHE_1.Reg)&^(0xffff)|value)
}
func (o *PMS_Type) GetPRO_CACHE_1_PRO_CACHE_CONNECT() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_1.Reg) & 0xffff
}

// PMS.PRO_CACHE_2: Cache permission control register 2.
func (o *PMS_Type) SetPRO_CACHE_2_PRO_CACHE_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_2.Reg, volatile.LoadUint32(&o.PRO_CACHE_2.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_CACHE_2_PRO_CACHE_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_2.Reg) & 0x1
}
func (o *PMS_Type) SetPRO_CACHE_2_PRO_CACHE_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_2.Reg, volatile.LoadUint32(&o.PRO_CACHE_2.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetPRO_CACHE_2_PRO_CACHE_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_2.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetPRO_CACHE_2_PRO_CACHE_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_2.Reg, volatile.LoadUint32(&o.PRO_CACHE_2.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetPRO_CACHE_2_PRO_CACHE_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.PRO_CACHE_2.Reg) & 0x4) >> 2
}

// PMS.PRO_CACHE_3: Icache status register.
func (o *PMS_Type) SetPRO_CACHE_3_PRO_CACHE_ILG_ST_I(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_3.Reg, volatile.LoadUint32(&o.PRO_CACHE_3.Reg)&^(0x1ffff)|value)
}
func (o *PMS_Type) GetPRO_CACHE_3_PRO_CACHE_ILG_ST_I() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_3.Reg) & 0x1ffff
}

// PMS.PRO_CACHE_4: Dcache status register.
func (o *PMS_Type) SetPRO_CACHE_4_PRO_CACHE_ILG_ST_D(value uint32) {
	volatile.StoreUint32(&o.PRO_CACHE_4.Reg, volatile.LoadUint32(&o.PRO_CACHE_4.Reg)&^(0x1ffff)|value)
}
func (o *PMS_Type) GetPRO_CACHE_4_PRO_CACHE_ILG_ST_D() uint32 {
	return volatile.LoadUint32(&o.PRO_CACHE_4.Reg) & 0x1ffff
}

// PMS.DMA_APB_I_0: Internal DMA permission control register 0.
func (o *PMS_Type) SetDMA_APB_I_0_DMA_APB_I_LOCK(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_0.Reg, volatile.LoadUint32(&o.DMA_APB_I_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_APB_I_0_DMA_APB_I_LOCK() uint32 {
	return volatile.LoadUint32(&o.DMA_APB_I_0.Reg) & 0x1
}

// PMS.DMA_APB_I_1: Internal DMA permission control register 1.
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_0_R(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_0_R() uint32 {
	return volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x1
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_0_W(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_0_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_1_R(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_1_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_1_W(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_1_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x8) >> 3
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_2_R(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x10)|value<<4)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_2_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x10) >> 4
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_2_W(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x20)|value<<5)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_2_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x20) >> 5
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_3_R(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x40)|value<<6)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_3_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x40) >> 6
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_3_W(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x80)|value<<7)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_3_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x80) >> 7
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_4_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x1ffff00)|value<<8)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_4_SPLTADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x1ffff00) >> 8
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_4_L_R(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_4_L_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x2000000) >> 25
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_4_L_W(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_4_L_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x4000000) >> 26
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_4_H_R(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_4_H_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x8000000) >> 27
}
func (o *PMS_Type) SetDMA_APB_I_1_DMA_APB_I_SRAM_4_H_W(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_1.Reg, volatile.LoadUint32(&o.DMA_APB_I_1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMS_Type) GetDMA_APB_I_1_DMA_APB_I_SRAM_4_H_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_1.Reg) & 0x10000000) >> 28
}

// PMS.DMA_APB_I_2: Internal DMA permission control register 2.
func (o *PMS_Type) SetDMA_APB_I_2_DMA_APB_I_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_2.Reg, volatile.LoadUint32(&o.DMA_APB_I_2.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_APB_I_2_DMA_APB_I_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.DMA_APB_I_2.Reg) & 0x1
}
func (o *PMS_Type) SetDMA_APB_I_2_DMA_APB_I_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_2.Reg, volatile.LoadUint32(&o.DMA_APB_I_2.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetDMA_APB_I_2_DMA_APB_I_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_2.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetDMA_APB_I_2_DMA_APB_I_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_2.Reg, volatile.LoadUint32(&o.DMA_APB_I_2.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetDMA_APB_I_2_DMA_APB_I_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.DMA_APB_I_2.Reg) & 0x4) >> 2
}

// PMS.DMA_APB_I_3: Internal DMA status register.
func (o *PMS_Type) SetDMA_APB_I_3_DMA_APB_I_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_APB_I_3.Reg, volatile.LoadUint32(&o.DMA_APB_I_3.Reg)&^(0x7fffff)|value)
}
func (o *PMS_Type) GetDMA_APB_I_3_DMA_APB_I_ILG_ST() uint32 {
	return volatile.LoadUint32(&o.DMA_APB_I_3.Reg) & 0x7fffff
}

// PMS.DMA_RX_I_0: RX Copy DMA permission control register 0.
func (o *PMS_Type) SetDMA_RX_I_0_DMA_RX_I_LOCK(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_0.Reg, volatile.LoadUint32(&o.DMA_RX_I_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_RX_I_0_DMA_RX_I_LOCK() uint32 {
	return volatile.LoadUint32(&o.DMA_RX_I_0.Reg) & 0x1
}

// PMS.DMA_RX_I_1: RX Copy DMA permission control register 1.
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_0_R(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_0_R() uint32 {
	return volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x1
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_0_W(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_0_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_1_R(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_1_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_1_W(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_1_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x8) >> 3
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_2_R(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x10)|value<<4)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_2_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x10) >> 4
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_2_W(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x20)|value<<5)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_2_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x20) >> 5
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_3_R(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x40)|value<<6)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_3_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x40) >> 6
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_3_W(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x80)|value<<7)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_3_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x80) >> 7
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_4_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x1ffff00)|value<<8)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_4_SPLTADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x1ffff00) >> 8
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_4_L_R(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_4_L_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x2000000) >> 25
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_4_L_W(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_4_L_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x4000000) >> 26
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_4_H_R(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_4_H_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x8000000) >> 27
}
func (o *PMS_Type) SetDMA_RX_I_1_DMA_RX_I_SRAM_4_H_W(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_1.Reg, volatile.LoadUint32(&o.DMA_RX_I_1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMS_Type) GetDMA_RX_I_1_DMA_RX_I_SRAM_4_H_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_1.Reg) & 0x10000000) >> 28
}

// PMS.DMA_RX_I_2: RX Copy DMA permission control register 2.
func (o *PMS_Type) SetDMA_RX_I_2_DMA_RX_I_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_2.Reg, volatile.LoadUint32(&o.DMA_RX_I_2.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_RX_I_2_DMA_RX_I_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.DMA_RX_I_2.Reg) & 0x1
}
func (o *PMS_Type) SetDMA_RX_I_2_DMA_RX_I_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_2.Reg, volatile.LoadUint32(&o.DMA_RX_I_2.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetDMA_RX_I_2_DMA_RX_I_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_2.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetDMA_RX_I_2_DMA_RX_I_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_2.Reg, volatile.LoadUint32(&o.DMA_RX_I_2.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetDMA_RX_I_2_DMA_RX_I_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.DMA_RX_I_2.Reg) & 0x4) >> 2
}

// PMS.DMA_RX_I_3: RX Copy DMA status register.
func (o *PMS_Type) SetDMA_RX_I_3_DMA_RX_I_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_RX_I_3.Reg, volatile.LoadUint32(&o.DMA_RX_I_3.Reg)&^(0x7fffff)|value)
}
func (o *PMS_Type) GetDMA_RX_I_3_DMA_RX_I_ILG_ST() uint32 {
	return volatile.LoadUint32(&o.DMA_RX_I_3.Reg) & 0x7fffff
}

// PMS.DMA_TX_I_0: TX Copy DMA permission control register 0.
func (o *PMS_Type) SetDMA_TX_I_0_DMA_TX_I_LOCK(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_0.Reg, volatile.LoadUint32(&o.DMA_TX_I_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_TX_I_0_DMA_TX_I_LOCK() uint32 {
	return volatile.LoadUint32(&o.DMA_TX_I_0.Reg) & 0x1
}

// PMS.DMA_TX_I_1: TX Copy DMA permission control register 1.
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_0_R(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_0_R() uint32 {
	return volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x1
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_0_W(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_0_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_1_R(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_1_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_1_W(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_1_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x8) >> 3
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_2_R(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x10)|value<<4)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_2_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x10) >> 4
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_2_W(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x20)|value<<5)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_2_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x20) >> 5
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_3_R(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x40)|value<<6)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_3_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x40) >> 6
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_3_W(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x80)|value<<7)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_3_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x80) >> 7
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_4_SPLTADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x1ffff00)|value<<8)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_4_SPLTADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x1ffff00) >> 8
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_4_L_R(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_4_L_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x2000000) >> 25
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_4_L_W(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_4_L_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x4000000) >> 26
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_4_H_R(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_4_H_R() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x8000000) >> 27
}
func (o *PMS_Type) SetDMA_TX_I_1_DMA_TX_I_SRAM_4_H_W(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_1.Reg, volatile.LoadUint32(&o.DMA_TX_I_1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMS_Type) GetDMA_TX_I_1_DMA_TX_I_SRAM_4_H_W() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_1.Reg) & 0x10000000) >> 28
}

// PMS.DMA_TX_I_2: TX Copy DMA permission control register 2.
func (o *PMS_Type) SetDMA_TX_I_2_DMA_TX_I_ILG_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_2.Reg, volatile.LoadUint32(&o.DMA_TX_I_2.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetDMA_TX_I_2_DMA_TX_I_ILG_CLR() uint32 {
	return volatile.LoadUint32(&o.DMA_TX_I_2.Reg) & 0x1
}
func (o *PMS_Type) SetDMA_TX_I_2_DMA_TX_I_ILG_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_2.Reg, volatile.LoadUint32(&o.DMA_TX_I_2.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetDMA_TX_I_2_DMA_TX_I_ILG_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_2.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetDMA_TX_I_2_DMA_TX_I_ILG_INTR(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_2.Reg, volatile.LoadUint32(&o.DMA_TX_I_2.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetDMA_TX_I_2_DMA_TX_I_ILG_INTR() uint32 {
	return (volatile.LoadUint32(&o.DMA_TX_I_2.Reg) & 0x4) >> 2
}

// PMS.DMA_TX_I_3: TX Copy DMA status register.
func (o *PMS_Type) SetDMA_TX_I_3_DMA_TX_I_ILG_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_TX_I_3.Reg, volatile.LoadUint32(&o.DMA_TX_I_3.Reg)&^(0x7fffff)|value)
}
func (o *PMS_Type) GetDMA_TX_I_3_DMA_TX_I_ILG_ST() uint32 {
	return volatile.LoadUint32(&o.DMA_TX_I_3.Reg) & 0x7fffff
}

// PMS.PRO_BOOT_LOCATION_0: Boot permission control register 0.
func (o *PMS_Type) SetPRO_BOOT_LOCATION_0_PRO_BOOT_LOCATION_LOCK(value uint32) {
	volatile.StoreUint32(&o.PRO_BOOT_LOCATION_0.Reg, volatile.LoadUint32(&o.PRO_BOOT_LOCATION_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_BOOT_LOCATION_0_PRO_BOOT_LOCATION_LOCK() uint32 {
	return volatile.LoadUint32(&o.PRO_BOOT_LOCATION_0.Reg) & 0x1
}

// PMS.PRO_BOOT_LOCATION_1: Boot permission control register 1.
func (o *PMS_Type) SetPRO_BOOT_LOCATION_1_PRO_BOOT_REMAP(value uint32) {
	volatile.StoreUint32(&o.PRO_BOOT_LOCATION_1.Reg, volatile.LoadUint32(&o.PRO_BOOT_LOCATION_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetPRO_BOOT_LOCATION_1_PRO_BOOT_REMAP() uint32 {
	return volatile.LoadUint32(&o.PRO_BOOT_LOCATION_1.Reg) & 0x1
}

// PMS.CACHE_SOURCE_0: Cache access permission control register 0.
func (o *PMS_Type) SetCACHE_SOURCE_0_CACHE_SOURCE_LOCK(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_0.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCACHE_SOURCE_0_CACHE_SOURCE_LOCK() uint32 {
	return volatile.LoadUint32(&o.CACHE_SOURCE_0.Reg) & 0x1
}

// PMS.CACHE_SOURCE_1: Cache access permission control register 1.
func (o *PMS_Type) SetCACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IRAM1(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_1.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IRAM1() uint32 {
	return volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg) & 0x1
}
func (o *PMS_Type) SetCACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IROM0(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_1.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetCACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IROM0() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetCACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_DROM0(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_1.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetCACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_DROM0() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetCACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DRAM0(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_1.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetCACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DRAM0() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg) & 0x8) >> 3
}
func (o *PMS_Type) SetCACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DPORT(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_1.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg)&^(0x10)|value<<4)
}
func (o *PMS_Type) GetCACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DPORT() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg) & 0x10) >> 4
}
func (o *PMS_Type) SetCACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DROM0(value uint32) {
	volatile.StoreUint32(&o.CACHE_SOURCE_1.Reg, volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg)&^(0x20)|value<<5)
}
func (o *PMS_Type) GetCACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DROM0() uint32 {
	return (volatile.LoadUint32(&o.CACHE_SOURCE_1.Reg) & 0x20) >> 5
}

// PMS.APB_PERIPHERAL_0: Peripheral access permission control register 0.
func (o *PMS_Type) SetAPB_PERIPHERAL_0_APB_PERIPHERAL_LOCK(value uint32) {
	volatile.StoreUint32(&o.APB_PERIPHERAL_0.Reg, volatile.LoadUint32(&o.APB_PERIPHERAL_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetAPB_PERIPHERAL_0_APB_PERIPHERAL_LOCK() uint32 {
	return volatile.LoadUint32(&o.APB_PERIPHERAL_0.Reg) & 0x1
}

// PMS.APB_PERIPHERAL_1: Peripheral access permission control register 1.
func (o *PMS_Type) SetAPB_PERIPHERAL_1_APB_PERIPHERAL_SPLIT_BURST(value uint32) {
	volatile.StoreUint32(&o.APB_PERIPHERAL_1.Reg, volatile.LoadUint32(&o.APB_PERIPHERAL_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetAPB_PERIPHERAL_1_APB_PERIPHERAL_SPLIT_BURST() uint32 {
	return volatile.LoadUint32(&o.APB_PERIPHERAL_1.Reg) & 0x1
}

// PMS.OCCUPY_0: Occupy permission control register 0.
func (o *PMS_Type) SetOCCUPY_0_OCCUPY_LOCK(value uint32) {
	volatile.StoreUint32(&o.OCCUPY_0.Reg, volatile.LoadUint32(&o.OCCUPY_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetOCCUPY_0_OCCUPY_LOCK() uint32 {
	return volatile.LoadUint32(&o.OCCUPY_0.Reg) & 0x1
}

// PMS.OCCUPY_1: Occupy permission control register 1.
func (o *PMS_Type) SetOCCUPY_1_OCCUPY_CACHE(value uint32) {
	volatile.StoreUint32(&o.OCCUPY_1.Reg, volatile.LoadUint32(&o.OCCUPY_1.Reg)&^(0xf)|value)
}
func (o *PMS_Type) GetOCCUPY_1_OCCUPY_CACHE() uint32 {
	return volatile.LoadUint32(&o.OCCUPY_1.Reg) & 0xf
}

// PMS.OCCUPY_2: Occupy permission control register 2.
func (o *PMS_Type) SetOCCUPY_2_OCCUPY_MAC_DUMP(value uint32) {
	volatile.StoreUint32(&o.OCCUPY_2.Reg, volatile.LoadUint32(&o.OCCUPY_2.Reg)&^(0xf)|value)
}
func (o *PMS_Type) GetOCCUPY_2_OCCUPY_MAC_DUMP() uint32 {
	return volatile.LoadUint32(&o.OCCUPY_2.Reg) & 0xf
}

// PMS.OCCUPY_3: Occupy permission control register 3.
func (o *PMS_Type) SetOCCUPY_3_OCCUPY_PRO_TRACE(value uint32) {
	volatile.StoreUint32(&o.OCCUPY_3.Reg, volatile.LoadUint32(&o.OCCUPY_3.Reg)&^(0x3ffff)|value)
}
func (o *PMS_Type) GetOCCUPY_3_OCCUPY_PRO_TRACE() uint32 {
	return volatile.LoadUint32(&o.OCCUPY_3.Reg) & 0x3ffff
}

// PMS.CACHE_TAG_ACCESS_0: Cache tag permission control register 0.
func (o *PMS_Type) SetCACHE_TAG_ACCESS_0_CACHE_TAG_ACCESS_LOCK(value uint32) {
	volatile.StoreUint32(&o.CACHE_TAG_ACCESS_0.Reg, volatile.LoadUint32(&o.CACHE_TAG_ACCESS_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCACHE_TAG_ACCESS_0_CACHE_TAG_ACCESS_LOCK() uint32 {
	return volatile.LoadUint32(&o.CACHE_TAG_ACCESS_0.Reg) & 0x1
}

// PMS.CACHE_TAG_ACCESS_1: Cache tag permission control register 1.
func (o *PMS_Type) SetCACHE_TAG_ACCESS_1_PRO_I_TAG_RD_ACS(value uint32) {
	volatile.StoreUint32(&o.CACHE_TAG_ACCESS_1.Reg, volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCACHE_TAG_ACCESS_1_PRO_I_TAG_RD_ACS() uint32 {
	return volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg) & 0x1
}
func (o *PMS_Type) SetCACHE_TAG_ACCESS_1_PRO_I_TAG_WR_ACS(value uint32) {
	volatile.StoreUint32(&o.CACHE_TAG_ACCESS_1.Reg, volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetCACHE_TAG_ACCESS_1_PRO_I_TAG_WR_ACS() uint32 {
	return (volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetCACHE_TAG_ACCESS_1_PRO_D_TAG_RD_ACS(value uint32) {
	volatile.StoreUint32(&o.CACHE_TAG_ACCESS_1.Reg, volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetCACHE_TAG_ACCESS_1_PRO_D_TAG_RD_ACS() uint32 {
	return (volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg) & 0x4) >> 2
}
func (o *PMS_Type) SetCACHE_TAG_ACCESS_1_PRO_D_TAG_WR_ACS(value uint32) {
	volatile.StoreUint32(&o.CACHE_TAG_ACCESS_1.Reg, volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg)&^(0x8)|value<<3)
}
func (o *PMS_Type) GetCACHE_TAG_ACCESS_1_PRO_D_TAG_WR_ACS() uint32 {
	return (volatile.LoadUint32(&o.CACHE_TAG_ACCESS_1.Reg) & 0x8) >> 3
}

// PMS.CACHE_MMU_ACCESS_0: Cache MMU permission control register 0.
func (o *PMS_Type) SetCACHE_MMU_ACCESS_0_CACHE_MMU_ACCESS_LOCK(value uint32) {
	volatile.StoreUint32(&o.CACHE_MMU_ACCESS_0.Reg, volatile.LoadUint32(&o.CACHE_MMU_ACCESS_0.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCACHE_MMU_ACCESS_0_CACHE_MMU_ACCESS_LOCK() uint32 {
	return volatile.LoadUint32(&o.CACHE_MMU_ACCESS_0.Reg) & 0x1
}

// PMS.CACHE_MMU_ACCESS_1: Cache MMU permission control register 1.
func (o *PMS_Type) SetCACHE_MMU_ACCESS_1_PRO_MMU_RD_ACS(value uint32) {
	volatile.StoreUint32(&o.CACHE_MMU_ACCESS_1.Reg, volatile.LoadUint32(&o.CACHE_MMU_ACCESS_1.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCACHE_MMU_ACCESS_1_PRO_MMU_RD_ACS() uint32 {
	return volatile.LoadUint32(&o.CACHE_MMU_ACCESS_1.Reg) & 0x1
}
func (o *PMS_Type) SetCACHE_MMU_ACCESS_1_PRO_MMU_WR_ACS(value uint32) {
	volatile.StoreUint32(&o.CACHE_MMU_ACCESS_1.Reg, volatile.LoadUint32(&o.CACHE_MMU_ACCESS_1.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetCACHE_MMU_ACCESS_1_PRO_MMU_WR_ACS() uint32 {
	return (volatile.LoadUint32(&o.CACHE_MMU_ACCESS_1.Reg) & 0x2) >> 1
}

// PMS.APB_PERIPHERAL_INTR: PeribBus2 permission control register.
func (o *PMS_Type) SetAPB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_CLR(value uint32) {
	volatile.StoreUint32(&o.APB_PERIPHERAL_INTR.Reg, volatile.LoadUint32(&o.APB_PERIPHERAL_INTR.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetAPB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_CLR() uint32 {
	return volatile.LoadUint32(&o.APB_PERIPHERAL_INTR.Reg) & 0x1
}
func (o *PMS_Type) SetAPB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.APB_PERIPHERAL_INTR.Reg, volatile.LoadUint32(&o.APB_PERIPHERAL_INTR.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetAPB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_PERIPHERAL_INTR.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetAPB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_INTR(value uint32) {
	volatile.StoreUint32(&o.APB_PERIPHERAL_INTR.Reg, volatile.LoadUint32(&o.APB_PERIPHERAL_INTR.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetAPB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_INTR() uint32 {
	return (volatile.LoadUint32(&o.APB_PERIPHERAL_INTR.Reg) & 0x4) >> 2
}

// PMS.APB_PERIPHERAL_STATUS: PeribBus2 peripheral access status register.
func (o *PMS_Type) SetAPB_PERIPHERAL_STATUS(value uint32) {
	volatile.StoreUint32(&o.APB_PERIPHERAL_STATUS.Reg, value)
}
func (o *PMS_Type) GetAPB_PERIPHERAL_STATUS() uint32 {
	return volatile.LoadUint32(&o.APB_PERIPHERAL_STATUS.Reg)
}

// PMS.CPU_PERIPHERAL_INTR: PeribBus1 permission control register.
func (o *PMS_Type) SetCPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_CLR(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIPHERAL_INTR.Reg, volatile.LoadUint32(&o.CPU_PERIPHERAL_INTR.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_CLR() uint32 {
	return volatile.LoadUint32(&o.CPU_PERIPHERAL_INTR.Reg) & 0x1
}
func (o *PMS_Type) SetCPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_EN(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIPHERAL_INTR.Reg, volatile.LoadUint32(&o.CPU_PERIPHERAL_INTR.Reg)&^(0x2)|value<<1)
}
func (o *PMS_Type) GetCPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_EN() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIPHERAL_INTR.Reg) & 0x2) >> 1
}
func (o *PMS_Type) SetCPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_INTR(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIPHERAL_INTR.Reg, volatile.LoadUint32(&o.CPU_PERIPHERAL_INTR.Reg)&^(0x4)|value<<2)
}
func (o *PMS_Type) GetCPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_INTR() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIPHERAL_INTR.Reg) & 0x4) >> 2
}

// PMS.CPU_PERIPHERAL_STATUS: PeribBus1 peripheral access status register.
func (o *PMS_Type) SetCPU_PERIPHERAL_STATUS(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIPHERAL_STATUS.Reg, value)
}
func (o *PMS_Type) GetCPU_PERIPHERAL_STATUS() uint32 {
	return volatile.LoadUint32(&o.CPU_PERIPHERAL_STATUS.Reg)
}

// PMS.CLOCK_GATE: Clock gate register of permission control.
func (o *PMS_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *PMS_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// PMS.DATE: Version control register.
func (o *PMS_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *PMS_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Remote Control
type RMT_Type struct {
	CH0DATA           volatile.Register32 // 0x0
	CH1DATA           volatile.Register32 // 0x4
	CH2DATA           volatile.Register32 // 0x8
	CH3DATA           volatile.Register32 // 0xC
	CH0CONF0          volatile.Register32 // 0x10
	CH0CONF1          volatile.Register32 // 0x14
	CH1CONF0          volatile.Register32 // 0x18
	CH1CONF1          volatile.Register32 // 0x1C
	CH2CONF0          volatile.Register32 // 0x20
	CH2CONF1          volatile.Register32 // 0x24
	CH3CONF0          volatile.Register32 // 0x28
	CH3CONF1          volatile.Register32 // 0x2C
	CH0STATUS         volatile.Register32 // 0x30
	CH1STATUS         volatile.Register32 // 0x34
	CH2STATUS         volatile.Register32 // 0x38
	CH3STATUS         volatile.Register32 // 0x3C
	CH0ADDR           volatile.Register32 // 0x40
	CH1ADDR           volatile.Register32 // 0x44
	CH2ADDR           volatile.Register32 // 0x48
	CH3ADDR           volatile.Register32 // 0x4C
	INT_RAW           volatile.Register32 // 0x50
	INT_ST            volatile.Register32 // 0x54
	INT_ENA           volatile.Register32 // 0x58
	INT_CLR           volatile.Register32 // 0x5C
	CH0CARRIER_DUTY   volatile.Register32 // 0x60
	CH1CARRIER_DUTY   volatile.Register32 // 0x64
	CH2CARRIER_DUTY   volatile.Register32 // 0x68
	CH3CARRIER_DUTY   volatile.Register32 // 0x6C
	CH0_TX_LIM        volatile.Register32 // 0x70
	CH1_TX_LIM        volatile.Register32 // 0x74
	CH2_TX_LIM        volatile.Register32 // 0x78
	CH3_TX_LIM        volatile.Register32 // 0x7C
	APB_CONF          volatile.Register32 // 0x80
	TX_SIM            volatile.Register32 // 0x84
	REF_CNT_RST       volatile.Register32 // 0x88
	CH0_RX_CARRIER_RM volatile.Register32 // 0x8C
	CH1_RX_CARRIER_RM volatile.Register32 // 0x90
	CH2_RX_CARRIER_RM volatile.Register32 // 0x94
	CH3_RX_CARRIER_RM volatile.Register32 // 0x98
	_                 [96]byte
	DATE              volatile.Register32 // 0xFC
}

// RMT.CH0DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH0DATA(value uint32) {
	volatile.StoreUint32(&o.CH0DATA.Reg, value)
}
func (o *RMT_Type) GetCH0DATA() uint32 {
	return volatile.LoadUint32(&o.CH0DATA.Reg)
}

// RMT.CH1DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH1DATA(value uint32) {
	volatile.StoreUint32(&o.CH1DATA.Reg, value)
}
func (o *RMT_Type) GetCH1DATA() uint32 {
	return volatile.LoadUint32(&o.CH1DATA.Reg)
}

// RMT.CH2DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH2DATA(value uint32) {
	volatile.StoreUint32(&o.CH2DATA.Reg, value)
}
func (o *RMT_Type) GetCH2DATA() uint32 {
	return volatile.LoadUint32(&o.CH2DATA.Reg)
}

// RMT.CH3DATA: The read and write data register for CHANNEL%s by apb fifo access.
func (o *RMT_Type) SetCH3DATA(value uint32) {
	volatile.StoreUint32(&o.CH3DATA.Reg, value)
}
func (o *RMT_Type) GetCH3DATA() uint32 {
	return volatile.LoadUint32(&o.CH3DATA.Reg)
}

// RMT.CH0CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH0CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH0CONF0_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.CH0CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH0CONF0_IDLE_THRES(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH0CONF0_IDLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH0CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH0CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH0CONF0_CARRIER_EFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH0CONF0_CARRIER_EFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH0CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH0CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH0CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH0CONF0.Reg, volatile.LoadUint32(&o.CH0CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH0CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH0CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH0CONF1_TX_START(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH0CONF1_TX_START() uint32 {
	return volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH0CONF1_RX_EN(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH0CONF1_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH0CONF1_MEM_WR_RST(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH0CONF1_MEM_WR_RST() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH0CONF1_MEM_RD_RST(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH0CONF1_MEM_RD_RST() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH0CONF1_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH0CONF1_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH0CONF1_MEM_OWNER(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH0CONF1_MEM_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH0CONF1_TX_CONTI_MODE(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH0CONF1_TX_CONTI_MODE() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH0CONF1_RX_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH0CONF1_RX_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH0CONF1_RX_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH0CONF1_RX_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH0CONF1_CHK_RX_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH0CONF1_CHK_RX_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH0CONF1_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH0CONF1_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH0CONF1_IDLE_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH0CONF1_IDLE_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH0CONF1_IDLE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH0CONF1_IDLE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH0CONF1_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.CH0CONF1.Reg, volatile.LoadUint32(&o.CH0CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH0CONF1_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.CH0CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH1CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH1CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH1CONF0_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.CH1CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH1CONF0_IDLE_THRES(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH1CONF0_IDLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH1CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH1CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH1CONF0_CARRIER_EFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH1CONF0_CARRIER_EFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH1CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH1CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH1CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH1CONF0.Reg, volatile.LoadUint32(&o.CH1CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH1CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH1CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH1CONF1_TX_START(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH1CONF1_TX_START() uint32 {
	return volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH1CONF1_RX_EN(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH1CONF1_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH1CONF1_MEM_WR_RST(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH1CONF1_MEM_WR_RST() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH1CONF1_MEM_RD_RST(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH1CONF1_MEM_RD_RST() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH1CONF1_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH1CONF1_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH1CONF1_MEM_OWNER(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH1CONF1_MEM_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH1CONF1_TX_CONTI_MODE(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH1CONF1_TX_CONTI_MODE() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH1CONF1_RX_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH1CONF1_RX_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH1CONF1_RX_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH1CONF1_RX_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH1CONF1_CHK_RX_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH1CONF1_CHK_RX_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH1CONF1_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH1CONF1_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH1CONF1_IDLE_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH1CONF1_IDLE_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH1CONF1_IDLE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH1CONF1_IDLE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH1CONF1_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.CH1CONF1.Reg, volatile.LoadUint32(&o.CH1CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH1CONF1_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.CH1CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH2CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH2CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH2CONF0_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.CH2CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH2CONF0_IDLE_THRES(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH2CONF0_IDLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH2CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH2CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH2CONF0_CARRIER_EFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH2CONF0_CARRIER_EFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH2CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH2CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH2CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH2CONF0.Reg, volatile.LoadUint32(&o.CH2CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH2CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH2CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH2CONF1_TX_START(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH2CONF1_TX_START() uint32 {
	return volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH2CONF1_RX_EN(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH2CONF1_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH2CONF1_MEM_WR_RST(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH2CONF1_MEM_WR_RST() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH2CONF1_MEM_RD_RST(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH2CONF1_MEM_RD_RST() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH2CONF1_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH2CONF1_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH2CONF1_MEM_OWNER(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH2CONF1_MEM_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH2CONF1_TX_CONTI_MODE(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH2CONF1_TX_CONTI_MODE() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH2CONF1_RX_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH2CONF1_RX_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH2CONF1_RX_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH2CONF1_RX_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH2CONF1_CHK_RX_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH2CONF1_CHK_RX_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH2CONF1_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH2CONF1_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH2CONF1_IDLE_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH2CONF1_IDLE_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH2CONF1_IDLE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH2CONF1_IDLE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH2CONF1_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.CH2CONF1.Reg, volatile.LoadUint32(&o.CH2CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH2CONF1_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.CH2CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH3CONF0: Channel %s configure register 0
func (o *RMT_Type) SetCH3CONF0_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0xff)|value)
}
func (o *RMT_Type) GetCH3CONF0_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.CH3CONF0.Reg) & 0xff
}
func (o *RMT_Type) SetCH3CONF0_IDLE_THRES(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0xffff00)|value<<8)
}
func (o *RMT_Type) GetCH3CONF0_IDLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0xffff00) >> 8
}
func (o *RMT_Type) SetCH3CONF0_MEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x7000000)|value<<24)
}
func (o *RMT_Type) GetCH3CONF0_MEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x7000000) >> 24
}
func (o *RMT_Type) SetCH3CONF0_CARRIER_EFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH3CONF0_CARRIER_EFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x8000000) >> 27
}
func (o *RMT_Type) SetCH3CONF0_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *RMT_Type) GetCH3CONF0_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x10000000) >> 28
}
func (o *RMT_Type) SetCH3CONF0_CARRIER_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH3CONF0.Reg, volatile.LoadUint32(&o.CH3CONF0.Reg)&^(0x20000000)|value<<29)
}
func (o *RMT_Type) GetCH3CONF0_CARRIER_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF0.Reg) & 0x20000000) >> 29
}

// RMT.CH3CONF1: Channel %s configure register 1
func (o *RMT_Type) SetCH3CONF1_TX_START(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetCH3CONF1_TX_START() uint32 {
	return volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x1
}
func (o *RMT_Type) SetCH3CONF1_RX_EN(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetCH3CONF1_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetCH3CONF1_MEM_WR_RST(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetCH3CONF1_MEM_WR_RST() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetCH3CONF1_MEM_RD_RST(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetCH3CONF1_MEM_RD_RST() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetCH3CONF1_APB_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetCH3CONF1_APB_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetCH3CONF1_MEM_OWNER(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x20)|value<<5)
}
func (o *RMT_Type) GetCH3CONF1_MEM_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x20) >> 5
}
func (o *RMT_Type) SetCH3CONF1_TX_CONTI_MODE(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x40)|value<<6)
}
func (o *RMT_Type) GetCH3CONF1_TX_CONTI_MODE() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x40) >> 6
}
func (o *RMT_Type) SetCH3CONF1_RX_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x80)|value<<7)
}
func (o *RMT_Type) GetCH3CONF1_RX_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x80) >> 7
}
func (o *RMT_Type) SetCH3CONF1_RX_FILTER_THRES(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *RMT_Type) GetCH3CONF1_RX_FILTER_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0xff00) >> 8
}
func (o *RMT_Type) SetCH3CONF1_CHK_RX_CARRIER_EN(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetCH3CONF1_CHK_RX_CARRIER_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x10000) >> 16
}
func (o *RMT_Type) SetCH3CONF1_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x20000)|value<<17)
}
func (o *RMT_Type) GetCH3CONF1_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x20000) >> 17
}
func (o *RMT_Type) SetCH3CONF1_IDLE_OUT_LV(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x40000)|value<<18)
}
func (o *RMT_Type) GetCH3CONF1_IDLE_OUT_LV() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x40000) >> 18
}
func (o *RMT_Type) SetCH3CONF1_IDLE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH3CONF1_IDLE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH3CONF1_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.CH3CONF1.Reg, volatile.LoadUint32(&o.CH3CONF1.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH3CONF1_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.CH3CONF1.Reg) & 0x100000) >> 20
}

// RMT.CH0STATUS: Channel %s status register
func (o *RMT_Type) SetCH0STATUS_MEM_WADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0STATUS_MEM_WADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0STATUS_MEM_RADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH0STATUS_MEM_RADDR_EX() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH0STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH0STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH0STATUS_MEM_OWNER_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH0STATUS_MEM_OWNER_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH0STATUS_MEM_FULL(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH0STATUS_MEM_FULL() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH0STATUS_MEM_EMPTY(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH0STATUS_MEM_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH0STATUS_APB_MEM_WR_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH0STATUS_APB_MEM_WR_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH0STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH0STATUS.Reg, volatile.LoadUint32(&o.CH0STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH0STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH0STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH1STATUS: Channel %s status register
func (o *RMT_Type) SetCH1STATUS_MEM_WADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1STATUS_MEM_WADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1STATUS_MEM_RADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH1STATUS_MEM_RADDR_EX() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH1STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH1STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH1STATUS_MEM_OWNER_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH1STATUS_MEM_OWNER_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH1STATUS_MEM_FULL(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH1STATUS_MEM_FULL() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH1STATUS_MEM_EMPTY(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH1STATUS_MEM_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH1STATUS_APB_MEM_WR_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH1STATUS_APB_MEM_WR_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH1STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH1STATUS.Reg, volatile.LoadUint32(&o.CH1STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH1STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH1STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH2STATUS: Channel %s status register
func (o *RMT_Type) SetCH2STATUS_MEM_WADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH2STATUS_MEM_WADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH2STATUS_MEM_RADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH2STATUS_MEM_RADDR_EX() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH2STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH2STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH2STATUS_MEM_OWNER_ERR(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH2STATUS_MEM_OWNER_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH2STATUS_MEM_FULL(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH2STATUS_MEM_FULL() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH2STATUS_MEM_EMPTY(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH2STATUS_MEM_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH2STATUS_APB_MEM_WR_ERR(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH2STATUS_APB_MEM_WR_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH2STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH2STATUS.Reg, volatile.LoadUint32(&o.CH2STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH2STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH2STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH3STATUS: Channel %s status register
func (o *RMT_Type) SetCH3STATUS_MEM_WADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH3STATUS_MEM_WADDR_EX() uint32 {
	return volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH3STATUS_MEM_RADDR_EX(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH3STATUS_MEM_RADDR_EX() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x7fc00) >> 10
}
func (o *RMT_Type) SetCH3STATUS_STATE(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x700000)|value<<20)
}
func (o *RMT_Type) GetCH3STATUS_STATE() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x700000) >> 20
}
func (o *RMT_Type) SetCH3STATUS_MEM_OWNER_ERR(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *RMT_Type) GetCH3STATUS_MEM_OWNER_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x800000) >> 23
}
func (o *RMT_Type) SetCH3STATUS_MEM_FULL(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *RMT_Type) GetCH3STATUS_MEM_FULL() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x1000000) >> 24
}
func (o *RMT_Type) SetCH3STATUS_MEM_EMPTY(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *RMT_Type) GetCH3STATUS_MEM_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x2000000) >> 25
}
func (o *RMT_Type) SetCH3STATUS_APB_MEM_WR_ERR(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *RMT_Type) GetCH3STATUS_APB_MEM_WR_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x4000000) >> 26
}
func (o *RMT_Type) SetCH3STATUS_APB_MEM_RD_ERR(value uint32) {
	volatile.StoreUint32(&o.CH3STATUS.Reg, volatile.LoadUint32(&o.CH3STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *RMT_Type) GetCH3STATUS_APB_MEM_RD_ERR() uint32 {
	return (volatile.LoadUint32(&o.CH3STATUS.Reg) & 0x8000000) >> 27
}

// RMT.CH0ADDR: Channel %s address register
func (o *RMT_Type) SetCH0ADDR_APB_MEM_WADDR(value uint32) {
	volatile.StoreUint32(&o.CH0ADDR.Reg, volatile.LoadUint32(&o.CH0ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0ADDR_APB_MEM_WADDR() uint32 {
	return volatile.LoadUint32(&o.CH0ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0ADDR_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH0ADDR.Reg, volatile.LoadUint32(&o.CH0ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH0ADDR_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH0ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.CH1ADDR: Channel %s address register
func (o *RMT_Type) SetCH1ADDR_APB_MEM_WADDR(value uint32) {
	volatile.StoreUint32(&o.CH1ADDR.Reg, volatile.LoadUint32(&o.CH1ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1ADDR_APB_MEM_WADDR() uint32 {
	return volatile.LoadUint32(&o.CH1ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1ADDR_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH1ADDR.Reg, volatile.LoadUint32(&o.CH1ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH1ADDR_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH1ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.CH2ADDR: Channel %s address register
func (o *RMT_Type) SetCH2ADDR_APB_MEM_WADDR(value uint32) {
	volatile.StoreUint32(&o.CH2ADDR.Reg, volatile.LoadUint32(&o.CH2ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH2ADDR_APB_MEM_WADDR() uint32 {
	return volatile.LoadUint32(&o.CH2ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH2ADDR_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH2ADDR.Reg, volatile.LoadUint32(&o.CH2ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH2ADDR_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH2ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.CH3ADDR: Channel %s address register
func (o *RMT_Type) SetCH3ADDR_APB_MEM_WADDR(value uint32) {
	volatile.StoreUint32(&o.CH3ADDR.Reg, volatile.LoadUint32(&o.CH3ADDR.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH3ADDR_APB_MEM_WADDR() uint32 {
	return volatile.LoadUint32(&o.CH3ADDR.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH3ADDR_APB_MEM_RADDR(value uint32) {
	volatile.StoreUint32(&o.CH3ADDR.Reg, volatile.LoadUint32(&o.CH3ADDR.Reg)&^(0x7fc00)|value<<10)
}
func (o *RMT_Type) GetCH3ADDR_APB_MEM_RADDR() uint32 {
	return (volatile.LoadUint32(&o.CH3ADDR.Reg) & 0x7fc00) >> 10
}

// RMT.INT_RAW: Raw interrupt status
func (o *RMT_Type) SetINT_RAW_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *RMT_Type) SetINT_RAW_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_RAW_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_RAW_CH_s_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_RAW_CH_s_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_RAW_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_RAW_CH_s_TX_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_RAW_CH_s_TX_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}

// RMT.INT_ST: Masked interrupt status
func (o *RMT_Type) SetINT_ST_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_ST_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *RMT_Type) SetINT_ST_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_ST_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_ST_CH_s_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_ST_CH_s_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_ST_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_ST_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_ST_CH_s_TX_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_ST_CH_s_TX_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}

// RMT.INT_ENA: Interrupt enable bits
func (o *RMT_Type) SetINT_ENA_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_ENA_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *RMT_Type) SetINT_ENA_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_ENA_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_ENA_CH_s_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_ENA_CH_s_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_ENA_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_ENA_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_ENA_CH_s_TX_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_ENA_CH_s_TX_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}

// RMT.INT_CLR: Interrupt clear bits
func (o *RMT_Type) SetINT_CLR_CH_s_TX_END(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_END() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *RMT_Type) SetINT_CLR_CH_s_RX_END(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetINT_CLR_CH_s_RX_END() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetINT_CLR_CH_s_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetINT_CLR_CH_s_ERR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetINT_CLR_CH_s_TX_THR_EVENT(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_THR_EVENT() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *RMT_Type) SetINT_CLR_CH_s_TX_LOOP(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *RMT_Type) GetINT_CLR_CH_s_TX_LOOP() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}

// RMT.CH0CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH0CARRIER_DUTY_CARRIER_LOW(value uint32) {
	volatile.StoreUint32(&o.CH0CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH0CARRIER_DUTY_CARRIER_LOW() uint32 {
	return volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH0CARRIER_DUTY_CARRIER_HIGH(value uint32) {
	volatile.StoreUint32(&o.CH0CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH0CARRIER_DUTY_CARRIER_HIGH() uint32 {
	return (volatile.LoadUint32(&o.CH0CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH1CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH1CARRIER_DUTY_CARRIER_LOW(value uint32) {
	volatile.StoreUint32(&o.CH1CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH1CARRIER_DUTY_CARRIER_LOW() uint32 {
	return volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH1CARRIER_DUTY_CARRIER_HIGH(value uint32) {
	volatile.StoreUint32(&o.CH1CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH1CARRIER_DUTY_CARRIER_HIGH() uint32 {
	return (volatile.LoadUint32(&o.CH1CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH2CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH2CARRIER_DUTY_CARRIER_LOW(value uint32) {
	volatile.StoreUint32(&o.CH2CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH2CARRIER_DUTY_CARRIER_LOW() uint32 {
	return volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH2CARRIER_DUTY_CARRIER_HIGH(value uint32) {
	volatile.StoreUint32(&o.CH2CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH2CARRIER_DUTY_CARRIER_HIGH() uint32 {
	return (volatile.LoadUint32(&o.CH2CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH3CARRIER_DUTY: Channel %s duty cycle configuration register
func (o *RMT_Type) SetCH3CARRIER_DUTY_CARRIER_LOW(value uint32) {
	volatile.StoreUint32(&o.CH3CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH3CARRIER_DUTY_CARRIER_LOW() uint32 {
	return volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg) & 0xffff
}
func (o *RMT_Type) SetCH3CARRIER_DUTY_CARRIER_HIGH(value uint32) {
	volatile.StoreUint32(&o.CH3CARRIER_DUTY.Reg, volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH3CARRIER_DUTY_CARRIER_HIGH() uint32 {
	return (volatile.LoadUint32(&o.CH3CARRIER_DUTY.Reg) & 0xffff0000) >> 16
}

// RMT.CH0_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH0_TX_LIM_TX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH0_TX_LIM_TX_LOOP_NUM(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LOOP_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH0_TX_LIM_TX_LOOP_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH0_TX_LIM_TX_LOOP_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH0_TX_LIM_LOOP_COUNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH0_TX_LIM.Reg, volatile.LoadUint32(&o.CH0_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH0_TX_LIM_LOOP_COUNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH0_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.CH1_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH1_TX_LIM_TX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH1_TX_LIM_TX_LOOP_NUM(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LOOP_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH1_TX_LIM_TX_LOOP_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH1_TX_LIM_TX_LOOP_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH1_TX_LIM_LOOP_COUNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH1_TX_LIM.Reg, volatile.LoadUint32(&o.CH1_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH1_TX_LIM_LOOP_COUNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH1_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.CH2_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH2_TX_LIM_TX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH2_TX_LIM_TX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH2_TX_LIM_TX_LOOP_NUM(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH2_TX_LIM_TX_LOOP_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH2_TX_LIM_TX_LOOP_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH2_TX_LIM_TX_LOOP_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH2_TX_LIM_LOOP_COUNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH2_TX_LIM.Reg, volatile.LoadUint32(&o.CH2_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH2_TX_LIM_LOOP_COUNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH2_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.CH3_TX_LIM: Channel %s Tx event configuration register
func (o *RMT_Type) SetCH3_TX_LIM_TX_LIM(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x1ff)|value)
}
func (o *RMT_Type) GetCH3_TX_LIM_TX_LIM() uint32 {
	return volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x1ff
}
func (o *RMT_Type) SetCH3_TX_LIM_TX_LOOP_NUM(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x7fe00)|value<<9)
}
func (o *RMT_Type) GetCH3_TX_LIM_TX_LOOP_NUM() uint32 {
	return (volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x7fe00) >> 9
}
func (o *RMT_Type) SetCH3_TX_LIM_TX_LOOP_CNT_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x80000)|value<<19)
}
func (o *RMT_Type) GetCH3_TX_LIM_TX_LOOP_CNT_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x80000) >> 19
}
func (o *RMT_Type) SetCH3_TX_LIM_LOOP_COUNT_RESET(value uint32) {
	volatile.StoreUint32(&o.CH3_TX_LIM.Reg, volatile.LoadUint32(&o.CH3_TX_LIM.Reg)&^(0x100000)|value<<20)
}
func (o *RMT_Type) GetCH3_TX_LIM_LOOP_COUNT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CH3_TX_LIM.Reg) & 0x100000) >> 20
}

// RMT.APB_CONF: RMT apb configuration register
func (o *RMT_Type) SetAPB_CONF_APB_FIFO_MASK(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetAPB_CONF_APB_FIFO_MASK() uint32 {
	return volatile.LoadUint32(&o.APB_CONF.Reg) & 0x1
}
func (o *RMT_Type) SetAPB_CONF_MEM_TX_WRAP_EN(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetAPB_CONF_MEM_TX_WRAP_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetAPB_CONF_MEM_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetAPB_CONF_MEM_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetAPB_CONF_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetAPB_CONF_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetAPB_CONF_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetAPB_CONF_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x10) >> 4
}
func (o *RMT_Type) SetAPB_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.APB_CONF.Reg, volatile.LoadUint32(&o.APB_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RMT_Type) GetAPB_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.APB_CONF.Reg) & 0x80000000) >> 31
}

// RMT.TX_SIM: RMT TX synchronous register
func (o *RMT_Type) SetTX_SIM_CH0(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetTX_SIM_CH0() uint32 {
	return volatile.LoadUint32(&o.TX_SIM.Reg) & 0x1
}
func (o *RMT_Type) SetTX_SIM_CH1(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetTX_SIM_CH1() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetTX_SIM_CH2(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetTX_SIM_CH2() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetTX_SIM_CH3(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetTX_SIM_CH3() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x8) >> 3
}
func (o *RMT_Type) SetTX_SIM_EN(value uint32) {
	volatile.StoreUint32(&o.TX_SIM.Reg, volatile.LoadUint32(&o.TX_SIM.Reg)&^(0x10)|value<<4)
}
func (o *RMT_Type) GetTX_SIM_EN() uint32 {
	return (volatile.LoadUint32(&o.TX_SIM.Reg) & 0x10) >> 4
}

// RMT.REF_CNT_RST: RMT clock divider reset register
func (o *RMT_Type) SetREF_CNT_RST_CH0(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x1)|value)
}
func (o *RMT_Type) GetREF_CNT_RST_CH0() uint32 {
	return volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x1
}
func (o *RMT_Type) SetREF_CNT_RST_CH1(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x2)|value<<1)
}
func (o *RMT_Type) GetREF_CNT_RST_CH1() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x2) >> 1
}
func (o *RMT_Type) SetREF_CNT_RST_CH2(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x4)|value<<2)
}
func (o *RMT_Type) GetREF_CNT_RST_CH2() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x4) >> 2
}
func (o *RMT_Type) SetREF_CNT_RST_CH3(value uint32) {
	volatile.StoreUint32(&o.REF_CNT_RST.Reg, volatile.LoadUint32(&o.REF_CNT_RST.Reg)&^(0x8)|value<<3)
}
func (o *RMT_Type) GetREF_CNT_RST_CH3() uint32 {
	return (volatile.LoadUint32(&o.REF_CNT_RST.Reg) & 0x8) >> 3
}

// RMT.CH0_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH0_RX_CARRIER_RM_CARRIER_LOW_THRES(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH0_RX_CARRIER_RM_CARRIER_LOW_THRES() uint32 {
	return volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH0_RX_CARRIER_RM_CARRIER_HIGH_THRES(value uint32) {
	volatile.StoreUint32(&o.CH0_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH0_RX_CARRIER_RM_CARRIER_HIGH_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH0_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH1_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH1_RX_CARRIER_RM_CARRIER_LOW_THRES(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH1_RX_CARRIER_RM_CARRIER_LOW_THRES() uint32 {
	return volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH1_RX_CARRIER_RM_CARRIER_HIGH_THRES(value uint32) {
	volatile.StoreUint32(&o.CH1_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH1_RX_CARRIER_RM_CARRIER_HIGH_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH1_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH2_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH2_RX_CARRIER_RM_CARRIER_LOW_THRES(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH2_RX_CARRIER_RM_CARRIER_LOW_THRES() uint32 {
	return volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH2_RX_CARRIER_RM_CARRIER_HIGH_THRES(value uint32) {
	volatile.StoreUint32(&o.CH2_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH2_RX_CARRIER_RM_CARRIER_HIGH_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH2_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.CH3_RX_CARRIER_RM: Channel %s carrier remove register
func (o *RMT_Type) SetCH3_RX_CARRIER_RM_CARRIER_LOW_THRES(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg)&^(0xffff)|value)
}
func (o *RMT_Type) GetCH3_RX_CARRIER_RM_CARRIER_LOW_THRES() uint32 {
	return volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg) & 0xffff
}
func (o *RMT_Type) SetCH3_RX_CARRIER_RM_CARRIER_HIGH_THRES(value uint32) {
	volatile.StoreUint32(&o.CH3_RX_CARRIER_RM.Reg, volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg)&^(0xffff0000)|value<<16)
}
func (o *RMT_Type) GetCH3_RX_CARRIER_RM_CARRIER_HIGH_THRES() uint32 {
	return (volatile.LoadUint32(&o.CH3_RX_CARRIER_RM.Reg) & 0xffff0000) >> 16
}

// RMT.DATE: RMT version register
func (o *RMT_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *RMT_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Hardware Random Number Generator
type RNG_Type struct {
	_    [272]byte
	DATA volatile.Register32 // 0x110
}

// RSA (Rivest Shamir Adleman) Accelerator
type RSA_Type struct {
	M_MEM           [512]volatile.Register8 // 0x0
	Z_MEM           [512]volatile.Register8 // 0x200
	Y_MEM           [512]volatile.Register8 // 0x400
	X_MEM           [512]volatile.Register8 // 0x600
	M_PRIME         volatile.Register32     // 0x800
	MODE            volatile.Register32     // 0x804
	CLEAN           volatile.Register32     // 0x808
	MODEXP_START    volatile.Register32     // 0x80C
	MODMULT_START   volatile.Register32     // 0x810
	MULT_START      volatile.Register32     // 0x814
	IDLE            volatile.Register32     // 0x818
	CLEAR_INTERRUPT volatile.Register32     // 0x81C
	CONSTANT_TIME   volatile.Register32     // 0x820
	SEARCH_ENABLE   volatile.Register32     // 0x824
	SEARCH_POS      volatile.Register32     // 0x828
	INTERRUPT_ENA   volatile.Register32     // 0x82C
	DATE            volatile.Register32     // 0x830
}

// RSA.M_PRIME: Register to store M'
func (o *RSA_Type) SetM_PRIME(value uint32) {
	volatile.StoreUint32(&o.M_PRIME.Reg, value)
}
func (o *RSA_Type) GetM_PRIME() uint32 {
	return volatile.LoadUint32(&o.M_PRIME.Reg)
}

// RSA.MODE: RSA length mode
func (o *RSA_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7f)|value)
}
func (o *RSA_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7f
}

// RSA.CLEAN: RSA clean register
func (o *RSA_Type) SetCLEAN(value uint32) {
	volatile.StoreUint32(&o.CLEAN.Reg, volatile.LoadUint32(&o.CLEAN.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCLEAN() uint32 {
	return volatile.LoadUint32(&o.CLEAN.Reg) & 0x1
}

// RSA.MODEXP_START: Modular exponentiation starting bit
func (o *RSA_Type) SetMODEXP_START(value uint32) {
	volatile.StoreUint32(&o.MODEXP_START.Reg, volatile.LoadUint32(&o.MODEXP_START.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetMODEXP_START() uint32 {
	return volatile.LoadUint32(&o.MODEXP_START.Reg) & 0x1
}

// RSA.MODMULT_START: Modular multiplication starting bit
func (o *RSA_Type) SetMODMULT_START(value uint32) {
	volatile.StoreUint32(&o.MODMULT_START.Reg, volatile.LoadUint32(&o.MODMULT_START.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetMODMULT_START() uint32 {
	return volatile.LoadUint32(&o.MODMULT_START.Reg) & 0x1
}

// RSA.MULT_START: Normal multiplication starting bit
func (o *RSA_Type) SetMULT_START(value uint32) {
	volatile.StoreUint32(&o.MULT_START.Reg, volatile.LoadUint32(&o.MULT_START.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetMULT_START() uint32 {
	return volatile.LoadUint32(&o.MULT_START.Reg) & 0x1
}

// RSA.IDLE: RSA idle register
func (o *RSA_Type) SetIDLE(value uint32) {
	volatile.StoreUint32(&o.IDLE.Reg, volatile.LoadUint32(&o.IDLE.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetIDLE() uint32 {
	return volatile.LoadUint32(&o.IDLE.Reg) & 0x1
}

// RSA.CLEAR_INTERRUPT: RSA clear interrupt register
func (o *RSA_Type) SetCLEAR_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.CLEAR_INTERRUPT.Reg, volatile.LoadUint32(&o.CLEAR_INTERRUPT.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCLEAR_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.CLEAR_INTERRUPT.Reg) & 0x1
}

// RSA.CONSTANT_TIME: The constant_time option
func (o *RSA_Type) SetCONSTANT_TIME(value uint32) {
	volatile.StoreUint32(&o.CONSTANT_TIME.Reg, volatile.LoadUint32(&o.CONSTANT_TIME.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetCONSTANT_TIME() uint32 {
	return volatile.LoadUint32(&o.CONSTANT_TIME.Reg) & 0x1
}

// RSA.SEARCH_ENABLE: The search option
func (o *RSA_Type) SetSEARCH_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SEARCH_ENABLE.Reg, volatile.LoadUint32(&o.SEARCH_ENABLE.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetSEARCH_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SEARCH_ENABLE.Reg) & 0x1
}

// RSA.SEARCH_POS: The search position
func (o *RSA_Type) SetSEARCH_POS(value uint32) {
	volatile.StoreUint32(&o.SEARCH_POS.Reg, volatile.LoadUint32(&o.SEARCH_POS.Reg)&^(0xfff)|value)
}
func (o *RSA_Type) GetSEARCH_POS() uint32 {
	return volatile.LoadUint32(&o.SEARCH_POS.Reg) & 0xfff
}

// RSA.INTERRUPT_ENA: RSA interrupt enable register
func (o *RSA_Type) SetINTERRUPT_ENA(value uint32) {
	volatile.StoreUint32(&o.INTERRUPT_ENA.Reg, volatile.LoadUint32(&o.INTERRUPT_ENA.Reg)&^(0x1)|value)
}
func (o *RSA_Type) GetINTERRUPT_ENA() uint32 {
	return volatile.LoadUint32(&o.INTERRUPT_ENA.Reg) & 0x1
}

// RSA.DATE: Version control register
func (o *RSA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *RSA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Low-power Input/Output
type RTCIO_Type struct {
	RTC_GPIO_OUT         volatile.Register32 // 0x0
	RTC_GPIO_OUT_W1TS    volatile.Register32 // 0x4
	RTC_GPIO_OUT_W1TC    volatile.Register32 // 0x8
	RTC_GPIO_ENABLE      volatile.Register32 // 0xC
	RTC_GPIO_ENABLE_W1TS volatile.Register32 // 0x10
	ENABLE_W1TC          volatile.Register32 // 0x14
	RTC_GPIO_STATUS      volatile.Register32 // 0x18
	RTC_GPIO_STATUS_W1TS volatile.Register32 // 0x1C
	RTC_GPIO_STATUS_W1TC volatile.Register32 // 0x20
	RTC_GPIO_IN          volatile.Register32 // 0x24
	PIN0                 volatile.Register32 // 0x28
	PIN1                 volatile.Register32 // 0x2C
	PIN2                 volatile.Register32 // 0x30
	PIN3                 volatile.Register32 // 0x34
	PIN4                 volatile.Register32 // 0x38
	PIN5                 volatile.Register32 // 0x3C
	PIN6                 volatile.Register32 // 0x40
	PIN7                 volatile.Register32 // 0x44
	PIN8                 volatile.Register32 // 0x48
	PIN9                 volatile.Register32 // 0x4C
	PIN10                volatile.Register32 // 0x50
	PIN11                volatile.Register32 // 0x54
	PIN12                volatile.Register32 // 0x58
	PIN13                volatile.Register32 // 0x5C
	PIN14                volatile.Register32 // 0x60
	PIN15                volatile.Register32 // 0x64
	PIN16                volatile.Register32 // 0x68
	PIN17                volatile.Register32 // 0x6C
	PIN18                volatile.Register32 // 0x70
	PIN19                volatile.Register32 // 0x74
	PIN20                volatile.Register32 // 0x78
	PIN21                volatile.Register32 // 0x7C
	RTC_DEBUG_SEL        volatile.Register32 // 0x80
	TOUCH_PAD0           volatile.Register32 // 0x84
	TOUCH_PAD1           volatile.Register32 // 0x88
	TOUCH_PAD2           volatile.Register32 // 0x8C
	TOUCH_PAD3           volatile.Register32 // 0x90
	TOUCH_PAD4           volatile.Register32 // 0x94
	TOUCH_PAD5           volatile.Register32 // 0x98
	TOUCH_PAD6           volatile.Register32 // 0x9C
	TOUCH_PAD7           volatile.Register32 // 0xA0
	TOUCH_PAD8           volatile.Register32 // 0xA4
	TOUCH_PAD9           volatile.Register32 // 0xA8
	TOUCH_PAD10          volatile.Register32 // 0xAC
	TOUCH_PAD11          volatile.Register32 // 0xB0
	TOUCH_PAD12          volatile.Register32 // 0xB4
	TOUCH_PAD13          volatile.Register32 // 0xB8
	TOUCH_PAD14          volatile.Register32 // 0xBC
	XTAL_32P_PAD         volatile.Register32 // 0xC0
	XTAL_32N_PAD         volatile.Register32 // 0xC4
	PAD_DAC1             volatile.Register32 // 0xC8
	PAD_DAC2             volatile.Register32 // 0xCC
	RTC_PAD19            volatile.Register32 // 0xD0
	RTC_PAD20            volatile.Register32 // 0xD4
	RTC_PAD21            volatile.Register32 // 0xD8
	EXT_WAKEUP0          volatile.Register32 // 0xDC
	XTL_EXT_CTR          volatile.Register32 // 0xE0
	SAR_I2C_IO           volatile.Register32 // 0xE4
	RTC_IO_TOUCH_CTRL    volatile.Register32 // 0xE8
	_                    [272]byte
	RTC_IO_DATE          volatile.Register32 // 0x1FC
}

// RTCIO.RTC_GPIO_OUT: RTC GPIO output register
func (o *RTCIO_Type) SetRTC_GPIO_OUT_GPIO_OUT_DATA(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_OUT.Reg, volatile.LoadUint32(&o.RTC_GPIO_OUT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_OUT_GPIO_OUT_DATA() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_OUT.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_OUT_W1TS: RTC GPIO output bit set register
func (o *RTCIO_Type) SetRTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_OUT_W1TS.Reg, volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_OUT_W1TC: RTC GPIO output bit clear register
func (o *RTCIO_Type) SetRTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_OUT_W1TC.Reg, volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TC.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_OUT_W1TC.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_ENABLE: RTC GPIO output enable register
func (o *RTCIO_Type) SetRTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_ENABLE.Reg, volatile.LoadUint32(&o.RTC_GPIO_ENABLE.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_ENABLE.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_ENABLE_W1TS: RTC GPIO output enable bit set register
func (o *RTCIO_Type) SetRTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_ENABLE_W1TS.Reg, volatile.LoadUint32(&o.RTC_GPIO_ENABLE_W1TS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_ENABLE_W1TS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.ENABLE_W1TC: RTC GPIO output enable bit clear register
func (o *RTCIO_Type) SetENABLE_W1TC(value uint32) {
	volatile.StoreUint32(&o.ENABLE_W1TC.Reg, volatile.LoadUint32(&o.ENABLE_W1TC.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetENABLE_W1TC() uint32 {
	return (volatile.LoadUint32(&o.ENABLE_W1TC.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_STATUS: RTC GPIO interrupt status register
func (o *RTCIO_Type) SetRTC_GPIO_STATUS_GPIO_STATUS_INT(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_STATUS.Reg, volatile.LoadUint32(&o.RTC_GPIO_STATUS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_STATUS_GPIO_STATUS_INT() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_STATUS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_STATUS_W1TS: RTC GPIO interrupt status bit set register
func (o *RTCIO_Type) SetRTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_STATUS_W1TS.Reg, volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TS.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TS.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_STATUS_W1TC: RTC GPIO interrupt status bit clear register
func (o *RTCIO_Type) SetRTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_STATUS_W1TC.Reg, volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TC.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_STATUS_W1TC.Reg) & 0xfffffc00) >> 10
}

// RTCIO.RTC_GPIO_IN: RTC GPIO input register
func (o *RTCIO_Type) SetRTC_GPIO_IN_GPIO_IN_NEXT(value uint32) {
	volatile.StoreUint32(&o.RTC_GPIO_IN.Reg, volatile.LoadUint32(&o.RTC_GPIO_IN.Reg)&^(0xfffffc00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_GPIO_IN_GPIO_IN_NEXT() uint32 {
	return (volatile.LoadUint32(&o.RTC_GPIO_IN.Reg) & 0xfffffc00) >> 10
}

// RTCIO.PIN0: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN0_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN0_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN0_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN0_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN0_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN0_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400) >> 10
}

// RTCIO.PIN1: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN1_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN1_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN1_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN1_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN1_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN1_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400) >> 10
}

// RTCIO.PIN2: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN2_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN2_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN2_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN2_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN2_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN2_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400) >> 10
}

// RTCIO.PIN3: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN3_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN3_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN3_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN3_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN3_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN3_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400) >> 10
}

// RTCIO.PIN4: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN4_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN4_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN4_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN4_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN4_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN4_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400) >> 10
}

// RTCIO.PIN5: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN5_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN5_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN5_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN5_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN5_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN5_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400) >> 10
}

// RTCIO.PIN6: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN6_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN6_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN6_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN6_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN6_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN6.Reg, volatile.LoadUint32(&o.PIN6.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN6_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN6.Reg) & 0x400) >> 10
}

// RTCIO.PIN7: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN7_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN7_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN7_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN7_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN7_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN7.Reg, volatile.LoadUint32(&o.PIN7.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN7_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN7.Reg) & 0x400) >> 10
}

// RTCIO.PIN8: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN8_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN8_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN8_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN8_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN8_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN8.Reg, volatile.LoadUint32(&o.PIN8.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN8_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN8.Reg) & 0x400) >> 10
}

// RTCIO.PIN9: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN9_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN9_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN9_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN9_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN9_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN9.Reg, volatile.LoadUint32(&o.PIN9.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN9_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN9.Reg) & 0x400) >> 10
}

// RTCIO.PIN10: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN10_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN10_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN10_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN10_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN10_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN10.Reg, volatile.LoadUint32(&o.PIN10.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN10_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN10.Reg) & 0x400) >> 10
}

// RTCIO.PIN11: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN11_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN11_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN11_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN11_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN11_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN11.Reg, volatile.LoadUint32(&o.PIN11.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN11_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN11.Reg) & 0x400) >> 10
}

// RTCIO.PIN12: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN12_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN12_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN12_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN12_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN12_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN12.Reg, volatile.LoadUint32(&o.PIN12.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN12_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN12.Reg) & 0x400) >> 10
}

// RTCIO.PIN13: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN13_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN13_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN13_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN13_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN13_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN13.Reg, volatile.LoadUint32(&o.PIN13.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN13_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN13.Reg) & 0x400) >> 10
}

// RTCIO.PIN14: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN14_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN14_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN14_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN14_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN14_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN14.Reg, volatile.LoadUint32(&o.PIN14.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN14_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN14.Reg) & 0x400) >> 10
}

// RTCIO.PIN15: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN15_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN15_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN15_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN15_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN15_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN15.Reg, volatile.LoadUint32(&o.PIN15.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN15_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN15.Reg) & 0x400) >> 10
}

// RTCIO.PIN16: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN16_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN16_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN16_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN16_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN16_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN16.Reg, volatile.LoadUint32(&o.PIN16.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN16_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN16.Reg) & 0x400) >> 10
}

// RTCIO.PIN17: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN17_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN17_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN17_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN17_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN17_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN17.Reg, volatile.LoadUint32(&o.PIN17.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN17_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN17.Reg) & 0x400) >> 10
}

// RTCIO.PIN18: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN18_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN18_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN18_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN18_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN18_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN18.Reg, volatile.LoadUint32(&o.PIN18.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN18_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN18.Reg) & 0x400) >> 10
}

// RTCIO.PIN19: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN19_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN19_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN19_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN19_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN19_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN19.Reg, volatile.LoadUint32(&o.PIN19.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN19_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN19.Reg) & 0x400) >> 10
}

// RTCIO.PIN20: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN20_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN20_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN20_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN20_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN20_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN20.Reg, volatile.LoadUint32(&o.PIN20.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN20_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN20.Reg) & 0x400) >> 10
}

// RTCIO.PIN21: RTC configuration for pin %s
func (o *RTCIO_Type) SetPIN21_PAD_DRIVER(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x4)|value<<2)
}
func (o *RTCIO_Type) GetPIN21_PAD_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x4) >> 2
}
func (o *RTCIO_Type) SetPIN21_GPIO_PIN_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x380)|value<<7)
}
func (o *RTCIO_Type) GetPIN21_GPIO_PIN_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x380) >> 7
}
func (o *RTCIO_Type) SetPIN21_GPIO_PIN_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PIN21.Reg, volatile.LoadUint32(&o.PIN21.Reg)&^(0x400)|value<<10)
}
func (o *RTCIO_Type) GetPIN21_GPIO_PIN_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PIN21.Reg) & 0x400) >> 10
}

// RTCIO.RTC_DEBUG_SEL: RTC debug select register
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL0(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x1f)|value)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL0() uint32 {
	return volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x1f
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL1(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x3e0)|value<<5)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL1() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x3e0) >> 5
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL2(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x7c00)|value<<10)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL2() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x7c00) >> 10
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL3(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0xf8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL3() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0xf8000) >> 15
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_SEL4(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x1f00000)|value<<20)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_SEL4() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x1f00000) >> 20
}
func (o *RTCIO_Type) SetRTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING(value uint32) {
	volatile.StoreUint32(&o.RTC_DEBUG_SEL.Reg, volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTCIO_Type) GetRTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING() uint32 {
	return (volatile.LoadUint32(&o.RTC_DEBUG_SEL.Reg) & 0x2000000) >> 25
}

// RTCIO.TOUCH_PAD0: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD0_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD0_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD0_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD0_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD0_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD0_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD0_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD0_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD0_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD0_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD0_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD0_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD0_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD0.Reg, volatile.LoadUint32(&o.TOUCH_PAD0.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD0_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD0.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD1: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD1_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD1_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD1_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD1_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD1_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD1_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD1_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD1_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD1_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD1_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD1_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD1.Reg, volatile.LoadUint32(&o.TOUCH_PAD1.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD1_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD1.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD2: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD2_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD2_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD2_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD2_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD2_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD2_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD2_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD2_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD2_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD2_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD2_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD2.Reg, volatile.LoadUint32(&o.TOUCH_PAD2.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD2_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD2.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD3: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD3_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD3_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD3_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD3_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD3_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD3_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD3_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD3_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD3_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD3_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD3_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD3_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD3_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD3.Reg, volatile.LoadUint32(&o.TOUCH_PAD3.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD3_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD3.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD4: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD4_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD4_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD4_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD4_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD4_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD4_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD4_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD4_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD4_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD4_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD4_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD4_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD4_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD4.Reg, volatile.LoadUint32(&o.TOUCH_PAD4.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD4_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD4.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD5: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD5_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD5_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD5_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD5_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD5_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD5_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD5_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD5_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD5_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD5_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD5_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD5_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD5_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD5.Reg, volatile.LoadUint32(&o.TOUCH_PAD5.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD5_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD5.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD6: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD6_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD6_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD6_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD6_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD6_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD6_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD6_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD6_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD6_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD6_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD6_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD6_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD6_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD6.Reg, volatile.LoadUint32(&o.TOUCH_PAD6.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD6_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD6.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD7: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD7_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD7_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD7_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD7_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD7_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD7_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD7_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD7_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD7_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD7_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD7_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD7_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD7_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD7.Reg, volatile.LoadUint32(&o.TOUCH_PAD7.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD7_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD7.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD8: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD8_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD8_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD8_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD8_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD8_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD8_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD8_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD8_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD8_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD8_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD8_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD8_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD8_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD8.Reg, volatile.LoadUint32(&o.TOUCH_PAD8.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD8_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD8.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD9: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD9_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD9_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD9_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD9_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD9_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD9_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD9_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD9_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD9_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD9_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD9_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD9_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD9_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD9.Reg, volatile.LoadUint32(&o.TOUCH_PAD9.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD9_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD9.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD10: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD10_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD10_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD10_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD10_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD10_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD10_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD10_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD10_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD10_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD10_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD10_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD10_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD10_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD10.Reg, volatile.LoadUint32(&o.TOUCH_PAD10.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD10_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD10.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD11: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD11_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD11_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD11_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD11_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD11_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD11_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD11_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD11_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD11_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD11_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD11_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD11_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD11_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD11.Reg, volatile.LoadUint32(&o.TOUCH_PAD11.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD11_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD11.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD12: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD12_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD12_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD12_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD12_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD12_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD12_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD12_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD12_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD12_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD12_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD12_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD12_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD12_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD12.Reg, volatile.LoadUint32(&o.TOUCH_PAD12.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD12_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD12.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD13: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD13_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD13_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD13_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD13_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD13_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD13_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD13_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD13_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD13_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD13_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD13_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD13_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD13_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD13.Reg, volatile.LoadUint32(&o.TOUCH_PAD13.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD13_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD13.Reg) & 0x60000000) >> 29
}

// RTCIO.TOUCH_PAD14: Touch pad %s configuration register
func (o *RTCIO_Type) SetTOUCH_PAD14_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetTOUCH_PAD14_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetTOUCH_PAD14_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetTOUCH_PAD14_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetTOUCH_PAD14_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetTOUCH_PAD14_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetTOUCH_PAD14_XPD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x100000)|value<<20)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_XPD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x100000) >> 20
}
func (o *RTCIO_Type) SetTOUCH_PAD14_TIE_OPT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x200000)|value<<21)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_TIE_OPT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x200000) >> 21
}
func (o *RTCIO_Type) SetTOUCH_PAD14_START(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x400000)|value<<22)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_START() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x400000) >> 22
}
func (o *RTCIO_Type) SetTOUCH_PAD14_DAC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x3800000)|value<<23)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_DAC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x3800000) >> 23
}
func (o *RTCIO_Type) SetTOUCH_PAD14_RUE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_RUE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetTOUCH_PAD14_RDE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_RDE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetTOUCH_PAD14_DRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_PAD14.Reg, volatile.LoadUint32(&o.TOUCH_PAD14.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetTOUCH_PAD14_DRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_PAD14.Reg) & 0x60000000) >> 29
}

// RTCIO.XTAL_32P_PAD: 32KHz crystal P-pad configuration register
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_RUE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_RUE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_RDE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_RDE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetXTAL_32P_PAD_X32P_DRV(value uint32) {
	volatile.StoreUint32(&o.XTAL_32P_PAD.Reg, volatile.LoadUint32(&o.XTAL_32P_PAD.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetXTAL_32P_PAD_X32P_DRV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32P_PAD.Reg) & 0x60000000) >> 29
}

// RTCIO.XTAL_32N_PAD: 32KHz crystal N-pad configuration register
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_RUE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_RUE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_RDE(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_RDE() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetXTAL_32N_PAD_X32N_DRV(value uint32) {
	volatile.StoreUint32(&o.XTAL_32N_PAD.Reg, volatile.LoadUint32(&o.XTAL_32N_PAD.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetXTAL_32N_PAD_X32N_DRV() uint32 {
	return (volatile.LoadUint32(&o.XTAL_32N_PAD.Reg) & 0x60000000) >> 29
}

// RTCIO.PAD_DAC1: DAC1 configuration register
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x7f8)|value<<3)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x7f8) >> 3
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_XPD_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x800)|value<<11)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_XPD_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x800) >> 11
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_DAC_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x1000)|value<<12)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_DAC_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x1000) >> 12
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_RUE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_RUE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_RDE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_RDE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetPAD_DAC1_PDAC1_DRV(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC1.Reg, volatile.LoadUint32(&o.PAD_DAC1.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetPAD_DAC1_PDAC1_DRV() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC1.Reg) & 0x60000000) >> 29
}

// RTCIO.PAD_DAC2: DAC2 configuration register
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x7f8)|value<<3)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x7f8) >> 3
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_XPD_DAC(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x800)|value<<11)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_XPD_DAC() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x800) >> 11
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_DAC_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x1000)|value<<12)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_DAC_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x1000) >> 12
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_RUE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_RUE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_RDE(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_RDE() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetPAD_DAC2_PDAC2_DRV(value uint32) {
	volatile.StoreUint32(&o.PAD_DAC2.Reg, volatile.LoadUint32(&o.PAD_DAC2.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetPAD_DAC2_PDAC2_DRV() uint32 {
	return (volatile.LoadUint32(&o.PAD_DAC2.Reg) & 0x60000000) >> 29
}

// RTCIO.RTC_PAD19: Touch pad 19 configuration register
func (o *RTCIO_Type) SetRTC_PAD19_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetRTC_PAD19_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetRTC_PAD19_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetRTC_PAD19_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetRTC_PAD19_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_PAD19_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetRTC_PAD19_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetRTC_PAD19_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetRTC_PAD19_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetRTC_PAD19_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetRTC_PAD19_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetRTC_PAD19_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetRTC_PAD19_RUE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetRTC_PAD19_RUE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetRTC_PAD19_RDE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetRTC_PAD19_RDE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetRTC_PAD19_DRV(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD19.Reg, volatile.LoadUint32(&o.RTC_PAD19.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetRTC_PAD19_DRV() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD19.Reg) & 0x60000000) >> 29
}

// RTCIO.RTC_PAD20: Touch pad 20 configuration register
func (o *RTCIO_Type) SetRTC_PAD20_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetRTC_PAD20_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetRTC_PAD20_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetRTC_PAD20_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetRTC_PAD20_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_PAD20_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetRTC_PAD20_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetRTC_PAD20_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetRTC_PAD20_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetRTC_PAD20_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetRTC_PAD20_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetRTC_PAD20_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetRTC_PAD20_RUE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetRTC_PAD20_RUE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetRTC_PAD20_RDE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetRTC_PAD20_RDE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetRTC_PAD20_DRV(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD20.Reg, volatile.LoadUint32(&o.RTC_PAD20.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetRTC_PAD20_DRV() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD20.Reg) & 0x60000000) >> 29
}

// RTCIO.RTC_PAD21: Touch pad 21 configuration register
func (o *RTCIO_Type) SetRTC_PAD21_FUN_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x2000)|value<<13)
}
func (o *RTCIO_Type) GetRTC_PAD21_FUN_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x2000) >> 13
}
func (o *RTCIO_Type) SetRTC_PAD21_SLP_OE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x4000)|value<<14)
}
func (o *RTCIO_Type) GetRTC_PAD21_SLP_OE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x4000) >> 14
}
func (o *RTCIO_Type) SetRTC_PAD21_SLP_IE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x8000)|value<<15)
}
func (o *RTCIO_Type) GetRTC_PAD21_SLP_IE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x8000) >> 15
}
func (o *RTCIO_Type) SetRTC_PAD21_SLP_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x10000)|value<<16)
}
func (o *RTCIO_Type) GetRTC_PAD21_SLP_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x10000) >> 16
}
func (o *RTCIO_Type) SetRTC_PAD21_FUN_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x60000)|value<<17)
}
func (o *RTCIO_Type) GetRTC_PAD21_FUN_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x60000) >> 17
}
func (o *RTCIO_Type) SetRTC_PAD21_MUX_SEL(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x80000)|value<<19)
}
func (o *RTCIO_Type) GetRTC_PAD21_MUX_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x80000) >> 19
}
func (o *RTCIO_Type) SetRTC_PAD21_RUE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x8000000)|value<<27)
}
func (o *RTCIO_Type) GetRTC_PAD21_RUE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x8000000) >> 27
}
func (o *RTCIO_Type) SetRTC_PAD21_RDE(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x10000000)|value<<28)
}
func (o *RTCIO_Type) GetRTC_PAD21_RDE() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x10000000) >> 28
}
func (o *RTCIO_Type) SetRTC_PAD21_DRV(value uint32) {
	volatile.StoreUint32(&o.RTC_PAD21.Reg, volatile.LoadUint32(&o.RTC_PAD21.Reg)&^(0x60000000)|value<<29)
}
func (o *RTCIO_Type) GetRTC_PAD21_DRV() uint32 {
	return (volatile.LoadUint32(&o.RTC_PAD21.Reg) & 0x60000000) >> 29
}

// RTCIO.EXT_WAKEUP0: External wake up configuration register
func (o *RTCIO_Type) SetEXT_WAKEUP0_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP0.Reg, volatile.LoadUint32(&o.EXT_WAKEUP0.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTCIO_Type) GetEXT_WAKEUP0_SEL() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP0.Reg) & 0xf8000000) >> 27
}

// RTCIO.XTL_EXT_CTR: Crystal power down enable GPIO source
func (o *RTCIO_Type) SetXTL_EXT_CTR_SEL(value uint32) {
	volatile.StoreUint32(&o.XTL_EXT_CTR.Reg, volatile.LoadUint32(&o.XTL_EXT_CTR.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTCIO_Type) GetXTL_EXT_CTR_SEL() uint32 {
	return (volatile.LoadUint32(&o.XTL_EXT_CTR.Reg) & 0xf8000000) >> 27
}

// RTCIO.SAR_I2C_IO: RTC I2C pad selection
func (o *RTCIO_Type) SetSAR_I2C_IO_SAR_DEBUG_BIT_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_IO.Reg, volatile.LoadUint32(&o.SAR_I2C_IO.Reg)&^(0xf800000)|value<<23)
}
func (o *RTCIO_Type) GetSAR_I2C_IO_SAR_DEBUG_BIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_IO.Reg) & 0xf800000) >> 23
}
func (o *RTCIO_Type) SetSAR_I2C_IO_SAR_I2C_SCL_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_IO.Reg, volatile.LoadUint32(&o.SAR_I2C_IO.Reg)&^(0x30000000)|value<<28)
}
func (o *RTCIO_Type) GetSAR_I2C_IO_SAR_I2C_SCL_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_IO.Reg) & 0x30000000) >> 28
}
func (o *RTCIO_Type) SetSAR_I2C_IO_SAR_I2C_SDA_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_IO.Reg, volatile.LoadUint32(&o.SAR_I2C_IO.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTCIO_Type) GetSAR_I2C_IO_SAR_I2C_SDA_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_IO.Reg) & 0xc0000000) >> 30
}

// RTCIO.RTC_IO_TOUCH_CTRL: Touch control register
func (o *RTCIO_Type) SetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL(value uint32) {
	volatile.StoreUint32(&o.RTC_IO_TOUCH_CTRL.Reg, volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg)&^(0xf)|value)
}
func (o *RTCIO_Type) GetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL() uint32 {
	return volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg) & 0xf
}
func (o *RTCIO_Type) SetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE(value uint32) {
	volatile.StoreUint32(&o.RTC_IO_TOUCH_CTRL.Reg, volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTCIO_Type) GetRTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE() uint32 {
	return (volatile.LoadUint32(&o.RTC_IO_TOUCH_CTRL.Reg) & 0x10) >> 4
}

// RTCIO.RTC_IO_DATE: Version control register
func (o *RTCIO_Type) SetRTC_IO_DATE_IO_DATE(value uint32) {
	volatile.StoreUint32(&o.RTC_IO_DATE.Reg, volatile.LoadUint32(&o.RTC_IO_DATE.Reg)&^(0xfffffff)|value)
}
func (o *RTCIO_Type) GetRTC_IO_DATE_IO_DATE() uint32 {
	return volatile.LoadUint32(&o.RTC_IO_DATE.Reg) & 0xfffffff
}

// Real-Time Clock Control
type RTC_CNTL_Type struct {
	OPTIONS0           volatile.Register32 // 0x0
	SLP_TIMER0         volatile.Register32 // 0x4
	SLP_TIMER1         volatile.Register32 // 0x8
	TIME_UPDATE        volatile.Register32 // 0xC
	TIME_LOW0          volatile.Register32 // 0x10
	TIME_HIGH0         volatile.Register32 // 0x14
	STATE0             volatile.Register32 // 0x18
	TIMER1             volatile.Register32 // 0x1C
	TIMER2             volatile.Register32 // 0x20
	TIMER3             volatile.Register32 // 0x24
	TIMER4             volatile.Register32 // 0x28
	TIMER5             volatile.Register32 // 0x2C
	TIMER6             volatile.Register32 // 0x30
	ANA_CONF           volatile.Register32 // 0x34
	RESET_STATE        volatile.Register32 // 0x38
	WAKEUP_STATE       volatile.Register32 // 0x3C
	INT_ENA_RTC        volatile.Register32 // 0x40
	INT_RAW_RTC        volatile.Register32 // 0x44
	INT_ST_RTC         volatile.Register32 // 0x48
	INT_CLR_RTC        volatile.Register32 // 0x4C
	STORE0             volatile.Register32 // 0x50
	STORE1             volatile.Register32 // 0x54
	STORE2             volatile.Register32 // 0x58
	STORE3             volatile.Register32 // 0x5C
	EXT_XTL_CONF       volatile.Register32 // 0x60
	EXT_WAKEUP_CONF    volatile.Register32 // 0x64
	SLP_REJECT_CONF    volatile.Register32 // 0x68
	CPU_PERIOD_CONF    volatile.Register32 // 0x6C
	SDIO_ACT_CONF      volatile.Register32 // 0x70
	CLK_CONF           volatile.Register32 // 0x74
	SLOW_CLK_CONF      volatile.Register32 // 0x78
	SDIO_CONF          volatile.Register32 // 0x7C
	BIAS_CONF          volatile.Register32 // 0x80
	REG                volatile.Register32 // 0x84
	PWC                volatile.Register32 // 0x88
	DIG_PWC            volatile.Register32 // 0x8C
	DIG_ISO            volatile.Register32 // 0x90
	WDTCONFIG0         volatile.Register32 // 0x94
	WDTCONFIG1         volatile.Register32 // 0x98
	WDTCONFIG2         volatile.Register32 // 0x9C
	WDTCONFIG3         volatile.Register32 // 0xA0
	WDTCONFIG4         volatile.Register32 // 0xA4
	WDTFEED            volatile.Register32 // 0xA8
	WDTWPROTECT        volatile.Register32 // 0xAC
	SWD_CONF           volatile.Register32 // 0xB0
	SWD_WPROTECT       volatile.Register32 // 0xB4
	SW_CPU_STALL       volatile.Register32 // 0xB8
	STORE4             volatile.Register32 // 0xBC
	STORE5             volatile.Register32 // 0xC0
	STORE6             volatile.Register32 // 0xC4
	STORE7             volatile.Register32 // 0xC8
	LOW_POWER_ST       volatile.Register32 // 0xCC
	DIAG0              volatile.Register32 // 0xD0
	PAD_HOLD           volatile.Register32 // 0xD4
	DIG_PAD_HOLD       volatile.Register32 // 0xD8
	EXT_WAKEUP1        volatile.Register32 // 0xDC
	EXT_WAKEUP1_STATUS volatile.Register32 // 0xE0
	BROWN_OUT          volatile.Register32 // 0xE4
	TIME_LOW1          volatile.Register32 // 0xE8
	TIME_HIGH1         volatile.Register32 // 0xEC
	XTAL32K_CLK_FACTOR volatile.Register32 // 0xF0
	XTAL32K_CONF       volatile.Register32 // 0xF4
	ULP_CP_TIMER       volatile.Register32 // 0xF8
	ULP_CP_CTRL        volatile.Register32 // 0xFC
	COCPU_CTRL         volatile.Register32 // 0x100
	TOUCH_CTRL1        volatile.Register32 // 0x104
	TOUCH_CTRL2        volatile.Register32 // 0x108
	TOUCH_SCAN_CTRL    volatile.Register32 // 0x10C
	TOUCH_SLP_THRES    volatile.Register32 // 0x110
	TOUCH_APPROACH     volatile.Register32 // 0x114
	TOUCH_FILTER_CTRL  volatile.Register32 // 0x118
	USB_CONF           volatile.Register32 // 0x11C
	TOUCH_TIMEOUT_CTRL volatile.Register32 // 0x120
	SLP_REJECT_CAUSE   volatile.Register32 // 0x124
	OPTIONS1           volatile.Register32 // 0x128
	SLP_WAKEUP_CAUSE   volatile.Register32 // 0x12C
	ULP_CP_TIMER_1     volatile.Register32 // 0x130
	_                  [4]byte
	DATE               volatile.Register32 // 0x138
}

// RTC_CNTL.OPTIONS0: Sets the power options of crystal and PLL clocks, and initiates reset by software
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_STALL_APPCPU_C0(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_STALL_APPCPU_C0() uint32 {
	return volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_STALL_PROCPU_C0(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_STALL_PROCPU_C0() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_APPCPU_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_APPCPU_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_PROCPU_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_PROCPU_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BB_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BB_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BB_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BB_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetOPTIONS0_BBPLL_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_BBPLL_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetOPTIONS0_PLL_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_PLL_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetOPTIONS0_ANALOG_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_ANALOG_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetOPTIONS0_XTL_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_XTL_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetOPTIONS0_PLL_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_PLL_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetOPTIONS0_ANALOG_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_ANALOG_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetOPTIONS0_DG_WRAP_FORCE_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_DG_WRAP_FORCE_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetOPTIONS0_DG_WRAP_FORCE_NORST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_DG_WRAP_FORCE_NORST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetOPTIONS0_SW_SYS_RST(value uint32) {
	volatile.StoreUint32(&o.OPTIONS0.Reg, volatile.LoadUint32(&o.OPTIONS0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetOPTIONS0_SW_SYS_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTIONS0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SLP_TIMER0: RTC timer threshold register 0
func (o *RTC_CNTL_Type) SetSLP_TIMER0(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER0.Reg, value)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER0() uint32 {
	return volatile.LoadUint32(&o.SLP_TIMER0.Reg)
}

// RTC_CNTL.SLP_TIMER1: RTC timer threshold register 1
func (o *RTC_CNTL_Type) SetSLP_TIMER1_SLP_VAL_HI(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER1.Reg, volatile.LoadUint32(&o.SLP_TIMER1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER1_SLP_VAL_HI() uint32 {
	return volatile.LoadUint32(&o.SLP_TIMER1.Reg) & 0xffff
}
func (o *RTC_CNTL_Type) SetSLP_TIMER1_MAIN_TIMER_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_TIMER1.Reg, volatile.LoadUint32(&o.SLP_TIMER1.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetSLP_TIMER1_MAIN_TIMER_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_TIMER1.Reg) & 0x10000) >> 16
}

// RTC_CNTL.TIME_UPDATE: RTC timer update control register
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIMER_SYS_STALL(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIMER_SYS_STALL() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIMER_XTL_OFF(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIMER_XTL_OFF() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE_TIMER_SYS_RST(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE_TIMER_SYS_RST() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetTIME_UPDATE(value uint32) {
	volatile.StoreUint32(&o.TIME_UPDATE.Reg, volatile.LoadUint32(&o.TIME_UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTIME_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.TIME_UPDATE.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIME_LOW0: Stores the lower 32 bits of RTC timer 0.
func (o *RTC_CNTL_Type) SetTIME_LOW0(value uint32) {
	volatile.StoreUint32(&o.TIME_LOW0.Reg, value)
}
func (o *RTC_CNTL_Type) GetTIME_LOW0() uint32 {
	return volatile.LoadUint32(&o.TIME_LOW0.Reg)
}

// RTC_CNTL.TIME_HIGH0: Stores the higher 16 bits of RTC timer 0
func (o *RTC_CNTL_Type) SetTIME_HIGH0_TIMER_VALUE0_HIGH(value uint32) {
	volatile.StoreUint32(&o.TIME_HIGH0.Reg, volatile.LoadUint32(&o.TIME_HIGH0.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTIME_HIGH0_TIMER_VALUE0_HIGH() uint32 {
	return volatile.LoadUint32(&o.TIME_HIGH0.Reg) & 0xffff
}

// RTC_CNTL.STATE0: Configures the sleep / reject / wakeup state
func (o *RTC_CNTL_Type) SetSTATE0_SW_CPU_INT(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetSTATE0_SW_CPU_INT() uint32 {
	return volatile.LoadUint32(&o.STATE0.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_REJECT_CAUSE_CLR(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_REJECT_CAUSE_CLR() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetSTATE0_APB2RTC_BRIDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSTATE0_APB2RTC_BRIDGE_SEL() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSTATE0_SDIO_ACTIVE_IND(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetSTATE0_SDIO_ACTIVE_IND() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetSTATE0_SLP_REJECT(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLP_REJECT() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSTATE0_SLEEP_EN(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSTATE0_SLEEP_EN() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIMER1: Configures CPU stall options
func (o *RTC_CNTL_Type) SetTIMER1_CPU_STALL_EN(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetTIMER1_CPU_STALL_EN() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetTIMER1_CPU_STALL_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3e)|value<<1)
}
func (o *RTC_CNTL_Type) GetTIMER1_CPU_STALL_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3e) >> 1
}
func (o *RTC_CNTL_Type) SetTIMER1_CK8M_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0x3fc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetTIMER1_CK8M_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0x3fc0) >> 6
}
func (o *RTC_CNTL_Type) SetTIMER1_XTL_BUF_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xffc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetTIMER1_XTL_BUF_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xffc000) >> 14
}
func (o *RTC_CNTL_Type) SetTIMER1_PLL_BUF_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTIMER1_PLL_BUF_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TIMER2: Configures RTC slow clock and touch controller
func (o *RTC_CNTL_Type) SetTIMER2_ULPCP_TOUCH_START_WAIT(value uint32) {
	volatile.StoreUint32(&o.TIMER2.Reg, volatile.LoadUint32(&o.TIMER2.Reg)&^(0xff8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTIMER2_ULPCP_TOUCH_START_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TIMER2.Reg) & 0xff8000) >> 15
}
func (o *RTC_CNTL_Type) SetTIMER2_MIN_TIME_CK8M_OFF(value uint32) {
	volatile.StoreUint32(&o.TIMER2.Reg, volatile.LoadUint32(&o.TIMER2.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTIMER2_MIN_TIME_CK8M_OFF() uint32 {
	return (volatile.LoadUint32(&o.TIMER2.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TIMER3: configure some wait time for power on
func (o *RTC_CNTL_Type) SetTIMER3_WIFI_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0x1ff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER3_WIFI_WAIT_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER3.Reg) & 0x1ff
}
func (o *RTC_CNTL_Type) SetTIMER3_WIFI_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0xfe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTIMER3_WIFI_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0xfe00) >> 9
}
func (o *RTC_CNTL_Type) SetTIMER3_ROM_RAM_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER3_ROM_RAM_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER3_ROM_RAM_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER3.Reg, volatile.LoadUint32(&o.TIMER3.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER3_ROM_RAM_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER3.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER4: configure some wait time for power on
func (o *RTC_CNTL_Type) SetTIMER4_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0x1ff)|value)
}
func (o *RTC_CNTL_Type) GetTIMER4_WAIT_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIMER4.Reg) & 0x1ff
}
func (o *RTC_CNTL_Type) SetTIMER4_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0xfe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTIMER4_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0xfe00) >> 9
}
func (o *RTC_CNTL_Type) SetTIMER4_DG_WRAP_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER4_DG_WRAP_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER4_DG_WRAP_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER4.Reg, volatile.LoadUint32(&o.TIMER4.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER4_DG_WRAP_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER4.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER5: Configures the minimal sleep cycles
func (o *RTC_CNTL_Type) SetTIMER5_MIN_SLP_VAL(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_CNTL_Type) GetTIMER5_MIN_SLP_VAL() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0xff00) >> 8
}
func (o *RTC_CNTL_Type) SetTIMER5_RTCMEM_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER5_RTCMEM_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER5_RTCMEM_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER5.Reg, volatile.LoadUint32(&o.TIMER5.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER5_RTCMEM_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER5.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.TIMER6: Configure minimal sleep cycles register
func (o *RTC_CNTL_Type) SetTIMER6_DG_DCDC_WAIT_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER6.Reg, volatile.LoadUint32(&o.TIMER6.Reg)&^(0x1ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTIMER6_DG_DCDC_WAIT_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER6.Reg) & 0x1ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetTIMER6_DG_DCDC_POWERUP_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIMER6.Reg, volatile.LoadUint32(&o.TIMER6.Reg)&^(0xfe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTIMER6_DG_DCDC_POWERUP_TIMER() uint32 {
	return (volatile.LoadUint32(&o.TIMER6.Reg) & 0xfe000000) >> 25
}

// RTC_CNTL.ANA_CONF: Configures the power options for I2C and PLLA
func (o *RTC_CNTL_Type) SetANA_CONF_I2C_RESET_POR_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetANA_CONF_I2C_RESET_POR_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetANA_CONF_I2C_RESET_POR_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetANA_CONF_I2C_RESET_POR_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetANA_CONF_GLITCH_RST_EN(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetANA_CONF_GLITCH_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetANA_CONF_SAR_I2C_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetANA_CONF_SAR_I2C_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetANA_CONF_SAR_I2C_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetANA_CONF_SAR_I2C_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLLA_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLLA_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLLA_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLLA_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetANA_CONF_BBPLL_CAL_SLP_START(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetANA_CONF_BBPLL_CAL_SLP_START() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetANA_CONF_PVTMON_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PVTMON_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetANA_CONF_TXRF_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetANA_CONF_TXRF_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetANA_CONF_RFRX_PBUS_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetANA_CONF_RFRX_PBUS_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetANA_CONF_CKGEN_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetANA_CONF_CKGEN_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetANA_CONF_PLL_I2C_PU(value uint32) {
	volatile.StoreUint32(&o.ANA_CONF.Reg, volatile.LoadUint32(&o.ANA_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetANA_CONF_PLL_I2C_PU() uint32 {
	return (volatile.LoadUint32(&o.ANA_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.RESET_STATE: Indicates the CPU reset source. For more information about the reset cause, please refer to Table \ref{table:resetreasons} in Chapter \ref{module:ResetandClock} \textit{\nameref{module:ResetandClock}}.
func (o *RTC_CNTL_Type) SetRESET_STATE_RESET_CAUSE_PROCPU(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x3f)|value)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_RESET_CAUSE_PROCPU() uint32 {
	return volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x3f
}
func (o *RTC_CNTL_Type) SetRESET_STATE_RESET_CAUSE_APPCPU(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_RESET_CAUSE_APPCPU() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0xfc0) >> 6
}
func (o *RTC_CNTL_Type) SetRESET_STATE_APPCPU_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_APPCPU_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetRESET_STATE_PROCPU_STAT_VECTOR_SEL(value uint32) {
	volatile.StoreUint32(&o.RESET_STATE.Reg, volatile.LoadUint32(&o.RESET_STATE.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetRESET_STATE_PROCPU_STAT_VECTOR_SEL() uint32 {
	return (volatile.LoadUint32(&o.RESET_STATE.Reg) & 0x2000) >> 13
}

// RTC_CNTL.WAKEUP_STATE: Wakeup bitmap enabling register
func (o *RTC_CNTL_Type) SetWAKEUP_STATE_WAKEUP_ENA(value uint32) {
	volatile.StoreUint32(&o.WAKEUP_STATE.Reg, volatile.LoadUint32(&o.WAKEUP_STATE.Reg)&^(0xffff8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetWAKEUP_STATE_WAKEUP_ENA() uint32 {
	return (volatile.LoadUint32(&o.WAKEUP_STATE.Reg) & 0xffff8000) >> 15
}

// RTC_CNTL.INT_ENA_RTC: RTC interrupt enabling register
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SLP_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SLP_WAKEUP_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SLP_REJECT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SLP_REJECT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SDIO_IDLE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SDIO_IDLE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_ULP_CP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_ULP_CP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_ACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_ACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_INACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_INACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_BROWN_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_BROWN_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_MAIN_TIMER_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_MAIN_TIMER_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SARADC1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SARADC1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TSENS_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TSENS_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_COCPU_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_COCPU_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SARADC2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SARADC2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_SWD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_SWD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_XTAL32K_DEAD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_XTAL32K_DEAD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_COCPU_TRAP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_COCPU_TRAP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_ENA_RTC_GLITCH_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_RTC.Reg, volatile.LoadUint32(&o.INT_ENA_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_ENA_RTC_GLITCH_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.INT_RAW_RTC: RTC interrupt raw register
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SLP_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SLP_WAKEUP_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SLP_REJECT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SLP_REJECT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SDIO_IDLE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SDIO_IDLE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_ULP_CP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_ULP_CP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_ACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_ACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_INACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_INACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_BROWN_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_BROWN_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_MAIN_TIMER_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_MAIN_TIMER_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SARADC1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SARADC1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TSENS_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TSENS_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_COCPU_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_COCPU_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SARADC2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SARADC2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_SWD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_SWD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_XTAL32K_DEAD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_XTAL32K_DEAD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_COCPU_TRAP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_COCPU_TRAP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_RAW_RTC_GLITCH_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_RTC.Reg, volatile.LoadUint32(&o.INT_RAW_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_RAW_RTC_GLITCH_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.INT_ST_RTC: RTC interrupt state register
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SLP_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SLP_WAKEUP_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SLP_REJECT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SLP_REJECT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SDIO_IDLE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SDIO_IDLE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_SCAN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_SCAN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_ULP_CP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_ULP_CP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_ACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_ACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_INACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_INACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_BROWN_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_BROWN_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_MAIN_TIMER_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_MAIN_TIMER_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SARADC1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SARADC1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TSENS_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TSENS_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_COCPU_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_COCPU_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SARADC2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SARADC2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_SWD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_SWD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_XTAL32K_DEAD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_XTAL32K_DEAD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_COCPU_TRAP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_COCPU_TRAP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_TOUCH_TIMEOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_TOUCH_TIMEOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_ST_RTC_GLITCH_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_RTC.Reg, volatile.LoadUint32(&o.INT_ST_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_ST_RTC_GLITCH_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.INT_CLR_RTC: RTC interrupt clear register
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SLP_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SLP_WAKEUP_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SLP_REJECT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SLP_REJECT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SDIO_IDLE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SDIO_IDLE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_ULP_CP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_ULP_CP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_ACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_ACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_INACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_INACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_BROWN_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_BROWN_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_MAIN_TIMER_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_MAIN_TIMER_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SARADC1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SARADC1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TSENS_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TSENS_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_COCPU_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_COCPU_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SARADC2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SARADC2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_SWD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_SWD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_XTAL32K_DEAD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_XTAL32K_DEAD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_COCPU_TRAP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_COCPU_TRAP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetINT_CLR_RTC_GLITCH_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_RTC.Reg, volatile.LoadUint32(&o.INT_CLR_RTC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetINT_CLR_RTC_GLITCH_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_RTC.Reg) & 0x80000) >> 19
}

// RTC_CNTL.STORE0: Reservation register 0
func (o *RTC_CNTL_Type) SetSTORE0(value uint32) {
	volatile.StoreUint32(&o.STORE0.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE0() uint32 {
	return volatile.LoadUint32(&o.STORE0.Reg)
}

// RTC_CNTL.STORE1: Reservation register 1
func (o *RTC_CNTL_Type) SetSTORE1(value uint32) {
	volatile.StoreUint32(&o.STORE1.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE1() uint32 {
	return volatile.LoadUint32(&o.STORE1.Reg)
}

// RTC_CNTL.STORE2: Reservation register 2
func (o *RTC_CNTL_Type) SetSTORE2(value uint32) {
	volatile.StoreUint32(&o.STORE2.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE2() uint32 {
	return volatile.LoadUint32(&o.STORE2.Reg)
}

// RTC_CNTL.STORE3: Reservation register 3
func (o *RTC_CNTL_Type) SetSTORE3(value uint32) {
	volatile.StoreUint32(&o.STORE3.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE3() uint32 {
	return volatile.LoadUint32(&o.STORE3.Reg)
}

// RTC_CNTL.EXT_XTL_CONF: 32 kHz crystal oscillator configuration register
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_WDT_EN() uint32 {
	return volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_WDT_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_WDT_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_WDT_RESET(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_WDT_RESET() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_EXT_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_EXT_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_AUTO_BACKUP(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_AUTO_BACKUP() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_AUTO_RESTART(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_AUTO_RESTART() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_AUTO_RETURN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_AUTO_RETURN() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_ENCKINIT_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_ENCKINIT_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DBUF_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DBUF_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DGM_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x1c00)|value<<10)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DGM_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x1c00) >> 10
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DRES_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DRES_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0xe000) >> 13
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XPD_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XPD_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_DAC_XTAL_32K(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0xe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_DAC_XTAL_32K() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0xe0000) >> 17
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_WDT_STATE(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x700000)|value<<20)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_WDT_STATE() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x700000) >> 20
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTAL32K_GPIO_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTAL32K_GPIO_SEL() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTL_EXT_CTR_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTL_EXT_CTR_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetEXT_XTL_CONF_XTL_EXT_CTR_EN(value uint32) {
	volatile.StoreUint32(&o.EXT_XTL_CONF.Reg, volatile.LoadUint32(&o.EXT_XTL_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetEXT_XTL_CONF_XTL_EXT_CTR_EN() uint32 {
	return (volatile.LoadUint32(&o.EXT_XTL_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.EXT_WAKEUP_CONF: GPIO wakeup configuration register
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_EXT_WAKEUP0_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_EXT_WAKEUP0_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP_CONF_EXT_WAKEUP1_LV(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP_CONF.Reg, volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP_CONF_EXT_WAKEUP1_LV() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SLP_REJECT_CONF: Configures sleep / reject options
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_SLEEP_REJECT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x3fffe000)|value<<13)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_SLEEP_REJECT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x3fffe000) >> 13
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_LIGHT_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_LIGHT_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSLP_REJECT_CONF_DEEP_SLP_REJECT_EN(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CONF.Reg, volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CONF_DEEP_SLP_REJECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLP_REJECT_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.CPU_PERIOD_CONF: CPU sel option
func (o *RTC_CNTL_Type) SetCPU_PERIOD_CONF_CPUSEL_CONF(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIOD_CONF.Reg, volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetCPU_PERIOD_CONF_CPUSEL_CONF() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetCPU_PERIOD_CONF_CPUPERIOD_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PERIOD_CONF.Reg, volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetCPU_PERIOD_CONF_CPUPERIOD_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERIOD_CONF.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SDIO_ACT_CONF: configure sdio active register
func (o *RTC_CNTL_Type) SetSDIO_ACT_CONF_SDIO_ACT_DNUM(value uint32) {
	volatile.StoreUint32(&o.SDIO_ACT_CONF.Reg, volatile.LoadUint32(&o.SDIO_ACT_CONF.Reg)&^(0xffc00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSDIO_ACT_CONF_SDIO_ACT_DNUM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_ACT_CONF.Reg) & 0xffc00000) >> 22
}

// RTC_CNTL.CLK_CONF: RTC clock configuration register
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV_SEL_VLD(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV_SEL_VLD() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x30)|value<<4)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x30) >> 4
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ENB_CK8M(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ENB_CK8M() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ENB_CK8M_DIV(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ENB_CK8M_DIV() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_XTAL32K_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_XTAL32K_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_CLK8M_D256_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_CLK8M_D256_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetCLK_CONF_DIG_CLK8M_EN(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_DIG_CLK8M_EN() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DIV_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DIV_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x7000) >> 12
}
func (o *RTC_CNTL_Type) SetCLK_CONF_XTAL_FORCE_NOGATING(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_XTAL_FORCE_NOGATING() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_NOGATING(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_NOGATING() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_DFREQ(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x1fe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_DFREQ() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x1fe0000) >> 17
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetCLK_CONF_CK8M_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_CK8M_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetCLK_CONF_FAST_CLK_RTC_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_FAST_CLK_RTC_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetCLK_CONF_ANA_CLK_RTC_SEL(value uint32) {
	volatile.StoreUint32(&o.CLK_CONF.Reg, volatile.LoadUint32(&o.CLK_CONF.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetCLK_CONF_ANA_CLK_RTC_SEL() uint32 {
	return (volatile.LoadUint32(&o.CLK_CONF.Reg) & 0xc0000000) >> 30
}

// RTC_CNTL.SLOW_CLK_CONF: RTC slow clock configuration register
func (o *RTC_CNTL_Type) SetSLOW_CLK_CONF_ANA_CLK_DIV_VLD(value uint32) {
	volatile.StoreUint32(&o.SLOW_CLK_CONF.Reg, volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSLOW_CLK_CONF_ANA_CLK_DIV_VLD() uint32 {
	return (volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSLOW_CLK_CONF_ANA_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SLOW_CLK_CONF.Reg, volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg)&^(0x7f800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetSLOW_CLK_CONF_ANA_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg) & 0x7f800000) >> 23
}
func (o *RTC_CNTL_Type) SetSLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE(value uint32) {
	volatile.StoreUint32(&o.SLOW_CLK_CONF.Reg, volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SLOW_CLK_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SDIO_CONF: configure vddsdio register
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_TIMER_TARGET(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0xff)|value)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_TIMER_TARGET() uint32 {
	return volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0xff
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_DTHDRV(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x600)|value<<9)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_DTHDRV() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x600) >> 9
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_DCAP(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x1800)|value<<11)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_DCAP() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x1800) >> 11
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_INITI(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x6000)|value<<13)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_INITI() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x6000) >> 13
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_EN_INITI(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_EN_INITI() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_DCURLIM(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_DCURLIM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x70000) >> 16
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_MODECURLIM(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_MODECURLIM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_ENCURLIM(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_ENCURLIM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_REG_PD_EN(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_REG_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_FORCE(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_SDIO_TIEH(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_SDIO_TIEH() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_REG1P8_READY(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_REG1P8_READY() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFL_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x6000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFL_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x6000000) >> 25
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFM_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x18000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFM_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x18000000) >> 27
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_DREFH_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x60000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_DREFH_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x60000000) >> 29
}
func (o *RTC_CNTL_Type) SetSDIO_CONF_XPD_SDIO(value uint32) {
	volatile.StoreUint32(&o.SDIO_CONF.Reg, volatile.LoadUint32(&o.SDIO_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSDIO_CONF_XPD_SDIO() uint32 {
	return (volatile.LoadUint32(&o.SDIO_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.BIAS_CONF: configure power register
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_IDLE(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_IDLE() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_WAKE(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_WAKE() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_BUF_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_BUF_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_PD_CUR_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_PD_CUR_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_PD_CUR_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_PD_CUR_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_SLEEP_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_SLEEP_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_BIAS_SLEEP_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_BIAS_SLEEP_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DBG_ATTEN_DEEP_SLP(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x3c0000)|value<<18)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DBG_ATTEN_DEEP_SLP() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x3c0000) >> 18
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DBG_ATTEN_MONITOR(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x3c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DBG_ATTEN_MONITOR() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x3c00000) >> 22
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_ENB_SCK_XTAL(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_ENB_SCK_XTAL() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_INC_HEARTBEAT_REFRESH(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_INC_HEARTBEAT_REFRESH() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DEC_HEARTBEAT_PERIOD(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DEC_HEARTBEAT_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_INC_HEARTBEAT_PERIOD(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_INC_HEARTBEAT_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_DEC_HEARTBEAT_WIDTH(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_DEC_HEARTBEAT_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBIAS_CONF_RST_BIAS_I2C(value uint32) {
	volatile.StoreUint32(&o.BIAS_CONF.Reg, volatile.LoadUint32(&o.BIAS_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBIAS_CONF_RST_BIAS_I2C() uint32 {
	return (volatile.LoadUint32(&o.BIAS_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.REG: RTC/DIG regulator configuration register
func (o *RTC_CNTL_Type) SetREG_DIG_REG_DBIAS_SLP(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x700)|value<<8)
}
func (o *RTC_CNTL_Type) GetREG_DIG_REG_DBIAS_SLP() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x700) >> 8
}
func (o *RTC_CNTL_Type) SetREG_DIG_REG_DBIAS_WAK(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x3800)|value<<11)
}
func (o *RTC_CNTL_Type) GetREG_DIG_REG_DBIAS_WAK() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x3800) >> 11
}
func (o *RTC_CNTL_Type) SetREG_SCK_DCAP(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x3fc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetREG_SCK_DCAP() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x3fc000) >> 14
}
func (o *RTC_CNTL_Type) SetREG_DBIAS_SLP(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x1c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetREG_DBIAS_SLP() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x1c00000) >> 22
}
func (o *RTC_CNTL_Type) SetREG_DBIAS_WAK(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetREG_DBIAS_WAK() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetREG_DBOOST_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetREG_DBOOST_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetREG_DBOOST_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetREG_DBOOST_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetREG_REGULATOR_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetREG_REGULATOR_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetREG_REGULATOR_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.REG.Reg, volatile.LoadUint32(&o.REG.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetREG_REGULATOR_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.REG.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.PWC: RTC power configuraiton register
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_NOISO() uint32 {
	return volatile.LoadUint32(&o.PWC.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FOLW_CPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FOLW_CPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_LPD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_LPD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_LPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_LPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FOLW_CPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FOLW_CPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_LPD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_LPD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_LPU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_LPU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetPWC_FASTMEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetPWC_FASTMEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetPWC_SLOWMEM_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetPWC_SLOWMEM_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetPWC_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetPWC_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetPWC_PD_EN(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetPWC_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetPWC_PAD_FORCE_HOLD(value uint32) {
	volatile.StoreUint32(&o.PWC.Reg, volatile.LoadUint32(&o.PWC.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetPWC_PAD_FORCE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PWC.Reg) & 0x200000) >> 21
}

// RTC_CNTL.DIG_PWC: Digital system power configuraiton register
func (o *RTC_CNTL_Type) SetDIG_PWC_LSLP_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_LSLP_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetDIG_PWC_LSLP_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_LSLP_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_DCDC_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_DCDC_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_DCDC_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_DCDC_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_DCDC_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_DCDC_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetDIG_PWC_ROM0_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_ROM0_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM0_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM0_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM1_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM1_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM2_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM2_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM3_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM3_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetDIG_PWC_INTER_RAM4_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_INTER_RAM4_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetDIG_PWC_WIFI_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_WIFI_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetDIG_PWC_DG_WRAP_PD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_PWC.Reg, volatile.LoadUint32(&o.DIG_PWC.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetDIG_PWC_DG_WRAP_PD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_PWC.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.DIG_ISO: Digital system ISO configuration register
func (o *RTC_CNTL_Type) SetDIG_ISO_FORCE_OFF(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_FORCE_OFF() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetDIG_ISO_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_AUTOHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_AUTOHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetDIG_ISO_CLR_DG_PAD_AUTOHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_CLR_DG_PAD_AUTOHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_AUTOHOLD_EN(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_AUTOHOLD_EN() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_UNHOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_UNHOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_PAD_FORCE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_PAD_FORCE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetDIG_ISO_ROM0_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_ROM0_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetDIG_ISO_ROM0_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_ROM0_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM0_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM0_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM0_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM0_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM1_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM1_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM1_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM1_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM2_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM2_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM2_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM2_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM3_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM3_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM3_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM3_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM4_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM4_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetDIG_ISO_INTER_RAM4_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_INTER_RAM4_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetDIG_ISO_WIFI_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_WIFI_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetDIG_ISO_WIFI_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_WIFI_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_WRAP_FORCE_ISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_WRAP_FORCE_ISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetDIG_ISO_DG_WRAP_FORCE_NOISO(value uint32) {
	volatile.StoreUint32(&o.DIG_ISO.Reg, volatile.LoadUint32(&o.DIG_ISO.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetDIG_ISO_DG_WRAP_FORCE_NOISO() uint32 {
	return (volatile.LoadUint32(&o.DIG_ISO.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTCONFIG0: RTC watchdog configuration register
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CHIP_RESET_WIDTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xff)|value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CHIP_RESET_WIDTH() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xff
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CHIP_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CHIP_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_PAUSE_IN_SLP(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_PAUSE_IN_SLP() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000) >> 13
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000) >> 16
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x380000)|value<<19)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x380000) >> 19
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c00000)|value<<22)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c00000) >> 22
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x70000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x70000000) >> 28
}
func (o *RTC_CNTL_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTCONFIG1: Configures the hold time of RTC watchdog at level 1
func (o *RTC_CNTL_Type) SetWDTCONFIG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG1() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG1.Reg)
}

// RTC_CNTL.WDTCONFIG2: Configures the hold time of RTC watchdog at level 2
func (o *RTC_CNTL_Type) SetWDTCONFIG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG2.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG2() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG2.Reg)
}

// RTC_CNTL.WDTCONFIG3: Configures the hold time of RTC watchdog at level 3
func (o *RTC_CNTL_Type) SetWDTCONFIG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG3.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG3() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG3.Reg)
}

// RTC_CNTL.WDTCONFIG4: Configures the hold time of RTC watchdog at level 4
func (o *RTC_CNTL_Type) SetWDTCONFIG4(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG4.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTCONFIG4() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG4.Reg)
}

// RTC_CNTL.WDTFEED: RTC watchdog SW feed configuration register
func (o *RTC_CNTL_Type) SetWDTFEED_WDT_FEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, volatile.LoadUint32(&o.WDTFEED.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetWDTFEED_WDT_FEED() uint32 {
	return (volatile.LoadUint32(&o.WDTFEED.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.WDTWPROTECT: RTC watchdog write protection configuration register
func (o *RTC_CNTL_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *RTC_CNTL_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// RTC_CNTL.SWD_CONF: Super watchdog configuration register
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_RESET_FLAG(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_RESET_FLAG() uint32 {
	return volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_FEED_INT(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_FEED_INT() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_SIGNAL_WIDTH(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0xffc0000)|value<<18)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_SIGNAL_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0xffc0000) >> 18
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_RST_FLAG_CLR(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_RST_FLAG_CLR() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_FEED(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_FEED() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetSWD_CONF_SWD_AUTO_FEED_EN(value uint32) {
	volatile.StoreUint32(&o.SWD_CONF.Reg, volatile.LoadUint32(&o.SWD_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetSWD_CONF_SWD_AUTO_FEED_EN() uint32 {
	return (volatile.LoadUint32(&o.SWD_CONF.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.SWD_WPROTECT: Super watchdog write protection configuration register
func (o *RTC_CNTL_Type) SetSWD_WPROTECT(value uint32) {
	volatile.StoreUint32(&o.SWD_WPROTECT.Reg, value)
}
func (o *RTC_CNTL_Type) GetSWD_WPROTECT() uint32 {
	return volatile.LoadUint32(&o.SWD_WPROTECT.Reg)
}

// RTC_CNTL.SW_CPU_STALL: CPU stall configuration register
func (o *RTC_CNTL_Type) SetSW_CPU_STALL_SW_STALL_APPCPU_C1(value uint32) {
	volatile.StoreUint32(&o.SW_CPU_STALL.Reg, volatile.LoadUint32(&o.SW_CPU_STALL.Reg)&^(0x3f00000)|value<<20)
}
func (o *RTC_CNTL_Type) GetSW_CPU_STALL_SW_STALL_APPCPU_C1() uint32 {
	return (volatile.LoadUint32(&o.SW_CPU_STALL.Reg) & 0x3f00000) >> 20
}
func (o *RTC_CNTL_Type) SetSW_CPU_STALL_SW_STALL_PROCPU_C1(value uint32) {
	volatile.StoreUint32(&o.SW_CPU_STALL.Reg, volatile.LoadUint32(&o.SW_CPU_STALL.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetSW_CPU_STALL_SW_STALL_PROCPU_C1() uint32 {
	return (volatile.LoadUint32(&o.SW_CPU_STALL.Reg) & 0xfc000000) >> 26
}

// RTC_CNTL.STORE4: Reservation register 4
func (o *RTC_CNTL_Type) SetSTORE4(value uint32) {
	volatile.StoreUint32(&o.STORE4.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE4() uint32 {
	return volatile.LoadUint32(&o.STORE4.Reg)
}

// RTC_CNTL.STORE5: Reservation register 5
func (o *RTC_CNTL_Type) SetSTORE5(value uint32) {
	volatile.StoreUint32(&o.STORE5.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE5() uint32 {
	return volatile.LoadUint32(&o.STORE5.Reg)
}

// RTC_CNTL.STORE6: Reservation register 6
func (o *RTC_CNTL_Type) SetSTORE6(value uint32) {
	volatile.StoreUint32(&o.STORE6.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE6() uint32 {
	return volatile.LoadUint32(&o.STORE6.Reg)
}

// RTC_CNTL.STORE7: Reservation register 7
func (o *RTC_CNTL_Type) SetSTORE7(value uint32) {
	volatile.StoreUint32(&o.STORE7.Reg, value)
}
func (o *RTC_CNTL_Type) GetSTORE7() uint32 {
	return volatile.LoadUint32(&o.STORE7.Reg)
}

// RTC_CNTL.LOW_POWER_ST: RTC main state machine status register
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_ROM0(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_ROM0() uint32 {
	return volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_DIG_DCDC(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_DIG_DCDC() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_PERI_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_PERI_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_RTC_PERI(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_RTC_PERI() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_WIFI_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_WIFI_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_WIFI(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_WIFI() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_DIG_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_DIG_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_XPD_DIG(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_XPD_DIG() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_START(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_START() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_SWITCH(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_SLP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_SLP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_TOUCH_STATE_DONE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_TOUCH_STATE_DONE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_START(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_START() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_SWITCH(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_SLP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_SLP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_COCPU_STATE_DONE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_COCPU_STATE_DONE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_XTAL_ISO(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_XTAL_ISO() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_PLL_ON(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_PLL_ON() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_RDY_FOR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_RDY_FOR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_WAIT_END(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_WAIT_END() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_IN_WAKEUP_STATE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_IN_WAKEUP_STATE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x200000) >> 21
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_IN_LOW_POWER_STATE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_IN_LOW_POWER_STATE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_WAIT_8M(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_WAIT_8M() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_SLP(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_SLP() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE_IN_IDLE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE_IN_IDLE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetLOW_POWER_ST_MAIN_STATE(value uint32) {
	volatile.StoreUint32(&o.LOW_POWER_ST.Reg, volatile.LoadUint32(&o.LOW_POWER_ST.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetLOW_POWER_ST_MAIN_STATE() uint32 {
	return (volatile.LoadUint32(&o.LOW_POWER_ST.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.DIAG0: debug register
func (o *RTC_CNTL_Type) SetDIAG0(value uint32) {
	volatile.StoreUint32(&o.DIAG0.Reg, value)
}
func (o *RTC_CNTL_Type) GetDIAG0() uint32 {
	return volatile.LoadUint32(&o.DIAG0.Reg)
}

// RTC_CNTL.PAD_HOLD: Configures the hold options for RTC GPIOs
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD0_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD0_HOLD() uint32 {
	return volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD1_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x2)|value<<1)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD1_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x2) >> 1
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD2_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD2_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD3_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x8)|value<<3)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD3_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x8) >> 3
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD4_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD4_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD5_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD5_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD6_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD6_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD7_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD7_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD8_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD8_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD9_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD9_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD10_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD10_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD11_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD11_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD12_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD12_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD13_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD13_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_TOUCH_PAD14_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_TOUCH_PAD14_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_X32P_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_X32P_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_X32N_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_X32N_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PDAC1_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PDAC1_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PDAC2_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PDAC2_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x40000) >> 18
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PAD19_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PAD19_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x80000) >> 19
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PAD20_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PAD20_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x100000) >> 20
}
func (o *RTC_CNTL_Type) SetPAD_HOLD_PAD21_HOLD(value uint32) {
	volatile.StoreUint32(&o.PAD_HOLD.Reg, volatile.LoadUint32(&o.PAD_HOLD.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_CNTL_Type) GetPAD_HOLD_PAD21_HOLD() uint32 {
	return (volatile.LoadUint32(&o.PAD_HOLD.Reg) & 0x200000) >> 21
}

// RTC_CNTL.DIG_PAD_HOLD: Configures the hold option for digital GPIOs
func (o *RTC_CNTL_Type) SetDIG_PAD_HOLD(value uint32) {
	volatile.StoreUint32(&o.DIG_PAD_HOLD.Reg, value)
}
func (o *RTC_CNTL_Type) GetDIG_PAD_HOLD() uint32 {
	return volatile.LoadUint32(&o.DIG_PAD_HOLD.Reg)
}

// RTC_CNTL.EXT_WAKEUP1: EXT1 wakeup configuration register
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_SEL(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_SEL() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP1.Reg) & 0x3fffff
}
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_STATUS_CLR() uint32 {
	return (volatile.LoadUint32(&o.EXT_WAKEUP1.Reg) & 0x400000) >> 22
}

// RTC_CNTL.EXT_WAKEUP1_STATUS: EXT1 wakeup source register
func (o *RTC_CNTL_Type) SetEXT_WAKEUP1_STATUS(value uint32) {
	volatile.StoreUint32(&o.EXT_WAKEUP1_STATUS.Reg, volatile.LoadUint32(&o.EXT_WAKEUP1_STATUS.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetEXT_WAKEUP1_STATUS() uint32 {
	return volatile.LoadUint32(&o.EXT_WAKEUP1_STATUS.Reg) & 0x3fffff
}

// RTC_CNTL.BROWN_OUT: Brownout configuration register
func (o *RTC_CNTL_Type) SetBROWN_OUT_BROWN_OUT2_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_BROWN_OUT2_ENA() uint32 {
	return volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_INT_WAIT(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x3ff0)|value<<4)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_INT_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x3ff0) >> 4
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_CLOSE_FLASH_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_CLOSE_FLASH_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_PD_RF_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_PD_RF_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_WAIT(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x3ff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_WAIT() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x3ff0000) >> 16
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_RST_SEL(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_RST_SEL() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x8000000) >> 27
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_CNT_CLR(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_CNT_CLR() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_ENA(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetBROWN_OUT_DET(value uint32) {
	volatile.StoreUint32(&o.BROWN_OUT.Reg, volatile.LoadUint32(&o.BROWN_OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetBROWN_OUT_DET() uint32 {
	return (volatile.LoadUint32(&o.BROWN_OUT.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TIME_LOW1: Stores the lower 32 bits of RTC timer 1
func (o *RTC_CNTL_Type) SetTIME_LOW1(value uint32) {
	volatile.StoreUint32(&o.TIME_LOW1.Reg, value)
}
func (o *RTC_CNTL_Type) GetTIME_LOW1() uint32 {
	return volatile.LoadUint32(&o.TIME_LOW1.Reg)
}

// RTC_CNTL.TIME_HIGH1: Stores the higher 16 bits of RTC timer 1
func (o *RTC_CNTL_Type) SetTIME_HIGH1_TIMER_VALUE1_HIGH(value uint32) {
	volatile.StoreUint32(&o.TIME_HIGH1.Reg, volatile.LoadUint32(&o.TIME_HIGH1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTIME_HIGH1_TIMER_VALUE1_HIGH() uint32 {
	return volatile.LoadUint32(&o.TIME_HIGH1.Reg) & 0xffff
}

// RTC_CNTL.XTAL32K_CLK_FACTOR: Configures the divider factor for the backup clock of 32 kHz crystal oscillator
func (o *RTC_CNTL_Type) SetXTAL32K_CLK_FACTOR(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CLK_FACTOR.Reg, value)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CLK_FACTOR() uint32 {
	return volatile.LoadUint32(&o.XTAL32K_CLK_FACTOR.Reg)
}

// RTC_CNTL.XTAL32K_CONF: 32 kHz crystal oscillator configuration register
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_RETURN_WAIT(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xf)|value)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_RETURN_WAIT() uint32 {
	return volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xf
}
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_RESTART_WAIT(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xffff0)|value<<4)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_RESTART_WAIT() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xffff0) >> 4
}
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_WDT_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xff00000)|value<<20)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_WDT_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xff00000) >> 20
}
func (o *RTC_CNTL_Type) SetXTAL32K_CONF_XTAL32K_STABLE_THRES(value uint32) {
	volatile.StoreUint32(&o.XTAL32K_CONF.Reg, volatile.LoadUint32(&o.XTAL32K_CONF.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetXTAL32K_CONF_XTAL32K_STABLE_THRES() uint32 {
	return (volatile.LoadUint32(&o.XTAL32K_CONF.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.ULP_CP_TIMER: Configure coprocessor timer
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_PC_INIT(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x7ff)|value)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_PC_INIT() uint32 {
	return volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x7ff
}
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_ULP_CP_SLP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_ULP_CP_SLP_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.ULP_CP_CTRL: ULP-FSM configuration register
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x7ff)|value)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT() uint32 {
	return volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x7ff
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x3ff800)|value<<11)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x3ff800) >> 11
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x10000000) >> 28
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_RESET(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_RESET() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_FORCE_START_TOP(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_FORCE_START_TOP() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetULP_CP_CTRL_ULP_CP_START_TOP(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_CTRL.Reg, volatile.LoadUint32(&o.ULP_CP_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetULP_CP_CTRL_ULP_CP_START_TOP() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_CTRL.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.COCPU_CTRL: ULP-RISCV configuration register
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_CLK_FO() uint32 {
	return volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x1
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_START_2_RESET_DIS(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x7e)|value<<1)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_START_2_RESET_DIS() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x7e) >> 1
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_START_2_INTR_EN(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x1f80)|value<<7)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_START_2_INTR_EN() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x1f80) >> 7
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SHUT(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SHUT() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SHUT_2_CLK_DIS(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x3fc000)|value<<14)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SHUT_2_CLK_DIS() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x3fc000) >> 14
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SHUT_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SHUT_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x400000) >> 22
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SEL(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SEL() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_DONE_FORCE(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_DONE_FORCE() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x1000000) >> 24
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_DONE(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_DONE() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x2000000) >> 25
}
func (o *RTC_CNTL_Type) SetCOCPU_CTRL_COCPU_SW_INT_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.COCPU_CTRL.Reg, volatile.LoadUint32(&o.COCPU_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetCOCPU_CTRL_COCPU_SW_INT_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.COCPU_CTRL.Reg) & 0x4000000) >> 26
}

// RTC_CNTL.TOUCH_CTRL1: Touch control register
func (o *RTC_CNTL_Type) SetTOUCH_CTRL1_TOUCH_SLEEP_CYCLES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL1.Reg, volatile.LoadUint32(&o.TOUCH_CTRL1.Reg)&^(0xffff)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL1_TOUCH_SLEEP_CYCLES() uint32 {
	return volatile.LoadUint32(&o.TOUCH_CTRL1.Reg) & 0xffff
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL1_TOUCH_MEAS_NUM(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL1.Reg, volatile.LoadUint32(&o.TOUCH_CTRL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL1_TOUCH_MEAS_NUM() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL1.Reg) & 0xffff0000) >> 16
}

// RTC_CNTL.TOUCH_CTRL2: Touch control register
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DRANGE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DRANGE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DREFL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DREFL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x30) >> 4
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DREFH(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DREFH() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0xc0) >> 6
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_XPD_BIAS(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_XPD_BIAS() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_REFC(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0xe00)|value<<9)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_REFC() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0xe00) >> 9
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_DBIAS(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_DBIAS() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_SLP_TIMER_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_SLP_TIMER_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_START_FSM_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_START_FSM_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_START_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_START_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x1fe0000)|value<<17)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_XPD_WAIT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x1fe0000) >> 17
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_SLP_CYC_DIV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x6000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_SLP_CYC_DIV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x6000000) >> 25
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x18000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x18000000) >> 27
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_RESET(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_RESET() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x20000000) >> 29
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_CLK_FO() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x40000000) >> 30
}
func (o *RTC_CNTL_Type) SetTOUCH_CTRL2_TOUCH_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_CTRL2.Reg, volatile.LoadUint32(&o.TOUCH_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTOUCH_CTRL2_TOUCH_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_CTRL2.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.TOUCH_SCAN_CTRL: Configure touch scan settings
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_DENOISE_RES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_DENOISE_RES() uint32 {
	return volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_DENOISE_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_DENOISE_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x4) >> 2
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0x1fffc00)|value<<10)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0x1fffc00) >> 10
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_BUFDRV(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_BUFDRV() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetTOUCH_SCAN_CTRL_TOUCH_OUT_RING(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SCAN_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetTOUCH_SCAN_CTRL_TOUCH_OUT_RING() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SCAN_CTRL.Reg) & 0xf0000000) >> 28
}

// RTC_CNTL.TOUCH_SLP_THRES: Configure the settings of touch sleep pad
func (o *RTC_CNTL_Type) SetTOUCH_SLP_THRES_TOUCH_SLP_TH(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SLP_THRES.Reg, volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_SLP_THRES_TOUCH_SLP_TH() uint32 {
	return volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg) & 0x3fffff
}
func (o *RTC_CNTL_Type) SetTOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SLP_THRES.Reg, volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_CNTL_Type) GetTOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg) & 0x4000000) >> 26
}
func (o *RTC_CNTL_Type) SetTOUCH_SLP_THRES_TOUCH_SLP_PAD(value uint32) {
	volatile.StoreUint32(&o.TOUCH_SLP_THRES.Reg, volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTC_CNTL_Type) GetTOUCH_SLP_THRES_TOUCH_SLP_PAD() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_SLP_THRES.Reg) & 0xf8000000) >> 27
}

// RTC_CNTL.TOUCH_APPROACH: Configure touch approach settings
func (o *RTC_CNTL_Type) SetTOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR(value uint32) {
	volatile.StoreUint32(&o.TOUCH_APPROACH.Reg, volatile.LoadUint32(&o.TOUCH_APPROACH.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetTOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_APPROACH.Reg) & 0x800000) >> 23
}
func (o *RTC_CNTL_Type) SetTOUCH_APPROACH_MEAS_TIME(value uint32) {
	volatile.StoreUint32(&o.TOUCH_APPROACH.Reg, volatile.LoadUint32(&o.TOUCH_APPROACH.Reg)&^(0xff000000)|value<<24)
}
func (o *RTC_CNTL_Type) GetTOUCH_APPROACH_MEAS_TIME() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_APPROACH.Reg) & 0xff000000) >> 24
}

// RTC_CNTL.TOUCH_FILTER_CTRL: Configure touch filter settings
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x600)|value<<9)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x600) >> 9
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_JITTER_STEP(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x7800)|value<<11)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_JITTER_STEP() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x7800) >> 11
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x78000)|value<<15)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x78000) >> 15
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x180000)|value<<19)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x180000) >> 19
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_NOISE_THRES(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_NOISE_THRES() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x600000) >> 21
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_HYSTERESIS(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x1800000)|value<<23)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_HYSTERESIS() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x1800000) >> 23
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0xe000000)|value<<25)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0xe000000) >> 25
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_FILTER_MODE(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x70000000)|value<<28)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_FILTER_MODE() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x70000000) >> 28
}
func (o *RTC_CNTL_Type) SetTOUCH_FILTER_CTRL_TOUCH_FILTER_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_FILTER_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_CNTL_Type) GetTOUCH_FILTER_CTRL_TOUCH_FILTER_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_FILTER_CTRL.Reg) & 0x80000000) >> 31
}

// RTC_CNTL.USB_CONF: configure usb control register
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_VREFH(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x3)|value)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_VREFH() uint32 {
	return volatile.LoadUint32(&o.USB_CONF.Reg) & 0x3
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_VREFL(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0xc)|value<<2)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_VREFL() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0xc) >> 2
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_VREF_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x10)|value<<4)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_VREF_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x10) >> 4
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PAD_PULL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x20)|value<<5)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PAD_PULL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x20) >> 5
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x40)|value<<6)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x40) >> 6
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DP_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x80)|value<<7)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DP_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x80) >> 7
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DM_PULLUP(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x100)|value<<8)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DM_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x100) >> 8
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_DM_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x200)|value<<9)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_DM_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x200) >> 9
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PULLUP_VALUE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x400)|value<<10)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PULLUP_VALUE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x400) >> 10
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PAD_ENABLE_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x800)|value<<11)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PAD_ENABLE_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x800) >> 11
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_PAD_ENABLE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_PAD_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x1000) >> 12
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TXM(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TXM() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x2000) >> 13
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TXP(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TXP() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x4000) >> 14
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TX_EN(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x8000) >> 15
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_TX_EN_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_TX_EN_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x10000) >> 16
}
func (o *RTC_CNTL_Type) SetUSB_CONF_USB_RESET_DISABLE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_USB_RESET_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x20000) >> 17
}
func (o *RTC_CNTL_Type) SetUSB_CONF_IO_MUX_RESET_DISABLE(value uint32) {
	volatile.StoreUint32(&o.USB_CONF.Reg, volatile.LoadUint32(&o.USB_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_CNTL_Type) GetUSB_CONF_IO_MUX_RESET_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.USB_CONF.Reg) & 0x40000) >> 18
}

// RTC_CNTL.TOUCH_TIMEOUT_CTRL: Configure touch timeout settings
func (o *RTC_CNTL_Type) SetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM(value uint32) {
	volatile.StoreUint32(&o.TOUCH_TIMEOUT_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg)&^(0x3fffff)|value)
}
func (o *RTC_CNTL_Type) GetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM() uint32 {
	return volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg) & 0x3fffff
}
func (o *RTC_CNTL_Type) SetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN(value uint32) {
	volatile.StoreUint32(&o.TOUCH_TIMEOUT_CTRL.Reg, volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_CNTL_Type) GetTOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.TOUCH_TIMEOUT_CTRL.Reg) & 0x400000) >> 22
}

// RTC_CNTL.SLP_REJECT_CAUSE: Stores the reject-to-sleep cause.
func (o *RTC_CNTL_Type) SetSLP_REJECT_CAUSE_REJECT_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SLP_REJECT_CAUSE.Reg, volatile.LoadUint32(&o.SLP_REJECT_CAUSE.Reg)&^(0x1ffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_REJECT_CAUSE_REJECT_CAUSE() uint32 {
	return volatile.LoadUint32(&o.SLP_REJECT_CAUSE.Reg) & 0x1ffff
}

// RTC_CNTL.OPTIONS1: RTC option register
func (o *RTC_CNTL_Type) SetOPTIONS1_FORCE_DOWNLOAD_BOOT(value uint32) {
	volatile.StoreUint32(&o.OPTIONS1.Reg, volatile.LoadUint32(&o.OPTIONS1.Reg)&^(0x1)|value)
}
func (o *RTC_CNTL_Type) GetOPTIONS1_FORCE_DOWNLOAD_BOOT() uint32 {
	return volatile.LoadUint32(&o.OPTIONS1.Reg) & 0x1
}

// RTC_CNTL.SLP_WAKEUP_CAUSE: Stores the sleep-to-wakeup cause.
func (o *RTC_CNTL_Type) SetSLP_WAKEUP_CAUSE_WAKEUP_CAUSE(value uint32) {
	volatile.StoreUint32(&o.SLP_WAKEUP_CAUSE.Reg, volatile.LoadUint32(&o.SLP_WAKEUP_CAUSE.Reg)&^(0x1ffff)|value)
}
func (o *RTC_CNTL_Type) GetSLP_WAKEUP_CAUSE_WAKEUP_CAUSE() uint32 {
	return volatile.LoadUint32(&o.SLP_WAKEUP_CAUSE.Reg) & 0x1ffff
}

// RTC_CNTL.ULP_CP_TIMER_1: Configure sleep cycle of the timer
func (o *RTC_CNTL_Type) SetULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE(value uint32) {
	volatile.StoreUint32(&o.ULP_CP_TIMER_1.Reg, volatile.LoadUint32(&o.ULP_CP_TIMER_1.Reg)&^(0xffffff00)|value<<8)
}
func (o *RTC_CNTL_Type) GetULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.ULP_CP_TIMER_1.Reg) & 0xffffff00) >> 8
}

// RTC_CNTL.DATE
func (o *RTC_CNTL_Type) SetDATE_CNTL_DATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *RTC_CNTL_Type) GetDATE_CNTL_DATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// Low-power I2C (Inter-Integrated Circuit) Controller
type RTC_I2C_Type struct {
	SCL_LOW          volatile.Register32 // 0x0
	CTRL             volatile.Register32 // 0x4
	STATUS           volatile.Register32 // 0x8
	TO               volatile.Register32 // 0xC
	SLAVE_ADDR       volatile.Register32 // 0x10
	SCL_HIGH         volatile.Register32 // 0x14
	SDA_DUTY         volatile.Register32 // 0x18
	SCL_START_PERIOD volatile.Register32 // 0x1C
	SCL_STOP_PERIOD  volatile.Register32 // 0x20
	INT_CLR          volatile.Register32 // 0x24
	INT_RAW          volatile.Register32 // 0x28
	INT_ST           volatile.Register32 // 0x2C
	INT_ENA          volatile.Register32 // 0x30
	DATA             volatile.Register32 // 0x34
	CMD0             volatile.Register32 // 0x38
	CMD1             volatile.Register32 // 0x3C
	CMD2             volatile.Register32 // 0x40
	CMD3             volatile.Register32 // 0x44
	CMD4             volatile.Register32 // 0x48
	CMD5             volatile.Register32 // 0x4C
	CMD6             volatile.Register32 // 0x50
	CMD7             volatile.Register32 // 0x54
	CMD8             volatile.Register32 // 0x58
	CMD9             volatile.Register32 // 0x5C
	CMD10            volatile.Register32 // 0x60
	CMD11            volatile.Register32 // 0x64
	CMD12            volatile.Register32 // 0x68
	CMD13            volatile.Register32 // 0x6C
	CMD14            volatile.Register32 // 0x70
	CMD15            volatile.Register32 // 0x74
	_                [132]byte
	DATE             volatile.Register32 // 0xFC
}

// RTC_I2C.SCL_LOW: Configure the low level width of SCL
func (o *RTC_I2C_Type) SetSCL_LOW_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_LOW.Reg, volatile.LoadUint32(&o.SCL_LOW.Reg)&^(0xfffff)|value)
}
func (o *RTC_I2C_Type) GetSCL_LOW_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_LOW.Reg) & 0xfffff
}

// RTC_I2C.CTRL: Transmission setting
func (o *RTC_I2C_Type) SetCTRL_SDA_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *RTC_I2C_Type) GetCTRL_SDA_FORCE_OUT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *RTC_I2C_Type) SetCTRL_SCL_FORCE_OUT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_I2C_Type) GetCTRL_SCL_FORCE_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *RTC_I2C_Type) SetCTRL_MS_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_I2C_Type) GetCTRL_MS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *RTC_I2C_Type) SetCTRL_TRANS_START(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *RTC_I2C_Type) GetCTRL_TRANS_START() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *RTC_I2C_Type) SetCTRL_TX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTC_I2C_Type) GetCTRL_TX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *RTC_I2C_Type) SetCTRL_RX_LSB_FIRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *RTC_I2C_Type) GetCTRL_RX_LSB_FIRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *RTC_I2C_Type) SetCTRL_CLK_GATE_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_I2C_Type) GetCTRL_CLK_GATE_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *RTC_I2C_Type) SetCTRL_RESET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_I2C_Type) GetCTRL_RESET() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *RTC_I2C_Type) SetCTRL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCTRL_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// RTC_I2C.STATUS: RTC I2C status
func (o *RTC_I2C_Type) SetSTATUS_ACK_REC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *RTC_I2C_Type) GetSTATUS_ACK_REC() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *RTC_I2C_Type) SetSTATUS_SLAVE_RW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *RTC_I2C_Type) GetSTATUS_SLAVE_RW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *RTC_I2C_Type) SetSTATUS_ARB_LOST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *RTC_I2C_Type) GetSTATUS_ARB_LOST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *RTC_I2C_Type) SetSTATUS_BUS_BUSY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *RTC_I2C_Type) GetSTATUS_BUS_BUSY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *RTC_I2C_Type) SetSTATUS_SLAVE_ADDRESSED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *RTC_I2C_Type) GetSTATUS_SLAVE_ADDRESSED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *RTC_I2C_Type) SetSTATUS_BYTE_TRANS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *RTC_I2C_Type) GetSTATUS_BYTE_TRANS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *RTC_I2C_Type) SetSTATUS_OP_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_I2C_Type) GetSTATUS_OP_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xc0) >> 6
}
func (o *RTC_I2C_Type) SetSTATUS_SHIFT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xff0000)|value<<16)
}
func (o *RTC_I2C_Type) GetSTATUS_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xff0000) >> 16
}
func (o *RTC_I2C_Type) SetSTATUS_SCL_MAIN_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_I2C_Type) GetSTATUS_SCL_MAIN_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x7000000) >> 24
}
func (o *RTC_I2C_Type) SetSTATUS_SCL_STATE_LAST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x70000000)|value<<28)
}
func (o *RTC_I2C_Type) GetSTATUS_SCL_STATE_LAST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x70000000) >> 28
}

// RTC_I2C.TO: Configure RTC I2C timeout
func (o *RTC_I2C_Type) SetTO_TIME_OUT(value uint32) {
	volatile.StoreUint32(&o.TO.Reg, volatile.LoadUint32(&o.TO.Reg)&^(0xfffff)|value)
}
func (o *RTC_I2C_Type) GetTO_TIME_OUT() uint32 {
	return volatile.LoadUint32(&o.TO.Reg) & 0xfffff
}

// RTC_I2C.SLAVE_ADDR: Configure slave address
func (o *RTC_I2C_Type) SetSLAVE_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x7fff)|value)
}
func (o *RTC_I2C_Type) GetSLAVE_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x7fff
}
func (o *RTC_I2C_Type) SetSLAVE_ADDR_ADDR_10BIT_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE_ADDR.Reg, volatile.LoadUint32(&o.SLAVE_ADDR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetSLAVE_ADDR_ADDR_10BIT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE_ADDR.Reg) & 0x80000000) >> 31
}

// RTC_I2C.SCL_HIGH: Configure the high level width of SCL
func (o *RTC_I2C_Type) SetSCL_HIGH_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_HIGH.Reg, volatile.LoadUint32(&o.SCL_HIGH.Reg)&^(0xfffff)|value)
}
func (o *RTC_I2C_Type) GetSCL_HIGH_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_HIGH.Reg) & 0xfffff
}

// RTC_I2C.SDA_DUTY: Configure the SDA hold time after a negative SCL edge
func (o *RTC_I2C_Type) SetSDA_DUTY_NUM(value uint32) {
	volatile.StoreUint32(&o.SDA_DUTY.Reg, volatile.LoadUint32(&o.SDA_DUTY.Reg)&^(0xfffff)|value)
}
func (o *RTC_I2C_Type) GetSDA_DUTY_NUM() uint32 {
	return volatile.LoadUint32(&o.SDA_DUTY.Reg) & 0xfffff
}

// RTC_I2C.SCL_START_PERIOD: Configure the delay between the SDA and SCL negative edge for a start condition
func (o *RTC_I2C_Type) SetSCL_START_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_START_PERIOD.Reg, volatile.LoadUint32(&o.SCL_START_PERIOD.Reg)&^(0xfffff)|value)
}
func (o *RTC_I2C_Type) GetSCL_START_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_START_PERIOD.Reg) & 0xfffff
}

// RTC_I2C.SCL_STOP_PERIOD: Configure the delay between SDA and SCL positive edge for a stop condition
func (o *RTC_I2C_Type) SetSCL_STOP_PERIOD(value uint32) {
	volatile.StoreUint32(&o.SCL_STOP_PERIOD.Reg, volatile.LoadUint32(&o.SCL_STOP_PERIOD.Reg)&^(0xfffff)|value)
}
func (o *RTC_I2C_Type) GetSCL_STOP_PERIOD() uint32 {
	return volatile.LoadUint32(&o.SCL_STOP_PERIOD.Reg) & 0xfffff
}

// RTC_I2C.INT_CLR: Clear RTC I2C interrupt
func (o *RTC_I2C_Type) SetINT_CLR_SLAVE_TRAN_COMP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *RTC_I2C_Type) GetINT_CLR_SLAVE_TRAN_COMP_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *RTC_I2C_Type) SetINT_CLR_ARBITRATION_LOST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_I2C_Type) GetINT_CLR_ARBITRATION_LOST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *RTC_I2C_Type) SetINT_CLR_MASTER_TRAN_COMP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_I2C_Type) GetINT_CLR_MASTER_TRAN_COMP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *RTC_I2C_Type) SetINT_CLR_TRANS_COMPLETE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_I2C_Type) GetINT_CLR_TRANS_COMPLETE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *RTC_I2C_Type) SetINT_CLR_TIME_OUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_I2C_Type) GetINT_CLR_TIME_OUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *RTC_I2C_Type) SetINT_CLR_ACK_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_I2C_Type) GetINT_CLR_ACK_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *RTC_I2C_Type) SetINT_CLR_RX_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_I2C_Type) GetINT_CLR_RX_DATA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *RTC_I2C_Type) SetINT_CLR_TX_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_I2C_Type) GetINT_CLR_TX_DATA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *RTC_I2C_Type) SetINT_CLR_DETECT_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_I2C_Type) GetINT_CLR_DETECT_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}

// RTC_I2C.INT_RAW: RTC I2C raw interrupt
func (o *RTC_I2C_Type) SetINT_RAW_SLAVE_TRAN_COMP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *RTC_I2C_Type) GetINT_RAW_SLAVE_TRAN_COMP_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *RTC_I2C_Type) SetINT_RAW_ARBITRATION_LOST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *RTC_I2C_Type) GetINT_RAW_ARBITRATION_LOST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *RTC_I2C_Type) SetINT_RAW_MASTER_TRAN_COMP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *RTC_I2C_Type) GetINT_RAW_MASTER_TRAN_COMP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *RTC_I2C_Type) SetINT_RAW_TRANS_COMPLETE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *RTC_I2C_Type) GetINT_RAW_TRANS_COMPLETE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *RTC_I2C_Type) SetINT_RAW_TIME_OUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *RTC_I2C_Type) GetINT_RAW_TIME_OUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *RTC_I2C_Type) SetINT_RAW_ACK_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *RTC_I2C_Type) GetINT_RAW_ACK_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *RTC_I2C_Type) SetINT_RAW_RX_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *RTC_I2C_Type) GetINT_RAW_RX_DATA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *RTC_I2C_Type) SetINT_RAW_TX_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *RTC_I2C_Type) GetINT_RAW_TX_DATA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *RTC_I2C_Type) SetINT_RAW_DETECT_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *RTC_I2C_Type) GetINT_RAW_DETECT_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}

// RTC_I2C.INT_ST: RTC I2C interrupt status
func (o *RTC_I2C_Type) SetINT_ST_SLAVE_TRAN_COMP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *RTC_I2C_Type) GetINT_ST_SLAVE_TRAN_COMP_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *RTC_I2C_Type) SetINT_ST_ARBITRATION_LOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *RTC_I2C_Type) GetINT_ST_ARBITRATION_LOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *RTC_I2C_Type) SetINT_ST_MASTER_TRAN_COMP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *RTC_I2C_Type) GetINT_ST_MASTER_TRAN_COMP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *RTC_I2C_Type) SetINT_ST_TRANS_COMPLETE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *RTC_I2C_Type) GetINT_ST_TRANS_COMPLETE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *RTC_I2C_Type) SetINT_ST_TIME_OUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *RTC_I2C_Type) GetINT_ST_TIME_OUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *RTC_I2C_Type) SetINT_ST_ACK_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *RTC_I2C_Type) GetINT_ST_ACK_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *RTC_I2C_Type) SetINT_ST_RX_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *RTC_I2C_Type) GetINT_ST_RX_DATA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *RTC_I2C_Type) SetINT_ST_TX_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *RTC_I2C_Type) GetINT_ST_TX_DATA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *RTC_I2C_Type) SetINT_ST_DETECT_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *RTC_I2C_Type) GetINT_ST_DETECT_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}

// RTC_I2C.INT_ENA: Enable RTC I2C interrupt
func (o *RTC_I2C_Type) SetINT_ENA_SLAVE_TRAN_COMP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *RTC_I2C_Type) GetINT_ENA_SLAVE_TRAN_COMP_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *RTC_I2C_Type) SetINT_ENA_ARBITRATION_LOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *RTC_I2C_Type) GetINT_ENA_ARBITRATION_LOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *RTC_I2C_Type) SetINT_ENA_MASTER_TRAN_COMP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *RTC_I2C_Type) GetINT_ENA_MASTER_TRAN_COMP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *RTC_I2C_Type) SetINT_ENA_TRANS_COMPLETE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *RTC_I2C_Type) GetINT_ENA_TRANS_COMPLETE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *RTC_I2C_Type) SetINT_ENA_TIME_OUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *RTC_I2C_Type) GetINT_ENA_TIME_OUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *RTC_I2C_Type) SetINT_ENA_ACK_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *RTC_I2C_Type) GetINT_ENA_ACK_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *RTC_I2C_Type) SetINT_ENA_RX_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *RTC_I2C_Type) GetINT_ENA_RX_DATA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *RTC_I2C_Type) SetINT_ENA_TX_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *RTC_I2C_Type) GetINT_ENA_TX_DATA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *RTC_I2C_Type) SetINT_ENA_DETECT_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *RTC_I2C_Type) GetINT_ENA_DETECT_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}

// RTC_I2C.DATA: RTC I2C read data
func (o *RTC_I2C_Type) SetDATA_RDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff)|value)
}
func (o *RTC_I2C_Type) GetDATA_RDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0xff
}
func (o *RTC_I2C_Type) SetDATA_SLAVE_TX_DATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_I2C_Type) GetDATA_SLAVE_TX_DATA() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xff00) >> 8
}
func (o *RTC_I2C_Type) SetDATA_DONE(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetDATA_DONE() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD0: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD0_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD0.Reg, volatile.LoadUint32(&o.CMD0.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD0_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD0.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD0_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD0.Reg, volatile.LoadUint32(&o.CMD0.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD0_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD0.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD1: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD1_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD1.Reg, volatile.LoadUint32(&o.CMD1.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD1_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD1.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD1_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD1.Reg, volatile.LoadUint32(&o.CMD1.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD1_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD1.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD2: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD2_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD2.Reg, volatile.LoadUint32(&o.CMD2.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD2_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD2.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD2_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD2.Reg, volatile.LoadUint32(&o.CMD2.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD2_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD2.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD3: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD3_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD3.Reg, volatile.LoadUint32(&o.CMD3.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD3_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD3.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD3_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD3.Reg, volatile.LoadUint32(&o.CMD3.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD3_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD3.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD4: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD4_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD4.Reg, volatile.LoadUint32(&o.CMD4.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD4_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD4.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD4_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD4.Reg, volatile.LoadUint32(&o.CMD4.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD4_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD4.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD5: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD5_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD5.Reg, volatile.LoadUint32(&o.CMD5.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD5_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD5.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD5_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD5.Reg, volatile.LoadUint32(&o.CMD5.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD5_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD5.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD6: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD6_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD6.Reg, volatile.LoadUint32(&o.CMD6.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD6_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD6.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD6_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD6.Reg, volatile.LoadUint32(&o.CMD6.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD6_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD6.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD7: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD7_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD7.Reg, volatile.LoadUint32(&o.CMD7.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD7_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD7.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD7_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD7.Reg, volatile.LoadUint32(&o.CMD7.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD7_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD7.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD8: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD8_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD8.Reg, volatile.LoadUint32(&o.CMD8.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD8_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD8.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD8_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD8.Reg, volatile.LoadUint32(&o.CMD8.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD8_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD8.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD9: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD9_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD9.Reg, volatile.LoadUint32(&o.CMD9.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD9_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD9.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD9_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD9.Reg, volatile.LoadUint32(&o.CMD9.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD9_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD9.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD10: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD10_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD10.Reg, volatile.LoadUint32(&o.CMD10.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD10_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD10.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD10_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD10.Reg, volatile.LoadUint32(&o.CMD10.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD10_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD10.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD11: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD11_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD11.Reg, volatile.LoadUint32(&o.CMD11.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD11_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD11.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD11_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD11.Reg, volatile.LoadUint32(&o.CMD11.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD11_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD11.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD12: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD12_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD12.Reg, volatile.LoadUint32(&o.CMD12.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD12_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD12.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD12_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD12.Reg, volatile.LoadUint32(&o.CMD12.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD12_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD12.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD13: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD13_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD13.Reg, volatile.LoadUint32(&o.CMD13.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD13_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD13.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD13_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD13.Reg, volatile.LoadUint32(&o.CMD13.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD13_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD13.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD14: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD14_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD14.Reg, volatile.LoadUint32(&o.CMD14.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD14_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD14.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD14_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD14.Reg, volatile.LoadUint32(&o.CMD14.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD14_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD14.Reg) & 0x80000000) >> 31
}

// RTC_I2C.CMD15: RTC I2C Command %s
func (o *RTC_I2C_Type) SetCMD15_COMMAND(value uint32) {
	volatile.StoreUint32(&o.CMD15.Reg, volatile.LoadUint32(&o.CMD15.Reg)&^(0x3fff)|value)
}
func (o *RTC_I2C_Type) GetCMD15_COMMAND() uint32 {
	return volatile.LoadUint32(&o.CMD15.Reg) & 0x3fff
}
func (o *RTC_I2C_Type) SetCMD15_COMMAND_DONE(value uint32) {
	volatile.StoreUint32(&o.CMD15.Reg, volatile.LoadUint32(&o.CMD15.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_I2C_Type) GetCMD15_COMMAND_DONE() uint32 {
	return (volatile.LoadUint32(&o.CMD15.Reg) & 0x80000000) >> 31
}

// RTC_I2C.DATE: Version control register
func (o *RTC_I2C_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *RTC_I2C_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// SENS Peripheral
type SENS_Type struct {
	SAR_READER1_CTRL   volatile.Register32 // 0x0
	SAR_READER1_STATUS volatile.Register32 // 0x4
	SAR_MEAS1_CTRL1    volatile.Register32 // 0x8
	SAR_MEAS1_CTRL2    volatile.Register32 // 0xC
	SAR_MEAS1_MUX      volatile.Register32 // 0x10
	SAR_ATTEN1         volatile.Register32 // 0x14
	SAR_AMP_CTRL1      volatile.Register32 // 0x18
	SAR_AMP_CTRL2      volatile.Register32 // 0x1C
	SAR_AMP_CTRL3      volatile.Register32 // 0x20
	SAR_READER2_CTRL   volatile.Register32 // 0x24
	SAR_READER2_STATUS volatile.Register32 // 0x28
	SAR_MEAS2_CTRL1    volatile.Register32 // 0x2C
	SAR_MEAS2_CTRL2    volatile.Register32 // 0x30
	SAR_MEAS2_MUX      volatile.Register32 // 0x34
	SAR_ATTEN2         volatile.Register32 // 0x38
	SAR_POWER_XPD_SAR  volatile.Register32 // 0x3C
	SAR_SLAVE_ADDR1    volatile.Register32 // 0x40
	SAR_SLAVE_ADDR2    volatile.Register32 // 0x44
	SAR_SLAVE_ADDR3    volatile.Register32 // 0x48
	SAR_SLAVE_ADDR4    volatile.Register32 // 0x4C
	SAR_TSENS_CTRL     volatile.Register32 // 0x50
	SAR_TSENS_CTRL2    volatile.Register32 // 0x54
	SAR_I2C_CTRL       volatile.Register32 // 0x58
	SAR_TOUCH_CONF     volatile.Register32 // 0x5C
	SAR_TOUCH_THRES1   volatile.Register32 // 0x60
	SAR_TOUCH_THRES2   volatile.Register32 // 0x64
	SAR_TOUCH_THRES3   volatile.Register32 // 0x68
	SAR_TOUCH_THRES4   volatile.Register32 // 0x6C
	SAR_TOUCH_THRES5   volatile.Register32 // 0x70
	SAR_TOUCH_THRES6   volatile.Register32 // 0x74
	SAR_TOUCH_THRES7   volatile.Register32 // 0x78
	SAR_TOUCH_THRES8   volatile.Register32 // 0x7C
	SAR_TOUCH_THRES9   volatile.Register32 // 0x80
	SAR_TOUCH_THRES10  volatile.Register32 // 0x84
	SAR_TOUCH_THRES11  volatile.Register32 // 0x88
	SAR_TOUCH_THRES12  volatile.Register32 // 0x8C
	SAR_TOUCH_THRES13  volatile.Register32 // 0x90
	SAR_TOUCH_THRES14  volatile.Register32 // 0x94
	_                  [60]byte
	SAR_TOUCH_CHN_ST   volatile.Register32 // 0xD4
	SAR_TOUCH_STATUS0  volatile.Register32 // 0xD8
	SAR_TOUCH_STATUS1  volatile.Register32 // 0xDC
	SAR_TOUCH_STATUS2  volatile.Register32 // 0xE0
	SAR_TOUCH_STATUS3  volatile.Register32 // 0xE4
	SAR_TOUCH_STATUS4  volatile.Register32 // 0xE8
	SAR_TOUCH_STATUS5  volatile.Register32 // 0xEC
	SAR_TOUCH_STATUS6  volatile.Register32 // 0xF0
	SAR_TOUCH_STATUS7  volatile.Register32 // 0xF4
	SAR_TOUCH_STATUS8  volatile.Register32 // 0xF8
	SAR_TOUCH_STATUS9  volatile.Register32 // 0xFC
	SAR_TOUCH_STATUS10 volatile.Register32 // 0x100
	SAR_TOUCH_STATUS11 volatile.Register32 // 0x104
	SAR_TOUCH_STATUS12 volatile.Register32 // 0x108
	SAR_TOUCH_STATUS13 volatile.Register32 // 0x10C
	SAR_TOUCH_STATUS14 volatile.Register32 // 0x110
	SAR_TOUCH_STATUS15 volatile.Register32 // 0x114
	SAR_TOUCH_STATUS16 volatile.Register32 // 0x118
	SAR_DAC_CTRL1      volatile.Register32 // 0x11C
	SAR_DAC_CTRL2      volatile.Register32 // 0x120
	SAR_COCPU_STATE    volatile.Register32 // 0x124
	SAR_COCPU_INT_RAW  volatile.Register32 // 0x128
	SAR_COCPU_INT_ENA  volatile.Register32 // 0x12C
	SAR_COCPU_INT_ST   volatile.Register32 // 0x130
	SAR_COCPU_INT_CLR  volatile.Register32 // 0x134
	SAR_COCPU_DEBUG    volatile.Register32 // 0x138
	SAR_HALL_CTRL      volatile.Register32 // 0x13C
	SAR_NOUSE          volatile.Register32 // 0x140
	SAR_IO_MUX_CONF    volatile.Register32 // 0x144
	SARDATE            volatile.Register32 // 0x148
}

// SENS.SAR_READER1_CTRL: RTC ADC1 data and sampling control
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_SAMPLE_NUM(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x7f80000)|value<<19)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_SAMPLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x7f80000) >> 19
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_DATA_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_DATA_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_READER1_CTRL_SAR1_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_READER1_CTRL_SAR1_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER1_CTRL.Reg) & 0x20000000) >> 29
}

// SENS.SAR_READER1_STATUS: saradc1 status for debug
func (o *SENS_Type) SetSAR_READER1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR_READER1_STATUS.Reg, value)
}
func (o *SENS_Type) GetSAR_READER1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR_READER1_STATUS.Reg)
}

// SENS.SAR_MEAS1_CTRL1: Configure RTC ADC1 controller
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_RTC_SARADC_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_RTC_SARADC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x400000) >> 22
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x800000) >> 23
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_FORCE_XPD_AMP(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x3000000)|value<<24)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_FORCE_XPD_AMP() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x3000000) >> 24
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_AMP_RST_FB_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0xc000000)|value<<26)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_AMP_RST_FB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0xc000000) >> 26
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0x30000000)|value<<28)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0x30000000) >> 28
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg)&^(0xc0000000)|value<<30)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL1.Reg) & 0xc0000000) >> 30
}

// SENS.SAR_MEAS1_CTRL2: Control RTC ADC1 conversion and status
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_DATA_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_DATA_SAR() uint32 {
	return volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_DONE_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_DONE_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x10000) >> 16
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_START_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_START_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x20000) >> 17
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_MEAS1_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_MEAS1_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_SAR1_EN_PAD(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x7ff80000)|value<<19)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_SAR1_EN_PAD() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x7ff80000) >> 19
}
func (o *SENS_Type) SetSAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_CTRL2.Reg) & 0x80000000) >> 31
}

// SENS.SAR_MEAS1_MUX: Select the controller for SAR ADC1
func (o *SENS_Type) SetSAR_MEAS1_MUX_SAR1_DIG_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS1_MUX.Reg, volatile.LoadUint32(&o.SAR_MEAS1_MUX.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS1_MUX_SAR1_DIG_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS1_MUX.Reg) & 0x80000000) >> 31
}

// SENS.SAR_ATTEN1: Configure SAR ADC1 attenuation
func (o *SENS_Type) SetSAR_ATTEN1(value uint32) {
	volatile.StoreUint32(&o.SAR_ATTEN1.Reg, value)
}
func (o *SENS_Type) GetSAR_ATTEN1() uint32 {
	return volatile.LoadUint32(&o.SAR_ATTEN1.Reg)
}

// SENS.SAR_AMP_CTRL1: AMP control
func (o *SENS_Type) SetSAR_AMP_CTRL1_SAR_AMP_WAIT1(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL1.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_AMP_CTRL1_SAR_AMP_WAIT1() uint32 {
	return volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_AMP_CTRL1_SAR_AMP_WAIT2(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL1.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_AMP_CTRL1_SAR_AMP_WAIT2() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL1.Reg) & 0xffff0000) >> 16
}

// SENS.SAR_AMP_CTRL2: AMP control
func (o *SENS_Type) SetSAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE() uint32 {
	return volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_XPD_SAR_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_XPD_SAR_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_AMP_CTRL2_SAR_AMP_WAIT3(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL2.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg)&^(0xffff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_AMP_CTRL2_SAR_AMP_WAIT3() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL2.Reg) & 0xffff0000) >> 16
}

// SENS.SAR_AMP_CTRL3: AMP control register
func (o *SENS_Type) SetSAR_AMP_CTRL3_SAR1_DAC_XPD_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf)|value)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_SAR1_DAC_XPD_FSM() uint32 {
	return volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_XPD_SAR_AMP_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf0)|value<<4)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_XPD_SAR_AMP_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf0) >> 4
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_AMP_RST_FB_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf00)|value<<8)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_AMP_RST_FB_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf00) >> 8
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_AMP_SHORT_REF_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf000)|value<<12)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_AMP_SHORT_REF_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf000) >> 12
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf0000)|value<<16)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf0000) >> 16
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_XPD_SAR_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf00000)|value<<20)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_XPD_SAR_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf00000) >> 20
}
func (o *SENS_Type) SetSAR_AMP_CTRL3_SAR_RSTB_FSM(value uint32) {
	volatile.StoreUint32(&o.SAR_AMP_CTRL3.Reg, volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg)&^(0xf000000)|value<<24)
}
func (o *SENS_Type) GetSAR_AMP_CTRL3_SAR_RSTB_FSM() uint32 {
	return (volatile.LoadUint32(&o.SAR_AMP_CTRL3.Reg) & 0xf000000) >> 24
}

// SENS.SAR_READER2_CTRL: RTC ADC2 data and sampling control
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_CLK_DIV() uint32 {
	return volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x30000) >> 16
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_CLK_GATED(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_CLK_GATED() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_SAMPLE_NUM(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x7f80000)|value<<19)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_SAMPLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x7f80000) >> 19
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_DATA_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_DATA_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x20000000) >> 29
}
func (o *SENS_Type) SetSAR_READER2_CTRL_SAR2_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_CTRL.Reg, volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_READER2_CTRL_SAR2_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_READER2_CTRL.Reg) & 0x40000000) >> 30
}

// SENS.SAR_READER2_STATUS: saradc2 status for debug
func (o *SENS_Type) SetSAR_READER2_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR_READER2_STATUS.Reg, value)
}
func (o *SENS_Type) GetSAR_READER2_STATUS() uint32 {
	return volatile.LoadUint32(&o.SAR_READER2_STATUS.Reg)
}

// SENS.SAR_MEAS2_CTRL1: configure rtc saradc2
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_CNTL_STATE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x7)|value)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_CNTL_STATE() uint32 {
	return volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x7
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_EN_TEST(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_EN_TEST() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_RSTB_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xc0)|value<<6)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_RSTB_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xc0) >> 6
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xff00)|value<<8)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xff00) >> 8
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_RSTB_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_RSTB_WAIT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xff0000) >> 16
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL1_SAR2_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL1.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL1_SAR2_XPD_WAIT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL1.Reg) & 0xff000000) >> 24
}

// SENS.SAR_MEAS2_CTRL2: Control RTC ADC2 conversion and status
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_DATA_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_DATA_SAR() uint32 {
	return volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_DONE_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_DONE_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x10000) >> 16
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_START_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_START_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x20000) >> 17
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_MEAS2_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_MEAS2_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_SAR2_EN_PAD(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x7ff80000)|value<<19)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_SAR2_EN_PAD() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x7ff80000) >> 19
}
func (o *SENS_Type) SetSAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_CTRL2.Reg, volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_CTRL2.Reg) & 0x80000000) >> 31
}

// SENS.SAR_MEAS2_MUX: Select the controller for SAR ADC2
func (o *SENS_Type) SetSAR_MEAS2_MUX_SAR2_PWDET_CCT(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_MUX.Reg, volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg)&^(0x70000000)|value<<28)
}
func (o *SENS_Type) GetSAR_MEAS2_MUX_SAR2_PWDET_CCT() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg) & 0x70000000) >> 28
}
func (o *SENS_Type) SetSAR_MEAS2_MUX_SAR2_RTC_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_MEAS2_MUX.Reg, volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_MEAS2_MUX_SAR2_RTC_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_MEAS2_MUX.Reg) & 0x80000000) >> 31
}

// SENS.SAR_ATTEN2: Configure SAR ADC2 attenuation
func (o *SENS_Type) SetSAR_ATTEN2(value uint32) {
	volatile.StoreUint32(&o.SAR_ATTEN2.Reg, value)
}
func (o *SENS_Type) GetSAR_ATTEN2() uint32 {
	return volatile.LoadUint32(&o.SAR_ATTEN2.Reg)
}

// SENS.SAR_POWER_XPD_SAR: configure saradc’s power by sw
func (o *SENS_Type) SetSAR_POWER_XPD_SAR_FORCE_XPD_SAR(value uint32) {
	volatile.StoreUint32(&o.SAR_POWER_XPD_SAR.Reg, volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg)&^(0x60000000)|value<<29)
}
func (o *SENS_Type) GetSAR_POWER_XPD_SAR_FORCE_XPD_SAR() uint32 {
	return (volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg) & 0x60000000) >> 29
}
func (o *SENS_Type) SetSAR_POWER_XPD_SAR_SARCLK_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_POWER_XPD_SAR.Reg, volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_POWER_XPD_SAR_SARCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_POWER_XPD_SAR.Reg) & 0x80000000) >> 31
}

// SENS.SAR_SLAVE_ADDR1: Configure slave addresses 0-1 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR1.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR1.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg) & 0x3ff800) >> 11
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR1_MEAS_STATUS(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR1.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg)&^(0x3fc00000)|value<<22)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR1_MEAS_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR1.Reg) & 0x3fc00000) >> 22
}

// SENS.SAR_SLAVE_ADDR2: Configure slave addresses 2-3 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR2.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR2.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR2.Reg) & 0x3ff800) >> 11
}

// SENS.SAR_SLAVE_ADDR3: Configure slave addresses 4-5 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR3.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR3.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR3.Reg) & 0x3ff800) >> 11
}

// SENS.SAR_SLAVE_ADDR4: Configure slave addresses 6-7 of RTC I2C
func (o *SENS_Type) SetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR4.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg)&^(0x7ff)|value)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7() uint32 {
	return volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg) & 0x7ff
}
func (o *SENS_Type) SetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6(value uint32) {
	volatile.StoreUint32(&o.SAR_SLAVE_ADDR4.Reg, volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg)&^(0x3ff800)|value<<11)
}
func (o *SENS_Type) GetSAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6() uint32 {
	return (volatile.LoadUint32(&o.SAR_SLAVE_ADDR4.Reg) & 0x3ff800) >> 11
}

// SENS.SAR_TSENS_CTRL: Temperature sensor data control
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_OUT(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_OUT() uint32 {
	return volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_READY(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_READY() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x100) >> 8
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x1000) >> 12
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_IN_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_IN_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x2000) >> 13
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x3fc000)|value<<14)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x3fc000) >> 14
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_POWER_UP(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_POWER_UP() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x400000) >> 22
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_POWER_UP_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_POWER_UP_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x800000) >> 23
}
func (o *SENS_Type) SetSAR_TSENS_CTRL_TSENS_DUMP_OUT(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL_TSENS_DUMP_OUT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL.Reg) & 0x1000000) >> 24
}

// SENS.SAR_TSENS_CTRL2: Temperature sensor control
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_XPD_WAIT(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0xfff)|value)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_XPD_WAIT() uint32 {
	return volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0xfff
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_XPD_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x3000)|value<<12)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_XPD_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x3000) >> 12
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_CLK_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_CLK_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x4000) >> 14
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x8000) >> 15
}
func (o *SENS_Type) SetSAR_TSENS_CTRL2_TSENS_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_TSENS_CTRL2.Reg, volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_TSENS_CTRL2_TSENS_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_TSENS_CTRL2.Reg) & 0x10000) >> 16
}

// SENS.SAR_I2C_CTRL: Configure RTC I2C transmission
func (o *SENS_Type) SetSAR_I2C_CTRL(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_CTRL.Reg, volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg)&^(0xfffffff)|value)
}
func (o *SENS_Type) GetSAR_I2C_CTRL() uint32 {
	return volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg) & 0xfffffff
}
func (o *SENS_Type) SetSAR_I2C_CTRL_SAR_I2C_START(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_CTRL.Reg, volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_I2C_CTRL_SAR_I2C_START() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_I2C_CTRL_SAR_I2C_START_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_I2C_CTRL.Reg, volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_I2C_CTRL_SAR_I2C_START_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_I2C_CTRL.Reg) & 0x20000000) >> 29
}

// SENS.SAR_TOUCH_CONF: Touch sensor configuration register
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_OUTEN(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x7fff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_OUTEN() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x7fff
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_STATUS_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_STATUS_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x8000) >> 15
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_DATA_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x30000)|value<<16)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_DATA_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x30000) >> 16
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_DENOISE_END(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_DENOISE_END() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x40000) >> 18
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_UNIT_END(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_UNIT_END() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0x80000) >> 19
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD2(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0xf00000)|value<<20)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD2() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0xf00000) >> 20
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD1(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0xf000000)|value<<24)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD1() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0xf000000) >> 24
}
func (o *SENS_Type) SetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD0(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CONF.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg)&^(0xf0000000)|value<<28)
}
func (o *SENS_Type) GetSAR_TOUCH_CONF_TOUCH_APPROACH_PAD0() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CONF.Reg) & 0xf0000000) >> 28
}

// SENS.SAR_TOUCH_THRES1: Finger threshold for touch pad 1
func (o *SENS_Type) SetSAR_TOUCH_THRES1_TOUCH_OUT_TH1(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES1.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES1.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES1_TOUCH_OUT_TH1() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES1.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES2: Finger threshold for touch pad 2
func (o *SENS_Type) SetSAR_TOUCH_THRES2_TOUCH_OUT_TH2(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES2.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES2.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES2_TOUCH_OUT_TH2() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES2.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES3: Finger threshold for touch pad 3
func (o *SENS_Type) SetSAR_TOUCH_THRES3_TOUCH_OUT_TH3(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES3.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES3.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES3_TOUCH_OUT_TH3() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES3.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES4: Finger threshold for touch pad 4
func (o *SENS_Type) SetSAR_TOUCH_THRES4_TOUCH_OUT_TH4(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES4.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES4.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES4_TOUCH_OUT_TH4() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES4.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES5: Finger threshold for touch pad 5
func (o *SENS_Type) SetSAR_TOUCH_THRES5_TOUCH_OUT_TH5(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES5.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES5.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES5_TOUCH_OUT_TH5() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES5.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES6: Finger threshold for touch pad 6
func (o *SENS_Type) SetSAR_TOUCH_THRES6_TOUCH_OUT_TH6(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES6.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES6.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES6_TOUCH_OUT_TH6() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES6.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES7: Finger threshold for touch pad 7
func (o *SENS_Type) SetSAR_TOUCH_THRES7_TOUCH_OUT_TH7(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES7.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES7.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES7_TOUCH_OUT_TH7() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES7.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES8: Finger threshold for touch pad 8
func (o *SENS_Type) SetSAR_TOUCH_THRES8_TOUCH_OUT_TH8(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES8.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES8.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES8_TOUCH_OUT_TH8() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES8.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES9: Finger threshold for touch pad 9
func (o *SENS_Type) SetSAR_TOUCH_THRES9_TOUCH_OUT_TH9(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES9.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES9.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES9_TOUCH_OUT_TH9() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES9.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES10: Finger threshold for touch pad 10
func (o *SENS_Type) SetSAR_TOUCH_THRES10_TOUCH_OUT_TH10(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES10.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES10.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES10_TOUCH_OUT_TH10() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES10.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES11: Finger threshold for touch pad 11
func (o *SENS_Type) SetSAR_TOUCH_THRES11_TOUCH_OUT_TH11(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES11.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES11.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES11_TOUCH_OUT_TH11() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES11.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES12: Finger threshold for touch pad 12
func (o *SENS_Type) SetSAR_TOUCH_THRES12_TOUCH_OUT_TH12(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES12.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES12.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES12_TOUCH_OUT_TH12() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES12.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES13: Finger threshold for touch pad 13
func (o *SENS_Type) SetSAR_TOUCH_THRES13_TOUCH_OUT_TH13(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES13.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES13.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES13_TOUCH_OUT_TH13() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES13.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_THRES14: Finger threshold for touch pad 14
func (o *SENS_Type) SetSAR_TOUCH_THRES14_TOUCH_OUT_TH14(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_THRES14.Reg, volatile.LoadUint32(&o.SAR_TOUCH_THRES14.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_THRES14_TOUCH_OUT_TH14() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_THRES14.Reg) & 0x3fffff
}

// SENS.SAR_TOUCH_CHN_ST: Touch channel status register
func (o *SENS_Type) SetSAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CHN_ST.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg)&^(0x7fff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg) & 0x7fff
}
func (o *SENS_Type) SetSAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CHN_ST.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg)&^(0x3fff8000)|value<<15)
}
func (o *SENS_Type) GetSAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg) & 0x3fff8000) >> 15
}
func (o *SENS_Type) SetSAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_CHN_ST.Reg, volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_CHN_ST.Reg) & 0x80000000) >> 31
}

// SENS.SAR_TOUCH_STATUS0: Status of touch controller
func (o *SENS_Type) SetSAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS0.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS0_TOUCH_SCAN_CURR(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS0.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg)&^(0x3c00000)|value<<22)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS0_TOUCH_SCAN_CURR() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS0.Reg) & 0x3c00000) >> 22
}

// SENS.SAR_TOUCH_STATUS1: Touch pad 1 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS1_TOUCH_PAD1_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS1.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS1_TOUCH_PAD1_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS1.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS1.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS2: Touch pad 2 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS2_TOUCH_PAD2_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS2.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS2_TOUCH_PAD2_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS2.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS2.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS3: Touch pad 3 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS3_TOUCH_PAD3_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS3.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS3_TOUCH_PAD3_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS3.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS3.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS4: Touch pad 4 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS4_TOUCH_PAD4_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS4.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS4_TOUCH_PAD4_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS4.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS4.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS5: Touch pad 5 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS5_TOUCH_PAD5_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS5.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS5_TOUCH_PAD5_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS5.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS5.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS6: Touch pad 6 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS6_TOUCH_PAD6_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS6.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS6_TOUCH_PAD6_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS6.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS6.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS7: Touch pad 7 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS7_TOUCH_PAD7_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS7.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS7_TOUCH_PAD7_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS7.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS7.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS8: Touch pad 8 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS8_TOUCH_PAD8_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS8.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS8_TOUCH_PAD8_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS8.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS8.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS9: Touch pad 9 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS9_TOUCH_PAD9_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS9.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS9_TOUCH_PAD9_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS9.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS9.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS10: Touch pad 10 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS10_TOUCH_PAD10_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS10.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS10_TOUCH_PAD10_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS10.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS10.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS11: Touch pad 11 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS11_TOUCH_PAD11_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS11.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS11_TOUCH_PAD11_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS11.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS11.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS12: Touch pad 12 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS12_TOUCH_PAD12_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS12.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS12_TOUCH_PAD12_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS12.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS12.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS13: Touch pad 13 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS13_TOUCH_PAD13_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS13.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS13_TOUCH_PAD13_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS13.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS13.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS14: Touch pad 14 status
func (o *SENS_Type) SetSAR_TOUCH_STATUS14_TOUCH_PAD14_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS14.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS14_TOUCH_PAD14_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS14.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS14.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS15: Touch sleep pad status
func (o *SENS_Type) SetSAR_TOUCH_STATUS15_TOUCH_SLP_DATA(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS15.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg)&^(0x3fffff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS15_TOUCH_SLP_DATA() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg) & 0x3fffff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS15.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg)&^(0xe0000000)|value<<29)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS15.Reg) & 0xe0000000) >> 29
}

// SENS.SAR_TOUCH_STATUS16: Touch approach count status
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT() uint32 {
	return volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff00)|value<<8)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff00) >> 8
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff0000)|value<<16)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff0000) >> 16
}
func (o *SENS_Type) SetSAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT(value uint32) {
	volatile.StoreUint32(&o.SAR_TOUCH_STATUS16.Reg, volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg)&^(0xff000000)|value<<24)
}
func (o *SENS_Type) GetSAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT() uint32 {
	return (volatile.LoadUint32(&o.SAR_TOUCH_STATUS16.Reg) & 0xff000000) >> 24
}

// SENS.SAR_DAC_CTRL1: DAC control
func (o *SENS_Type) SetSAR_DAC_CTRL1_SW_FSTEP(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0xffff)|value)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_SW_FSTEP() uint32 {
	return volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0xffff
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_SW_TONE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_SW_TONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x10000) >> 16
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DEBUG_BIT_SEL(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x3e0000)|value<<17)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DEBUG_BIT_SEL() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x3e0000) >> 17
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_DIG_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_DIG_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x400000) >> 22
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLK_FORCE_LOW(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLK_FORCE_LOW() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x800000) >> 23
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x1000000)|value<<24)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x1000000) >> 24
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLK_INV(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x2000000)|value<<25)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLK_INV() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x2000000) >> 25
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x4000000)|value<<26)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x4000000) >> 26
}
func (o *SENS_Type) SetSAR_DAC_CTRL1_DAC_CLKGATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL1.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg)&^(0x8000000)|value<<27)
}
func (o *SENS_Type) GetSAR_DAC_CTRL1_DAC_CLKGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL1.Reg) & 0x8000000) >> 27
}

// SENS.SAR_DAC_CTRL2: DAC output control
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_DC1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xff)|value)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_DC1() uint32 {
	return volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xff
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_DC2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xff00)|value<<8)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_DC2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xff00) >> 8
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_SCALE1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x30000)|value<<16)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_SCALE1() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x30000) >> 16
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_SCALE2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xc0000)|value<<18)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_SCALE2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xc0000) >> 18
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_INV1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x300000)|value<<20)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_INV1() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x300000) >> 20
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_INV2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0xc00000)|value<<22)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_INV2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0xc00000) >> 22
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_CW_EN1(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x1000000)|value<<24)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_CW_EN1() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x1000000) >> 24
}
func (o *SENS_Type) SetSAR_DAC_CTRL2_DAC_CW_EN2(value uint32) {
	volatile.StoreUint32(&o.SAR_DAC_CTRL2.Reg, volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg)&^(0x2000000)|value<<25)
}
func (o *SENS_Type) GetSAR_DAC_CTRL2_DAC_CW_EN2() uint32 {
	return (volatile.LoadUint32(&o.SAR_DAC_CTRL2.Reg) & 0x2000000) >> 25
}

// SENS.SAR_COCPU_STATE: ULP-RISCV status
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_DBG_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x2000000)|value<<25)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_DBG_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x2000000) >> 25
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x4000000)|value<<26)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x4000000) >> 26
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_RESET_N(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x8000000)|value<<27)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_RESET_N() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x8000000) >> 27
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_EOI(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_EOI() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_TRAP(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_TRAP() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x20000000) >> 29
}
func (o *SENS_Type) SetSAR_COCPU_STATE_COCPU_EBREAK(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_STATE.Reg, volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_COCPU_STATE_COCPU_EBREAK() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_STATE.Reg) & 0x40000000) >> 30
}

// SENS.SAR_COCPU_INT_RAW: Interrupt raw bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SW_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SW_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_RAW.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_RAW.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_INT_ENA: Interrupt enable bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SW_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SW_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ENA.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ENA.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_INT_ST: Interrupt status bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_TSENS_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_TSENS_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SW_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SW_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_ST_COCPU_SWD_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_ST.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_ST_COCPU_SWD_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_ST.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_INT_CLR: Interrupt clear bit of ULP-RISCV
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x1)|value)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x1
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x2) >> 1
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x4) >> 2
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x20) >> 5
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x40) >> 6
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SW_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SW_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x80) >> 7
}
func (o *SENS_Type) SetSAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_INT_CLR.Reg, volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SENS_Type) GetSAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_INT_CLR.Reg) & 0x100) >> 8
}

// SENS.SAR_COCPU_DEBUG: ULP-RISCV debug register
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_PC(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x1fff)|value)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_PC() uint32 {
	return volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x1fff
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_VLD(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x2000)|value<<13)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_VLD() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x2000) >> 13
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_RDY(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x4000)|value<<14)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_RDY() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x4000) >> 14
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_WEN(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0x78000)|value<<15)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_WEN() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0x78000) >> 15
}
func (o *SENS_Type) SetSAR_COCPU_DEBUG_COCPU_MEM_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAR_COCPU_DEBUG.Reg, volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg)&^(0xfff80000)|value<<19)
}
func (o *SENS_Type) GetSAR_COCPU_DEBUG_COCPU_MEM_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SAR_COCPU_DEBUG.Reg) & 0xfff80000) >> 19
}

// SENS.SAR_HALL_CTRL: hall control
func (o *SENS_Type) SetSAR_HALL_CTRL_XPD_HALL(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_XPD_HALL() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x10000000) >> 28
}
func (o *SENS_Type) SetSAR_HALL_CTRL_XPD_HALL_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_XPD_HALL_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x20000000) >> 29
}
func (o *SENS_Type) SetSAR_HALL_CTRL_HALL_PHASE(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_HALL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x40000000) >> 30
}
func (o *SENS_Type) SetSAR_HALL_CTRL_HALL_PHASE_FORCE(value uint32) {
	volatile.StoreUint32(&o.SAR_HALL_CTRL.Reg, volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_HALL_CTRL_HALL_PHASE_FORCE() uint32 {
	return (volatile.LoadUint32(&o.SAR_HALL_CTRL.Reg) & 0x80000000) >> 31
}

// SENS.SAR_NOUSE: sar nouse
func (o *SENS_Type) SetSAR_NOUSE(value uint32) {
	volatile.StoreUint32(&o.SAR_NOUSE.Reg, value)
}
func (o *SENS_Type) GetSAR_NOUSE() uint32 {
	return volatile.LoadUint32(&o.SAR_NOUSE.Reg)
}

// SENS.SAR_IO_MUX_CONF: Configure and reset IO MUX
func (o *SENS_Type) SetSAR_IO_MUX_CONF_IOMUX_RESET(value uint32) {
	volatile.StoreUint32(&o.SAR_IO_MUX_CONF.Reg, volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SENS_Type) GetSAR_IO_MUX_CONF_IOMUX_RESET() uint32 {
	return (volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg) & 0x40000000) >> 30
}
func (o *SENS_Type) SetSAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN(value uint32) {
	volatile.StoreUint32(&o.SAR_IO_MUX_CONF.Reg, volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SENS_Type) GetSAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN() uint32 {
	return (volatile.LoadUint32(&o.SAR_IO_MUX_CONF.Reg) & 0x80000000) >> 31
}

// SENS.SARDATE: Version Control Register
func (o *SENS_Type) SetSARDATE_SAR_DATE(value uint32) {
	volatile.StoreUint32(&o.SARDATE.Reg, volatile.LoadUint32(&o.SARDATE.Reg)&^(0xfffffff)|value)
}
func (o *SENS_Type) GetSARDATE_SAR_DATE() uint32 {
	return volatile.LoadUint32(&o.SARDATE.Reg) & 0xfffffff
}

// SHA (Secure Hash Algorithm) Accelerator
type SHA_Type struct {
	MODE          volatile.Register32 // 0x0
	T_STRING      volatile.Register32 // 0x4
	T_LENGTH      volatile.Register32 // 0x8
	DMA_BLOCK_NUM volatile.Register32 // 0xC
	START         volatile.Register32 // 0x10
	CONTINUE      volatile.Register32 // 0x14
	BUSY          volatile.Register32 // 0x18
	DMA_START     volatile.Register32 // 0x1C
	DMA_CONTINUE  volatile.Register32 // 0x20
	INT_CLEAR     volatile.Register32 // 0x24
	INT_ENA       volatile.Register32 // 0x28
	DATE          volatile.Register32 // 0x2C
	_             [16]byte
	H_MEM0        volatile.Register32 // 0x40
	H_MEM1        volatile.Register32 // 0x44
	H_MEM2        volatile.Register32 // 0x48
	H_MEM3        volatile.Register32 // 0x4C
	H_MEM4        volatile.Register32 // 0x50
	H_MEM5        volatile.Register32 // 0x54
	H_MEM6        volatile.Register32 // 0x58
	H_MEM7        volatile.Register32 // 0x5C
	H_MEM8        volatile.Register32 // 0x60
	H_MEM9        volatile.Register32 // 0x64
	H_MEM10       volatile.Register32 // 0x68
	H_MEM11       volatile.Register32 // 0x6C
	H_MEM12       volatile.Register32 // 0x70
	H_MEM13       volatile.Register32 // 0x74
	H_MEM14       volatile.Register32 // 0x78
	H_MEM15       volatile.Register32 // 0x7C
	M_MEM0        volatile.Register32 // 0x80
	M_MEM1        volatile.Register32 // 0x84
	M_MEM2        volatile.Register32 // 0x88
	M_MEM3        volatile.Register32 // 0x8C
	M_MEM4        volatile.Register32 // 0x90
	M_MEM5        volatile.Register32 // 0x94
	M_MEM6        volatile.Register32 // 0x98
	M_MEM7        volatile.Register32 // 0x9C
	M_MEM8        volatile.Register32 // 0xA0
	M_MEM9        volatile.Register32 // 0xA4
	M_MEM10       volatile.Register32 // 0xA8
	M_MEM11       volatile.Register32 // 0xAC
	M_MEM12       volatile.Register32 // 0xB0
	M_MEM13       volatile.Register32 // 0xB4
	M_MEM14       volatile.Register32 // 0xB8
	M_MEM15       volatile.Register32 // 0xBC
	M_MEM16       volatile.Register32 // 0xC0
	M_MEM17       volatile.Register32 // 0xC4
	M_MEM18       volatile.Register32 // 0xC8
	M_MEM19       volatile.Register32 // 0xCC
	M_MEM20       volatile.Register32 // 0xD0
	M_MEM21       volatile.Register32 // 0xD4
	M_MEM22       volatile.Register32 // 0xD8
	M_MEM23       volatile.Register32 // 0xDC
	M_MEM24       volatile.Register32 // 0xE0
	M_MEM25       volatile.Register32 // 0xE4
	M_MEM26       volatile.Register32 // 0xE8
	M_MEM27       volatile.Register32 // 0xEC
	M_MEM28       volatile.Register32 // 0xF0
	M_MEM29       volatile.Register32 // 0xF4
	M_MEM30       volatile.Register32 // 0xF8
	M_MEM31       volatile.Register32 // 0xFC
}

// SHA.MODE: Defines the algorithm of SHA accelerator
func (o *SHA_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x7)|value)
}
func (o *SHA_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x7
}

// SHA.T_STRING: String content register for calculating initial Hash Value (only effective for SHA-512/t)
func (o *SHA_Type) SetT_STRING(value uint32) {
	volatile.StoreUint32(&o.T_STRING.Reg, value)
}
func (o *SHA_Type) GetT_STRING() uint32 {
	return volatile.LoadUint32(&o.T_STRING.Reg)
}

// SHA.T_LENGTH: String length register for calculating initial Hash Value (only effective for SHA-512/t)
func (o *SHA_Type) SetT_LENGTH(value uint32) {
	volatile.StoreUint32(&o.T_LENGTH.Reg, volatile.LoadUint32(&o.T_LENGTH.Reg)&^(0x3f)|value)
}
func (o *SHA_Type) GetT_LENGTH() uint32 {
	return volatile.LoadUint32(&o.T_LENGTH.Reg) & 0x3f
}

// SHA.DMA_BLOCK_NUM: Block number register (only effective for DMA-SHA)
func (o *SHA_Type) SetDMA_BLOCK_NUM(value uint32) {
	volatile.StoreUint32(&o.DMA_BLOCK_NUM.Reg, volatile.LoadUint32(&o.DMA_BLOCK_NUM.Reg)&^(0x3f)|value)
}
func (o *SHA_Type) GetDMA_BLOCK_NUM() uint32 {
	return volatile.LoadUint32(&o.DMA_BLOCK_NUM.Reg) & 0x3f
}

// SHA.START: Starts the SHA accelerator for Typical SHA operation
func (o *SHA_Type) SetSTART(value uint32) {
	volatile.StoreUint32(&o.START.Reg, volatile.LoadUint32(&o.START.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetSTART() uint32 {
	return volatile.LoadUint32(&o.START.Reg) & 0x1
}

// SHA.CONTINUE: Continues SHA operation (only effective in Typical SHA mode)
func (o *SHA_Type) SetCONTINUE_CONTINUE_OP(value uint32) {
	volatile.StoreUint32(&o.CONTINUE.Reg, volatile.LoadUint32(&o.CONTINUE.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetCONTINUE_CONTINUE_OP() uint32 {
	return volatile.LoadUint32(&o.CONTINUE.Reg) & 0x1
}

// SHA.BUSY: Indicates if SHA Accelerator is busy or not
func (o *SHA_Type) SetBUSY_STATE(value uint32) {
	volatile.StoreUint32(&o.BUSY.Reg, volatile.LoadUint32(&o.BUSY.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetBUSY_STATE() uint32 {
	return volatile.LoadUint32(&o.BUSY.Reg) & 0x1
}

// SHA.DMA_START: Starts the SHA accelerator for DMA-SHA operation
func (o *SHA_Type) SetDMA_START(value uint32) {
	volatile.StoreUint32(&o.DMA_START.Reg, volatile.LoadUint32(&o.DMA_START.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetDMA_START() uint32 {
	return volatile.LoadUint32(&o.DMA_START.Reg) & 0x1
}

// SHA.DMA_CONTINUE: Continues SHA operation (only effective in DMA-SHA mode)
func (o *SHA_Type) SetDMA_CONTINUE(value uint32) {
	volatile.StoreUint32(&o.DMA_CONTINUE.Reg, volatile.LoadUint32(&o.DMA_CONTINUE.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetDMA_CONTINUE() uint32 {
	return volatile.LoadUint32(&o.DMA_CONTINUE.Reg) & 0x1
}

// SHA.INT_CLEAR: DMA-SHA interrupt clear register
func (o *SHA_Type) SetINT_CLEAR_CLEAR_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.INT_CLEAR.Reg, volatile.LoadUint32(&o.INT_CLEAR.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetINT_CLEAR_CLEAR_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.INT_CLEAR.Reg) & 0x1
}

// SHA.INT_ENA: DMA-SHA interrupt enable register
func (o *SHA_Type) SetINT_ENA_INTERRUPT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *SHA_Type) GetINT_ENA_INTERRUPT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}

// SHA.DATE: Version control register
func (o *SHA_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *SHA_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// SHA.H_MEM0: Hash value
func (o *SHA_Type) SetH_MEM0(value uint32) {
	volatile.StoreUint32(&o.H_MEM0.Reg, value)
}
func (o *SHA_Type) GetH_MEM0() uint32 {
	return volatile.LoadUint32(&o.H_MEM0.Reg)
}

// SHA.H_MEM1: Hash value
func (o *SHA_Type) SetH_MEM1(value uint32) {
	volatile.StoreUint32(&o.H_MEM1.Reg, value)
}
func (o *SHA_Type) GetH_MEM1() uint32 {
	return volatile.LoadUint32(&o.H_MEM1.Reg)
}

// SHA.H_MEM2: Hash value
func (o *SHA_Type) SetH_MEM2(value uint32) {
	volatile.StoreUint32(&o.H_MEM2.Reg, value)
}
func (o *SHA_Type) GetH_MEM2() uint32 {
	return volatile.LoadUint32(&o.H_MEM2.Reg)
}

// SHA.H_MEM3: Hash value
func (o *SHA_Type) SetH_MEM3(value uint32) {
	volatile.StoreUint32(&o.H_MEM3.Reg, value)
}
func (o *SHA_Type) GetH_MEM3() uint32 {
	return volatile.LoadUint32(&o.H_MEM3.Reg)
}

// SHA.H_MEM4: Hash value
func (o *SHA_Type) SetH_MEM4(value uint32) {
	volatile.StoreUint32(&o.H_MEM4.Reg, value)
}
func (o *SHA_Type) GetH_MEM4() uint32 {
	return volatile.LoadUint32(&o.H_MEM4.Reg)
}

// SHA.H_MEM5: Hash value
func (o *SHA_Type) SetH_MEM5(value uint32) {
	volatile.StoreUint32(&o.H_MEM5.Reg, value)
}
func (o *SHA_Type) GetH_MEM5() uint32 {
	return volatile.LoadUint32(&o.H_MEM5.Reg)
}

// SHA.H_MEM6: Hash value
func (o *SHA_Type) SetH_MEM6(value uint32) {
	volatile.StoreUint32(&o.H_MEM6.Reg, value)
}
func (o *SHA_Type) GetH_MEM6() uint32 {
	return volatile.LoadUint32(&o.H_MEM6.Reg)
}

// SHA.H_MEM7: Hash value
func (o *SHA_Type) SetH_MEM7(value uint32) {
	volatile.StoreUint32(&o.H_MEM7.Reg, value)
}
func (o *SHA_Type) GetH_MEM7() uint32 {
	return volatile.LoadUint32(&o.H_MEM7.Reg)
}

// SHA.H_MEM8: Hash value
func (o *SHA_Type) SetH_MEM8(value uint32) {
	volatile.StoreUint32(&o.H_MEM8.Reg, value)
}
func (o *SHA_Type) GetH_MEM8() uint32 {
	return volatile.LoadUint32(&o.H_MEM8.Reg)
}

// SHA.H_MEM9: Hash value
func (o *SHA_Type) SetH_MEM9(value uint32) {
	volatile.StoreUint32(&o.H_MEM9.Reg, value)
}
func (o *SHA_Type) GetH_MEM9() uint32 {
	return volatile.LoadUint32(&o.H_MEM9.Reg)
}

// SHA.H_MEM10: Hash value
func (o *SHA_Type) SetH_MEM10(value uint32) {
	volatile.StoreUint32(&o.H_MEM10.Reg, value)
}
func (o *SHA_Type) GetH_MEM10() uint32 {
	return volatile.LoadUint32(&o.H_MEM10.Reg)
}

// SHA.H_MEM11: Hash value
func (o *SHA_Type) SetH_MEM11(value uint32) {
	volatile.StoreUint32(&o.H_MEM11.Reg, value)
}
func (o *SHA_Type) GetH_MEM11() uint32 {
	return volatile.LoadUint32(&o.H_MEM11.Reg)
}

// SHA.H_MEM12: Hash value
func (o *SHA_Type) SetH_MEM12(value uint32) {
	volatile.StoreUint32(&o.H_MEM12.Reg, value)
}
func (o *SHA_Type) GetH_MEM12() uint32 {
	return volatile.LoadUint32(&o.H_MEM12.Reg)
}

// SHA.H_MEM13: Hash value
func (o *SHA_Type) SetH_MEM13(value uint32) {
	volatile.StoreUint32(&o.H_MEM13.Reg, value)
}
func (o *SHA_Type) GetH_MEM13() uint32 {
	return volatile.LoadUint32(&o.H_MEM13.Reg)
}

// SHA.H_MEM14: Hash value
func (o *SHA_Type) SetH_MEM14(value uint32) {
	volatile.StoreUint32(&o.H_MEM14.Reg, value)
}
func (o *SHA_Type) GetH_MEM14() uint32 {
	return volatile.LoadUint32(&o.H_MEM14.Reg)
}

// SHA.H_MEM15: Hash value
func (o *SHA_Type) SetH_MEM15(value uint32) {
	volatile.StoreUint32(&o.H_MEM15.Reg, value)
}
func (o *SHA_Type) GetH_MEM15() uint32 {
	return volatile.LoadUint32(&o.H_MEM15.Reg)
}

// SHA.M_MEM0: Message
func (o *SHA_Type) SetM_MEM0(value uint32) {
	volatile.StoreUint32(&o.M_MEM0.Reg, value)
}
func (o *SHA_Type) GetM_MEM0() uint32 {
	return volatile.LoadUint32(&o.M_MEM0.Reg)
}

// SHA.M_MEM1: Message
func (o *SHA_Type) SetM_MEM1(value uint32) {
	volatile.StoreUint32(&o.M_MEM1.Reg, value)
}
func (o *SHA_Type) GetM_MEM1() uint32 {
	return volatile.LoadUint32(&o.M_MEM1.Reg)
}

// SHA.M_MEM2: Message
func (o *SHA_Type) SetM_MEM2(value uint32) {
	volatile.StoreUint32(&o.M_MEM2.Reg, value)
}
func (o *SHA_Type) GetM_MEM2() uint32 {
	return volatile.LoadUint32(&o.M_MEM2.Reg)
}

// SHA.M_MEM3: Message
func (o *SHA_Type) SetM_MEM3(value uint32) {
	volatile.StoreUint32(&o.M_MEM3.Reg, value)
}
func (o *SHA_Type) GetM_MEM3() uint32 {
	return volatile.LoadUint32(&o.M_MEM3.Reg)
}

// SHA.M_MEM4: Message
func (o *SHA_Type) SetM_MEM4(value uint32) {
	volatile.StoreUint32(&o.M_MEM4.Reg, value)
}
func (o *SHA_Type) GetM_MEM4() uint32 {
	return volatile.LoadUint32(&o.M_MEM4.Reg)
}

// SHA.M_MEM5: Message
func (o *SHA_Type) SetM_MEM5(value uint32) {
	volatile.StoreUint32(&o.M_MEM5.Reg, value)
}
func (o *SHA_Type) GetM_MEM5() uint32 {
	return volatile.LoadUint32(&o.M_MEM5.Reg)
}

// SHA.M_MEM6: Message
func (o *SHA_Type) SetM_MEM6(value uint32) {
	volatile.StoreUint32(&o.M_MEM6.Reg, value)
}
func (o *SHA_Type) GetM_MEM6() uint32 {
	return volatile.LoadUint32(&o.M_MEM6.Reg)
}

// SHA.M_MEM7: Message
func (o *SHA_Type) SetM_MEM7(value uint32) {
	volatile.StoreUint32(&o.M_MEM7.Reg, value)
}
func (o *SHA_Type) GetM_MEM7() uint32 {
	return volatile.LoadUint32(&o.M_MEM7.Reg)
}

// SHA.M_MEM8: Message
func (o *SHA_Type) SetM_MEM8(value uint32) {
	volatile.StoreUint32(&o.M_MEM8.Reg, value)
}
func (o *SHA_Type) GetM_MEM8() uint32 {
	return volatile.LoadUint32(&o.M_MEM8.Reg)
}

// SHA.M_MEM9: Message
func (o *SHA_Type) SetM_MEM9(value uint32) {
	volatile.StoreUint32(&o.M_MEM9.Reg, value)
}
func (o *SHA_Type) GetM_MEM9() uint32 {
	return volatile.LoadUint32(&o.M_MEM9.Reg)
}

// SHA.M_MEM10: Message
func (o *SHA_Type) SetM_MEM10(value uint32) {
	volatile.StoreUint32(&o.M_MEM10.Reg, value)
}
func (o *SHA_Type) GetM_MEM10() uint32 {
	return volatile.LoadUint32(&o.M_MEM10.Reg)
}

// SHA.M_MEM11: Message
func (o *SHA_Type) SetM_MEM11(value uint32) {
	volatile.StoreUint32(&o.M_MEM11.Reg, value)
}
func (o *SHA_Type) GetM_MEM11() uint32 {
	return volatile.LoadUint32(&o.M_MEM11.Reg)
}

// SHA.M_MEM12: Message
func (o *SHA_Type) SetM_MEM12(value uint32) {
	volatile.StoreUint32(&o.M_MEM12.Reg, value)
}
func (o *SHA_Type) GetM_MEM12() uint32 {
	return volatile.LoadUint32(&o.M_MEM12.Reg)
}

// SHA.M_MEM13: Message
func (o *SHA_Type) SetM_MEM13(value uint32) {
	volatile.StoreUint32(&o.M_MEM13.Reg, value)
}
func (o *SHA_Type) GetM_MEM13() uint32 {
	return volatile.LoadUint32(&o.M_MEM13.Reg)
}

// SHA.M_MEM14: Message
func (o *SHA_Type) SetM_MEM14(value uint32) {
	volatile.StoreUint32(&o.M_MEM14.Reg, value)
}
func (o *SHA_Type) GetM_MEM14() uint32 {
	return volatile.LoadUint32(&o.M_MEM14.Reg)
}

// SHA.M_MEM15: Message
func (o *SHA_Type) SetM_MEM15(value uint32) {
	volatile.StoreUint32(&o.M_MEM15.Reg, value)
}
func (o *SHA_Type) GetM_MEM15() uint32 {
	return volatile.LoadUint32(&o.M_MEM15.Reg)
}

// SHA.M_MEM16: Message
func (o *SHA_Type) SetM_MEM16(value uint32) {
	volatile.StoreUint32(&o.M_MEM16.Reg, value)
}
func (o *SHA_Type) GetM_MEM16() uint32 {
	return volatile.LoadUint32(&o.M_MEM16.Reg)
}

// SHA.M_MEM17: Message
func (o *SHA_Type) SetM_MEM17(value uint32) {
	volatile.StoreUint32(&o.M_MEM17.Reg, value)
}
func (o *SHA_Type) GetM_MEM17() uint32 {
	return volatile.LoadUint32(&o.M_MEM17.Reg)
}

// SHA.M_MEM18: Message
func (o *SHA_Type) SetM_MEM18(value uint32) {
	volatile.StoreUint32(&o.M_MEM18.Reg, value)
}
func (o *SHA_Type) GetM_MEM18() uint32 {
	return volatile.LoadUint32(&o.M_MEM18.Reg)
}

// SHA.M_MEM19: Message
func (o *SHA_Type) SetM_MEM19(value uint32) {
	volatile.StoreUint32(&o.M_MEM19.Reg, value)
}
func (o *SHA_Type) GetM_MEM19() uint32 {
	return volatile.LoadUint32(&o.M_MEM19.Reg)
}

// SHA.M_MEM20: Message
func (o *SHA_Type) SetM_MEM20(value uint32) {
	volatile.StoreUint32(&o.M_MEM20.Reg, value)
}
func (o *SHA_Type) GetM_MEM20() uint32 {
	return volatile.LoadUint32(&o.M_MEM20.Reg)
}

// SHA.M_MEM21: Message
func (o *SHA_Type) SetM_MEM21(value uint32) {
	volatile.StoreUint32(&o.M_MEM21.Reg, value)
}
func (o *SHA_Type) GetM_MEM21() uint32 {
	return volatile.LoadUint32(&o.M_MEM21.Reg)
}

// SHA.M_MEM22: Message
func (o *SHA_Type) SetM_MEM22(value uint32) {
	volatile.StoreUint32(&o.M_MEM22.Reg, value)
}
func (o *SHA_Type) GetM_MEM22() uint32 {
	return volatile.LoadUint32(&o.M_MEM22.Reg)
}

// SHA.M_MEM23: Message
func (o *SHA_Type) SetM_MEM23(value uint32) {
	volatile.StoreUint32(&o.M_MEM23.Reg, value)
}
func (o *SHA_Type) GetM_MEM23() uint32 {
	return volatile.LoadUint32(&o.M_MEM23.Reg)
}

// SHA.M_MEM24: Message
func (o *SHA_Type) SetM_MEM24(value uint32) {
	volatile.StoreUint32(&o.M_MEM24.Reg, value)
}
func (o *SHA_Type) GetM_MEM24() uint32 {
	return volatile.LoadUint32(&o.M_MEM24.Reg)
}

// SHA.M_MEM25: Message
func (o *SHA_Type) SetM_MEM25(value uint32) {
	volatile.StoreUint32(&o.M_MEM25.Reg, value)
}
func (o *SHA_Type) GetM_MEM25() uint32 {
	return volatile.LoadUint32(&o.M_MEM25.Reg)
}

// SHA.M_MEM26: Message
func (o *SHA_Type) SetM_MEM26(value uint32) {
	volatile.StoreUint32(&o.M_MEM26.Reg, value)
}
func (o *SHA_Type) GetM_MEM26() uint32 {
	return volatile.LoadUint32(&o.M_MEM26.Reg)
}

// SHA.M_MEM27: Message
func (o *SHA_Type) SetM_MEM27(value uint32) {
	volatile.StoreUint32(&o.M_MEM27.Reg, value)
}
func (o *SHA_Type) GetM_MEM27() uint32 {
	return volatile.LoadUint32(&o.M_MEM27.Reg)
}

// SHA.M_MEM28: Message
func (o *SHA_Type) SetM_MEM28(value uint32) {
	volatile.StoreUint32(&o.M_MEM28.Reg, value)
}
func (o *SHA_Type) GetM_MEM28() uint32 {
	return volatile.LoadUint32(&o.M_MEM28.Reg)
}

// SHA.M_MEM29: Message
func (o *SHA_Type) SetM_MEM29(value uint32) {
	volatile.StoreUint32(&o.M_MEM29.Reg, value)
}
func (o *SHA_Type) GetM_MEM29() uint32 {
	return volatile.LoadUint32(&o.M_MEM29.Reg)
}

// SHA.M_MEM30: Message
func (o *SHA_Type) SetM_MEM30(value uint32) {
	volatile.StoreUint32(&o.M_MEM30.Reg, value)
}
func (o *SHA_Type) GetM_MEM30() uint32 {
	return volatile.LoadUint32(&o.M_MEM30.Reg)
}

// SHA.M_MEM31: Message
func (o *SHA_Type) SetM_MEM31(value uint32) {
	volatile.StoreUint32(&o.M_MEM31.Reg, value)
}
func (o *SHA_Type) GetM_MEM31() uint32 {
	return volatile.LoadUint32(&o.M_MEM31.Reg)
}

// SPI (Serial Peripheral Interface) Controller 0
type SPI_Type struct {
	CMD                  volatile.Register32 // 0x0
	ADDR                 volatile.Register32 // 0x4
	CTRL                 volatile.Register32 // 0x8
	CTRL1                volatile.Register32 // 0xC
	CTRL2                volatile.Register32 // 0x10
	CLOCK                volatile.Register32 // 0x14
	USER                 volatile.Register32 // 0x18
	USER1                volatile.Register32 // 0x1C
	USER2                volatile.Register32 // 0x20
	MOSI_DLEN            volatile.Register32 // 0x24
	MISO_DLEN            volatile.Register32 // 0x28
	MISC                 volatile.Register32 // 0x2C
	SLAVE                volatile.Register32 // 0x30
	SLAVE1               volatile.Register32 // 0x34
	SLV_WRBUF_DLEN       volatile.Register32 // 0x38
	SLV_RDBUF_DLEN       volatile.Register32 // 0x3C
	SLV_RD_BYTE          volatile.Register32 // 0x40
	FSM                  volatile.Register32 // 0x44
	HOLD                 volatile.Register32 // 0x48
	DMA_CONF             volatile.Register32 // 0x4C
	DMA_OUT_LINK         volatile.Register32 // 0x50
	DMA_IN_LINK          volatile.Register32 // 0x54
	DMA_INT_ENA          volatile.Register32 // 0x58
	DMA_INT_RAW          volatile.Register32 // 0x5C
	DMA_INT_ST           volatile.Register32 // 0x60
	DMA_INT_CLR          volatile.Register32 // 0x64
	IN_ERR_EOF_DES_ADDR  volatile.Register32 // 0x68
	IN_SUC_EOF_DES_ADDR  volatile.Register32 // 0x6C
	INLINK_DSCR          volatile.Register32 // 0x70
	INLINK_DSCR_BF0      volatile.Register32 // 0x74
	INLINK_DSCR_BF1      volatile.Register32 // 0x78
	OUT_EOF_BFR_DES_ADDR volatile.Register32 // 0x7C
	OUT_EOF_DES_ADDR     volatile.Register32 // 0x80
	OUTLINK_DSCR         volatile.Register32 // 0x84
	OUTLINK_DSCR_BF0     volatile.Register32 // 0x88
	OUTLINK_DSCR_BF1     volatile.Register32 // 0x8C
	DMA_OUTSTATUS        volatile.Register32 // 0x90
	DMA_INSTATUS         volatile.Register32 // 0x94
	W0                   volatile.Register32 // 0x98
	W1                   volatile.Register32 // 0x9C
	W2                   volatile.Register32 // 0xA0
	W3                   volatile.Register32 // 0xA4
	W4                   volatile.Register32 // 0xA8
	W5                   volatile.Register32 // 0xAC
	W6                   volatile.Register32 // 0xB0
	W7                   volatile.Register32 // 0xB4
	W8                   volatile.Register32 // 0xB8
	W9                   volatile.Register32 // 0xBC
	W10                  volatile.Register32 // 0xC0
	W11                  volatile.Register32 // 0xC4
	W12                  volatile.Register32 // 0xC8
	W13                  volatile.Register32 // 0xCC
	W14                  volatile.Register32 // 0xD0
	W15                  volatile.Register32 // 0xD4
	W16                  volatile.Register32 // 0xD8
	W17                  volatile.Register32 // 0xDC
	DIN_MODE             volatile.Register32 // 0xE0
	DIN_NUM              volatile.Register32 // 0xE4
	DOUT_MODE            volatile.Register32 // 0xE8
	DOUT_NUM             volatile.Register32 // 0xEC
	LCD_CTRL             volatile.Register32 // 0xF0
	LCD_CTRL1            volatile.Register32 // 0xF4
	LCD_CTRL2            volatile.Register32 // 0xF8
	LCD_D_MODE           volatile.Register32 // 0xFC
	LCD_D_NUM            volatile.Register32 // 0x100
	_                    [760]byte
	REG_DATE             volatile.Register32 // 0x3FC
}

// SPI.CMD: Command control register
func (o *SPI_Type) SetCMD_CONF_BITLEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x7fffff)|value)
}
func (o *SPI_Type) GetCMD_CONF_BITLEN() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x7fffff
}
func (o *SPI_Type) SetCMD_USR(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCMD_USR() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x1000000) >> 24
}

// SPI.ADDR: Address value
func (o *SPI_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *SPI_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// SPI.CTRL: SPI control register
func (o *SPI_Type) SetCTRL_EXT_HOLD_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCTRL_EXT_HOLD_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCTRL_DUMMY_OUT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCTRL_DUMMY_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCTRL_FADDR_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCTRL_FADDR_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCTRL_FADDR_QUAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCTRL_FADDR_QUAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCTRL_FADDR_OCT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCTRL_FADDR_OCT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCTRL_FCMD_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCTRL_FCMD_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCTRL_FCMD_QUAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCTRL_FCMD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCTRL_FCMD_OCT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCTRL_FCMD_OCT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCTRL_FREAD_DUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCTRL_FREAD_DUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCTRL_FREAD_QUAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCTRL_FREAD_QUAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCTRL_FREAD_OCT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetCTRL_FREAD_OCT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetCTRL_Q_POL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetCTRL_Q_POL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetCTRL_D_POL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetCTRL_D_POL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetCTRL_WP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetCTRL_WP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetCTRL_RD_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetCTRL_RD_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetCTRL_WR_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetCTRL_WR_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}

// SPI.CTRL1: SPI control register 1
func (o *SPI_Type) SetCTRL1_CLK_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x3)|value)
}
func (o *SPI_Type) GetCTRL1_CLK_MODE() uint32 {
	return volatile.LoadUint32(&o.CTRL1.Reg) & 0x3
}
func (o *SPI_Type) SetCTRL1_CLK_MODE_13(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCTRL1_CLK_MODE_13() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCTRL1_RSCK_DATA_OUT(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCTRL1_RSCK_DATA_OUT() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCTRL1_W16_17_WR_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetCTRL1_W16_17_WR_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetCTRL1_CS_HOLD_DELAY(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xfc000)|value<<14)
}
func (o *SPI_Type) GetCTRL1_CS_HOLD_DELAY() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xfc000) >> 14
}

// SPI.CTRL2: SPI control register 2
func (o *SPI_Type) SetCTRL2_CS_SETUP_TIME(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1fff)|value)
}
func (o *SPI_Type) GetCTRL2_CS_SETUP_TIME() uint32 {
	return volatile.LoadUint32(&o.CTRL2.Reg) & 0x1fff
}
func (o *SPI_Type) SetCTRL2_CS_HOLD_TIME(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x3ffe000)|value<<13)
}
func (o *SPI_Type) GetCTRL2_CS_HOLD_TIME() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x3ffe000) >> 13
}
func (o *SPI_Type) SetCTRL2_CS_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x1c000000)|value<<26)
}
func (o *SPI_Type) GetCTRL2_CS_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x1c000000) >> 26
}
func (o *SPI_Type) SetCTRL2_CS_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.CTRL2.Reg, volatile.LoadUint32(&o.CTRL2.Reg)&^(0x60000000)|value<<29)
}
func (o *SPI_Type) GetCTRL2_CS_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CTRL2.Reg) & 0x60000000) >> 29
}

// SPI.CLOCK: SPI clock control register
func (o *SPI_Type) SetCLOCK_CLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3f)|value)
}
func (o *SPI_Type) GetCLOCK_CLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0x3f
}
func (o *SPI_Type) SetCLOCK_CLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xfc0)|value<<6)
}
func (o *SPI_Type) GetCLOCK_CLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xfc0) >> 6
}
func (o *SPI_Type) SetCLOCK_CLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3f000)|value<<12)
}
func (o *SPI_Type) GetCLOCK_CLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x3f000) >> 12
}
func (o *SPI_Type) SetCLOCK_CLKDIV_PRE(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x7ffc0000)|value<<18)
}
func (o *SPI_Type) GetCLOCK_CLKDIV_PRE() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x7ffc0000) >> 18
}
func (o *SPI_Type) SetCLOCK_CLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetCLOCK_CLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x80000000) >> 31
}

// SPI.USER: SPI USER control register
func (o *SPI_Type) SetUSER_DOUTDIN(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetUSER_DOUTDIN() uint32 {
	return volatile.LoadUint32(&o.USER.Reg) & 0x1
}
func (o *SPI_Type) SetUSER_QPI_MODE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetUSER_QPI_MODE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetUSER_OPI_MODE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetUSER_OPI_MODE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetUSER_TSCK_I_EDGE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetUSER_TSCK_I_EDGE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetUSER_CS_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetUSER_CS_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetUSER_CS_SETUP(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetUSER_CS_SETUP() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetUSER_RSCK_I_EDGE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetUSER_RSCK_I_EDGE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetUSER_CK_OUT_EDGE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetUSER_CK_OUT_EDGE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetUSER_RD_BYTE_ORDER(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetUSER_RD_BYTE_ORDER() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetUSER_WR_BYTE_ORDER(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetUSER_WR_BYTE_ORDER() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetUSER_FWRITE_DUAL(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetUSER_FWRITE_DUAL() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetUSER_FWRITE_QUAD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetUSER_FWRITE_QUAD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetUSER_FWRITE_OCT(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetUSER_FWRITE_OCT() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetUSER_USR_CONF_NXT(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetUSER_USR_CONF_NXT() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetUSER_SIO(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetUSER_SIO() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetUSER_USR_HOLD_POL(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetUSER_USR_HOLD_POL() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetUSER_USR_DOUT_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetUSER_USR_DOUT_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetUSER_USR_DIN_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetUSER_USR_DIN_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetUSER_USR_DUMMY_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetUSER_USR_DUMMY_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetUSER_USR_ADDR_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetUSER_USR_ADDR_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetUSER_USR_CMD_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetUSER_USR_CMD_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetUSER_USR_PREP_HOLD(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x800000)|value<<23)
}
func (o *SPI_Type) GetUSER_USR_PREP_HOLD() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x800000) >> 23
}
func (o *SPI_Type) SetUSER_USR_MISO_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetUSER_USR_MISO_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetUSER_USR_MOSI_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetUSER_USR_MOSI_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetUSER_USR_DUMMY_IDLE(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetUSER_USR_DUMMY_IDLE() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetUSER_USR_MOSI(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI_Type) GetUSER_USR_MOSI() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x8000000) >> 27
}
func (o *SPI_Type) SetUSER_USR_MISO(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetUSER_USR_MISO() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetUSER_USR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI_Type) GetUSER_USR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x20000000) >> 29
}
func (o *SPI_Type) SetUSER_USR_ADDR(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetUSER_USR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetUSER_USR_COMMAND(value uint32) {
	volatile.StoreUint32(&o.USER.Reg, volatile.LoadUint32(&o.USER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetUSER_USR_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.USER.Reg) & 0x80000000) >> 31
}

// SPI.USER1: SPI USER control register 1
func (o *SPI_Type) SetUSER1_USR_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetUSER1_USR_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.USER1.Reg) & 0xff
}
func (o *SPI_Type) SetUSER1_USR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.USER1.Reg, volatile.LoadUint32(&o.USER1.Reg)&^(0xf8000000)|value<<27)
}
func (o *SPI_Type) GetUSER1_USR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.USER1.Reg) & 0xf8000000) >> 27
}

// SPI.USER2: SPI USER control register 2
func (o *SPI_Type) SetUSER2_USR_COMMAND_VALUE(value uint32) {
	volatile.StoreUint32(&o.USER2.Reg, volatile.LoadUint32(&o.USER2.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetUSER2_USR_COMMAND_VALUE() uint32 {
	return volatile.LoadUint32(&o.USER2.Reg) & 0xffff
}
func (o *SPI_Type) SetUSER2_USR_COMMAND_BITLEN(value uint32) {
	volatile.StoreUint32(&o.USER2.Reg, volatile.LoadUint32(&o.USER2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI_Type) GetUSER2_USR_COMMAND_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.USER2.Reg) & 0xf0000000) >> 28
}

// SPI.MOSI_DLEN: MOSI length
func (o *SPI_Type) SetMOSI_DLEN_USR_MOSI_DBITLEN(value uint32) {
	volatile.StoreUint32(&o.MOSI_DLEN.Reg, volatile.LoadUint32(&o.MOSI_DLEN.Reg)&^(0x7fffff)|value)
}
func (o *SPI_Type) GetMOSI_DLEN_USR_MOSI_DBITLEN() uint32 {
	return volatile.LoadUint32(&o.MOSI_DLEN.Reg) & 0x7fffff
}

// SPI.MISO_DLEN: MISO length
func (o *SPI_Type) SetMISO_DLEN_USR_MISO_DBITLEN(value uint32) {
	volatile.StoreUint32(&o.MISO_DLEN.Reg, volatile.LoadUint32(&o.MISO_DLEN.Reg)&^(0x7fffff)|value)
}
func (o *SPI_Type) GetMISO_DLEN_USR_MISO_DBITLEN() uint32 {
	return volatile.LoadUint32(&o.MISO_DLEN.Reg) & 0x7fffff
}

// SPI.MISC: SPI misc register
func (o *SPI_Type) SetMISC_CS0_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMISC_CS0_DIS() uint32 {
	return volatile.LoadUint32(&o.MISC.Reg) & 0x1
}
func (o *SPI_Type) SetMISC_CS1_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetMISC_CS1_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetMISC_CS2_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetMISC_CS2_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetMISC_CS3_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetMISC_CS3_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetMISC_CS4_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetMISC_CS4_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetMISC_CS5_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetMISC_CS5_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetMISC_CK_DIS(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetMISC_CK_DIS() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetMISC_MASTER_CS_POL(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1f80)|value<<7)
}
func (o *SPI_Type) GetMISC_MASTER_CS_POL() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x1f80) >> 7
}
func (o *SPI_Type) SetMISC_CLK_DATA_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetMISC_CLK_DATA_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetMISC_DATA_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetMISC_DATA_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetMISC_ADDR_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetMISC_ADDR_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetMISC_CMD_DTR_EN(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetMISC_CMD_DTR_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetMISC_CD_DATA_SET(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetMISC_CD_DATA_SET() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetMISC_CD_DUMMY_SET(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetMISC_CD_DUMMY_SET() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetMISC_CD_ADDR_SET(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetMISC_CD_ADDR_SET() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetMISC_SLAVE_CS_POL(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x800000)|value<<23)
}
func (o *SPI_Type) GetMISC_SLAVE_CS_POL() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x800000) >> 23
}
func (o *SPI_Type) SetMISC_DQS_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetMISC_DQS_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetMISC_CD_CMD_SET(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetMISC_CD_CMD_SET() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x2000000) >> 25
}
func (o *SPI_Type) SetMISC_CD_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI_Type) GetMISC_CD_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x4000000) >> 26
}
func (o *SPI_Type) SetMISC_CK_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI_Type) GetMISC_CK_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x20000000) >> 29
}
func (o *SPI_Type) SetMISC_CS_KEEP_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetMISC_CS_KEEP_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetMISC_QUAD_DIN_PIN_SWAP(value uint32) {
	volatile.StoreUint32(&o.MISC.Reg, volatile.LoadUint32(&o.MISC.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetMISC_QUAD_DIN_PIN_SWAP() uint32 {
	return (volatile.LoadUint32(&o.MISC.Reg) & 0x80000000) >> 31
}

// SPI.SLAVE: SPI slave control register
func (o *SPI_Type) SetSLAVE_TRANS_DONE(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSLAVE_TRANS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSLAVE_INT_RD_BUF_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSLAVE_INT_RD_BUF_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSLAVE_INT_WR_BUF_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSLAVE_INT_WR_BUF_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSLAVE_INT_RD_DMA_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSLAVE_INT_RD_DMA_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSLAVE_INT_WR_DMA_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSLAVE_INT_WR_DMA_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSLAVE_INT_TRANS_DONE_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetSLAVE_INT_TRANS_DONE_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetSLAVE_INT_DMA_SEG_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetSLAVE_INT_DMA_SEG_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetSLAVE_SEG_MAGIC_ERR_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetSLAVE_SEG_MAGIC_ERR_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetSLAVE_TRANS_CNT(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x7800000)|value<<23)
}
func (o *SPI_Type) GetSLAVE_TRANS_CNT() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x7800000) >> 23
}
func (o *SPI_Type) SetSLAVE_TRANS_DONE_AUTO_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI_Type) GetSLAVE_TRANS_DONE_AUTO_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x20000000) >> 29
}
func (o *SPI_Type) SetSLAVE_MODE(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetSLAVE_MODE() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetSLAVE_SOFT_RESET(value uint32) {
	volatile.StoreUint32(&o.SLAVE.Reg, volatile.LoadUint32(&o.SLAVE.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetSLAVE_SOFT_RESET() uint32 {
	return (volatile.LoadUint32(&o.SLAVE.Reg) & 0x80000000) >> 31
}

// SPI.SLAVE1: SPI slave control register 1
func (o *SPI_Type) SetSLAVE1_SLV_ADDR_ERR_CLR(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetSLAVE1_SLV_ADDR_ERR_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetSLAVE1_SLV_CMD_ERR_CLR(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetSLAVE1_SLV_CMD_ERR_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetSLAVE1_SLV_NO_QPI_EN(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetSLAVE1_SLV_NO_QPI_EN() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetSLAVE1_SLV_ADDR_ERR(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetSLAVE1_SLV_ADDR_ERR() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetSLAVE1_SLV_CMD_ERR(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetSLAVE1_SLV_CMD_ERR() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetSLAVE1_SLV_WR_DMA_DONE(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetSLAVE1_SLV_WR_DMA_DONE() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetSLAVE1_SLV_LAST_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI_Type) GetSLAVE1_SLV_LAST_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0xff0000) >> 16
}
func (o *SPI_Type) SetSLAVE1_SLV_LAST_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLAVE1.Reg, volatile.LoadUint32(&o.SLAVE1.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetSLAVE1_SLV_LAST_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SLAVE1.Reg) & 0xff000000) >> 24
}

// SPI.SLV_WRBUF_DLEN: SPI slave Wr_BUF interrupt and CONF control register
func (o *SPI_Type) SetSLV_WRBUF_DLEN_SLV_WR_BUF_DONE(value uint32) {
	volatile.StoreUint32(&o.SLV_WRBUF_DLEN.Reg, volatile.LoadUint32(&o.SLV_WRBUF_DLEN.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetSLV_WRBUF_DLEN_SLV_WR_BUF_DONE() uint32 {
	return (volatile.LoadUint32(&o.SLV_WRBUF_DLEN.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetSLV_WRBUF_DLEN_CONF_BASE_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SLV_WRBUF_DLEN.Reg, volatile.LoadUint32(&o.SLV_WRBUF_DLEN.Reg)&^(0xfe000000)|value<<25)
}
func (o *SPI_Type) GetSLV_WRBUF_DLEN_CONF_BASE_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SLV_WRBUF_DLEN.Reg) & 0xfe000000) >> 25
}

// SPI.SLV_RDBUF_DLEN: SPI magic error and slave control register
func (o *SPI_Type) SetSLV_RDBUF_DLEN_SLV_DMA_RD_BYTELEN(value uint32) {
	volatile.StoreUint32(&o.SLV_RDBUF_DLEN.Reg, volatile.LoadUint32(&o.SLV_RDBUF_DLEN.Reg)&^(0xfffff)|value)
}
func (o *SPI_Type) GetSLV_RDBUF_DLEN_SLV_DMA_RD_BYTELEN() uint32 {
	return volatile.LoadUint32(&o.SLV_RDBUF_DLEN.Reg) & 0xfffff
}
func (o *SPI_Type) SetSLV_RDBUF_DLEN_SLV_RD_BUF_DONE(value uint32) {
	volatile.StoreUint32(&o.SLV_RDBUF_DLEN.Reg, volatile.LoadUint32(&o.SLV_RDBUF_DLEN.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetSLV_RDBUF_DLEN_SLV_RD_BUF_DONE() uint32 {
	return (volatile.LoadUint32(&o.SLV_RDBUF_DLEN.Reg) & 0x1000000) >> 24
}
func (o *SPI_Type) SetSLV_RDBUF_DLEN_SEG_MAGIC_ERR(value uint32) {
	volatile.StoreUint32(&o.SLV_RDBUF_DLEN.Reg, volatile.LoadUint32(&o.SLV_RDBUF_DLEN.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI_Type) GetSLV_RDBUF_DLEN_SEG_MAGIC_ERR() uint32 {
	return (volatile.LoadUint32(&o.SLV_RDBUF_DLEN.Reg) & 0x2000000) >> 25
}

// SPI.SLV_RD_BYTE: SPI interrupt control register
func (o *SPI_Type) SetSLV_RD_BYTE_SLV_DATA_BYTELEN(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0xfffff)|value)
}
func (o *SPI_Type) GetSLV_RD_BYTE_SLV_DATA_BYTELEN() uint32 {
	return volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0xfffff
}
func (o *SPI_Type) SetSLV_RD_BYTE_SLV_RDDMA_BYTELEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetSLV_RD_BYTE_SLV_RDDMA_BYTELEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetSLV_RD_BYTE_SLV_WRDMA_BYTELEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetSLV_RD_BYTE_SLV_WRDMA_BYTELEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetSLV_RD_BYTE_SLV_RDBUF_BYTELEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetSLV_RD_BYTE_SLV_RDBUF_BYTELEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetSLV_RD_BYTE_SLV_WRBUF_BYTELEN_EN(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0x800000)|value<<23)
}
func (o *SPI_Type) GetSLV_RD_BYTE_SLV_WRBUF_BYTELEN_EN() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0x800000) >> 23
}
func (o *SPI_Type) SetSLV_RD_BYTE_DMA_SEG_MAGIC_VALUE(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0xf000000)|value<<24)
}
func (o *SPI_Type) GetSLV_RD_BYTE_DMA_SEG_MAGIC_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0xf000000) >> 24
}
func (o *SPI_Type) SetSLV_RD_BYTE_SLV_RD_DMA_DONE(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetSLV_RD_BYTE_SLV_RD_DMA_DONE() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetSLV_RD_BYTE_USR_CONF(value uint32) {
	volatile.StoreUint32(&o.SLV_RD_BYTE.Reg, volatile.LoadUint32(&o.SLV_RD_BYTE.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetSLV_RD_BYTE_USR_CONF() uint32 {
	return (volatile.LoadUint32(&o.SLV_RD_BYTE.Reg) & 0x80000000) >> 31
}

// SPI.FSM: SPI master status and DMA read byte control register
func (o *SPI_Type) SetFSM_ST(value uint32) {
	volatile.StoreUint32(&o.FSM.Reg, volatile.LoadUint32(&o.FSM.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetFSM_ST() uint32 {
	return volatile.LoadUint32(&o.FSM.Reg) & 0xf
}
func (o *SPI_Type) SetFSM_MST_DMA_RD_BYTELEN(value uint32) {
	volatile.StoreUint32(&o.FSM.Reg, volatile.LoadUint32(&o.FSM.Reg)&^(0xfffff000)|value<<12)
}
func (o *SPI_Type) GetFSM_MST_DMA_RD_BYTELEN() uint32 {
	return (volatile.LoadUint32(&o.FSM.Reg) & 0xfffff000) >> 12
}

// SPI.HOLD: SPI hold register
func (o *SPI_Type) SetHOLD_INT_HOLD_ENA(value uint32) {
	volatile.StoreUint32(&o.HOLD.Reg, volatile.LoadUint32(&o.HOLD.Reg)&^(0x3)|value)
}
func (o *SPI_Type) GetHOLD_INT_HOLD_ENA() uint32 {
	return volatile.LoadUint32(&o.HOLD.Reg) & 0x3
}
func (o *SPI_Type) SetHOLD_VAL(value uint32) {
	volatile.StoreUint32(&o.HOLD.Reg, volatile.LoadUint32(&o.HOLD.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetHOLD_VAL() uint32 {
	return (volatile.LoadUint32(&o.HOLD.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetHOLD_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.HOLD.Reg, volatile.LoadUint32(&o.HOLD.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetHOLD_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.HOLD.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetHOLD_OUT_TIME(value uint32) {
	volatile.StoreUint32(&o.HOLD.Reg, volatile.LoadUint32(&o.HOLD.Reg)&^(0x70)|value<<4)
}
func (o *SPI_Type) GetHOLD_OUT_TIME() uint32 {
	return (volatile.LoadUint32(&o.HOLD.Reg) & 0x70) >> 4
}
func (o *SPI_Type) SetHOLD_DMA_SEG_TRANS_DONE(value uint32) {
	volatile.StoreUint32(&o.HOLD.Reg, volatile.LoadUint32(&o.HOLD.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetHOLD_DMA_SEG_TRANS_DONE() uint32 {
	return (volatile.LoadUint32(&o.HOLD.Reg) & 0x80) >> 7
}

// SPI.DMA_CONF: SPI DMA control register
func (o *SPI_Type) SetDMA_CONF_IN_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetDMA_CONF_IN_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetDMA_CONF_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetDMA_CONF_OUT_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetDMA_CONF_AHBM_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetDMA_CONF_AHBM_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetDMA_CONF_AHBM_RST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetDMA_CONF_AHBM_RST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetDMA_CONF_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetDMA_CONF_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetDMA_CONF_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetDMA_CONF_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetDMA_CONF_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetDMA_CONF_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetDMA_CONF_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetDMA_CONF_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetDMA_CONF_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetDMA_CONF_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetDMA_CONF_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetDMA_CONF_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetDMA_CONF_OUT_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetDMA_CONF_OUT_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetDMA_CONF_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetDMA_CONF_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetDMA_CONF_DMA_RX_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetDMA_CONF_DMA_RX_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetDMA_CONF_DMA_TX_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetDMA_CONF_DMA_TX_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetDMA_CONF_DMA_CONTINUE(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetDMA_CONF_DMA_CONTINUE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x10000) >> 16
}
func (o *SPI_Type) SetDMA_CONF_SLV_LAST_SEG_POP_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *SPI_Type) GetDMA_CONF_SLV_LAST_SEG_POP_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x20000) >> 17
}
func (o *SPI_Type) SetDMA_CONF_DMA_SLV_SEG_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *SPI_Type) GetDMA_CONF_DMA_SLV_SEG_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x40000) >> 18
}
func (o *SPI_Type) SetDMA_CONF_SLV_RX_SEG_TRANS_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *SPI_Type) GetDMA_CONF_SLV_RX_SEG_TRANS_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x80000) >> 19
}
func (o *SPI_Type) SetDMA_CONF_SLV_TX_SEG_TRANS_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetDMA_CONF_SLV_TX_SEG_TRANS_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetDMA_CONF_RX_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *SPI_Type) GetDMA_CONF_RX_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x200000) >> 21
}
func (o *SPI_Type) SetDMA_CONF_DMA_INFIFO_FULL_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *SPI_Type) GetDMA_CONF_DMA_INFIFO_FULL_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x400000) >> 22
}
func (o *SPI_Type) SetDMA_CONF_DMA_OUTFIFO_EMPTY_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *SPI_Type) GetDMA_CONF_DMA_OUTFIFO_EMPTY_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x800000) >> 23
}
func (o *SPI_Type) SetDMA_CONF_EXT_MEM_BK_SIZE(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0xc000000)|value<<26)
}
func (o *SPI_Type) GetDMA_CONF_EXT_MEM_BK_SIZE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0xc000000) >> 26
}
func (o *SPI_Type) SetDMA_CONF_DMA_SEG_TRANS_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_CONF.Reg, volatile.LoadUint32(&o.DMA_CONF.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetDMA_CONF_DMA_SEG_TRANS_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_CONF.Reg) & 0x10000000) >> 28
}

// SPI.DMA_OUT_LINK: SPI DMA TX link configuration
func (o *SPI_Type) SetDMA_OUT_LINK_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0xfffff)|value)
}
func (o *SPI_Type) GetDMA_OUT_LINK_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0xfffff
}
func (o *SPI_Type) SetDMA_OUT_LINK_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetDMA_OUT_LINK_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetDMA_OUT_LINK_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI_Type) GetDMA_OUT_LINK_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x20000000) >> 29
}
func (o *SPI_Type) SetDMA_OUT_LINK_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetDMA_OUT_LINK_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetDMA_OUT_LINK_DMA_TX_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetDMA_OUT_LINK_DMA_TX_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x80000000) >> 31
}

// SPI.DMA_IN_LINK: SPI DMA RX link configuration
func (o *SPI_Type) SetDMA_IN_LINK_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0xfffff)|value)
}
func (o *SPI_Type) GetDMA_IN_LINK_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0xfffff
}
func (o *SPI_Type) SetDMA_IN_LINK_INLINK_AUTO_RET(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x100000)|value<<20)
}
func (o *SPI_Type) GetDMA_IN_LINK_INLINK_AUTO_RET() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x100000) >> 20
}
func (o *SPI_Type) SetDMA_IN_LINK_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI_Type) GetDMA_IN_LINK_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x10000000) >> 28
}
func (o *SPI_Type) SetDMA_IN_LINK_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI_Type) GetDMA_IN_LINK_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x20000000) >> 29
}
func (o *SPI_Type) SetDMA_IN_LINK_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetDMA_IN_LINK_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetDMA_IN_LINK_DMA_RX_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetDMA_IN_LINK_DMA_RX_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x80000000) >> 31
}

// SPI.DMA_INT_ENA: SPI DMA interrupt enable register
func (o *SPI_Type) SetDMA_INT_ENA_INLINK_DSCR_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetDMA_INT_ENA_INLINK_DSCR_EMPTY_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x1
}
func (o *SPI_Type) SetDMA_INT_ENA_OUTLINK_DSCR_ERROR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetDMA_INT_ENA_OUTLINK_DSCR_ERROR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetDMA_INT_ENA_INLINK_DSCR_ERROR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetDMA_INT_ENA_INLINK_DSCR_ERROR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetDMA_INT_ENA_IN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetDMA_INT_ENA_IN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetDMA_INT_ENA_IN_ERR_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetDMA_INT_ENA_IN_ERR_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetDMA_INT_ENA_IN_SUC_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetDMA_INT_ENA_IN_SUC_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetDMA_INT_ENA_OUT_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetDMA_INT_ENA_OUT_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetDMA_INT_ENA_OUT_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetDMA_INT_ENA_OUT_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetDMA_INT_ENA_OUT_TOTAL_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetDMA_INT_ENA_OUT_TOTAL_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetDMA_INT_ENA_INFIFO_FULL_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetDMA_INT_ENA_INFIFO_FULL_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetDMA_INT_ENA_OUTFIFO_EMPTY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetDMA_INT_ENA_OUTFIFO_EMPTY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetDMA_INT_ENA_SLV_CMD6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetDMA_INT_ENA_SLV_CMD6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetDMA_INT_ENA_SLV_CMD7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetDMA_INT_ENA_SLV_CMD7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetDMA_INT_ENA_SLV_CMD8_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetDMA_INT_ENA_SLV_CMD8_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetDMA_INT_ENA_SLV_CMD9_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetDMA_INT_ENA_SLV_CMD9_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetDMA_INT_ENA_SLV_CMDA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ENA.Reg, volatile.LoadUint32(&o.DMA_INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetDMA_INT_ENA_SLV_CMDA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ENA.Reg) & 0x8000) >> 15
}

// SPI.DMA_INT_RAW: SPI DMA interrupt raw register
func (o *SPI_Type) SetDMA_INT_RAW_INLINK_DSCR_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetDMA_INT_RAW_INLINK_DSCR_EMPTY_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x1
}
func (o *SPI_Type) SetDMA_INT_RAW_OUTLINK_DSCR_ERROR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetDMA_INT_RAW_OUTLINK_DSCR_ERROR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetDMA_INT_RAW_INLINK_DSCR_ERROR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetDMA_INT_RAW_INLINK_DSCR_ERROR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetDMA_INT_RAW_IN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetDMA_INT_RAW_IN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetDMA_INT_RAW_IN_ERR_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetDMA_INT_RAW_IN_ERR_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetDMA_INT_RAW_IN_SUC_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetDMA_INT_RAW_IN_SUC_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetDMA_INT_RAW_OUT_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetDMA_INT_RAW_OUT_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetDMA_INT_RAW_OUT_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetDMA_INT_RAW_OUT_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetDMA_INT_RAW_OUT_TOTAL_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetDMA_INT_RAW_OUT_TOTAL_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetDMA_INT_RAW_INFIFO_FULL_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetDMA_INT_RAW_INFIFO_FULL_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetDMA_INT_RAW_OUTFIFO_EMPTY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetDMA_INT_RAW_OUTFIFO_EMPTY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetDMA_INT_RAW_SLV_CMD6_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetDMA_INT_RAW_SLV_CMD6_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetDMA_INT_RAW_SLV_CMD7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetDMA_INT_RAW_SLV_CMD7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetDMA_INT_RAW_SLV_CMD8_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetDMA_INT_RAW_SLV_CMD8_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetDMA_INT_RAW_SLV_CMD9_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetDMA_INT_RAW_SLV_CMD9_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetDMA_INT_RAW_SLV_CMDA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_RAW.Reg, volatile.LoadUint32(&o.DMA_INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetDMA_INT_RAW_SLV_CMDA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_RAW.Reg) & 0x8000) >> 15
}

// SPI.DMA_INT_ST: SPI DMA interrupt status register
func (o *SPI_Type) SetDMA_INT_ST_INLINK_DSCR_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetDMA_INT_ST_INLINK_DSCR_EMPTY_INT_ST() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x1
}
func (o *SPI_Type) SetDMA_INT_ST_OUTLINK_DSCR_ERROR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetDMA_INT_ST_OUTLINK_DSCR_ERROR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetDMA_INT_ST_INLINK_DSCR_ERROR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetDMA_INT_ST_INLINK_DSCR_ERROR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetDMA_INT_ST_IN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetDMA_INT_ST_IN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetDMA_INT_ST_IN_ERR_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetDMA_INT_ST_IN_ERR_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetDMA_INT_ST_IN_SUC_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetDMA_INT_ST_IN_SUC_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetDMA_INT_ST_OUT_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetDMA_INT_ST_OUT_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetDMA_INT_ST_OUT_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetDMA_INT_ST_OUT_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetDMA_INT_ST_OUT_TOTAL_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetDMA_INT_ST_OUT_TOTAL_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetDMA_INT_ST_INFIFO_FULL_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetDMA_INT_ST_INFIFO_FULL_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetDMA_INT_ST_OUTFIFO_EMPTY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetDMA_INT_ST_OUTFIFO_EMPTY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetDMA_INT_ST_SLV_CMD6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetDMA_INT_ST_SLV_CMD6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetDMA_INT_ST_SLV_CMD7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetDMA_INT_ST_SLV_CMD7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetDMA_INT_ST_SLV_CMD8_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetDMA_INT_ST_SLV_CMD8_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetDMA_INT_ST_SLV_CMD9_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetDMA_INT_ST_SLV_CMD9_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetDMA_INT_ST_SLV_CMDA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_ST.Reg, volatile.LoadUint32(&o.DMA_INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetDMA_INT_ST_SLV_CMDA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_ST.Reg) & 0x8000) >> 15
}

// SPI.DMA_INT_CLR: SPI DMA interrupt clear register
func (o *SPI_Type) SetDMA_INT_CLR_INLINK_DSCR_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetDMA_INT_CLR_INLINK_DSCR_EMPTY_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x1
}
func (o *SPI_Type) SetDMA_INT_CLR_OUTLINK_DSCR_ERROR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetDMA_INT_CLR_OUTLINK_DSCR_ERROR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetDMA_INT_CLR_INLINK_DSCR_ERROR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetDMA_INT_CLR_INLINK_DSCR_ERROR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetDMA_INT_CLR_IN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetDMA_INT_CLR_IN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetDMA_INT_CLR_IN_ERR_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetDMA_INT_CLR_IN_ERR_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetDMA_INT_CLR_IN_SUC_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetDMA_INT_CLR_IN_SUC_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetDMA_INT_CLR_OUT_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetDMA_INT_CLR_OUT_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetDMA_INT_CLR_OUT_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetDMA_INT_CLR_OUT_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetDMA_INT_CLR_OUT_TOTAL_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetDMA_INT_CLR_OUT_TOTAL_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetDMA_INT_CLR_INFIFO_FULL_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetDMA_INT_CLR_INFIFO_FULL_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetDMA_INT_CLR_OUTFIFO_EMPTY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetDMA_INT_CLR_OUTFIFO_EMPTY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetDMA_INT_CLR_SLV_CMD6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetDMA_INT_CLR_SLV_CMD6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetDMA_INT_CLR_SLV_CMD7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetDMA_INT_CLR_SLV_CMD7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetDMA_INT_CLR_SLV_CMD8_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetDMA_INT_CLR_SLV_CMD8_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetDMA_INT_CLR_SLV_CMD9_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetDMA_INT_CLR_SLV_CMD9_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetDMA_INT_CLR_SLV_CMDA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.DMA_INT_CLR.Reg, volatile.LoadUint32(&o.DMA_INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetDMA_INT_CLR_SLV_CMDA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.DMA_INT_CLR.Reg) & 0x8000) >> 15
}

// SPI.IN_ERR_EOF_DES_ADDR: The latest SPI DMA RX descriptor address receiving error
func (o *SPI_Type) SetIN_ERR_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_ERR_EOF_DES_ADDR.Reg, value)
}
func (o *SPI_Type) GetIN_ERR_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_ERR_EOF_DES_ADDR.Reg)
}

// SPI.IN_SUC_EOF_DES_ADDR: The latest SPI DMA eof RX descriptor address
func (o *SPI_Type) SetIN_SUC_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.IN_SUC_EOF_DES_ADDR.Reg, value)
}
func (o *SPI_Type) GetIN_SUC_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.IN_SUC_EOF_DES_ADDR.Reg)
}

// SPI.INLINK_DSCR: Current SPI DMA RX descriptor pointer
func (o *SPI_Type) SetINLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR.Reg, value)
}
func (o *SPI_Type) GetINLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR.Reg)
}

// SPI.INLINK_DSCR_BF0: Next SPI DMA RX descriptor pointer
func (o *SPI_Type) SetINLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR_BF0.Reg, value)
}
func (o *SPI_Type) GetINLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR_BF0.Reg)
}

// SPI.INLINK_DSCR_BF1: Current SPI DMA RX buffer pointer
func (o *SPI_Type) SetINLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.INLINK_DSCR_BF1.Reg, value)
}
func (o *SPI_Type) GetINLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.INLINK_DSCR_BF1.Reg)
}

// SPI.OUT_EOF_BFR_DES_ADDR: The latest SPI DMA eof TX buffer address
func (o *SPI_Type) SetOUT_EOF_BFR_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_BFR_DES_ADDR.Reg, value)
}
func (o *SPI_Type) GetOUT_EOF_BFR_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_BFR_DES_ADDR.Reg)
}

// SPI.OUT_EOF_DES_ADDR: The latest SPI DMA eof TX descriptor address
func (o *SPI_Type) SetOUT_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.OUT_EOF_DES_ADDR.Reg, value)
}
func (o *SPI_Type) GetOUT_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.OUT_EOF_DES_ADDR.Reg)
}

// SPI.OUTLINK_DSCR: Current SPI DMA TX descriptor pointer
func (o *SPI_Type) SetOUTLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR.Reg, value)
}
func (o *SPI_Type) GetOUTLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR.Reg)
}

// SPI.OUTLINK_DSCR_BF0: Next SPI DMA TX descriptor pointer
func (o *SPI_Type) SetOUTLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR_BF0.Reg, value)
}
func (o *SPI_Type) GetOUTLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR_BF0.Reg)
}

// SPI.OUTLINK_DSCR_BF1: Current SPI DMA TX buffer pointer
func (o *SPI_Type) SetOUTLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.OUTLINK_DSCR_BF1.Reg, value)
}
func (o *SPI_Type) GetOUTLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.OUTLINK_DSCR_BF1.Reg)
}

// SPI.DMA_OUTSTATUS: SPI DMA TX status
func (o *SPI_Type) SetDMA_OUTSTATUS_DMA_OUTDSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUTSTATUS.Reg, volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg)&^(0x3ffff)|value)
}
func (o *SPI_Type) GetDMA_OUTSTATUS_DMA_OUTDSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg) & 0x3ffff
}
func (o *SPI_Type) SetDMA_OUTSTATUS_DMA_OUTDSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.DMA_OUTSTATUS.Reg, volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI_Type) GetDMA_OUTSTATUS_DMA_OUTDSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg) & 0xc0000) >> 18
}
func (o *SPI_Type) SetDMA_OUTSTATUS_DMA_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.DMA_OUTSTATUS.Reg, volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg)&^(0x700000)|value<<20)
}
func (o *SPI_Type) GetDMA_OUTSTATUS_DMA_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg) & 0x700000) >> 20
}
func (o *SPI_Type) SetDMA_OUTSTATUS_DMA_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.DMA_OUTSTATUS.Reg, volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg)&^(0x3f800000)|value<<23)
}
func (o *SPI_Type) GetDMA_OUTSTATUS_DMA_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg) & 0x3f800000) >> 23
}
func (o *SPI_Type) SetDMA_OUTSTATUS_DMA_OUTFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_OUTSTATUS.Reg, volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetDMA_OUTSTATUS_DMA_OUTFIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetDMA_OUTSTATUS_DMA_OUTFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_OUTSTATUS.Reg, volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetDMA_OUTSTATUS_DMA_OUTFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUTSTATUS.Reg) & 0x80000000) >> 31
}

// SPI.DMA_INSTATUS: SPI DMA RX status
func (o *SPI_Type) SetDMA_INSTATUS_DMA_INDSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_INSTATUS.Reg, volatile.LoadUint32(&o.DMA_INSTATUS.Reg)&^(0x3ffff)|value)
}
func (o *SPI_Type) GetDMA_INSTATUS_DMA_INDSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_INSTATUS.Reg) & 0x3ffff
}
func (o *SPI_Type) SetDMA_INSTATUS_DMA_INDSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.DMA_INSTATUS.Reg, volatile.LoadUint32(&o.DMA_INSTATUS.Reg)&^(0xc0000)|value<<18)
}
func (o *SPI_Type) GetDMA_INSTATUS_DMA_INDSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INSTATUS.Reg) & 0xc0000) >> 18
}
func (o *SPI_Type) SetDMA_INSTATUS_DMA_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.DMA_INSTATUS.Reg, volatile.LoadUint32(&o.DMA_INSTATUS.Reg)&^(0x700000)|value<<20)
}
func (o *SPI_Type) GetDMA_INSTATUS_DMA_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.DMA_INSTATUS.Reg) & 0x700000) >> 20
}
func (o *SPI_Type) SetDMA_INSTATUS_DMA_INFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.DMA_INSTATUS.Reg, volatile.LoadUint32(&o.DMA_INSTATUS.Reg)&^(0x3f800000)|value<<23)
}
func (o *SPI_Type) GetDMA_INSTATUS_DMA_INFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.DMA_INSTATUS.Reg) & 0x3f800000) >> 23
}
func (o *SPI_Type) SetDMA_INSTATUS_DMA_INFIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_INSTATUS.Reg, volatile.LoadUint32(&o.DMA_INSTATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI_Type) GetDMA_INSTATUS_DMA_INFIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.DMA_INSTATUS.Reg) & 0x40000000) >> 30
}
func (o *SPI_Type) SetDMA_INSTATUS_DMA_INFIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_INSTATUS.Reg, volatile.LoadUint32(&o.DMA_INSTATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetDMA_INSTATUS_DMA_INFIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.DMA_INSTATUS.Reg) & 0x80000000) >> 31
}

// SPI.W0: Data buffer 0
func (o *SPI_Type) SetW0(value uint32) {
	volatile.StoreUint32(&o.W0.Reg, value)
}
func (o *SPI_Type) GetW0() uint32 {
	return volatile.LoadUint32(&o.W0.Reg)
}

// SPI.W1: Data buffer 1
func (o *SPI_Type) SetW1(value uint32) {
	volatile.StoreUint32(&o.W1.Reg, value)
}
func (o *SPI_Type) GetW1() uint32 {
	return volatile.LoadUint32(&o.W1.Reg)
}

// SPI.W2: Data buffer 2
func (o *SPI_Type) SetW2(value uint32) {
	volatile.StoreUint32(&o.W2.Reg, value)
}
func (o *SPI_Type) GetW2() uint32 {
	return volatile.LoadUint32(&o.W2.Reg)
}

// SPI.W3: Data buffer 3
func (o *SPI_Type) SetW3(value uint32) {
	volatile.StoreUint32(&o.W3.Reg, value)
}
func (o *SPI_Type) GetW3() uint32 {
	return volatile.LoadUint32(&o.W3.Reg)
}

// SPI.W4: Data buffer 4
func (o *SPI_Type) SetW4(value uint32) {
	volatile.StoreUint32(&o.W4.Reg, value)
}
func (o *SPI_Type) GetW4() uint32 {
	return volatile.LoadUint32(&o.W4.Reg)
}

// SPI.W5: Data buffer 5
func (o *SPI_Type) SetW5(value uint32) {
	volatile.StoreUint32(&o.W5.Reg, value)
}
func (o *SPI_Type) GetW5() uint32 {
	return volatile.LoadUint32(&o.W5.Reg)
}

// SPI.W6: Data buffer 6
func (o *SPI_Type) SetW6(value uint32) {
	volatile.StoreUint32(&o.W6.Reg, value)
}
func (o *SPI_Type) GetW6() uint32 {
	return volatile.LoadUint32(&o.W6.Reg)
}

// SPI.W7: Data buffer 7
func (o *SPI_Type) SetW7(value uint32) {
	volatile.StoreUint32(&o.W7.Reg, value)
}
func (o *SPI_Type) GetW7() uint32 {
	return volatile.LoadUint32(&o.W7.Reg)
}

// SPI.W8: Data buffer 8
func (o *SPI_Type) SetW8(value uint32) {
	volatile.StoreUint32(&o.W8.Reg, value)
}
func (o *SPI_Type) GetW8() uint32 {
	return volatile.LoadUint32(&o.W8.Reg)
}

// SPI.W9: Data buffer 9
func (o *SPI_Type) SetW9(value uint32) {
	volatile.StoreUint32(&o.W9.Reg, value)
}
func (o *SPI_Type) GetW9() uint32 {
	return volatile.LoadUint32(&o.W9.Reg)
}

// SPI.W10: Data buffer 10
func (o *SPI_Type) SetW10(value uint32) {
	volatile.StoreUint32(&o.W10.Reg, value)
}
func (o *SPI_Type) GetW10() uint32 {
	return volatile.LoadUint32(&o.W10.Reg)
}

// SPI.W11: Data buffer 11
func (o *SPI_Type) SetW11(value uint32) {
	volatile.StoreUint32(&o.W11.Reg, value)
}
func (o *SPI_Type) GetW11() uint32 {
	return volatile.LoadUint32(&o.W11.Reg)
}

// SPI.W12: Data buffer 12
func (o *SPI_Type) SetW12(value uint32) {
	volatile.StoreUint32(&o.W12.Reg, value)
}
func (o *SPI_Type) GetW12() uint32 {
	return volatile.LoadUint32(&o.W12.Reg)
}

// SPI.W13: Data buffer 13
func (o *SPI_Type) SetW13(value uint32) {
	volatile.StoreUint32(&o.W13.Reg, value)
}
func (o *SPI_Type) GetW13() uint32 {
	return volatile.LoadUint32(&o.W13.Reg)
}

// SPI.W14: Data buffer 14
func (o *SPI_Type) SetW14(value uint32) {
	volatile.StoreUint32(&o.W14.Reg, value)
}
func (o *SPI_Type) GetW14() uint32 {
	return volatile.LoadUint32(&o.W14.Reg)
}

// SPI.W15: Data buffer 15
func (o *SPI_Type) SetW15(value uint32) {
	volatile.StoreUint32(&o.W15.Reg, value)
}
func (o *SPI_Type) GetW15() uint32 {
	return volatile.LoadUint32(&o.W15.Reg)
}

// SPI.W16: Data buffer 16
func (o *SPI_Type) SetW16(value uint32) {
	volatile.StoreUint32(&o.W16.Reg, value)
}
func (o *SPI_Type) GetW16() uint32 {
	return volatile.LoadUint32(&o.W16.Reg)
}

// SPI.W17: Data buffer 17
func (o *SPI_Type) SetW17(value uint32) {
	volatile.StoreUint32(&o.W17.Reg, value)
}
func (o *SPI_Type) GetW17() uint32 {
	return volatile.LoadUint32(&o.W17.Reg)
}

// SPI.DIN_MODE: SPI input delay mode configuration
func (o *SPI_Type) SetDIN_MODE_DIN0_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x7)|value)
}
func (o *SPI_Type) GetDIN_MODE_DIN0_MODE() uint32 {
	return volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x7
}
func (o *SPI_Type) SetDIN_MODE_DIN1_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetDIN_MODE_DIN1_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetDIN_MODE_DIN2_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x1c0)|value<<6)
}
func (o *SPI_Type) GetDIN_MODE_DIN2_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x1c0) >> 6
}
func (o *SPI_Type) SetDIN_MODE_DIN3_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0xe00)|value<<9)
}
func (o *SPI_Type) GetDIN_MODE_DIN3_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0xe00) >> 9
}
func (o *SPI_Type) SetDIN_MODE_DIN4_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x7000)|value<<12)
}
func (o *SPI_Type) GetDIN_MODE_DIN4_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x7000) >> 12
}
func (o *SPI_Type) SetDIN_MODE_DIN5_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x38000)|value<<15)
}
func (o *SPI_Type) GetDIN_MODE_DIN5_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x38000) >> 15
}
func (o *SPI_Type) SetDIN_MODE_DIN6_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x1c0000)|value<<18)
}
func (o *SPI_Type) GetDIN_MODE_DIN6_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x1c0000) >> 18
}
func (o *SPI_Type) SetDIN_MODE_DIN7_MODE(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0xe00000)|value<<21)
}
func (o *SPI_Type) GetDIN_MODE_DIN7_MODE() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0xe00000) >> 21
}
func (o *SPI_Type) SetDIN_MODE_TIMING_CLK_ENA(value uint32) {
	volatile.StoreUint32(&o.DIN_MODE.Reg, volatile.LoadUint32(&o.DIN_MODE.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetDIN_MODE_TIMING_CLK_ENA() uint32 {
	return (volatile.LoadUint32(&o.DIN_MODE.Reg) & 0x1000000) >> 24
}

// SPI.DIN_NUM: SPI input delay number configuration
func (o *SPI_Type) SetDIN_NUM_DIN0_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x3)|value)
}
func (o *SPI_Type) GetDIN_NUM_DIN0_NUM() uint32 {
	return volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x3
}
func (o *SPI_Type) SetDIN_NUM_DIN1_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc)|value<<2)
}
func (o *SPI_Type) GetDIN_NUM_DIN1_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc) >> 2
}
func (o *SPI_Type) SetDIN_NUM_DIN2_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetDIN_NUM_DIN2_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetDIN_NUM_DIN3_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc0)|value<<6)
}
func (o *SPI_Type) GetDIN_NUM_DIN3_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc0) >> 6
}
func (o *SPI_Type) SetDIN_NUM_DIN4_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetDIN_NUM_DIN4_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetDIN_NUM_DIN5_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc00)|value<<10)
}
func (o *SPI_Type) GetDIN_NUM_DIN5_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc00) >> 10
}
func (o *SPI_Type) SetDIN_NUM_DIN6_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0x3000)|value<<12)
}
func (o *SPI_Type) GetDIN_NUM_DIN6_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0x3000) >> 12
}
func (o *SPI_Type) SetDIN_NUM_DIN7_NUM(value uint32) {
	volatile.StoreUint32(&o.DIN_NUM.Reg, volatile.LoadUint32(&o.DIN_NUM.Reg)&^(0xc000)|value<<14)
}
func (o *SPI_Type) GetDIN_NUM_DIN7_NUM() uint32 {
	return (volatile.LoadUint32(&o.DIN_NUM.Reg) & 0xc000) >> 14
}

// SPI.DOUT_MODE: SPI output delay mode configuration
func (o *SPI_Type) SetDOUT_MODE_DOUT0_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x7)|value)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT0_MODE() uint32 {
	return volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x7
}
func (o *SPI_Type) SetDOUT_MODE_DOUT1_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT1_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetDOUT_MODE_DOUT2_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x1c0)|value<<6)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT2_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x1c0) >> 6
}
func (o *SPI_Type) SetDOUT_MODE_DOUT3_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0xe00)|value<<9)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT3_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0xe00) >> 9
}
func (o *SPI_Type) SetDOUT_MODE_DOUT4_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x7000)|value<<12)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT4_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x7000) >> 12
}
func (o *SPI_Type) SetDOUT_MODE_DOUT5_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x38000)|value<<15)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT5_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x38000) >> 15
}
func (o *SPI_Type) SetDOUT_MODE_DOUT6_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0x1c0000)|value<<18)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT6_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0x1c0000) >> 18
}
func (o *SPI_Type) SetDOUT_MODE_DOUT7_MODE(value uint32) {
	volatile.StoreUint32(&o.DOUT_MODE.Reg, volatile.LoadUint32(&o.DOUT_MODE.Reg)&^(0xe00000)|value<<21)
}
func (o *SPI_Type) GetDOUT_MODE_DOUT7_MODE() uint32 {
	return (volatile.LoadUint32(&o.DOUT_MODE.Reg) & 0xe00000) >> 21
}

// SPI.DOUT_NUM: SPI output delay number configuration
func (o *SPI_Type) SetDOUT_NUM_DOUT0_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0x3)|value)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT0_NUM() uint32 {
	return volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0x3
}
func (o *SPI_Type) SetDOUT_NUM_DOUT1_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0xc)|value<<2)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT1_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0xc) >> 2
}
func (o *SPI_Type) SetDOUT_NUM_DOUT2_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT2_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetDOUT_NUM_DOUT3_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0xc0)|value<<6)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT3_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0xc0) >> 6
}
func (o *SPI_Type) SetDOUT_NUM_DOUT4_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT4_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetDOUT_NUM_DOUT5_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0xc00)|value<<10)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT5_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0xc00) >> 10
}
func (o *SPI_Type) SetDOUT_NUM_DOUT6_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0x3000)|value<<12)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT6_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0x3000) >> 12
}
func (o *SPI_Type) SetDOUT_NUM_DOUT7_NUM(value uint32) {
	volatile.StoreUint32(&o.DOUT_NUM.Reg, volatile.LoadUint32(&o.DOUT_NUM.Reg)&^(0xc000)|value<<14)
}
func (o *SPI_Type) GetDOUT_NUM_DOUT7_NUM() uint32 {
	return (volatile.LoadUint32(&o.DOUT_NUM.Reg) & 0xc000) >> 14
}

// SPI.LCD_CTRL: LCD frame control register
func (o *SPI_Type) SetLCD_CTRL_LCD_HB_FRONT(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL.Reg, volatile.LoadUint32(&o.LCD_CTRL.Reg)&^(0x7ff)|value)
}
func (o *SPI_Type) GetLCD_CTRL_LCD_HB_FRONT() uint32 {
	return volatile.LoadUint32(&o.LCD_CTRL.Reg) & 0x7ff
}
func (o *SPI_Type) SetLCD_CTRL_LCD_VA_HEIGHT(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL.Reg, volatile.LoadUint32(&o.LCD_CTRL.Reg)&^(0x1ff800)|value<<11)
}
func (o *SPI_Type) GetLCD_CTRL_LCD_VA_HEIGHT() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL.Reg) & 0x1ff800) >> 11
}
func (o *SPI_Type) SetLCD_CTRL_LCD_VT_HEIGHT(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL.Reg, volatile.LoadUint32(&o.LCD_CTRL.Reg)&^(0x7fe00000)|value<<21)
}
func (o *SPI_Type) GetLCD_CTRL_LCD_VT_HEIGHT() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL.Reg) & 0x7fe00000) >> 21
}
func (o *SPI_Type) SetLCD_CTRL_LCD_MODE_EN(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL.Reg, volatile.LoadUint32(&o.LCD_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_Type) GetLCD_CTRL_LCD_MODE_EN() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL.Reg) & 0x80000000) >> 31
}

// SPI.LCD_CTRL1: LCD frame control1 register
func (o *SPI_Type) SetLCD_CTRL1_LCD_VB_FRONT(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL1.Reg, volatile.LoadUint32(&o.LCD_CTRL1.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetLCD_CTRL1_LCD_VB_FRONT() uint32 {
	return volatile.LoadUint32(&o.LCD_CTRL1.Reg) & 0xff
}
func (o *SPI_Type) SetLCD_CTRL1_LCD_HA_WIDTH(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL1.Reg, volatile.LoadUint32(&o.LCD_CTRL1.Reg)&^(0xfff00)|value<<8)
}
func (o *SPI_Type) GetLCD_CTRL1_LCD_HA_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL1.Reg) & 0xfff00) >> 8
}
func (o *SPI_Type) SetLCD_CTRL1_LCD_HT_WIDTH(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL1.Reg, volatile.LoadUint32(&o.LCD_CTRL1.Reg)&^(0xfff00000)|value<<20)
}
func (o *SPI_Type) GetLCD_CTRL1_LCD_HT_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL1.Reg) & 0xfff00000) >> 20
}

// SPI.LCD_CTRL2: LCD frame control2 register
func (o *SPI_Type) SetLCD_CTRL2_LCD_VSYNC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL2.Reg, volatile.LoadUint32(&o.LCD_CTRL2.Reg)&^(0x7f)|value)
}
func (o *SPI_Type) GetLCD_CTRL2_LCD_VSYNC_WIDTH() uint32 {
	return volatile.LoadUint32(&o.LCD_CTRL2.Reg) & 0x7f
}
func (o *SPI_Type) SetLCD_CTRL2_VSYNC_IDLE_POL(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL2.Reg, volatile.LoadUint32(&o.LCD_CTRL2.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetLCD_CTRL2_VSYNC_IDLE_POL() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL2.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetLCD_CTRL2_LCD_HSYNC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL2.Reg, volatile.LoadUint32(&o.LCD_CTRL2.Reg)&^(0x7f0000)|value<<16)
}
func (o *SPI_Type) GetLCD_CTRL2_LCD_HSYNC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL2.Reg) & 0x7f0000) >> 16
}
func (o *SPI_Type) SetLCD_CTRL2_HSYNC_IDLE_POL(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL2.Reg, volatile.LoadUint32(&o.LCD_CTRL2.Reg)&^(0x800000)|value<<23)
}
func (o *SPI_Type) GetLCD_CTRL2_HSYNC_IDLE_POL() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL2.Reg) & 0x800000) >> 23
}
func (o *SPI_Type) SetLCD_CTRL2_LCD_HSYNC_POSITION(value uint32) {
	volatile.StoreUint32(&o.LCD_CTRL2.Reg, volatile.LoadUint32(&o.LCD_CTRL2.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetLCD_CTRL2_LCD_HSYNC_POSITION() uint32 {
	return (volatile.LoadUint32(&o.LCD_CTRL2.Reg) & 0xff000000) >> 24
}

// SPI.LCD_D_MODE: LCD delay number
func (o *SPI_Type) SetLCD_D_MODE_D_DQS_MODE(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0x7)|value)
}
func (o *SPI_Type) GetLCD_D_MODE_D_DQS_MODE() uint32 {
	return volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0x7
}
func (o *SPI_Type) SetLCD_D_MODE_D_CD_MODE(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetLCD_D_MODE_D_CD_MODE() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetLCD_D_MODE_D_DE_MODE(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0x1c0)|value<<6)
}
func (o *SPI_Type) GetLCD_D_MODE_D_DE_MODE() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0x1c0) >> 6
}
func (o *SPI_Type) SetLCD_D_MODE_D_HSYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0xe00)|value<<9)
}
func (o *SPI_Type) GetLCD_D_MODE_D_HSYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0xe00) >> 9
}
func (o *SPI_Type) SetLCD_D_MODE_D_VSYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0x7000)|value<<12)
}
func (o *SPI_Type) GetLCD_D_MODE_D_VSYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0x7000) >> 12
}
func (o *SPI_Type) SetLCD_D_MODE_DE_IDLE_POL(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetLCD_D_MODE_DE_IDLE_POL() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetLCD_D_MODE_HS_BLANK_EN(value uint32) {
	volatile.StoreUint32(&o.LCD_D_MODE.Reg, volatile.LoadUint32(&o.LCD_D_MODE.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetLCD_D_MODE_HS_BLANK_EN() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_MODE.Reg) & 0x10000) >> 16
}

// SPI.LCD_D_NUM: LCD delay mode
func (o *SPI_Type) SetLCD_D_NUM_D_DQS_NUM(value uint32) {
	volatile.StoreUint32(&o.LCD_D_NUM.Reg, volatile.LoadUint32(&o.LCD_D_NUM.Reg)&^(0x3)|value)
}
func (o *SPI_Type) GetLCD_D_NUM_D_DQS_NUM() uint32 {
	return volatile.LoadUint32(&o.LCD_D_NUM.Reg) & 0x3
}
func (o *SPI_Type) SetLCD_D_NUM_D_CD_NUM(value uint32) {
	volatile.StoreUint32(&o.LCD_D_NUM.Reg, volatile.LoadUint32(&o.LCD_D_NUM.Reg)&^(0xc)|value<<2)
}
func (o *SPI_Type) GetLCD_D_NUM_D_CD_NUM() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_NUM.Reg) & 0xc) >> 2
}
func (o *SPI_Type) SetLCD_D_NUM_D_DE_NUM(value uint32) {
	volatile.StoreUint32(&o.LCD_D_NUM.Reg, volatile.LoadUint32(&o.LCD_D_NUM.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetLCD_D_NUM_D_DE_NUM() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_NUM.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetLCD_D_NUM_D_HSYNC_NUM(value uint32) {
	volatile.StoreUint32(&o.LCD_D_NUM.Reg, volatile.LoadUint32(&o.LCD_D_NUM.Reg)&^(0xc0)|value<<6)
}
func (o *SPI_Type) GetLCD_D_NUM_D_HSYNC_NUM() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_NUM.Reg) & 0xc0) >> 6
}
func (o *SPI_Type) SetLCD_D_NUM_D_VSYNC_NUM(value uint32) {
	volatile.StoreUint32(&o.LCD_D_NUM.Reg, volatile.LoadUint32(&o.LCD_D_NUM.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetLCD_D_NUM_D_VSYNC_NUM() uint32 {
	return (volatile.LoadUint32(&o.LCD_D_NUM.Reg) & 0x300) >> 8
}

// SPI.REG_DATE: SPI version control
func (o *SPI_Type) SetREG_DATE_DATE(value uint32) {
	volatile.StoreUint32(&o.REG_DATE.Reg, volatile.LoadUint32(&o.REG_DATE.Reg)&^(0xfffffff)|value)
}
func (o *SPI_Type) GetREG_DATE_DATE() uint32 {
	return volatile.LoadUint32(&o.REG_DATE.Reg) & 0xfffffff
}

// SYSCON Peripheral
type SYSCON_Type struct {
	SYSCLK_CONF         volatile.Register32 // 0x0
	TICK_CONF           volatile.Register32 // 0x4
	CLK_OUT_EN          volatile.Register32 // 0x8
	HOST_INF_SEL        volatile.Register32 // 0xC
	EXT_MEM_PMS_LOCK    volatile.Register32 // 0x10
	FLASH_ACE0_ATTR     volatile.Register32 // 0x14
	FLASH_ACE1_ATTR     volatile.Register32 // 0x18
	FLASH_ACE2_ATTR     volatile.Register32 // 0x1C
	FLASH_ACE3_ATTR     volatile.Register32 // 0x20
	FLASH_ACE0_ADDR     volatile.Register32 // 0x24
	FLASH_ACE1_ADDR     volatile.Register32 // 0x28
	FLASH_ACE2_ADDR     volatile.Register32 // 0x2C
	FLASH_ACE3_ADDR     volatile.Register32 // 0x30
	FLASH_ACE0_SIZE     volatile.Register32 // 0x34
	FLASH_ACE1_SIZE     volatile.Register32 // 0x38
	FLASH_ACE2_SIZE     volatile.Register32 // 0x3C
	FLASH_ACE3_SIZE     volatile.Register32 // 0x40
	SRAM_ACE0_ATTR      volatile.Register32 // 0x44
	SRAM_ACE1_ATTR      volatile.Register32 // 0x48
	SRAM_ACE2_ATTR      volatile.Register32 // 0x4C
	SRAM_ACE3_ATTR      volatile.Register32 // 0x50
	SRAM_ACE0_ADDR      volatile.Register32 // 0x54
	SRAM_ACE1_ADDR      volatile.Register32 // 0x58
	SRAM_ACE2_ADDR      volatile.Register32 // 0x5C
	SRAM_ACE3_ADDR      volatile.Register32 // 0x60
	SRAM_ACE0_SIZE      volatile.Register32 // 0x64
	SRAM_ACE1_SIZE      volatile.Register32 // 0x68
	SRAM_ACE2_SIZE      volatile.Register32 // 0x6C
	SRAM_ACE3_SIZE      volatile.Register32 // 0x70
	SPI_MEM_PMS_CTRL    volatile.Register32 // 0x74
	SPI_MEM_REJECT_ADDR volatile.Register32 // 0x78
	SDIO_CTRL           volatile.Register32 // 0x7C
	REDCY_SIG0          volatile.Register32 // 0x80
	REDCY_SIG1          volatile.Register32 // 0x84
	WIFI_BB_CFG         volatile.Register32 // 0x88
	WIFI_BB_CFG_2       volatile.Register32 // 0x8C
	WIFI_CLK_EN         volatile.Register32 // 0x90
	WIFI_RST_EN         volatile.Register32 // 0x94
	FRONT_END_MEM_PD    volatile.Register32 // 0x98
	_                   [864]byte
	DATE                volatile.Register32 // 0x3FC
}

// SYSCON.SYSCLK_CONF
func (o *SYSCON_Type) SetSYSCLK_CONF_CLK_320M_EN(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSYSCLK_CONF_CLK_320M_EN() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSYSCLK_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSYSCLK_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSYSCLK_CONF_RST_TICK_CNT(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSYSCLK_CONF_RST_TICK_CNT() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x1000) >> 12
}

// SYSCON.TICK_CONF
func (o *SYSCON_Type) SetTICK_CONF_XTAL_TICK_NUM(value uint32) {
	volatile.StoreUint32(&o.TICK_CONF.Reg, volatile.LoadUint32(&o.TICK_CONF.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetTICK_CONF_XTAL_TICK_NUM() uint32 {
	return volatile.LoadUint32(&o.TICK_CONF.Reg) & 0xff
}
func (o *SYSCON_Type) SetTICK_CONF_CK8M_TICK_NUM(value uint32) {
	volatile.StoreUint32(&o.TICK_CONF.Reg, volatile.LoadUint32(&o.TICK_CONF.Reg)&^(0xff00)|value<<8)
}
func (o *SYSCON_Type) GetTICK_CONF_CK8M_TICK_NUM() uint32 {
	return (volatile.LoadUint32(&o.TICK_CONF.Reg) & 0xff00) >> 8
}
func (o *SYSCON_Type) SetTICK_CONF_TICK_ENABLE(value uint32) {
	volatile.StoreUint32(&o.TICK_CONF.Reg, volatile.LoadUint32(&o.TICK_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetTICK_CONF_TICK_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.TICK_CONF.Reg) & 0x10000) >> 16
}

// SYSCON.CLK_OUT_EN
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK20_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK20_OEN() uint32 {
	return volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x1
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK22_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK22_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK44_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK44_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK_BB_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK_BB_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK80_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK80_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK160_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK160_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK_320M_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK_320M_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK_ADC_INF_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK_ADC_INF_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK_DAC_CPU_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK_DAC_CPU_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK40X_BB_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK40X_BB_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetCLK_OUT_EN_CLK_XTAL_OEN(value uint32) {
	volatile.StoreUint32(&o.CLK_OUT_EN.Reg, volatile.LoadUint32(&o.CLK_OUT_EN.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetCLK_OUT_EN_CLK_XTAL_OEN() uint32 {
	return (volatile.LoadUint32(&o.CLK_OUT_EN.Reg) & 0x400) >> 10
}

// SYSCON.HOST_INF_SEL
func (o *SYSCON_Type) SetHOST_INF_SEL_PERI_IO_SWAP(value uint32) {
	volatile.StoreUint32(&o.HOST_INF_SEL.Reg, volatile.LoadUint32(&o.HOST_INF_SEL.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetHOST_INF_SEL_PERI_IO_SWAP() uint32 {
	return volatile.LoadUint32(&o.HOST_INF_SEL.Reg) & 0xff
}

// SYSCON.EXT_MEM_PMS_LOCK
func (o *SYSCON_Type) SetEXT_MEM_PMS_LOCK(value uint32) {
	volatile.StoreUint32(&o.EXT_MEM_PMS_LOCK.Reg, volatile.LoadUint32(&o.EXT_MEM_PMS_LOCK.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetEXT_MEM_PMS_LOCK() uint32 {
	return volatile.LoadUint32(&o.EXT_MEM_PMS_LOCK.Reg) & 0x1
}

// SYSCON.FLASH_ACE0_ATTR
func (o *SYSCON_Type) SetFLASH_ACE0_ATTR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE0_ATTR.Reg, volatile.LoadUint32(&o.FLASH_ACE0_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE0_ATTR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE0_ATTR.Reg) & 0x7
}

// SYSCON.FLASH_ACE1_ATTR
func (o *SYSCON_Type) SetFLASH_ACE1_ATTR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE1_ATTR.Reg, volatile.LoadUint32(&o.FLASH_ACE1_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE1_ATTR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE1_ATTR.Reg) & 0x7
}

// SYSCON.FLASH_ACE2_ATTR
func (o *SYSCON_Type) SetFLASH_ACE2_ATTR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE2_ATTR.Reg, volatile.LoadUint32(&o.FLASH_ACE2_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE2_ATTR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE2_ATTR.Reg) & 0x7
}

// SYSCON.FLASH_ACE3_ATTR
func (o *SYSCON_Type) SetFLASH_ACE3_ATTR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE3_ATTR.Reg, volatile.LoadUint32(&o.FLASH_ACE3_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE3_ATTR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE3_ATTR.Reg) & 0x7
}

// SYSCON.FLASH_ACE0_ADDR
func (o *SYSCON_Type) SetFLASH_ACE0_ADDR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE0_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetFLASH_ACE0_ADDR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE0_ADDR.Reg)
}

// SYSCON.FLASH_ACE1_ADDR
func (o *SYSCON_Type) SetFLASH_ACE1_ADDR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE1_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetFLASH_ACE1_ADDR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE1_ADDR.Reg)
}

// SYSCON.FLASH_ACE2_ADDR
func (o *SYSCON_Type) SetFLASH_ACE2_ADDR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE2_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetFLASH_ACE2_ADDR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE2_ADDR.Reg)
}

// SYSCON.FLASH_ACE3_ADDR
func (o *SYSCON_Type) SetFLASH_ACE3_ADDR(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE3_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetFLASH_ACE3_ADDR() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE3_ADDR.Reg)
}

// SYSCON.FLASH_ACE0_SIZE
func (o *SYSCON_Type) SetFLASH_ACE0_SIZE(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE0_SIZE.Reg, volatile.LoadUint32(&o.FLASH_ACE0_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE0_SIZE() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE0_SIZE.Reg) & 0xffff
}

// SYSCON.FLASH_ACE1_SIZE
func (o *SYSCON_Type) SetFLASH_ACE1_SIZE(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE1_SIZE.Reg, volatile.LoadUint32(&o.FLASH_ACE1_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE1_SIZE() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE1_SIZE.Reg) & 0xffff
}

// SYSCON.FLASH_ACE2_SIZE
func (o *SYSCON_Type) SetFLASH_ACE2_SIZE(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE2_SIZE.Reg, volatile.LoadUint32(&o.FLASH_ACE2_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE2_SIZE() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE2_SIZE.Reg) & 0xffff
}

// SYSCON.FLASH_ACE3_SIZE
func (o *SYSCON_Type) SetFLASH_ACE3_SIZE(value uint32) {
	volatile.StoreUint32(&o.FLASH_ACE3_SIZE.Reg, volatile.LoadUint32(&o.FLASH_ACE3_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetFLASH_ACE3_SIZE() uint32 {
	return volatile.LoadUint32(&o.FLASH_ACE3_SIZE.Reg) & 0xffff
}

// SYSCON.SRAM_ACE0_ATTR
func (o *SYSCON_Type) SetSRAM_ACE0_ATTR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE0_ATTR.Reg, volatile.LoadUint32(&o.SRAM_ACE0_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE0_ATTR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE0_ATTR.Reg) & 0x7
}

// SYSCON.SRAM_ACE1_ATTR
func (o *SYSCON_Type) SetSRAM_ACE1_ATTR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE1_ATTR.Reg, volatile.LoadUint32(&o.SRAM_ACE1_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE1_ATTR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE1_ATTR.Reg) & 0x7
}

// SYSCON.SRAM_ACE2_ATTR
func (o *SYSCON_Type) SetSRAM_ACE2_ATTR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE2_ATTR.Reg, volatile.LoadUint32(&o.SRAM_ACE2_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE2_ATTR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE2_ATTR.Reg) & 0x7
}

// SYSCON.SRAM_ACE3_ATTR
func (o *SYSCON_Type) SetSRAM_ACE3_ATTR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE3_ATTR.Reg, volatile.LoadUint32(&o.SRAM_ACE3_ATTR.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE3_ATTR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE3_ATTR.Reg) & 0x7
}

// SYSCON.SRAM_ACE0_ADDR
func (o *SYSCON_Type) SetSRAM_ACE0_ADDR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE0_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetSRAM_ACE0_ADDR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE0_ADDR.Reg)
}

// SYSCON.SRAM_ACE1_ADDR
func (o *SYSCON_Type) SetSRAM_ACE1_ADDR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE1_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetSRAM_ACE1_ADDR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE1_ADDR.Reg)
}

// SYSCON.SRAM_ACE2_ADDR
func (o *SYSCON_Type) SetSRAM_ACE2_ADDR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE2_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetSRAM_ACE2_ADDR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE2_ADDR.Reg)
}

// SYSCON.SRAM_ACE3_ADDR
func (o *SYSCON_Type) SetSRAM_ACE3_ADDR(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE3_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetSRAM_ACE3_ADDR() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE3_ADDR.Reg)
}

// SYSCON.SRAM_ACE0_SIZE
func (o *SYSCON_Type) SetSRAM_ACE0_SIZE(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE0_SIZE.Reg, volatile.LoadUint32(&o.SRAM_ACE0_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE0_SIZE() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE0_SIZE.Reg) & 0xffff
}

// SYSCON.SRAM_ACE1_SIZE
func (o *SYSCON_Type) SetSRAM_ACE1_SIZE(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE1_SIZE.Reg, volatile.LoadUint32(&o.SRAM_ACE1_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE1_SIZE() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE1_SIZE.Reg) & 0xffff
}

// SYSCON.SRAM_ACE2_SIZE
func (o *SYSCON_Type) SetSRAM_ACE2_SIZE(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE2_SIZE.Reg, volatile.LoadUint32(&o.SRAM_ACE2_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE2_SIZE() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE2_SIZE.Reg) & 0xffff
}

// SYSCON.SRAM_ACE3_SIZE
func (o *SYSCON_Type) SetSRAM_ACE3_SIZE(value uint32) {
	volatile.StoreUint32(&o.SRAM_ACE3_SIZE.Reg, volatile.LoadUint32(&o.SRAM_ACE3_SIZE.Reg)&^(0xffff)|value)
}
func (o *SYSCON_Type) GetSRAM_ACE3_SIZE() uint32 {
	return volatile.LoadUint32(&o.SRAM_ACE3_SIZE.Reg) & 0xffff
}

// SYSCON.SPI_MEM_PMS_CTRL
func (o *SYSCON_Type) SetSPI_MEM_PMS_CTRL_SPI_MEM_REJECT_INT(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_CTRL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSPI_MEM_PMS_CTRL_SPI_MEM_REJECT_INT() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_PMS_CTRL.Reg) & 0x1
}
func (o *SYSCON_Type) SetSPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CLR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_CTRL.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CDE(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_PMS_CTRL.Reg, volatile.LoadUint32(&o.SPI_MEM_PMS_CTRL.Reg)&^(0x7c)|value<<2)
}
func (o *SYSCON_Type) GetSPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CDE() uint32 {
	return (volatile.LoadUint32(&o.SPI_MEM_PMS_CTRL.Reg) & 0x7c) >> 2
}

// SYSCON.SPI_MEM_REJECT_ADDR
func (o *SYSCON_Type) SetSPI_MEM_REJECT_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_MEM_REJECT_ADDR.Reg, value)
}
func (o *SYSCON_Type) GetSPI_MEM_REJECT_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_MEM_REJECT_ADDR.Reg)
}

// SYSCON.SDIO_CTRL
func (o *SYSCON_Type) SetSDIO_CTRL_SDIO_WIN_ACCESS_EN(value uint32) {
	volatile.StoreUint32(&o.SDIO_CTRL.Reg, volatile.LoadUint32(&o.SDIO_CTRL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSDIO_CTRL_SDIO_WIN_ACCESS_EN() uint32 {
	return volatile.LoadUint32(&o.SDIO_CTRL.Reg) & 0x1
}

// SYSCON.REDCY_SIG0
func (o *SYSCON_Type) SetREDCY_SIG0(value uint32) {
	volatile.StoreUint32(&o.REDCY_SIG0.Reg, volatile.LoadUint32(&o.REDCY_SIG0.Reg)&^(0x7fffffff)|value)
}
func (o *SYSCON_Type) GetREDCY_SIG0() uint32 {
	return volatile.LoadUint32(&o.REDCY_SIG0.Reg) & 0x7fffffff
}
func (o *SYSCON_Type) SetREDCY_SIG0_REDCY_ANDOR(value uint32) {
	volatile.StoreUint32(&o.REDCY_SIG0.Reg, volatile.LoadUint32(&o.REDCY_SIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetREDCY_SIG0_REDCY_ANDOR() uint32 {
	return (volatile.LoadUint32(&o.REDCY_SIG0.Reg) & 0x80000000) >> 31
}

// SYSCON.REDCY_SIG1
func (o *SYSCON_Type) SetREDCY_SIG1(value uint32) {
	volatile.StoreUint32(&o.REDCY_SIG1.Reg, volatile.LoadUint32(&o.REDCY_SIG1.Reg)&^(0x7fffffff)|value)
}
func (o *SYSCON_Type) GetREDCY_SIG1() uint32 {
	return volatile.LoadUint32(&o.REDCY_SIG1.Reg) & 0x7fffffff
}
func (o *SYSCON_Type) SetREDCY_SIG1_REDCY_NANDOR(value uint32) {
	volatile.StoreUint32(&o.REDCY_SIG1.Reg, volatile.LoadUint32(&o.REDCY_SIG1.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetREDCY_SIG1_REDCY_NANDOR() uint32 {
	return (volatile.LoadUint32(&o.REDCY_SIG1.Reg) & 0x80000000) >> 31
}

// SYSCON.WIFI_BB_CFG
func (o *SYSCON_Type) SetWIFI_BB_CFG(value uint32) {
	volatile.StoreUint32(&o.WIFI_BB_CFG.Reg, value)
}
func (o *SYSCON_Type) GetWIFI_BB_CFG() uint32 {
	return volatile.LoadUint32(&o.WIFI_BB_CFG.Reg)
}

// SYSCON.WIFI_BB_CFG_2
func (o *SYSCON_Type) SetWIFI_BB_CFG_2(value uint32) {
	volatile.StoreUint32(&o.WIFI_BB_CFG_2.Reg, value)
}
func (o *SYSCON_Type) GetWIFI_BB_CFG_2() uint32 {
	return volatile.LoadUint32(&o.WIFI_BB_CFG_2.Reg)
}

// SYSCON.WIFI_CLK_EN
func (o *SYSCON_Type) SetWIFI_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.WIFI_CLK_EN.Reg, value)
}
func (o *SYSCON_Type) GetWIFI_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.WIFI_CLK_EN.Reg)
}

// SYSCON.WIFI_RST_EN
func (o *SYSCON_Type) SetWIFI_RST_EN(value uint32) {
	volatile.StoreUint32(&o.WIFI_RST_EN.Reg, value)
}
func (o *SYSCON_Type) GetWIFI_RST_EN() uint32 {
	return volatile.LoadUint32(&o.WIFI_RST_EN.Reg)
}

// SYSCON.FRONT_END_MEM_PD
func (o *SYSCON_Type) SetFRONT_END_MEM_PD_AGC_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.FRONT_END_MEM_PD.Reg, volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetFRONT_END_MEM_PD_AGC_MEM_FORCE_PU() uint32 {
	return volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg) & 0x1
}
func (o *SYSCON_Type) SetFRONT_END_MEM_PD_AGC_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.FRONT_END_MEM_PD.Reg, volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetFRONT_END_MEM_PD_AGC_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetFRONT_END_MEM_PD_PBUS_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.FRONT_END_MEM_PD.Reg, volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetFRONT_END_MEM_PD_PBUS_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetFRONT_END_MEM_PD_PBUS_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.FRONT_END_MEM_PD.Reg, volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetFRONT_END_MEM_PD_PBUS_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetFRONT_END_MEM_PD_DC_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.FRONT_END_MEM_PD.Reg, volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetFRONT_END_MEM_PD_DC_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetFRONT_END_MEM_PD_DC_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.FRONT_END_MEM_PD.Reg, volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetFRONT_END_MEM_PD_DC_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.FRONT_END_MEM_PD.Reg) & 0x20) >> 5
}

// SYSCON.DATE
func (o *SYSCON_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *SYSCON_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// System Configuration Registers
type SYSTEM_Type struct {
	ROM_CTRL_0                              volatile.Register32 // 0x0
	ROM_CTRL_1                              volatile.Register32 // 0x4
	SRAM_CTRL_0                             volatile.Register32 // 0x8
	SRAM_CTRL_1                             volatile.Register32 // 0xC
	CPU_PERI_CLK_EN                         volatile.Register32 // 0x10
	CPU_PERI_RST_EN                         volatile.Register32 // 0x14
	CPU_PER_CONF                            volatile.Register32 // 0x18
	JTAG_CTRL_0                             volatile.Register32 // 0x1C
	JTAG_CTRL_1                             volatile.Register32 // 0x20
	JTAG_CTRL_2                             volatile.Register32 // 0x24
	JTAG_CTRL_3                             volatile.Register32 // 0x28
	JTAG_CTRL_4                             volatile.Register32 // 0x2C
	JTAG_CTRL_5                             volatile.Register32 // 0x30
	JTAG_CTRL_6                             volatile.Register32 // 0x34
	JTAG_CTRL_7                             volatile.Register32 // 0x38
	MEM_PD_MASK                             volatile.Register32 // 0x3C
	PERIP_CLK_EN0                           volatile.Register32 // 0x40
	PERIP_CLK_EN1                           volatile.Register32 // 0x44
	PERIP_RST_EN0                           volatile.Register32 // 0x48
	PERIP_RST_EN1                           volatile.Register32 // 0x4C
	LPCK_DIV_INT                            volatile.Register32 // 0x50
	BT_LPCK_DIV_FRAC                        volatile.Register32 // 0x54
	CPU_INTR_FROM_CPU_0                     volatile.Register32 // 0x58
	CPU_INTR_FROM_CPU_1                     volatile.Register32 // 0x5C
	CPU_INTR_FROM_CPU_2                     volatile.Register32 // 0x60
	CPU_INTR_FROM_CPU_3                     volatile.Register32 // 0x64
	RSA_PD_CTRL                             volatile.Register32 // 0x68
	BUSTOEXTMEM_ENA                         volatile.Register32 // 0x6C
	CACHE_CONTROL                           volatile.Register32 // 0x70
	EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL volatile.Register32 // 0x74
	RTC_FASTMEM_CONFIG                      volatile.Register32 // 0x78
	RTC_FASTMEM_CRC                         volatile.Register32 // 0x7C
	Redundant_ECO_Ctrl                      volatile.Register32 // 0x80
	CLOCK_GATE                              volatile.Register32 // 0x84
	SRAM_CTRL_2                             volatile.Register32 // 0x88
	SYSCLK_CONF                             volatile.Register32 // 0x8C
	_                                       [3948]byte
	DATE                                    volatile.Register32 // 0xFFC
}

// SYSTEM.ROM_CTRL_0: System ROM configuration register 0
func (o *SYSTEM_Type) SetROM_CTRL_0_ROM_FO(value uint32) {
	volatile.StoreUint32(&o.ROM_CTRL_0.Reg, volatile.LoadUint32(&o.ROM_CTRL_0.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetROM_CTRL_0_ROM_FO() uint32 {
	return volatile.LoadUint32(&o.ROM_CTRL_0.Reg) & 0x3
}

// SYSTEM.ROM_CTRL_1: System ROM configuration register 1
func (o *SYSTEM_Type) SetROM_CTRL_1_ROM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.ROM_CTRL_1.Reg, volatile.LoadUint32(&o.ROM_CTRL_1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetROM_CTRL_1_ROM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.ROM_CTRL_1.Reg) & 0x3
}
func (o *SYSTEM_Type) SetROM_CTRL_1_ROM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.ROM_CTRL_1.Reg, volatile.LoadUint32(&o.ROM_CTRL_1.Reg)&^(0xc)|value<<2)
}
func (o *SYSTEM_Type) GetROM_CTRL_1_ROM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.ROM_CTRL_1.Reg) & 0xc) >> 2
}

// SYSTEM.SRAM_CTRL_0: System SRAM configuration register 0
func (o *SYSTEM_Type) SetSRAM_CTRL_0_SRAM_FO(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL_0.Reg, volatile.LoadUint32(&o.SRAM_CTRL_0.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetSRAM_CTRL_0_SRAM_FO() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL_0.Reg) & 0x3fffff
}

// SYSTEM.SRAM_CTRL_1: System SRAM configuration register 1
func (o *SYSTEM_Type) SetSRAM_CTRL_1_SRAM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL_1.Reg, volatile.LoadUint32(&o.SRAM_CTRL_1.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetSRAM_CTRL_1_SRAM_FORCE_PD() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL_1.Reg) & 0x3fffff
}

// SYSTEM.CPU_PERI_CLK_EN: CPU peripheral clock enable register
func (o *SYSTEM_Type) SetCPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_CLK_EN.Reg, volatile.LoadUint32(&o.CPU_PERI_CLK_EN.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERI_CLK_EN.Reg) & 0x80) >> 7
}

// SYSTEM.CPU_PERI_RST_EN: CPU peripheral reset register
func (o *SYSTEM_Type) SetCPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO(value uint32) {
	volatile.StoreUint32(&o.CPU_PERI_RST_EN.Reg, volatile.LoadUint32(&o.CPU_PERI_RST_EN.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO() uint32 {
	return (volatile.LoadUint32(&o.CPU_PERI_RST_EN.Reg) & 0x80) >> 7
}

// SYSTEM.CPU_PER_CONF: CPU peripheral clock configuration register
func (o *SYSTEM_Type) SetCPU_PER_CONF_CPUPERIOD_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_CPUPERIOD_SEL() uint32 {
	return volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0x3
}
func (o *SYSTEM_Type) SetCPU_PER_CONF_PLL_FREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_PLL_FREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetCPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetCPU_PER_CONF_CPU_WAITI_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.CPU_PER_CONF.Reg, volatile.LoadUint32(&o.CPU_PER_CONF.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetCPU_PER_CONF_CPU_WAITI_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.CPU_PER_CONF.Reg) & 0xf0) >> 4
}

// SYSTEM.JTAG_CTRL_0: JTAG configuration register 0
func (o *SYSTEM_Type) SetJTAG_CTRL_0(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_0.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_0() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_0.Reg)
}

// SYSTEM.JTAG_CTRL_1: JTAG configuration register 1
func (o *SYSTEM_Type) SetJTAG_CTRL_1(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_1.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_1() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_1.Reg)
}

// SYSTEM.JTAG_CTRL_2: JTAG configuration register 2
func (o *SYSTEM_Type) SetJTAG_CTRL_2(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_2.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_2() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_2.Reg)
}

// SYSTEM.JTAG_CTRL_3: JTAG configuration register 3
func (o *SYSTEM_Type) SetJTAG_CTRL_3(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_3.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_3() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_3.Reg)
}

// SYSTEM.JTAG_CTRL_4: JTAG configuration register 4
func (o *SYSTEM_Type) SetJTAG_CTRL_4(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_4.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_4() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_4.Reg)
}

// SYSTEM.JTAG_CTRL_5: JTAG configuration register 5
func (o *SYSTEM_Type) SetJTAG_CTRL_5(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_5.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_5() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_5.Reg)
}

// SYSTEM.JTAG_CTRL_6: JTAG configuration register 6
func (o *SYSTEM_Type) SetJTAG_CTRL_6(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_6.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_6() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_6.Reg)
}

// SYSTEM.JTAG_CTRL_7: JTAG configuration register 7
func (o *SYSTEM_Type) SetJTAG_CTRL_7(value uint32) {
	volatile.StoreUint32(&o.JTAG_CTRL_7.Reg, value)
}
func (o *SYSTEM_Type) GetJTAG_CTRL_7() uint32 {
	return volatile.LoadUint32(&o.JTAG_CTRL_7.Reg)
}

// SYSTEM.MEM_PD_MASK: Memory power-related controlling register (under low-sleep)
func (o *SYSTEM_Type) SetMEM_PD_MASK_LSLP_MEM_PD_MASK(value uint32) {
	volatile.StoreUint32(&o.MEM_PD_MASK.Reg, volatile.LoadUint32(&o.MEM_PD_MASK.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMEM_PD_MASK_LSLP_MEM_PD_MASK() uint32 {
	return volatile.LoadUint32(&o.MEM_PD_MASK.Reg) & 0x1
}

// SYSTEM.PERIP_CLK_EN0: System peripheral clock (for hardware accelerators) enable register
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TIMERS_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TIMERS_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x1
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI01_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI01_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UART_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UART_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_WDG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_WDG_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2S0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2S0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UART1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UART1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI2_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI2_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2C_EXT0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2C_EXT0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UHCI0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UHCI0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_RMT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_RMT_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PCNT_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PCNT_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_LEDC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_LEDC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UHCI1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UHCI1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TIMERGROUP_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TIMERGROUP_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x2000) >> 13
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_EFUSE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_EFUSE_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TIMERGROUP1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TIMERGROUP1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI3_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI3_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x10000) >> 16
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2C_EXT1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2C_EXT1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x40000) >> 18
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_TWAI_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_TWAI_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x80000) >> 19
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x100000) >> 20
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_I2S1_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_I2S1_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x200000) >> 21
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI2_DMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI2_DMA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_USB_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_USB_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x800000) >> 23
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_UART_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_UART_MEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM2_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM2_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_PWM3_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_PWM3_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x4000000) >> 26
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI3_DMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI3_DMA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_APB_SARADC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_APB_SARADC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SYSTIMER_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SYSTIMER_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_ADC2_ARB_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_ADC2_ARB_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN0_SPI4_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN0.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN0_SPI4_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN0.Reg) & 0x80000000) >> 31
}

// SYSTEM.PERIP_CLK_EN1: System peripheral clock (for hardware accelerators) enable register 1
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_AES_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_AES_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_SHA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_SHA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_RSA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_RSA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_DS_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_DS_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_CLK_EN1_CRYPTO_DMA_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.PERIP_CLK_EN1.Reg, volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_CLK_EN1_CRYPTO_DMA_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.PERIP_CLK_EN1.Reg) & 0x40) >> 6
}

// SYSTEM.PERIP_RST_EN0: System peripheral (hardware accelerators) reset register 0
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TIMERS_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TIMERS_RST() uint32 {
	return volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x1
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI01_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI01_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UART_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UART_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_WDG_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_WDG_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2S0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2S0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UART1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UART1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI2_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI2_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2C_EXT0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2C_EXT0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UHCI0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UHCI0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_RMT_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_RMT_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PCNT_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PCNT_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_LEDC_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_LEDC_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UHCI1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UHCI1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TIMERGROUP_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TIMERGROUP_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x2000) >> 13
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_EFUSE_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_EFUSE_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TIMERGROUP1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TIMERGROUP1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI3_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI3_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x10000) >> 16
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM0_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM0_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2C_EXT1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2C_EXT1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x40000) >> 18
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_TWAI_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_TWAI_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x80000) >> 19
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x100000) >> 20
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_I2S1_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_I2S1_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x200000) >> 21
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI2_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI2_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_USB_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_USB_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x800000) >> 23
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_UART_MEM_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_UART_MEM_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM2_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM2_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_PWM3_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_PWM3_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x4000000) >> 26
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI3_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI3_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_APB_SARADC_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_APB_SARADC_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SYSTIMER_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SYSTIMER_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_ADC2_ARB_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_ADC2_ARB_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetPERIP_RST_EN0_SPI4_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN0.Reg, volatile.LoadUint32(&o.PERIP_RST_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN0_SPI4_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN0.Reg) & 0x80000000) >> 31
}

// SYSTEM.PERIP_RST_EN1: System peripheral (hardware accelerators) reset register 1
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_AES_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_AES_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_SHA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_SHA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_RSA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_RSA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_DS_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_DS_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_HMAC_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_HMAC_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetPERIP_RST_EN1_CRYPTO_DMA_RST(value uint32) {
	volatile.StoreUint32(&o.PERIP_RST_EN1.Reg, volatile.LoadUint32(&o.PERIP_RST_EN1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetPERIP_RST_EN1_CRYPTO_DMA_RST() uint32 {
	return (volatile.LoadUint32(&o.PERIP_RST_EN1.Reg) & 0x40) >> 6
}

// SYSTEM.LPCK_DIV_INT: Low power clock divider integer register
func (o *SYSTEM_Type) SetLPCK_DIV_INT_LPCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.LPCK_DIV_INT.Reg, volatile.LoadUint32(&o.LPCK_DIV_INT.Reg)&^(0xfff)|value)
}
func (o *SYSTEM_Type) GetLPCK_DIV_INT_LPCK_DIV_NUM() uint32 {
	return volatile.LoadUint32(&o.LPCK_DIV_INT.Reg) & 0xfff
}

// SYSTEM.BT_LPCK_DIV_FRAC: Divider fraction configuration register for low-power clock
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_8M(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_8M() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x4000000) >> 26
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x8000000) >> 27
}
func (o *SYSTEM_Type) SetBT_LPCK_DIV_FRAC_LPCLK_RTC_EN(value uint32) {
	volatile.StoreUint32(&o.BT_LPCK_DIV_FRAC.Reg, volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetBT_LPCK_DIV_FRAC_LPCLK_RTC_EN() uint32 {
	return (volatile.LoadUint32(&o.BT_LPCK_DIV_FRAC.Reg) & 0x10000000) >> 28
}

// SYSTEM.CPU_INTR_FROM_CPU_0: CPU interrupt controlling register 0
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_0(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_0.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_0() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_0.Reg) & 0x1
}

// SYSTEM.CPU_INTR_FROM_CPU_1: CPU interrupt controlling register 1
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_1(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_1.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_1() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_1.Reg) & 0x1
}

// SYSTEM.CPU_INTR_FROM_CPU_2: CPU interrupt controlling register 2
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_2(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_2.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_2() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_2.Reg) & 0x1
}

// SYSTEM.CPU_INTR_FROM_CPU_3: CPU interrupt controlling register 3
func (o *SYSTEM_Type) SetCPU_INTR_FROM_CPU_3(value uint32) {
	volatile.StoreUint32(&o.CPU_INTR_FROM_CPU_3.Reg, volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCPU_INTR_FROM_CPU_3() uint32 {
	return volatile.LoadUint32(&o.CPU_INTR_FROM_CPU_3.Reg) & 0x1
}

// SYSTEM.RSA_PD_CTRL: RSA memory remapping register
func (o *SYSTEM_Type) SetRSA_PD_CTRL_RSA_MEM_PD(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSA_PD_CTRL_RSA_MEM_PD() uint32 {
	return volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x1
}
func (o *SYSTEM_Type) SetRSA_PD_CTRL_RSA_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSA_PD_CTRL_RSA_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSA_PD_CTRL_RSA_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.RSA_PD_CTRL.Reg, volatile.LoadUint32(&o.RSA_PD_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSA_PD_CTRL_RSA_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.RSA_PD_CTRL.Reg) & 0x4) >> 2
}

// SYSTEM.BUSTOEXTMEM_ENA: EDMA enable register
func (o *SYSTEM_Type) SetBUSTOEXTMEM_ENA(value uint32) {
	volatile.StoreUint32(&o.BUSTOEXTMEM_ENA.Reg, volatile.LoadUint32(&o.BUSTOEXTMEM_ENA.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetBUSTOEXTMEM_ENA() uint32 {
	return volatile.LoadUint32(&o.BUSTOEXTMEM_ENA.Reg) & 0x1
}

// SYSTEM.CACHE_CONTROL: Cache control register
func (o *SYSTEM_Type) SetCACHE_CONTROL_PRO_ICACHE_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONTROL.Reg, volatile.LoadUint32(&o.CACHE_CONTROL.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCACHE_CONTROL_PRO_ICACHE_CLK_ON() uint32 {
	return volatile.LoadUint32(&o.CACHE_CONTROL.Reg) & 0x1
}
func (o *SYSTEM_Type) SetCACHE_CONTROL_PRO_DCACHE_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONTROL.Reg, volatile.LoadUint32(&o.CACHE_CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetCACHE_CONTROL_PRO_DCACHE_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.CACHE_CONTROL.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetCACHE_CONTROL_PRO_CACHE_RESET(value uint32) {
	volatile.StoreUint32(&o.CACHE_CONTROL.Reg, volatile.LoadUint32(&o.CACHE_CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetCACHE_CONTROL_PRO_CACHE_RESET() uint32 {
	return (volatile.LoadUint32(&o.CACHE_CONTROL.Reg) & 0x4) >> 2
}

// SYSTEM.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL: External memory encrypt and decrypt controlling register
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT() uint32 {
	return volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x1
}
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg, volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetEXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL.Reg) & 0x8) >> 3
}

// SYSTEM.RTC_FASTMEM_CONFIG: RTC fast memory configuration register
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_START(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_START() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0xffe00)|value<<9)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0xffe00) >> 9
}
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0x7ff00000)|value<<20)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0x7ff00000) >> 20
}
func (o *SYSTEM_Type) SetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CONFIG.Reg, volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH() uint32 {
	return (volatile.LoadUint32(&o.RTC_FASTMEM_CONFIG.Reg) & 0x80000000) >> 31
}

// SYSTEM.RTC_FASTMEM_CRC: RTC fast memory CRC controlling register
func (o *SYSTEM_Type) SetRTC_FASTMEM_CRC(value uint32) {
	volatile.StoreUint32(&o.RTC_FASTMEM_CRC.Reg, value)
}
func (o *SYSTEM_Type) GetRTC_FASTMEM_CRC() uint32 {
	return volatile.LoadUint32(&o.RTC_FASTMEM_CRC.Reg)
}

// SYSTEM.Redundant_ECO_Ctrl: Redundant ECO control register
func (o *SYSTEM_Type) SetRedundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE(value uint32) {
	volatile.StoreUint32(&o.Redundant_ECO_Ctrl.Reg, volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRedundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE() uint32 {
	return volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg) & 0x1
}
func (o *SYSTEM_Type) SetRedundant_ECO_Ctrl_REDUNDANT_ECO_RESULT(value uint32) {
	volatile.StoreUint32(&o.Redundant_ECO_Ctrl.Reg, volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRedundant_ECO_Ctrl_REDUNDANT_ECO_RESULT() uint32 {
	return (volatile.LoadUint32(&o.Redundant_ECO_Ctrl.Reg) & 0x2) >> 1
}

// SYSTEM.CLOCK_GATE: Clock gate control register
func (o *SYSTEM_Type) SetCLOCK_GATE_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLOCK_GATE.Reg, volatile.LoadUint32(&o.CLOCK_GATE.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetCLOCK_GATE_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLOCK_GATE.Reg) & 0x1
}

// SYSTEM.SRAM_CTRL_2: System SRAM configuration register 2
func (o *SYSTEM_Type) SetSRAM_CTRL_2_SRAM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.SRAM_CTRL_2.Reg, volatile.LoadUint32(&o.SRAM_CTRL_2.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetSRAM_CTRL_2_SRAM_FORCE_PU() uint32 {
	return volatile.LoadUint32(&o.SRAM_CTRL_2.Reg) & 0x3fffff
}

// SYSTEM.SYSCLK_CONF: SoC clock configuration register
func (o *SYSTEM_Type) SetSYSCLK_CONF_PRE_DIV_CNT(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x3ff)|value)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_PRE_DIV_CNT() uint32 {
	return volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x3ff
}
func (o *SYSTEM_Type) SetSYSCLK_CONF_SOC_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0xc00)|value<<10)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_SOC_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0xc00) >> 10
}
func (o *SYSTEM_Type) SetSYSCLK_CONF_CLK_XTAL_FREQ(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x7f000)|value<<12)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_CLK_XTAL_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x7f000) >> 12
}
func (o *SYSTEM_Type) SetSYSCLK_CONF_CLK_DIV_EN(value uint32) {
	volatile.StoreUint32(&o.SYSCLK_CONF.Reg, volatile.LoadUint32(&o.SYSCLK_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *SYSTEM_Type) GetSYSCLK_CONF_CLK_DIV_EN() uint32 {
	return (volatile.LoadUint32(&o.SYSCLK_CONF.Reg) & 0x80000) >> 19
}

// SYSTEM.DATE: Version control register
func (o *SYSTEM_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0xfffffff)|value)
}
func (o *SYSTEM_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0xfffffff
}

// System Timer
type SYSTIMER_Type struct {
	CONF           volatile.Register32 // 0x0
	LOAD           volatile.Register32 // 0x4
	LOAD_HI        volatile.Register32 // 0x8
	LOAD_LO        volatile.Register32 // 0xC
	STEP           volatile.Register32 // 0x10
	TARGET0_HI     volatile.Register32 // 0x14
	TARGET0_LO     volatile.Register32 // 0x18
	TARGET1_HI     volatile.Register32 // 0x1C
	TARGET1_LO     volatile.Register32 // 0x20
	TARGET2_HI     volatile.Register32 // 0x24
	TARGET2_LO     volatile.Register32 // 0x28
	TARGET0_CONF   volatile.Register32 // 0x2C
	TARGET1_CONF   volatile.Register32 // 0x30
	TARGET2_CONF   volatile.Register32 // 0x34
	UNIT0_OP       volatile.Register32 // 0x38
	UNIT0_VALUE_HI volatile.Register32 // 0x3C
	UNIT0_VALUE_LO volatile.Register32 // 0x40
	INT_ENA        volatile.Register32 // 0x44
	INT_RAW        volatile.Register32 // 0x48
	INT_CLR        volatile.Register32 // 0x4C
	_              [172]byte
	DATE           volatile.Register32 // 0xFC
}

// SYSTIMER.CONF: Configure system timer clock
func (o *SYSTIMER_Type) SetCONF_CLK_FO(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetCONF_CLK_FO() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetCONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetCONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.LOAD: Load value to system timer
func (o *SYSTIMER_Type) SetLOAD_TIMER_LOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, volatile.LoadUint32(&o.LOAD.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetLOAD_TIMER_LOAD() uint32 {
	return (volatile.LoadUint32(&o.LOAD.Reg) & 0x80000000) >> 31
}

// SYSTIMER.LOAD_HI: High 32 bits to be loaded to system timer
func (o *SYSTIMER_Type) SetLOAD_HI(value uint32) {
	volatile.StoreUint32(&o.LOAD_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetLOAD_HI() uint32 {
	return volatile.LoadUint32(&o.LOAD_HI.Reg)
}

// SYSTIMER.LOAD_LO: Low 32 bits to be loaded to system timer
func (o *SYSTIMER_Type) SetLOAD_LO(value uint32) {
	volatile.StoreUint32(&o.LOAD_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetLOAD_LO() uint32 {
	return volatile.LoadUint32(&o.LOAD_LO.Reg)
}

// SYSTIMER.STEP: System timer accumulation step
func (o *SYSTIMER_Type) SetSTEP_TIMER_XTAL_STEP(value uint32) {
	volatile.StoreUint32(&o.STEP.Reg, volatile.LoadUint32(&o.STEP.Reg)&^(0x3ff)|value)
}
func (o *SYSTIMER_Type) GetSTEP_TIMER_XTAL_STEP() uint32 {
	return volatile.LoadUint32(&o.STEP.Reg) & 0x3ff
}
func (o *SYSTIMER_Type) SetSTEP_TIMER_PLL_STEP(value uint32) {
	volatile.StoreUint32(&o.STEP.Reg, volatile.LoadUint32(&o.STEP.Reg)&^(0xffc00)|value<<10)
}
func (o *SYSTIMER_Type) GetSTEP_TIMER_PLL_STEP() uint32 {
	return (volatile.LoadUint32(&o.STEP.Reg) & 0xffc00) >> 10
}

// SYSTIMER.TARGET0_HI: System timer target 0, high 32 bits
func (o *SYSTIMER_Type) SetTARGET0_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET0_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET0_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET0_HI.Reg)
}

// SYSTIMER.TARGET0_LO: System timer target 0, low 32 bits
func (o *SYSTIMER_Type) SetTARGET0_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET0_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET0_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET0_LO.Reg)
}

// SYSTIMER.TARGET1_HI: System timer target 1, high 32 bits
func (o *SYSTIMER_Type) SetTARGET1_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET1_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET1_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET1_HI.Reg)
}

// SYSTIMER.TARGET1_LO: System timer target 1, low 32 bits
func (o *SYSTIMER_Type) SetTARGET1_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET1_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET1_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET1_LO.Reg)
}

// SYSTIMER.TARGET2_HI: System timer target 2, high 32 bits
func (o *SYSTIMER_Type) SetTARGET2_HI(value uint32) {
	volatile.StoreUint32(&o.TARGET2_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET2_HI() uint32 {
	return volatile.LoadUint32(&o.TARGET2_HI.Reg)
}

// SYSTIMER.TARGET2_LO: System timer target 2, low 32 bits
func (o *SYSTIMER_Type) SetTARGET2_LO(value uint32) {
	volatile.StoreUint32(&o.TARGET2_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetTARGET2_LO() uint32 {
	return volatile.LoadUint32(&o.TARGET2_LO.Reg)
}

// SYSTIMER.TARGET0_CONF: Configure work mode for system timer target 0
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x3fffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x3fffffff
}
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET0_CONF_TARGET0_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.TARGET0_CONF.Reg, volatile.LoadUint32(&o.TARGET0_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET0_CONF_TARGET0_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.TARGET0_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.TARGET1_CONF: Configure work mode for system timer target 1
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x3fffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x3fffffff
}
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET1_CONF_TARGET1_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.TARGET1_CONF.Reg, volatile.LoadUint32(&o.TARGET1_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET1_CONF_TARGET1_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.TARGET1_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.TARGET2_CONF: Configure work mode for system timer target 2
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x3fffffff)|value)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_PERIOD() uint32 {
	return volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x3fffffff
}
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_PERIOD_MODE(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_PERIOD_MODE() uint32 {
	return (volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetTARGET2_CONF_TARGET2_WORK_EN(value uint32) {
	volatile.StoreUint32(&o.TARGET2_CONF.Reg, volatile.LoadUint32(&o.TARGET2_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetTARGET2_CONF_TARGET2_WORK_EN() uint32 {
	return (volatile.LoadUint32(&o.TARGET2_CONF.Reg) & 0x80000000) >> 31
}

// SYSTIMER.UNIT0_OP: Read out system timer value
func (o *SYSTIMER_Type) SetUNIT0_OP_TIMER_UNIT0_VALUE_VALID(value uint32) {
	volatile.StoreUint32(&o.UNIT0_OP.Reg, volatile.LoadUint32(&o.UNIT0_OP.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTIMER_Type) GetUNIT0_OP_TIMER_UNIT0_VALUE_VALID() uint32 {
	return (volatile.LoadUint32(&o.UNIT0_OP.Reg) & 0x40000000) >> 30
}
func (o *SYSTIMER_Type) SetUNIT0_OP_TIMER_UNIT0_UPDATE(value uint32) {
	volatile.StoreUint32(&o.UNIT0_OP.Reg, volatile.LoadUint32(&o.UNIT0_OP.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTIMER_Type) GetUNIT0_OP_TIMER_UNIT0_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.UNIT0_OP.Reg) & 0x80000000) >> 31
}

// SYSTIMER.UNIT0_VALUE_HI: System timer value, high 32 bits
func (o *SYSTIMER_Type) SetUNIT0_VALUE_HI(value uint32) {
	volatile.StoreUint32(&o.UNIT0_VALUE_HI.Reg, value)
}
func (o *SYSTIMER_Type) GetUNIT0_VALUE_HI() uint32 {
	return volatile.LoadUint32(&o.UNIT0_VALUE_HI.Reg)
}

// SYSTIMER.UNIT0_VALUE_LO: System timer value, low 32 bits
func (o *SYSTIMER_Type) SetUNIT0_VALUE_LO(value uint32) {
	volatile.StoreUint32(&o.UNIT0_VALUE_LO.Reg, value)
}
func (o *SYSTIMER_Type) GetUNIT0_VALUE_LO() uint32 {
	return volatile.LoadUint32(&o.UNIT0_VALUE_LO.Reg)
}

// SYSTIMER.INT_ENA: System timer interrupt enable
func (o *SYSTIMER_Type) SetINT_ENA_TARGET0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_ENA_TARGET0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_ENA_TARGET1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_ENA_TARGET1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_ENA_TARGET2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_ENA_TARGET2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_RAW: System timer interrupt raw
func (o *SYSTIMER_Type) SetINT_RAW_INT0_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_RAW_INT0_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_RAW_INT1_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_RAW_INT1_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_RAW_INT2_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_RAW_INT2_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}

// SYSTIMER.INT_CLR: System timer interrupt clear
func (o *SYSTIMER_Type) SetINT_CLR_TARGET0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *SYSTIMER_Type) GetINT_CLR_TARGET0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *SYSTIMER_Type) SetINT_CLR_TARGET1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTIMER_Type) GetINT_CLR_TARGET1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *SYSTIMER_Type) SetINT_CLR_TARGET2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTIMER_Type) GetINT_CLR_TARGET2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}

// SYSTIMER.DATE: Version control register
func (o *SYSTIMER_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *SYSTIMER_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// Timer Group 0
type TIMG_Type struct {
	T0CONFIG       volatile.Register32 // 0x0
	T0LO           volatile.Register32 // 0x4
	T0HI           volatile.Register32 // 0x8
	T0UPDATE       volatile.Register32 // 0xC
	T0ALARMLO      volatile.Register32 // 0x10
	T0ALARMHI      volatile.Register32 // 0x14
	T0LOADLO       volatile.Register32 // 0x18
	T0LOADHI       volatile.Register32 // 0x1C
	T0LOAD         volatile.Register32 // 0x20
	T1CONFIG       volatile.Register32 // 0x24
	T1LO           volatile.Register32 // 0x28
	T1HI           volatile.Register32 // 0x2C
	T1UPDATE       volatile.Register32 // 0x30
	T1ALARMLO      volatile.Register32 // 0x34
	T1ALARMHI      volatile.Register32 // 0x38
	T1LOADLO       volatile.Register32 // 0x3C
	T1LOADHI       volatile.Register32 // 0x40
	T1LOAD         volatile.Register32 // 0x44
	WDTCONFIG0     volatile.Register32 // 0x48
	WDTCONFIG1     volatile.Register32 // 0x4C
	WDTCONFIG2     volatile.Register32 // 0x50
	WDTCONFIG3     volatile.Register32 // 0x54
	WDTCONFIG4     volatile.Register32 // 0x58
	WDTCONFIG5     volatile.Register32 // 0x5C
	WDTFEED        volatile.Register32 // 0x60
	WDTWPROTECT    volatile.Register32 // 0x64
	RTCCALICFG     volatile.Register32 // 0x68
	RTCCALICFG1    volatile.Register32 // 0x6C
	LACTCONFIG     volatile.Register32 // 0x70
	LACTRTC        volatile.Register32 // 0x74
	LACTLO         volatile.Register32 // 0x78
	LACTHI         volatile.Register32 // 0x7C
	LACTUPDATE     volatile.Register32 // 0x80
	LACTALARMLO    volatile.Register32 // 0x84
	LACTALARMHI    volatile.Register32 // 0x88
	LACTLOADLO     volatile.Register32 // 0x8C
	LACTLOADHI     volatile.Register32 // 0x90
	LACTLOAD       volatile.Register32 // 0x94
	INT_ENA_TIMERS volatile.Register32 // 0x98
	INT_RAW_TIMERS volatile.Register32 // 0x9C
	INT_ST_TIMERS  volatile.Register32 // 0xA0
	INT_CLR_TIMERS volatile.Register32 // 0xA4
	RTCCALICFG2    volatile.Register32 // 0xA8
	_              [76]byte
	TIMERS_DATE    volatile.Register32 // 0xF8
	REGCLK         volatile.Register32 // 0xFC
}

// TIMG.T0CONFIG: Timer %s configuration register
func (o *TIMG_Type) SetT0CONFIG_USE_XTAL(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG_Type) GetT0CONFIG_USE_XTAL() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG_Type) SetT0CONFIG_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG_Type) GetT0CONFIG_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG_Type) SetT0CONFIG_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x800)|value<<11)
}
func (o *TIMG_Type) GetT0CONFIG_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x800) >> 11
}
func (o *TIMG_Type) SetT0CONFIG_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetT0CONFIG_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetT0CONFIG_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG_Type) GetT0CONFIG_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG_Type) SetT0CONFIG_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG_Type) GetT0CONFIG_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG_Type) SetT0CONFIG_INCREASE(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG_Type) GetT0CONFIG_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG_Type) SetT0CONFIG_EN(value uint32) {
	volatile.StoreUint32(&o.T0CONFIG.Reg, volatile.LoadUint32(&o.T0CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetT0CONFIG_EN() uint32 {
	return (volatile.LoadUint32(&o.T0CONFIG.Reg) & 0x80000000) >> 31
}

// TIMG.T0LO: Timer %s current value, low 32 bits
func (o *TIMG_Type) SetT0LO(value uint32) {
	volatile.StoreUint32(&o.T0LO.Reg, value)
}
func (o *TIMG_Type) GetT0LO() uint32 {
	return volatile.LoadUint32(&o.T0LO.Reg)
}

// TIMG.T0HI: Timer %s current value, high 32 bits
func (o *TIMG_Type) SetT0HI(value uint32) {
	volatile.StoreUint32(&o.T0HI.Reg, value)
}
func (o *TIMG_Type) GetT0HI() uint32 {
	return volatile.LoadUint32(&o.T0HI.Reg)
}

// TIMG.T0UPDATE: Write to copy current timer value to TIMG_T%sLO_REG or TIMGn_T%sHI_REG
func (o *TIMG_Type) SetT0UPDATE_UPDATE(value uint32) {
	volatile.StoreUint32(&o.T0UPDATE.Reg, volatile.LoadUint32(&o.T0UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetT0UPDATE_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.T0UPDATE.Reg) & 0x80000000) >> 31
}

// TIMG.T0ALARMLO: Timer %s alarm value, low 32 bits
func (o *TIMG_Type) SetT0ALARMLO(value uint32) {
	volatile.StoreUint32(&o.T0ALARMLO.Reg, value)
}
func (o *TIMG_Type) GetT0ALARMLO() uint32 {
	return volatile.LoadUint32(&o.T0ALARMLO.Reg)
}

// TIMG.T0ALARMHI: Timer %s alarm value, high bits
func (o *TIMG_Type) SetT0ALARMHI(value uint32) {
	volatile.StoreUint32(&o.T0ALARMHI.Reg, value)
}
func (o *TIMG_Type) GetT0ALARMHI() uint32 {
	return volatile.LoadUint32(&o.T0ALARMHI.Reg)
}

// TIMG.T0LOADLO: Timer %s reload value, low 32 bits
func (o *TIMG_Type) SetT0LOADLO(value uint32) {
	volatile.StoreUint32(&o.T0LOADLO.Reg, value)
}
func (o *TIMG_Type) GetT0LOADLO() uint32 {
	return volatile.LoadUint32(&o.T0LOADLO.Reg)
}

// TIMG.T0LOADHI: Timer %s reload value, high 32 bits
func (o *TIMG_Type) SetT0LOADHI(value uint32) {
	volatile.StoreUint32(&o.T0LOADHI.Reg, value)
}
func (o *TIMG_Type) GetT0LOADHI() uint32 {
	return volatile.LoadUint32(&o.T0LOADHI.Reg)
}

// TIMG.T0LOAD: Write to reload timer from TIMG_T%sLOADLO_REG or TIMG_T%sLOADHI_REG
func (o *TIMG_Type) SetT0LOAD(value uint32) {
	volatile.StoreUint32(&o.T0LOAD.Reg, value)
}
func (o *TIMG_Type) GetT0LOAD() uint32 {
	return volatile.LoadUint32(&o.T0LOAD.Reg)
}

// TIMG.T1CONFIG: Timer %s configuration register
func (o *TIMG_Type) SetT1CONFIG_USE_XTAL(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG_Type) GetT1CONFIG_USE_XTAL() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG_Type) SetT1CONFIG_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG_Type) GetT1CONFIG_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG_Type) SetT1CONFIG_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x800)|value<<11)
}
func (o *TIMG_Type) GetT1CONFIG_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x800) >> 11
}
func (o *TIMG_Type) SetT1CONFIG_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetT1CONFIG_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetT1CONFIG_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG_Type) GetT1CONFIG_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG_Type) SetT1CONFIG_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG_Type) GetT1CONFIG_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG_Type) SetT1CONFIG_INCREASE(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG_Type) GetT1CONFIG_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG_Type) SetT1CONFIG_EN(value uint32) {
	volatile.StoreUint32(&o.T1CONFIG.Reg, volatile.LoadUint32(&o.T1CONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetT1CONFIG_EN() uint32 {
	return (volatile.LoadUint32(&o.T1CONFIG.Reg) & 0x80000000) >> 31
}

// TIMG.T1LO: Timer %s current value, low 32 bits
func (o *TIMG_Type) SetT1LO(value uint32) {
	volatile.StoreUint32(&o.T1LO.Reg, value)
}
func (o *TIMG_Type) GetT1LO() uint32 {
	return volatile.LoadUint32(&o.T1LO.Reg)
}

// TIMG.T1HI: Timer %s current value, high 32 bits
func (o *TIMG_Type) SetT1HI(value uint32) {
	volatile.StoreUint32(&o.T1HI.Reg, value)
}
func (o *TIMG_Type) GetT1HI() uint32 {
	return volatile.LoadUint32(&o.T1HI.Reg)
}

// TIMG.T1UPDATE: Write to copy current timer value to TIMG_T%sLO_REG or TIMGn_T%sHI_REG
func (o *TIMG_Type) SetT1UPDATE_UPDATE(value uint32) {
	volatile.StoreUint32(&o.T1UPDATE.Reg, volatile.LoadUint32(&o.T1UPDATE.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetT1UPDATE_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.T1UPDATE.Reg) & 0x80000000) >> 31
}

// TIMG.T1ALARMLO: Timer %s alarm value, low 32 bits
func (o *TIMG_Type) SetT1ALARMLO(value uint32) {
	volatile.StoreUint32(&o.T1ALARMLO.Reg, value)
}
func (o *TIMG_Type) GetT1ALARMLO() uint32 {
	return volatile.LoadUint32(&o.T1ALARMLO.Reg)
}

// TIMG.T1ALARMHI: Timer %s alarm value, high bits
func (o *TIMG_Type) SetT1ALARMHI(value uint32) {
	volatile.StoreUint32(&o.T1ALARMHI.Reg, value)
}
func (o *TIMG_Type) GetT1ALARMHI() uint32 {
	return volatile.LoadUint32(&o.T1ALARMHI.Reg)
}

// TIMG.T1LOADLO: Timer %s reload value, low 32 bits
func (o *TIMG_Type) SetT1LOADLO(value uint32) {
	volatile.StoreUint32(&o.T1LOADLO.Reg, value)
}
func (o *TIMG_Type) GetT1LOADLO() uint32 {
	return volatile.LoadUint32(&o.T1LOADLO.Reg)
}

// TIMG.T1LOADHI: Timer %s reload value, high 32 bits
func (o *TIMG_Type) SetT1LOADHI(value uint32) {
	volatile.StoreUint32(&o.T1LOADHI.Reg, value)
}
func (o *TIMG_Type) GetT1LOADHI() uint32 {
	return volatile.LoadUint32(&o.T1LOADHI.Reg)
}

// TIMG.T1LOAD: Write to reload timer from TIMG_T%sLOADLO_REG or TIMG_T%sLOADHI_REG
func (o *TIMG_Type) SetT1LOAD(value uint32) {
	volatile.StoreUint32(&o.T1LOAD.Reg, value)
}
func (o *TIMG_Type) GetT1LOAD() uint32 {
	return volatile.LoadUint32(&o.T1LOAD.Reg)
}

// TIMG.WDTCONFIG0: Watchdog timer configuration register
func (o *TIMG_Type) SetWDTCONFIG0_WDT_APPCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_APPCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_PROCPU_RESET_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x2000)|value<<13)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_PROCPU_RESET_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x2000) >> 13
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_FLASHBOOT_MOD_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x4000) >> 14
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_SYS_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x38000)|value<<15)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_SYS_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x38000) >> 15
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_CPU_RESET_LENGTH(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1c0000)|value<<18)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_CPU_RESET_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1c0000) >> 18
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x200000)|value<<21)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x200000) >> 21
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x400000)|value<<22)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x400000) >> 22
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x1800000)|value<<23)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG3() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x1800000) >> 23
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x6000000)|value<<25)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG2() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x6000000) >> 25
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG1(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x18000000)|value<<27)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG1() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x18000000) >> 27
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_STG0(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x60000000)|value<<29)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_STG0() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x60000000) >> 29
}
func (o *TIMG_Type) SetWDTCONFIG0_WDT_EN(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG0.Reg, volatile.LoadUint32(&o.WDTCONFIG0.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetWDTCONFIG0_WDT_EN() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG0.Reg) & 0x80000000) >> 31
}

// TIMG.WDTCONFIG1: Watchdog timer prescaler register
func (o *TIMG_Type) SetWDTCONFIG1_WDT_CLK_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG1.Reg, volatile.LoadUint32(&o.WDTCONFIG1.Reg)&^(0xffff0000)|value<<16)
}
func (o *TIMG_Type) GetWDTCONFIG1_WDT_CLK_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.WDTCONFIG1.Reg) & 0xffff0000) >> 16
}

// TIMG.WDTCONFIG2: Watchdog timer stage 0 timeout value
func (o *TIMG_Type) SetWDTCONFIG2(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG2.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG2() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG2.Reg)
}

// TIMG.WDTCONFIG3: Watchdog timer stage 1 timeout value
func (o *TIMG_Type) SetWDTCONFIG3(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG3.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG3() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG3.Reg)
}

// TIMG.WDTCONFIG4: Watchdog timer stage 2 timeout value
func (o *TIMG_Type) SetWDTCONFIG4(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG4.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG4() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG4.Reg)
}

// TIMG.WDTCONFIG5: Watchdog timer stage 3 timeout value
func (o *TIMG_Type) SetWDTCONFIG5(value uint32) {
	volatile.StoreUint32(&o.WDTCONFIG5.Reg, value)
}
func (o *TIMG_Type) GetWDTCONFIG5() uint32 {
	return volatile.LoadUint32(&o.WDTCONFIG5.Reg)
}

// TIMG.WDTFEED: Write to feed the watchdog timer
func (o *TIMG_Type) SetWDTFEED(value uint32) {
	volatile.StoreUint32(&o.WDTFEED.Reg, value)
}
func (o *TIMG_Type) GetWDTFEED() uint32 {
	return volatile.LoadUint32(&o.WDTFEED.Reg)
}

// TIMG.WDTWPROTECT: Watchdog write protect register
func (o *TIMG_Type) SetWDTWPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDTWPROTECT.Reg, value)
}
func (o *TIMG_Type) GetWDTWPROTECT() uint32 {
	return volatile.LoadUint32(&o.WDTWPROTECT.Reg)
}

// TIMG.RTCCALICFG: RTC calibration configuration register
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_START_CYCLING(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_START_CYCLING() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x6000)|value<<13)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x6000) >> 13
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_RDY(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x8000)|value<<15)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_RDY() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x8000) >> 15
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_MAX(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x7fff0000)|value<<16)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_MAX() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x7fff0000) >> 16
}
func (o *TIMG_Type) SetRTCCALICFG_RTC_CALI_START(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG.Reg, volatile.LoadUint32(&o.RTCCALICFG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetRTCCALICFG_RTC_CALI_START() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG.Reg) & 0x80000000) >> 31
}

// TIMG.RTCCALICFG1: RTC calibration configuration register 1
func (o *TIMG_Type) SetRTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG1.Reg, volatile.LoadUint32(&o.RTCCALICFG1.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetRTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD() uint32 {
	return volatile.LoadUint32(&o.RTCCALICFG1.Reg) & 0x1
}
func (o *TIMG_Type) SetRTCCALICFG1_RTC_CALI_VALUE(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG1.Reg, volatile.LoadUint32(&o.RTCCALICFG1.Reg)&^(0xffffff80)|value<<7)
}
func (o *TIMG_Type) GetRTCCALICFG1_RTC_CALI_VALUE() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG1.Reg) & 0xffffff80) >> 7
}

// TIMG.LACTCONFIG: LACT configuration register
func (o *TIMG_Type) SetLACTCONFIG_LACT_USE_REFTICK(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x40)|value<<6)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_USE_REFTICK() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x40) >> 6
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_RTC_ONLY(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x80)|value<<7)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_RTC_ONLY() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x80) >> 7
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_CPST_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x100)|value<<8)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_CPST_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x100) >> 8
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_LAC_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x200)|value<<9)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_LAC_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x200) >> 9
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_ALARM_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x400)|value<<10)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_ALARM_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x400) >> 10
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_LEVEL_INT_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x800)|value<<11)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_LEVEL_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x800) >> 11
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_EDGE_INT_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x1000)|value<<12)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_EDGE_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x1000) >> 12
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x1fffe000)|value<<13)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x1fffe000) >> 13
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_AUTORELOAD(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x20000000)|value<<29)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_AUTORELOAD() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x20000000) >> 29
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_INCREASE(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_INCREASE() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x40000000) >> 30
}
func (o *TIMG_Type) SetLACTCONFIG_LACT_EN(value uint32) {
	volatile.StoreUint32(&o.LACTCONFIG.Reg, volatile.LoadUint32(&o.LACTCONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetLACTCONFIG_LACT_EN() uint32 {
	return (volatile.LoadUint32(&o.LACTCONFIG.Reg) & 0x80000000) >> 31
}

// TIMG.LACTRTC: LACT RTC register
func (o *TIMG_Type) SetLACTRTC_LACT_RTC_STEP_LEN(value uint32) {
	volatile.StoreUint32(&o.LACTRTC.Reg, volatile.LoadUint32(&o.LACTRTC.Reg)&^(0xffffffc0)|value<<6)
}
func (o *TIMG_Type) GetLACTRTC_LACT_RTC_STEP_LEN() uint32 {
	return (volatile.LoadUint32(&o.LACTRTC.Reg) & 0xffffffc0) >> 6
}

// TIMG.LACTLO: LACT low register
func (o *TIMG_Type) SetLACTLO(value uint32) {
	volatile.StoreUint32(&o.LACTLO.Reg, value)
}
func (o *TIMG_Type) GetLACTLO() uint32 {
	return volatile.LoadUint32(&o.LACTLO.Reg)
}

// TIMG.LACTHI: LACT high register
func (o *TIMG_Type) SetLACTHI(value uint32) {
	volatile.StoreUint32(&o.LACTHI.Reg, value)
}
func (o *TIMG_Type) GetLACTHI() uint32 {
	return volatile.LoadUint32(&o.LACTHI.Reg)
}

// TIMG.LACTUPDATE: LACT update register
func (o *TIMG_Type) SetLACTUPDATE(value uint32) {
	volatile.StoreUint32(&o.LACTUPDATE.Reg, value)
}
func (o *TIMG_Type) GetLACTUPDATE() uint32 {
	return volatile.LoadUint32(&o.LACTUPDATE.Reg)
}

// TIMG.LACTALARMLO: LACT alarm low register
func (o *TIMG_Type) SetLACTALARMLO(value uint32) {
	volatile.StoreUint32(&o.LACTALARMLO.Reg, value)
}
func (o *TIMG_Type) GetLACTALARMLO() uint32 {
	return volatile.LoadUint32(&o.LACTALARMLO.Reg)
}

// TIMG.LACTALARMHI: LACT alarm high register
func (o *TIMG_Type) SetLACTALARMHI(value uint32) {
	volatile.StoreUint32(&o.LACTALARMHI.Reg, value)
}
func (o *TIMG_Type) GetLACTALARMHI() uint32 {
	return volatile.LoadUint32(&o.LACTALARMHI.Reg)
}

// TIMG.LACTLOADLO: LACT load low register
func (o *TIMG_Type) SetLACTLOADLO(value uint32) {
	volatile.StoreUint32(&o.LACTLOADLO.Reg, value)
}
func (o *TIMG_Type) GetLACTLOADLO() uint32 {
	return volatile.LoadUint32(&o.LACTLOADLO.Reg)
}

// TIMG.LACTLOADHI: Timer LACT load high register
func (o *TIMG_Type) SetLACTLOADHI(value uint32) {
	volatile.StoreUint32(&o.LACTLOADHI.Reg, value)
}
func (o *TIMG_Type) GetLACTLOADHI() uint32 {
	return volatile.LoadUint32(&o.LACTLOADHI.Reg)
}

// TIMG.LACTLOAD: Timer LACT load register
func (o *TIMG_Type) SetLACTLOAD(value uint32) {
	volatile.StoreUint32(&o.LACTLOAD.Reg, value)
}
func (o *TIMG_Type) GetLACTLOAD() uint32 {
	return volatile.LoadUint32(&o.LACTLOAD.Reg)
}

// TIMG.INT_ENA_TIMERS: Interrupt enable bits
func (o *TIMG_Type) SetINT_ENA_TIMERS_T0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_ENA_TIMERS_T0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_ENA_TIMERS_T1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_ENA_TIMERS_T1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG_Type) SetINT_ENA_TIMERS_WDT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG_Type) GetINT_ENA_TIMERS_WDT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG_Type) SetINT_ENA_TIMERS_LACT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA_TIMERS.Reg, volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG_Type) GetINT_ENA_TIMERS_LACT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA_TIMERS.Reg) & 0x8) >> 3
}

// TIMG.INT_RAW_TIMERS: Raw interrupt status
func (o *TIMG_Type) SetINT_RAW_TIMERS_T0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_RAW_TIMERS_T0_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_RAW_TIMERS_T1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_RAW_TIMERS_T1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG_Type) SetINT_RAW_TIMERS_WDT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG_Type) GetINT_RAW_TIMERS_WDT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG_Type) SetINT_RAW_TIMERS_LACT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW_TIMERS.Reg, volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG_Type) GetINT_RAW_TIMERS_LACT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW_TIMERS.Reg) & 0x8) >> 3
}

// TIMG.INT_ST_TIMERS: Masked interrupt status
func (o *TIMG_Type) SetINT_ST_TIMERS_T0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_ST_TIMERS_T0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_ST_TIMERS_T1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_ST_TIMERS_T1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG_Type) SetINT_ST_TIMERS_WDT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG_Type) GetINT_ST_TIMERS_WDT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG_Type) SetINT_ST_TIMERS_LACT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST_TIMERS.Reg, volatile.LoadUint32(&o.INT_ST_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG_Type) GetINT_ST_TIMERS_LACT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST_TIMERS.Reg) & 0x8) >> 3
}

// TIMG.INT_CLR_TIMERS: Interrupt clear bits
func (o *TIMG_Type) SetINT_CLR_TIMERS_T0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetINT_CLR_TIMERS_T0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x1
}
func (o *TIMG_Type) SetINT_CLR_TIMERS_T1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x2)|value<<1)
}
func (o *TIMG_Type) GetINT_CLR_TIMERS_T1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x2) >> 1
}
func (o *TIMG_Type) SetINT_CLR_TIMERS_WDT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x4)|value<<2)
}
func (o *TIMG_Type) GetINT_CLR_TIMERS_WDT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x4) >> 2
}
func (o *TIMG_Type) SetINT_CLR_TIMERS_LACT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR_TIMERS.Reg, volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg)&^(0x8)|value<<3)
}
func (o *TIMG_Type) GetINT_CLR_TIMERS_LACT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR_TIMERS.Reg) & 0x8) >> 3
}

// TIMG.RTCCALICFG2: Timer group calibration register
func (o *TIMG_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0x1)|value)
}
func (o *TIMG_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0x1
}
func (o *TIMG_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0x78)|value<<3)
}
func (o *TIMG_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0x78) >> 3
}
func (o *TIMG_Type) SetRTCCALICFG2_RTC_CALI_TIMEOUT_THRES(value uint32) {
	volatile.StoreUint32(&o.RTCCALICFG2.Reg, volatile.LoadUint32(&o.RTCCALICFG2.Reg)&^(0xffffff80)|value<<7)
}
func (o *TIMG_Type) GetRTCCALICFG2_RTC_CALI_TIMEOUT_THRES() uint32 {
	return (volatile.LoadUint32(&o.RTCCALICFG2.Reg) & 0xffffff80) >> 7
}

// TIMG.TIMERS_DATE: Version control register
func (o *TIMG_Type) SetTIMERS_DATE(value uint32) {
	volatile.StoreUint32(&o.TIMERS_DATE.Reg, volatile.LoadUint32(&o.TIMERS_DATE.Reg)&^(0xfffffff)|value)
}
func (o *TIMG_Type) GetTIMERS_DATE() uint32 {
	return volatile.LoadUint32(&o.TIMERS_DATE.Reg) & 0xfffffff
}

// TIMG.REGCLK: Timer group clock gate register
func (o *TIMG_Type) SetREGCLK_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.REGCLK.Reg, volatile.LoadUint32(&o.REGCLK.Reg)&^(0x80000000)|value<<31)
}
func (o *TIMG_Type) GetREGCLK_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.REGCLK.Reg) & 0x80000000) >> 31
}

// Two-Wire Automotive Interface
type TWAI_Type struct {
	MODE              volatile.Register32 // 0x0
	CMD               volatile.Register32 // 0x4
	STATUS            volatile.Register32 // 0x8
	INT_RAW           volatile.Register32 // 0xC
	INT_ENA           volatile.Register32 // 0x10
	_                 [4]byte
	BUS_TIMING_0      volatile.Register32 // 0x18
	BUS_TIMING_1      volatile.Register32 // 0x1C
	_                 [12]byte
	ARB_LOST_CAP      volatile.Register32 // 0x2C
	ERR_CODE_CAP      volatile.Register32 // 0x30
	ERR_WARNING_LIMIT volatile.Register32 // 0x34
	RX_ERR_CNT        volatile.Register32 // 0x38
	TX_ERR_CNT        volatile.Register32 // 0x3C
	DATA_0            volatile.Register32 // 0x40
	DATA_1            volatile.Register32 // 0x44
	DATA_2            volatile.Register32 // 0x48
	DATA_3            volatile.Register32 // 0x4C
	DATA_4            volatile.Register32 // 0x50
	DATA_5            volatile.Register32 // 0x54
	DATA_6            volatile.Register32 // 0x58
	DATA_7            volatile.Register32 // 0x5C
	DATA_8            volatile.Register32 // 0x60
	DATA_9            volatile.Register32 // 0x64
	DATA_10           volatile.Register32 // 0x68
	DATA_11           volatile.Register32 // 0x6C
	DATA_12           volatile.Register32 // 0x70
	RX_MESSAGE_CNT    volatile.Register32 // 0x74
	_                 [4]byte
	CLOCK_DIVIDER     volatile.Register32 // 0x7C
}

// TWAI.MODE: Mode Register
func (o *TWAI_Type) SetMODE_RESET_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetMODE_RESET_MODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *TWAI_Type) SetMODE_LISTEN_ONLY_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetMODE_LISTEN_ONLY_MODE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetMODE_SELF_TEST_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetMODE_SELF_TEST_MODE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetMODE_RX_FILTER_MODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetMODE_RX_FILTER_MODE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x8) >> 3
}

// TWAI.CMD: Command Register
func (o *TWAI_Type) SetCMD_TX_REQ(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetCMD_TX_REQ() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x1
}
func (o *TWAI_Type) SetCMD_ABORT_TX(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetCMD_ABORT_TX() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetCMD_RELEASE_BUF(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetCMD_RELEASE_BUF() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetCMD_CLR_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetCMD_CLR_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetCMD_SELF_RX_REQ(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x10)|value<<4)
}
func (o *TWAI_Type) GetCMD_SELF_RX_REQ() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x10) >> 4
}

// TWAI.STATUS: Status register
func (o *TWAI_Type) SetSTATUS_RX_BUF_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetSTATUS_RX_BUF_ST() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *TWAI_Type) SetSTATUS_OVERRUN_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetSTATUS_OVERRUN_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetSTATUS_TX_BUF_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetSTATUS_TX_BUF_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetSTATUS_TX_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetSTATUS_TX_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetSTATUS_RX_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TWAI_Type) GetSTATUS_RX_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TWAI_Type) SetSTATUS_TX_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetSTATUS_TX_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetSTATUS_ERR_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *TWAI_Type) GetSTATUS_ERR_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *TWAI_Type) SetSTATUS_BUS_OFF_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetSTATUS_BUS_OFF_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *TWAI_Type) SetSTATUS_MISS_ST(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *TWAI_Type) GetSTATUS_MISS_ST() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}

// TWAI.INT_RAW: Interrupt Register
func (o *TWAI_Type) SetINT_RAW_RX_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetINT_RAW_RX_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *TWAI_Type) SetINT_RAW_TX_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetINT_RAW_TX_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetINT_RAW_ERR_WARN_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetINT_RAW_ERR_WARN_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetINT_RAW_OVERRUN_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetINT_RAW_OVERRUN_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetINT_RAW_ERR_PASSIVE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetINT_RAW_ERR_PASSIVE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetINT_RAW_ARB_LOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *TWAI_Type) GetINT_RAW_ARB_LOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *TWAI_Type) SetINT_RAW_BUS_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetINT_RAW_BUS_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}

// TWAI.INT_ENA: Interrupt Enable Register
func (o *TWAI_Type) SetINT_ENA_RX_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *TWAI_Type) GetINT_ENA_RX_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *TWAI_Type) SetINT_ENA_TX_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *TWAI_Type) GetINT_ENA_TX_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *TWAI_Type) SetINT_ENA_ERR_WARN_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *TWAI_Type) GetINT_ENA_ERR_WARN_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *TWAI_Type) SetINT_ENA_OVERRUN_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *TWAI_Type) GetINT_ENA_OVERRUN_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *TWAI_Type) SetINT_ENA_ERR_PASSIVE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetINT_ENA_ERR_PASSIVE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetINT_ENA_ARB_LOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *TWAI_Type) GetINT_ENA_ARB_LOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *TWAI_Type) SetINT_ENA_BUS_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetINT_ENA_BUS_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}

// TWAI.BUS_TIMING_0: Bus Timing Register 0
func (o *TWAI_Type) SetBUS_TIMING_0_BAUD_PRESC(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_0.Reg, volatile.LoadUint32(&o.BUS_TIMING_0.Reg)&^(0x3fff)|value)
}
func (o *TWAI_Type) GetBUS_TIMING_0_BAUD_PRESC() uint32 {
	return volatile.LoadUint32(&o.BUS_TIMING_0.Reg) & 0x3fff
}
func (o *TWAI_Type) SetBUS_TIMING_0_SYNC_JUMP_WIDTH(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_0.Reg, volatile.LoadUint32(&o.BUS_TIMING_0.Reg)&^(0xc000)|value<<14)
}
func (o *TWAI_Type) GetBUS_TIMING_0_SYNC_JUMP_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMING_0.Reg) & 0xc000) >> 14
}

// TWAI.BUS_TIMING_1: Bus Timing Register 1
func (o *TWAI_Type) SetBUS_TIMING_1_TIME_SEG1(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_1.Reg, volatile.LoadUint32(&o.BUS_TIMING_1.Reg)&^(0xf)|value)
}
func (o *TWAI_Type) GetBUS_TIMING_1_TIME_SEG1() uint32 {
	return volatile.LoadUint32(&o.BUS_TIMING_1.Reg) & 0xf
}
func (o *TWAI_Type) SetBUS_TIMING_1_TIME_SEG2(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_1.Reg, volatile.LoadUint32(&o.BUS_TIMING_1.Reg)&^(0x70)|value<<4)
}
func (o *TWAI_Type) GetBUS_TIMING_1_TIME_SEG2() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMING_1.Reg) & 0x70) >> 4
}
func (o *TWAI_Type) SetBUS_TIMING_1_TIME_SAMP(value uint32) {
	volatile.StoreUint32(&o.BUS_TIMING_1.Reg, volatile.LoadUint32(&o.BUS_TIMING_1.Reg)&^(0x80)|value<<7)
}
func (o *TWAI_Type) GetBUS_TIMING_1_TIME_SAMP() uint32 {
	return (volatile.LoadUint32(&o.BUS_TIMING_1.Reg) & 0x80) >> 7
}

// TWAI.ARB_LOST_CAP: Arbitration Lost Capture Register
func (o *TWAI_Type) SetARB_LOST_CAP(value uint32) {
	volatile.StoreUint32(&o.ARB_LOST_CAP.Reg, volatile.LoadUint32(&o.ARB_LOST_CAP.Reg)&^(0x1f)|value)
}
func (o *TWAI_Type) GetARB_LOST_CAP() uint32 {
	return volatile.LoadUint32(&o.ARB_LOST_CAP.Reg) & 0x1f
}

// TWAI.ERR_CODE_CAP: Error Code Capture Register
func (o *TWAI_Type) SetERR_CODE_CAP_ECC_SEGMENT(value uint32) {
	volatile.StoreUint32(&o.ERR_CODE_CAP.Reg, volatile.LoadUint32(&o.ERR_CODE_CAP.Reg)&^(0x1f)|value)
}
func (o *TWAI_Type) GetERR_CODE_CAP_ECC_SEGMENT() uint32 {
	return volatile.LoadUint32(&o.ERR_CODE_CAP.Reg) & 0x1f
}
func (o *TWAI_Type) SetERR_CODE_CAP_ECC_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.ERR_CODE_CAP.Reg, volatile.LoadUint32(&o.ERR_CODE_CAP.Reg)&^(0x20)|value<<5)
}
func (o *TWAI_Type) GetERR_CODE_CAP_ECC_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.ERR_CODE_CAP.Reg) & 0x20) >> 5
}
func (o *TWAI_Type) SetERR_CODE_CAP_ECC_TYPE(value uint32) {
	volatile.StoreUint32(&o.ERR_CODE_CAP.Reg, volatile.LoadUint32(&o.ERR_CODE_CAP.Reg)&^(0xc0)|value<<6)
}
func (o *TWAI_Type) GetERR_CODE_CAP_ECC_TYPE() uint32 {
	return (volatile.LoadUint32(&o.ERR_CODE_CAP.Reg) & 0xc0) >> 6
}

// TWAI.ERR_WARNING_LIMIT: Error Warning Limit Register
func (o *TWAI_Type) SetERR_WARNING_LIMIT(value uint32) {
	volatile.StoreUint32(&o.ERR_WARNING_LIMIT.Reg, volatile.LoadUint32(&o.ERR_WARNING_LIMIT.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetERR_WARNING_LIMIT() uint32 {
	return volatile.LoadUint32(&o.ERR_WARNING_LIMIT.Reg) & 0xff
}

// TWAI.RX_ERR_CNT: Receive Error Counter Register
func (o *TWAI_Type) SetRX_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.RX_ERR_CNT.Reg, volatile.LoadUint32(&o.RX_ERR_CNT.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetRX_ERR_CNT() uint32 {
	return volatile.LoadUint32(&o.RX_ERR_CNT.Reg) & 0xff
}

// TWAI.TX_ERR_CNT: Transmit Error Counter Register
func (o *TWAI_Type) SetTX_ERR_CNT(value uint32) {
	volatile.StoreUint32(&o.TX_ERR_CNT.Reg, volatile.LoadUint32(&o.TX_ERR_CNT.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetTX_ERR_CNT() uint32 {
	return volatile.LoadUint32(&o.TX_ERR_CNT.Reg) & 0xff
}

// TWAI.DATA_0: Data register 0
func (o *TWAI_Type) SetDATA_0_TX_BYTE_0(value uint32) {
	volatile.StoreUint32(&o.DATA_0.Reg, volatile.LoadUint32(&o.DATA_0.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_0_TX_BYTE_0() uint32 {
	return volatile.LoadUint32(&o.DATA_0.Reg) & 0xff
}

// TWAI.DATA_1: Data register 1
func (o *TWAI_Type) SetDATA_1_TX_BYTE_1(value uint32) {
	volatile.StoreUint32(&o.DATA_1.Reg, volatile.LoadUint32(&o.DATA_1.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_1_TX_BYTE_1() uint32 {
	return volatile.LoadUint32(&o.DATA_1.Reg) & 0xff
}

// TWAI.DATA_2: Data register 2
func (o *TWAI_Type) SetDATA_2_TX_BYTE_2(value uint32) {
	volatile.StoreUint32(&o.DATA_2.Reg, volatile.LoadUint32(&o.DATA_2.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_2_TX_BYTE_2() uint32 {
	return volatile.LoadUint32(&o.DATA_2.Reg) & 0xff
}

// TWAI.DATA_3: Data register 3
func (o *TWAI_Type) SetDATA_3_TX_BYTE_3(value uint32) {
	volatile.StoreUint32(&o.DATA_3.Reg, volatile.LoadUint32(&o.DATA_3.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_3_TX_BYTE_3() uint32 {
	return volatile.LoadUint32(&o.DATA_3.Reg) & 0xff
}

// TWAI.DATA_4: Data register 4
func (o *TWAI_Type) SetDATA_4_TX_BYTE_4(value uint32) {
	volatile.StoreUint32(&o.DATA_4.Reg, volatile.LoadUint32(&o.DATA_4.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_4_TX_BYTE_4() uint32 {
	return volatile.LoadUint32(&o.DATA_4.Reg) & 0xff
}

// TWAI.DATA_5: Data register 5
func (o *TWAI_Type) SetDATA_5_TX_BYTE_5(value uint32) {
	volatile.StoreUint32(&o.DATA_5.Reg, volatile.LoadUint32(&o.DATA_5.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_5_TX_BYTE_5() uint32 {
	return volatile.LoadUint32(&o.DATA_5.Reg) & 0xff
}

// TWAI.DATA_6: Data register 6
func (o *TWAI_Type) SetDATA_6_TX_BYTE_6(value uint32) {
	volatile.StoreUint32(&o.DATA_6.Reg, volatile.LoadUint32(&o.DATA_6.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_6_TX_BYTE_6() uint32 {
	return volatile.LoadUint32(&o.DATA_6.Reg) & 0xff
}

// TWAI.DATA_7: Data register 7
func (o *TWAI_Type) SetDATA_7_TX_BYTE_7(value uint32) {
	volatile.StoreUint32(&o.DATA_7.Reg, volatile.LoadUint32(&o.DATA_7.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_7_TX_BYTE_7() uint32 {
	return volatile.LoadUint32(&o.DATA_7.Reg) & 0xff
}

// TWAI.DATA_8: Data register 8
func (o *TWAI_Type) SetDATA_8_TX_BYTE_8(value uint32) {
	volatile.StoreUint32(&o.DATA_8.Reg, volatile.LoadUint32(&o.DATA_8.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_8_TX_BYTE_8() uint32 {
	return volatile.LoadUint32(&o.DATA_8.Reg) & 0xff
}

// TWAI.DATA_9: Data register 9
func (o *TWAI_Type) SetDATA_9_TX_BYTE_9(value uint32) {
	volatile.StoreUint32(&o.DATA_9.Reg, volatile.LoadUint32(&o.DATA_9.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_9_TX_BYTE_9() uint32 {
	return volatile.LoadUint32(&o.DATA_9.Reg) & 0xff
}

// TWAI.DATA_10: Data register 10
func (o *TWAI_Type) SetDATA_10_TX_BYTE_10(value uint32) {
	volatile.StoreUint32(&o.DATA_10.Reg, volatile.LoadUint32(&o.DATA_10.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_10_TX_BYTE_10() uint32 {
	return volatile.LoadUint32(&o.DATA_10.Reg) & 0xff
}

// TWAI.DATA_11: Data register 11
func (o *TWAI_Type) SetDATA_11_TX_BYTE_11(value uint32) {
	volatile.StoreUint32(&o.DATA_11.Reg, volatile.LoadUint32(&o.DATA_11.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_11_TX_BYTE_11() uint32 {
	return volatile.LoadUint32(&o.DATA_11.Reg) & 0xff
}

// TWAI.DATA_12: Data register 12
func (o *TWAI_Type) SetDATA_12_TX_BYTE_12(value uint32) {
	volatile.StoreUint32(&o.DATA_12.Reg, volatile.LoadUint32(&o.DATA_12.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetDATA_12_TX_BYTE_12() uint32 {
	return volatile.LoadUint32(&o.DATA_12.Reg) & 0xff
}

// TWAI.RX_MESSAGE_CNT: Receive Message Counter Register
func (o *TWAI_Type) SetRX_MESSAGE_CNT_RX_MESSAGE_COUNTER(value uint32) {
	volatile.StoreUint32(&o.RX_MESSAGE_CNT.Reg, volatile.LoadUint32(&o.RX_MESSAGE_CNT.Reg)&^(0x7f)|value)
}
func (o *TWAI_Type) GetRX_MESSAGE_CNT_RX_MESSAGE_COUNTER() uint32 {
	return volatile.LoadUint32(&o.RX_MESSAGE_CNT.Reg) & 0x7f
}

// TWAI.CLOCK_DIVIDER: Clock Divider register
func (o *TWAI_Type) SetCLOCK_DIVIDER_CD(value uint32) {
	volatile.StoreUint32(&o.CLOCK_DIVIDER.Reg, volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg)&^(0xff)|value)
}
func (o *TWAI_Type) GetCLOCK_DIVIDER_CD() uint32 {
	return volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg) & 0xff
}
func (o *TWAI_Type) SetCLOCK_DIVIDER_CLOCK_OFF(value uint32) {
	volatile.StoreUint32(&o.CLOCK_DIVIDER.Reg, volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg)&^(0x100)|value<<8)
}
func (o *TWAI_Type) GetCLOCK_DIVIDER_CLOCK_OFF() uint32 {
	return (volatile.LoadUint32(&o.CLOCK_DIVIDER.Reg) & 0x100) >> 8
}

// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
type UART_Type struct {
	FIFO           volatile.Register32 // 0x0
	INT_RAW        volatile.Register32 // 0x4
	INT_ST         volatile.Register32 // 0x8
	INT_ENA        volatile.Register32 // 0xC
	INT_CLR        volatile.Register32 // 0x10
	CLKDIV         volatile.Register32 // 0x14
	AUTOBAUD       volatile.Register32 // 0x18
	STATUS         volatile.Register32 // 0x1C
	CONF0          volatile.Register32 // 0x20
	CONF1          volatile.Register32 // 0x24
	LOWPULSE       volatile.Register32 // 0x28
	HIGHPULSE      volatile.Register32 // 0x2C
	RXD_CNT        volatile.Register32 // 0x30
	FLOW_CONF      volatile.Register32 // 0x34
	SLEEP_CONF     volatile.Register32 // 0x38
	SWFC_CONF0     volatile.Register32 // 0x3C
	SWFC_CONF1     volatile.Register32 // 0x40
	IDLE_CONF      volatile.Register32 // 0x44
	RS485_CONF     volatile.Register32 // 0x48
	AT_CMD_PRECNT  volatile.Register32 // 0x4C
	AT_CMD_POSTCNT volatile.Register32 // 0x50
	AT_CMD_GAPTOUT volatile.Register32 // 0x54
	AT_CMD_CHAR    volatile.Register32 // 0x58
	MEM_CONF       volatile.Register32 // 0x5C
	MEM_TX_STATUS  volatile.Register32 // 0x60
	MEM_RX_STATUS  volatile.Register32 // 0x64
	FSM_STATUS     volatile.Register32 // 0x68
	POSPULSE       volatile.Register32 // 0x6C
	NEGPULSE       volatile.Register32 // 0x70
	DATE           volatile.Register32 // 0x74
	ID             volatile.Register32 // 0x78
}

// UART.FIFO: FIFO data register
func (o *UART_Type) SetFIFO_RXFIFO_RD_BYTE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetFIFO_RXFIFO_RD_BYTE() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg) & 0xff
}

// UART.INT_RAW: Raw interrupt status
func (o *UART_Type) SetINT_RAW_RXFIFO_FULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_RAW_RXFIFO_FULL_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *UART_Type) SetINT_RAW_TXFIFO_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_RAW_TXFIFO_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_RAW_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_RAW_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_RAW_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_RAW_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_RAW_DSR_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_RAW_DSR_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_RAW_CTS_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_RAW_CTS_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_RAW_BRK_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_RAW_BRK_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_RAW_RXFIFO_TOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_RAW_RXFIFO_TOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_RAW_SW_XON_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_RAW_SW_XON_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_RAW_SW_XOFF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_RAW_SW_XOFF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_RAW_GLITCH_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_RAW_GLITCH_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_RAW_TX_BRK_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_RAW_TX_BRK_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_RAW_TX_BRK_IDLE_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_RAW_TX_BRK_IDLE_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_RAW_TX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_RAW_TX_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_RAW_RS485_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_RAW_RS485_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_RAW_RS485_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_RAW_RS485_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_RAW_RS485_CLASH_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_RAW_RS485_CLASH_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_RAW_AT_CMD_CHAR_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_RAW_AT_CMD_CHAR_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_RAW_WAKEUP_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_RAW_WAKEUP_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80000) >> 19
}

// UART.INT_ST: Masked interrupt status
func (o *UART_Type) SetINT_ST_RXFIFO_FULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_ST_RXFIFO_FULL_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *UART_Type) SetINT_ST_TXFIFO_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_ST_TXFIFO_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_ST_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_ST_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_ST_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_ST_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_ST_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_ST_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_ST_DSR_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_ST_DSR_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_ST_CTS_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_ST_CTS_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_ST_BRK_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_ST_BRK_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_ST_RXFIFO_TOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_ST_RXFIFO_TOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_ST_SW_XON_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_ST_SW_XON_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_ST_SW_XOFF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_ST_SW_XOFF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_ST_GLITCH_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_ST_GLITCH_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_ST_TX_BRK_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_ST_TX_BRK_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_ST_TX_BRK_IDLE_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_ST_TX_BRK_IDLE_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_ST_TX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_ST_TX_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_ST_RS485_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_ST_RS485_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_ST_RS485_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_ST_RS485_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_ST_RS485_CLASH_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_ST_RS485_CLASH_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_ST_AT_CMD_CHAR_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_ST_AT_CMD_CHAR_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_ST_WAKEUP_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_ST_WAKEUP_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80000) >> 19
}

// UART.INT_ENA: Interrupt enable bits
func (o *UART_Type) SetINT_ENA_RXFIFO_FULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_ENA_RXFIFO_FULL_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *UART_Type) SetINT_ENA_TXFIFO_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_ENA_TXFIFO_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_ENA_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_ENA_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_ENA_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_ENA_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_ENA_DSR_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_ENA_DSR_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_ENA_CTS_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_ENA_CTS_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_ENA_BRK_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_ENA_BRK_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_ENA_RXFIFO_TOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_ENA_RXFIFO_TOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_ENA_SW_XON_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_ENA_SW_XON_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_ENA_SW_XOFF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_ENA_SW_XOFF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_ENA_GLITCH_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_ENA_GLITCH_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_ENA_TX_BRK_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_ENA_TX_BRK_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_ENA_TX_BRK_IDLE_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_ENA_TX_BRK_IDLE_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_ENA_TX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_ENA_TX_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_ENA_RS485_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_ENA_RS485_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_ENA_RS485_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_ENA_RS485_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_ENA_RS485_CLASH_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_ENA_RS485_CLASH_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_ENA_AT_CMD_CHAR_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_ENA_AT_CMD_CHAR_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_ENA_WAKEUP_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_ENA_WAKEUP_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80000) >> 19
}

// UART.INT_CLR: Interrupt clear bits
func (o *UART_Type) SetINT_CLR_RXFIFO_FULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINT_CLR_RXFIFO_FULL_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *UART_Type) SetINT_CLR_TXFIFO_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINT_CLR_TXFIFO_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINT_CLR_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINT_CLR_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINT_CLR_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetINT_CLR_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetINT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetINT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetINT_CLR_DSR_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetINT_CLR_DSR_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetINT_CLR_CTS_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetINT_CLR_CTS_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetINT_CLR_BRK_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINT_CLR_BRK_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINT_CLR_RXFIFO_TOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetINT_CLR_RXFIFO_TOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetINT_CLR_SW_XON_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINT_CLR_SW_XON_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINT_CLR_SW_XOFF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetINT_CLR_SW_XOFF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetINT_CLR_GLITCH_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetINT_CLR_GLITCH_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetINT_CLR_TX_BRK_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetINT_CLR_TX_BRK_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetINT_CLR_TX_BRK_IDLE_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetINT_CLR_TX_BRK_IDLE_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetINT_CLR_TX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetINT_CLR_TX_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetINT_CLR_RS485_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetINT_CLR_RS485_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetINT_CLR_RS485_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetINT_CLR_RS485_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetINT_CLR_RS485_CLASH_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINT_CLR_RS485_CLASH_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetINT_CLR_AT_CMD_CHAR_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetINT_CLR_AT_CMD_CHAR_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetINT_CLR_WAKEUP_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetINT_CLR_WAKEUP_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80000) >> 19
}

// UART.CLKDIV: Clock divider configuration
func (o *UART_Type) SetCLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xfffff)|value)
}
func (o *UART_Type) GetCLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKDIV.Reg) & 0xfffff
}
func (o *UART_Type) SetCLKDIV_FRAG(value uint32) {
	volatile.StoreUint32(&o.CLKDIV.Reg, volatile.LoadUint32(&o.CLKDIV.Reg)&^(0xf00000)|value<<20)
}
func (o *UART_Type) GetCLKDIV_FRAG() uint32 {
	return (volatile.LoadUint32(&o.CLKDIV.Reg) & 0xf00000) >> 20
}

// UART.AUTOBAUD: Autobaud configuration register
func (o *UART_Type) SetAUTOBAUD_EN(value uint32) {
	volatile.StoreUint32(&o.AUTOBAUD.Reg, volatile.LoadUint32(&o.AUTOBAUD.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetAUTOBAUD_EN() uint32 {
	return volatile.LoadUint32(&o.AUTOBAUD.Reg) & 0x1
}
func (o *UART_Type) SetAUTOBAUD_GLITCH_FILT(value uint32) {
	volatile.StoreUint32(&o.AUTOBAUD.Reg, volatile.LoadUint32(&o.AUTOBAUD.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetAUTOBAUD_GLITCH_FILT() uint32 {
	return (volatile.LoadUint32(&o.AUTOBAUD.Reg) & 0xff00) >> 8
}

// UART.STATUS: UART status register
func (o *UART_Type) SetSTATUS_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetSTATUS_RXFIFO_CNT() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x3ff
}
func (o *UART_Type) SetSTATUS_DSRN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetSTATUS_DSRN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetSTATUS_CTSN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetSTATUS_CTSN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetSTATUS_RXD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetSTATUS_RXD() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetSTATUS_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3ff0000)|value<<16)
}
func (o *UART_Type) GetSTATUS_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x3ff0000) >> 16
}
func (o *UART_Type) SetSTATUS_DTRN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *UART_Type) GetSTATUS_DTRN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000000) >> 29
}
func (o *UART_Type) SetSTATUS_RTSN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *UART_Type) GetSTATUS_RTSN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000000) >> 30
}
func (o *UART_Type) SetSTATUS_TXD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_Type) GetSTATUS_TXD() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}

// UART.CONF0: Configuration register 0
func (o *UART_Type) SetCONF0_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetCONF0_PARITY() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *UART_Type) SetCONF0_PARITY_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetCONF0_PARITY_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetCONF0_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0xc)|value<<2)
}
func (o *UART_Type) GetCONF0_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0xc) >> 2
}
func (o *UART_Type) SetCONF0_STOP_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x30)|value<<4)
}
func (o *UART_Type) GetCONF0_STOP_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x30) >> 4
}
func (o *UART_Type) SetCONF0_SW_RTS(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCONF0_SW_RTS() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCONF0_SW_DTR(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCONF0_SW_DTR() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetCONF0_TXD_BRK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetCONF0_TXD_BRK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetCONF0_IRDA_DPLX(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetCONF0_IRDA_DPLX() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetCONF0_IRDA_TX_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *UART_Type) GetCONF0_IRDA_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *UART_Type) SetCONF0_IRDA_WCTL(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800)|value<<11)
}
func (o *UART_Type) GetCONF0_IRDA_WCTL() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800) >> 11
}
func (o *UART_Type) SetCONF0_IRDA_TX_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *UART_Type) GetCONF0_IRDA_TX_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}
func (o *UART_Type) SetCONF0_IRDA_RX_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *UART_Type) GetCONF0_IRDA_RX_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000) >> 13
}
func (o *UART_Type) SetCONF0_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *UART_Type) GetCONF0_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000) >> 14
}
func (o *UART_Type) SetCONF0_TX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UART_Type) GetCONF0_TX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000) >> 15
}
func (o *UART_Type) SetCONF0_IRDA_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *UART_Type) GetCONF0_IRDA_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000) >> 16
}
func (o *UART_Type) SetCONF0_RXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetCONF0_RXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20000) >> 17
}
func (o *UART_Type) SetCONF0_TXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UART_Type) GetCONF0_TXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40000) >> 18
}
func (o *UART_Type) SetCONF0_RXD_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UART_Type) GetCONF0_RXD_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80000) >> 19
}
func (o *UART_Type) SetCONF0_CTS_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UART_Type) GetCONF0_CTS_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100000) >> 20
}
func (o *UART_Type) SetCONF0_DSR_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UART_Type) GetCONF0_DSR_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200000) >> 21
}
func (o *UART_Type) SetCONF0_TXD_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UART_Type) GetCONF0_TXD_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400000) >> 22
}
func (o *UART_Type) SetCONF0_RTS_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UART_Type) GetCONF0_RTS_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800000) >> 23
}
func (o *UART_Type) SetCONF0_DTR_INV(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000000)|value<<24)
}
func (o *UART_Type) GetCONF0_DTR_INV() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000000) >> 24
}
func (o *UART_Type) SetCONF0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000000)|value<<25)
}
func (o *UART_Type) GetCONF0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000000) >> 25
}
func (o *UART_Type) SetCONF0_ERR_WR_MASK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4000000)|value<<26)
}
func (o *UART_Type) GetCONF0_ERR_WR_MASK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4000000) >> 26
}
func (o *UART_Type) SetCONF0_TICK_REF_ALWAYS_ON(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000000)|value<<27)
}
func (o *UART_Type) GetCONF0_TICK_REF_ALWAYS_ON() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000000) >> 27
}
func (o *UART_Type) SetCONF0_MEM_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000000)|value<<28)
}
func (o *UART_Type) GetCONF0_MEM_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000000) >> 28
}

// UART.CONF1: Configuration register 1
func (o *UART_Type) SetCONF1_RXFIFO_FULL_THRHD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1ff)|value)
}
func (o *UART_Type) GetCONF1_RXFIFO_FULL_THRHD() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x1ff
}
func (o *UART_Type) SetCONF1_TXFIFO_EMPTY_THRHD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x3fe00)|value<<9)
}
func (o *UART_Type) GetCONF1_TXFIFO_EMPTY_THRHD() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x3fe00) >> 9
}
func (o *UART_Type) SetCONF1_RX_TOUT_FLOW_DIS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x20000000)|value<<29)
}
func (o *UART_Type) GetCONF1_RX_TOUT_FLOW_DIS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x20000000) >> 29
}
func (o *UART_Type) SetCONF1_RX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x40000000)|value<<30)
}
func (o *UART_Type) GetCONF1_RX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x40000000) >> 30
}
func (o *UART_Type) SetCONF1_RX_TOUT_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_Type) GetCONF1_RX_TOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80000000) >> 31
}

// UART.LOWPULSE: Autobaud minimum low pulse duration register
func (o *UART_Type) SetLOWPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.LOWPULSE.Reg, volatile.LoadUint32(&o.LOWPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART_Type) GetLOWPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.LOWPULSE.Reg) & 0xfffff
}

// UART.HIGHPULSE: Autobaud minimum high pulse duration register
func (o *UART_Type) SetHIGHPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.HIGHPULSE.Reg, volatile.LoadUint32(&o.HIGHPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART_Type) GetHIGHPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.HIGHPULSE.Reg) & 0xfffff
}

// UART.RXD_CNT: Autobaud edge change count register
func (o *UART_Type) SetRXD_CNT_RXD_EDGE_CNT(value uint32) {
	volatile.StoreUint32(&o.RXD_CNT.Reg, volatile.LoadUint32(&o.RXD_CNT.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetRXD_CNT_RXD_EDGE_CNT() uint32 {
	return volatile.LoadUint32(&o.RXD_CNT.Reg) & 0x3ff
}

// UART.FLOW_CONF: Software flow control configuration
func (o *UART_Type) SetFLOW_CONF_SW_FLOW_CON_EN(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetFLOW_CONF_SW_FLOW_CON_EN() uint32 {
	return volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x1
}
func (o *UART_Type) SetFLOW_CONF_XONOFF_DEL(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetFLOW_CONF_XONOFF_DEL() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetFLOW_CONF_FORCE_XON(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetFLOW_CONF_FORCE_XON() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetFLOW_CONF_FORCE_XOFF(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetFLOW_CONF_FORCE_XOFF() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetFLOW_CONF_SEND_XON(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetFLOW_CONF_SEND_XON() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetFLOW_CONF_SEND_XOFF(value uint32) {
	volatile.StoreUint32(&o.FLOW_CONF.Reg, volatile.LoadUint32(&o.FLOW_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetFLOW_CONF_SEND_XOFF() uint32 {
	return (volatile.LoadUint32(&o.FLOW_CONF.Reg) & 0x20) >> 5
}

// UART.SLEEP_CONF: Sleep mode configuration
func (o *UART_Type) SetSLEEP_CONF_ACTIVE_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SLEEP_CONF.Reg, volatile.LoadUint32(&o.SLEEP_CONF.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetSLEEP_CONF_ACTIVE_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SLEEP_CONF.Reg) & 0x3ff
}

// UART.SWFC_CONF0: Software flow control character configuration
func (o *UART_Type) SetSWFC_CONF0_XOFF_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x1ff)|value)
}
func (o *UART_Type) GetSWFC_CONF0_XOFF_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x1ff
}
func (o *UART_Type) SetSWFC_CONF0_XOFF_CHAR(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF0.Reg, volatile.LoadUint32(&o.SWFC_CONF0.Reg)&^(0x1fe00)|value<<9)
}
func (o *UART_Type) GetSWFC_CONF0_XOFF_CHAR() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF0.Reg) & 0x1fe00) >> 9
}

// UART.SWFC_CONF1: Software flow-control character configuration
func (o *UART_Type) SetSWFC_CONF1_XON_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF1.Reg, volatile.LoadUint32(&o.SWFC_CONF1.Reg)&^(0x1ff)|value)
}
func (o *UART_Type) GetSWFC_CONF1_XON_THRESHOLD() uint32 {
	return volatile.LoadUint32(&o.SWFC_CONF1.Reg) & 0x1ff
}
func (o *UART_Type) SetSWFC_CONF1_XON_CHAR(value uint32) {
	volatile.StoreUint32(&o.SWFC_CONF1.Reg, volatile.LoadUint32(&o.SWFC_CONF1.Reg)&^(0x1fe00)|value<<9)
}
func (o *UART_Type) GetSWFC_CONF1_XON_CHAR() uint32 {
	return (volatile.LoadUint32(&o.SWFC_CONF1.Reg) & 0x1fe00) >> 9
}

// UART.IDLE_CONF: Frame end idle time configuration
func (o *UART_Type) SetIDLE_CONF_RX_IDLE_THRHD(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetIDLE_CONF_RX_IDLE_THRHD() uint32 {
	return volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0x3ff
}
func (o *UART_Type) SetIDLE_CONF_TX_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0xffc00)|value<<10)
}
func (o *UART_Type) GetIDLE_CONF_TX_IDLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0xffc00) >> 10
}
func (o *UART_Type) SetIDLE_CONF_TX_BRK_NUM(value uint32) {
	volatile.StoreUint32(&o.IDLE_CONF.Reg, volatile.LoadUint32(&o.IDLE_CONF.Reg)&^(0xff00000)|value<<20)
}
func (o *UART_Type) GetIDLE_CONF_TX_BRK_NUM() uint32 {
	return (volatile.LoadUint32(&o.IDLE_CONF.Reg) & 0xff00000) >> 20
}

// UART.RS485_CONF: RS485 mode configuration
func (o *UART_Type) SetRS485_CONF_RS485_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetRS485_CONF_RS485_EN() uint32 {
	return volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x1
}
func (o *UART_Type) SetRS485_CONF_DL0_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetRS485_CONF_DL0_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetRS485_CONF_DL1_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetRS485_CONF_DL1_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetRS485_CONF_RS485TX_RX_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetRS485_CONF_RS485TX_RX_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetRS485_CONF_RS485RXBY_TX_EN(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetRS485_CONF_RS485RXBY_TX_EN() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetRS485_CONF_RS485_RX_DLY_NUM(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetRS485_CONF_RS485_RX_DLY_NUM() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetRS485_CONF_RS485_TX_DLY_NUM(value uint32) {
	volatile.StoreUint32(&o.RS485_CONF.Reg, volatile.LoadUint32(&o.RS485_CONF.Reg)&^(0x3c0)|value<<6)
}
func (o *UART_Type) GetRS485_CONF_RS485_TX_DLY_NUM() uint32 {
	return (volatile.LoadUint32(&o.RS485_CONF.Reg) & 0x3c0) >> 6
}

// UART.AT_CMD_PRECNT: Pre-sequence timing configuration
func (o *UART_Type) SetAT_CMD_PRECNT_PRE_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_PRECNT.Reg, volatile.LoadUint32(&o.AT_CMD_PRECNT.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetAT_CMD_PRECNT_PRE_IDLE_NUM() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_PRECNT.Reg) & 0xffff
}

// UART.AT_CMD_POSTCNT: Post-sequence timing configuration
func (o *UART_Type) SetAT_CMD_POSTCNT_POST_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_POSTCNT.Reg, volatile.LoadUint32(&o.AT_CMD_POSTCNT.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetAT_CMD_POSTCNT_POST_IDLE_NUM() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_POSTCNT.Reg) & 0xffff
}

// UART.AT_CMD_GAPTOUT: Timeout configuration
func (o *UART_Type) SetAT_CMD_GAPTOUT_RX_GAP_TOUT(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_GAPTOUT.Reg, volatile.LoadUint32(&o.AT_CMD_GAPTOUT.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetAT_CMD_GAPTOUT_RX_GAP_TOUT() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_GAPTOUT.Reg) & 0xffff
}

// UART.AT_CMD_CHAR: AT escape sequence selection configuration
func (o *UART_Type) SetAT_CMD_CHAR(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_CHAR.Reg, volatile.LoadUint32(&o.AT_CMD_CHAR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetAT_CMD_CHAR() uint32 {
	return volatile.LoadUint32(&o.AT_CMD_CHAR.Reg) & 0xff
}
func (o *UART_Type) SetAT_CMD_CHAR_CHAR_NUM(value uint32) {
	volatile.StoreUint32(&o.AT_CMD_CHAR.Reg, volatile.LoadUint32(&o.AT_CMD_CHAR.Reg)&^(0xff00)|value<<8)
}
func (o *UART_Type) GetAT_CMD_CHAR_CHAR_NUM() uint32 {
	return (volatile.LoadUint32(&o.AT_CMD_CHAR.Reg) & 0xff00) >> 8
}

// UART.MEM_CONF: UART threshold and allocation configuration
func (o *UART_Type) SetMEM_CONF_RX_SIZE(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xe)|value<<1)
}
func (o *UART_Type) GetMEM_CONF_RX_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xe) >> 1
}
func (o *UART_Type) SetMEM_CONF_TX_SIZE(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x70)|value<<4)
}
func (o *UART_Type) GetMEM_CONF_TX_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x70) >> 4
}
func (o *UART_Type) SetMEM_CONF_RX_FLOW_THRHD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0xff80)|value<<7)
}
func (o *UART_Type) GetMEM_CONF_RX_FLOW_THRHD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0xff80) >> 7
}
func (o *UART_Type) SetMEM_CONF_RX_TOUT_THRHD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x3ff0000)|value<<16)
}
func (o *UART_Type) GetMEM_CONF_RX_TOUT_THRHD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x3ff0000) >> 16
}
func (o *UART_Type) SetMEM_CONF_MEM_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x4000000)|value<<26)
}
func (o *UART_Type) GetMEM_CONF_MEM_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x4000000) >> 26
}
func (o *UART_Type) SetMEM_CONF_MEM_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.MEM_CONF.Reg, volatile.LoadUint32(&o.MEM_CONF.Reg)&^(0x8000000)|value<<27)
}
func (o *UART_Type) GetMEM_CONF_MEM_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.MEM_CONF.Reg) & 0x8000000) >> 27
}

// UART.MEM_TX_STATUS: TX FIFO write and read offset address
func (o *UART_Type) SetMEM_TX_STATUS_APB_TX_WADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_TX_STATUS.Reg, volatile.LoadUint32(&o.MEM_TX_STATUS.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetMEM_TX_STATUS_APB_TX_WADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_TX_STATUS.Reg) & 0x3ff
}
func (o *UART_Type) SetMEM_TX_STATUS_TX_RADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_TX_STATUS.Reg, volatile.LoadUint32(&o.MEM_TX_STATUS.Reg)&^(0x1ff800)|value<<11)
}
func (o *UART_Type) GetMEM_TX_STATUS_TX_RADDR() uint32 {
	return (volatile.LoadUint32(&o.MEM_TX_STATUS.Reg) & 0x1ff800) >> 11
}

// UART.MEM_RX_STATUS: RX FIFO write and read offset address
func (o *UART_Type) SetMEM_RX_STATUS_APB_RX_RADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_RX_STATUS.Reg, volatile.LoadUint32(&o.MEM_RX_STATUS.Reg)&^(0x3ff)|value)
}
func (o *UART_Type) GetMEM_RX_STATUS_APB_RX_RADDR() uint32 {
	return volatile.LoadUint32(&o.MEM_RX_STATUS.Reg) & 0x3ff
}
func (o *UART_Type) SetMEM_RX_STATUS_RX_WADDR(value uint32) {
	volatile.StoreUint32(&o.MEM_RX_STATUS.Reg, volatile.LoadUint32(&o.MEM_RX_STATUS.Reg)&^(0x1ff800)|value<<11)
}
func (o *UART_Type) GetMEM_RX_STATUS_RX_WADDR() uint32 {
	return (volatile.LoadUint32(&o.MEM_RX_STATUS.Reg) & 0x1ff800) >> 11
}

// UART.FSM_STATUS: UART transmitter and receiver status
func (o *UART_Type) SetFSM_STATUS_ST_URX_OUT(value uint32) {
	volatile.StoreUint32(&o.FSM_STATUS.Reg, volatile.LoadUint32(&o.FSM_STATUS.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetFSM_STATUS_ST_URX_OUT() uint32 {
	return volatile.LoadUint32(&o.FSM_STATUS.Reg) & 0xf
}
func (o *UART_Type) SetFSM_STATUS_ST_UTX_OUT(value uint32) {
	volatile.StoreUint32(&o.FSM_STATUS.Reg, volatile.LoadUint32(&o.FSM_STATUS.Reg)&^(0xf0)|value<<4)
}
func (o *UART_Type) GetFSM_STATUS_ST_UTX_OUT() uint32 {
	return (volatile.LoadUint32(&o.FSM_STATUS.Reg) & 0xf0) >> 4
}

// UART.POSPULSE: Autobaud high pulse register
func (o *UART_Type) SetPOSPULSE_POSEDGE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.POSPULSE.Reg, volatile.LoadUint32(&o.POSPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART_Type) GetPOSPULSE_POSEDGE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.POSPULSE.Reg) & 0xfffff
}

// UART.NEGPULSE: Autobaud low pulse register
func (o *UART_Type) SetNEGPULSE_NEGEDGE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.NEGPULSE.Reg, volatile.LoadUint32(&o.NEGPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART_Type) GetNEGPULSE_NEGEDGE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.NEGPULSE.Reg) & 0xfffff
}

// UART.DATE: UART version control register
func (o *UART_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *UART_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// UART.ID: UART ID register
func (o *UART_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, value)
}
func (o *UART_Type) GetID() uint32 {
	return volatile.LoadUint32(&o.ID.Reg)
}

// Universal Host Controller Interface 0
type UHCI_Type struct {
	CONF0                    volatile.Register32 // 0x0
	INT_RAW                  volatile.Register32 // 0x4
	INT_ST                   volatile.Register32 // 0x8
	INT_ENA                  volatile.Register32 // 0xC
	INT_CLR                  volatile.Register32 // 0x10
	DMA_OUT_STATUS           volatile.Register32 // 0x14
	DMA_OUT_PUSH             volatile.Register32 // 0x18
	DMA_IN_STATUS            volatile.Register32 // 0x1C
	DMA_IN_POP               volatile.Register32 // 0x20
	DMA_OUT_LINK             volatile.Register32 // 0x24
	DMA_IN_LINK              volatile.Register32 // 0x28
	CONF1                    volatile.Register32 // 0x2C
	STATE0                   volatile.Register32 // 0x30
	STATE1                   volatile.Register32 // 0x34
	DMA_OUT_EOF_DES_ADDR     volatile.Register32 // 0x38
	DMA_IN_SUC_EOF_DES_ADDR  volatile.Register32 // 0x3C
	DMA_IN_ERR_EOF_DES_ADDR  volatile.Register32 // 0x40
	DMA_OUT_EOF_BFR_DES_ADDR volatile.Register32 // 0x44
	AHB_TEST                 volatile.Register32 // 0x48
	DMA_IN_DSCR              volatile.Register32 // 0x4C
	DMA_IN_DSCR_BF0          volatile.Register32 // 0x50
	_                        [4]byte
	DMA_OUT_DSCR             volatile.Register32 // 0x58
	DMA_OUT_DSCR_BF0         volatile.Register32 // 0x5C
	_                        [4]byte
	ESCAPE_CONF              volatile.Register32 // 0x64
	HUNG_CONF                volatile.Register32 // 0x68
	_                        [4]byte
	RX_HEAD                  volatile.Register32 // 0x70
	QUICK_SENT               volatile.Register32 // 0x74
	Q0_WORD0                 volatile.Register32 // 0x78
	Q0_WORD1                 volatile.Register32 // 0x7C
	Q1_WORD0                 volatile.Register32 // 0x80
	Q1_WORD1                 volatile.Register32 // 0x84
	Q2_WORD0                 volatile.Register32 // 0x88
	Q2_WORD1                 volatile.Register32 // 0x8C
	Q3_WORD0                 volatile.Register32 // 0x90
	Q3_WORD1                 volatile.Register32 // 0x94
	Q4_WORD0                 volatile.Register32 // 0x98
	Q4_WORD1                 volatile.Register32 // 0x9C
	Q5_WORD0                 volatile.Register32 // 0xA0
	Q5_WORD1                 volatile.Register32 // 0xA4
	Q6_WORD0                 volatile.Register32 // 0xA8
	Q6_WORD1                 volatile.Register32 // 0xAC
	ESC_CONF0                volatile.Register32 // 0xB0
	ESC_CONF1                volatile.Register32 // 0xB4
	ESC_CONF2                volatile.Register32 // 0xB8
	ESC_CONF3                volatile.Register32 // 0xBC
	PKT_THRES                volatile.Register32 // 0xC0
	_                        [56]byte
	DATE                     volatile.Register32 // 0xFC
}

// UHCI.CONF0: UHCI configuration register
func (o *UHCI_Type) SetCONF0_IN_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetCONF0_IN_RST() uint32 {
	return volatile.LoadUint32(&o.CONF0.Reg) & 0x1
}
func (o *UHCI_Type) SetCONF0_OUT_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetCONF0_OUT_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetCONF0_AHBM_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetCONF0_AHBM_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetCONF0_AHBM_RST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetCONF0_AHBM_RST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetCONF0_IN_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetCONF0_IN_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetCONF0_OUT_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetCONF0_OUT_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetCONF0_OUT_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetCONF0_OUT_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetCONF0_OUT_NO_RESTART_CLR(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetCONF0_OUT_NO_RESTART_CLR() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetCONF0_OUT_EOF_MODE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetCONF0_OUT_EOF_MODE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetCONF0_UART0_CE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200)|value<<9)
}
func (o *UHCI_Type) GetCONF0_UART0_CE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200) >> 9
}
func (o *UHCI_Type) SetCONF0_UART1_CE(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400)|value<<10)
}
func (o *UHCI_Type) GetCONF0_UART1_CE() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400) >> 10
}
func (o *UHCI_Type) SetCONF0_OUTDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI_Type) GetCONF0_OUTDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x1000) >> 12
}
func (o *UHCI_Type) SetCONF0_INDSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI_Type) GetCONF0_INDSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x2000) >> 13
}
func (o *UHCI_Type) SetCONF0_MEM_TRANS_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI_Type) GetCONF0_MEM_TRANS_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x8000) >> 15
}
func (o *UHCI_Type) SetCONF0_SEPER_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetCONF0_SEPER_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x10000) >> 16
}
func (o *UHCI_Type) SetCONF0_HEAD_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UHCI_Type) GetCONF0_HEAD_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x20000) >> 17
}
func (o *UHCI_Type) SetCONF0_CRC_REC_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UHCI_Type) GetCONF0_CRC_REC_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x40000) >> 18
}
func (o *UHCI_Type) SetCONF0_UART_IDLE_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UHCI_Type) GetCONF0_UART_IDLE_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x80000) >> 19
}
func (o *UHCI_Type) SetCONF0_LEN_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UHCI_Type) GetCONF0_LEN_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x100000) >> 20
}
func (o *UHCI_Type) SetCONF0_ENCODE_CRC_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UHCI_Type) GetCONF0_ENCODE_CRC_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x200000) >> 21
}
func (o *UHCI_Type) SetCONF0_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UHCI_Type) GetCONF0_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x400000) >> 22
}
func (o *UHCI_Type) SetCONF0_UART_RX_BRK_EOF_EN(value uint32) {
	volatile.StoreUint32(&o.CONF0.Reg, volatile.LoadUint32(&o.CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UHCI_Type) GetCONF0_UART_RX_BRK_EOF_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF0.Reg) & 0x800000) >> 23
}

// UHCI.INT_RAW: Raw interrupt status
func (o *UHCI_Type) SetINT_RAW_RX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_RAW_RX_START_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_RAW_TX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_RAW_TX_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_RAW_RX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_RAW_RX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_RAW_TX_HUNG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_RAW_TX_HUNG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_RAW_IN_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_RAW_IN_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_RAW_IN_SUC_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_RAW_IN_SUC_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_RAW_IN_ERR_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_RAW_IN_ERR_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_RAW_OUT_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_RAW_OUT_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_RAW_OUT_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_RAW_OUT_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetINT_RAW_IN_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *UHCI_Type) GetINT_RAW_IN_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x200) >> 9
}
func (o *UHCI_Type) SetINT_RAW_OUT_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *UHCI_Type) GetINT_RAW_OUT_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x400) >> 10
}
func (o *UHCI_Type) SetINT_RAW_IN_DSCR_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetINT_RAW_IN_DSCR_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetINT_RAW_OUTLINK_EOF_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI_Type) GetINT_RAW_OUTLINK_EOF_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x1000) >> 12
}
func (o *UHCI_Type) SetINT_RAW_OUT_TOTAL_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI_Type) GetINT_RAW_OUT_TOTAL_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x2000) >> 13
}
func (o *UHCI_Type) SetINT_RAW_SEND_S_REG_Q_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI_Type) GetINT_RAW_SEND_S_REG_Q_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x4000) >> 14
}
func (o *UHCI_Type) SetINT_RAW_SEND_A_REG_Q_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI_Type) GetINT_RAW_SEND_A_REG_Q_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x8000) >> 15
}
func (o *UHCI_Type) SetINT_RAW_DMA_INFIFO_FULL_WM_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.INT_RAW.Reg, volatile.LoadUint32(&o.INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetINT_RAW_DMA_INFIFO_FULL_WM_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.INT_RAW.Reg) & 0x10000) >> 16
}

// UHCI.INT_ST: Masked interrupt status
func (o *UHCI_Type) SetINT_ST_RX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_ST_RX_START_INT_ST() uint32 {
	return volatile.LoadUint32(&o.INT_ST.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_ST_TX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_ST_TX_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_ST_RX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_ST_RX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_ST_TX_HUNG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_ST_TX_HUNG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_ST_IN_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_ST_IN_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_ST_IN_SUC_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_ST_IN_SUC_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_ST_IN_ERR_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_ST_IN_ERR_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_ST_OUT_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_ST_OUT_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_ST_OUT_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_ST_OUT_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetINT_ST_IN_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x200)|value<<9)
}
func (o *UHCI_Type) GetINT_ST_IN_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x200) >> 9
}
func (o *UHCI_Type) SetINT_ST_OUT_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x400)|value<<10)
}
func (o *UHCI_Type) GetINT_ST_OUT_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x400) >> 10
}
func (o *UHCI_Type) SetINT_ST_IN_DSCR_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetINT_ST_IN_DSCR_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetINT_ST_OUTLINK_EOF_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI_Type) GetINT_ST_OUTLINK_EOF_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x1000) >> 12
}
func (o *UHCI_Type) SetINT_ST_OUT_TOTAL_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI_Type) GetINT_ST_OUT_TOTAL_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x2000) >> 13
}
func (o *UHCI_Type) SetINT_ST_SEND_S_REG_Q_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI_Type) GetINT_ST_SEND_S_REG_Q_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x4000) >> 14
}
func (o *UHCI_Type) SetINT_ST_SEND_A_REG_Q_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI_Type) GetINT_ST_SEND_A_REG_Q_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x8000) >> 15
}
func (o *UHCI_Type) SetINT_ST_DMA_INFIFO_FULL_WM_INT_ST(value uint32) {
	volatile.StoreUint32(&o.INT_ST.Reg, volatile.LoadUint32(&o.INT_ST.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetINT_ST_DMA_INFIFO_FULL_WM_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.INT_ST.Reg) & 0x10000) >> 16
}

// UHCI.INT_ENA: Interrupt enable bits
func (o *UHCI_Type) SetINT_ENA_RX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_ENA_RX_START_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_ENA_TX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_ENA_TX_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_ENA_RX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_ENA_RX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_ENA_TX_HUNG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_ENA_TX_HUNG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_ENA_IN_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_ENA_IN_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_ENA_IN_SUC_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_ENA_IN_SUC_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_ENA_IN_ERR_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_ENA_IN_ERR_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_ENA_OUT_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_ENA_OUT_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_ENA_OUT_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_ENA_OUT_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetINT_ENA_IN_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *UHCI_Type) GetINT_ENA_IN_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x200) >> 9
}
func (o *UHCI_Type) SetINT_ENA_OUT_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *UHCI_Type) GetINT_ENA_OUT_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x400) >> 10
}
func (o *UHCI_Type) SetINT_ENA_IN_DSCR_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetINT_ENA_IN_DSCR_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetINT_ENA_OUTLINK_EOF_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI_Type) GetINT_ENA_OUTLINK_EOF_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x1000) >> 12
}
func (o *UHCI_Type) SetINT_ENA_OUT_TOTAL_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI_Type) GetINT_ENA_OUT_TOTAL_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x2000) >> 13
}
func (o *UHCI_Type) SetINT_ENA_SEND_S_REG_Q_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI_Type) GetINT_ENA_SEND_S_REG_Q_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x4000) >> 14
}
func (o *UHCI_Type) SetINT_ENA_SEND_A_REG_Q_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI_Type) GetINT_ENA_SEND_A_REG_Q_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x8000) >> 15
}
func (o *UHCI_Type) SetINT_ENA_DMA_INFIFO_FULL_WM_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.INT_ENA.Reg, volatile.LoadUint32(&o.INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetINT_ENA_DMA_INFIFO_FULL_WM_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.INT_ENA.Reg) & 0x10000) >> 16
}

// UHCI.INT_CLR: Interrupt clear bits
func (o *UHCI_Type) SetINT_CLR_RX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetINT_CLR_RX_START_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1
}
func (o *UHCI_Type) SetINT_CLR_TX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetINT_CLR_TX_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetINT_CLR_RX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetINT_CLR_RX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetINT_CLR_TX_HUNG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetINT_CLR_TX_HUNG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetINT_CLR_IN_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetINT_CLR_IN_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetINT_CLR_IN_SUC_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetINT_CLR_IN_SUC_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetINT_CLR_IN_ERR_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetINT_CLR_IN_ERR_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetINT_CLR_OUT_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetINT_CLR_OUT_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetINT_CLR_OUT_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetINT_CLR_OUT_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetINT_CLR_IN_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *UHCI_Type) GetINT_CLR_IN_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x200) >> 9
}
func (o *UHCI_Type) SetINT_CLR_OUT_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *UHCI_Type) GetINT_CLR_OUT_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x400) >> 10
}
func (o *UHCI_Type) SetINT_CLR_IN_DSCR_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetINT_CLR_IN_DSCR_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetINT_CLR_OUTLINK_EOF_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *UHCI_Type) GetINT_CLR_OUTLINK_EOF_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x1000) >> 12
}
func (o *UHCI_Type) SetINT_CLR_OUT_TOTAL_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *UHCI_Type) GetINT_CLR_OUT_TOTAL_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x2000) >> 13
}
func (o *UHCI_Type) SetINT_CLR_SEND_S_REG_Q_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *UHCI_Type) GetINT_CLR_SEND_S_REG_Q_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x4000) >> 14
}
func (o *UHCI_Type) SetINT_CLR_SEND_A_REG_Q_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *UHCI_Type) GetINT_CLR_SEND_A_REG_Q_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x8000) >> 15
}
func (o *UHCI_Type) SetINT_CLR_DMA_INFIFO_FULL_WM_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.INT_CLR.Reg, volatile.LoadUint32(&o.INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetINT_CLR_DMA_INFIFO_FULL_WM_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INT_CLR.Reg) & 0x10000) >> 16
}

// UHCI.DMA_OUT_STATUS: DMA data-output status register
func (o *UHCI_Type) SetDMA_OUT_STATUS_OUT_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_STATUS.Reg, volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetDMA_OUT_STATUS_OUT_FULL() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg) & 0x1
}
func (o *UHCI_Type) SetDMA_OUT_STATUS_OUT_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_STATUS.Reg, volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetDMA_OUT_STATUS_OUT_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_STATUS.Reg) & 0x2) >> 1
}

// UHCI.DMA_OUT_PUSH: Push control register of TX FIFO
func (o *UHCI_Type) SetDMA_OUT_PUSH_OUTFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_PUSH.Reg, volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg)&^(0x1ff)|value)
}
func (o *UHCI_Type) GetDMA_OUT_PUSH_OUTFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg) & 0x1ff
}
func (o *UHCI_Type) SetDMA_OUT_PUSH_OUTFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_PUSH.Reg, volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetDMA_OUT_PUSH_OUTFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_PUSH.Reg) & 0x10000) >> 16
}

// UHCI.DMA_IN_STATUS: UHCI data-input status register
func (o *UHCI_Type) SetDMA_IN_STATUS_IN_FULL(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_STATUS.Reg, volatile.LoadUint32(&o.DMA_IN_STATUS.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetDMA_IN_STATUS_IN_FULL() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_STATUS.Reg) & 0x1
}
func (o *UHCI_Type) SetDMA_IN_STATUS_IN_EMPTY(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_STATUS.Reg, volatile.LoadUint32(&o.DMA_IN_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetDMA_IN_STATUS_IN_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_STATUS.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetDMA_IN_STATUS_RX_ERR_CAUSE(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_STATUS.Reg, volatile.LoadUint32(&o.DMA_IN_STATUS.Reg)&^(0x70)|value<<4)
}
func (o *UHCI_Type) GetDMA_IN_STATUS_RX_ERR_CAUSE() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_STATUS.Reg) & 0x70) >> 4
}

// UHCI.DMA_IN_POP: Pop control register of RX FIFO
func (o *UHCI_Type) SetDMA_IN_POP_INFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_POP.Reg, volatile.LoadUint32(&o.DMA_IN_POP.Reg)&^(0xfff)|value)
}
func (o *UHCI_Type) GetDMA_IN_POP_INFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_POP.Reg) & 0xfff
}
func (o *UHCI_Type) SetDMA_IN_POP_INFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_POP.Reg, volatile.LoadUint32(&o.DMA_IN_POP.Reg)&^(0x10000)|value<<16)
}
func (o *UHCI_Type) GetDMA_IN_POP_INFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_POP.Reg) & 0x10000) >> 16
}

// UHCI.DMA_OUT_LINK: Link descriptor address and control
func (o *UHCI_Type) SetDMA_OUT_LINK_OUTLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0xfffff)|value)
}
func (o *UHCI_Type) GetDMA_OUT_LINK_OUTLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0xfffff
}
func (o *UHCI_Type) SetDMA_OUT_LINK_OUTLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *UHCI_Type) GetDMA_OUT_LINK_OUTLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x10000000) >> 28
}
func (o *UHCI_Type) SetDMA_OUT_LINK_OUTLINK_START(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *UHCI_Type) GetDMA_OUT_LINK_OUTLINK_START() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x20000000) >> 29
}
func (o *UHCI_Type) SetDMA_OUT_LINK_OUTLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *UHCI_Type) GetDMA_OUT_LINK_OUTLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x40000000) >> 30
}
func (o *UHCI_Type) SetDMA_OUT_LINK_OUTLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_LINK.Reg, volatile.LoadUint32(&o.DMA_OUT_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *UHCI_Type) GetDMA_OUT_LINK_OUTLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.DMA_OUT_LINK.Reg) & 0x80000000) >> 31
}

// UHCI.DMA_IN_LINK: Link descriptor address and control
func (o *UHCI_Type) SetDMA_IN_LINK_INLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0xfffff)|value)
}
func (o *UHCI_Type) GetDMA_IN_LINK_INLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0xfffff
}
func (o *UHCI_Type) SetDMA_IN_LINK_INLINK_AUTO_RET(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x100000)|value<<20)
}
func (o *UHCI_Type) GetDMA_IN_LINK_INLINK_AUTO_RET() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x100000) >> 20
}
func (o *UHCI_Type) SetDMA_IN_LINK_INLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *UHCI_Type) GetDMA_IN_LINK_INLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x10000000) >> 28
}
func (o *UHCI_Type) SetDMA_IN_LINK_INLINK_START(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *UHCI_Type) GetDMA_IN_LINK_INLINK_START() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x20000000) >> 29
}
func (o *UHCI_Type) SetDMA_IN_LINK_INLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *UHCI_Type) GetDMA_IN_LINK_INLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x40000000) >> 30
}
func (o *UHCI_Type) SetDMA_IN_LINK_INLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_LINK.Reg, volatile.LoadUint32(&o.DMA_IN_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *UHCI_Type) GetDMA_IN_LINK_INLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.DMA_IN_LINK.Reg) & 0x80000000) >> 31
}

// UHCI.CONF1: UHCI configuration register
func (o *UHCI_Type) SetCONF1_CHECK_SUM_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetCONF1_CHECK_SUM_EN() uint32 {
	return volatile.LoadUint32(&o.CONF1.Reg) & 0x1
}
func (o *UHCI_Type) SetCONF1_CHECK_SEQ_EN(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetCONF1_CHECK_SEQ_EN() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetCONF1_CRC_DISABLE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetCONF1_CRC_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetCONF1_SAVE_HEAD(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetCONF1_SAVE_HEAD() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetCONF1_TX_CHECK_SUM_RE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetCONF1_TX_CHECK_SUM_RE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetCONF1_TX_ACK_NUM_RE(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetCONF1_TX_ACK_NUM_RE() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetCONF1_CHECK_OWNER(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetCONF1_CHECK_OWNER() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetCONF1_WAIT_SW_START(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetCONF1_WAIT_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x80) >> 7
}
func (o *UHCI_Type) SetCONF1_SW_START(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x100)|value<<8)
}
func (o *UHCI_Type) GetCONF1_SW_START() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x100) >> 8
}
func (o *UHCI_Type) SetCONF1_DMA_INFIFO_FULL_THRS(value uint32) {
	volatile.StoreUint32(&o.CONF1.Reg, volatile.LoadUint32(&o.CONF1.Reg)&^(0x1ffe00)|value<<9)
}
func (o *UHCI_Type) GetCONF1_DMA_INFIFO_FULL_THRS() uint32 {
	return (volatile.LoadUint32(&o.CONF1.Reg) & 0x1ffe00) >> 9
}

// UHCI.STATE0: UHCI decoder status register
func (o *UHCI_Type) SetSTATE0_INLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x3ffff)|value)
}
func (o *UHCI_Type) GetSTATE0_INLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.STATE0.Reg) & 0x3ffff
}
func (o *UHCI_Type) SetSTATE0_IN_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0xc0000)|value<<18)
}
func (o *UHCI_Type) GetSTATE0_IN_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0xc0000) >> 18
}
func (o *UHCI_Type) SetSTATE0_IN_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI_Type) GetSTATE0_IN_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x700000) >> 20
}
func (o *UHCI_Type) SetSTATE0_INFIFO_CNT_DEBUG(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0xf800000)|value<<23)
}
func (o *UHCI_Type) GetSTATE0_INFIFO_CNT_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0xf800000) >> 23
}
func (o *UHCI_Type) SetSTATE0_DECODE_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE0.Reg, volatile.LoadUint32(&o.STATE0.Reg)&^(0x70000000)|value<<28)
}
func (o *UHCI_Type) GetSTATE0_DECODE_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE0.Reg) & 0x70000000) >> 28
}

// UHCI.STATE1: UHCI encoder status register
func (o *UHCI_Type) SetSTATE1_OUTLINK_DSCR_ADDR(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x3ffff)|value)
}
func (o *UHCI_Type) GetSTATE1_OUTLINK_DSCR_ADDR() uint32 {
	return volatile.LoadUint32(&o.STATE1.Reg) & 0x3ffff
}
func (o *UHCI_Type) SetSTATE1_OUT_DSCR_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0xc0000)|value<<18)
}
func (o *UHCI_Type) GetSTATE1_OUT_DSCR_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0xc0000) >> 18
}
func (o *UHCI_Type) SetSTATE1_OUT_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI_Type) GetSTATE1_OUT_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0x700000) >> 20
}
func (o *UHCI_Type) SetSTATE1_OUTFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0xf800000)|value<<23)
}
func (o *UHCI_Type) GetSTATE1_OUTFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0xf800000) >> 23
}
func (o *UHCI_Type) SetSTATE1_ENCODE_STATE(value uint32) {
	volatile.StoreUint32(&o.STATE1.Reg, volatile.LoadUint32(&o.STATE1.Reg)&^(0x70000000)|value<<28)
}
func (o *UHCI_Type) GetSTATE1_ENCODE_STATE() uint32 {
	return (volatile.LoadUint32(&o.STATE1.Reg) & 0x70000000) >> 28
}

// UHCI.DMA_OUT_EOF_DES_ADDR: Outlink descriptor address when EOF occurs
func (o *UHCI_Type) SetDMA_OUT_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_EOF_DES_ADDR.Reg, value)
}
func (o *UHCI_Type) GetDMA_OUT_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_EOF_DES_ADDR.Reg)
}

// UHCI.DMA_IN_SUC_EOF_DES_ADDR: Inlink descriptor address when EOF occurs
func (o *UHCI_Type) SetDMA_IN_SUC_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_SUC_EOF_DES_ADDR.Reg, value)
}
func (o *UHCI_Type) GetDMA_IN_SUC_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_SUC_EOF_DES_ADDR.Reg)
}

// UHCI.DMA_IN_ERR_EOF_DES_ADDR: Inlink descriptor address when errors occur
func (o *UHCI_Type) SetDMA_IN_ERR_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_ERR_EOF_DES_ADDR.Reg, value)
}
func (o *UHCI_Type) GetDMA_IN_ERR_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_ERR_EOF_DES_ADDR.Reg)
}

// UHCI.DMA_OUT_EOF_BFR_DES_ADDR: Outlink descriptor address before the last transmit descriptor
func (o *UHCI_Type) SetDMA_OUT_EOF_BFR_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_EOF_BFR_DES_ADDR.Reg, value)
}
func (o *UHCI_Type) GetDMA_OUT_EOF_BFR_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_EOF_BFR_DES_ADDR.Reg)
}

// UHCI.AHB_TEST: AHB test register
func (o *UHCI_Type) SetAHB_TEST_AHB_TESTMODE(value uint32) {
	volatile.StoreUint32(&o.AHB_TEST.Reg, volatile.LoadUint32(&o.AHB_TEST.Reg)&^(0x7)|value)
}
func (o *UHCI_Type) GetAHB_TEST_AHB_TESTMODE() uint32 {
	return volatile.LoadUint32(&o.AHB_TEST.Reg) & 0x7
}
func (o *UHCI_Type) SetAHB_TEST_AHB_TESTADDR(value uint32) {
	volatile.StoreUint32(&o.AHB_TEST.Reg, volatile.LoadUint32(&o.AHB_TEST.Reg)&^(0x30)|value<<4)
}
func (o *UHCI_Type) GetAHB_TEST_AHB_TESTADDR() uint32 {
	return (volatile.LoadUint32(&o.AHB_TEST.Reg) & 0x30) >> 4
}

// UHCI.DMA_IN_DSCR: The third word of the next receive descriptor
func (o *UHCI_Type) SetDMA_IN_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_DSCR.Reg, value)
}
func (o *UHCI_Type) GetDMA_IN_DSCR() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_DSCR.Reg)
}

// UHCI.DMA_IN_DSCR_BF0: The third word of current receive descriptor
func (o *UHCI_Type) SetDMA_IN_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.DMA_IN_DSCR_BF0.Reg, value)
}
func (o *UHCI_Type) GetDMA_IN_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.DMA_IN_DSCR_BF0.Reg)
}

// UHCI.DMA_OUT_DSCR: The third word of the next transmit descriptor
func (o *UHCI_Type) SetDMA_OUT_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_DSCR.Reg, value)
}
func (o *UHCI_Type) GetDMA_OUT_DSCR() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_DSCR.Reg)
}

// UHCI.DMA_OUT_DSCR_BF0: The third word of current transmit descriptor
func (o *UHCI_Type) SetDMA_OUT_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.DMA_OUT_DSCR_BF0.Reg, value)
}
func (o *UHCI_Type) GetDMA_OUT_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.DMA_OUT_DSCR_BF0.Reg)
}

// UHCI.ESCAPE_CONF: Escape character configuration
func (o *UHCI_Type) SetESCAPE_CONF_TX_C0_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x1)|value)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_C0_ESC_EN() uint32 {
	return volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x1
}
func (o *UHCI_Type) SetESCAPE_CONF_TX_DB_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x2)|value<<1)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_DB_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x2) >> 1
}
func (o *UHCI_Type) SetESCAPE_CONF_TX_11_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x4)|value<<2)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_11_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x4) >> 2
}
func (o *UHCI_Type) SetESCAPE_CONF_TX_13_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetESCAPE_CONF_TX_13_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_C0_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x10)|value<<4)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_C0_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x10) >> 4
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_DB_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x20)|value<<5)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_DB_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x20) >> 5
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_11_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x40)|value<<6)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_11_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x40) >> 6
}
func (o *UHCI_Type) SetESCAPE_CONF_RX_13_ESC_EN(value uint32) {
	volatile.StoreUint32(&o.ESCAPE_CONF.Reg, volatile.LoadUint32(&o.ESCAPE_CONF.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetESCAPE_CONF_RX_13_ESC_EN() uint32 {
	return (volatile.LoadUint32(&o.ESCAPE_CONF.Reg) & 0x80) >> 7
}

// UHCI.HUNG_CONF: Timeout configuration
func (o *UHCI_Type) SetHUNG_CONF_TXFIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetHUNG_CONF_TXFIFO_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0xff
}
func (o *UHCI_Type) SetHUNG_CONF_TXFIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x700)|value<<8)
}
func (o *UHCI_Type) GetHUNG_CONF_TXFIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x700) >> 8
}
func (o *UHCI_Type) SetHUNG_CONF_TXFIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *UHCI_Type) GetHUNG_CONF_TXFIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x800) >> 11
}
func (o *UHCI_Type) SetHUNG_CONF_RXFIFO_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0xff000)|value<<12)
}
func (o *UHCI_Type) GetHUNG_CONF_RXFIFO_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0xff000) >> 12
}
func (o *UHCI_Type) SetHUNG_CONF_RXFIFO_TIMEOUT_SHIFT(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x700000)|value<<20)
}
func (o *UHCI_Type) GetHUNG_CONF_RXFIFO_TIMEOUT_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x700000) >> 20
}
func (o *UHCI_Type) SetHUNG_CONF_RXFIFO_TIMEOUT_ENA(value uint32) {
	volatile.StoreUint32(&o.HUNG_CONF.Reg, volatile.LoadUint32(&o.HUNG_CONF.Reg)&^(0x800000)|value<<23)
}
func (o *UHCI_Type) GetHUNG_CONF_RXFIFO_TIMEOUT_ENA() uint32 {
	return (volatile.LoadUint32(&o.HUNG_CONF.Reg) & 0x800000) >> 23
}

// UHCI.RX_HEAD: UHCI packet header register
func (o *UHCI_Type) SetRX_HEAD(value uint32) {
	volatile.StoreUint32(&o.RX_HEAD.Reg, value)
}
func (o *UHCI_Type) GetRX_HEAD() uint32 {
	return volatile.LoadUint32(&o.RX_HEAD.Reg)
}

// UHCI.QUICK_SENT: UHCI quick_sent configuration register
func (o *UHCI_Type) SetQUICK_SENT_SINGLE_SEND_NUM(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x7)|value)
}
func (o *UHCI_Type) GetQUICK_SENT_SINGLE_SEND_NUM() uint32 {
	return volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x7
}
func (o *UHCI_Type) SetQUICK_SENT_SINGLE_SEND_EN(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x8)|value<<3)
}
func (o *UHCI_Type) GetQUICK_SENT_SINGLE_SEND_EN() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x8) >> 3
}
func (o *UHCI_Type) SetQUICK_SENT_ALWAYS_SEND_NUM(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x70)|value<<4)
}
func (o *UHCI_Type) GetQUICK_SENT_ALWAYS_SEND_NUM() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x70) >> 4
}
func (o *UHCI_Type) SetQUICK_SENT_ALWAYS_SEND_EN(value uint32) {
	volatile.StoreUint32(&o.QUICK_SENT.Reg, volatile.LoadUint32(&o.QUICK_SENT.Reg)&^(0x80)|value<<7)
}
func (o *UHCI_Type) GetQUICK_SENT_ALWAYS_SEND_EN() uint32 {
	return (volatile.LoadUint32(&o.QUICK_SENT.Reg) & 0x80) >> 7
}

// UHCI.Q0_WORD0: Q0_WORD0 quick_sent register
func (o *UHCI_Type) SetQ0_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q0_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ0_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q0_WORD0.Reg)
}

// UHCI.Q0_WORD1: Q0_WORD1 quick_sent register
func (o *UHCI_Type) SetQ0_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q0_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ0_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q0_WORD1.Reg)
}

// UHCI.Q1_WORD0: Q1_WORD0 quick_sent register
func (o *UHCI_Type) SetQ1_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q1_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ1_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q1_WORD0.Reg)
}

// UHCI.Q1_WORD1: Q1_WORD1 quick_sent register
func (o *UHCI_Type) SetQ1_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q1_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ1_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q1_WORD1.Reg)
}

// UHCI.Q2_WORD0: Q2_WORD0 quick_sent register
func (o *UHCI_Type) SetQ2_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q2_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ2_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q2_WORD0.Reg)
}

// UHCI.Q2_WORD1: Q2_WORD1 quick_sent register
func (o *UHCI_Type) SetQ2_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q2_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ2_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q2_WORD1.Reg)
}

// UHCI.Q3_WORD0: Q3_WORD0 quick_sent register
func (o *UHCI_Type) SetQ3_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q3_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ3_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q3_WORD0.Reg)
}

// UHCI.Q3_WORD1: Q3_WORD1 quick_sent register
func (o *UHCI_Type) SetQ3_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q3_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ3_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q3_WORD1.Reg)
}

// UHCI.Q4_WORD0: Q4_WORD0 quick_sent register
func (o *UHCI_Type) SetQ4_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q4_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ4_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q4_WORD0.Reg)
}

// UHCI.Q4_WORD1: Q4_WORD1 quick_sent register
func (o *UHCI_Type) SetQ4_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q4_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ4_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q4_WORD1.Reg)
}

// UHCI.Q5_WORD0: Q5_WORD0 quick_sent register
func (o *UHCI_Type) SetQ5_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q5_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ5_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q5_WORD0.Reg)
}

// UHCI.Q5_WORD1: Q5_WORD1 quick_sent register
func (o *UHCI_Type) SetQ5_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q5_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ5_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q5_WORD1.Reg)
}

// UHCI.Q6_WORD0: Q6_WORD0 quick_sent register
func (o *UHCI_Type) SetQ6_WORD0(value uint32) {
	volatile.StoreUint32(&o.Q6_WORD0.Reg, value)
}
func (o *UHCI_Type) GetQ6_WORD0() uint32 {
	return volatile.LoadUint32(&o.Q6_WORD0.Reg)
}

// UHCI.Q6_WORD1: Q6_WORD1 quick_sent register
func (o *UHCI_Type) SetQ6_WORD1(value uint32) {
	volatile.StoreUint32(&o.Q6_WORD1.Reg, value)
}
func (o *UHCI_Type) GetQ6_WORD1() uint32 {
	return volatile.LoadUint32(&o.Q6_WORD1.Reg)
}

// UHCI.ESC_CONF0: Escape sequence configuration register 0
func (o *UHCI_Type) SetESC_CONF0_SEPER_CHAR(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF0_SEPER_CHAR() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF0_SEPER_ESC_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF0_SEPER_ESC_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF0_SEPER_ESC_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF0.Reg, volatile.LoadUint32(&o.ESC_CONF0.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF0_SEPER_ESC_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF0.Reg) & 0xff0000) >> 16
}

// UHCI.ESC_CONF1: Escape sequence configuration register 1
func (o *UHCI_Type) SetESC_CONF1_ESC_SEQ0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF1_ESC_SEQ0() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF1_ESC_SEQ0_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF1_ESC_SEQ0_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF1_ESC_SEQ0_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF1.Reg, volatile.LoadUint32(&o.ESC_CONF1.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF1_ESC_SEQ0_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF1.Reg) & 0xff0000) >> 16
}

// UHCI.ESC_CONF2: Escape sequence configuration register 2
func (o *UHCI_Type) SetESC_CONF2_ESC_SEQ1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF2_ESC_SEQ1() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF2_ESC_SEQ1_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF2_ESC_SEQ1_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF2_ESC_SEQ1_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF2.Reg, volatile.LoadUint32(&o.ESC_CONF2.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF2_ESC_SEQ1_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF2.Reg) & 0xff0000) >> 16
}

// UHCI.ESC_CONF3: Escape sequence configuration register 3
func (o *UHCI_Type) SetESC_CONF3_ESC_SEQ2(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff)|value)
}
func (o *UHCI_Type) GetESC_CONF3_ESC_SEQ2() uint32 {
	return volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff
}
func (o *UHCI_Type) SetESC_CONF3_ESC_SEQ2_CHAR0(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff00)|value<<8)
}
func (o *UHCI_Type) GetESC_CONF3_ESC_SEQ2_CHAR0() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff00) >> 8
}
func (o *UHCI_Type) SetESC_CONF3_ESC_SEQ2_CHAR1(value uint32) {
	volatile.StoreUint32(&o.ESC_CONF3.Reg, volatile.LoadUint32(&o.ESC_CONF3.Reg)&^(0xff0000)|value<<16)
}
func (o *UHCI_Type) GetESC_CONF3_ESC_SEQ2_CHAR1() uint32 {
	return (volatile.LoadUint32(&o.ESC_CONF3.Reg) & 0xff0000) >> 16
}

// UHCI.PKT_THRES: Configure register for packet length
func (o *UHCI_Type) SetPKT_THRES_PKT_THRS(value uint32) {
	volatile.StoreUint32(&o.PKT_THRES.Reg, volatile.LoadUint32(&o.PKT_THRES.Reg)&^(0x1fff)|value)
}
func (o *UHCI_Type) GetPKT_THRES_PKT_THRS() uint32 {
	return volatile.LoadUint32(&o.PKT_THRES.Reg) & 0x1fff
}

// UHCI.DATE: UHCI version control register
func (o *UHCI_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *UHCI_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// USB OTG (On-The-Go)
type USB_Type struct {
	GOTGCTL    volatile.Register32 // 0x0
	GOTGINT    volatile.Register32 // 0x4
	GAHBCFG    volatile.Register32 // 0x8
	GUSBCFG    volatile.Register32 // 0xC
	GRSTCTL    volatile.Register32 // 0x10
	GINTSTS    volatile.Register32 // 0x14
	GINTMSK    volatile.Register32 // 0x18
	GRXSTSR    volatile.Register32 // 0x1C
	GRXSTSP    volatile.Register32 // 0x20
	GRXFSIZ    volatile.Register32 // 0x24
	GNPTXFSIZ  volatile.Register32 // 0x28
	GNPTXSTS   volatile.Register32 // 0x2C
	_          [16]byte
	GSNPSID    volatile.Register32 // 0x40
	GHWCFG1    volatile.Register32 // 0x44
	GHWCFG2    volatile.Register32 // 0x48
	GHWCFG3    volatile.Register32 // 0x4C
	GHWCFG4    volatile.Register32 // 0x50
	_          [8]byte
	GDFIFOCFG  volatile.Register32 // 0x5C
	_          [160]byte
	HPTXFSIZ   volatile.Register32 // 0x100
	DIEPTXF1   volatile.Register32 // 0x104
	DIEPTXF2   volatile.Register32 // 0x108
	DIEPTXF3   volatile.Register32 // 0x10C
	DIEPTXF4   volatile.Register32 // 0x110
	_          [748]byte
	HCFG       volatile.Register32 // 0x400
	HFIR       volatile.Register32 // 0x404
	HFNUM      volatile.Register32 // 0x408
	_          [4]byte
	HPTXSTS    volatile.Register32 // 0x410
	HAINT      volatile.Register32 // 0x414
	HAINTMSK   volatile.Register32 // 0x418
	HFLBADDR   volatile.Register32 // 0x41C
	_          [32]byte
	HPRT       volatile.Register32 // 0x440
	_          [188]byte
	HCCHAR0    volatile.Register32 // 0x500
	_          [4]byte
	HCINT0     volatile.Register32 // 0x508
	HCINTMSK0  volatile.Register32 // 0x50C
	HCTSIZ0    volatile.Register32 // 0x510
	HCDMA0     volatile.Register32 // 0x514
	_          [4]byte
	HCDMAB0    volatile.Register32 // 0x51C
	HCCHAR1    volatile.Register32 // 0x520
	_          [4]byte
	HCINT1     volatile.Register32 // 0x528
	HCINTMSK1  volatile.Register32 // 0x52C
	HCTSIZ1    volatile.Register32 // 0x530
	HCDMA1     volatile.Register32 // 0x534
	_          [4]byte
	HCDMAB1    volatile.Register32 // 0x53C
	HCCHAR2    volatile.Register32 // 0x540
	_          [4]byte
	HCINT2     volatile.Register32 // 0x548
	HCINTMSK2  volatile.Register32 // 0x54C
	HCTSIZ2    volatile.Register32 // 0x550
	HCDMA2     volatile.Register32 // 0x554
	_          [4]byte
	HCDMAB2    volatile.Register32 // 0x55C
	HCCHAR3    volatile.Register32 // 0x560
	_          [4]byte
	HCINT3     volatile.Register32 // 0x568
	HCINTMSK3  volatile.Register32 // 0x56C
	HCTSIZ3    volatile.Register32 // 0x570
	HCDMA3     volatile.Register32 // 0x574
	_          [4]byte
	HCDMAB3    volatile.Register32 // 0x57C
	HCCHAR4    volatile.Register32 // 0x580
	_          [4]byte
	HCINT4     volatile.Register32 // 0x588
	HCINTMSK4  volatile.Register32 // 0x58C
	HCTSIZ4    volatile.Register32 // 0x590
	HCDMA4     volatile.Register32 // 0x594
	_          [4]byte
	HCDMAB4    volatile.Register32 // 0x59C
	HCCHAR5    volatile.Register32 // 0x5A0
	_          [4]byte
	HCINT5     volatile.Register32 // 0x5A8
	HCINTMSK5  volatile.Register32 // 0x5AC
	HCTSIZ5    volatile.Register32 // 0x5B0
	HCDMA5     volatile.Register32 // 0x5B4
	_          [4]byte
	HCDMAB5    volatile.Register32 // 0x5BC
	HCCHAR6    volatile.Register32 // 0x5C0
	_          [4]byte
	HCINT6     volatile.Register32 // 0x5C8
	HCINTMSK6  volatile.Register32 // 0x5CC
	HCTSIZ6    volatile.Register32 // 0x5D0
	HCDMA6     volatile.Register32 // 0x5D4
	_          [4]byte
	HCDMAB6    volatile.Register32 // 0x5DC
	HCCHAR7    volatile.Register32 // 0x5E0
	_          [4]byte
	HCINT7     volatile.Register32 // 0x5E8
	HCINTMSK7  volatile.Register32 // 0x5EC
	HCTSIZ7    volatile.Register32 // 0x5F0
	HCDMA7     volatile.Register32 // 0x5F4
	_          [4]byte
	HCDMAB7    volatile.Register32 // 0x5FC
	_          [512]byte
	DCFG       volatile.Register32 // 0x800
	DCTL       volatile.Register32 // 0x804
	DSTS       volatile.Register32 // 0x808
	_          [4]byte
	DIEPMSK    volatile.Register32 // 0x810
	DOEPMSK    volatile.Register32 // 0x814
	DAINT      volatile.Register32 // 0x818
	DAINTMSK   volatile.Register32 // 0x81C
	_          [8]byte
	DVBUSDIS   volatile.Register32 // 0x828
	DVBUSPULSE volatile.Register32 // 0x82C
	DTHRCTL    volatile.Register32 // 0x830
	DIEPEMPMSK volatile.Register32 // 0x834
	_          [200]byte
	DIEPCTL0   volatile.Register32 // 0x900
	_          [4]byte
	DIEPINT0   volatile.Register32 // 0x908
	_          [4]byte
	DIEPTSIZ0  volatile.Register32 // 0x910
	DIEPDMA0   volatile.Register32 // 0x914
	DTXFSTS0   volatile.Register32 // 0x918
	DIEPDMAB0  volatile.Register32 // 0x91C
	DIEPCTL1   volatile.Register32 // 0x920
	_          [4]byte
	DIEPINT1   volatile.Register32 // 0x928
	_          [4]byte
	DIEPTSIZ1  volatile.Register32 // 0x930
	DIEPDMA1   volatile.Register32 // 0x934
	DTXFSTS1   volatile.Register32 // 0x938
	DIEPDMAB1  volatile.Register32 // 0x93C
	DIEPCTL2   volatile.Register32 // 0x940
	_          [4]byte
	DIEPINT2   volatile.Register32 // 0x948
	_          [4]byte
	DIEPTSIZ2  volatile.Register32 // 0x950
	DIEPDMA2   volatile.Register32 // 0x954
	DTXFSTS2   volatile.Register32 // 0x958
	DIEPDMAB2  volatile.Register32 // 0x95C
	DIEPCTL3   volatile.Register32 // 0x960
	_          [4]byte
	DIEPINT3   volatile.Register32 // 0x968
	_          [4]byte
	DIEPTSIZ3  volatile.Register32 // 0x970
	DIEPDMA3   volatile.Register32 // 0x974
	DTXFSTS3   volatile.Register32 // 0x978
	DIEPDMAB3  volatile.Register32 // 0x97C
	DIEPCTL4   volatile.Register32 // 0x980
	_          [4]byte
	DIEPINT4   volatile.Register32 // 0x988
	_          [4]byte
	DIEPTSIZ4  volatile.Register32 // 0x990
	DIEPDMA4   volatile.Register32 // 0x994
	DTXFSTS4   volatile.Register32 // 0x998
	DIEPDMAB4  volatile.Register32 // 0x99C
	DIEPCTL5   volatile.Register32 // 0x9A0
	_          [4]byte
	DIEPINT5   volatile.Register32 // 0x9A8
	_          [4]byte
	DIEPTSIZ5  volatile.Register32 // 0x9B0
	DIEPDMA5   volatile.Register32 // 0x9B4
	DTXFSTS5   volatile.Register32 // 0x9B8
	DIEPDMAB5  volatile.Register32 // 0x9BC
	DIEPCTL6   volatile.Register32 // 0x9C0
	_          [4]byte
	DIEPINT6   volatile.Register32 // 0x9C8
	_          [4]byte
	DIEPTSIZ6  volatile.Register32 // 0x9D0
	DIEPDMA6   volatile.Register32 // 0x9D4
	DTXFSTS6   volatile.Register32 // 0x9D8
	DIEPDMAB6  volatile.Register32 // 0x9DC
	_          [288]byte
	DOEPCTL0   volatile.Register32 // 0xB00
	_          [4]byte
	DOEPINT0   volatile.Register32 // 0xB08
	_          [4]byte
	DOEPTSIZ0  volatile.Register32 // 0xB10
	DOEPDMA0   volatile.Register32 // 0xB14
	_          [4]byte
	DOEPDMAB0  volatile.Register32 // 0xB1C
	DOEPCTL1   volatile.Register32 // 0xB20
	_          [4]byte
	DOEPINT1   volatile.Register32 // 0xB28
	_          [4]byte
	DOEPTSIZ1  volatile.Register32 // 0xB30
	DOEPDMA1   volatile.Register32 // 0xB34
	_          [4]byte
	DOEPDMAB1  volatile.Register32 // 0xB3C
	DOEPCTL2   volatile.Register32 // 0xB40
	_          [4]byte
	DOEPINT2   volatile.Register32 // 0xB48
	_          [4]byte
	DOEPTSIZ2  volatile.Register32 // 0xB50
	DOEPDMA2   volatile.Register32 // 0xB54
	_          [4]byte
	DOEPDMAB2  volatile.Register32 // 0xB5C
	DOEPCTL3   volatile.Register32 // 0xB60
	_          [4]byte
	DOEPINT3   volatile.Register32 // 0xB68
	_          [4]byte
	DOEPTSIZ3  volatile.Register32 // 0xB70
	DOEPDMA3   volatile.Register32 // 0xB74
	_          [4]byte
	DOEPDMAB3  volatile.Register32 // 0xB7C
	DOEPCTL4   volatile.Register32 // 0xB80
	_          [4]byte
	DOEPINT4   volatile.Register32 // 0xB88
	_          [4]byte
	DOEPTSIZ4  volatile.Register32 // 0xB90
	DOEPDMA4   volatile.Register32 // 0xB94
	_          [4]byte
	DOEPDMAB4  volatile.Register32 // 0xB9C
	DOEPCTL5   volatile.Register32 // 0xBA0
	_          [4]byte
	DOEPINT5   volatile.Register32 // 0xBA8
	_          [4]byte
	DOEPTSIZ5  volatile.Register32 // 0xBB0
	DOEPDMA5   volatile.Register32 // 0xBB4
	_          [4]byte
	DOEPDMAB5  volatile.Register32 // 0xBBC
	DOEPCTL6   volatile.Register32 // 0xBC0
	_          [4]byte
	DOEPINT6   volatile.Register32 // 0xBC8
	_          [4]byte
	DOEPTSIZ6  volatile.Register32 // 0xBD0
	DOEPDMA6   volatile.Register32 // 0xBD4
	_          [4]byte
	DOEPDMAB6  volatile.Register32 // 0xBDC
	_          [544]byte
	PCGCCTL    volatile.Register32 // 0xE00
}

// USB.GOTGCTL
func (o *USB_Type) SetGOTGCTL_SESREQSCS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetGOTGCTL_SESREQSCS() uint32 {
	return volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x1
}
func (o *USB_Type) SetGOTGCTL_SESREQ(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetGOTGCTL_SESREQ() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetGOTGCTL_VBVALIDOVEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetGOTGCTL_VBVALIDOVEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetGOTGCTL_VBVALIDOVVAL(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetGOTGCTL_VBVALIDOVVAL() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetGOTGCTL_AVALIDOVEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetGOTGCTL_AVALIDOVEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetGOTGCTL_AVALIDOVVAL(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGOTGCTL_AVALIDOVVAL() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGOTGCTL_BVALIDOVEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetGOTGCTL_BVALIDOVEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetGOTGCTL_BVALIDOVVAL(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetGOTGCTL_BVALIDOVVAL() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetGOTGCTL_HSTNEGSCS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetGOTGCTL_HSTNEGSCS() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetGOTGCTL_HNPREQ(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetGOTGCTL_HNPREQ() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetGOTGCTL_HSTSETHNPEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetGOTGCTL_HSTSETHNPEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetGOTGCTL_DEVHNPEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetGOTGCTL_DEVHNPEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetGOTGCTL_EHEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetGOTGCTL_EHEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetGOTGCTL_DBNCEFLTRBYPASS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetGOTGCTL_DBNCEFLTRBYPASS() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetGOTGCTL_CONIDSTS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetGOTGCTL_CONIDSTS() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetGOTGCTL_DBNCTIME(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetGOTGCTL_DBNCTIME() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetGOTGCTL_ASESVLD(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetGOTGCTL_ASESVLD() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetGOTGCTL_BSESVLD(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetGOTGCTL_BSESVLD() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetGOTGCTL_OTGVER(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetGOTGCTL_OTGVER() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetGOTGCTL_CURMOD(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetGOTGCTL_CURMOD() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x200000) >> 21
}

// USB.GOTGINT
func (o *USB_Type) SetGOTGINT_SESENDDET(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetGOTGINT_SESENDDET() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetGOTGINT_SESREQSUCSTSCHNG(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetGOTGINT_SESREQSUCSTSCHNG() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetGOTGINT_HSTNEGSUCSTSCHNG(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetGOTGINT_HSTNEGSUCSTSCHNG() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetGOTGINT_HSTNEGDET(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetGOTGINT_HSTNEGDET() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetGOTGINT_ADEVTOUTCHG(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetGOTGINT_ADEVTOUTCHG() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetGOTGINT_DBNCEDONE(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetGOTGINT_DBNCEDONE() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x80000) >> 19
}

// USB.GAHBCFG
func (o *USB_Type) SetGAHBCFG_GLBLLNTRMSK(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetGAHBCFG_GLBLLNTRMSK() uint32 {
	return volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x1
}
func (o *USB_Type) SetGAHBCFG_HBSTLEN(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x1e)|value<<1)
}
func (o *USB_Type) GetGAHBCFG_HBSTLEN() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x1e) >> 1
}
func (o *USB_Type) SetGAHBCFG_DMAEN(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGAHBCFG_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGAHBCFG_NPTXFEMPLVL(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetGAHBCFG_NPTXFEMPLVL() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetGAHBCFG_PTXFEMPLVL(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetGAHBCFG_PTXFEMPLVL() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetGAHBCFG_REMMEMSUPP(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetGAHBCFG_REMMEMSUPP() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetGAHBCFG_NOTIALLDMAWRIT(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetGAHBCFG_NOTIALLDMAWRIT() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetGAHBCFG_AHBSINGLE(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetGAHBCFG_AHBSINGLE() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetGAHBCFG_INVDESCENDIANESS(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetGAHBCFG_INVDESCENDIANESS() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x1000000) >> 24
}

// USB.GUSBCFG
func (o *USB_Type) SetGUSBCFG_TOUTCAL(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x7)|value)
}
func (o *USB_Type) GetGUSBCFG_TOUTCAL() uint32 {
	return volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x7
}
func (o *USB_Type) SetGUSBCFG_PHYIF(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetGUSBCFG_PHYIF() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetGUSBCFG_ULPI_UTMI_SEL(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetGUSBCFG_ULPI_UTMI_SEL() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetGUSBCFG_FSINTF(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGUSBCFG_FSINTF() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGUSBCFG_PHYSEL(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetGUSBCFG_PHYSEL() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetGUSBCFG_SRPCAP(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetGUSBCFG_SRPCAP() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetGUSBCFG_HNPCAP(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetGUSBCFG_HNPCAP() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetGUSBCFG_USBTRDTIM(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x3c00)|value<<10)
}
func (o *USB_Type) GetGUSBCFG_USBTRDTIM() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x3c00) >> 10
}
func (o *USB_Type) SetGUSBCFG_TERMSELDLPULSE(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetGUSBCFG_TERMSELDLPULSE() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetGUSBCFG_TXENDDELAY(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetGUSBCFG_TXENDDELAY() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetGUSBCFG_FORCEHSTMODE(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetGUSBCFG_FORCEHSTMODE() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetGUSBCFG_FORCEDEVMODE(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGUSBCFG_FORCEDEVMODE() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGUSBCFG_CORRUPTTXPKT(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGUSBCFG_CORRUPTTXPKT() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x80000000) >> 31
}

// USB.GRSTCTL
func (o *USB_Type) SetGRSTCTL_CSFTRST(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetGRSTCTL_CSFTRST() uint32 {
	return volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x1
}
func (o *USB_Type) SetGRSTCTL_PIUFSSFTRST(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetGRSTCTL_PIUFSSFTRST() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetGRSTCTL_FRMCNTRRST(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetGRSTCTL_FRMCNTRRST() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetGRSTCTL_RXFFLSH(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetGRSTCTL_RXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetGRSTCTL_TXFFLSH(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGRSTCTL_TXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGRSTCTL_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x7c0)|value<<6)
}
func (o *USB_Type) GetGRSTCTL_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x7c0) >> 6
}
func (o *USB_Type) SetGRSTCTL_DMAREQ(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGRSTCTL_DMAREQ() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGRSTCTL_AHBIDLE(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGRSTCTL_AHBIDLE() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x80000000) >> 31
}

// USB.GINTSTS
func (o *USB_Type) SetGINTSTS_CURMOD_INT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetGINTSTS_CURMOD_INT() uint32 {
	return volatile.LoadUint32(&o.GINTSTS.Reg) & 0x1
}
func (o *USB_Type) SetGINTSTS_MODEMIS(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetGINTSTS_MODEMIS() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetGINTSTS_OTGINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetGINTSTS_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetGINTSTS_SOF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetGINTSTS_SOF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetGINTSTS_RXFLVI(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetGINTSTS_RXFLVI() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetGINTSTS_NPTXFEMP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGINTSTS_NPTXFEMP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGINTSTS_GINNAKEFF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetGINTSTS_GINNAKEFF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetGINTSTS_GOUTNAKEFF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetGINTSTS_GOUTNAKEFF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetGINTSTS_ERLYSUSP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetGINTSTS_ERLYSUSP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetGINTSTS_USBSUSP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetGINTSTS_USBSUSP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetGINTSTS_USBRST(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetGINTSTS_USBRST() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetGINTSTS_ENUMDONE(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetGINTSTS_ENUMDONE() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetGINTSTS_ISOOUTDROP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetGINTSTS_ISOOUTDROP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetGINTSTS_EOPF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetGINTSTS_EOPF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetGINTSTS_EPMIS(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetGINTSTS_EPMIS() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetGINTSTS_IEPINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetGINTSTS_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetGINTSTS_OEPINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetGINTSTS_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetGINTSTS_INCOMPISOIN(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetGINTSTS_INCOMPISOIN() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetGINTSTS_INCOMPIP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetGINTSTS_INCOMPIP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetGINTSTS_FETSUSP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetGINTSTS_FETSUSP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetGINTSTS_RESETDET(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetGINTSTS_RESETDET() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetGINTSTS_PRTLNT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetGINTSTS_PRTLNT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetGINTSTS_HCHLNT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetGINTSTS_HCHLNT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetGINTSTS_PTXFEMP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetGINTSTS_PTXFEMP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetGINTSTS_CONIDSTSCHNG(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetGINTSTS_CONIDSTSCHNG() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetGINTSTS_DISCONNINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetGINTSTS_DISCONNINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetGINTSTS_SESSREQINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGINTSTS_SESSREQINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGINTSTS_WKUPINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGINTSTS_WKUPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x80000000) >> 31
}

// USB.GINTMSK
func (o *USB_Type) SetGINTMSK_MODEMISMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetGINTMSK_MODEMISMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetGINTMSK_OTGINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetGINTMSK_OTGINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetGINTMSK_SOFMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetGINTMSK_SOFMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetGINTMSK_RXFLVIMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetGINTMSK_RXFLVIMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetGINTMSK_NPTXFEMPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGINTMSK_NPTXFEMPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGINTMSK_GINNAKEFFMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetGINTMSK_GINNAKEFFMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetGINTMSK_GOUTNACKEFFMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetGINTMSK_GOUTNACKEFFMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetGINTMSK_ERLYSUSPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetGINTMSK_ERLYSUSPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetGINTMSK_USBSUSPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetGINTMSK_USBSUSPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetGINTMSK_USBRSTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetGINTMSK_USBRSTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetGINTMSK_ENUMDONEMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetGINTMSK_ENUMDONEMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetGINTMSK_ISOOUTDROPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetGINTMSK_ISOOUTDROPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetGINTMSK_EOPFMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetGINTMSK_EOPFMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetGINTMSK_EPMISMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetGINTMSK_EPMISMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetGINTMSK_IEPINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetGINTMSK_IEPINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetGINTMSK_OEPINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetGINTMSK_OEPINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetGINTMSK_INCOMPISOINMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetGINTMSK_INCOMPISOINMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetGINTMSK_INCOMPIPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetGINTMSK_INCOMPIPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetGINTMSK_FETSUSPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetGINTMSK_FETSUSPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetGINTMSK_RESETDETMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetGINTMSK_RESETDETMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetGINTMSK_PRTLNTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetGINTMSK_PRTLNTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetGINTMSK_HCHINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetGINTMSK_HCHINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetGINTMSK_PTXFEMPMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetGINTMSK_PTXFEMPMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetGINTMSK_CONIDSTSCHNGMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetGINTMSK_CONIDSTSCHNGMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetGINTMSK_DISCONNINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetGINTMSK_DISCONNINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetGINTMSK_SESSREQINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGINTMSK_SESSREQINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGINTMSK_WKUPINTMSK(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGINTMSK_WKUPINTMSK() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x80000000) >> 31
}

// USB.GRXSTSR
func (o *USB_Type) SetGRXSTSR_G_CHNUM(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR.Reg, volatile.LoadUint32(&o.GRXSTSR.Reg)&^(0xf)|value)
}
func (o *USB_Type) GetGRXSTSR_G_CHNUM() uint32 {
	return volatile.LoadUint32(&o.GRXSTSR.Reg) & 0xf
}
func (o *USB_Type) SetGRXSTSR_G_BCNT(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR.Reg, volatile.LoadUint32(&o.GRXSTSR.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_Type) GetGRXSTSR_G_BCNT() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR.Reg) & 0x7ff0) >> 4
}
func (o *USB_Type) SetGRXSTSR_G_DPID(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR.Reg, volatile.LoadUint32(&o.GRXSTSR.Reg)&^(0x18000)|value<<15)
}
func (o *USB_Type) GetGRXSTSR_G_DPID() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR.Reg) & 0x18000) >> 15
}
func (o *USB_Type) SetGRXSTSR_G_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR.Reg, volatile.LoadUint32(&o.GRXSTSR.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_Type) GetGRXSTSR_G_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR.Reg) & 0x1e0000) >> 17
}
func (o *USB_Type) SetGRXSTSR_G_FN(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR.Reg, volatile.LoadUint32(&o.GRXSTSR.Reg)&^(0x1e00000)|value<<21)
}
func (o *USB_Type) GetGRXSTSR_G_FN() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR.Reg) & 0x1e00000) >> 21
}

// USB.GRXSTSP
func (o *USB_Type) SetGRXSTSP_CHNUM(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP.Reg, volatile.LoadUint32(&o.GRXSTSP.Reg)&^(0xf)|value)
}
func (o *USB_Type) GetGRXSTSP_CHNUM() uint32 {
	return volatile.LoadUint32(&o.GRXSTSP.Reg) & 0xf
}
func (o *USB_Type) SetGRXSTSP_BCNT(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP.Reg, volatile.LoadUint32(&o.GRXSTSP.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_Type) GetGRXSTSP_BCNT() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP.Reg) & 0x7ff0) >> 4
}
func (o *USB_Type) SetGRXSTSP_DPID(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP.Reg, volatile.LoadUint32(&o.GRXSTSP.Reg)&^(0x18000)|value<<15)
}
func (o *USB_Type) GetGRXSTSP_DPID() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP.Reg) & 0x18000) >> 15
}
func (o *USB_Type) SetGRXSTSP_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP.Reg, volatile.LoadUint32(&o.GRXSTSP.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_Type) GetGRXSTSP_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP.Reg) & 0x1e0000) >> 17
}
func (o *USB_Type) SetGRXSTSP_FN(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP.Reg, volatile.LoadUint32(&o.GRXSTSP.Reg)&^(0x1e00000)|value<<21)
}
func (o *USB_Type) GetGRXSTSP_FN() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP.Reg) & 0x1e00000) >> 21
}

// USB.GRXFSIZ
func (o *USB_Type) SetGRXFSIZ_RXFDEP(value uint32) {
	volatile.StoreUint32(&o.GRXFSIZ.Reg, volatile.LoadUint32(&o.GRXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetGRXFSIZ_RXFDEP() uint32 {
	return volatile.LoadUint32(&o.GRXFSIZ.Reg) & 0xffff
}

// USB.GNPTXFSIZ
func (o *USB_Type) SetGNPTXFSIZ_NPTXFSTADDR(value uint32) {
	volatile.StoreUint32(&o.GNPTXFSIZ.Reg, volatile.LoadUint32(&o.GNPTXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetGNPTXFSIZ_NPTXFSTADDR() uint32 {
	return volatile.LoadUint32(&o.GNPTXFSIZ.Reg) & 0xffff
}
func (o *USB_Type) SetGNPTXFSIZ_NPTXFDEP(value uint32) {
	volatile.StoreUint32(&o.GNPTXFSIZ.Reg, volatile.LoadUint32(&o.GNPTXFSIZ.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetGNPTXFSIZ_NPTXFDEP() uint32 {
	return (volatile.LoadUint32(&o.GNPTXFSIZ.Reg) & 0xffff0000) >> 16
}

// USB.GNPTXSTS
func (o *USB_Type) SetGNPTXSTS_NPTXFSPCAVAIL(value uint32) {
	volatile.StoreUint32(&o.GNPTXSTS.Reg, volatile.LoadUint32(&o.GNPTXSTS.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetGNPTXSTS_NPTXFSPCAVAIL() uint32 {
	return volatile.LoadUint32(&o.GNPTXSTS.Reg) & 0xffff
}
func (o *USB_Type) SetGNPTXSTS_NPTXQSPCAVAIL(value uint32) {
	volatile.StoreUint32(&o.GNPTXSTS.Reg, volatile.LoadUint32(&o.GNPTXSTS.Reg)&^(0xf0000)|value<<16)
}
func (o *USB_Type) GetGNPTXSTS_NPTXQSPCAVAIL() uint32 {
	return (volatile.LoadUint32(&o.GNPTXSTS.Reg) & 0xf0000) >> 16
}
func (o *USB_Type) SetGNPTXSTS_NPTXQTOP(value uint32) {
	volatile.StoreUint32(&o.GNPTXSTS.Reg, volatile.LoadUint32(&o.GNPTXSTS.Reg)&^(0x7f000000)|value<<24)
}
func (o *USB_Type) GetGNPTXSTS_NPTXQTOP() uint32 {
	return (volatile.LoadUint32(&o.GNPTXSTS.Reg) & 0x7f000000) >> 24
}

// USB.GSNPSID
func (o *USB_Type) SetGSNPSID(value uint32) {
	volatile.StoreUint32(&o.GSNPSID.Reg, value)
}
func (o *USB_Type) GetGSNPSID() uint32 {
	return volatile.LoadUint32(&o.GSNPSID.Reg)
}

// USB.GHWCFG1
func (o *USB_Type) SetGHWCFG1(value uint32) {
	volatile.StoreUint32(&o.GHWCFG1.Reg, value)
}
func (o *USB_Type) GetGHWCFG1() uint32 {
	return volatile.LoadUint32(&o.GHWCFG1.Reg)
}

// USB.GHWCFG2
func (o *USB_Type) SetGHWCFG2_OTGMODE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x7)|value)
}
func (o *USB_Type) GetGHWCFG2_OTGMODE() uint32 {
	return volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x7
}
func (o *USB_Type) SetGHWCFG2_OTGARCH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x18)|value<<3)
}
func (o *USB_Type) GetGHWCFG2_OTGARCH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x18) >> 3
}
func (o *USB_Type) SetGHWCFG2_SINGPNT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGHWCFG2_SINGPNT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGHWCFG2_HSPHYTYPE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0xc0)|value<<6)
}
func (o *USB_Type) GetGHWCFG2_HSPHYTYPE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0xc0) >> 6
}
func (o *USB_Type) SetGHWCFG2_FSPHYTYPE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x300)|value<<8)
}
func (o *USB_Type) GetGHWCFG2_FSPHYTYPE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x300) >> 8
}
func (o *USB_Type) SetGHWCFG2_NUMDEVEPS(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x3c00)|value<<10)
}
func (o *USB_Type) GetGHWCFG2_NUMDEVEPS() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x3c00) >> 10
}
func (o *USB_Type) SetGHWCFG2_NUMHSTCHNL(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x3c000)|value<<14)
}
func (o *USB_Type) GetGHWCFG2_NUMHSTCHNL() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x3c000) >> 14
}
func (o *USB_Type) SetGHWCFG2_PERIOSUPPORT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetGHWCFG2_PERIOSUPPORT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetGHWCFG2_DYNFIFOSIZING(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetGHWCFG2_DYNFIFOSIZING() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetGHWCFG2_MULTIPROCINTRPT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetGHWCFG2_MULTIPROCINTRPT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetGHWCFG2_NPTXQDEPTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0xc00000)|value<<22)
}
func (o *USB_Type) GetGHWCFG2_NPTXQDEPTH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0xc00000) >> 22
}
func (o *USB_Type) SetGHWCFG2_PTXQDEPTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x3000000)|value<<24)
}
func (o *USB_Type) GetGHWCFG2_PTXQDEPTH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x3000000) >> 24
}
func (o *USB_Type) SetGHWCFG2_TKNQDEPTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x7c000000)|value<<26)
}
func (o *USB_Type) GetGHWCFG2_TKNQDEPTH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x7c000000) >> 26
}
func (o *USB_Type) SetGHWCFG2_OTG_ENABLE_IC_USB(value uint32) {
	volatile.StoreUint32(&o.GHWCFG2.Reg, volatile.LoadUint32(&o.GHWCFG2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGHWCFG2_OTG_ENABLE_IC_USB() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG2.Reg) & 0x80000000) >> 31
}

// USB.GHWCFG3
func (o *USB_Type) SetGHWCFG3_XFERSIZEWIDTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0xf)|value)
}
func (o *USB_Type) GetGHWCFG3_XFERSIZEWIDTH() uint32 {
	return volatile.LoadUint32(&o.GHWCFG3.Reg) & 0xf
}
func (o *USB_Type) SetGHWCFG3_PKTSIZEWIDTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x70)|value<<4)
}
func (o *USB_Type) GetGHWCFG3_PKTSIZEWIDTH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x70) >> 4
}
func (o *USB_Type) SetGHWCFG3_OTGEN(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetGHWCFG3_OTGEN() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetGHWCFG3_I2CINTSEL(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetGHWCFG3_I2CINTSEL() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetGHWCFG3_VNDCTLSUPT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetGHWCFG3_VNDCTLSUPT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetGHWCFG3_OPTFEATURE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetGHWCFG3_OPTFEATURE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetGHWCFG3_RSTTYPE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetGHWCFG3_RSTTYPE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetGHWCFG3_ADPSUPPORT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetGHWCFG3_ADPSUPPORT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetGHWCFG3_HSICMODE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetGHWCFG3_HSICMODE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetGHWCFG3_BCSUPPORT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetGHWCFG3_BCSUPPORT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetGHWCFG3_LPMMODE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetGHWCFG3_LPMMODE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetGHWCFG3_DFIFODEPTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG3.Reg, volatile.LoadUint32(&o.GHWCFG3.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetGHWCFG3_DFIFODEPTH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG3.Reg) & 0xffff0000) >> 16
}

// USB.GHWCFG4
func (o *USB_Type) SetGHWCFG4_G_NUMDEVPERIOEPS(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0xf)|value)
}
func (o *USB_Type) GetGHWCFG4_G_NUMDEVPERIOEPS() uint32 {
	return volatile.LoadUint32(&o.GHWCFG4.Reg) & 0xf
}
func (o *USB_Type) SetGHWCFG4_G_PARTIALPWRDN(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetGHWCFG4_G_PARTIALPWRDN() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetGHWCFG4_G_AHBFREQ(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetGHWCFG4_G_AHBFREQ() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetGHWCFG4_G_HIBERNATION(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetGHWCFG4_G_HIBERNATION() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetGHWCFG4_G_EXTENDEDHIBERNATION(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetGHWCFG4_G_EXTENDEDHIBERNATION() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetGHWCFG4_G_ACGSUPT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetGHWCFG4_G_ACGSUPT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetGHWCFG4_G_ENHANCEDLPMSUPT(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetGHWCFG4_G_ENHANCEDLPMSUPT() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetGHWCFG4_G_PHYDATAWIDTH(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0xc000)|value<<14)
}
func (o *USB_Type) GetGHWCFG4_G_PHYDATAWIDTH() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0xc000) >> 14
}
func (o *USB_Type) SetGHWCFG4_G_NUMCTLEPS(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0xf0000)|value<<16)
}
func (o *USB_Type) GetGHWCFG4_G_NUMCTLEPS() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0xf0000) >> 16
}
func (o *USB_Type) SetGHWCFG4_G_IDDQFLTR(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetGHWCFG4_G_IDDQFLTR() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetGHWCFG4_G_VBUSVALIDFLTR(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetGHWCFG4_G_VBUSVALIDFLTR() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetGHWCFG4_G_AVALIDFLTR(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetGHWCFG4_G_AVALIDFLTR() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetGHWCFG4_G_BVALIDFLTR(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetGHWCFG4_G_BVALIDFLTR() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetGHWCFG4_G_SESSENDFLTR(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetGHWCFG4_G_SESSENDFLTR() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetGHWCFG4_G_DEDFIFOMODE(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetGHWCFG4_G_DEDFIFOMODE() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetGHWCFG4_G_INEPS(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x3c000000)|value<<26)
}
func (o *USB_Type) GetGHWCFG4_G_INEPS() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x3c000000) >> 26
}
func (o *USB_Type) SetGHWCFG4_G_DESCDMAENABLED(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGHWCFG4_G_DESCDMAENABLED() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGHWCFG4_G_DESCDMA(value uint32) {
	volatile.StoreUint32(&o.GHWCFG4.Reg, volatile.LoadUint32(&o.GHWCFG4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGHWCFG4_G_DESCDMA() uint32 {
	return (volatile.LoadUint32(&o.GHWCFG4.Reg) & 0x80000000) >> 31
}

// USB.GDFIFOCFG
func (o *USB_Type) SetGDFIFOCFG(value uint32) {
	volatile.StoreUint32(&o.GDFIFOCFG.Reg, volatile.LoadUint32(&o.GDFIFOCFG.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetGDFIFOCFG() uint32 {
	return volatile.LoadUint32(&o.GDFIFOCFG.Reg) & 0xffff
}
func (o *USB_Type) SetGDFIFOCFG_EPINFOBASEADDR(value uint32) {
	volatile.StoreUint32(&o.GDFIFOCFG.Reg, volatile.LoadUint32(&o.GDFIFOCFG.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetGDFIFOCFG_EPINFOBASEADDR() uint32 {
	return (volatile.LoadUint32(&o.GDFIFOCFG.Reg) & 0xffff0000) >> 16
}

// USB.HPTXFSIZ
func (o *USB_Type) SetHPTXFSIZ_PTXFSTADDR(value uint32) {
	volatile.StoreUint32(&o.HPTXFSIZ.Reg, volatile.LoadUint32(&o.HPTXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetHPTXFSIZ_PTXFSTADDR() uint32 {
	return volatile.LoadUint32(&o.HPTXFSIZ.Reg) & 0xffff
}
func (o *USB_Type) SetHPTXFSIZ_PTXFSIZE(value uint32) {
	volatile.StoreUint32(&o.HPTXFSIZ.Reg, volatile.LoadUint32(&o.HPTXFSIZ.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetHPTXFSIZ_PTXFSIZE() uint32 {
	return (volatile.LoadUint32(&o.HPTXFSIZ.Reg) & 0xffff0000) >> 16
}

// USB.DIEPTXF1
func (o *USB_Type) SetDIEPTXF1_INEP1TXFSTADDR(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF1.Reg, volatile.LoadUint32(&o.DIEPTXF1.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDIEPTXF1_INEP1TXFSTADDR() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF1.Reg) & 0xffff
}
func (o *USB_Type) SetDIEPTXF1_INEP1TXFDEP(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF1.Reg, volatile.LoadUint32(&o.DIEPTXF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetDIEPTXF1_INEP1TXFDEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF1.Reg) & 0xffff0000) >> 16
}

// USB.DIEPTXF2
func (o *USB_Type) SetDIEPTXF2_INEP2TXFSTADDR(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF2.Reg, volatile.LoadUint32(&o.DIEPTXF2.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDIEPTXF2_INEP2TXFSTADDR() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF2.Reg) & 0xffff
}
func (o *USB_Type) SetDIEPTXF2_INEP2TXFDEP(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF2.Reg, volatile.LoadUint32(&o.DIEPTXF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetDIEPTXF2_INEP2TXFDEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF2.Reg) & 0xffff0000) >> 16
}

// USB.DIEPTXF3
func (o *USB_Type) SetDIEPTXF3_INEP3TXFSTADDR(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF3.Reg, volatile.LoadUint32(&o.DIEPTXF3.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDIEPTXF3_INEP3TXFSTADDR() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF3.Reg) & 0xffff
}
func (o *USB_Type) SetDIEPTXF3_INEP3TXFDEP(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF3.Reg, volatile.LoadUint32(&o.DIEPTXF3.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetDIEPTXF3_INEP3TXFDEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF3.Reg) & 0xffff0000) >> 16
}

// USB.DIEPTXF4
func (o *USB_Type) SetDIEPTXF4_INEP4TXFSTADDR(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF4.Reg, volatile.LoadUint32(&o.DIEPTXF4.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDIEPTXF4_INEP4TXFSTADDR() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF4.Reg) & 0xffff
}
func (o *USB_Type) SetDIEPTXF4_INEP4TXFDEP(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF4.Reg, volatile.LoadUint32(&o.DIEPTXF4.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetDIEPTXF4_INEP4TXFDEP() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF4.Reg) & 0xffff0000) >> 16
}

// USB.HCFG
func (o *USB_Type) SetHCFG_H_FSLSPCLKSEL(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetHCFG_H_FSLSPCLKSEL() uint32 {
	return volatile.LoadUint32(&o.HCFG.Reg) & 0x3
}
func (o *USB_Type) SetHCFG_H_FSLSSUPP(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCFG_H_FSLSSUPP() uint32 {
	return (volatile.LoadUint32(&o.HCFG.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCFG_H_ENA32KHZS(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCFG_H_ENA32KHZS() uint32 {
	return (volatile.LoadUint32(&o.HCFG.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCFG_H_DESCDMA(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetHCFG_H_DESCDMA() uint32 {
	return (volatile.LoadUint32(&o.HCFG.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetHCFG_H_FRLISTEN(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x3000000)|value<<24)
}
func (o *USB_Type) GetHCFG_H_FRLISTEN() uint32 {
	return (volatile.LoadUint32(&o.HCFG.Reg) & 0x3000000) >> 24
}
func (o *USB_Type) SetHCFG_H_PERSCHEDENA(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetHCFG_H_PERSCHEDENA() uint32 {
	return (volatile.LoadUint32(&o.HCFG.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetHCFG_H_MODECHTIMEN(value uint32) {
	volatile.StoreUint32(&o.HCFG.Reg, volatile.LoadUint32(&o.HCFG.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCFG_H_MODECHTIMEN() uint32 {
	return (volatile.LoadUint32(&o.HCFG.Reg) & 0x80000000) >> 31
}

// USB.HFIR
func (o *USB_Type) SetHFIR_FRINT(value uint32) {
	volatile.StoreUint32(&o.HFIR.Reg, volatile.LoadUint32(&o.HFIR.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetHFIR_FRINT() uint32 {
	return volatile.LoadUint32(&o.HFIR.Reg) & 0xffff
}
func (o *USB_Type) SetHFIR_HFIRRLDCTRL(value uint32) {
	volatile.StoreUint32(&o.HFIR.Reg, volatile.LoadUint32(&o.HFIR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetHFIR_HFIRRLDCTRL() uint32 {
	return (volatile.LoadUint32(&o.HFIR.Reg) & 0x10000) >> 16
}

// USB.HFNUM
func (o *USB_Type) SetHFNUM_FRNUM(value uint32) {
	volatile.StoreUint32(&o.HFNUM.Reg, volatile.LoadUint32(&o.HFNUM.Reg)&^(0x3fff)|value)
}
func (o *USB_Type) GetHFNUM_FRNUM() uint32 {
	return volatile.LoadUint32(&o.HFNUM.Reg) & 0x3fff
}
func (o *USB_Type) SetHFNUM_FRREM(value uint32) {
	volatile.StoreUint32(&o.HFNUM.Reg, volatile.LoadUint32(&o.HFNUM.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetHFNUM_FRREM() uint32 {
	return (volatile.LoadUint32(&o.HFNUM.Reg) & 0xffff0000) >> 16
}

// USB.HPTXSTS
func (o *USB_Type) SetHPTXSTS_PTXFSPCAVAIL(value uint32) {
	volatile.StoreUint32(&o.HPTXSTS.Reg, volatile.LoadUint32(&o.HPTXSTS.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetHPTXSTS_PTXFSPCAVAIL() uint32 {
	return volatile.LoadUint32(&o.HPTXSTS.Reg) & 0xffff
}
func (o *USB_Type) SetHPTXSTS_PTXQSPCAVAIL(value uint32) {
	volatile.StoreUint32(&o.HPTXSTS.Reg, volatile.LoadUint32(&o.HPTXSTS.Reg)&^(0x1f0000)|value<<16)
}
func (o *USB_Type) GetHPTXSTS_PTXQSPCAVAIL() uint32 {
	return (volatile.LoadUint32(&o.HPTXSTS.Reg) & 0x1f0000) >> 16
}
func (o *USB_Type) SetHPTXSTS_PTXQTOP(value uint32) {
	volatile.StoreUint32(&o.HPTXSTS.Reg, volatile.LoadUint32(&o.HPTXSTS.Reg)&^(0xff000000)|value<<24)
}
func (o *USB_Type) GetHPTXSTS_PTXQTOP() uint32 {
	return (volatile.LoadUint32(&o.HPTXSTS.Reg) & 0xff000000) >> 24
}

// USB.HAINT
func (o *USB_Type) SetHAINT(value uint32) {
	volatile.StoreUint32(&o.HAINT.Reg, volatile.LoadUint32(&o.HAINT.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetHAINT() uint32 {
	return volatile.LoadUint32(&o.HAINT.Reg) & 0xff
}

// USB.HAINTMSK
func (o *USB_Type) SetHAINTMSK(value uint32) {
	volatile.StoreUint32(&o.HAINTMSK.Reg, volatile.LoadUint32(&o.HAINTMSK.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetHAINTMSK() uint32 {
	return volatile.LoadUint32(&o.HAINTMSK.Reg) & 0xff
}

// USB.HFLBADDR
func (o *USB_Type) SetHFLBADDR(value uint32) {
	volatile.StoreUint32(&o.HFLBADDR.Reg, value)
}
func (o *USB_Type) GetHFLBADDR() uint32 {
	return volatile.LoadUint32(&o.HFLBADDR.Reg)
}

// USB.HPRT
func (o *USB_Type) SetHPRT_PRTCONNSTS(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHPRT_PRTCONNSTS() uint32 {
	return volatile.LoadUint32(&o.HPRT.Reg) & 0x1
}
func (o *USB_Type) SetHPRT_PRTCONNDET(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHPRT_PRTCONNDET() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHPRT_PRTENA(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHPRT_PRTENA() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHPRT_PRTENCHNG(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHPRT_PRTENCHNG() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHPRT_PRTOVRCURRACT(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHPRT_PRTOVRCURRACT() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHPRT_PRTOVRCURRCHNG(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHPRT_PRTOVRCURRCHNG() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHPRT_PRTRES(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHPRT_PRTRES() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHPRT_PRTSUSP(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHPRT_PRTSUSP() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHPRT_PRTRST(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHPRT_PRTRST() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHPRT_PRTLNSTS(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0xc00)|value<<10)
}
func (o *USB_Type) GetHPRT_PRTLNSTS() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0xc00) >> 10
}
func (o *USB_Type) SetHPRT_PRTPWR(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHPRT_PRTPWR() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHPRT_PRTTSTCTL(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x1e000)|value<<13)
}
func (o *USB_Type) GetHPRT_PRTTSTCTL() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x1e000) >> 13
}
func (o *USB_Type) SetHPRT_PRTSPD(value uint32) {
	volatile.StoreUint32(&o.HPRT.Reg, volatile.LoadUint32(&o.HPRT.Reg)&^(0x60000)|value<<17)
}
func (o *USB_Type) GetHPRT_PRTSPD() uint32 {
	return (volatile.LoadUint32(&o.HPRT.Reg) & 0x60000) >> 17
}

// USB.HCCHAR0
func (o *USB_Type) SetHCCHAR0_H_MPS0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR0_H_MPS0() uint32 {
	return volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR0_H_EPNUM0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR0_H_EPNUM0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR0_H_EPDIR0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR0_H_EPDIR0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR0_H_LSPDDEV0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR0_H_LSPDDEV0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR0_H_EPTYPE0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR0_H_EPTYPE0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR0_H_EC0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR0_H_EC0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR0_H_DEVADDR0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR0_H_DEVADDR0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR0_H_ODDFRM0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR0_H_ODDFRM0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR0_H_CHDIS0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR0_H_CHDIS0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR0_H_CHENA0(value uint32) {
	volatile.StoreUint32(&o.HCCHAR0.Reg, volatile.LoadUint32(&o.HCCHAR0.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR0_H_CHENA0() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR0.Reg) & 0x80000000) >> 31
}

// USB.HCINT0
func (o *USB_Type) SetHCINT0_H_XFERCOMPL0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT0_H_XFERCOMPL0() uint32 {
	return volatile.LoadUint32(&o.HCINT0.Reg) & 0x1
}
func (o *USB_Type) SetHCINT0_H_CHHLTD0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT0_H_CHHLTD0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT0_H_AHBERR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT0_H_AHBERR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT0_H_STALL0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT0_H_STALL0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT0_H_NACK0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT0_H_NACK0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT0_H_ACK0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT0_H_ACK0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT0_H_NYET0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT0_H_NYET0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT0_H_XACTERR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT0_H_XACTERR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT0_H_BBLERR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT0_H_BBLERR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT0_H_FRMOVRUN0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT0_H_FRMOVRUN0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT0_H_DATATGLERR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT0_H_DATATGLERR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT0_H_BNAINTR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT0_H_BNAINTR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT0_H_XCS_XACT_ERR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT0_H_XCS_XACT_ERR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT0_H_DESC_LST_ROLLINTR0(value uint32) {
	volatile.StoreUint32(&o.HCINT0.Reg, volatile.LoadUint32(&o.HCINT0.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT0_H_DESC_LST_ROLLINTR0() uint32 {
	return (volatile.LoadUint32(&o.HCINT0.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK0
func (o *USB_Type) SetHCINTMSK0_H_XFERCOMPLMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK0_H_XFERCOMPLMSK0() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK0_H_CHHLTDMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK0_H_CHHLTDMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK0_H_AHBERRMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK0_H_AHBERRMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK0_H_STALLMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK0_H_STALLMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK0_H_NAKMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK0_H_NAKMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK0_H_ACKMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK0_H_ACKMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK0_H_NYETMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK0_H_NYETMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK0_H_XACTERRMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK0_H_XACTERRMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK0_H_BBLERRMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK0_H_BBLERRMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK0_H_FRMOVRUNMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK0_H_FRMOVRUNMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK0_H_DATATGLERRMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK0_H_DATATGLERRMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK0_H_BNAINTRMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK0_H_BNAINTRMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK0_H_DESC_LST_ROLLINTRMSK0(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK0.Reg, volatile.LoadUint32(&o.HCINTMSK0.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK0_H_DESC_LST_ROLLINTRMSK0() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK0.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ0
func (o *USB_Type) SetHCTSIZ0_H_XFERSIZE0(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ0.Reg, volatile.LoadUint32(&o.HCTSIZ0.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ0_H_XFERSIZE0() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ0.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ0_H_PKTCNT0(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ0.Reg, volatile.LoadUint32(&o.HCTSIZ0.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ0_H_PKTCNT0() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ0.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ0_H_PID0(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ0.Reg, volatile.LoadUint32(&o.HCTSIZ0.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ0_H_PID0() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ0.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ0_H_DOPNG0(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ0.Reg, volatile.LoadUint32(&o.HCTSIZ0.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ0_H_DOPNG0() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ0.Reg) & 0x80000000) >> 31
}

// USB.HCDMA0
func (o *USB_Type) SetHCDMA0(value uint32) {
	volatile.StoreUint32(&o.HCDMA0.Reg, value)
}
func (o *USB_Type) GetHCDMA0() uint32 {
	return volatile.LoadUint32(&o.HCDMA0.Reg)
}

// USB.HCDMAB0
func (o *USB_Type) SetHCDMAB0(value uint32) {
	volatile.StoreUint32(&o.HCDMAB0.Reg, value)
}
func (o *USB_Type) GetHCDMAB0() uint32 {
	return volatile.LoadUint32(&o.HCDMAB0.Reg)
}

// USB.HCCHAR1
func (o *USB_Type) SetHCCHAR1_H_MPS1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR1_H_MPS1() uint32 {
	return volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR1_H_EPNUM1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR1_H_EPNUM1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR1_H_EPDIR1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR1_H_EPDIR1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR1_H_LSPDDEV1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR1_H_LSPDDEV1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR1_H_EPTYPE1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR1_H_EPTYPE1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR1_H_EC1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR1_H_EC1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR1_H_DEVADDR1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR1_H_DEVADDR1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR1_H_ODDFRM1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR1_H_ODDFRM1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR1_H_CHDIS1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR1_H_CHDIS1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR1_H_CHENA1(value uint32) {
	volatile.StoreUint32(&o.HCCHAR1.Reg, volatile.LoadUint32(&o.HCCHAR1.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR1_H_CHENA1() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR1.Reg) & 0x80000000) >> 31
}

// USB.HCINT1
func (o *USB_Type) SetHCINT1_H_XFERCOMPL1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT1_H_XFERCOMPL1() uint32 {
	return volatile.LoadUint32(&o.HCINT1.Reg) & 0x1
}
func (o *USB_Type) SetHCINT1_H_CHHLTD1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT1_H_CHHLTD1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT1_H_AHBERR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT1_H_AHBERR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT1_H_STALL1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT1_H_STALL1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT1_H_NACK1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT1_H_NACK1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT1_H_ACK1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT1_H_ACK1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT1_H_NYET1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT1_H_NYET1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT1_H_XACTERR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT1_H_XACTERR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT1_H_BBLERR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT1_H_BBLERR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT1_H_FRMOVRUN1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT1_H_FRMOVRUN1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT1_H_DATATGLERR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT1_H_DATATGLERR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT1_H_BNAINTR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT1_H_BNAINTR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT1_H_XCS_XACT_ERR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT1_H_XCS_XACT_ERR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT1_H_DESC_LST_ROLLINTR1(value uint32) {
	volatile.StoreUint32(&o.HCINT1.Reg, volatile.LoadUint32(&o.HCINT1.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT1_H_DESC_LST_ROLLINTR1() uint32 {
	return (volatile.LoadUint32(&o.HCINT1.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK1
func (o *USB_Type) SetHCINTMSK1_H_XFERCOMPLMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK1_H_XFERCOMPLMSK1() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK1_H_CHHLTDMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK1_H_CHHLTDMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK1_H_AHBERRMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK1_H_AHBERRMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK1_H_STALLMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK1_H_STALLMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK1_H_NAKMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK1_H_NAKMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK1_H_ACKMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK1_H_ACKMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK1_H_NYETMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK1_H_NYETMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK1_H_XACTERRMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK1_H_XACTERRMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK1_H_BBLERRMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK1_H_BBLERRMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK1_H_FRMOVRUNMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK1_H_FRMOVRUNMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK1_H_DATATGLERRMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK1_H_DATATGLERRMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK1_H_BNAINTRMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK1_H_BNAINTRMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK1_H_DESC_LST_ROLLINTRMSK1(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK1.Reg, volatile.LoadUint32(&o.HCINTMSK1.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK1_H_DESC_LST_ROLLINTRMSK1() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK1.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ1
func (o *USB_Type) SetHCTSIZ1_H_XFERSIZE1(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ1.Reg, volatile.LoadUint32(&o.HCTSIZ1.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ1_H_XFERSIZE1() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ1.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ1_H_PKTCNT1(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ1.Reg, volatile.LoadUint32(&o.HCTSIZ1.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ1_H_PKTCNT1() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ1.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ1_H_PID1(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ1.Reg, volatile.LoadUint32(&o.HCTSIZ1.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ1_H_PID1() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ1.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ1_H_DOPNG1(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ1.Reg, volatile.LoadUint32(&o.HCTSIZ1.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ1_H_DOPNG1() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ1.Reg) & 0x80000000) >> 31
}

// USB.HCDMA1
func (o *USB_Type) SetHCDMA1(value uint32) {
	volatile.StoreUint32(&o.HCDMA1.Reg, value)
}
func (o *USB_Type) GetHCDMA1() uint32 {
	return volatile.LoadUint32(&o.HCDMA1.Reg)
}

// USB.HCDMAB1
func (o *USB_Type) SetHCDMAB1(value uint32) {
	volatile.StoreUint32(&o.HCDMAB1.Reg, value)
}
func (o *USB_Type) GetHCDMAB1() uint32 {
	return volatile.LoadUint32(&o.HCDMAB1.Reg)
}

// USB.HCCHAR2
func (o *USB_Type) SetHCCHAR2_H_MPS2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR2_H_MPS2() uint32 {
	return volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR2_H_EPNUM2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR2_H_EPNUM2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR2_H_EPDIR2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR2_H_EPDIR2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR2_H_LSPDDEV2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR2_H_LSPDDEV2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR2_H_EPTYPE2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR2_H_EPTYPE2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR2_H_EC2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR2_H_EC2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR2_H_DEVADDR2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR2_H_DEVADDR2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR2_H_ODDFRM2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR2_H_ODDFRM2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR2_H_CHDIS2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR2_H_CHDIS2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR2_H_CHENA2(value uint32) {
	volatile.StoreUint32(&o.HCCHAR2.Reg, volatile.LoadUint32(&o.HCCHAR2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR2_H_CHENA2() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR2.Reg) & 0x80000000) >> 31
}

// USB.HCINT2
func (o *USB_Type) SetHCINT2_H_XFERCOMPL2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT2_H_XFERCOMPL2() uint32 {
	return volatile.LoadUint32(&o.HCINT2.Reg) & 0x1
}
func (o *USB_Type) SetHCINT2_H_CHHLTD2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT2_H_CHHLTD2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT2_H_AHBERR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT2_H_AHBERR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT2_H_STALL2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT2_H_STALL2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT2_H_NACK2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT2_H_NACK2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT2_H_ACK2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT2_H_ACK2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT2_H_NYET2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT2_H_NYET2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT2_H_XACTERR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT2_H_XACTERR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT2_H_BBLERR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT2_H_BBLERR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT2_H_FRMOVRUN2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT2_H_FRMOVRUN2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT2_H_DATATGLERR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT2_H_DATATGLERR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT2_H_BNAINTR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT2_H_BNAINTR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT2_H_XCS_XACT_ERR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT2_H_XCS_XACT_ERR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT2_H_DESC_LST_ROLLINTR2(value uint32) {
	volatile.StoreUint32(&o.HCINT2.Reg, volatile.LoadUint32(&o.HCINT2.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT2_H_DESC_LST_ROLLINTR2() uint32 {
	return (volatile.LoadUint32(&o.HCINT2.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK2
func (o *USB_Type) SetHCINTMSK2_H_XFERCOMPLMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK2_H_XFERCOMPLMSK2() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK2_H_CHHLTDMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK2_H_CHHLTDMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK2_H_AHBERRMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK2_H_AHBERRMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK2_H_STALLMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK2_H_STALLMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK2_H_NAKMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK2_H_NAKMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK2_H_ACKMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK2_H_ACKMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK2_H_NYETMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK2_H_NYETMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK2_H_XACTERRMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK2_H_XACTERRMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK2_H_BBLERRMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK2_H_BBLERRMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK2_H_FRMOVRUNMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK2_H_FRMOVRUNMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK2_H_DATATGLERRMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK2_H_DATATGLERRMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK2_H_BNAINTRMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK2_H_BNAINTRMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK2_H_DESC_LST_ROLLINTRMSK2(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK2.Reg, volatile.LoadUint32(&o.HCINTMSK2.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK2_H_DESC_LST_ROLLINTRMSK2() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK2.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ2
func (o *USB_Type) SetHCTSIZ2_H_XFERSIZE2(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ2.Reg, volatile.LoadUint32(&o.HCTSIZ2.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ2_H_XFERSIZE2() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ2.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ2_H_PKTCNT2(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ2.Reg, volatile.LoadUint32(&o.HCTSIZ2.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ2_H_PKTCNT2() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ2.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ2_H_PID2(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ2.Reg, volatile.LoadUint32(&o.HCTSIZ2.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ2_H_PID2() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ2.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ2_H_DOPNG2(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ2.Reg, volatile.LoadUint32(&o.HCTSIZ2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ2_H_DOPNG2() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ2.Reg) & 0x80000000) >> 31
}

// USB.HCDMA2
func (o *USB_Type) SetHCDMA2(value uint32) {
	volatile.StoreUint32(&o.HCDMA2.Reg, value)
}
func (o *USB_Type) GetHCDMA2() uint32 {
	return volatile.LoadUint32(&o.HCDMA2.Reg)
}

// USB.HCDMAB2
func (o *USB_Type) SetHCDMAB2(value uint32) {
	volatile.StoreUint32(&o.HCDMAB2.Reg, value)
}
func (o *USB_Type) GetHCDMAB2() uint32 {
	return volatile.LoadUint32(&o.HCDMAB2.Reg)
}

// USB.HCCHAR3
func (o *USB_Type) SetHCCHAR3_H_MPS3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR3_H_MPS3() uint32 {
	return volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR3_H_EPNUM3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR3_H_EPNUM3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR3_H_EPDIR3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR3_H_EPDIR3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR3_H_LSPDDEV3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR3_H_LSPDDEV3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR3_H_EPTYPE3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR3_H_EPTYPE3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR3_H_EC3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR3_H_EC3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR3_H_DEVADDR3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR3_H_DEVADDR3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR3_H_ODDFRM3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR3_H_ODDFRM3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR3_H_CHDIS3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR3_H_CHDIS3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR3_H_CHENA3(value uint32) {
	volatile.StoreUint32(&o.HCCHAR3.Reg, volatile.LoadUint32(&o.HCCHAR3.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR3_H_CHENA3() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR3.Reg) & 0x80000000) >> 31
}

// USB.HCINT3
func (o *USB_Type) SetHCINT3_H_XFERCOMPL3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT3_H_XFERCOMPL3() uint32 {
	return volatile.LoadUint32(&o.HCINT3.Reg) & 0x1
}
func (o *USB_Type) SetHCINT3_H_CHHLTD3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT3_H_CHHLTD3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT3_H_AHBERR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT3_H_AHBERR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT3_H_STALL3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT3_H_STALL3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT3_H_NACK3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT3_H_NACK3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT3_H_ACK3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT3_H_ACK3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT3_H_NYET3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT3_H_NYET3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT3_H_XACTERR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT3_H_XACTERR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT3_H_BBLERR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT3_H_BBLERR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT3_H_FRMOVRUN3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT3_H_FRMOVRUN3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT3_H_DATATGLERR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT3_H_DATATGLERR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT3_H_BNAINTR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT3_H_BNAINTR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT3_H_XCS_XACT_ERR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT3_H_XCS_XACT_ERR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT3_H_DESC_LST_ROLLINTR3(value uint32) {
	volatile.StoreUint32(&o.HCINT3.Reg, volatile.LoadUint32(&o.HCINT3.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT3_H_DESC_LST_ROLLINTR3() uint32 {
	return (volatile.LoadUint32(&o.HCINT3.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK3
func (o *USB_Type) SetHCINTMSK3_H_XFERCOMPLMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK3_H_XFERCOMPLMSK3() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK3_H_CHHLTDMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK3_H_CHHLTDMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK3_H_AHBERRMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK3_H_AHBERRMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK3_H_STALLMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK3_H_STALLMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK3_H_NAKMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK3_H_NAKMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK3_H_ACKMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK3_H_ACKMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK3_H_NYETMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK3_H_NYETMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK3_H_XACTERRMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK3_H_XACTERRMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK3_H_BBLERRMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK3_H_BBLERRMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK3_H_FRMOVRUNMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK3_H_FRMOVRUNMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK3_H_DATATGLERRMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK3_H_DATATGLERRMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK3_H_BNAINTRMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK3_H_BNAINTRMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK3_H_DESC_LST_ROLLINTRMSK3(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK3.Reg, volatile.LoadUint32(&o.HCINTMSK3.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK3_H_DESC_LST_ROLLINTRMSK3() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK3.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ3
func (o *USB_Type) SetHCTSIZ3_H_XFERSIZE3(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ3.Reg, volatile.LoadUint32(&o.HCTSIZ3.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ3_H_XFERSIZE3() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ3.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ3_H_PKTCNT3(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ3.Reg, volatile.LoadUint32(&o.HCTSIZ3.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ3_H_PKTCNT3() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ3.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ3_H_PID3(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ3.Reg, volatile.LoadUint32(&o.HCTSIZ3.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ3_H_PID3() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ3.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ3_H_DOPNG3(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ3.Reg, volatile.LoadUint32(&o.HCTSIZ3.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ3_H_DOPNG3() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ3.Reg) & 0x80000000) >> 31
}

// USB.HCDMA3
func (o *USB_Type) SetHCDMA3(value uint32) {
	volatile.StoreUint32(&o.HCDMA3.Reg, value)
}
func (o *USB_Type) GetHCDMA3() uint32 {
	return volatile.LoadUint32(&o.HCDMA3.Reg)
}

// USB.HCDMAB3
func (o *USB_Type) SetHCDMAB3(value uint32) {
	volatile.StoreUint32(&o.HCDMAB3.Reg, value)
}
func (o *USB_Type) GetHCDMAB3() uint32 {
	return volatile.LoadUint32(&o.HCDMAB3.Reg)
}

// USB.HCCHAR4
func (o *USB_Type) SetHCCHAR4_H_MPS4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR4_H_MPS4() uint32 {
	return volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR4_H_EPNUM4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR4_H_EPNUM4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR4_H_EPDIR4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR4_H_EPDIR4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR4_H_LSPDDEV4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR4_H_LSPDDEV4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR4_H_EPTYPE4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR4_H_EPTYPE4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR4_H_EC4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR4_H_EC4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR4_H_DEVADDR4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR4_H_DEVADDR4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR4_H_ODDFRM4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR4_H_ODDFRM4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR4_H_CHDIS4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR4_H_CHDIS4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR4_H_CHENA4(value uint32) {
	volatile.StoreUint32(&o.HCCHAR4.Reg, volatile.LoadUint32(&o.HCCHAR4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR4_H_CHENA4() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR4.Reg) & 0x80000000) >> 31
}

// USB.HCINT4
func (o *USB_Type) SetHCINT4_H_XFERCOMPL4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT4_H_XFERCOMPL4() uint32 {
	return volatile.LoadUint32(&o.HCINT4.Reg) & 0x1
}
func (o *USB_Type) SetHCINT4_H_CHHLTD4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT4_H_CHHLTD4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT4_H_AHBERR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT4_H_AHBERR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT4_H_STALL4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT4_H_STALL4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT4_H_NACK4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT4_H_NACK4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT4_H_ACK4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT4_H_ACK4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT4_H_NYET4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT4_H_NYET4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT4_H_XACTERR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT4_H_XACTERR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT4_H_BBLERR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT4_H_BBLERR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT4_H_FRMOVRUN4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT4_H_FRMOVRUN4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT4_H_DATATGLERR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT4_H_DATATGLERR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT4_H_BNAINTR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT4_H_BNAINTR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT4_H_XCS_XACT_ERR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT4_H_XCS_XACT_ERR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT4_H_DESC_LST_ROLLINTR4(value uint32) {
	volatile.StoreUint32(&o.HCINT4.Reg, volatile.LoadUint32(&o.HCINT4.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT4_H_DESC_LST_ROLLINTR4() uint32 {
	return (volatile.LoadUint32(&o.HCINT4.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK4
func (o *USB_Type) SetHCINTMSK4_H_XFERCOMPLMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK4_H_XFERCOMPLMSK4() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK4_H_CHHLTDMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK4_H_CHHLTDMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK4_H_AHBERRMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK4_H_AHBERRMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK4_H_STALLMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK4_H_STALLMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK4_H_NAKMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK4_H_NAKMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK4_H_ACKMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK4_H_ACKMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK4_H_NYETMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK4_H_NYETMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK4_H_XACTERRMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK4_H_XACTERRMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK4_H_BBLERRMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK4_H_BBLERRMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK4_H_FRMOVRUNMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK4_H_FRMOVRUNMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK4_H_DATATGLERRMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK4_H_DATATGLERRMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK4_H_BNAINTRMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK4_H_BNAINTRMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK4_H_DESC_LST_ROLLINTRMSK4(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK4.Reg, volatile.LoadUint32(&o.HCINTMSK4.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK4_H_DESC_LST_ROLLINTRMSK4() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK4.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ4
func (o *USB_Type) SetHCTSIZ4_H_XFERSIZE4(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ4.Reg, volatile.LoadUint32(&o.HCTSIZ4.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ4_H_XFERSIZE4() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ4.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ4_H_PKTCNT4(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ4.Reg, volatile.LoadUint32(&o.HCTSIZ4.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ4_H_PKTCNT4() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ4.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ4_H_PID4(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ4.Reg, volatile.LoadUint32(&o.HCTSIZ4.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ4_H_PID4() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ4.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ4_H_DOPNG4(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ4.Reg, volatile.LoadUint32(&o.HCTSIZ4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ4_H_DOPNG4() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ4.Reg) & 0x80000000) >> 31
}

// USB.HCDMA4
func (o *USB_Type) SetHCDMA4(value uint32) {
	volatile.StoreUint32(&o.HCDMA4.Reg, value)
}
func (o *USB_Type) GetHCDMA4() uint32 {
	return volatile.LoadUint32(&o.HCDMA4.Reg)
}

// USB.HCDMAB4
func (o *USB_Type) SetHCDMAB4(value uint32) {
	volatile.StoreUint32(&o.HCDMAB4.Reg, value)
}
func (o *USB_Type) GetHCDMAB4() uint32 {
	return volatile.LoadUint32(&o.HCDMAB4.Reg)
}

// USB.HCCHAR5
func (o *USB_Type) SetHCCHAR5_H_MPS5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR5_H_MPS5() uint32 {
	return volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR5_H_EPNUM5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR5_H_EPNUM5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR5_H_EPDIR5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR5_H_EPDIR5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR5_H_LSPDDEV5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR5_H_LSPDDEV5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR5_H_EPTYPE5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR5_H_EPTYPE5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR5_H_EC5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR5_H_EC5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR5_H_DEVADDR5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR5_H_DEVADDR5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR5_H_ODDFRM5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR5_H_ODDFRM5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR5_H_CHDIS5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR5_H_CHDIS5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR5_H_CHENA5(value uint32) {
	volatile.StoreUint32(&o.HCCHAR5.Reg, volatile.LoadUint32(&o.HCCHAR5.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR5_H_CHENA5() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR5.Reg) & 0x80000000) >> 31
}

// USB.HCINT5
func (o *USB_Type) SetHCINT5_H_XFERCOMPL5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT5_H_XFERCOMPL5() uint32 {
	return volatile.LoadUint32(&o.HCINT5.Reg) & 0x1
}
func (o *USB_Type) SetHCINT5_H_CHHLTD5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT5_H_CHHLTD5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT5_H_AHBERR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT5_H_AHBERR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT5_H_STALL5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT5_H_STALL5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT5_H_NACK5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT5_H_NACK5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT5_H_ACK5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT5_H_ACK5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT5_H_NYET5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT5_H_NYET5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT5_H_XACTERR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT5_H_XACTERR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT5_H_BBLERR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT5_H_BBLERR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT5_H_FRMOVRUN5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT5_H_FRMOVRUN5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT5_H_DATATGLERR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT5_H_DATATGLERR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT5_H_BNAINTR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT5_H_BNAINTR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT5_H_XCS_XACT_ERR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT5_H_XCS_XACT_ERR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT5_H_DESC_LST_ROLLINTR5(value uint32) {
	volatile.StoreUint32(&o.HCINT5.Reg, volatile.LoadUint32(&o.HCINT5.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT5_H_DESC_LST_ROLLINTR5() uint32 {
	return (volatile.LoadUint32(&o.HCINT5.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK5
func (o *USB_Type) SetHCINTMSK5_H_XFERCOMPLMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK5_H_XFERCOMPLMSK5() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK5_H_CHHLTDMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK5_H_CHHLTDMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK5_H_AHBERRMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK5_H_AHBERRMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK5_H_STALLMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK5_H_STALLMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK5_H_NAKMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK5_H_NAKMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK5_H_ACKMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK5_H_ACKMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK5_H_NYETMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK5_H_NYETMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK5_H_XACTERRMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK5_H_XACTERRMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK5_H_BBLERRMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK5_H_BBLERRMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK5_H_FRMOVRUNMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK5_H_FRMOVRUNMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK5_H_DATATGLERRMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK5_H_DATATGLERRMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK5_H_BNAINTRMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK5_H_BNAINTRMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK5_H_DESC_LST_ROLLINTRMSK5(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK5.Reg, volatile.LoadUint32(&o.HCINTMSK5.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK5_H_DESC_LST_ROLLINTRMSK5() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK5.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ5
func (o *USB_Type) SetHCTSIZ5_H_XFERSIZE5(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ5.Reg, volatile.LoadUint32(&o.HCTSIZ5.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ5_H_XFERSIZE5() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ5.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ5_H_PKTCNT5(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ5.Reg, volatile.LoadUint32(&o.HCTSIZ5.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ5_H_PKTCNT5() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ5.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ5_H_PID5(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ5.Reg, volatile.LoadUint32(&o.HCTSIZ5.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ5_H_PID5() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ5.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ5_H_DOPNG5(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ5.Reg, volatile.LoadUint32(&o.HCTSIZ5.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ5_H_DOPNG5() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ5.Reg) & 0x80000000) >> 31
}

// USB.HCDMA5
func (o *USB_Type) SetHCDMA5(value uint32) {
	volatile.StoreUint32(&o.HCDMA5.Reg, value)
}
func (o *USB_Type) GetHCDMA5() uint32 {
	return volatile.LoadUint32(&o.HCDMA5.Reg)
}

// USB.HCDMAB5
func (o *USB_Type) SetHCDMAB5(value uint32) {
	volatile.StoreUint32(&o.HCDMAB5.Reg, value)
}
func (o *USB_Type) GetHCDMAB5() uint32 {
	return volatile.LoadUint32(&o.HCDMAB5.Reg)
}

// USB.HCCHAR6
func (o *USB_Type) SetHCCHAR6_H_MPS6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR6_H_MPS6() uint32 {
	return volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR6_H_EPNUM6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR6_H_EPNUM6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR6_H_EPDIR6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR6_H_EPDIR6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR6_H_LSPDDEV6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR6_H_LSPDDEV6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR6_H_EPTYPE6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR6_H_EPTYPE6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR6_H_EC6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR6_H_EC6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR6_H_DEVADDR6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR6_H_DEVADDR6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR6_H_ODDFRM6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR6_H_ODDFRM6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR6_H_CHDIS6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR6_H_CHDIS6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR6_H_CHENA6(value uint32) {
	volatile.StoreUint32(&o.HCCHAR6.Reg, volatile.LoadUint32(&o.HCCHAR6.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR6_H_CHENA6() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR6.Reg) & 0x80000000) >> 31
}

// USB.HCINT6
func (o *USB_Type) SetHCINT6_H_XFERCOMPL6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT6_H_XFERCOMPL6() uint32 {
	return volatile.LoadUint32(&o.HCINT6.Reg) & 0x1
}
func (o *USB_Type) SetHCINT6_H_CHHLTD6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT6_H_CHHLTD6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT6_H_AHBERR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT6_H_AHBERR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT6_H_STALL6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT6_H_STALL6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT6_H_NACK6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT6_H_NACK6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT6_H_ACK6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT6_H_ACK6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT6_H_NYET6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT6_H_NYET6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT6_H_XACTERR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT6_H_XACTERR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT6_H_BBLERR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT6_H_BBLERR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT6_H_FRMOVRUN6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT6_H_FRMOVRUN6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT6_H_DATATGLERR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT6_H_DATATGLERR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT6_H_BNAINTR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT6_H_BNAINTR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT6_H_XCS_XACT_ERR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT6_H_XCS_XACT_ERR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT6_H_DESC_LST_ROLLINTR6(value uint32) {
	volatile.StoreUint32(&o.HCINT6.Reg, volatile.LoadUint32(&o.HCINT6.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT6_H_DESC_LST_ROLLINTR6() uint32 {
	return (volatile.LoadUint32(&o.HCINT6.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK6
func (o *USB_Type) SetHCINTMSK6_H_XFERCOMPLMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK6_H_XFERCOMPLMSK6() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK6_H_CHHLTDMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK6_H_CHHLTDMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK6_H_AHBERRMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK6_H_AHBERRMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK6_H_STALLMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK6_H_STALLMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK6_H_NAKMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK6_H_NAKMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK6_H_ACKMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK6_H_ACKMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK6_H_NYETMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK6_H_NYETMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK6_H_XACTERRMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK6_H_XACTERRMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK6_H_BBLERRMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK6_H_BBLERRMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK6_H_FRMOVRUNMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK6_H_FRMOVRUNMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK6_H_DATATGLERRMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK6_H_DATATGLERRMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK6_H_BNAINTRMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK6_H_BNAINTRMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK6_H_DESC_LST_ROLLINTRMSK6(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK6.Reg, volatile.LoadUint32(&o.HCINTMSK6.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK6_H_DESC_LST_ROLLINTRMSK6() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK6.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ6
func (o *USB_Type) SetHCTSIZ6_H_XFERSIZE6(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ6.Reg, volatile.LoadUint32(&o.HCTSIZ6.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ6_H_XFERSIZE6() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ6.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ6_H_PKTCNT6(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ6.Reg, volatile.LoadUint32(&o.HCTSIZ6.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ6_H_PKTCNT6() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ6.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ6_H_PID6(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ6.Reg, volatile.LoadUint32(&o.HCTSIZ6.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ6_H_PID6() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ6.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ6_H_DOPNG6(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ6.Reg, volatile.LoadUint32(&o.HCTSIZ6.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ6_H_DOPNG6() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ6.Reg) & 0x80000000) >> 31
}

// USB.HCDMA6
func (o *USB_Type) SetHCDMA6(value uint32) {
	volatile.StoreUint32(&o.HCDMA6.Reg, value)
}
func (o *USB_Type) GetHCDMA6() uint32 {
	return volatile.LoadUint32(&o.HCDMA6.Reg)
}

// USB.HCDMAB6
func (o *USB_Type) SetHCDMAB6(value uint32) {
	volatile.StoreUint32(&o.HCDMAB6.Reg, value)
}
func (o *USB_Type) GetHCDMAB6() uint32 {
	return volatile.LoadUint32(&o.HCDMAB6.Reg)
}

// USB.HCCHAR7
func (o *USB_Type) SetHCCHAR7_H_MPS7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetHCCHAR7_H_MPS7() uint32 {
	return volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x7ff
}
func (o *USB_Type) SetHCCHAR7_H_EPNUM7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x7800)|value<<11)
}
func (o *USB_Type) GetHCCHAR7_H_EPNUM7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x7800) >> 11
}
func (o *USB_Type) SetHCCHAR7_H_EPDIR7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetHCCHAR7_H_EPDIR7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetHCCHAR7_H_LSPDDEV7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetHCCHAR7_H_LSPDDEV7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetHCCHAR7_H_EPTYPE7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetHCCHAR7_H_EPTYPE7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetHCCHAR7_H_EC7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetHCCHAR7_H_EC7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetHCCHAR7_H_DEVADDR7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x1fc00000)|value<<22)
}
func (o *USB_Type) GetHCCHAR7_H_DEVADDR7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x1fc00000) >> 22
}
func (o *USB_Type) SetHCCHAR7_H_ODDFRM7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetHCCHAR7_H_ODDFRM7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetHCCHAR7_H_CHDIS7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetHCCHAR7_H_CHDIS7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetHCCHAR7_H_CHENA7(value uint32) {
	volatile.StoreUint32(&o.HCCHAR7.Reg, volatile.LoadUint32(&o.HCCHAR7.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCCHAR7_H_CHENA7() uint32 {
	return (volatile.LoadUint32(&o.HCCHAR7.Reg) & 0x80000000) >> 31
}

// USB.HCINT7
func (o *USB_Type) SetHCINT7_H_XFERCOMPL7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINT7_H_XFERCOMPL7() uint32 {
	return volatile.LoadUint32(&o.HCINT7.Reg) & 0x1
}
func (o *USB_Type) SetHCINT7_H_CHHLTD7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINT7_H_CHHLTD7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINT7_H_AHBERR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINT7_H_AHBERR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINT7_H_STALL7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINT7_H_STALL7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINT7_H_NACK7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINT7_H_NACK7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINT7_H_ACK7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINT7_H_ACK7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINT7_H_NYET7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINT7_H_NYET7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINT7_H_XACTERR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINT7_H_XACTERR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINT7_H_BBLERR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINT7_H_BBLERR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINT7_H_FRMOVRUN7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINT7_H_FRMOVRUN7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINT7_H_DATATGLERR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINT7_H_DATATGLERR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINT7_H_BNAINTR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINT7_H_BNAINTR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINT7_H_XCS_XACT_ERR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetHCINT7_H_XCS_XACT_ERR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetHCINT7_H_DESC_LST_ROLLINTR7(value uint32) {
	volatile.StoreUint32(&o.HCINT7.Reg, volatile.LoadUint32(&o.HCINT7.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINT7_H_DESC_LST_ROLLINTR7() uint32 {
	return (volatile.LoadUint32(&o.HCINT7.Reg) & 0x2000) >> 13
}

// USB.HCINTMSK7
func (o *USB_Type) SetHCINTMSK7_H_XFERCOMPLMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCINTMSK7_H_XFERCOMPLMSK7() uint32 {
	return volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x1
}
func (o *USB_Type) SetHCINTMSK7_H_CHHLTDMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCINTMSK7_H_CHHLTDMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCINTMSK7_H_AHBERRMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCINTMSK7_H_AHBERRMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCINTMSK7_H_STALLMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetHCINTMSK7_H_STALLMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetHCINTMSK7_H_NAKMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCINTMSK7_H_NAKMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCINTMSK7_H_ACKMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetHCINTMSK7_H_ACKMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetHCINTMSK7_H_NYETMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetHCINTMSK7_H_NYETMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetHCINTMSK7_H_XACTERRMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetHCINTMSK7_H_XACTERRMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetHCINTMSK7_H_BBLERRMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetHCINTMSK7_H_BBLERRMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetHCINTMSK7_H_FRMOVRUNMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetHCINTMSK7_H_FRMOVRUNMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetHCINTMSK7_H_DATATGLERRMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetHCINTMSK7_H_DATATGLERRMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetHCINTMSK7_H_BNAINTRMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetHCINTMSK7_H_BNAINTRMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetHCINTMSK7_H_DESC_LST_ROLLINTRMSK7(value uint32) {
	volatile.StoreUint32(&o.HCINTMSK7.Reg, volatile.LoadUint32(&o.HCINTMSK7.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetHCINTMSK7_H_DESC_LST_ROLLINTRMSK7() uint32 {
	return (volatile.LoadUint32(&o.HCINTMSK7.Reg) & 0x2000) >> 13
}

// USB.HCTSIZ7
func (o *USB_Type) SetHCTSIZ7_H_XFERSIZE7(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ7.Reg, volatile.LoadUint32(&o.HCTSIZ7.Reg)&^(0x7ffff)|value)
}
func (o *USB_Type) GetHCTSIZ7_H_XFERSIZE7() uint32 {
	return volatile.LoadUint32(&o.HCTSIZ7.Reg) & 0x7ffff
}
func (o *USB_Type) SetHCTSIZ7_H_PKTCNT7(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ7.Reg, volatile.LoadUint32(&o.HCTSIZ7.Reg)&^(0x1ff80000)|value<<19)
}
func (o *USB_Type) GetHCTSIZ7_H_PKTCNT7() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ7.Reg) & 0x1ff80000) >> 19
}
func (o *USB_Type) SetHCTSIZ7_H_PID7(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ7.Reg, volatile.LoadUint32(&o.HCTSIZ7.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetHCTSIZ7_H_PID7() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ7.Reg) & 0x60000000) >> 29
}
func (o *USB_Type) SetHCTSIZ7_H_DOPNG7(value uint32) {
	volatile.StoreUint32(&o.HCTSIZ7.Reg, volatile.LoadUint32(&o.HCTSIZ7.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetHCTSIZ7_H_DOPNG7() uint32 {
	return (volatile.LoadUint32(&o.HCTSIZ7.Reg) & 0x80000000) >> 31
}

// USB.HCDMA7
func (o *USB_Type) SetHCDMA7(value uint32) {
	volatile.StoreUint32(&o.HCDMA7.Reg, value)
}
func (o *USB_Type) GetHCDMA7() uint32 {
	return volatile.LoadUint32(&o.HCDMA7.Reg)
}

// USB.HCDMAB7
func (o *USB_Type) SetHCDMAB7(value uint32) {
	volatile.StoreUint32(&o.HCDMAB7.Reg, value)
}
func (o *USB_Type) GetHCDMAB7() uint32 {
	return volatile.LoadUint32(&o.HCDMAB7.Reg)
}

// USB.DCFG
func (o *USB_Type) SetDCFG_NZSTSOUTHSHK(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDCFG_NZSTSOUTHSHK() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDCFG_ENA32KHZSUSP(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDCFG_ENA32KHZSUSP() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDCFG_DEVADDR(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x7f0)|value<<4)
}
func (o *USB_Type) GetDCFG_DEVADDR() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x7f0) >> 4
}
func (o *USB_Type) SetDCFG_PERFRLINT(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x1800)|value<<11)
}
func (o *USB_Type) GetDCFG_PERFRLINT() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x1800) >> 11
}
func (o *USB_Type) SetDCFG_ENDEVOUTNAK(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDCFG_ENDEVOUTNAK() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDCFG_XCVRDLY(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDCFG_XCVRDLY() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDCFG_ERRATICINTMSK(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDCFG_ERRATICINTMSK() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDCFG_EPMISCNT(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x7c0000)|value<<18)
}
func (o *USB_Type) GetDCFG_EPMISCNT() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x7c0000) >> 18
}
func (o *USB_Type) SetDCFG_DESCDMA(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetDCFG_DESCDMA() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetDCFG_PERSCHINTVL(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0x3000000)|value<<24)
}
func (o *USB_Type) GetDCFG_PERSCHINTVL() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0x3000000) >> 24
}
func (o *USB_Type) SetDCFG_RESVALID(value uint32) {
	volatile.StoreUint32(&o.DCFG.Reg, volatile.LoadUint32(&o.DCFG.Reg)&^(0xfc000000)|value<<26)
}
func (o *USB_Type) GetDCFG_RESVALID() uint32 {
	return (volatile.LoadUint32(&o.DCFG.Reg) & 0xfc000000) >> 26
}

// USB.DCTL
func (o *USB_Type) SetDCTL_RMTWKUPSIG(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDCTL_RMTWKUPSIG() uint32 {
	return volatile.LoadUint32(&o.DCTL.Reg) & 0x1
}
func (o *USB_Type) SetDCTL_SFTDISCON(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDCTL_SFTDISCON() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDCTL_GNPINNAKSTS(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDCTL_GNPINNAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDCTL_GOUTNAKSTS(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDCTL_GOUTNAKSTS() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDCTL_TSTCTL(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x70)|value<<4)
}
func (o *USB_Type) GetDCTL_TSTCTL() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x70) >> 4
}
func (o *USB_Type) SetDCTL_SGNPINNAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDCTL_SGNPINNAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDCTL_CGNPINNAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDCTL_CGNPINNAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDCTL_SGOUTNAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDCTL_SGOUTNAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDCTL_CGOUTNAK(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetDCTL_CGOUTNAK() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetDCTL_PWRONPRGDONE(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDCTL_PWRONPRGDONE() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDCTL_GMC(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x6000)|value<<13)
}
func (o *USB_Type) GetDCTL_GMC() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x6000) >> 13
}
func (o *USB_Type) SetDCTL_IGNRFRMNUM(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDCTL_IGNRFRMNUM() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDCTL_NAKONBBLE(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDCTL_NAKONBBLE() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDCTL_ENCOUNTONBNA(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDCTL_ENCOUNTONBNA() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDCTL_DEEPSLEEPBESLREJECT(value uint32) {
	volatile.StoreUint32(&o.DCTL.Reg, volatile.LoadUint32(&o.DCTL.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetDCTL_DEEPSLEEPBESLREJECT() uint32 {
	return (volatile.LoadUint32(&o.DCTL.Reg) & 0x40000) >> 18
}

// USB.DSTS
func (o *USB_Type) SetDSTS_SUSPSTS(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDSTS_SUSPSTS() uint32 {
	return volatile.LoadUint32(&o.DSTS.Reg) & 0x1
}
func (o *USB_Type) SetDSTS_ENUMSPD(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x6)|value<<1)
}
func (o *USB_Type) GetDSTS_ENUMSPD() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0x6) >> 1
}
func (o *USB_Type) SetDSTS_ERRTICERR(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDSTS_ERRTICERR() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDSTS_SOFFN(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0x3fff00)|value<<8)
}
func (o *USB_Type) GetDSTS_SOFFN() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0x3fff00) >> 8
}
func (o *USB_Type) SetDSTS_DEVLNSTS(value uint32) {
	volatile.StoreUint32(&o.DSTS.Reg, volatile.LoadUint32(&o.DSTS.Reg)&^(0xc00000)|value<<22)
}
func (o *USB_Type) GetDSTS_DEVLNSTS() uint32 {
	return (volatile.LoadUint32(&o.DSTS.Reg) & 0xc00000) >> 22
}

// USB.DIEPMSK
func (o *USB_Type) SetDIEPMSK_DI_XFERCOMPLMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPMSK_DI_XFERCOMPLMSK() uint32 {
	return volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x1
}
func (o *USB_Type) SetDIEPMSK_DI_EPDISBLDMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPMSK_DI_EPDISBLDMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPMSK_DI_AHBERMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPMSK_DI_AHBERMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPMSK_TIMEOUTMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPMSK_TIMEOUTMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPMSK_INTKNTXFEMPMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPMSK_INTKNTXFEMPMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPMSK_INTKNEPMISMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPMSK_INTKNEPMISMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPMSK_INEPNAKEFFMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPMSK_INEPNAKEFFMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPMSK_TXFIFOUNDRNMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPMSK_TXFIFOUNDRNMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPMSK_BNAININTRMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPMSK_BNAININTRMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPMSK_DI_NAKMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPMSK.Reg, volatile.LoadUint32(&o.DIEPMSK.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPMSK_DI_NAKMSK() uint32 {
	return (volatile.LoadUint32(&o.DIEPMSK.Reg) & 0x2000) >> 13
}

// USB.DOEPMSK
func (o *USB_Type) SetDOEPMSK_XFERCOMPLMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPMSK_XFERCOMPLMSK() uint32 {
	return volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x1
}
func (o *USB_Type) SetDOEPMSK_EPDISBLDMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPMSK_EPDISBLDMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPMSK_AHBERMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPMSK_AHBERMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPMSK_SETUPMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPMSK_SETUPMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPMSK_OUTTKNEPDISMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPMSK_OUTTKNEPDISMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPMSK_STSPHSERCVDMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPMSK_STSPHSERCVDMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPMSK_BACK2BACKSETUP(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPMSK_BACK2BACKSETUP() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPMSK_OUTPKTERRMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPMSK_OUTPKTERRMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPMSK_BNAOUTINTRMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPMSK_BNAOUTINTRMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPMSK_BBLEERRMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPMSK_BBLEERRMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPMSK_NAKMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPMSK_NAKMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPMSK_NYETMSK(value uint32) {
	volatile.StoreUint32(&o.DOEPMSK.Reg, volatile.LoadUint32(&o.DOEPMSK.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPMSK_NYETMSK() uint32 {
	return (volatile.LoadUint32(&o.DOEPMSK.Reg) & 0x4000) >> 14
}

// USB.DAINT
func (o *USB_Type) SetDAINT_INEPINT0(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDAINT_INEPINT0() uint32 {
	return volatile.LoadUint32(&o.DAINT.Reg) & 0x1
}
func (o *USB_Type) SetDAINT_INEPINT1(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDAINT_INEPINT1() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDAINT_INEPINT2(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDAINT_INEPINT2() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDAINT_INEPINT3(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDAINT_INEPINT3() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDAINT_INEPINT4(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDAINT_INEPINT4() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDAINT_INEPINT5(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDAINT_INEPINT5() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDAINT_INEPINT6(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDAINT_INEPINT6() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDAINT_OUTEPINT0(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDAINT_OUTEPINT0() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDAINT_OUTEPINT1(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDAINT_OUTEPINT1() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDAINT_OUTEPINT2(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetDAINT_OUTEPINT2() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetDAINT_OUTEPINT3(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDAINT_OUTEPINT3() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDAINT_OUTEPINT4(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDAINT_OUTEPINT4() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDAINT_OUTEPINT5(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDAINT_OUTEPINT5() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDAINT_OUTEPINT6(value uint32) {
	volatile.StoreUint32(&o.DAINT.Reg, volatile.LoadUint32(&o.DAINT.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetDAINT_OUTEPINT6() uint32 {
	return (volatile.LoadUint32(&o.DAINT.Reg) & 0x400000) >> 22
}

// USB.DAINTMSK
func (o *USB_Type) SetDAINTMSK_INEPMSK0(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK0() uint32 {
	return volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x1
}
func (o *USB_Type) SetDAINTMSK_INEPMSK1(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK1() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDAINTMSK_INEPMSK2(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK2() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDAINTMSK_INEPMSK3(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK3() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDAINTMSK_INEPMSK4(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK4() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDAINTMSK_INEPMSK5(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK5() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDAINTMSK_INEPMSK6(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDAINTMSK_INEPMSK6() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK0(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK0() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK1(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK1() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK2(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK2() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK3(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK3() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK4(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK4() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK5(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK5() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDAINTMSK_OUTEPMSK6(value uint32) {
	volatile.StoreUint32(&o.DAINTMSK.Reg, volatile.LoadUint32(&o.DAINTMSK.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetDAINTMSK_OUTEPMSK6() uint32 {
	return (volatile.LoadUint32(&o.DAINTMSK.Reg) & 0x400000) >> 22
}

// USB.DVBUSDIS
func (o *USB_Type) SetDVBUSDIS(value uint32) {
	volatile.StoreUint32(&o.DVBUSDIS.Reg, volatile.LoadUint32(&o.DVBUSDIS.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDVBUSDIS() uint32 {
	return volatile.LoadUint32(&o.DVBUSDIS.Reg) & 0xffff
}

// USB.DVBUSPULSE
func (o *USB_Type) SetDVBUSPULSE(value uint32) {
	volatile.StoreUint32(&o.DVBUSPULSE.Reg, volatile.LoadUint32(&o.DVBUSPULSE.Reg)&^(0xfff)|value)
}
func (o *USB_Type) GetDVBUSPULSE() uint32 {
	return volatile.LoadUint32(&o.DVBUSPULSE.Reg) & 0xfff
}

// USB.DTHRCTL
func (o *USB_Type) SetDTHRCTL_NONISOTHREN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDTHRCTL_NONISOTHREN() uint32 {
	return volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x1
}
func (o *USB_Type) SetDTHRCTL_ISOTHREN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDTHRCTL_ISOTHREN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDTHRCTL_TXTHRLEN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x7fc)|value<<2)
}
func (o *USB_Type) GetDTHRCTL_TXTHRLEN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x7fc) >> 2
}
func (o *USB_Type) SetDTHRCTL_AHBTHRRATIO(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x1800)|value<<11)
}
func (o *USB_Type) GetDTHRCTL_AHBTHRRATIO() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x1800) >> 11
}
func (o *USB_Type) SetDTHRCTL_RXTHREN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDTHRCTL_RXTHREN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDTHRCTL_RXTHRLEN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x3fe0000)|value<<17)
}
func (o *USB_Type) GetDTHRCTL_RXTHRLEN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x3fe0000) >> 17
}
func (o *USB_Type) SetDTHRCTL_ARBPRKEN(value uint32) {
	volatile.StoreUint32(&o.DTHRCTL.Reg, volatile.LoadUint32(&o.DTHRCTL.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDTHRCTL_ARBPRKEN() uint32 {
	return (volatile.LoadUint32(&o.DTHRCTL.Reg) & 0x8000000) >> 27
}

// USB.DIEPEMPMSK
func (o *USB_Type) SetDIEPEMPMSK_D_INEPTXFEMPMSK(value uint32) {
	volatile.StoreUint32(&o.DIEPEMPMSK.Reg, volatile.LoadUint32(&o.DIEPEMPMSK.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDIEPEMPMSK_D_INEPTXFEMPMSK() uint32 {
	return volatile.LoadUint32(&o.DIEPEMPMSK.Reg) & 0xffff
}

// USB.DIEPCTL0
func (o *USB_Type) SetDIEPCTL0_D_MPS0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL0_D_MPS0() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL0_D_USBACTEP0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL0_D_USBACTEP0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL0_D_NAKSTS0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL0_D_NAKSTS0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL0_D_EPTYPE0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL0_D_EPTYPE0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL0_D_STALL0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL0_D_STALL0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL0_D_TXFNUM0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL0_D_TXFNUM0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL0_D_CNAK0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL0_D_CNAK0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL0_DI_SNAK0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL0_DI_SNAK0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL0_D_EPDIS0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL0_D_EPDIS0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL0_D_EPENA0(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL0.Reg, volatile.LoadUint32(&o.DIEPCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL0_D_EPENA0() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL0.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT0
func (o *USB_Type) SetDIEPINT0_D_XFERCOMPL0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT0_D_XFERCOMPL0() uint32 {
	return volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT0_D_EPDISBLD0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT0_D_EPDISBLD0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT0_D_AHBERR0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT0_D_AHBERR0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT0_D_TIMEOUT0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT0_D_TIMEOUT0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT0_D_INTKNTXFEMP0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT0_D_INTKNTXFEMP0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT0_D_INTKNEPMIS0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT0_D_INTKNEPMIS0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT0_D_INEPNAKEFF0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT0_D_INEPNAKEFF0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT0_D_TXFEMP0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT0_D_TXFEMP0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT0_D_TXFIFOUNDRN0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT0_D_TXFIFOUNDRN0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT0_D_BNAINTR0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT0_D_BNAINTR0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT0_D_PKTDRPSTS0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT0_D_PKTDRPSTS0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT0_D_BBLEERR0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT0_D_BBLEERR0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT0_D_NAKINTRPT0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT0_D_NAKINTRPT0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT0_D_NYETINTRPT0(value uint32) {
	volatile.StoreUint32(&o.DIEPINT0.Reg, volatile.LoadUint32(&o.DIEPINT0.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT0_D_NYETINTRPT0() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT0.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ0
func (o *USB_Type) SetDIEPTSIZ0_D_XFERSIZE0(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ0.Reg, volatile.LoadUint32(&o.DIEPTSIZ0.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ0_D_XFERSIZE0() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ0.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ0_D_PKTCNT0(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ0.Reg, volatile.LoadUint32(&o.DIEPTSIZ0.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ0_D_PKTCNT0() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ0.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA0
func (o *USB_Type) SetDIEPDMA0(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA0.Reg, value)
}
func (o *USB_Type) GetDIEPDMA0() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA0.Reg)
}

// USB.DTXFSTS0
func (o *USB_Type) SetDTXFSTS0_D_INEPTXFSPCAVAIL0(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS0.Reg, volatile.LoadUint32(&o.DTXFSTS0.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS0_D_INEPTXFSPCAVAIL0() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS0.Reg) & 0xffff
}

// USB.DIEPDMAB0
func (o *USB_Type) SetDIEPDMAB0(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB0.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB0() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB0.Reg)
}

// USB.DIEPCTL1
func (o *USB_Type) SetDIEPCTL1_D_MPS1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL1_D_MPS1() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL1_D_USBACTEP1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL1_D_USBACTEP1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL1_D_NAKSTS1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL1_D_NAKSTS1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL1_D_EPTYPE1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL1_D_EPTYPE1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL1_D_STALL1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL1_D_STALL1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL1_D_TXFNUM1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL1_D_TXFNUM1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL1_D_CNAK1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL1_D_CNAK1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL1_DI_SNAK1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL1_DI_SNAK1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL1_DI_SETD0PID1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDIEPCTL1_DI_SETD0PID1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDIEPCTL1_DI_SETD1PID1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDIEPCTL1_DI_SETD1PID1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDIEPCTL1_D_EPDIS1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL1_D_EPDIS1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL1_D_EPENA1(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL1.Reg, volatile.LoadUint32(&o.DIEPCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL1_D_EPENA1() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL1.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT1
func (o *USB_Type) SetDIEPINT1_D_XFERCOMPL1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT1_D_XFERCOMPL1() uint32 {
	return volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT1_D_EPDISBLD1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT1_D_EPDISBLD1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT1_D_AHBERR1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT1_D_AHBERR1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT1_D_TIMEOUT1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT1_D_TIMEOUT1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT1_D_INTKNTXFEMP1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT1_D_INTKNTXFEMP1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT1_D_INTKNEPMIS1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT1_D_INTKNEPMIS1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT1_D_INEPNAKEFF1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT1_D_INEPNAKEFF1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT1_D_TXFEMP1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT1_D_TXFEMP1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT1_D_TXFIFOUNDRN1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT1_D_TXFIFOUNDRN1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT1_D_BNAINTR1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT1_D_BNAINTR1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT1_D_PKTDRPSTS1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT1_D_PKTDRPSTS1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT1_D_BBLEERR1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT1_D_BBLEERR1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT1_D_NAKINTRPT1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT1_D_NAKINTRPT1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT1_D_NYETINTRPT1(value uint32) {
	volatile.StoreUint32(&o.DIEPINT1.Reg, volatile.LoadUint32(&o.DIEPINT1.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT1_D_NYETINTRPT1() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT1.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ1
func (o *USB_Type) SetDIEPTSIZ1_D_XFERSIZE1(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ1.Reg, volatile.LoadUint32(&o.DIEPTSIZ1.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ1_D_XFERSIZE1() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ1.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ1_D_PKTCNT1(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ1.Reg, volatile.LoadUint32(&o.DIEPTSIZ1.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ1_D_PKTCNT1() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ1.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA1
func (o *USB_Type) SetDIEPDMA1(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA1.Reg, value)
}
func (o *USB_Type) GetDIEPDMA1() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA1.Reg)
}

// USB.DTXFSTS1
func (o *USB_Type) SetDTXFSTS1_D_INEPTXFSPCAVAIL1(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS1.Reg, volatile.LoadUint32(&o.DTXFSTS1.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS1_D_INEPTXFSPCAVAIL1() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS1.Reg) & 0xffff
}

// USB.DIEPDMAB1
func (o *USB_Type) SetDIEPDMAB1(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB1.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB1() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB1.Reg)
}

// USB.DIEPCTL2
func (o *USB_Type) SetDIEPCTL2_D_MPS2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL2_D_MPS2() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL2_D_USBACTEP2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL2_D_USBACTEP2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL2_D_NAKSTS2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL2_D_NAKSTS2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL2_D_EPTYPE2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL2_D_EPTYPE2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL2_D_STALL2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL2_D_STALL2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL2_D_TXFNUM2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL2_D_TXFNUM2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL2_D_CNAK2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL2_D_CNAK2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL2_DI_SNAK2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL2_DI_SNAK2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL2_DI_SETD0PID2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDIEPCTL2_DI_SETD0PID2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDIEPCTL2_DI_SETD1PID2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDIEPCTL2_DI_SETD1PID2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDIEPCTL2_D_EPDIS2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL2_D_EPDIS2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL2_D_EPENA2(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL2.Reg, volatile.LoadUint32(&o.DIEPCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL2_D_EPENA2() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL2.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT2
func (o *USB_Type) SetDIEPINT2_D_XFERCOMPL2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT2_D_XFERCOMPL2() uint32 {
	return volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT2_D_EPDISBLD2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT2_D_EPDISBLD2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT2_D_AHBERR2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT2_D_AHBERR2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT2_D_TIMEOUT2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT2_D_TIMEOUT2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT2_D_INTKNTXFEMP2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT2_D_INTKNTXFEMP2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT2_D_INTKNEPMIS2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT2_D_INTKNEPMIS2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT2_D_INEPNAKEFF2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT2_D_INEPNAKEFF2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT2_D_TXFEMP2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT2_D_TXFEMP2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT2_D_TXFIFOUNDRN2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT2_D_TXFIFOUNDRN2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT2_D_BNAINTR2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT2_D_BNAINTR2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT2_D_PKTDRPSTS2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT2_D_PKTDRPSTS2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT2_D_BBLEERR2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT2_D_BBLEERR2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT2_D_NAKINTRPT2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT2_D_NAKINTRPT2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT2_D_NYETINTRPT2(value uint32) {
	volatile.StoreUint32(&o.DIEPINT2.Reg, volatile.LoadUint32(&o.DIEPINT2.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT2_D_NYETINTRPT2() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT2.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ2
func (o *USB_Type) SetDIEPTSIZ2_D_XFERSIZE2(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ2.Reg, volatile.LoadUint32(&o.DIEPTSIZ2.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ2_D_XFERSIZE2() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ2.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ2_D_PKTCNT2(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ2.Reg, volatile.LoadUint32(&o.DIEPTSIZ2.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ2_D_PKTCNT2() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ2.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA2
func (o *USB_Type) SetDIEPDMA2(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA2.Reg, value)
}
func (o *USB_Type) GetDIEPDMA2() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA2.Reg)
}

// USB.DTXFSTS2
func (o *USB_Type) SetDTXFSTS2_D_INEPTXFSPCAVAIL2(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS2.Reg, volatile.LoadUint32(&o.DTXFSTS2.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS2_D_INEPTXFSPCAVAIL2() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS2.Reg) & 0xffff
}

// USB.DIEPDMAB2
func (o *USB_Type) SetDIEPDMAB2(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB2.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB2() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB2.Reg)
}

// USB.DIEPCTL3
func (o *USB_Type) SetDIEPCTL3_DI_MPS3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL3_DI_MPS3() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL3_DI_USBACTEP3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL3_DI_USBACTEP3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL3_DI_NAKSTS3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL3_DI_NAKSTS3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL3_DI_EPTYPE3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL3_DI_EPTYPE3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL3_DI_STALL3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL3_DI_STALL3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL3_DI_TXFNUM3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL3_DI_TXFNUM3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL3_DI_CNAK3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL3_DI_CNAK3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL3_DI_SNAK3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL3_DI_SNAK3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL3_DI_SETD0PID3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDIEPCTL3_DI_SETD0PID3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDIEPCTL3_DI_SETD1PID3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDIEPCTL3_DI_SETD1PID3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDIEPCTL3_DI_EPDIS3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL3_DI_EPDIS3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL3_DI_EPENA3(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL3.Reg, volatile.LoadUint32(&o.DIEPCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL3_DI_EPENA3() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL3.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT3
func (o *USB_Type) SetDIEPINT3_D_XFERCOMPL3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT3_D_XFERCOMPL3() uint32 {
	return volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT3_D_EPDISBLD3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT3_D_EPDISBLD3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT3_D_AHBERR3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT3_D_AHBERR3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT3_D_TIMEOUT3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT3_D_TIMEOUT3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT3_D_INTKNTXFEMP3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT3_D_INTKNTXFEMP3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT3_D_INTKNEPMIS3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT3_D_INTKNEPMIS3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT3_D_INEPNAKEFF3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT3_D_INEPNAKEFF3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT3_D_TXFEMP3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT3_D_TXFEMP3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT3_D_TXFIFOUNDRN3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT3_D_TXFIFOUNDRN3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT3_D_BNAINTR3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT3_D_BNAINTR3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT3_D_PKTDRPSTS3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT3_D_PKTDRPSTS3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT3_D_BBLEERR3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT3_D_BBLEERR3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT3_D_NAKINTRPT3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT3_D_NAKINTRPT3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT3_D_NYETINTRPT3(value uint32) {
	volatile.StoreUint32(&o.DIEPINT3.Reg, volatile.LoadUint32(&o.DIEPINT3.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT3_D_NYETINTRPT3() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT3.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ3
func (o *USB_Type) SetDIEPTSIZ3_D_XFERSIZE3(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ3.Reg, volatile.LoadUint32(&o.DIEPTSIZ3.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ3_D_XFERSIZE3() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ3.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ3_D_PKTCNT3(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ3.Reg, volatile.LoadUint32(&o.DIEPTSIZ3.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ3_D_PKTCNT3() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ3.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA3
func (o *USB_Type) SetDIEPDMA3(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA3.Reg, value)
}
func (o *USB_Type) GetDIEPDMA3() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA3.Reg)
}

// USB.DTXFSTS3
func (o *USB_Type) SetDTXFSTS3_D_INEPTXFSPCAVAIL3(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS3.Reg, volatile.LoadUint32(&o.DTXFSTS3.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS3_D_INEPTXFSPCAVAIL3() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS3.Reg) & 0xffff
}

// USB.DIEPDMAB3
func (o *USB_Type) SetDIEPDMAB3(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB3.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB3() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB3.Reg)
}

// USB.DIEPCTL4
func (o *USB_Type) SetDIEPCTL4_D_MPS4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL4_D_MPS4() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL4_D_USBACTEP4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL4_D_USBACTEP4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL4_D_NAKSTS4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL4_D_NAKSTS4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL4_D_EPTYPE4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL4_D_EPTYPE4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL4_D_STALL4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL4_D_STALL4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL4_D_TXFNUM4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL4_D_TXFNUM4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL4_D_CNAK4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL4_D_CNAK4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL4_DI_SNAK4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL4_DI_SNAK4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL4_DI_SETD0PID4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDIEPCTL4_DI_SETD0PID4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDIEPCTL4_DI_SETD1PID4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDIEPCTL4_DI_SETD1PID4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDIEPCTL4_D_EPDIS4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL4_D_EPDIS4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL4_D_EPENA4(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL4.Reg, volatile.LoadUint32(&o.DIEPCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL4_D_EPENA4() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL4.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT4
func (o *USB_Type) SetDIEPINT4_D_XFERCOMPL4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT4_D_XFERCOMPL4() uint32 {
	return volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT4_D_EPDISBLD4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT4_D_EPDISBLD4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT4_D_AHBERR4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT4_D_AHBERR4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT4_D_TIMEOUT4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT4_D_TIMEOUT4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT4_D_INTKNTXFEMP4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT4_D_INTKNTXFEMP4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT4_D_INTKNEPMIS4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT4_D_INTKNEPMIS4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT4_D_INEPNAKEFF4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT4_D_INEPNAKEFF4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT4_D_TXFEMP4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT4_D_TXFEMP4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT4_D_TXFIFOUNDRN4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT4_D_TXFIFOUNDRN4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT4_D_BNAINTR4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT4_D_BNAINTR4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT4_D_PKTDRPSTS4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT4_D_PKTDRPSTS4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT4_D_BBLEERR4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT4_D_BBLEERR4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT4_D_NAKINTRPT4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT4_D_NAKINTRPT4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT4_D_NYETINTRPT4(value uint32) {
	volatile.StoreUint32(&o.DIEPINT4.Reg, volatile.LoadUint32(&o.DIEPINT4.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT4_D_NYETINTRPT4() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT4.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ4
func (o *USB_Type) SetDIEPTSIZ4_D_XFERSIZE4(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ4.Reg, volatile.LoadUint32(&o.DIEPTSIZ4.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ4_D_XFERSIZE4() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ4.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ4_D_PKTCNT4(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ4.Reg, volatile.LoadUint32(&o.DIEPTSIZ4.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ4_D_PKTCNT4() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ4.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA4
func (o *USB_Type) SetDIEPDMA4(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA4.Reg, value)
}
func (o *USB_Type) GetDIEPDMA4() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA4.Reg)
}

// USB.DTXFSTS4
func (o *USB_Type) SetDTXFSTS4_D_INEPTXFSPCAVAIL4(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS4.Reg, volatile.LoadUint32(&o.DTXFSTS4.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS4_D_INEPTXFSPCAVAIL4() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS4.Reg) & 0xffff
}

// USB.DIEPDMAB4
func (o *USB_Type) SetDIEPDMAB4(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB4.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB4() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB4.Reg)
}

// USB.DIEPCTL5
func (o *USB_Type) SetDIEPCTL5_DI_MPS5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL5_DI_MPS5() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL5_DI_USBACTEP5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL5_DI_USBACTEP5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL5_DI_NAKSTS5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL5_DI_NAKSTS5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL5_DI_EPTYPE5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL5_DI_EPTYPE5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL5_DI_STALL5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL5_DI_STALL5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL5_DI_TXFNUM5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL5_DI_TXFNUM5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL5_DI_CNAK5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL5_DI_CNAK5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL5_DI_SNAK5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL5_DI_SNAK5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL5_DI_SETD0PID5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDIEPCTL5_DI_SETD0PID5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDIEPCTL5_DI_SETD1PID5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDIEPCTL5_DI_SETD1PID5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDIEPCTL5_DI_EPDIS5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL5_DI_EPDIS5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL5_DI_EPENA5(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL5.Reg, volatile.LoadUint32(&o.DIEPCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL5_DI_EPENA5() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL5.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT5
func (o *USB_Type) SetDIEPINT5_D_XFERCOMPL5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT5_D_XFERCOMPL5() uint32 {
	return volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT5_D_EPDISBLD5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT5_D_EPDISBLD5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT5_D_AHBERR5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT5_D_AHBERR5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT5_D_TIMEOUT5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT5_D_TIMEOUT5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT5_D_INTKNTXFEMP5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT5_D_INTKNTXFEMP5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT5_D_INTKNEPMIS5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT5_D_INTKNEPMIS5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT5_D_INEPNAKEFF5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT5_D_INEPNAKEFF5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT5_D_TXFEMP5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT5_D_TXFEMP5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT5_D_TXFIFOUNDRN5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT5_D_TXFIFOUNDRN5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT5_D_BNAINTR5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT5_D_BNAINTR5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT5_D_PKTDRPSTS5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT5_D_PKTDRPSTS5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT5_D_BBLEERR5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT5_D_BBLEERR5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT5_D_NAKINTRPT5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT5_D_NAKINTRPT5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT5_D_NYETINTRPT5(value uint32) {
	volatile.StoreUint32(&o.DIEPINT5.Reg, volatile.LoadUint32(&o.DIEPINT5.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT5_D_NYETINTRPT5() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT5.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ5
func (o *USB_Type) SetDIEPTSIZ5_D_XFERSIZE5(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ5.Reg, volatile.LoadUint32(&o.DIEPTSIZ5.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ5_D_XFERSIZE5() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ5.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ5_D_PKTCNT5(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ5.Reg, volatile.LoadUint32(&o.DIEPTSIZ5.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ5_D_PKTCNT5() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ5.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA5
func (o *USB_Type) SetDIEPDMA5(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA5.Reg, value)
}
func (o *USB_Type) GetDIEPDMA5() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA5.Reg)
}

// USB.DTXFSTS5
func (o *USB_Type) SetDTXFSTS5_D_INEPTXFSPCAVAIL5(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS5.Reg, volatile.LoadUint32(&o.DTXFSTS5.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS5_D_INEPTXFSPCAVAIL5() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS5.Reg) & 0xffff
}

// USB.DIEPDMAB5
func (o *USB_Type) SetDIEPDMAB5(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB5.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB5() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB5.Reg)
}

// USB.DIEPCTL6
func (o *USB_Type) SetDIEPCTL6_D_MPS6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDIEPCTL6_D_MPS6() uint32 {
	return volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x3
}
func (o *USB_Type) SetDIEPCTL6_D_USBACTEP6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDIEPCTL6_D_USBACTEP6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDIEPCTL6_D_NAKSTS6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDIEPCTL6_D_NAKSTS6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDIEPCTL6_D_EPTYPE6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDIEPCTL6_D_EPTYPE6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDIEPCTL6_D_STALL6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDIEPCTL6_D_STALL6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDIEPCTL6_D_TXFNUM6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x3c00000)|value<<22)
}
func (o *USB_Type) GetDIEPCTL6_D_TXFNUM6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x3c00000) >> 22
}
func (o *USB_Type) SetDIEPCTL6_D_CNAK6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDIEPCTL6_D_CNAK6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDIEPCTL6_DI_SNAK6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDIEPCTL6_DI_SNAK6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDIEPCTL6_DI_SETD0PID6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDIEPCTL6_DI_SETD0PID6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDIEPCTL6_DI_SETD1PID6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDIEPCTL6_DI_SETD1PID6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDIEPCTL6_D_EPDIS6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDIEPCTL6_D_EPDIS6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDIEPCTL6_D_EPENA6(value uint32) {
	volatile.StoreUint32(&o.DIEPCTL6.Reg, volatile.LoadUint32(&o.DIEPCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDIEPCTL6_D_EPENA6() uint32 {
	return (volatile.LoadUint32(&o.DIEPCTL6.Reg) & 0x80000000) >> 31
}

// USB.DIEPINT6
func (o *USB_Type) SetDIEPINT6_D_XFERCOMPL6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDIEPINT6_D_XFERCOMPL6() uint32 {
	return volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x1
}
func (o *USB_Type) SetDIEPINT6_D_EPDISBLD6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDIEPINT6_D_EPDISBLD6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDIEPINT6_D_AHBERR6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDIEPINT6_D_AHBERR6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDIEPINT6_D_TIMEOUT6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDIEPINT6_D_TIMEOUT6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDIEPINT6_D_INTKNTXFEMP6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDIEPINT6_D_INTKNTXFEMP6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDIEPINT6_D_INTKNEPMIS6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDIEPINT6_D_INTKNEPMIS6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDIEPINT6_D_INEPNAKEFF6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDIEPINT6_D_INEPNAKEFF6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDIEPINT6_D_TXFEMP6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDIEPINT6_D_TXFEMP6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDIEPINT6_D_TXFIFOUNDRN6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDIEPINT6_D_TXFIFOUNDRN6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDIEPINT6_D_BNAINTR6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDIEPINT6_D_BNAINTR6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDIEPINT6_D_PKTDRPSTS6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDIEPINT6_D_PKTDRPSTS6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDIEPINT6_D_BBLEERR6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDIEPINT6_D_BBLEERR6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDIEPINT6_D_NAKINTRPT6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDIEPINT6_D_NAKINTRPT6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDIEPINT6_D_NYETINTRPT6(value uint32) {
	volatile.StoreUint32(&o.DIEPINT6.Reg, volatile.LoadUint32(&o.DIEPINT6.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDIEPINT6_D_NYETINTRPT6() uint32 {
	return (volatile.LoadUint32(&o.DIEPINT6.Reg) & 0x4000) >> 14
}

// USB.DIEPTSIZ6
func (o *USB_Type) SetDIEPTSIZ6_D_XFERSIZE6(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ6.Reg, volatile.LoadUint32(&o.DIEPTSIZ6.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDIEPTSIZ6_D_XFERSIZE6() uint32 {
	return volatile.LoadUint32(&o.DIEPTSIZ6.Reg) & 0x7f
}
func (o *USB_Type) SetDIEPTSIZ6_D_PKTCNT6(value uint32) {
	volatile.StoreUint32(&o.DIEPTSIZ6.Reg, volatile.LoadUint32(&o.DIEPTSIZ6.Reg)&^(0x180000)|value<<19)
}
func (o *USB_Type) GetDIEPTSIZ6_D_PKTCNT6() uint32 {
	return (volatile.LoadUint32(&o.DIEPTSIZ6.Reg) & 0x180000) >> 19
}

// USB.DIEPDMA6
func (o *USB_Type) SetDIEPDMA6(value uint32) {
	volatile.StoreUint32(&o.DIEPDMA6.Reg, value)
}
func (o *USB_Type) GetDIEPDMA6() uint32 {
	return volatile.LoadUint32(&o.DIEPDMA6.Reg)
}

// USB.DTXFSTS6
func (o *USB_Type) SetDTXFSTS6_D_INEPTXFSPCAVAIL6(value uint32) {
	volatile.StoreUint32(&o.DTXFSTS6.Reg, volatile.LoadUint32(&o.DTXFSTS6.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetDTXFSTS6_D_INEPTXFSPCAVAIL6() uint32 {
	return volatile.LoadUint32(&o.DTXFSTS6.Reg) & 0xffff
}

// USB.DIEPDMAB6
func (o *USB_Type) SetDIEPDMAB6(value uint32) {
	volatile.StoreUint32(&o.DIEPDMAB6.Reg, value)
}
func (o *USB_Type) GetDIEPDMAB6() uint32 {
	return volatile.LoadUint32(&o.DIEPDMAB6.Reg)
}

// USB.DOEPCTL0
func (o *USB_Type) SetDOEPCTL0_MPS0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetDOEPCTL0_MPS0() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x3
}
func (o *USB_Type) SetDOEPCTL0_USBACTEP0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL0_USBACTEP0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL0_NAKSTS0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL0_NAKSTS0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL0_EPTYPE0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL0_EPTYPE0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL0_SNP0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL0_SNP0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL0_STALL0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL0_STALL0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL0_CNAK0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL0_CNAK0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL0_DO_SNAK0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL0_DO_SNAK0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL0_EPDIS0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL0_EPDIS0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL0_EPENA0(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL0.Reg, volatile.LoadUint32(&o.DOEPCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL0_EPENA0() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL0.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT0
func (o *USB_Type) SetDOEPINT0_XFERCOMPL0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT0_XFERCOMPL0() uint32 {
	return volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT0_EPDISBLD0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT0_EPDISBLD0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT0_AHBERR0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT0_AHBERR0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT0_SETUP0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT0_SETUP0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT0_OUTTKNEPDIS0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT0_OUTTKNEPDIS0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT0_STSPHSERCVD0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT0_STSPHSERCVD0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT0_BACK2BACKSETUP0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT0_BACK2BACKSETUP0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT0_OUTPKTERR0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT0_OUTPKTERR0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT0_BNAINTR0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT0_BNAINTR0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT0_PKTDRPSTS0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT0_PKTDRPSTS0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT0_BBLEERR0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT0_BBLEERR0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT0_NAKINTRPT0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT0_NAKINTRPT0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT0_NYEPINTRPT0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT0_NYEPINTRPT0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT0_STUPPKTRCVD0(value uint32) {
	volatile.StoreUint32(&o.DOEPINT0.Reg, volatile.LoadUint32(&o.DOEPINT0.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT0_STUPPKTRCVD0() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT0.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ0
func (o *USB_Type) SetDOEPTSIZ0_XFERSIZE0(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ0.Reg, volatile.LoadUint32(&o.DOEPTSIZ0.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ0_XFERSIZE0() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ0.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ0_PKTCNT0(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ0.Reg, volatile.LoadUint32(&o.DOEPTSIZ0.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ0_PKTCNT0() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ0.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ0_SUPCNT0(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ0.Reg, volatile.LoadUint32(&o.DOEPTSIZ0.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ0_SUPCNT0() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ0.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA0
func (o *USB_Type) SetDOEPDMA0(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA0.Reg, value)
}
func (o *USB_Type) GetDOEPDMA0() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA0.Reg)
}

// USB.DOEPDMAB0
func (o *USB_Type) SetDOEPDMAB0(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB0.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB0() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB0.Reg)
}

// USB.DOEPCTL1
func (o *USB_Type) SetDOEPCTL1_MPS1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetDOEPCTL1_MPS1() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x7ff
}
func (o *USB_Type) SetDOEPCTL1_USBACTEP1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL1_USBACTEP1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL1_NAKSTS1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL1_NAKSTS1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL1_EPTYPE1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL1_EPTYPE1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL1_SNP1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL1_SNP1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL1_STALL1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL1_STALL1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL1_CNAK1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL1_CNAK1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL1_DO_SNAK1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL1_DO_SNAK1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL1_DO_SETD0PID1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDOEPCTL1_DO_SETD0PID1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDOEPCTL1_DO_SETD1PID1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDOEPCTL1_DO_SETD1PID1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDOEPCTL1_EPDIS1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL1_EPDIS1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL1_EPENA1(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL1.Reg, volatile.LoadUint32(&o.DOEPCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL1_EPENA1() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL1.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT1
func (o *USB_Type) SetDOEPINT1_XFERCOMPL1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT1_XFERCOMPL1() uint32 {
	return volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT1_EPDISBLD1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT1_EPDISBLD1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT1_AHBERR1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT1_AHBERR1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT1_SETUP1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT1_SETUP1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT1_OUTTKNEPDIS1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT1_OUTTKNEPDIS1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT1_STSPHSERCVD1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT1_STSPHSERCVD1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT1_BACK2BACKSETUP1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT1_BACK2BACKSETUP1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT1_OUTPKTERR1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT1_OUTPKTERR1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT1_BNAINTR1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT1_BNAINTR1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT1_PKTDRPSTS1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT1_PKTDRPSTS1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT1_BBLEERR1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT1_BBLEERR1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT1_NAKINTRPT1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT1_NAKINTRPT1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT1_NYEPINTRPT1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT1_NYEPINTRPT1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT1_STUPPKTRCVD1(value uint32) {
	volatile.StoreUint32(&o.DOEPINT1.Reg, volatile.LoadUint32(&o.DOEPINT1.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT1_STUPPKTRCVD1() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT1.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ1
func (o *USB_Type) SetDOEPTSIZ1_XFERSIZE1(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ1.Reg, volatile.LoadUint32(&o.DOEPTSIZ1.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ1_XFERSIZE1() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ1.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ1_PKTCNT1(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ1.Reg, volatile.LoadUint32(&o.DOEPTSIZ1.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ1_PKTCNT1() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ1.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ1_SUPCNT1(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ1.Reg, volatile.LoadUint32(&o.DOEPTSIZ1.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ1_SUPCNT1() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ1.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA1
func (o *USB_Type) SetDOEPDMA1(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA1.Reg, value)
}
func (o *USB_Type) GetDOEPDMA1() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA1.Reg)
}

// USB.DOEPDMAB1
func (o *USB_Type) SetDOEPDMAB1(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB1.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB1() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB1.Reg)
}

// USB.DOEPCTL2
func (o *USB_Type) SetDOEPCTL2_MPS2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetDOEPCTL2_MPS2() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x7ff
}
func (o *USB_Type) SetDOEPCTL2_USBACTEP2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL2_USBACTEP2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL2_NAKSTS2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL2_NAKSTS2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL2_EPTYPE2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL2_EPTYPE2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL2_SNP2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL2_SNP2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL2_STALL2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL2_STALL2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL2_CNAK2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL2_CNAK2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL2_DO_SNAK2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL2_DO_SNAK2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL2_DO_SETD0PID2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDOEPCTL2_DO_SETD0PID2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDOEPCTL2_DO_SETD1PID2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDOEPCTL2_DO_SETD1PID2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDOEPCTL2_EPDIS2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL2_EPDIS2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL2_EPENA2(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL2.Reg, volatile.LoadUint32(&o.DOEPCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL2_EPENA2() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL2.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT2
func (o *USB_Type) SetDOEPINT2_XFERCOMPL2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT2_XFERCOMPL2() uint32 {
	return volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT2_EPDISBLD2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT2_EPDISBLD2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT2_AHBERR2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT2_AHBERR2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT2_SETUP2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT2_SETUP2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT2_OUTTKNEPDIS2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT2_OUTTKNEPDIS2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT2_STSPHSERCVD2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT2_STSPHSERCVD2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT2_BACK2BACKSETUP2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT2_BACK2BACKSETUP2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT2_OUTPKTERR2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT2_OUTPKTERR2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT2_BNAINTR2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT2_BNAINTR2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT2_PKTDRPSTS2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT2_PKTDRPSTS2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT2_BBLEERR2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT2_BBLEERR2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT2_NAKINTRPT2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT2_NAKINTRPT2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT2_NYEPINTRPT2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT2_NYEPINTRPT2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT2_STUPPKTRCVD2(value uint32) {
	volatile.StoreUint32(&o.DOEPINT2.Reg, volatile.LoadUint32(&o.DOEPINT2.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT2_STUPPKTRCVD2() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT2.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ2
func (o *USB_Type) SetDOEPTSIZ2_XFERSIZE2(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ2.Reg, volatile.LoadUint32(&o.DOEPTSIZ2.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ2_XFERSIZE2() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ2.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ2_PKTCNT2(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ2.Reg, volatile.LoadUint32(&o.DOEPTSIZ2.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ2_PKTCNT2() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ2.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ2_SUPCNT2(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ2.Reg, volatile.LoadUint32(&o.DOEPTSIZ2.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ2_SUPCNT2() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ2.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA2
func (o *USB_Type) SetDOEPDMA2(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA2.Reg, value)
}
func (o *USB_Type) GetDOEPDMA2() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA2.Reg)
}

// USB.DOEPDMAB2
func (o *USB_Type) SetDOEPDMAB2(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB2.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB2() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB2.Reg)
}

// USB.DOEPCTL3
func (o *USB_Type) SetDOEPCTL3_MPS3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetDOEPCTL3_MPS3() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x7ff
}
func (o *USB_Type) SetDOEPCTL3_USBACTEP3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL3_USBACTEP3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL3_NAKSTS3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL3_NAKSTS3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL3_EPTYPE3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL3_EPTYPE3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL3_SNP3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL3_SNP3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL3_STALL3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL3_STALL3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL3_CNAK3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL3_CNAK3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL3_DO_SNAK3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL3_DO_SNAK3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL3_DO_SETD0PID3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDOEPCTL3_DO_SETD0PID3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDOEPCTL3_DO_SETD1PID3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDOEPCTL3_DO_SETD1PID3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDOEPCTL3_EPDIS3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL3_EPDIS3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL3_EPENA3(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL3.Reg, volatile.LoadUint32(&o.DOEPCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL3_EPENA3() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL3.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT3
func (o *USB_Type) SetDOEPINT3_XFERCOMPL3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT3_XFERCOMPL3() uint32 {
	return volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT3_EPDISBLD3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT3_EPDISBLD3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT3_AHBERR3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT3_AHBERR3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT3_SETUP3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT3_SETUP3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT3_OUTTKNEPDIS3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT3_OUTTKNEPDIS3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT3_STSPHSERCVD3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT3_STSPHSERCVD3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT3_BACK2BACKSETUP3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT3_BACK2BACKSETUP3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT3_OUTPKTERR3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT3_OUTPKTERR3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT3_BNAINTR3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT3_BNAINTR3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT3_PKTDRPSTS3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT3_PKTDRPSTS3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT3_BBLEERR3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT3_BBLEERR3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT3_NAKINTRPT3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT3_NAKINTRPT3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT3_NYEPINTRPT3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT3_NYEPINTRPT3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT3_STUPPKTRCVD3(value uint32) {
	volatile.StoreUint32(&o.DOEPINT3.Reg, volatile.LoadUint32(&o.DOEPINT3.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT3_STUPPKTRCVD3() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT3.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ3
func (o *USB_Type) SetDOEPTSIZ3_XFERSIZE3(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ3.Reg, volatile.LoadUint32(&o.DOEPTSIZ3.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ3_XFERSIZE3() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ3.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ3_PKTCNT3(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ3.Reg, volatile.LoadUint32(&o.DOEPTSIZ3.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ3_PKTCNT3() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ3.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ3_SUPCNT3(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ3.Reg, volatile.LoadUint32(&o.DOEPTSIZ3.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ3_SUPCNT3() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ3.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA3
func (o *USB_Type) SetDOEPDMA3(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA3.Reg, value)
}
func (o *USB_Type) GetDOEPDMA3() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA3.Reg)
}

// USB.DOEPDMAB3
func (o *USB_Type) SetDOEPDMAB3(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB3.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB3() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB3.Reg)
}

// USB.DOEPCTL4
func (o *USB_Type) SetDOEPCTL4_MPS4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetDOEPCTL4_MPS4() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x7ff
}
func (o *USB_Type) SetDOEPCTL4_USBACTEP4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL4_USBACTEP4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL4_NAKSTS4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL4_NAKSTS4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL4_EPTYPE4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL4_EPTYPE4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL4_SNP4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL4_SNP4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL4_STALL4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL4_STALL4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL4_CNAK4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL4_CNAK4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL4_DO_SNAK4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL4_DO_SNAK4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL4_DO_SETD0PID4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDOEPCTL4_DO_SETD0PID4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDOEPCTL4_DO_SETD1PID4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDOEPCTL4_DO_SETD1PID4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDOEPCTL4_EPDIS4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL4_EPDIS4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL4_EPENA4(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL4.Reg, volatile.LoadUint32(&o.DOEPCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL4_EPENA4() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL4.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT4
func (o *USB_Type) SetDOEPINT4_XFERCOMPL4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT4_XFERCOMPL4() uint32 {
	return volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT4_EPDISBLD4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT4_EPDISBLD4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT4_AHBERR4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT4_AHBERR4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT4_SETUP4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT4_SETUP4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT4_OUTTKNEPDIS4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT4_OUTTKNEPDIS4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT4_STSPHSERCVD4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT4_STSPHSERCVD4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT4_BACK2BACKSETUP4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT4_BACK2BACKSETUP4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT4_OUTPKTERR4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT4_OUTPKTERR4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT4_BNAINTR4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT4_BNAINTR4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT4_PKTDRPSTS4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT4_PKTDRPSTS4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT4_BBLEERR4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT4_BBLEERR4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT4_NAKINTRPT4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT4_NAKINTRPT4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT4_NYEPINTRPT4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT4_NYEPINTRPT4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT4_STUPPKTRCVD4(value uint32) {
	volatile.StoreUint32(&o.DOEPINT4.Reg, volatile.LoadUint32(&o.DOEPINT4.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT4_STUPPKTRCVD4() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT4.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ4
func (o *USB_Type) SetDOEPTSIZ4_XFERSIZE4(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ4.Reg, volatile.LoadUint32(&o.DOEPTSIZ4.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ4_XFERSIZE4() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ4.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ4_PKTCNT4(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ4.Reg, volatile.LoadUint32(&o.DOEPTSIZ4.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ4_PKTCNT4() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ4.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ4_SUPCNT4(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ4.Reg, volatile.LoadUint32(&o.DOEPTSIZ4.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ4_SUPCNT4() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ4.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA4
func (o *USB_Type) SetDOEPDMA4(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA4.Reg, value)
}
func (o *USB_Type) GetDOEPDMA4() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA4.Reg)
}

// USB.DOEPDMAB4
func (o *USB_Type) SetDOEPDMAB4(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB4.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB4() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB4.Reg)
}

// USB.DOEPCTL5
func (o *USB_Type) SetDOEPCTL5_MPS5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetDOEPCTL5_MPS5() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x7ff
}
func (o *USB_Type) SetDOEPCTL5_USBACTEP5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL5_USBACTEP5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL5_NAKSTS5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL5_NAKSTS5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL5_EPTYPE5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL5_EPTYPE5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL5_SNP5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL5_SNP5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL5_STALL5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL5_STALL5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL5_CNAK5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL5_CNAK5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL5_DO_SNAK5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL5_DO_SNAK5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL5_DO_SETD0PID5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDOEPCTL5_DO_SETD0PID5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDOEPCTL5_DO_SETD1PID5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDOEPCTL5_DO_SETD1PID5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDOEPCTL5_EPDIS5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL5_EPDIS5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL5_EPENA5(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL5.Reg, volatile.LoadUint32(&o.DOEPCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL5_EPENA5() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL5.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT5
func (o *USB_Type) SetDOEPINT5_XFERCOMPL5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT5_XFERCOMPL5() uint32 {
	return volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT5_EPDISBLD5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT5_EPDISBLD5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT5_AHBERR5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT5_AHBERR5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT5_SETUP5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT5_SETUP5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT5_OUTTKNEPDIS5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT5_OUTTKNEPDIS5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT5_STSPHSERCVD5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT5_STSPHSERCVD5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT5_BACK2BACKSETUP5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT5_BACK2BACKSETUP5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT5_OUTPKTERR5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT5_OUTPKTERR5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT5_BNAINTR5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT5_BNAINTR5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT5_PKTDRPSTS5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT5_PKTDRPSTS5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT5_BBLEERR5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT5_BBLEERR5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT5_NAKINTRPT5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT5_NAKINTRPT5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT5_NYEPINTRPT5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT5_NYEPINTRPT5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT5_STUPPKTRCVD5(value uint32) {
	volatile.StoreUint32(&o.DOEPINT5.Reg, volatile.LoadUint32(&o.DOEPINT5.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT5_STUPPKTRCVD5() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT5.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ5
func (o *USB_Type) SetDOEPTSIZ5_XFERSIZE5(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ5.Reg, volatile.LoadUint32(&o.DOEPTSIZ5.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ5_XFERSIZE5() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ5.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ5_PKTCNT5(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ5.Reg, volatile.LoadUint32(&o.DOEPTSIZ5.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ5_PKTCNT5() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ5.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ5_SUPCNT5(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ5.Reg, volatile.LoadUint32(&o.DOEPTSIZ5.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ5_SUPCNT5() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ5.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA5
func (o *USB_Type) SetDOEPDMA5(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA5.Reg, value)
}
func (o *USB_Type) GetDOEPDMA5() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA5.Reg)
}

// USB.DOEPDMAB5
func (o *USB_Type) SetDOEPDMAB5(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB5.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB5() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB5.Reg)
}

// USB.DOEPCTL6
func (o *USB_Type) SetDOEPCTL6_MPS6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x7ff)|value)
}
func (o *USB_Type) GetDOEPCTL6_MPS6() uint32 {
	return volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x7ff
}
func (o *USB_Type) SetDOEPCTL6_USBACTEP6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPCTL6_USBACTEP6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDOEPCTL6_NAKSTS6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDOEPCTL6_NAKSTS6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDOEPCTL6_EPTYPE6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetDOEPCTL6_EPTYPE6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetDOEPCTL6_SNP6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDOEPCTL6_SNP6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDOEPCTL6_STALL6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDOEPCTL6_STALL6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDOEPCTL6_CNAK6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDOEPCTL6_CNAK6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDOEPCTL6_DO_SNAK6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDOEPCTL6_DO_SNAK6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDOEPCTL6_DO_SETD0PID6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDOEPCTL6_DO_SETD0PID6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDOEPCTL6_DO_SETD1PID6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDOEPCTL6_DO_SETD1PID6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDOEPCTL6_EPDIS6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDOEPCTL6_EPDIS6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDOEPCTL6_EPENA6(value uint32) {
	volatile.StoreUint32(&o.DOEPCTL6.Reg, volatile.LoadUint32(&o.DOEPCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDOEPCTL6_EPENA6() uint32 {
	return (volatile.LoadUint32(&o.DOEPCTL6.Reg) & 0x80000000) >> 31
}

// USB.DOEPINT6
func (o *USB_Type) SetDOEPINT6_XFERCOMPL6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDOEPINT6_XFERCOMPL6() uint32 {
	return volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x1
}
func (o *USB_Type) SetDOEPINT6_EPDISBLD6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDOEPINT6_EPDISBLD6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDOEPINT6_AHBERR6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDOEPINT6_AHBERR6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDOEPINT6_SETUP6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDOEPINT6_SETUP6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDOEPINT6_OUTTKNEPDIS6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDOEPINT6_OUTTKNEPDIS6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDOEPINT6_STSPHSERCVD6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDOEPINT6_STSPHSERCVD6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDOEPINT6_BACK2BACKSETUP6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDOEPINT6_BACK2BACKSETUP6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDOEPINT6_OUTPKTERR6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDOEPINT6_OUTPKTERR6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDOEPINT6_BNAINTR6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDOEPINT6_BNAINTR6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDOEPINT6_PKTDRPSTS6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDOEPINT6_PKTDRPSTS6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDOEPINT6_BBLEERR6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDOEPINT6_BBLEERR6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDOEPINT6_NAKINTRPT6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDOEPINT6_NAKINTRPT6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDOEPINT6_NYEPINTRPT6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDOEPINT6_NYEPINTRPT6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDOEPINT6_STUPPKTRCVD6(value uint32) {
	volatile.StoreUint32(&o.DOEPINT6.Reg, volatile.LoadUint32(&o.DOEPINT6.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDOEPINT6_STUPPKTRCVD6() uint32 {
	return (volatile.LoadUint32(&o.DOEPINT6.Reg) & 0x8000) >> 15
}

// USB.DOEPTSIZ6
func (o *USB_Type) SetDOEPTSIZ6_XFERSIZE6(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ6.Reg, volatile.LoadUint32(&o.DOEPTSIZ6.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetDOEPTSIZ6_XFERSIZE6() uint32 {
	return volatile.LoadUint32(&o.DOEPTSIZ6.Reg) & 0x7f
}
func (o *USB_Type) SetDOEPTSIZ6_PKTCNT6(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ6.Reg, volatile.LoadUint32(&o.DOEPTSIZ6.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDOEPTSIZ6_PKTCNT6() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ6.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDOEPTSIZ6_SUPCNT6(value uint32) {
	volatile.StoreUint32(&o.DOEPTSIZ6.Reg, volatile.LoadUint32(&o.DOEPTSIZ6.Reg)&^(0x60000000)|value<<29)
}
func (o *USB_Type) GetDOEPTSIZ6_SUPCNT6() uint32 {
	return (volatile.LoadUint32(&o.DOEPTSIZ6.Reg) & 0x60000000) >> 29
}

// USB.DOEPDMA6
func (o *USB_Type) SetDOEPDMA6(value uint32) {
	volatile.StoreUint32(&o.DOEPDMA6.Reg, value)
}
func (o *USB_Type) GetDOEPDMA6() uint32 {
	return volatile.LoadUint32(&o.DOEPDMA6.Reg)
}

// USB.DOEPDMAB6
func (o *USB_Type) SetDOEPDMAB6(value uint32) {
	volatile.StoreUint32(&o.DOEPDMAB6.Reg, value)
}
func (o *USB_Type) GetDOEPDMAB6() uint32 {
	return volatile.LoadUint32(&o.DOEPDMAB6.Reg)
}

// USB.PCGCCTL
func (o *USB_Type) SetPCGCCTL_STOPPCLK(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetPCGCCTL_STOPPCLK() uint32 {
	return volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x1
}
func (o *USB_Type) SetPCGCCTL_GATEHCLK(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetPCGCCTL_GATEHCLK() uint32 {
	return (volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetPCGCCTL_PWRCLMP(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetPCGCCTL_PWRCLMP() uint32 {
	return (volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetPCGCCTL_RSTPDWNMODULE(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetPCGCCTL_RSTPDWNMODULE() uint32 {
	return (volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetPCGCCTL_PHYSLEEP(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetPCGCCTL_PHYSLEEP() uint32 {
	return (volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetPCGCCTL_L1SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetPCGCCTL_L1SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetPCGCCTL_RESETAFTERSUSP(value uint32) {
	volatile.StoreUint32(&o.PCGCCTL.Reg, volatile.LoadUint32(&o.PCGCCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetPCGCCTL_RESETAFTERSUSP() uint32 {
	return (volatile.LoadUint32(&o.PCGCCTL.Reg) & 0x100) >> 8
}

// USB_WRAP Peripheral
type USB_WRAP_Type struct {
	OTG_CONF  volatile.Register32 // 0x0
	TEST_CONF volatile.Register32 // 0x4
	_         [1012]byte
	DATE      volatile.Register32 // 0x3FC
}

// USB_WRAP.OTG_CONF: USB OTG Wrapper Configure Register
func (o *USB_WRAP_Type) SetOTG_CONF_SRP_SESSEND_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x1)|value)
}
func (o *USB_WRAP_Type) GetOTG_CONF_SRP_SESSEND_OVERRIDE() uint32 {
	return volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x1
}
func (o *USB_WRAP_Type) SetOTG_CONF_SRP_SESSEND_VALUE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x2)|value<<1)
}
func (o *USB_WRAP_Type) GetOTG_CONF_SRP_SESSEND_VALUE() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x2) >> 1
}
func (o *USB_WRAP_Type) SetOTG_CONF_PHY_SEL(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x4)|value<<2)
}
func (o *USB_WRAP_Type) GetOTG_CONF_PHY_SEL() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x4) >> 2
}
func (o *USB_WRAP_Type) SetOTG_CONF_DFIFO_FORCE_PD(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x8)|value<<3)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DFIFO_FORCE_PD() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x8) >> 3
}
func (o *USB_WRAP_Type) SetOTG_CONF_DBNCE_FLTR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x10)|value<<4)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DBNCE_FLTR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x10) >> 4
}
func (o *USB_WRAP_Type) SetOTG_CONF_EXCHG_PINS_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x20)|value<<5)
}
func (o *USB_WRAP_Type) GetOTG_CONF_EXCHG_PINS_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x20) >> 5
}
func (o *USB_WRAP_Type) SetOTG_CONF_EXCHG_PINS(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x40)|value<<6)
}
func (o *USB_WRAP_Type) GetOTG_CONF_EXCHG_PINS() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x40) >> 6
}
func (o *USB_WRAP_Type) SetOTG_CONF_VREFH(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x180)|value<<7)
}
func (o *USB_WRAP_Type) GetOTG_CONF_VREFH() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x180) >> 7
}
func (o *USB_WRAP_Type) SetOTG_CONF_VREFL(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x600)|value<<9)
}
func (o *USB_WRAP_Type) GetOTG_CONF_VREFL() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x600) >> 9
}
func (o *USB_WRAP_Type) SetOTG_CONF_VREF_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x800)|value<<11)
}
func (o *USB_WRAP_Type) GetOTG_CONF_VREF_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x800) >> 11
}
func (o *USB_WRAP_Type) SetOTG_CONF_PAD_PULL_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *USB_WRAP_Type) GetOTG_CONF_PAD_PULL_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x1000) >> 12
}
func (o *USB_WRAP_Type) SetOTG_CONF_DP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x2000)|value<<13)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x2000) >> 13
}
func (o *USB_WRAP_Type) SetOTG_CONF_DP_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x4000)|value<<14)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DP_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x4000) >> 14
}
func (o *USB_WRAP_Type) SetOTG_CONF_DM_PULLUP(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x8000)|value<<15)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DM_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x8000) >> 15
}
func (o *USB_WRAP_Type) SetOTG_CONF_DM_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x10000)|value<<16)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DM_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x10000) >> 16
}
func (o *USB_WRAP_Type) SetOTG_CONF_PULLUP_VALUE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x20000)|value<<17)
}
func (o *USB_WRAP_Type) GetOTG_CONF_PULLUP_VALUE() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x20000) >> 17
}
func (o *USB_WRAP_Type) SetOTG_CONF_USB_PAD_ENABLE(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x40000)|value<<18)
}
func (o *USB_WRAP_Type) GetOTG_CONF_USB_PAD_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x40000) >> 18
}
func (o *USB_WRAP_Type) SetOTG_CONF_AHB_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x80000)|value<<19)
}
func (o *USB_WRAP_Type) GetOTG_CONF_AHB_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x80000) >> 19
}
func (o *USB_WRAP_Type) SetOTG_CONF_PHY_CLK_FORCE_ON(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x100000)|value<<20)
}
func (o *USB_WRAP_Type) GetOTG_CONF_PHY_CLK_FORCE_ON() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x100000) >> 20
}
func (o *USB_WRAP_Type) SetOTG_CONF_PHY_TX_EDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x200000)|value<<21)
}
func (o *USB_WRAP_Type) GetOTG_CONF_PHY_TX_EDGE_SEL() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x200000) >> 21
}
func (o *USB_WRAP_Type) SetOTG_CONF_DFIFO_FORCE_PU(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x400000)|value<<22)
}
func (o *USB_WRAP_Type) GetOTG_CONF_DFIFO_FORCE_PU() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x400000) >> 22
}
func (o *USB_WRAP_Type) SetOTG_CONF_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.OTG_CONF.Reg, volatile.LoadUint32(&o.OTG_CONF.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_WRAP_Type) GetOTG_CONF_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.OTG_CONF.Reg) & 0x80000000) >> 31
}

// USB_WRAP.TEST_CONF: USB Internal PHY Testing Register
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_ENABLE(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x1)|value)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_ENABLE() uint32 {
	return volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x1
}
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_USB_OE(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x2)|value<<1)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_USB_OE() uint32 {
	return (volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x2) >> 1
}
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_TX_DP(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x4)|value<<2)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_TX_DP() uint32 {
	return (volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x4) >> 2
}
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_TX_DM(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x8)|value<<3)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_TX_DM() uint32 {
	return (volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x8) >> 3
}
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_RX_RCV(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x10)|value<<4)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_RX_RCV() uint32 {
	return (volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x10) >> 4
}
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_RX_DP(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x20)|value<<5)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_RX_DP() uint32 {
	return (volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x20) >> 5
}
func (o *USB_WRAP_Type) SetTEST_CONF_TEST_RX_DM(value uint32) {
	volatile.StoreUint32(&o.TEST_CONF.Reg, volatile.LoadUint32(&o.TEST_CONF.Reg)&^(0x40)|value<<6)
}
func (o *USB_WRAP_Type) GetTEST_CONF_TEST_RX_DM() uint32 {
	return (volatile.LoadUint32(&o.TEST_CONF.Reg) & 0x40) >> 6
}

// USB_WRAP.DATE: Version Control Register
func (o *USB_WRAP_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, value)
}
func (o *USB_WRAP_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg)
}

// XTS-AES-128 Flash Encryption
type XTS_AES_Type struct {
	_                [256]byte
	PLAIN_0          volatile.Register32 // 0x100
	PLAIN_1          volatile.Register32 // 0x104
	PLAIN_2          volatile.Register32 // 0x108
	PLAIN_3          volatile.Register32 // 0x10C
	PLAIN_4          volatile.Register32 // 0x110
	PLAIN_5          volatile.Register32 // 0x114
	PLAIN_6          volatile.Register32 // 0x118
	PLAIN_7          volatile.Register32 // 0x11C
	PLAIN_8          volatile.Register32 // 0x120
	PLAIN_9          volatile.Register32 // 0x124
	PLAIN_10         volatile.Register32 // 0x128
	PLAIN_11         volatile.Register32 // 0x12C
	PLAIN_12         volatile.Register32 // 0x130
	PLAIN_13         volatile.Register32 // 0x134
	PLAIN_14         volatile.Register32 // 0x138
	PLAIN_15         volatile.Register32 // 0x13C
	LINESIZE         volatile.Register32 // 0x140
	DESTINATION      volatile.Register32 // 0x144
	PHYSICAL_ADDRESS volatile.Register32 // 0x148
	TRIGGER          volatile.Register32 // 0x14C
	RELEASE          volatile.Register32 // 0x150
	DESTROY          volatile.Register32 // 0x154
	STATE            volatile.Register32 // 0x158
	DATE             volatile.Register32 // 0x15C
}

// XTS_AES.PLAIN_0: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_0(value uint32) {
	volatile.StoreUint32(&o.PLAIN_0.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_0() uint32 {
	return volatile.LoadUint32(&o.PLAIN_0.Reg)
}

// XTS_AES.PLAIN_1: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_1(value uint32) {
	volatile.StoreUint32(&o.PLAIN_1.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_1() uint32 {
	return volatile.LoadUint32(&o.PLAIN_1.Reg)
}

// XTS_AES.PLAIN_2: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_2(value uint32) {
	volatile.StoreUint32(&o.PLAIN_2.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_2() uint32 {
	return volatile.LoadUint32(&o.PLAIN_2.Reg)
}

// XTS_AES.PLAIN_3: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_3(value uint32) {
	volatile.StoreUint32(&o.PLAIN_3.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_3() uint32 {
	return volatile.LoadUint32(&o.PLAIN_3.Reg)
}

// XTS_AES.PLAIN_4: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_4(value uint32) {
	volatile.StoreUint32(&o.PLAIN_4.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_4() uint32 {
	return volatile.LoadUint32(&o.PLAIN_4.Reg)
}

// XTS_AES.PLAIN_5: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_5(value uint32) {
	volatile.StoreUint32(&o.PLAIN_5.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_5() uint32 {
	return volatile.LoadUint32(&o.PLAIN_5.Reg)
}

// XTS_AES.PLAIN_6: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_6(value uint32) {
	volatile.StoreUint32(&o.PLAIN_6.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_6() uint32 {
	return volatile.LoadUint32(&o.PLAIN_6.Reg)
}

// XTS_AES.PLAIN_7: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_7(value uint32) {
	volatile.StoreUint32(&o.PLAIN_7.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_7() uint32 {
	return volatile.LoadUint32(&o.PLAIN_7.Reg)
}

// XTS_AES.PLAIN_8: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_8(value uint32) {
	volatile.StoreUint32(&o.PLAIN_8.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_8() uint32 {
	return volatile.LoadUint32(&o.PLAIN_8.Reg)
}

// XTS_AES.PLAIN_9: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_9(value uint32) {
	volatile.StoreUint32(&o.PLAIN_9.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_9() uint32 {
	return volatile.LoadUint32(&o.PLAIN_9.Reg)
}

// XTS_AES.PLAIN_10: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_10(value uint32) {
	volatile.StoreUint32(&o.PLAIN_10.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_10() uint32 {
	return volatile.LoadUint32(&o.PLAIN_10.Reg)
}

// XTS_AES.PLAIN_11: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_11(value uint32) {
	volatile.StoreUint32(&o.PLAIN_11.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_11() uint32 {
	return volatile.LoadUint32(&o.PLAIN_11.Reg)
}

// XTS_AES.PLAIN_12: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_12(value uint32) {
	volatile.StoreUint32(&o.PLAIN_12.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_12() uint32 {
	return volatile.LoadUint32(&o.PLAIN_12.Reg)
}

// XTS_AES.PLAIN_13: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_13(value uint32) {
	volatile.StoreUint32(&o.PLAIN_13.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_13() uint32 {
	return volatile.LoadUint32(&o.PLAIN_13.Reg)
}

// XTS_AES.PLAIN_14: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_14(value uint32) {
	volatile.StoreUint32(&o.PLAIN_14.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_14() uint32 {
	return volatile.LoadUint32(&o.PLAIN_14.Reg)
}

// XTS_AES.PLAIN_15: Plaintext register %s
func (o *XTS_AES_Type) SetPLAIN_15(value uint32) {
	volatile.StoreUint32(&o.PLAIN_15.Reg, value)
}
func (o *XTS_AES_Type) GetPLAIN_15() uint32 {
	return volatile.LoadUint32(&o.PLAIN_15.Reg)
}

// XTS_AES.LINESIZE: Configures the size of target memory space
func (o *XTS_AES_Type) SetLINESIZE(value uint32) {
	volatile.StoreUint32(&o.LINESIZE.Reg, volatile.LoadUint32(&o.LINESIZE.Reg)&^(0x3)|value)
}
func (o *XTS_AES_Type) GetLINESIZE() uint32 {
	return volatile.LoadUint32(&o.LINESIZE.Reg) & 0x3
}

// XTS_AES.DESTINATION: Configures the type of the external memory
func (o *XTS_AES_Type) SetDESTINATION(value uint32) {
	volatile.StoreUint32(&o.DESTINATION.Reg, volatile.LoadUint32(&o.DESTINATION.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetDESTINATION() uint32 {
	return volatile.LoadUint32(&o.DESTINATION.Reg) & 0x1
}

// XTS_AES.PHYSICAL_ADDRESS: Physical address
func (o *XTS_AES_Type) SetPHYSICAL_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.PHYSICAL_ADDRESS.Reg, volatile.LoadUint32(&o.PHYSICAL_ADDRESS.Reg)&^(0x3fffffff)|value)
}
func (o *XTS_AES_Type) GetPHYSICAL_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.PHYSICAL_ADDRESS.Reg) & 0x3fffffff
}

// XTS_AES.TRIGGER: Activates AES algorithm
func (o *XTS_AES_Type) SetTRIGGER(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetTRIGGER() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}

// XTS_AES.RELEASE: Release control
func (o *XTS_AES_Type) SetRELEASE(value uint32) {
	volatile.StoreUint32(&o.RELEASE.Reg, volatile.LoadUint32(&o.RELEASE.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetRELEASE() uint32 {
	return volatile.LoadUint32(&o.RELEASE.Reg) & 0x1
}

// XTS_AES.DESTROY: Destroys control
func (o *XTS_AES_Type) SetDESTROY(value uint32) {
	volatile.StoreUint32(&o.DESTROY.Reg, volatile.LoadUint32(&o.DESTROY.Reg)&^(0x1)|value)
}
func (o *XTS_AES_Type) GetDESTROY() uint32 {
	return volatile.LoadUint32(&o.DESTROY.Reg) & 0x1
}

// XTS_AES.STATE: Status register
func (o *XTS_AES_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x3)|value)
}
func (o *XTS_AES_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x3
}

// XTS_AES.DATE: Version control register
func (o *XTS_AES_Type) SetDATE(value uint32) {
	volatile.StoreUint32(&o.DATE.Reg, volatile.LoadUint32(&o.DATE.Reg)&^(0x3fffffff)|value)
}
func (o *XTS_AES_Type) GetDATE() uint32 {
	return volatile.LoadUint32(&o.DATE.Reg) & 0x3fffffff
}

// Constants for AES: AES (Advanced Encryption Standard) Accelerator
const (
	// KEY_0: AES key register %s
	// Position of KEY field.
	AES_KEY_KEY_Pos = 0x0
	// Bit mask of KEY field.
	AES_KEY_KEY_Msk = 0xffffffff

	// TEXT_IN_0: Source data register %s
	// Position of TEXT_IN field.
	AES_TEXT_IN_TEXT_IN_Pos = 0x0
	// Bit mask of TEXT_IN field.
	AES_TEXT_IN_TEXT_IN_Msk = 0xffffffff

	// TEXT_OUT_0: Result data register %s
	// Position of TEXT_OUT field.
	AES_TEXT_OUT_TEXT_OUT_Pos = 0x0
	// Bit mask of TEXT_OUT field.
	AES_TEXT_OUT_TEXT_OUT_Msk = 0xffffffff

	// MODE: AES working mode configuration register
	// Position of MODE field.
	AES_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	AES_MODE_MODE_Msk = 0x7

	// ENDIAN: Endian configuration register
	// Position of ENDIAN field.
	AES_ENDIAN_ENDIAN_Pos = 0x0
	// Bit mask of ENDIAN field.
	AES_ENDIAN_ENDIAN_Msk = 0x3f

	// TRIGGER: Operation start controlling register
	// Position of TRIGGER field.
	AES_TRIGGER_TRIGGER_Pos = 0x0
	// Bit mask of TRIGGER field.
	AES_TRIGGER_TRIGGER_Msk = 0x1
	// Bit TRIGGER.
	AES_TRIGGER_TRIGGER = 0x1

	// STATE: Operation status register
	// Position of STATE field.
	AES_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	AES_STATE_STATE_Msk = 0x3

	// IV_0: initialization vector
	// Position of IV field.
	AES_IV_IV_Pos = 0x0
	// Bit mask of IV field.
	AES_IV_IV_Msk = 0xffffffff

	// H_0: GCM hash subkey
	// Position of H field.
	AES_H_H_Pos = 0x0
	// Bit mask of H field.
	AES_H_H_Msk = 0xffffffff

	// J0_0: J0
	// Position of J0 field.
	AES_J0_J0_Pos = 0x0
	// Bit mask of J0 field.
	AES_J0_J0_Msk = 0xffffffff

	// T0_0: T0
	// Position of T0 field.
	AES_T0_T0_Pos = 0x0
	// Bit mask of T0 field.
	AES_T0_T0_Msk = 0xffffffff

	// DMA_ENABLE: DMA enable register
	// Position of DMA_ENABLE field.
	AES_DMA_ENABLE_DMA_ENABLE_Pos = 0x0
	// Bit mask of DMA_ENABLE field.
	AES_DMA_ENABLE_DMA_ENABLE_Msk = 0x1
	// Bit DMA_ENABLE.
	AES_DMA_ENABLE_DMA_ENABLE = 0x1

	// BLOCK_MODE: Block operation type register
	// Position of BLOCK_MODE field.
	AES_BLOCK_MODE_BLOCK_MODE_Pos = 0x0
	// Bit mask of BLOCK_MODE field.
	AES_BLOCK_MODE_BLOCK_MODE_Msk = 0x7

	// BLOCK_NUM: Block number configuration register
	// Position of BLOCK_NUM field.
	AES_BLOCK_NUM_BLOCK_NUM_Pos = 0x0
	// Bit mask of BLOCK_NUM field.
	AES_BLOCK_NUM_BLOCK_NUM_Msk = 0xffffffff

	// INC_SEL: Standard incrementing function register
	// Position of INC_SEL field.
	AES_INC_SEL_INC_SEL_Pos = 0x0
	// Bit mask of INC_SEL field.
	AES_INC_SEL_INC_SEL_Msk = 0x1
	// Bit INC_SEL.
	AES_INC_SEL_INC_SEL = 0x1

	// AAD_BLOCK_NUM: AAD block number configuration register
	// Position of AAD_BLOCK_NUM field.
	AES_AAD_BLOCK_NUM_AAD_BLOCK_NUM_Pos = 0x0
	// Bit mask of AAD_BLOCK_NUM field.
	AES_AAD_BLOCK_NUM_AAD_BLOCK_NUM_Msk = 0xffffffff

	// REMAINDER_BIT_NUM: Remainder bit number of plaintext/ciphertext
	// Position of REMAINDER_BIT_NUM field.
	AES_REMAINDER_BIT_NUM_REMAINDER_BIT_NUM_Pos = 0x0
	// Bit mask of REMAINDER_BIT_NUM field.
	AES_REMAINDER_BIT_NUM_REMAINDER_BIT_NUM_Msk = 0x7f

	// CONTINUE_OP: Operation continue controlling register
	// Position of CONTINUE_OP field.
	AES_CONTINUE_OP_CONTINUE_OP_Pos = 0x0
	// Bit mask of CONTINUE_OP field.
	AES_CONTINUE_OP_CONTINUE_OP_Msk = 0x1
	// Bit CONTINUE_OP.
	AES_CONTINUE_OP_CONTINUE_OP = 0x1

	// INT_CLR: DMA-AES interrupt clear register
	// Position of INT_CLR field.
	AES_INT_CLR_INT_CLR_Pos = 0x0
	// Bit mask of INT_CLR field.
	AES_INT_CLR_INT_CLR_Msk = 0x1
	// Bit INT_CLR.
	AES_INT_CLR_INT_CLR = 0x1

	// INT_ENA: DMA-AES interrupt enable register
	// Position of INT_ENA field.
	AES_INT_ENA_INT_ENA_Pos = 0x0
	// Bit mask of INT_ENA field.
	AES_INT_ENA_INT_ENA_Msk = 0x1
	// Bit INT_ENA.
	AES_INT_ENA_INT_ENA = 0x1

	// DATE: Version control register
	// Position of DATE field.
	AES_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	AES_DATE_DATE_Msk = 0x3fffffff

	// DMA_EXIT: Operation exit controlling register
	// Position of DMA_EXIT field.
	AES_DMA_EXIT_DMA_EXIT_Pos = 0x0
	// Bit mask of DMA_EXIT field.
	AES_DMA_EXIT_DMA_EXIT_Msk = 0x1
	// Bit DMA_EXIT.
	AES_DMA_EXIT_DMA_EXIT = 0x1
)

// Constants for APB_SARADC: SAR (Successive Approximation Register) Analog-to-Digital Converter
const (
	// CTRL: DIG ADC common configuration
	// Position of START_FORCE field.
	APB_SARADC_CTRL_START_FORCE_Pos = 0x0
	// Bit mask of START_FORCE field.
	APB_SARADC_CTRL_START_FORCE_Msk = 0x1
	// Bit START_FORCE.
	APB_SARADC_CTRL_START_FORCE = 0x1
	// Position of START field.
	APB_SARADC_CTRL_START_Pos = 0x1
	// Bit mask of START field.
	APB_SARADC_CTRL_START_Msk = 0x2
	// Bit START.
	APB_SARADC_CTRL_START = 0x2
	// Position of WORK_MODE field.
	APB_SARADC_CTRL_WORK_MODE_Pos = 0x3
	// Bit mask of WORK_MODE field.
	APB_SARADC_CTRL_WORK_MODE_Msk = 0x18
	// Position of SAR_SEL field.
	APB_SARADC_CTRL_SAR_SEL_Pos = 0x5
	// Bit mask of SAR_SEL field.
	APB_SARADC_CTRL_SAR_SEL_Msk = 0x20
	// Bit SAR_SEL.
	APB_SARADC_CTRL_SAR_SEL = 0x20
	// Position of SAR_CLK_GATED field.
	APB_SARADC_CTRL_SAR_CLK_GATED_Pos = 0x6
	// Bit mask of SAR_CLK_GATED field.
	APB_SARADC_CTRL_SAR_CLK_GATED_Msk = 0x40
	// Bit SAR_CLK_GATED.
	APB_SARADC_CTRL_SAR_CLK_GATED = 0x40
	// Position of SAR_CLK_DIV field.
	APB_SARADC_CTRL_SAR_CLK_DIV_Pos = 0x7
	// Bit mask of SAR_CLK_DIV field.
	APB_SARADC_CTRL_SAR_CLK_DIV_Msk = 0x7f80
	// Position of SAR1_PATT_LEN field.
	APB_SARADC_CTRL_SAR1_PATT_LEN_Pos = 0xf
	// Bit mask of SAR1_PATT_LEN field.
	APB_SARADC_CTRL_SAR1_PATT_LEN_Msk = 0x78000
	// Position of SAR2_PATT_LEN field.
	APB_SARADC_CTRL_SAR2_PATT_LEN_Pos = 0x13
	// Bit mask of SAR2_PATT_LEN field.
	APB_SARADC_CTRL_SAR2_PATT_LEN_Msk = 0x780000
	// Position of SAR1_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR1_PATT_P_CLEAR_Pos = 0x17
	// Bit mask of SAR1_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR1_PATT_P_CLEAR_Msk = 0x800000
	// Bit SAR1_PATT_P_CLEAR.
	APB_SARADC_CTRL_SAR1_PATT_P_CLEAR = 0x800000
	// Position of SAR2_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR2_PATT_P_CLEAR_Pos = 0x18
	// Bit mask of SAR2_PATT_P_CLEAR field.
	APB_SARADC_CTRL_SAR2_PATT_P_CLEAR_Msk = 0x1000000
	// Bit SAR2_PATT_P_CLEAR.
	APB_SARADC_CTRL_SAR2_PATT_P_CLEAR = 0x1000000
	// Position of DATA_SAR_SEL field.
	APB_SARADC_CTRL_DATA_SAR_SEL_Pos = 0x19
	// Bit mask of DATA_SAR_SEL field.
	APB_SARADC_CTRL_DATA_SAR_SEL_Msk = 0x2000000
	// Bit DATA_SAR_SEL.
	APB_SARADC_CTRL_DATA_SAR_SEL = 0x2000000
	// Position of DATA_TO_I2S field.
	APB_SARADC_CTRL_DATA_TO_I2S_Pos = 0x1a
	// Bit mask of DATA_TO_I2S field.
	APB_SARADC_CTRL_DATA_TO_I2S_Msk = 0x4000000
	// Bit DATA_TO_I2S.
	APB_SARADC_CTRL_DATA_TO_I2S = 0x4000000
	// Position of XPD_SAR_FORCE field.
	APB_SARADC_CTRL_XPD_SAR_FORCE_Pos = 0x1b
	// Bit mask of XPD_SAR_FORCE field.
	APB_SARADC_CTRL_XPD_SAR_FORCE_Msk = 0x18000000
	// Position of WAIT_ARB_CYCLE field.
	APB_SARADC_CTRL_WAIT_ARB_CYCLE_Pos = 0x1e
	// Bit mask of WAIT_ARB_CYCLE field.
	APB_SARADC_CTRL_WAIT_ARB_CYCLE_Msk = 0xc0000000

	// CTRL2: DIG ADC common configuration
	// Position of MEAS_NUM_LIMIT field.
	APB_SARADC_CTRL2_MEAS_NUM_LIMIT_Pos = 0x0
	// Bit mask of MEAS_NUM_LIMIT field.
	APB_SARADC_CTRL2_MEAS_NUM_LIMIT_Msk = 0x1
	// Bit MEAS_NUM_LIMIT.
	APB_SARADC_CTRL2_MEAS_NUM_LIMIT = 0x1
	// Position of MAX_MEAS_NUM field.
	APB_SARADC_CTRL2_MAX_MEAS_NUM_Pos = 0x1
	// Bit mask of MAX_MEAS_NUM field.
	APB_SARADC_CTRL2_MAX_MEAS_NUM_Msk = 0x1fe
	// Position of SAR1_INV field.
	APB_SARADC_CTRL2_SAR1_INV_Pos = 0x9
	// Bit mask of SAR1_INV field.
	APB_SARADC_CTRL2_SAR1_INV_Msk = 0x200
	// Bit SAR1_INV.
	APB_SARADC_CTRL2_SAR1_INV = 0x200
	// Position of SAR2_INV field.
	APB_SARADC_CTRL2_SAR2_INV_Pos = 0xa
	// Bit mask of SAR2_INV field.
	APB_SARADC_CTRL2_SAR2_INV_Msk = 0x400
	// Bit SAR2_INV.
	APB_SARADC_CTRL2_SAR2_INV = 0x400
	// Position of TIMER_SEL field.
	APB_SARADC_CTRL2_TIMER_SEL_Pos = 0xb
	// Bit mask of TIMER_SEL field.
	APB_SARADC_CTRL2_TIMER_SEL_Msk = 0x800
	// Bit TIMER_SEL.
	APB_SARADC_CTRL2_TIMER_SEL = 0x800
	// Position of TIMER_TARGET field.
	APB_SARADC_CTRL2_TIMER_TARGET_Pos = 0xc
	// Bit mask of TIMER_TARGET field.
	APB_SARADC_CTRL2_TIMER_TARGET_Msk = 0xfff000
	// Position of TIMER_EN field.
	APB_SARADC_CTRL2_TIMER_EN_Pos = 0x18
	// Bit mask of TIMER_EN field.
	APB_SARADC_CTRL2_TIMER_EN_Msk = 0x1000000
	// Bit TIMER_EN.
	APB_SARADC_CTRL2_TIMER_EN = 0x1000000

	// FSM: digital adc control register
	// Position of SAMPLE_NUM field.
	APB_SARADC_FSM_SAMPLE_NUM_Pos = 0x10
	// Bit mask of SAMPLE_NUM field.
	APB_SARADC_FSM_SAMPLE_NUM_Msk = 0xff0000
	// Position of SAMPLE_CYCLE field.
	APB_SARADC_FSM_SAMPLE_CYCLE_Pos = 0x18
	// Bit mask of SAMPLE_CYCLE field.
	APB_SARADC_FSM_SAMPLE_CYCLE_Msk = 0xff000000

	// FSM_WAIT: configure saradc fsm internal parameter base on test
	// Position of XPD_WAIT field.
	APB_SARADC_FSM_WAIT_XPD_WAIT_Pos = 0x0
	// Bit mask of XPD_WAIT field.
	APB_SARADC_FSM_WAIT_XPD_WAIT_Msk = 0xff
	// Position of RSTB_WAIT field.
	APB_SARADC_FSM_WAIT_RSTB_WAIT_Pos = 0x8
	// Bit mask of RSTB_WAIT field.
	APB_SARADC_FSM_WAIT_RSTB_WAIT_Msk = 0xff00
	// Position of STANDBY_WAIT field.
	APB_SARADC_FSM_WAIT_STANDBY_WAIT_Pos = 0x10
	// Bit mask of STANDBY_WAIT field.
	APB_SARADC_FSM_WAIT_STANDBY_WAIT_Msk = 0xff0000

	// SAR1_STATUS: digital adc1 status
	// Position of SAR1_STATUS field.
	APB_SARADC_SAR1_STATUS_SAR1_STATUS_Pos = 0x0
	// Bit mask of SAR1_STATUS field.
	APB_SARADC_SAR1_STATUS_SAR1_STATUS_Msk = 0xffffffff

	// SAR2_STATUS: digital adc2 status
	// Position of SAR2_STATUS field.
	APB_SARADC_SAR2_STATUS_SAR2_STATUS_Pos = 0x0
	// Bit mask of SAR2_STATUS field.
	APB_SARADC_SAR2_STATUS_SAR2_STATUS_Msk = 0xffffffff

	// SAR1_PATT_TAB1: item 0 ~ 3 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB1 field.
	APB_SARADC_SAR1_PATT_TAB1_SAR1_PATT_TAB1_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB1 field.
	APB_SARADC_SAR1_PATT_TAB1_SAR1_PATT_TAB1_Msk = 0xffffffff

	// SAR1_PATT_TAB2: Item 4 ~ 7 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB2 field.
	APB_SARADC_SAR1_PATT_TAB2_SAR1_PATT_TAB2_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB2 field.
	APB_SARADC_SAR1_PATT_TAB2_SAR1_PATT_TAB2_Msk = 0xffffffff

	// SAR1_PATT_TAB3: Item 8 ~ 11 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB3 field.
	APB_SARADC_SAR1_PATT_TAB3_SAR1_PATT_TAB3_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB3 field.
	APB_SARADC_SAR1_PATT_TAB3_SAR1_PATT_TAB3_Msk = 0xffffffff

	// SAR1_PATT_TAB4: Item 12 ~ 15 for pattern table 1 (each item one byte)
	// Position of SAR1_PATT_TAB4 field.
	APB_SARADC_SAR1_PATT_TAB4_SAR1_PATT_TAB4_Pos = 0x0
	// Bit mask of SAR1_PATT_TAB4 field.
	APB_SARADC_SAR1_PATT_TAB4_SAR1_PATT_TAB4_Msk = 0xffffffff

	// SAR2_PATT_TAB1: item 0 ~ 3 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB1 field.
	APB_SARADC_SAR2_PATT_TAB1_SAR2_PATT_TAB1_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB1 field.
	APB_SARADC_SAR2_PATT_TAB1_SAR2_PATT_TAB1_Msk = 0xffffffff

	// SAR2_PATT_TAB2: Item 4 ~ 7 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB2 field.
	APB_SARADC_SAR2_PATT_TAB2_SAR2_PATT_TAB2_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB2 field.
	APB_SARADC_SAR2_PATT_TAB2_SAR2_PATT_TAB2_Msk = 0xffffffff

	// SAR2_PATT_TAB3: Item 8 ~ 11 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB3 field.
	APB_SARADC_SAR2_PATT_TAB3_SAR2_PATT_TAB3_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB3 field.
	APB_SARADC_SAR2_PATT_TAB3_SAR2_PATT_TAB3_Msk = 0xffffffff

	// SAR2_PATT_TAB4: Item 12 ~ 15 for pattern table 2 (each item one byte)
	// Position of SAR2_PATT_TAB4 field.
	APB_SARADC_SAR2_PATT_TAB4_SAR2_PATT_TAB4_Pos = 0x0
	// Bit mask of SAR2_PATT_TAB4 field.
	APB_SARADC_SAR2_PATT_TAB4_SAR2_PATT_TAB4_Msk = 0xffffffff

	// ARB_CTRL: Configure the settings of DIG ADC2 arbiter
	// Position of ADC_ARB_APB_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE_Pos = 0x2
	// Bit mask of ADC_ARB_APB_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE_Msk = 0x4
	// Bit ADC_ARB_APB_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_FORCE = 0x4
	// Position of ADC_ARB_RTC_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE_Pos = 0x3
	// Bit mask of ADC_ARB_RTC_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE_Msk = 0x8
	// Bit ADC_ARB_RTC_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_FORCE = 0x8
	// Position of ADC_ARB_WIFI_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE_Pos = 0x4
	// Bit mask of ADC_ARB_WIFI_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE_Msk = 0x10
	// Bit ADC_ARB_WIFI_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_FORCE = 0x10
	// Position of ADC_ARB_GRANT_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE_Pos = 0x5
	// Bit mask of ADC_ARB_GRANT_FORCE field.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE_Msk = 0x20
	// Bit ADC_ARB_GRANT_FORCE.
	APB_SARADC_ARB_CTRL_ADC_ARB_GRANT_FORCE = 0x20
	// Position of ADC_ARB_APB_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_PRIORITY_Pos = 0x6
	// Bit mask of ADC_ARB_APB_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_APB_PRIORITY_Msk = 0xc0
	// Position of ADC_ARB_RTC_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_PRIORITY_Pos = 0x8
	// Bit mask of ADC_ARB_RTC_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_RTC_PRIORITY_Msk = 0x300
	// Position of ADC_ARB_WIFI_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_PRIORITY_Pos = 0xa
	// Bit mask of ADC_ARB_WIFI_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_WIFI_PRIORITY_Msk = 0xc00
	// Position of ADC_ARB_FIX_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY_Pos = 0xc
	// Bit mask of ADC_ARB_FIX_PRIORITY field.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY_Msk = 0x1000
	// Bit ADC_ARB_FIX_PRIORITY.
	APB_SARADC_ARB_CTRL_ADC_ARB_FIX_PRIORITY = 0x1000

	// FILTER_CTRL: Configure the settings of DIG ADC2 filter
	// Position of ADC2_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_RESET_Pos = 0x0
	// Bit mask of ADC2_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_RESET_Msk = 0x1
	// Bit ADC2_FILTER_RESET.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_RESET = 0x1
	// Position of ADC1_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_RESET_Pos = 0x1
	// Bit mask of ADC1_FILTER_RESET field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_RESET_Msk = 0x2
	// Bit ADC1_FILTER_RESET.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_RESET = 0x2
	// Position of ADC2_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_FACTOR_Pos = 0x10
	// Bit mask of ADC2_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_FACTOR_Msk = 0x7f0000
	// Position of ADC1_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_FACTOR_Pos = 0x17
	// Bit mask of ADC1_FILTER_FACTOR field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_FACTOR_Msk = 0x3f800000
	// Position of ADC2_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_EN_Pos = 0x1e
	// Bit mask of ADC2_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_EN_Msk = 0x40000000
	// Bit ADC2_FILTER_EN.
	APB_SARADC_FILTER_CTRL_ADC2_FILTER_EN = 0x40000000
	// Position of ADC1_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_EN_Pos = 0x1f
	// Bit mask of ADC1_FILTER_EN field.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_EN_Msk = 0x80000000
	// Bit ADC1_FILTER_EN.
	APB_SARADC_FILTER_CTRL_ADC1_FILTER_EN = 0x80000000

	// FILTER_STATUS: Data status of DIG ADC2 filter
	// Position of ADC2_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC2_FILTER_DATA_Pos = 0x0
	// Bit mask of ADC2_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC2_FILTER_DATA_Msk = 0xffff
	// Position of ADC1_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC1_FILTER_DATA_Pos = 0x10
	// Bit mask of ADC1_FILTER_DATA field.
	APB_SARADC_FILTER_STATUS_ADC1_FILTER_DATA_Msk = 0xffff0000

	// THRES_CTRL: Configure monitor threshold for DIG ADC2
	// Position of CLK_EN field.
	APB_SARADC_THRES_CTRL_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	APB_SARADC_THRES_CTRL_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	APB_SARADC_THRES_CTRL_CLK_EN = 0x1
	// Position of ADC2_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_MODE_Pos = 0x2
	// Bit mask of ADC2_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_MODE_Msk = 0x4
	// Bit ADC2_THRES_MODE.
	APB_SARADC_THRES_CTRL_ADC2_THRES_MODE = 0x4
	// Position of ADC1_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_MODE_Pos = 0x3
	// Bit mask of ADC1_THRES_MODE field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_MODE_Msk = 0x8
	// Bit ADC1_THRES_MODE.
	APB_SARADC_THRES_CTRL_ADC1_THRES_MODE = 0x8
	// Position of ADC2_THRES field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_Pos = 0x4
	// Bit mask of ADC2_THRES field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_Msk = 0x1fff0
	// Position of ADC1_THRES field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_Pos = 0x11
	// Bit mask of ADC1_THRES field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_Msk = 0x3ffe0000
	// Position of ADC2_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_EN_Pos = 0x1e
	// Bit mask of ADC2_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC2_THRES_EN_Msk = 0x40000000
	// Bit ADC2_THRES_EN.
	APB_SARADC_THRES_CTRL_ADC2_THRES_EN = 0x40000000
	// Position of ADC1_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_EN_Pos = 0x1f
	// Bit mask of ADC1_THRES_EN field.
	APB_SARADC_THRES_CTRL_ADC1_THRES_EN_Msk = 0x80000000
	// Bit ADC1_THRES_EN.
	APB_SARADC_THRES_CTRL_ADC1_THRES_EN = 0x80000000

	// INT_ENA: Enable DIG ADC interrupts
	// Position of ADC2_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_THRES_INT_ENA_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_THRES_INT_ENA_Msk = 0x10000000
	// Bit ADC2_THRES_INT_ENA.
	APB_SARADC_INT_ENA_ADC2_THRES_INT_ENA = 0x10000000
	// Position of ADC1_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_THRES_INT_ENA_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_THRES_INT_ENA_Msk = 0x20000000
	// Bit ADC1_THRES_INT_ENA.
	APB_SARADC_INT_ENA_ADC1_THRES_INT_ENA = 0x20000000
	// Position of ADC2_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_DONE_INT_ENA_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC2_DONE_INT_ENA_Msk = 0x40000000
	// Bit ADC2_DONE_INT_ENA.
	APB_SARADC_INT_ENA_ADC2_DONE_INT_ENA = 0x40000000
	// Position of ADC1_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_DONE_INT_ENA_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_ENA field.
	APB_SARADC_INT_ENA_ADC1_DONE_INT_ENA_Msk = 0x80000000
	// Bit ADC1_DONE_INT_ENA.
	APB_SARADC_INT_ENA_ADC1_DONE_INT_ENA = 0x80000000

	// INT_RAW: DIG ADC interrupt raw bits
	// Position of ADC2_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_THRES_INT_RAW_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_THRES_INT_RAW_Msk = 0x10000000
	// Bit ADC2_THRES_INT_RAW.
	APB_SARADC_INT_RAW_ADC2_THRES_INT_RAW = 0x10000000
	// Position of ADC1_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_THRES_INT_RAW_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_THRES_INT_RAW_Msk = 0x20000000
	// Bit ADC1_THRES_INT_RAW.
	APB_SARADC_INT_RAW_ADC1_THRES_INT_RAW = 0x20000000
	// Position of ADC2_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_DONE_INT_RAW_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC2_DONE_INT_RAW_Msk = 0x40000000
	// Bit ADC2_DONE_INT_RAW.
	APB_SARADC_INT_RAW_ADC2_DONE_INT_RAW = 0x40000000
	// Position of ADC1_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_DONE_INT_RAW_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_RAW field.
	APB_SARADC_INT_RAW_ADC1_DONE_INT_RAW_Msk = 0x80000000
	// Bit ADC1_DONE_INT_RAW.
	APB_SARADC_INT_RAW_ADC1_DONE_INT_RAW = 0x80000000

	// INT_ST: DIG ADC interrupt status
	// Position of ADC2_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC2_THRES_INT_ST_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC2_THRES_INT_ST_Msk = 0x10000000
	// Bit ADC2_THRES_INT_ST.
	APB_SARADC_INT_ST_ADC2_THRES_INT_ST = 0x10000000
	// Position of ADC1_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC1_THRES_INT_ST_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_ST field.
	APB_SARADC_INT_ST_ADC1_THRES_INT_ST_Msk = 0x20000000
	// Bit ADC1_THRES_INT_ST.
	APB_SARADC_INT_ST_ADC1_THRES_INT_ST = 0x20000000
	// Position of ADC2_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC2_DONE_INT_ST_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC2_DONE_INT_ST_Msk = 0x40000000
	// Bit ADC2_DONE_INT_ST.
	APB_SARADC_INT_ST_ADC2_DONE_INT_ST = 0x40000000
	// Position of ADC1_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC1_DONE_INT_ST_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_ST field.
	APB_SARADC_INT_ST_ADC1_DONE_INT_ST_Msk = 0x80000000
	// Bit ADC1_DONE_INT_ST.
	APB_SARADC_INT_ST_ADC1_DONE_INT_ST = 0x80000000

	// INT_CLR: Clear DIG ADC interrupts
	// Position of ADC2_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_THRES_INT_CLR_Pos = 0x1c
	// Bit mask of ADC2_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_THRES_INT_CLR_Msk = 0x10000000
	// Bit ADC2_THRES_INT_CLR.
	APB_SARADC_INT_CLR_ADC2_THRES_INT_CLR = 0x10000000
	// Position of ADC1_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_THRES_INT_CLR_Pos = 0x1d
	// Bit mask of ADC1_THRES_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_THRES_INT_CLR_Msk = 0x20000000
	// Bit ADC1_THRES_INT_CLR.
	APB_SARADC_INT_CLR_ADC1_THRES_INT_CLR = 0x20000000
	// Position of ADC2_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_DONE_INT_CLR_Pos = 0x1e
	// Bit mask of ADC2_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC2_DONE_INT_CLR_Msk = 0x40000000
	// Bit ADC2_DONE_INT_CLR.
	APB_SARADC_INT_CLR_ADC2_DONE_INT_CLR = 0x40000000
	// Position of ADC1_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_DONE_INT_CLR_Pos = 0x1f
	// Bit mask of ADC1_DONE_INT_CLR field.
	APB_SARADC_INT_CLR_ADC1_DONE_INT_CLR_Msk = 0x80000000
	// Bit ADC1_DONE_INT_CLR.
	APB_SARADC_INT_CLR_ADC1_DONE_INT_CLR = 0x80000000

	// DMA_CONF: Configure digital ADC DMA path
	// Position of APB_ADC_EOF_NUM field.
	APB_SARADC_DMA_CONF_APB_ADC_EOF_NUM_Pos = 0x0
	// Bit mask of APB_ADC_EOF_NUM field.
	APB_SARADC_DMA_CONF_APB_ADC_EOF_NUM_Msk = 0xffff
	// Position of APB_ADC_RESET_FSM field.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM_Pos = 0x1e
	// Bit mask of APB_ADC_RESET_FSM field.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM_Msk = 0x40000000
	// Bit APB_ADC_RESET_FSM.
	APB_SARADC_DMA_CONF_APB_ADC_RESET_FSM = 0x40000000
	// Position of APB_ADC_TRANS field.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS_Pos = 0x1f
	// Bit mask of APB_ADC_TRANS field.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS_Msk = 0x80000000
	// Bit APB_ADC_TRANS.
	APB_SARADC_DMA_CONF_APB_ADC_TRANS = 0x80000000

	// CLKM_CONF: Configure DIG ADC clock
	// Position of CLKM_DIV_NUM field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of CLKM_DIV_NUM field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_NUM_Msk = 0xff
	// Position of CLKM_DIV_B field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_B_Pos = 0x8
	// Bit mask of CLKM_DIV_B field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_B_Msk = 0x3f00
	// Position of CLKM_DIV_A field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_A_Pos = 0xe
	// Bit mask of CLKM_DIV_A field.
	APB_SARADC_CLKM_CONF_CLKM_DIV_A_Msk = 0xfc000
	// Position of CLK_SEL field.
	APB_SARADC_CLKM_CONF_CLK_SEL_Pos = 0x15
	// Bit mask of CLK_SEL field.
	APB_SARADC_CLKM_CONF_CLK_SEL_Msk = 0x600000

	// APB_DAC_CTRL: Configure DAC settings
	// Position of DAC_TIMER_TARGET field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_TARGET_Pos = 0x0
	// Bit mask of DAC_TIMER_TARGET field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_TARGET_Msk = 0xfff
	// Position of DAC_TIMER_EN field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_EN_Pos = 0xc
	// Bit mask of DAC_TIMER_EN field.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_EN_Msk = 0x1000
	// Bit DAC_TIMER_EN.
	APB_SARADC_APB_DAC_CTRL_DAC_TIMER_EN = 0x1000
	// Position of APB_DAC_ALTER_MODE field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_ALTER_MODE_Pos = 0xd
	// Bit mask of APB_DAC_ALTER_MODE field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_ALTER_MODE_Msk = 0x2000
	// Bit APB_DAC_ALTER_MODE.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_ALTER_MODE = 0x2000
	// Position of APB_DAC_TRANS field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_TRANS_Pos = 0xe
	// Bit mask of APB_DAC_TRANS field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_TRANS_Msk = 0x4000
	// Bit APB_DAC_TRANS.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_TRANS = 0x4000
	// Position of DAC_RESET_FIFO field.
	APB_SARADC_APB_DAC_CTRL_DAC_RESET_FIFO_Pos = 0xf
	// Bit mask of DAC_RESET_FIFO field.
	APB_SARADC_APB_DAC_CTRL_DAC_RESET_FIFO_Msk = 0x8000
	// Bit DAC_RESET_FIFO.
	APB_SARADC_APB_DAC_CTRL_DAC_RESET_FIFO = 0x8000
	// Position of APB_DAC_RST field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_RST_Pos = 0x10
	// Bit mask of APB_DAC_RST field.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_RST_Msk = 0x10000
	// Bit APB_DAC_RST.
	APB_SARADC_APB_DAC_CTRL_APB_DAC_RST = 0x10000

	// APB_CTRL_DATE: Version control register
	// Position of APB_CTRL_DATE field.
	APB_SARADC_APB_CTRL_DATE_APB_CTRL_DATE_Pos = 0x0
	// Bit mask of APB_CTRL_DATE field.
	APB_SARADC_APB_CTRL_DATE_APB_CTRL_DATE_Msk = 0xffffffff
)

// Constants for BB: BB Peripheral
const (
	// BBPD_CTRL: Baseband control register
	// Position of DC_EST_FORCE_PD field.
	BB_BBPD_CTRL_DC_EST_FORCE_PD_Pos = 0x0
	// Bit mask of DC_EST_FORCE_PD field.
	BB_BBPD_CTRL_DC_EST_FORCE_PD_Msk = 0x1
	// Bit DC_EST_FORCE_PD.
	BB_BBPD_CTRL_DC_EST_FORCE_PD = 0x1
	// Position of DC_EST_FORCE_PU field.
	BB_BBPD_CTRL_DC_EST_FORCE_PU_Pos = 0x1
	// Bit mask of DC_EST_FORCE_PU field.
	BB_BBPD_CTRL_DC_EST_FORCE_PU_Msk = 0x2
	// Bit DC_EST_FORCE_PU.
	BB_BBPD_CTRL_DC_EST_FORCE_PU = 0x2
	// Position of FFT_FORCE_PD field.
	BB_BBPD_CTRL_FFT_FORCE_PD_Pos = 0x2
	// Bit mask of FFT_FORCE_PD field.
	BB_BBPD_CTRL_FFT_FORCE_PD_Msk = 0x4
	// Bit FFT_FORCE_PD.
	BB_BBPD_CTRL_FFT_FORCE_PD = 0x4
	// Position of FFT_FORCE_PU field.
	BB_BBPD_CTRL_FFT_FORCE_PU_Pos = 0x3
	// Bit mask of FFT_FORCE_PU field.
	BB_BBPD_CTRL_FFT_FORCE_PU_Msk = 0x8
	// Bit FFT_FORCE_PU.
	BB_BBPD_CTRL_FFT_FORCE_PU = 0x8
)

// Constants for DEDICATED_GPIO: DEDICATED_GPIO Peripheral
const (
	// OUT_DRT: Dedicated GPIO directive output register
	// Position of VLAUE field.
	DEDIC_GPIO_OUT_DRT_VLAUE_Pos = 0x0
	// Bit mask of VLAUE field.
	DEDIC_GPIO_OUT_DRT_VLAUE_Msk = 0xff

	// OUT_MSK: Dedicated GPIO mask output register
	// Position of OUT_VALUE field.
	DEDIC_GPIO_OUT_MSK_OUT_VALUE_Pos = 0x0
	// Bit mask of OUT_VALUE field.
	DEDIC_GPIO_OUT_MSK_OUT_VALUE_Msk = 0xff
	// Position of OUT_MSK field.
	DEDIC_GPIO_OUT_MSK_OUT_MSK_Pos = 0x8
	// Bit mask of OUT_MSK field.
	DEDIC_GPIO_OUT_MSK_OUT_MSK_Msk = 0xff00

	// OUT_IDV: Dedicated GPIO individual output register
	// Position of CH0 field.
	DEDIC_GPIO_OUT_IDV_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DEDIC_GPIO_OUT_IDV_CH0_Msk = 0x3
	// Position of CH1 field.
	DEDIC_GPIO_OUT_IDV_CH1_Pos = 0x2
	// Bit mask of CH1 field.
	DEDIC_GPIO_OUT_IDV_CH1_Msk = 0xc
	// Position of CH2 field.
	DEDIC_GPIO_OUT_IDV_CH2_Pos = 0x4
	// Bit mask of CH2 field.
	DEDIC_GPIO_OUT_IDV_CH2_Msk = 0x30
	// Position of CH3 field.
	DEDIC_GPIO_OUT_IDV_CH3_Pos = 0x6
	// Bit mask of CH3 field.
	DEDIC_GPIO_OUT_IDV_CH3_Msk = 0xc0
	// Position of CH4 field.
	DEDIC_GPIO_OUT_IDV_CH4_Pos = 0x8
	// Bit mask of CH4 field.
	DEDIC_GPIO_OUT_IDV_CH4_Msk = 0x300
	// Position of CH5 field.
	DEDIC_GPIO_OUT_IDV_CH5_Pos = 0xa
	// Bit mask of CH5 field.
	DEDIC_GPIO_OUT_IDV_CH5_Msk = 0xc00
	// Position of CH6 field.
	DEDIC_GPIO_OUT_IDV_CH6_Pos = 0xc
	// Bit mask of CH6 field.
	DEDIC_GPIO_OUT_IDV_CH6_Msk = 0x3000
	// Position of CH7 field.
	DEDIC_GPIO_OUT_IDV_CH7_Pos = 0xe
	// Bit mask of CH7 field.
	DEDIC_GPIO_OUT_IDV_CH7_Msk = 0xc000

	// OUT_SCAN: Dedicated GPIO output status register
	// Position of OUT_STATUS field.
	DEDIC_GPIO_OUT_SCAN_OUT_STATUS_Pos = 0x0
	// Bit mask of OUT_STATUS field.
	DEDIC_GPIO_OUT_SCAN_OUT_STATUS_Msk = 0xff

	// OUT_CPU: Dedicated GPIO output mode selection register
	// Position of SEL0 field.
	DEDIC_GPIO_OUT_CPU_SEL0_Pos = 0x0
	// Bit mask of SEL0 field.
	DEDIC_GPIO_OUT_CPU_SEL0_Msk = 0x1
	// Bit SEL0.
	DEDIC_GPIO_OUT_CPU_SEL0 = 0x1
	// Position of SEL1 field.
	DEDIC_GPIO_OUT_CPU_SEL1_Pos = 0x1
	// Bit mask of SEL1 field.
	DEDIC_GPIO_OUT_CPU_SEL1_Msk = 0x2
	// Bit SEL1.
	DEDIC_GPIO_OUT_CPU_SEL1 = 0x2
	// Position of SEL2 field.
	DEDIC_GPIO_OUT_CPU_SEL2_Pos = 0x2
	// Bit mask of SEL2 field.
	DEDIC_GPIO_OUT_CPU_SEL2_Msk = 0x4
	// Bit SEL2.
	DEDIC_GPIO_OUT_CPU_SEL2 = 0x4
	// Position of SEL3 field.
	DEDIC_GPIO_OUT_CPU_SEL3_Pos = 0x3
	// Bit mask of SEL3 field.
	DEDIC_GPIO_OUT_CPU_SEL3_Msk = 0x8
	// Bit SEL3.
	DEDIC_GPIO_OUT_CPU_SEL3 = 0x8
	// Position of SEL4 field.
	DEDIC_GPIO_OUT_CPU_SEL4_Pos = 0x4
	// Bit mask of SEL4 field.
	DEDIC_GPIO_OUT_CPU_SEL4_Msk = 0x10
	// Bit SEL4.
	DEDIC_GPIO_OUT_CPU_SEL4 = 0x10
	// Position of SEL5 field.
	DEDIC_GPIO_OUT_CPU_SEL5_Pos = 0x5
	// Bit mask of SEL5 field.
	DEDIC_GPIO_OUT_CPU_SEL5_Msk = 0x20
	// Bit SEL5.
	DEDIC_GPIO_OUT_CPU_SEL5 = 0x20
	// Position of SEL6 field.
	DEDIC_GPIO_OUT_CPU_SEL6_Pos = 0x6
	// Bit mask of SEL6 field.
	DEDIC_GPIO_OUT_CPU_SEL6_Msk = 0x40
	// Bit SEL6.
	DEDIC_GPIO_OUT_CPU_SEL6 = 0x40
	// Position of SEL7 field.
	DEDIC_GPIO_OUT_CPU_SEL7_Pos = 0x7
	// Bit mask of SEL7 field.
	DEDIC_GPIO_OUT_CPU_SEL7_Msk = 0x80
	// Bit SEL7.
	DEDIC_GPIO_OUT_CPU_SEL7 = 0x80

	// IN_DLY: Dedicated GPIO input delay configuration register
	// Position of CH0 field.
	DEDIC_GPIO_IN_DLY_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	DEDIC_GPIO_IN_DLY_CH0_Msk = 0x3
	// Position of CH1 field.
	DEDIC_GPIO_IN_DLY_CH1_Pos = 0x2
	// Bit mask of CH1 field.
	DEDIC_GPIO_IN_DLY_CH1_Msk = 0xc
	// Position of CH2 field.
	DEDIC_GPIO_IN_DLY_CH2_Pos = 0x4
	// Bit mask of CH2 field.
	DEDIC_GPIO_IN_DLY_CH2_Msk = 0x30
	// Position of CH3 field.
	DEDIC_GPIO_IN_DLY_CH3_Pos = 0x6
	// Bit mask of CH3 field.
	DEDIC_GPIO_IN_DLY_CH3_Msk = 0xc0
	// Position of CH4 field.
	DEDIC_GPIO_IN_DLY_CH4_Pos = 0x8
	// Bit mask of CH4 field.
	DEDIC_GPIO_IN_DLY_CH4_Msk = 0x300
	// Position of CH5 field.
	DEDIC_GPIO_IN_DLY_CH5_Pos = 0xa
	// Bit mask of CH5 field.
	DEDIC_GPIO_IN_DLY_CH5_Msk = 0xc00
	// Position of CH6 field.
	DEDIC_GPIO_IN_DLY_CH6_Pos = 0xc
	// Bit mask of CH6 field.
	DEDIC_GPIO_IN_DLY_CH6_Msk = 0x3000
	// Position of CH7 field.
	DEDIC_GPIO_IN_DLY_CH7_Pos = 0xe
	// Bit mask of CH7 field.
	DEDIC_GPIO_IN_DLY_CH7_Msk = 0xc000

	// IN_SCAN: Dedicated GPIO input status register
	// Position of IN_STATUS field.
	DEDIC_GPIO_IN_SCAN_IN_STATUS_Pos = 0x0
	// Bit mask of IN_STATUS field.
	DEDIC_GPIO_IN_SCAN_IN_STATUS_Msk = 0xff

	// INTR_RCGN: Dedicated GPIO interrupts generation mode register
	// Position of INTR_MODE_CH0 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH0_Pos = 0x0
	// Bit mask of INTR_MODE_CH0 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH0_Msk = 0x7
	// Position of INTR_MODE_CH1 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH1_Pos = 0x3
	// Bit mask of INTR_MODE_CH1 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH1_Msk = 0x38
	// Position of INTR_MODE_CH2 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH2_Pos = 0x6
	// Bit mask of INTR_MODE_CH2 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH2_Msk = 0x1c0
	// Position of INTR_MODE_CH3 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH3_Pos = 0x9
	// Bit mask of INTR_MODE_CH3 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH3_Msk = 0xe00
	// Position of INTR_MODE_CH4 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH4_Pos = 0xc
	// Bit mask of INTR_MODE_CH4 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH4_Msk = 0x7000
	// Position of INTR_MODE_CH5 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH5_Pos = 0xf
	// Bit mask of INTR_MODE_CH5 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH5_Msk = 0x38000
	// Position of INTR_MODE_CH6 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH6_Pos = 0x12
	// Bit mask of INTR_MODE_CH6 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH6_Msk = 0x1c0000
	// Position of INTR_MODE_CH7 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH7_Pos = 0x15
	// Bit mask of INTR_MODE_CH7 field.
	DEDIC_GPIO_INTR_RCGN_INTR_MODE_CH7_Msk = 0xe00000

	// INTR_RAW: Raw interrupt status
	// Position of GPIO0 field.
	DEDIC_GPIO_INTR_RAW_GPIO0_Pos = 0x0
	// Bit mask of GPIO0 field.
	DEDIC_GPIO_INTR_RAW_GPIO0_Msk = 0x1
	// Bit GPIO0.
	DEDIC_GPIO_INTR_RAW_GPIO0 = 0x1
	// Position of GPIO1 field.
	DEDIC_GPIO_INTR_RAW_GPIO1_Pos = 0x1
	// Bit mask of GPIO1 field.
	DEDIC_GPIO_INTR_RAW_GPIO1_Msk = 0x2
	// Bit GPIO1.
	DEDIC_GPIO_INTR_RAW_GPIO1 = 0x2
	// Position of GPIO2 field.
	DEDIC_GPIO_INTR_RAW_GPIO2_Pos = 0x2
	// Bit mask of GPIO2 field.
	DEDIC_GPIO_INTR_RAW_GPIO2_Msk = 0x4
	// Bit GPIO2.
	DEDIC_GPIO_INTR_RAW_GPIO2 = 0x4
	// Position of GPIO3 field.
	DEDIC_GPIO_INTR_RAW_GPIO3_Pos = 0x3
	// Bit mask of GPIO3 field.
	DEDIC_GPIO_INTR_RAW_GPIO3_Msk = 0x8
	// Bit GPIO3.
	DEDIC_GPIO_INTR_RAW_GPIO3 = 0x8
	// Position of GPIO4 field.
	DEDIC_GPIO_INTR_RAW_GPIO4_Pos = 0x4
	// Bit mask of GPIO4 field.
	DEDIC_GPIO_INTR_RAW_GPIO4_Msk = 0x10
	// Bit GPIO4.
	DEDIC_GPIO_INTR_RAW_GPIO4 = 0x10
	// Position of GPIO5 field.
	DEDIC_GPIO_INTR_RAW_GPIO5_Pos = 0x5
	// Bit mask of GPIO5 field.
	DEDIC_GPIO_INTR_RAW_GPIO5_Msk = 0x20
	// Bit GPIO5.
	DEDIC_GPIO_INTR_RAW_GPIO5 = 0x20
	// Position of GPIO6 field.
	DEDIC_GPIO_INTR_RAW_GPIO6_Pos = 0x6
	// Bit mask of GPIO6 field.
	DEDIC_GPIO_INTR_RAW_GPIO6_Msk = 0x40
	// Bit GPIO6.
	DEDIC_GPIO_INTR_RAW_GPIO6 = 0x40
	// Position of GPIO7 field.
	DEDIC_GPIO_INTR_RAW_GPIO7_Pos = 0x7
	// Bit mask of GPIO7 field.
	DEDIC_GPIO_INTR_RAW_GPIO7_Msk = 0x80
	// Bit GPIO7.
	DEDIC_GPIO_INTR_RAW_GPIO7 = 0x80

	// INTR_RLS: Interrupt enable bits
	// Position of GPIO0_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO0_INT_ENA_Pos = 0x0
	// Bit mask of GPIO0_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO0_INT_ENA_Msk = 0x1
	// Bit GPIO0_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO0_INT_ENA = 0x1
	// Position of GPIO1_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO1_INT_ENA_Pos = 0x1
	// Bit mask of GPIO1_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO1_INT_ENA_Msk = 0x2
	// Bit GPIO1_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO1_INT_ENA = 0x2
	// Position of GPIO2_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO2_INT_ENA_Pos = 0x2
	// Bit mask of GPIO2_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO2_INT_ENA_Msk = 0x4
	// Bit GPIO2_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO2_INT_ENA = 0x4
	// Position of GPIO3_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO3_INT_ENA_Pos = 0x3
	// Bit mask of GPIO3_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO3_INT_ENA_Msk = 0x8
	// Bit GPIO3_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO3_INT_ENA = 0x8
	// Position of GPIO4_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO4_INT_ENA_Pos = 0x4
	// Bit mask of GPIO4_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO4_INT_ENA_Msk = 0x10
	// Bit GPIO4_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO4_INT_ENA = 0x10
	// Position of GPIO5_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO5_INT_ENA_Pos = 0x5
	// Bit mask of GPIO5_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO5_INT_ENA_Msk = 0x20
	// Bit GPIO5_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO5_INT_ENA = 0x20
	// Position of GPIO6_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO6_INT_ENA_Pos = 0x6
	// Bit mask of GPIO6_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO6_INT_ENA_Msk = 0x40
	// Bit GPIO6_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO6_INT_ENA = 0x40
	// Position of GPIO7_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO7_INT_ENA_Pos = 0x7
	// Bit mask of GPIO7_INT_ENA field.
	DEDIC_GPIO_INTR_RLS_GPIO7_INT_ENA_Msk = 0x80
	// Bit GPIO7_INT_ENA.
	DEDIC_GPIO_INTR_RLS_GPIO7_INT_ENA = 0x80

	// INTR_ST: Masked interrupt status
	// Position of GPIO0_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO0_INT_ST_Pos = 0x0
	// Bit mask of GPIO0_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO0_INT_ST_Msk = 0x1
	// Bit GPIO0_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO0_INT_ST = 0x1
	// Position of GPIO1_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO1_INT_ST_Pos = 0x1
	// Bit mask of GPIO1_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO1_INT_ST_Msk = 0x2
	// Bit GPIO1_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO1_INT_ST = 0x2
	// Position of GPIO2_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO2_INT_ST_Pos = 0x2
	// Bit mask of GPIO2_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO2_INT_ST_Msk = 0x4
	// Bit GPIO2_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO2_INT_ST = 0x4
	// Position of GPIO3_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO3_INT_ST_Pos = 0x3
	// Bit mask of GPIO3_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO3_INT_ST_Msk = 0x8
	// Bit GPIO3_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO3_INT_ST = 0x8
	// Position of GPIO4_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO4_INT_ST_Pos = 0x4
	// Bit mask of GPIO4_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO4_INT_ST_Msk = 0x10
	// Bit GPIO4_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO4_INT_ST = 0x10
	// Position of GPIO5_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO5_INT_ST_Pos = 0x5
	// Bit mask of GPIO5_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO5_INT_ST_Msk = 0x20
	// Bit GPIO5_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO5_INT_ST = 0x20
	// Position of GPIO6_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO6_INT_ST_Pos = 0x6
	// Bit mask of GPIO6_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO6_INT_ST_Msk = 0x40
	// Bit GPIO6_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO6_INT_ST = 0x40
	// Position of GPIO7_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO7_INT_ST_Pos = 0x7
	// Bit mask of GPIO7_INT_ST field.
	DEDIC_GPIO_INTR_ST_GPIO7_INT_ST_Msk = 0x80
	// Bit GPIO7_INT_ST.
	DEDIC_GPIO_INTR_ST_GPIO7_INT_ST = 0x80

	// INTR_CLR: Interrupt clear bits
	// Position of GPIO0_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO0_INT_CLR_Pos = 0x0
	// Bit mask of GPIO0_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO0_INT_CLR_Msk = 0x1
	// Bit GPIO0_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO0_INT_CLR = 0x1
	// Position of GPIO1_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO1_INT_CLR_Pos = 0x1
	// Bit mask of GPIO1_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO1_INT_CLR_Msk = 0x2
	// Bit GPIO1_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO1_INT_CLR = 0x2
	// Position of GPIO2_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO2_INT_CLR_Pos = 0x2
	// Bit mask of GPIO2_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO2_INT_CLR_Msk = 0x4
	// Bit GPIO2_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO2_INT_CLR = 0x4
	// Position of GPIO3_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO3_INT_CLR_Pos = 0x3
	// Bit mask of GPIO3_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO3_INT_CLR_Msk = 0x8
	// Bit GPIO3_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO3_INT_CLR = 0x8
	// Position of GPIO4_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO4_INT_CLR_Pos = 0x4
	// Bit mask of GPIO4_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO4_INT_CLR_Msk = 0x10
	// Bit GPIO4_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO4_INT_CLR = 0x10
	// Position of GPIO5_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO5_INT_CLR_Pos = 0x5
	// Bit mask of GPIO5_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO5_INT_CLR_Msk = 0x20
	// Bit GPIO5_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO5_INT_CLR = 0x20
	// Position of GPIO6_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO6_INT_CLR_Pos = 0x6
	// Bit mask of GPIO6_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO6_INT_CLR_Msk = 0x40
	// Bit GPIO6_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO6_INT_CLR = 0x40
	// Position of GPIO7_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO7_INT_CLR_Pos = 0x7
	// Bit mask of GPIO7_INT_CLR field.
	DEDIC_GPIO_INTR_CLR_GPIO7_INT_CLR_Msk = 0x80
	// Bit GPIO7_INT_CLR.
	DEDIC_GPIO_INTR_CLR_GPIO7_INT_CLR = 0x80
)

// Constants for DS: Digital Signature
const (
	// IV_0: IV block data.
	// Position of IV field.
	DS_IV_IV_Pos = 0x0
	// Bit mask of IV field.
	DS_IV_IV_Msk = 0xffffffff

	// SET_START: Activates the DS peripheral
	// Position of SET_START field.
	DS_SET_START_SET_START_Pos = 0x0
	// Bit mask of SET_START field.
	DS_SET_START_SET_START_Msk = 0x1
	// Bit SET_START.
	DS_SET_START_SET_START = 0x1

	// SET_ME: Starts DS operation
	// Position of SET_ME field.
	DS_SET_ME_SET_ME_Pos = 0x0
	// Bit mask of SET_ME field.
	DS_SET_ME_SET_ME_Msk = 0x1
	// Bit SET_ME.
	DS_SET_ME_SET_ME = 0x1

	// SET_FINISH: Ends DS operation
	// Position of SET_FINISH field.
	DS_SET_FINISH_SET_FINISH_Pos = 0x0
	// Bit mask of SET_FINISH field.
	DS_SET_FINISH_SET_FINISH_Msk = 0x1
	// Bit SET_FINISH.
	DS_SET_FINISH_SET_FINISH = 0x1

	// QUERY_BUSY: Status of the DS
	// Position of QUERY_BUSY field.
	DS_QUERY_BUSY_QUERY_BUSY_Pos = 0x0
	// Bit mask of QUERY_BUSY field.
	DS_QUERY_BUSY_QUERY_BUSY_Msk = 0x1
	// Bit QUERY_BUSY.
	DS_QUERY_BUSY_QUERY_BUSY = 0x1

	// QUERY_KEY_WRONG: Checks the reason why DS_KEY is not ready.
	// Position of QUERY_KEY_WRONG field.
	DS_QUERY_KEY_WRONG_QUERY_KEY_WRONG_Pos = 0x0
	// Bit mask of QUERY_KEY_WRONG field.
	DS_QUERY_KEY_WRONG_QUERY_KEY_WRONG_Msk = 0xf

	// QUERY_CHECK: Queries DS check result
	// Position of MD_ERROR field.
	DS_QUERY_CHECK_MD_ERROR_Pos = 0x0
	// Bit mask of MD_ERROR field.
	DS_QUERY_CHECK_MD_ERROR_Msk = 0x1
	// Bit MD_ERROR.
	DS_QUERY_CHECK_MD_ERROR = 0x1
	// Position of PADDING_BAD field.
	DS_QUERY_CHECK_PADDING_BAD_Pos = 0x1
	// Bit mask of PADDING_BAD field.
	DS_QUERY_CHECK_PADDING_BAD_Msk = 0x2
	// Bit PADDING_BAD.
	DS_QUERY_CHECK_PADDING_BAD = 0x2

	// DATE: Version control register
	// Position of DATE field.
	DS_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	DS_DATE_DATE_Msk = 0x3fffffff
)

// Constants for EFUSE: eFuse Controller
const (
	// PGM_DATA0: Register %s that stores data to be programmed.
	// Position of PGM_DATA field.
	EFUSE_PGM_DATA_PGM_DATA_Pos = 0x0
	// Bit mask of PGM_DATA field.
	EFUSE_PGM_DATA_PGM_DATA_Msk = 0xffffffff

	// PGM_CHECK_VALUE0: Register %s that stores the RS code to be programmed.
	// Position of PGM_RS_DATA field.
	EFUSE_PGM_CHECK_VALUE_PGM_RS_DATA_Pos = 0x0
	// Bit mask of PGM_RS_DATA field.
	EFUSE_PGM_CHECK_VALUE_PGM_RS_DATA_Msk = 0xffffffff

	// RD_WR_DIS: Register 0 of BLOCK0.
	// Position of WR_DIS field.
	EFUSE_RD_WR_DIS_WR_DIS_Pos = 0x0
	// Bit mask of WR_DIS field.
	EFUSE_RD_WR_DIS_WR_DIS_Msk = 0xffffffff

	// RD_REPEAT_DATA0: Register 1 of BLOCK0.
	// Position of RD_DIS field.
	EFUSE_RD_REPEAT_DATA0_RD_DIS_Pos = 0x0
	// Bit mask of RD_DIS field.
	EFUSE_RD_REPEAT_DATA0_RD_DIS_Msk = 0x7f
	// Position of DIS_RTC_RAM_BOOT field.
	EFUSE_RD_REPEAT_DATA0_DIS_RTC_RAM_BOOT_Pos = 0x7
	// Bit mask of DIS_RTC_RAM_BOOT field.
	EFUSE_RD_REPEAT_DATA0_DIS_RTC_RAM_BOOT_Msk = 0x80
	// Bit DIS_RTC_RAM_BOOT.
	EFUSE_RD_REPEAT_DATA0_DIS_RTC_RAM_BOOT = 0x80
	// Position of DIS_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE_Pos = 0x8
	// Bit mask of DIS_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE_Msk = 0x100
	// Bit DIS_ICACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_ICACHE = 0x100
	// Position of DIS_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DCACHE_Pos = 0x9
	// Bit mask of DIS_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DCACHE_Msk = 0x200
	// Bit DIS_DCACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_DCACHE = 0x200
	// Position of DIS_DOWNLOAD_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE_Pos = 0xa
	// Bit mask of DIS_DOWNLOAD_ICACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE_Msk = 0x400
	// Bit DIS_DOWNLOAD_ICACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_ICACHE = 0x400
	// Position of DIS_DOWNLOAD_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE_Pos = 0xb
	// Bit mask of DIS_DOWNLOAD_DCACHE field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE_Msk = 0x800
	// Bit DIS_DOWNLOAD_DCACHE.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_DCACHE = 0x800
	// Position of DIS_FORCE_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD_Pos = 0xc
	// Bit mask of DIS_FORCE_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD_Msk = 0x1000
	// Bit DIS_FORCE_DOWNLOAD.
	EFUSE_RD_REPEAT_DATA0_DIS_FORCE_DOWNLOAD = 0x1000
	// Position of DIS_USB field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_Pos = 0xd
	// Bit mask of DIS_USB field.
	EFUSE_RD_REPEAT_DATA0_DIS_USB_Msk = 0x2000
	// Bit DIS_USB.
	EFUSE_RD_REPEAT_DATA0_DIS_USB = 0x2000
	// Position of DIS_CAN field.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN_Pos = 0xe
	// Bit mask of DIS_CAN field.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN_Msk = 0x4000
	// Bit DIS_CAN.
	EFUSE_RD_REPEAT_DATA0_DIS_CAN = 0x4000
	// Position of DIS_BOOT_REMAP field.
	EFUSE_RD_REPEAT_DATA0_DIS_BOOT_REMAP_Pos = 0xf
	// Bit mask of DIS_BOOT_REMAP field.
	EFUSE_RD_REPEAT_DATA0_DIS_BOOT_REMAP_Msk = 0x8000
	// Bit DIS_BOOT_REMAP.
	EFUSE_RD_REPEAT_DATA0_DIS_BOOT_REMAP = 0x8000
	// Position of RPT4_RESERVED5 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED5_Pos = 0x10
	// Bit mask of RPT4_RESERVED5 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED5_Msk = 0x10000
	// Bit RPT4_RESERVED5.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED5 = 0x10000
	// Position of SOFT_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG_Pos = 0x11
	// Bit mask of SOFT_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG_Msk = 0x20000
	// Bit SOFT_DIS_JTAG.
	EFUSE_RD_REPEAT_DATA0_SOFT_DIS_JTAG = 0x20000
	// Position of HARD_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_HARD_DIS_JTAG_Pos = 0x12
	// Bit mask of HARD_DIS_JTAG field.
	EFUSE_RD_REPEAT_DATA0_HARD_DIS_JTAG_Msk = 0x40000
	// Bit HARD_DIS_JTAG.
	EFUSE_RD_REPEAT_DATA0_HARD_DIS_JTAG = 0x40000
	// Position of DIS_DOWNLOAD_MANUAL_ENCRYPT field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT_Pos = 0x13
	// Bit mask of DIS_DOWNLOAD_MANUAL_ENCRYPT field.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT_Msk = 0x80000
	// Bit DIS_DOWNLOAD_MANUAL_ENCRYPT.
	EFUSE_RD_REPEAT_DATA0_DIS_DOWNLOAD_MANUAL_ENCRYPT = 0x80000
	// Position of USB_DREFH field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFH_Pos = 0x14
	// Bit mask of USB_DREFH field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFH_Msk = 0x300000
	// Position of USB_DREFL field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFL_Pos = 0x16
	// Bit mask of USB_DREFL field.
	EFUSE_RD_REPEAT_DATA0_USB_DREFL_Msk = 0xc00000
	// Position of USB_EXCHG_PINS field.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS_Pos = 0x18
	// Bit mask of USB_EXCHG_PINS field.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS_Msk = 0x1000000
	// Bit USB_EXCHG_PINS.
	EFUSE_RD_REPEAT_DATA0_USB_EXCHG_PINS = 0x1000000
	// Position of EXT_PHY_ENABLE field.
	EFUSE_RD_REPEAT_DATA0_EXT_PHY_ENABLE_Pos = 0x19
	// Bit mask of EXT_PHY_ENABLE field.
	EFUSE_RD_REPEAT_DATA0_EXT_PHY_ENABLE_Msk = 0x2000000
	// Bit EXT_PHY_ENABLE.
	EFUSE_RD_REPEAT_DATA0_EXT_PHY_ENABLE = 0x2000000
	// Position of USB_FORCE_NOPERSIST field.
	EFUSE_RD_REPEAT_DATA0_USB_FORCE_NOPERSIST_Pos = 0x1a
	// Bit mask of USB_FORCE_NOPERSIST field.
	EFUSE_RD_REPEAT_DATA0_USB_FORCE_NOPERSIST_Msk = 0x4000000
	// Bit USB_FORCE_NOPERSIST.
	EFUSE_RD_REPEAT_DATA0_USB_FORCE_NOPERSIST = 0x4000000
	// Position of RPT4_RESERVED0 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_Pos = 0x1b
	// Bit mask of RPT4_RESERVED0 field.
	EFUSE_RD_REPEAT_DATA0_RPT4_RESERVED0_Msk = 0x18000000
	// Position of VDD_SPI_MODECURLIM field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_MODECURLIM_Pos = 0x1d
	// Bit mask of VDD_SPI_MODECURLIM field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_MODECURLIM_Msk = 0x20000000
	// Bit VDD_SPI_MODECURLIM.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_MODECURLIM = 0x20000000
	// Position of VDD_SPI_DREFH field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_DREFH_Pos = 0x1e
	// Bit mask of VDD_SPI_DREFH field.
	EFUSE_RD_REPEAT_DATA0_VDD_SPI_DREFH_Msk = 0xc0000000

	// RD_REPEAT_DATA1: Register 2 of BLOCK0.
	// Position of VDD_SPI_DREFM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFM_Pos = 0x0
	// Bit mask of VDD_SPI_DREFM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFM_Msk = 0x3
	// Position of VDD_SPI_DREFL field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFL_Pos = 0x2
	// Bit mask of VDD_SPI_DREFL field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DREFL_Msk = 0xc
	// Position of VDD_SPI_XPD field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_XPD_Pos = 0x4
	// Bit mask of VDD_SPI_XPD field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_XPD_Msk = 0x10
	// Bit VDD_SPI_XPD.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_XPD = 0x10
	// Position of VDD_SPI_TIEH field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_TIEH_Pos = 0x5
	// Bit mask of VDD_SPI_TIEH field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_TIEH_Msk = 0x20
	// Bit VDD_SPI_TIEH.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_TIEH = 0x20
	// Position of VDD_SPI_FORCE field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_FORCE_Pos = 0x6
	// Bit mask of VDD_SPI_FORCE field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_FORCE_Msk = 0x40
	// Bit VDD_SPI_FORCE.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_FORCE = 0x40
	// Position of VDD_SPI_EN_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_EN_INIT_Pos = 0x7
	// Bit mask of VDD_SPI_EN_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_EN_INIT_Msk = 0x80
	// Bit VDD_SPI_EN_INIT.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_EN_INIT = 0x80
	// Position of VDD_SPI_ENCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_ENCURLIM_Pos = 0x8
	// Bit mask of VDD_SPI_ENCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_ENCURLIM_Msk = 0x100
	// Bit VDD_SPI_ENCURLIM.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_ENCURLIM = 0x100
	// Position of VDD_SPI_DCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCURLIM_Pos = 0x9
	// Bit mask of VDD_SPI_DCURLIM field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCURLIM_Msk = 0xe00
	// Position of VDD_SPI_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_INIT_Pos = 0xc
	// Bit mask of VDD_SPI_INIT field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_INIT_Msk = 0x3000
	// Position of VDD_SPI_DCAP field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCAP_Pos = 0xe
	// Bit mask of VDD_SPI_DCAP field.
	EFUSE_RD_REPEAT_DATA1_VDD_SPI_DCAP_Msk = 0xc000
	// Position of WDT_DELAY_SEL field.
	EFUSE_RD_REPEAT_DATA1_WDT_DELAY_SEL_Pos = 0x10
	// Bit mask of WDT_DELAY_SEL field.
	EFUSE_RD_REPEAT_DATA1_WDT_DELAY_SEL_Msk = 0x30000
	// Position of SPI_BOOT_CRYPT_CNT field.
	EFUSE_RD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT_Pos = 0x12
	// Bit mask of SPI_BOOT_CRYPT_CNT field.
	EFUSE_RD_REPEAT_DATA1_SPI_BOOT_CRYPT_CNT_Msk = 0x1c0000
	// Position of SECURE_BOOT_KEY_REVOKE0 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0_Pos = 0x15
	// Bit mask of SECURE_BOOT_KEY_REVOKE0 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0_Msk = 0x200000
	// Bit SECURE_BOOT_KEY_REVOKE0.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE0 = 0x200000
	// Position of SECURE_BOOT_KEY_REVOKE1 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1_Pos = 0x16
	// Bit mask of SECURE_BOOT_KEY_REVOKE1 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1_Msk = 0x400000
	// Bit SECURE_BOOT_KEY_REVOKE1.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE1 = 0x400000
	// Position of SECURE_BOOT_KEY_REVOKE2 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2_Pos = 0x17
	// Bit mask of SECURE_BOOT_KEY_REVOKE2 field.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2_Msk = 0x800000
	// Bit SECURE_BOOT_KEY_REVOKE2.
	EFUSE_RD_REPEAT_DATA1_SECURE_BOOT_KEY_REVOKE2 = 0x800000
	// Position of KEY_PURPOSE_0 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_0_Pos = 0x18
	// Bit mask of KEY_PURPOSE_0 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_0_Msk = 0xf000000
	// Position of KEY_PURPOSE_1 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_1_Pos = 0x1c
	// Bit mask of KEY_PURPOSE_1 field.
	EFUSE_RD_REPEAT_DATA1_KEY_PURPOSE_1_Msk = 0xf0000000

	// RD_REPEAT_DATA2: Register 3 of BLOCK0.
	// Position of KEY_PURPOSE_2 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_2_Pos = 0x0
	// Bit mask of KEY_PURPOSE_2 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_2_Msk = 0xf
	// Position of KEY_PURPOSE_3 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_3_Pos = 0x4
	// Bit mask of KEY_PURPOSE_3 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_3_Msk = 0xf0
	// Position of KEY_PURPOSE_4 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_4_Pos = 0x8
	// Bit mask of KEY_PURPOSE_4 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_4_Msk = 0xf00
	// Position of KEY_PURPOSE_5 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_5_Pos = 0xc
	// Bit mask of KEY_PURPOSE_5 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_5_Msk = 0xf000
	// Position of KEY_PURPOSE_6 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_6_Pos = 0x10
	// Bit mask of KEY_PURPOSE_6 field.
	EFUSE_RD_REPEAT_DATA2_KEY_PURPOSE_6_Msk = 0xf0000
	// Position of SECURE_BOOT_EN field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN_Pos = 0x14
	// Bit mask of SECURE_BOOT_EN field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN_Msk = 0x100000
	// Bit SECURE_BOOT_EN.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_EN = 0x100000
	// Position of SECURE_BOOT_AGGRESSIVE_REVOKE field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE_Pos = 0x15
	// Bit mask of SECURE_BOOT_AGGRESSIVE_REVOKE field.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE_Msk = 0x200000
	// Bit SECURE_BOOT_AGGRESSIVE_REVOKE.
	EFUSE_RD_REPEAT_DATA2_SECURE_BOOT_AGGRESSIVE_REVOKE = 0x200000
	// Position of RPT4_RESERVED1 field.
	EFUSE_RD_REPEAT_DATA2_RPT4_RESERVED1_Pos = 0x16
	// Bit mask of RPT4_RESERVED1 field.
	EFUSE_RD_REPEAT_DATA2_RPT4_RESERVED1_Msk = 0xfc00000
	// Position of FLASH_TPUW field.
	EFUSE_RD_REPEAT_DATA2_FLASH_TPUW_Pos = 0x1c
	// Bit mask of FLASH_TPUW field.
	EFUSE_RD_REPEAT_DATA2_FLASH_TPUW_Msk = 0xf0000000

	// RD_REPEAT_DATA3: Register 4 of BLOCK0.
	// Position of DIS_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE_Pos = 0x0
	// Bit mask of DIS_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE_Msk = 0x1
	// Bit DIS_DOWNLOAD_MODE.
	EFUSE_RD_REPEAT_DATA3_DIS_DOWNLOAD_MODE = 0x1
	// Position of DIS_LEGACY_SPI_BOOT field.
	EFUSE_RD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT_Pos = 0x1
	// Bit mask of DIS_LEGACY_SPI_BOOT field.
	EFUSE_RD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT_Msk = 0x2
	// Bit DIS_LEGACY_SPI_BOOT.
	EFUSE_RD_REPEAT_DATA3_DIS_LEGACY_SPI_BOOT = 0x2
	// Position of UART_PRINT_CHANNEL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CHANNEL_Pos = 0x2
	// Bit mask of UART_PRINT_CHANNEL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CHANNEL_Msk = 0x4
	// Bit UART_PRINT_CHANNEL.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CHANNEL = 0x4
	// Position of RPT4_RESERVED3 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_Pos = 0x3
	// Bit mask of RPT4_RESERVED3 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3_Msk = 0x8
	// Bit RPT4_RESERVED3.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED3 = 0x8
	// Position of DIS_USB_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE_Pos = 0x4
	// Bit mask of DIS_USB_DOWNLOAD_MODE field.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE_Msk = 0x10
	// Bit DIS_USB_DOWNLOAD_MODE.
	EFUSE_RD_REPEAT_DATA3_DIS_USB_DOWNLOAD_MODE = 0x10
	// Position of ENABLE_SECURITY_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD_Pos = 0x5
	// Bit mask of ENABLE_SECURITY_DOWNLOAD field.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD_Msk = 0x20
	// Bit ENABLE_SECURITY_DOWNLOAD.
	EFUSE_RD_REPEAT_DATA3_ENABLE_SECURITY_DOWNLOAD = 0x20
	// Position of UART_PRINT_CONTROL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CONTROL_Pos = 0x6
	// Bit mask of UART_PRINT_CONTROL field.
	EFUSE_RD_REPEAT_DATA3_UART_PRINT_CONTROL_Msk = 0xc0
	// Position of PIN_POWER_SELECTION field.
	EFUSE_RD_REPEAT_DATA3_PIN_POWER_SELECTION_Pos = 0x8
	// Bit mask of PIN_POWER_SELECTION field.
	EFUSE_RD_REPEAT_DATA3_PIN_POWER_SELECTION_Msk = 0x100
	// Bit PIN_POWER_SELECTION.
	EFUSE_RD_REPEAT_DATA3_PIN_POWER_SELECTION = 0x100
	// Position of FLASH_TYPE field.
	EFUSE_RD_REPEAT_DATA3_FLASH_TYPE_Pos = 0x9
	// Bit mask of FLASH_TYPE field.
	EFUSE_RD_REPEAT_DATA3_FLASH_TYPE_Msk = 0x200
	// Bit FLASH_TYPE.
	EFUSE_RD_REPEAT_DATA3_FLASH_TYPE = 0x200
	// Position of FORCE_SEND_RESUME field.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME_Pos = 0xa
	// Bit mask of FORCE_SEND_RESUME field.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME_Msk = 0x400
	// Bit FORCE_SEND_RESUME.
	EFUSE_RD_REPEAT_DATA3_FORCE_SEND_RESUME = 0x400
	// Position of SECURE_VERSION field.
	EFUSE_RD_REPEAT_DATA3_SECURE_VERSION_Pos = 0xb
	// Bit mask of SECURE_VERSION field.
	EFUSE_RD_REPEAT_DATA3_SECURE_VERSION_Msk = 0x7fff800
	// Position of RPT4_RESERVED2 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED2_Pos = 0x1b
	// Bit mask of RPT4_RESERVED2 field.
	EFUSE_RD_REPEAT_DATA3_RPT4_RESERVED2_Msk = 0xf8000000

	// RD_REPEAT_DATA4: Register 5 of BLOCK0.
	// Position of RPT4_RESERVED4 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_Pos = 0x0
	// Bit mask of RPT4_RESERVED4 field.
	EFUSE_RD_REPEAT_DATA4_RPT4_RESERVED4_Msk = 0xffffff

	// RD_MAC_SPI_SYS_0: Register 0 of BLOCK1.
	// Position of MAC_0 field.
	EFUSE_RD_MAC_SPI_SYS_0_MAC_0_Pos = 0x0
	// Bit mask of MAC_0 field.
	EFUSE_RD_MAC_SPI_SYS_0_MAC_0_Msk = 0xffffffff

	// RD_MAC_SPI_SYS_1: Register 1 of BLOCK1.
	// Position of MAC_1 field.
	EFUSE_RD_MAC_SPI_SYS_1_MAC_1_Pos = 0x0
	// Bit mask of MAC_1 field.
	EFUSE_RD_MAC_SPI_SYS_1_MAC_1_Msk = 0xffff
	// Position of SPI_PAD_CONF_0 field.
	EFUSE_RD_MAC_SPI_SYS_1_SPI_PAD_CONF_0_Pos = 0x10
	// Bit mask of SPI_PAD_CONF_0 field.
	EFUSE_RD_MAC_SPI_SYS_1_SPI_PAD_CONF_0_Msk = 0xffff0000

	// RD_MAC_SPI_SYS_2: Register 2 of BLOCK1.
	// Position of SPI_PAD_CONF_1 field.
	EFUSE_RD_MAC_SPI_SYS_2_SPI_PAD_CONF_1_Pos = 0x0
	// Bit mask of SPI_PAD_CONF_1 field.
	EFUSE_RD_MAC_SPI_SYS_2_SPI_PAD_CONF_1_Msk = 0xffffffff

	// RD_MAC_SPI_SYS_3: Register 3 of BLOCK1.
	// Position of SPI_PAD_CONF_2 field.
	EFUSE_RD_MAC_SPI_SYS_3_SPI_PAD_CONF_2_Pos = 0x0
	// Bit mask of SPI_PAD_CONF_2 field.
	EFUSE_RD_MAC_SPI_SYS_3_SPI_PAD_CONF_2_Msk = 0x3ffff
	// Position of SYS_DATA_PART0_0 field.
	EFUSE_RD_MAC_SPI_SYS_3_SYS_DATA_PART0_0_Pos = 0x12
	// Bit mask of SYS_DATA_PART0_0 field.
	EFUSE_RD_MAC_SPI_SYS_3_SYS_DATA_PART0_0_Msk = 0xfffc0000

	// RD_MAC_SPI_SYS_4: Register 4 of BLOCK1.
	// Position of SYS_DATA_PART0_1 field.
	EFUSE_RD_MAC_SPI_SYS_4_SYS_DATA_PART0_1_Pos = 0x0
	// Bit mask of SYS_DATA_PART0_1 field.
	EFUSE_RD_MAC_SPI_SYS_4_SYS_DATA_PART0_1_Msk = 0xffffffff

	// RD_MAC_SPI_SYS_5: Register 5 of BLOCK1.
	// Position of SYS_DATA_PART0_2 field.
	EFUSE_RD_MAC_SPI_SYS_5_SYS_DATA_PART0_2_Pos = 0x0
	// Bit mask of SYS_DATA_PART0_2 field.
	EFUSE_RD_MAC_SPI_SYS_5_SYS_DATA_PART0_2_Msk = 0xffffffff

	// RD_SYS_DATA_PART1_0: Register %s of BLOCK2 (system).
	// Position of SYS_DATA_PART1 field.
	EFUSE_RD_SYS_DATA_PART1_SYS_DATA_PART1_Pos = 0x0
	// Bit mask of SYS_DATA_PART1 field.
	EFUSE_RD_SYS_DATA_PART1_SYS_DATA_PART1_Msk = 0xffffffff

	// RD_USR_DATA0: Register %s of BLOCK3 (user).
	// Position of USR_DATA field.
	EFUSE_RD_USR_DATA_USR_DATA_Pos = 0x0
	// Bit mask of USR_DATA field.
	EFUSE_RD_USR_DATA_USR_DATA_Msk = 0xffffffff

	// RD_KEY0_DATA0: Register %s of BLOCK4 (KEY0).
	// Position of KEY0_DATA field.
	EFUSE_RD_KEY0_DATA_KEY0_DATA_Pos = 0x0
	// Bit mask of KEY0_DATA field.
	EFUSE_RD_KEY0_DATA_KEY0_DATA_Msk = 0xffffffff

	// RD_KEY1_DATA0: Register %s of BLOCK5 (KEY1).
	// Position of KEY1_DATA field.
	EFUSE_RD_KEY1_DATA_KEY1_DATA_Pos = 0x0
	// Bit mask of KEY1_DATA field.
	EFUSE_RD_KEY1_DATA_KEY1_DATA_Msk = 0xffffffff

	// RD_KEY2_DATA0: Register %s of BLOCK6 (KEY2).
	// Position of KEY2_DATA field.
	EFUSE_RD_KEY2_DATA_KEY2_DATA_Pos = 0x0
	// Bit mask of KEY2_DATA field.
	EFUSE_RD_KEY2_DATA_KEY2_DATA_Msk = 0xffffffff

	// RD_KEY3_DATA0: Register %s of BLOCK7 (KEY3).
	// Position of KEY3_DATA field.
	EFUSE_RD_KEY3_DATA_KEY3_DATA_Pos = 0x0
	// Bit mask of KEY3_DATA field.
	EFUSE_RD_KEY3_DATA_KEY3_DATA_Msk = 0xffffffff

	// RD_KEY4_DATA0: Register %s of BLOCK8 (KEY4).
	// Position of KEY4_DATA field.
	EFUSE_RD_KEY4_DATA_KEY4_DATA_Pos = 0x0
	// Bit mask of KEY4_DATA field.
	EFUSE_RD_KEY4_DATA_KEY4_DATA_Msk = 0xffffffff

	// RD_KEY5_DATA0: Register %s of BLOCK9 (KEY5).
	// Position of KEY5_DATA field.
	EFUSE_RD_KEY5_DATA_KEY5_DATA_Pos = 0x0
	// Bit mask of KEY5_DATA field.
	EFUSE_RD_KEY5_DATA_KEY5_DATA_Msk = 0xffffffff

	// RD_SYS_DATA_PART2_0: Register %s of BLOCK10 (system).
	// Position of SYS_DATA_PART2 field.
	EFUSE_RD_SYS_DATA_PART2_SYS_DATA_PART2_Pos = 0x0
	// Bit mask of SYS_DATA_PART2 field.
	EFUSE_RD_SYS_DATA_PART2_SYS_DATA_PART2_Msk = 0xffffffff

	// RD_REPEAT_ERR0: Programming error record register 0 of BLOCK0.
	// Position of RD_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_RD_DIS_ERR_Pos = 0x0
	// Bit mask of RD_DIS_ERR field.
	EFUSE_RD_REPEAT_ERR0_RD_DIS_ERR_Msk = 0x7f
	// Position of DIS_RTC_RAM_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR_Pos = 0x7
	// Bit mask of DIS_RTC_RAM_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR_Msk = 0x80
	// Bit DIS_RTC_RAM_BOOT_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_RTC_RAM_BOOT_ERR = 0x80
	// Position of DIS_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR_Pos = 0x8
	// Bit mask of DIS_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR_Msk = 0x100
	// Bit DIS_ICACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_ICACHE_ERR = 0x100
	// Position of DIS_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DCACHE_ERR_Pos = 0x9
	// Bit mask of DIS_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DCACHE_ERR_Msk = 0x200
	// Bit DIS_DCACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DCACHE_ERR = 0x200
	// Position of DIS_DOWNLOAD_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR_Pos = 0xa
	// Bit mask of DIS_DOWNLOAD_ICACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR_Msk = 0x400
	// Bit DIS_DOWNLOAD_ICACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_ICACHE_ERR = 0x400
	// Position of DIS_DOWNLOAD_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR_Pos = 0xb
	// Bit mask of DIS_DOWNLOAD_DCACHE_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR_Msk = 0x800
	// Bit DIS_DOWNLOAD_DCACHE_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_DCACHE_ERR = 0x800
	// Position of DIS_FORCE_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR_Pos = 0xc
	// Bit mask of DIS_FORCE_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR_Msk = 0x1000
	// Bit DIS_FORCE_DOWNLOAD_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_FORCE_DOWNLOAD_ERR = 0x1000
	// Position of DIS_USB_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_ERR_Pos = 0xd
	// Bit mask of DIS_USB_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_ERR_Msk = 0x2000
	// Bit DIS_USB_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_USB_ERR = 0x2000
	// Position of DIS_CAN_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_CAN_ERR_Pos = 0xe
	// Bit mask of DIS_CAN_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_CAN_ERR_Msk = 0x4000
	// Bit DIS_CAN_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_CAN_ERR = 0x4000
	// Position of DIS_BOOT_REMAP_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR_Pos = 0xf
	// Bit mask of DIS_BOOT_REMAP_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR_Msk = 0x8000
	// Bit DIS_BOOT_REMAP_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_BOOT_REMAP_ERR = 0x8000
	// Position of RPT4_RESERVED5_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED5_ERR_Pos = 0x10
	// Bit mask of RPT4_RESERVED5_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED5_ERR_Msk = 0x10000
	// Bit RPT4_RESERVED5_ERR.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED5_ERR = 0x10000
	// Position of SOFT_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR_Pos = 0x11
	// Bit mask of SOFT_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR_Msk = 0x20000
	// Bit SOFT_DIS_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_SOFT_DIS_JTAG_ERR = 0x20000
	// Position of HARD_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_HARD_DIS_JTAG_ERR_Pos = 0x12
	// Bit mask of HARD_DIS_JTAG_ERR field.
	EFUSE_RD_REPEAT_ERR0_HARD_DIS_JTAG_ERR_Msk = 0x40000
	// Bit HARD_DIS_JTAG_ERR.
	EFUSE_RD_REPEAT_ERR0_HARD_DIS_JTAG_ERR = 0x40000
	// Position of DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR_Pos = 0x13
	// Bit mask of DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR field.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR_Msk = 0x80000
	// Bit DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR.
	EFUSE_RD_REPEAT_ERR0_DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR = 0x80000
	// Position of USB_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFH_ERR_Pos = 0x14
	// Bit mask of USB_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFH_ERR_Msk = 0x300000
	// Position of USB_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFL_ERR_Pos = 0x16
	// Bit mask of USB_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_DREFL_ERR_Msk = 0xc00000
	// Position of USB_EXCHG_PINS_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR_Pos = 0x18
	// Bit mask of USB_EXCHG_PINS_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR_Msk = 0x1000000
	// Bit USB_EXCHG_PINS_ERR.
	EFUSE_RD_REPEAT_ERR0_USB_EXCHG_PINS_ERR = 0x1000000
	// Position of EXT_PHY_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR_Pos = 0x19
	// Bit mask of EXT_PHY_ENABLE_ERR field.
	EFUSE_RD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR_Msk = 0x2000000
	// Bit EXT_PHY_ENABLE_ERR.
	EFUSE_RD_REPEAT_ERR0_EXT_PHY_ENABLE_ERR = 0x2000000
	// Position of USB_FORCE_NOPERSIST_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR_Pos = 0x1a
	// Bit mask of USB_FORCE_NOPERSIST_ERR field.
	EFUSE_RD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR_Msk = 0x4000000
	// Bit USB_FORCE_NOPERSIST_ERR.
	EFUSE_RD_REPEAT_ERR0_USB_FORCE_NOPERSIST_ERR = 0x4000000
	// Position of RPT4_RESERVED0_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_Pos = 0x1b
	// Bit mask of RPT4_RESERVED0_ERR field.
	EFUSE_RD_REPEAT_ERR0_RPT4_RESERVED0_ERR_Msk = 0x18000000
	// Position of VDD_SPI_MODECURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR_Pos = 0x1d
	// Bit mask of VDD_SPI_MODECURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR_Msk = 0x20000000
	// Bit VDD_SPI_MODECURLIM_ERR.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_MODECURLIM_ERR = 0x20000000
	// Position of VDD_SPI_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_DREFH_ERR_Pos = 0x1e
	// Bit mask of VDD_SPI_DREFH_ERR field.
	EFUSE_RD_REPEAT_ERR0_VDD_SPI_DREFH_ERR_Msk = 0xc0000000

	// RD_REPEAT_ERR1: Programming error record register 1 of BLOCK0.
	// Position of VDD_SPI_DREFM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFM_ERR_Pos = 0x0
	// Bit mask of VDD_SPI_DREFM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFM_ERR_Msk = 0x3
	// Position of VDD_SPI_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFL_ERR_Pos = 0x2
	// Bit mask of VDD_SPI_DREFL_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DREFL_ERR_Msk = 0xc
	// Position of VDD_SPI_XPD_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_XPD_ERR_Pos = 0x4
	// Bit mask of VDD_SPI_XPD_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_XPD_ERR_Msk = 0x10
	// Bit VDD_SPI_XPD_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_XPD_ERR = 0x10
	// Position of VDD_SPI_TIEH_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_TIEH_ERR_Pos = 0x5
	// Bit mask of VDD_SPI_TIEH_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_TIEH_ERR_Msk = 0x20
	// Bit VDD_SPI_TIEH_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_TIEH_ERR = 0x20
	// Position of VDD_SPI_FORCE_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_FORCE_ERR_Pos = 0x6
	// Bit mask of VDD_SPI_FORCE_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_FORCE_ERR_Msk = 0x40
	// Bit VDD_SPI_FORCE_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_FORCE_ERR = 0x40
	// Position of VDD_SPI_EN_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR_Pos = 0x7
	// Bit mask of VDD_SPI_EN_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR_Msk = 0x80
	// Bit VDD_SPI_EN_INIT_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_EN_INIT_ERR = 0x80
	// Position of VDD_SPI_ENCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR_Pos = 0x8
	// Bit mask of VDD_SPI_ENCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR_Msk = 0x100
	// Bit VDD_SPI_ENCURLIM_ERR.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_ENCURLIM_ERR = 0x100
	// Position of VDD_SPI_DCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR_Pos = 0x9
	// Bit mask of VDD_SPI_DCURLIM_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCURLIM_ERR_Msk = 0xe00
	// Position of VDD_SPI_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_INIT_ERR_Pos = 0xc
	// Bit mask of VDD_SPI_INIT_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_INIT_ERR_Msk = 0x3000
	// Position of VDD_SPI_DCAP_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCAP_ERR_Pos = 0xe
	// Bit mask of VDD_SPI_DCAP_ERR field.
	EFUSE_RD_REPEAT_ERR1_VDD_SPI_DCAP_ERR_Msk = 0xc000
	// Position of WDT_DELAY_SEL_ERR field.
	EFUSE_RD_REPEAT_ERR1_WDT_DELAY_SEL_ERR_Pos = 0x10
	// Bit mask of WDT_DELAY_SEL_ERR field.
	EFUSE_RD_REPEAT_ERR1_WDT_DELAY_SEL_ERR_Msk = 0x30000
	// Position of SPI_BOOT_CRYPT_CNT_ERR field.
	EFUSE_RD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR_Pos = 0x12
	// Bit mask of SPI_BOOT_CRYPT_CNT_ERR field.
	EFUSE_RD_REPEAT_ERR1_SPI_BOOT_CRYPT_CNT_ERR_Msk = 0x1c0000
	// Position of SECURE_BOOT_KEY_REVOKE0_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR_Pos = 0x15
	// Bit mask of SECURE_BOOT_KEY_REVOKE0_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR_Msk = 0x200000
	// Bit SECURE_BOOT_KEY_REVOKE0_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE0_ERR = 0x200000
	// Position of SECURE_BOOT_KEY_REVOKE1_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR_Pos = 0x16
	// Bit mask of SECURE_BOOT_KEY_REVOKE1_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR_Msk = 0x400000
	// Bit SECURE_BOOT_KEY_REVOKE1_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE1_ERR = 0x400000
	// Position of SECURE_BOOT_KEY_REVOKE2_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR_Pos = 0x17
	// Bit mask of SECURE_BOOT_KEY_REVOKE2_ERR field.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR_Msk = 0x800000
	// Bit SECURE_BOOT_KEY_REVOKE2_ERR.
	EFUSE_RD_REPEAT_ERR1_SECURE_BOOT_KEY_REVOKE2_ERR = 0x800000
	// Position of KEY_PURPOSE_0_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_0_ERR_Pos = 0x18
	// Bit mask of KEY_PURPOSE_0_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_0_ERR_Msk = 0xf000000
	// Position of KEY_PURPOSE_1_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_1_ERR_Pos = 0x1c
	// Bit mask of KEY_PURPOSE_1_ERR field.
	EFUSE_RD_REPEAT_ERR1_KEY_PURPOSE_1_ERR_Msk = 0xf0000000

	// RD_REPEAT_ERR2: Programming error record register 2 of BLOCK0.
	// Position of KEY_PURPOSE_2_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_2_ERR_Pos = 0x0
	// Bit mask of KEY_PURPOSE_2_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_2_ERR_Msk = 0xf
	// Position of KEY_PURPOSE_3_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_3_ERR_Pos = 0x4
	// Bit mask of KEY_PURPOSE_3_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_3_ERR_Msk = 0xf0
	// Position of KEY_PURPOSE_4_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_4_ERR_Pos = 0x8
	// Bit mask of KEY_PURPOSE_4_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_4_ERR_Msk = 0xf00
	// Position of KEY_PURPOSE_5_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_5_ERR_Pos = 0xc
	// Bit mask of KEY_PURPOSE_5_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_5_ERR_Msk = 0xf000
	// Position of KEY_PURPOSE_6_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_6_ERR_Pos = 0x10
	// Bit mask of KEY_PURPOSE_6_ERR field.
	EFUSE_RD_REPEAT_ERR2_KEY_PURPOSE_6_ERR_Msk = 0xf0000
	// Position of SECURE_BOOT_EN_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR_Pos = 0x14
	// Bit mask of SECURE_BOOT_EN_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR_Msk = 0x100000
	// Bit SECURE_BOOT_EN_ERR.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_EN_ERR = 0x100000
	// Position of SECURE_BOOT_AGGRESSIVE_REVOKE_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR_Pos = 0x15
	// Bit mask of SECURE_BOOT_AGGRESSIVE_REVOKE_ERR field.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR_Msk = 0x200000
	// Bit SECURE_BOOT_AGGRESSIVE_REVOKE_ERR.
	EFUSE_RD_REPEAT_ERR2_SECURE_BOOT_AGGRESSIVE_REVOKE_ERR = 0x200000
	// Position of RPT4_RESERVED1_ERR field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED1_ERR_Pos = 0x16
	// Bit mask of RPT4_RESERVED1_ERR field.
	EFUSE_RD_REPEAT_ERR2_RPT4_RESERVED1_ERR_Msk = 0xfc00000
	// Position of FLASH_TPUW_ERR field.
	EFUSE_RD_REPEAT_ERR2_FLASH_TPUW_ERR_Pos = 0x1c
	// Bit mask of FLASH_TPUW_ERR field.
	EFUSE_RD_REPEAT_ERR2_FLASH_TPUW_ERR_Msk = 0xf0000000

	// RD_REPEAT_ERR3: Programming error record register 3 of BLOCK0.
	// Position of DIS_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR_Pos = 0x0
	// Bit mask of DIS_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR_Msk = 0x1
	// Bit DIS_DOWNLOAD_MODE_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_DOWNLOAD_MODE_ERR = 0x1
	// Position of DIS_LEGACY_SPI_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR_Pos = 0x1
	// Bit mask of DIS_LEGACY_SPI_BOOT_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR_Msk = 0x2
	// Bit DIS_LEGACY_SPI_BOOT_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_LEGACY_SPI_BOOT_ERR = 0x2
	// Position of UART_PRINT_CHANNEL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR_Pos = 0x2
	// Bit mask of UART_PRINT_CHANNEL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR_Msk = 0x4
	// Bit UART_PRINT_CHANNEL_ERR.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CHANNEL_ERR = 0x4
	// Position of RPT4_RESERVED3_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_Pos = 0x3
	// Bit mask of RPT4_RESERVED3_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR_Msk = 0x8
	// Bit RPT4_RESERVED3_ERR.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED3_ERR = 0x8
	// Position of DIS_USB_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR_Pos = 0x4
	// Bit mask of DIS_USB_DOWNLOAD_MODE_ERR field.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR_Msk = 0x10
	// Bit DIS_USB_DOWNLOAD_MODE_ERR.
	EFUSE_RD_REPEAT_ERR3_DIS_USB_DOWNLOAD_MODE_ERR = 0x10
	// Position of ENABLE_SECURITY_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR_Pos = 0x5
	// Bit mask of ENABLE_SECURITY_DOWNLOAD_ERR field.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR_Msk = 0x20
	// Bit ENABLE_SECURITY_DOWNLOAD_ERR.
	EFUSE_RD_REPEAT_ERR3_ENABLE_SECURITY_DOWNLOAD_ERR = 0x20
	// Position of UART_PRINT_CONTROL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR_Pos = 0x6
	// Bit mask of UART_PRINT_CONTROL_ERR field.
	EFUSE_RD_REPEAT_ERR3_UART_PRINT_CONTROL_ERR_Msk = 0xc0
	// Position of PIN_POWER_SELECTION_ERR field.
	EFUSE_RD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR_Pos = 0x8
	// Bit mask of PIN_POWER_SELECTION_ERR field.
	EFUSE_RD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR_Msk = 0x100
	// Bit PIN_POWER_SELECTION_ERR.
	EFUSE_RD_REPEAT_ERR3_PIN_POWER_SELECTION_ERR = 0x100
	// Position of FLASH_TYPE_ERR field.
	EFUSE_RD_REPEAT_ERR3_FLASH_TYPE_ERR_Pos = 0x9
	// Bit mask of FLASH_TYPE_ERR field.
	EFUSE_RD_REPEAT_ERR3_FLASH_TYPE_ERR_Msk = 0x200
	// Bit FLASH_TYPE_ERR.
	EFUSE_RD_REPEAT_ERR3_FLASH_TYPE_ERR = 0x200
	// Position of FORCE_SEND_RESUME_ERR field.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR_Pos = 0xa
	// Bit mask of FORCE_SEND_RESUME_ERR field.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR_Msk = 0x400
	// Bit FORCE_SEND_RESUME_ERR.
	EFUSE_RD_REPEAT_ERR3_FORCE_SEND_RESUME_ERR = 0x400
	// Position of SECURE_VERSION_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_VERSION_ERR_Pos = 0xb
	// Bit mask of SECURE_VERSION_ERR field.
	EFUSE_RD_REPEAT_ERR3_SECURE_VERSION_ERR_Msk = 0x7fff800
	// Position of RPT4_RESERVED2_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED2_ERR_Pos = 0x1b
	// Bit mask of RPT4_RESERVED2_ERR field.
	EFUSE_RD_REPEAT_ERR3_RPT4_RESERVED2_ERR_Msk = 0xf8000000

	// RD_REPEAT_ERR4: Programming error record register 4 of BLOCK0.
	// Position of RPT4_RESERVED4_ERR field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_Pos = 0x0
	// Bit mask of RPT4_RESERVED4_ERR field.
	EFUSE_RD_REPEAT_ERR4_RPT4_RESERVED4_ERR_Msk = 0xffffff

	// RD_RS_ERR0: Programming error record register 0 of BLOCK1-10.
	// Position of MAC_SPI_8M_ERR_NUM field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_ERR_NUM_Pos = 0x0
	// Bit mask of MAC_SPI_8M_ERR_NUM field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_ERR_NUM_Msk = 0x7
	// Position of MAC_SPI_8M_FAIL field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL_Pos = 0x3
	// Bit mask of MAC_SPI_8M_FAIL field.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL_Msk = 0x8
	// Bit MAC_SPI_8M_FAIL.
	EFUSE_RD_RS_ERR0_MAC_SPI_8M_FAIL = 0x8
	// Position of SYS_PART1_NUM field.
	EFUSE_RD_RS_ERR0_SYS_PART1_NUM_Pos = 0x4
	// Bit mask of SYS_PART1_NUM field.
	EFUSE_RD_RS_ERR0_SYS_PART1_NUM_Msk = 0x70
	// Position of SYS_PART1_FAIL field.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL_Pos = 0x7
	// Bit mask of SYS_PART1_FAIL field.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL_Msk = 0x80
	// Bit SYS_PART1_FAIL.
	EFUSE_RD_RS_ERR0_SYS_PART1_FAIL = 0x80
	// Position of USR_DATA_ERR_NUM field.
	EFUSE_RD_RS_ERR0_USR_DATA_ERR_NUM_Pos = 0x8
	// Bit mask of USR_DATA_ERR_NUM field.
	EFUSE_RD_RS_ERR0_USR_DATA_ERR_NUM_Msk = 0x700
	// Position of USR_DATA_FAIL field.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL_Pos = 0xb
	// Bit mask of USR_DATA_FAIL field.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL_Msk = 0x800
	// Bit USR_DATA_FAIL.
	EFUSE_RD_RS_ERR0_USR_DATA_FAIL = 0x800
	// Position of KEY0_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY0_ERR_NUM_Pos = 0xc
	// Bit mask of KEY0_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY0_ERR_NUM_Msk = 0x7000
	// Position of KEY0_FAIL field.
	EFUSE_RD_RS_ERR0_KEY0_FAIL_Pos = 0xf
	// Bit mask of KEY0_FAIL field.
	EFUSE_RD_RS_ERR0_KEY0_FAIL_Msk = 0x8000
	// Bit KEY0_FAIL.
	EFUSE_RD_RS_ERR0_KEY0_FAIL = 0x8000
	// Position of KEY1_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY1_ERR_NUM_Pos = 0x10
	// Bit mask of KEY1_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY1_ERR_NUM_Msk = 0x70000
	// Position of KEY1_FAIL field.
	EFUSE_RD_RS_ERR0_KEY1_FAIL_Pos = 0x13
	// Bit mask of KEY1_FAIL field.
	EFUSE_RD_RS_ERR0_KEY1_FAIL_Msk = 0x80000
	// Bit KEY1_FAIL.
	EFUSE_RD_RS_ERR0_KEY1_FAIL = 0x80000
	// Position of KEY2_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY2_ERR_NUM_Pos = 0x14
	// Bit mask of KEY2_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY2_ERR_NUM_Msk = 0x700000
	// Position of KEY2_FAIL field.
	EFUSE_RD_RS_ERR0_KEY2_FAIL_Pos = 0x17
	// Bit mask of KEY2_FAIL field.
	EFUSE_RD_RS_ERR0_KEY2_FAIL_Msk = 0x800000
	// Bit KEY2_FAIL.
	EFUSE_RD_RS_ERR0_KEY2_FAIL = 0x800000
	// Position of KEY3_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY3_ERR_NUM_Pos = 0x18
	// Bit mask of KEY3_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY3_ERR_NUM_Msk = 0x7000000
	// Position of KEY3_FAIL field.
	EFUSE_RD_RS_ERR0_KEY3_FAIL_Pos = 0x1b
	// Bit mask of KEY3_FAIL field.
	EFUSE_RD_RS_ERR0_KEY3_FAIL_Msk = 0x8000000
	// Bit KEY3_FAIL.
	EFUSE_RD_RS_ERR0_KEY3_FAIL = 0x8000000
	// Position of KEY4_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY4_ERR_NUM_Pos = 0x1c
	// Bit mask of KEY4_ERR_NUM field.
	EFUSE_RD_RS_ERR0_KEY4_ERR_NUM_Msk = 0x70000000
	// Position of KEY4_FAIL field.
	EFUSE_RD_RS_ERR0_KEY4_FAIL_Pos = 0x1f
	// Bit mask of KEY4_FAIL field.
	EFUSE_RD_RS_ERR0_KEY4_FAIL_Msk = 0x80000000
	// Bit KEY4_FAIL.
	EFUSE_RD_RS_ERR0_KEY4_FAIL = 0x80000000

	// RD_RS_ERR1: Programming error record register 1 of BLOCK1-10.
	// Position of KEY5_ERR_NUM field.
	EFUSE_RD_RS_ERR1_KEY5_ERR_NUM_Pos = 0x0
	// Bit mask of KEY5_ERR_NUM field.
	EFUSE_RD_RS_ERR1_KEY5_ERR_NUM_Msk = 0x7
	// Position of KEY5_FAIL field.
	EFUSE_RD_RS_ERR1_KEY5_FAIL_Pos = 0x3
	// Bit mask of KEY5_FAIL field.
	EFUSE_RD_RS_ERR1_KEY5_FAIL_Msk = 0x8
	// Bit KEY5_FAIL.
	EFUSE_RD_RS_ERR1_KEY5_FAIL = 0x8
	// Position of SYS_PART2_ERR_NUM field.
	EFUSE_RD_RS_ERR1_SYS_PART2_ERR_NUM_Pos = 0x4
	// Bit mask of SYS_PART2_ERR_NUM field.
	EFUSE_RD_RS_ERR1_SYS_PART2_ERR_NUM_Msk = 0x70
	// Position of SYS_PART2_FAIL field.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL_Pos = 0x7
	// Bit mask of SYS_PART2_FAIL field.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL_Msk = 0x80
	// Bit SYS_PART2_FAIL.
	EFUSE_RD_RS_ERR1_SYS_PART2_FAIL = 0x80

	// CLK: eFuse clock configuration register.
	// Position of EFUSE_MEM_FORCE_PD field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PD_Pos = 0x0
	// Bit mask of EFUSE_MEM_FORCE_PD field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PD_Msk = 0x1
	// Bit EFUSE_MEM_FORCE_PD.
	EFUSE_CLK_EFUSE_MEM_FORCE_PD = 0x1
	// Position of MEM_CLK_FORCE_ON field.
	EFUSE_CLK_MEM_CLK_FORCE_ON_Pos = 0x1
	// Bit mask of MEM_CLK_FORCE_ON field.
	EFUSE_CLK_MEM_CLK_FORCE_ON_Msk = 0x2
	// Bit MEM_CLK_FORCE_ON.
	EFUSE_CLK_MEM_CLK_FORCE_ON = 0x2
	// Position of EFUSE_MEM_FORCE_PU field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of EFUSE_MEM_FORCE_PU field.
	EFUSE_CLK_EFUSE_MEM_FORCE_PU_Msk = 0x4
	// Bit EFUSE_MEM_FORCE_PU.
	EFUSE_CLK_EFUSE_MEM_FORCE_PU = 0x4
	// Position of EN field.
	EFUSE_CLK_EN_Pos = 0x10
	// Bit mask of EN field.
	EFUSE_CLK_EN_Msk = 0x10000
	// Bit EN.
	EFUSE_CLK_EN = 0x10000

	// CONF: eFuse operation mode configuration register.
	// Position of OP_CODE field.
	EFUSE_CONF_OP_CODE_Pos = 0x0
	// Bit mask of OP_CODE field.
	EFUSE_CONF_OP_CODE_Msk = 0xffff

	// STATUS: eFuse status register.
	// Position of STATE field.
	EFUSE_STATUS_STATE_Pos = 0x0
	// Bit mask of STATE field.
	EFUSE_STATUS_STATE_Msk = 0xf
	// Position of OTP_LOAD_SW field.
	EFUSE_STATUS_OTP_LOAD_SW_Pos = 0x4
	// Bit mask of OTP_LOAD_SW field.
	EFUSE_STATUS_OTP_LOAD_SW_Msk = 0x10
	// Bit OTP_LOAD_SW.
	EFUSE_STATUS_OTP_LOAD_SW = 0x10
	// Position of OTP_VDDQ_C_SYNC2 field.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2_Pos = 0x5
	// Bit mask of OTP_VDDQ_C_SYNC2 field.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2_Msk = 0x20
	// Bit OTP_VDDQ_C_SYNC2.
	EFUSE_STATUS_OTP_VDDQ_C_SYNC2 = 0x20
	// Position of OTP_STROBE_SW field.
	EFUSE_STATUS_OTP_STROBE_SW_Pos = 0x6
	// Bit mask of OTP_STROBE_SW field.
	EFUSE_STATUS_OTP_STROBE_SW_Msk = 0x40
	// Bit OTP_STROBE_SW.
	EFUSE_STATUS_OTP_STROBE_SW = 0x40
	// Position of OTP_CSB_SW field.
	EFUSE_STATUS_OTP_CSB_SW_Pos = 0x7
	// Bit mask of OTP_CSB_SW field.
	EFUSE_STATUS_OTP_CSB_SW_Msk = 0x80
	// Bit OTP_CSB_SW.
	EFUSE_STATUS_OTP_CSB_SW = 0x80
	// Position of OTP_PGENB_SW field.
	EFUSE_STATUS_OTP_PGENB_SW_Pos = 0x8
	// Bit mask of OTP_PGENB_SW field.
	EFUSE_STATUS_OTP_PGENB_SW_Msk = 0x100
	// Bit OTP_PGENB_SW.
	EFUSE_STATUS_OTP_PGENB_SW = 0x100
	// Position of OTP_VDDQ_IS_SW field.
	EFUSE_STATUS_OTP_VDDQ_IS_SW_Pos = 0x9
	// Bit mask of OTP_VDDQ_IS_SW field.
	EFUSE_STATUS_OTP_VDDQ_IS_SW_Msk = 0x200
	// Bit OTP_VDDQ_IS_SW.
	EFUSE_STATUS_OTP_VDDQ_IS_SW = 0x200
	// Position of REPEAT_ERR_CNT field.
	EFUSE_STATUS_REPEAT_ERR_CNT_Pos = 0xa
	// Bit mask of REPEAT_ERR_CNT field.
	EFUSE_STATUS_REPEAT_ERR_CNT_Msk = 0x3fc00

	// CMD: eFuse command register.
	// Position of READ_CMD field.
	EFUSE_CMD_READ_CMD_Pos = 0x0
	// Bit mask of READ_CMD field.
	EFUSE_CMD_READ_CMD_Msk = 0x1
	// Bit READ_CMD.
	EFUSE_CMD_READ_CMD = 0x1
	// Position of PGM_CMD field.
	EFUSE_CMD_PGM_CMD_Pos = 0x1
	// Bit mask of PGM_CMD field.
	EFUSE_CMD_PGM_CMD_Msk = 0x2
	// Bit PGM_CMD.
	EFUSE_CMD_PGM_CMD = 0x2
	// Position of BLK_NUM field.
	EFUSE_CMD_BLK_NUM_Pos = 0x2
	// Bit mask of BLK_NUM field.
	EFUSE_CMD_BLK_NUM_Msk = 0x3c

	// INT_RAW: eFuse raw interrupt register.
	// Position of READ_DONE_INT_RAW field.
	EFUSE_INT_RAW_READ_DONE_INT_RAW_Pos = 0x0
	// Bit mask of READ_DONE_INT_RAW field.
	EFUSE_INT_RAW_READ_DONE_INT_RAW_Msk = 0x1
	// Bit READ_DONE_INT_RAW.
	EFUSE_INT_RAW_READ_DONE_INT_RAW = 0x1
	// Position of PGM_DONE_INT_RAW field.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW_Pos = 0x1
	// Bit mask of PGM_DONE_INT_RAW field.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW_Msk = 0x2
	// Bit PGM_DONE_INT_RAW.
	EFUSE_INT_RAW_PGM_DONE_INT_RAW = 0x2

	// INT_ST: eFuse interrupt status register.
	// Position of READ_DONE_INT_ST field.
	EFUSE_INT_ST_READ_DONE_INT_ST_Pos = 0x0
	// Bit mask of READ_DONE_INT_ST field.
	EFUSE_INT_ST_READ_DONE_INT_ST_Msk = 0x1
	// Bit READ_DONE_INT_ST.
	EFUSE_INT_ST_READ_DONE_INT_ST = 0x1
	// Position of PGM_DONE_INT_ST field.
	EFUSE_INT_ST_PGM_DONE_INT_ST_Pos = 0x1
	// Bit mask of PGM_DONE_INT_ST field.
	EFUSE_INT_ST_PGM_DONE_INT_ST_Msk = 0x2
	// Bit PGM_DONE_INT_ST.
	EFUSE_INT_ST_PGM_DONE_INT_ST = 0x2

	// INT_ENA: eFuse interrupt enable register.
	// Position of READ_DONE_INT_ENA field.
	EFUSE_INT_ENA_READ_DONE_INT_ENA_Pos = 0x0
	// Bit mask of READ_DONE_INT_ENA field.
	EFUSE_INT_ENA_READ_DONE_INT_ENA_Msk = 0x1
	// Bit READ_DONE_INT_ENA.
	EFUSE_INT_ENA_READ_DONE_INT_ENA = 0x1
	// Position of PGM_DONE_INT_ENA field.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA_Pos = 0x1
	// Bit mask of PGM_DONE_INT_ENA field.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA_Msk = 0x2
	// Bit PGM_DONE_INT_ENA.
	EFUSE_INT_ENA_PGM_DONE_INT_ENA = 0x2

	// INT_CLR: eFuse interrupt clear register.
	// Position of READ_DONE_INT_CLR field.
	EFUSE_INT_CLR_READ_DONE_INT_CLR_Pos = 0x0
	// Bit mask of READ_DONE_INT_CLR field.
	EFUSE_INT_CLR_READ_DONE_INT_CLR_Msk = 0x1
	// Bit READ_DONE_INT_CLR.
	EFUSE_INT_CLR_READ_DONE_INT_CLR = 0x1
	// Position of PGM_DONE_INT_CLR field.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR_Pos = 0x1
	// Bit mask of PGM_DONE_INT_CLR field.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR_Msk = 0x2
	// Bit PGM_DONE_INT_CLR.
	EFUSE_INT_CLR_PGM_DONE_INT_CLR = 0x2

	// DAC_CONF: Controls the eFuse programming voltage.
	// Position of DAC_CLK_DIV field.
	EFUSE_DAC_CONF_DAC_CLK_DIV_Pos = 0x0
	// Bit mask of DAC_CLK_DIV field.
	EFUSE_DAC_CONF_DAC_CLK_DIV_Msk = 0xff
	// Position of DAC_CLK_PAD_SEL field.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL_Pos = 0x8
	// Bit mask of DAC_CLK_PAD_SEL field.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL_Msk = 0x100
	// Bit DAC_CLK_PAD_SEL.
	EFUSE_DAC_CONF_DAC_CLK_PAD_SEL = 0x100
	// Position of DAC_NUM field.
	EFUSE_DAC_CONF_DAC_NUM_Pos = 0x9
	// Bit mask of DAC_NUM field.
	EFUSE_DAC_CONF_DAC_NUM_Msk = 0x1fe00
	// Position of OE_CLR field.
	EFUSE_DAC_CONF_OE_CLR_Pos = 0x11
	// Bit mask of OE_CLR field.
	EFUSE_DAC_CONF_OE_CLR_Msk = 0x20000
	// Bit OE_CLR.
	EFUSE_DAC_CONF_OE_CLR = 0x20000

	// RD_TIM_CONF: Configures read timing parameters.
	// Position of THR_A field.
	EFUSE_RD_TIM_CONF_THR_A_Pos = 0x0
	// Bit mask of THR_A field.
	EFUSE_RD_TIM_CONF_THR_A_Msk = 0xff
	// Position of TRD field.
	EFUSE_RD_TIM_CONF_TRD_Pos = 0x8
	// Bit mask of TRD field.
	EFUSE_RD_TIM_CONF_TRD_Msk = 0xff00
	// Position of TSUR_A field.
	EFUSE_RD_TIM_CONF_TSUR_A_Pos = 0x10
	// Bit mask of TSUR_A field.
	EFUSE_RD_TIM_CONF_TSUR_A_Msk = 0xff0000
	// Position of READ_INIT_NUM field.
	EFUSE_RD_TIM_CONF_READ_INIT_NUM_Pos = 0x18
	// Bit mask of READ_INIT_NUM field.
	EFUSE_RD_TIM_CONF_READ_INIT_NUM_Msk = 0xff000000

	// WR_TIM_CONF0: Configuration register 0 of eFuse programming timing parameters.
	// Position of THP_A field.
	EFUSE_WR_TIM_CONF0_THP_A_Pos = 0x0
	// Bit mask of THP_A field.
	EFUSE_WR_TIM_CONF0_THP_A_Msk = 0xff
	// Position of TPGM_INACTIVE field.
	EFUSE_WR_TIM_CONF0_TPGM_INACTIVE_Pos = 0x8
	// Bit mask of TPGM_INACTIVE field.
	EFUSE_WR_TIM_CONF0_TPGM_INACTIVE_Msk = 0xff00
	// Position of TPGM field.
	EFUSE_WR_TIM_CONF0_TPGM_Pos = 0x10
	// Bit mask of TPGM field.
	EFUSE_WR_TIM_CONF0_TPGM_Msk = 0xffff0000

	// WR_TIM_CONF1: Configuration register 1 of eFuse programming timing parameters.
	// Position of TSUP_A field.
	EFUSE_WR_TIM_CONF1_TSUP_A_Pos = 0x0
	// Bit mask of TSUP_A field.
	EFUSE_WR_TIM_CONF1_TSUP_A_Msk = 0xff
	// Position of PWR_ON_NUM field.
	EFUSE_WR_TIM_CONF1_PWR_ON_NUM_Pos = 0x8
	// Bit mask of PWR_ON_NUM field.
	EFUSE_WR_TIM_CONF1_PWR_ON_NUM_Msk = 0xffff00

	// WR_TIM_CONF2: Configuration register 2 of eFuse programming timing parameters.
	// Position of PWR_OFF_NUM field.
	EFUSE_WR_TIM_CONF2_PWR_OFF_NUM_Pos = 0x0
	// Bit mask of PWR_OFF_NUM field.
	EFUSE_WR_TIM_CONF2_PWR_OFF_NUM_Msk = 0xffff

	// DATE: Version control register.
	// Position of DATE field.
	EFUSE_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	EFUSE_DATE_DATE_Msk = 0xffffffff
)

// Constants for EXTMEM: External Memory
const (
	// PRO_DCACHE_CTRL: register description
	// Position of PRO_DCACHE_ENABLE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_ENABLE_Pos = 0x0
	// Bit mask of PRO_DCACHE_ENABLE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_ENABLE_Msk = 0x1
	// Bit PRO_DCACHE_ENABLE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_ENABLE = 0x1
	// Position of PRO_DCACHE_SETSIZE_MODE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_SETSIZE_MODE_Pos = 0x2
	// Bit mask of PRO_DCACHE_SETSIZE_MODE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_SETSIZE_MODE_Msk = 0x4
	// Bit PRO_DCACHE_SETSIZE_MODE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_SETSIZE_MODE = 0x4
	// Position of PRO_DCACHE_BLOCKSIZE_MODE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_BLOCKSIZE_MODE_Pos = 0x3
	// Bit mask of PRO_DCACHE_BLOCKSIZE_MODE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_BLOCKSIZE_MODE_Msk = 0x8
	// Bit PRO_DCACHE_BLOCKSIZE_MODE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_BLOCKSIZE_MODE = 0x8
	// Position of PRO_DCACHE_INVALIDATE_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_ENA_Pos = 0x8
	// Bit mask of PRO_DCACHE_INVALIDATE_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_ENA_Msk = 0x100
	// Bit PRO_DCACHE_INVALIDATE_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_ENA = 0x100
	// Position of PRO_DCACHE_INVALIDATE_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_DONE_Pos = 0x9
	// Bit mask of PRO_DCACHE_INVALIDATE_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_DONE_Msk = 0x200
	// Bit PRO_DCACHE_INVALIDATE_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_INVALIDATE_DONE = 0x200
	// Position of PRO_DCACHE_FLUSH_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_ENA_Pos = 0xa
	// Bit mask of PRO_DCACHE_FLUSH_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_ENA_Msk = 0x400
	// Bit PRO_DCACHE_FLUSH_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_ENA = 0x400
	// Position of PRO_DCACHE_FLUSH_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_DONE_Pos = 0xb
	// Bit mask of PRO_DCACHE_FLUSH_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_DONE_Msk = 0x800
	// Bit PRO_DCACHE_FLUSH_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_FLUSH_DONE = 0x800
	// Position of PRO_DCACHE_CLEAN_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_ENA_Pos = 0xc
	// Bit mask of PRO_DCACHE_CLEAN_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_ENA_Msk = 0x1000
	// Bit PRO_DCACHE_CLEAN_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_ENA = 0x1000
	// Position of PRO_DCACHE_CLEAN_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_DONE_Pos = 0xd
	// Bit mask of PRO_DCACHE_CLEAN_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_DONE_Msk = 0x2000
	// Bit PRO_DCACHE_CLEAN_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_CLEAN_DONE = 0x2000
	// Position of PRO_DCACHE_LOCK0_EN field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK0_EN_Pos = 0xe
	// Bit mask of PRO_DCACHE_LOCK0_EN field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK0_EN_Msk = 0x4000
	// Bit PRO_DCACHE_LOCK0_EN.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK0_EN = 0x4000
	// Position of PRO_DCACHE_LOCK1_EN field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK1_EN_Pos = 0xf
	// Bit mask of PRO_DCACHE_LOCK1_EN field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK1_EN_Msk = 0x8000
	// Bit PRO_DCACHE_LOCK1_EN.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK1_EN = 0x8000
	// Position of PRO_DCACHE_AUTOLOAD_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_ENA_Pos = 0x12
	// Bit mask of PRO_DCACHE_AUTOLOAD_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_ENA_Msk = 0x40000
	// Bit PRO_DCACHE_AUTOLOAD_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_ENA = 0x40000
	// Position of PRO_DCACHE_AUTOLOAD_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_DONE_Pos = 0x13
	// Bit mask of PRO_DCACHE_AUTOLOAD_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_DONE_Msk = 0x80000
	// Bit PRO_DCACHE_AUTOLOAD_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_AUTOLOAD_DONE = 0x80000
	// Position of PRO_DCACHE_PRELOAD_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_ENA_Pos = 0x14
	// Bit mask of PRO_DCACHE_PRELOAD_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_ENA_Msk = 0x100000
	// Bit PRO_DCACHE_PRELOAD_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_ENA = 0x100000
	// Position of PRO_DCACHE_PRELOAD_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_DONE_Pos = 0x15
	// Bit mask of PRO_DCACHE_PRELOAD_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_DONE_Msk = 0x200000
	// Bit PRO_DCACHE_PRELOAD_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_PRELOAD_DONE = 0x200000
	// Position of PRO_DCACHE_UNLOCK_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_ENA_Pos = 0x16
	// Bit mask of PRO_DCACHE_UNLOCK_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_ENA_Msk = 0x400000
	// Bit PRO_DCACHE_UNLOCK_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_ENA = 0x400000
	// Position of PRO_DCACHE_UNLOCK_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_DONE_Pos = 0x17
	// Bit mask of PRO_DCACHE_UNLOCK_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_DONE_Msk = 0x800000
	// Bit PRO_DCACHE_UNLOCK_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_UNLOCK_DONE = 0x800000
	// Position of PRO_DCACHE_LOCK_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK_ENA_Pos = 0x18
	// Bit mask of PRO_DCACHE_LOCK_ENA field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK_ENA_Msk = 0x1000000
	// Bit PRO_DCACHE_LOCK_ENA.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK_ENA = 0x1000000
	// Position of PRO_DCACHE_LOCK_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK_DONE_Pos = 0x19
	// Bit mask of PRO_DCACHE_LOCK_DONE field.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK_DONE_Msk = 0x2000000
	// Bit PRO_DCACHE_LOCK_DONE.
	EXTMEM_PRO_DCACHE_CTRL_PRO_DCACHE_LOCK_DONE = 0x2000000

	// PRO_DCACHE_CTRL1: register description
	// Position of PRO_DCACHE_MASK_BUS0 field.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS0_Pos = 0x0
	// Bit mask of PRO_DCACHE_MASK_BUS0 field.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS0_Msk = 0x1
	// Bit PRO_DCACHE_MASK_BUS0.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS0 = 0x1
	// Position of PRO_DCACHE_MASK_BUS1 field.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS1_Pos = 0x1
	// Bit mask of PRO_DCACHE_MASK_BUS1 field.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS1_Msk = 0x2
	// Bit PRO_DCACHE_MASK_BUS1.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS1 = 0x2
	// Position of PRO_DCACHE_MASK_BUS2 field.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS2_Pos = 0x2
	// Bit mask of PRO_DCACHE_MASK_BUS2 field.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS2_Msk = 0x4
	// Bit PRO_DCACHE_MASK_BUS2.
	EXTMEM_PRO_DCACHE_CTRL1_PRO_DCACHE_MASK_BUS2 = 0x4

	// PRO_DCACHE_TAG_POWER_CTRL: register description
	// Position of PRO_DCACHE_TAG_MEM_FORCE_ON field.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_ON_Pos = 0x0
	// Bit mask of PRO_DCACHE_TAG_MEM_FORCE_ON field.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_ON_Msk = 0x1
	// Bit PRO_DCACHE_TAG_MEM_FORCE_ON.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_ON = 0x1
	// Position of PRO_DCACHE_TAG_MEM_FORCE_PD field.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PD_Pos = 0x1
	// Bit mask of PRO_DCACHE_TAG_MEM_FORCE_PD field.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PD_Msk = 0x2
	// Bit PRO_DCACHE_TAG_MEM_FORCE_PD.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PD = 0x2
	// Position of PRO_DCACHE_TAG_MEM_FORCE_PU field.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of PRO_DCACHE_TAG_MEM_FORCE_PU field.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PU_Msk = 0x4
	// Bit PRO_DCACHE_TAG_MEM_FORCE_PU.
	EXTMEM_PRO_DCACHE_TAG_POWER_CTRL_PRO_DCACHE_TAG_MEM_FORCE_PU = 0x4

	// PRO_DCACHE_LOCK0_ADDR: register description
	// Position of PRO_DCACHE_LOCK0_ADDR field.
	EXTMEM_PRO_DCACHE_LOCK0_ADDR_PRO_DCACHE_LOCK0_ADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_LOCK0_ADDR field.
	EXTMEM_PRO_DCACHE_LOCK0_ADDR_PRO_DCACHE_LOCK0_ADDR_Msk = 0xffffffff

	// PRO_DCACHE_LOCK0_SIZE: register description
	// Position of PRO_DCACHE_LOCK0_SIZE field.
	EXTMEM_PRO_DCACHE_LOCK0_SIZE_PRO_DCACHE_LOCK0_SIZE_Pos = 0x0
	// Bit mask of PRO_DCACHE_LOCK0_SIZE field.
	EXTMEM_PRO_DCACHE_LOCK0_SIZE_PRO_DCACHE_LOCK0_SIZE_Msk = 0xffff

	// PRO_DCACHE_LOCK1_ADDR: register description
	// Position of PRO_DCACHE_LOCK1_ADDR field.
	EXTMEM_PRO_DCACHE_LOCK1_ADDR_PRO_DCACHE_LOCK1_ADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_LOCK1_ADDR field.
	EXTMEM_PRO_DCACHE_LOCK1_ADDR_PRO_DCACHE_LOCK1_ADDR_Msk = 0xffffffff

	// PRO_DCACHE_LOCK1_SIZE: register description
	// Position of PRO_DCACHE_LOCK1_SIZE field.
	EXTMEM_PRO_DCACHE_LOCK1_SIZE_PRO_DCACHE_LOCK1_SIZE_Pos = 0x0
	// Bit mask of PRO_DCACHE_LOCK1_SIZE field.
	EXTMEM_PRO_DCACHE_LOCK1_SIZE_PRO_DCACHE_LOCK1_SIZE_Msk = 0xffff

	// PRO_DCACHE_MEM_SYNC0: register description
	// Position of PRO_DCACHE_MEMSYNC_ADDR field.
	EXTMEM_PRO_DCACHE_MEM_SYNC0_PRO_DCACHE_MEMSYNC_ADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_MEMSYNC_ADDR field.
	EXTMEM_PRO_DCACHE_MEM_SYNC0_PRO_DCACHE_MEMSYNC_ADDR_Msk = 0xffffffff

	// PRO_DCACHE_MEM_SYNC1: register description
	// Position of PRO_DCACHE_MEMSYNC_SIZE field.
	EXTMEM_PRO_DCACHE_MEM_SYNC1_PRO_DCACHE_MEMSYNC_SIZE_Pos = 0x0
	// Bit mask of PRO_DCACHE_MEMSYNC_SIZE field.
	EXTMEM_PRO_DCACHE_MEM_SYNC1_PRO_DCACHE_MEMSYNC_SIZE_Msk = 0x7ffff

	// PRO_DCACHE_PRELOAD_ADDR: register description
	// Position of PRO_DCACHE_PRELOAD_ADDR field.
	EXTMEM_PRO_DCACHE_PRELOAD_ADDR_PRO_DCACHE_PRELOAD_ADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_PRELOAD_ADDR field.
	EXTMEM_PRO_DCACHE_PRELOAD_ADDR_PRO_DCACHE_PRELOAD_ADDR_Msk = 0xffffffff

	// PRO_DCACHE_PRELOAD_SIZE: register description
	// Position of PRO_DCACHE_PRELOAD_SIZE field.
	EXTMEM_PRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_SIZE_Pos = 0x0
	// Bit mask of PRO_DCACHE_PRELOAD_SIZE field.
	EXTMEM_PRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_SIZE_Msk = 0x3ff
	// Position of PRO_DCACHE_PRELOAD_ORDER field.
	EXTMEM_PRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_ORDER_Pos = 0xa
	// Bit mask of PRO_DCACHE_PRELOAD_ORDER field.
	EXTMEM_PRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_ORDER_Msk = 0x400
	// Bit PRO_DCACHE_PRELOAD_ORDER.
	EXTMEM_PRO_DCACHE_PRELOAD_SIZE_PRO_DCACHE_PRELOAD_ORDER = 0x400

	// PRO_DCACHE_AUTOLOAD_CFG: register description
	// Position of PRO_DCACHE_AUTOLOAD_MODE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_MODE_Pos = 0x0
	// Bit mask of PRO_DCACHE_AUTOLOAD_MODE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_MODE_Msk = 0x1
	// Bit PRO_DCACHE_AUTOLOAD_MODE.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_MODE = 0x1
	// Position of PRO_DCACHE_AUTOLOAD_STEP field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_STEP_Pos = 0x1
	// Bit mask of PRO_DCACHE_AUTOLOAD_STEP field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_STEP_Msk = 0x6
	// Position of PRO_DCACHE_AUTOLOAD_ORDER field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_ORDER_Pos = 0x3
	// Bit mask of PRO_DCACHE_AUTOLOAD_ORDER field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_ORDER_Msk = 0x8
	// Bit PRO_DCACHE_AUTOLOAD_ORDER.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_ORDER = 0x8
	// Position of PRO_DCACHE_AUTOLOAD_RQST field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_RQST_Pos = 0x4
	// Bit mask of PRO_DCACHE_AUTOLOAD_RQST field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_RQST_Msk = 0x30
	// Position of PRO_DCACHE_AUTOLOAD_SIZE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SIZE_Pos = 0x6
	// Bit mask of PRO_DCACHE_AUTOLOAD_SIZE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SIZE_Msk = 0xc0
	// Position of PRO_DCACHE_AUTOLOAD_SCT0_ENA field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT0_ENA_Pos = 0x8
	// Bit mask of PRO_DCACHE_AUTOLOAD_SCT0_ENA field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT0_ENA_Msk = 0x100
	// Bit PRO_DCACHE_AUTOLOAD_SCT0_ENA.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT0_ENA = 0x100
	// Position of PRO_DCACHE_AUTOLOAD_SCT1_ENA field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT1_ENA_Pos = 0x9
	// Bit mask of PRO_DCACHE_AUTOLOAD_SCT1_ENA field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT1_ENA_Msk = 0x200
	// Bit PRO_DCACHE_AUTOLOAD_SCT1_ENA.
	EXTMEM_PRO_DCACHE_AUTOLOAD_CFG_PRO_DCACHE_AUTOLOAD_SCT1_ENA = 0x200

	// PRO_DCACHE_AUTOLOAD_SECTION0_ADDR: register description
	// Position of PRO_DCACHE_AUTOLOAD_SCT0_ADDR field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION0_ADDR_PRO_DCACHE_AUTOLOAD_SCT0_ADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_AUTOLOAD_SCT0_ADDR field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION0_ADDR_PRO_DCACHE_AUTOLOAD_SCT0_ADDR_Msk = 0xffffffff

	// PRO_DCACHE_AUTOLOAD_SECTION0_SIZE: register description
	// Position of PRO_DCACHE_AUTOLOAD_SCT0_SIZE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION0_SIZE_PRO_DCACHE_AUTOLOAD_SCT0_SIZE_Pos = 0x0
	// Bit mask of PRO_DCACHE_AUTOLOAD_SCT0_SIZE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION0_SIZE_PRO_DCACHE_AUTOLOAD_SCT0_SIZE_Msk = 0xffffff

	// PRO_DCACHE_AUTOLOAD_SECTION1_ADDR: register description
	// Position of PRO_DCACHE_AUTOLOAD_SCT1_ADDR field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION1_ADDR_PRO_DCACHE_AUTOLOAD_SCT1_ADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_AUTOLOAD_SCT1_ADDR field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION1_ADDR_PRO_DCACHE_AUTOLOAD_SCT1_ADDR_Msk = 0xffffffff

	// PRO_DCACHE_AUTOLOAD_SECTION1_SIZE: register description
	// Position of PRO_DCACHE_AUTOLOAD_SCT1_SIZE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION1_SIZE_PRO_DCACHE_AUTOLOAD_SCT1_SIZE_Pos = 0x0
	// Bit mask of PRO_DCACHE_AUTOLOAD_SCT1_SIZE field.
	EXTMEM_PRO_DCACHE_AUTOLOAD_SECTION1_SIZE_PRO_DCACHE_AUTOLOAD_SCT1_SIZE_Msk = 0xffffff

	// PRO_ICACHE_CTRL: register description
	// Position of PRO_ICACHE_ENABLE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_ENABLE_Pos = 0x0
	// Bit mask of PRO_ICACHE_ENABLE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_ENABLE_Msk = 0x1
	// Bit PRO_ICACHE_ENABLE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_ENABLE = 0x1
	// Position of PRO_ICACHE_SETSIZE_MODE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_SETSIZE_MODE_Pos = 0x2
	// Bit mask of PRO_ICACHE_SETSIZE_MODE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_SETSIZE_MODE_Msk = 0x4
	// Bit PRO_ICACHE_SETSIZE_MODE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_SETSIZE_MODE = 0x4
	// Position of PRO_ICACHE_BLOCKSIZE_MODE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_BLOCKSIZE_MODE_Pos = 0x3
	// Bit mask of PRO_ICACHE_BLOCKSIZE_MODE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_BLOCKSIZE_MODE_Msk = 0x8
	// Bit PRO_ICACHE_BLOCKSIZE_MODE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_BLOCKSIZE_MODE = 0x8
	// Position of PRO_ICACHE_INVALIDATE_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_ENA_Pos = 0x8
	// Bit mask of PRO_ICACHE_INVALIDATE_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_ENA_Msk = 0x100
	// Bit PRO_ICACHE_INVALIDATE_ENA.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_ENA = 0x100
	// Position of PRO_ICACHE_INVALIDATE_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_DONE_Pos = 0x9
	// Bit mask of PRO_ICACHE_INVALIDATE_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_DONE_Msk = 0x200
	// Bit PRO_ICACHE_INVALIDATE_DONE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_INVALIDATE_DONE = 0x200
	// Position of PRO_ICACHE_LOCK0_EN field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK0_EN_Pos = 0xe
	// Bit mask of PRO_ICACHE_LOCK0_EN field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK0_EN_Msk = 0x4000
	// Bit PRO_ICACHE_LOCK0_EN.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK0_EN = 0x4000
	// Position of PRO_ICACHE_LOCK1_EN field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK1_EN_Pos = 0xf
	// Bit mask of PRO_ICACHE_LOCK1_EN field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK1_EN_Msk = 0x8000
	// Bit PRO_ICACHE_LOCK1_EN.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK1_EN = 0x8000
	// Position of PRO_ICACHE_AUTOLOAD_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_ENA_Pos = 0x12
	// Bit mask of PRO_ICACHE_AUTOLOAD_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_ENA_Msk = 0x40000
	// Bit PRO_ICACHE_AUTOLOAD_ENA.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_ENA = 0x40000
	// Position of PRO_ICACHE_AUTOLOAD_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_DONE_Pos = 0x13
	// Bit mask of PRO_ICACHE_AUTOLOAD_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_DONE_Msk = 0x80000
	// Bit PRO_ICACHE_AUTOLOAD_DONE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_AUTOLOAD_DONE = 0x80000
	// Position of PRO_ICACHE_PRELOAD_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_ENA_Pos = 0x14
	// Bit mask of PRO_ICACHE_PRELOAD_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_ENA_Msk = 0x100000
	// Bit PRO_ICACHE_PRELOAD_ENA.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_ENA = 0x100000
	// Position of PRO_ICACHE_PRELOAD_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_DONE_Pos = 0x15
	// Bit mask of PRO_ICACHE_PRELOAD_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_DONE_Msk = 0x200000
	// Bit PRO_ICACHE_PRELOAD_DONE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_PRELOAD_DONE = 0x200000
	// Position of PRO_ICACHE_UNLOCK_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_ENA_Pos = 0x16
	// Bit mask of PRO_ICACHE_UNLOCK_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_ENA_Msk = 0x400000
	// Bit PRO_ICACHE_UNLOCK_ENA.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_ENA = 0x400000
	// Position of PRO_ICACHE_UNLOCK_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_DONE_Pos = 0x17
	// Bit mask of PRO_ICACHE_UNLOCK_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_DONE_Msk = 0x800000
	// Bit PRO_ICACHE_UNLOCK_DONE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_UNLOCK_DONE = 0x800000
	// Position of PRO_ICACHE_LOCK_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK_ENA_Pos = 0x18
	// Bit mask of PRO_ICACHE_LOCK_ENA field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK_ENA_Msk = 0x1000000
	// Bit PRO_ICACHE_LOCK_ENA.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK_ENA = 0x1000000
	// Position of PRO_ICACHE_LOCK_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK_DONE_Pos = 0x19
	// Bit mask of PRO_ICACHE_LOCK_DONE field.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK_DONE_Msk = 0x2000000
	// Bit PRO_ICACHE_LOCK_DONE.
	EXTMEM_PRO_ICACHE_CTRL_PRO_ICACHE_LOCK_DONE = 0x2000000

	// PRO_ICACHE_CTRL1: register description
	// Position of PRO_ICACHE_MASK_BUS0 field.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS0_Pos = 0x0
	// Bit mask of PRO_ICACHE_MASK_BUS0 field.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS0_Msk = 0x1
	// Bit PRO_ICACHE_MASK_BUS0.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS0 = 0x1
	// Position of PRO_ICACHE_MASK_BUS1 field.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS1_Pos = 0x1
	// Bit mask of PRO_ICACHE_MASK_BUS1 field.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS1_Msk = 0x2
	// Bit PRO_ICACHE_MASK_BUS1.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS1 = 0x2
	// Position of PRO_ICACHE_MASK_BUS2 field.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS2_Pos = 0x2
	// Bit mask of PRO_ICACHE_MASK_BUS2 field.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS2_Msk = 0x4
	// Bit PRO_ICACHE_MASK_BUS2.
	EXTMEM_PRO_ICACHE_CTRL1_PRO_ICACHE_MASK_BUS2 = 0x4

	// PRO_ICACHE_TAG_POWER_CTRL: register description
	// Position of PRO_ICACHE_TAG_MEM_FORCE_ON field.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_ON_Pos = 0x0
	// Bit mask of PRO_ICACHE_TAG_MEM_FORCE_ON field.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_ON_Msk = 0x1
	// Bit PRO_ICACHE_TAG_MEM_FORCE_ON.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_ON = 0x1
	// Position of PRO_ICACHE_TAG_MEM_FORCE_PD field.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PD_Pos = 0x1
	// Bit mask of PRO_ICACHE_TAG_MEM_FORCE_PD field.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PD_Msk = 0x2
	// Bit PRO_ICACHE_TAG_MEM_FORCE_PD.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PD = 0x2
	// Position of PRO_ICACHE_TAG_MEM_FORCE_PU field.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of PRO_ICACHE_TAG_MEM_FORCE_PU field.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PU_Msk = 0x4
	// Bit PRO_ICACHE_TAG_MEM_FORCE_PU.
	EXTMEM_PRO_ICACHE_TAG_POWER_CTRL_PRO_ICACHE_TAG_MEM_FORCE_PU = 0x4

	// PRO_ICACHE_LOCK0_ADDR: register description
	// Position of PRO_ICACHE_LOCK0_ADDR field.
	EXTMEM_PRO_ICACHE_LOCK0_ADDR_PRO_ICACHE_LOCK0_ADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_LOCK0_ADDR field.
	EXTMEM_PRO_ICACHE_LOCK0_ADDR_PRO_ICACHE_LOCK0_ADDR_Msk = 0xffffffff

	// PRO_ICACHE_LOCK0_SIZE: register description
	// Position of PRO_ICACHE_LOCK0_SIZE field.
	EXTMEM_PRO_ICACHE_LOCK0_SIZE_PRO_ICACHE_LOCK0_SIZE_Pos = 0x0
	// Bit mask of PRO_ICACHE_LOCK0_SIZE field.
	EXTMEM_PRO_ICACHE_LOCK0_SIZE_PRO_ICACHE_LOCK0_SIZE_Msk = 0xffff

	// PRO_ICACHE_LOCK1_ADDR: register description
	// Position of PRO_ICACHE_LOCK1_ADDR field.
	EXTMEM_PRO_ICACHE_LOCK1_ADDR_PRO_ICACHE_LOCK1_ADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_LOCK1_ADDR field.
	EXTMEM_PRO_ICACHE_LOCK1_ADDR_PRO_ICACHE_LOCK1_ADDR_Msk = 0xffffffff

	// PRO_ICACHE_LOCK1_SIZE: register description
	// Position of PRO_ICACHE_LOCK1_SIZE field.
	EXTMEM_PRO_ICACHE_LOCK1_SIZE_PRO_ICACHE_LOCK1_SIZE_Pos = 0x0
	// Bit mask of PRO_ICACHE_LOCK1_SIZE field.
	EXTMEM_PRO_ICACHE_LOCK1_SIZE_PRO_ICACHE_LOCK1_SIZE_Msk = 0xffff

	// PRO_ICACHE_MEM_SYNC0: register description
	// Position of PRO_ICACHE_MEMSYNC_ADDR field.
	EXTMEM_PRO_ICACHE_MEM_SYNC0_PRO_ICACHE_MEMSYNC_ADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_MEMSYNC_ADDR field.
	EXTMEM_PRO_ICACHE_MEM_SYNC0_PRO_ICACHE_MEMSYNC_ADDR_Msk = 0xffffffff

	// PRO_ICACHE_MEM_SYNC1: register description
	// Position of PRO_ICACHE_MEMSYNC_SIZE field.
	EXTMEM_PRO_ICACHE_MEM_SYNC1_PRO_ICACHE_MEMSYNC_SIZE_Pos = 0x0
	// Bit mask of PRO_ICACHE_MEMSYNC_SIZE field.
	EXTMEM_PRO_ICACHE_MEM_SYNC1_PRO_ICACHE_MEMSYNC_SIZE_Msk = 0x7ffff

	// PRO_ICACHE_PRELOAD_ADDR: register description
	// Position of PRO_ICACHE_PRELOAD_ADDR field.
	EXTMEM_PRO_ICACHE_PRELOAD_ADDR_PRO_ICACHE_PRELOAD_ADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_PRELOAD_ADDR field.
	EXTMEM_PRO_ICACHE_PRELOAD_ADDR_PRO_ICACHE_PRELOAD_ADDR_Msk = 0xffffffff

	// PRO_ICACHE_PRELOAD_SIZE: register description
	// Position of PRO_ICACHE_PRELOAD_SIZE field.
	EXTMEM_PRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_SIZE_Pos = 0x0
	// Bit mask of PRO_ICACHE_PRELOAD_SIZE field.
	EXTMEM_PRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_SIZE_Msk = 0x3ff
	// Position of PRO_ICACHE_PRELOAD_ORDER field.
	EXTMEM_PRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_ORDER_Pos = 0xa
	// Bit mask of PRO_ICACHE_PRELOAD_ORDER field.
	EXTMEM_PRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_ORDER_Msk = 0x400
	// Bit PRO_ICACHE_PRELOAD_ORDER.
	EXTMEM_PRO_ICACHE_PRELOAD_SIZE_PRO_ICACHE_PRELOAD_ORDER = 0x400

	// PRO_ICACHE_AUTOLOAD_CFG: register description
	// Position of PRO_ICACHE_AUTOLOAD_MODE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_MODE_Pos = 0x0
	// Bit mask of PRO_ICACHE_AUTOLOAD_MODE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_MODE_Msk = 0x1
	// Bit PRO_ICACHE_AUTOLOAD_MODE.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_MODE = 0x1
	// Position of PRO_ICACHE_AUTOLOAD_STEP field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_STEP_Pos = 0x1
	// Bit mask of PRO_ICACHE_AUTOLOAD_STEP field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_STEP_Msk = 0x6
	// Position of PRO_ICACHE_AUTOLOAD_ORDER field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_ORDER_Pos = 0x3
	// Bit mask of PRO_ICACHE_AUTOLOAD_ORDER field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_ORDER_Msk = 0x8
	// Bit PRO_ICACHE_AUTOLOAD_ORDER.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_ORDER = 0x8
	// Position of PRO_ICACHE_AUTOLOAD_RQST field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_RQST_Pos = 0x4
	// Bit mask of PRO_ICACHE_AUTOLOAD_RQST field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_RQST_Msk = 0x30
	// Position of PRO_ICACHE_AUTOLOAD_SIZE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SIZE_Pos = 0x6
	// Bit mask of PRO_ICACHE_AUTOLOAD_SIZE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SIZE_Msk = 0xc0
	// Position of PRO_ICACHE_AUTOLOAD_SCT0_ENA field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT0_ENA_Pos = 0x8
	// Bit mask of PRO_ICACHE_AUTOLOAD_SCT0_ENA field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT0_ENA_Msk = 0x100
	// Bit PRO_ICACHE_AUTOLOAD_SCT0_ENA.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT0_ENA = 0x100
	// Position of PRO_ICACHE_AUTOLOAD_SCT1_ENA field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT1_ENA_Pos = 0x9
	// Bit mask of PRO_ICACHE_AUTOLOAD_SCT1_ENA field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT1_ENA_Msk = 0x200
	// Bit PRO_ICACHE_AUTOLOAD_SCT1_ENA.
	EXTMEM_PRO_ICACHE_AUTOLOAD_CFG_PRO_ICACHE_AUTOLOAD_SCT1_ENA = 0x200

	// PRO_ICACHE_AUTOLOAD_SECTION0_ADDR: register description
	// Position of PRO_ICACHE_AUTOLOAD_SCT0_ADDR field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION0_ADDR_PRO_ICACHE_AUTOLOAD_SCT0_ADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_AUTOLOAD_SCT0_ADDR field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION0_ADDR_PRO_ICACHE_AUTOLOAD_SCT0_ADDR_Msk = 0xffffffff

	// PRO_ICACHE_AUTOLOAD_SECTION0_SIZE: register description
	// Position of PRO_ICACHE_AUTOLOAD_SCT0_SIZE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION0_SIZE_PRO_ICACHE_AUTOLOAD_SCT0_SIZE_Pos = 0x0
	// Bit mask of PRO_ICACHE_AUTOLOAD_SCT0_SIZE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION0_SIZE_PRO_ICACHE_AUTOLOAD_SCT0_SIZE_Msk = 0xffffff

	// PRO_ICACHE_AUTOLOAD_SECTION1_ADDR: register description
	// Position of PRO_ICACHE_AUTOLOAD_SCT1_ADDR field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION1_ADDR_PRO_ICACHE_AUTOLOAD_SCT1_ADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_AUTOLOAD_SCT1_ADDR field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION1_ADDR_PRO_ICACHE_AUTOLOAD_SCT1_ADDR_Msk = 0xffffffff

	// PRO_ICACHE_AUTOLOAD_SECTION1_SIZE: register description
	// Position of PRO_ICACHE_AUTOLOAD_SCT1_SIZE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION1_SIZE_PRO_ICACHE_AUTOLOAD_SCT1_SIZE_Pos = 0x0
	// Bit mask of PRO_ICACHE_AUTOLOAD_SCT1_SIZE field.
	EXTMEM_PRO_ICACHE_AUTOLOAD_SECTION1_SIZE_PRO_ICACHE_AUTOLOAD_SCT1_SIZE_Msk = 0xffffff

	// IC_PRELOAD_CNT: register description
	// Position of IC_PRELOAD_CNT field.
	EXTMEM_IC_PRELOAD_CNT_IC_PRELOAD_CNT_Pos = 0x0
	// Bit mask of IC_PRELOAD_CNT field.
	EXTMEM_IC_PRELOAD_CNT_IC_PRELOAD_CNT_Msk = 0xffff

	// IC_PRELOAD_MISS_CNT: register description
	// Position of IC_PRELOAD_MISS_CNT field.
	EXTMEM_IC_PRELOAD_MISS_CNT_IC_PRELOAD_MISS_CNT_Pos = 0x0
	// Bit mask of IC_PRELOAD_MISS_CNT field.
	EXTMEM_IC_PRELOAD_MISS_CNT_IC_PRELOAD_MISS_CNT_Msk = 0xffff

	// IBUS2_ABANDON_CNT: register description
	// Position of IBUS2_ABANDON_CNT field.
	EXTMEM_IBUS2_ABANDON_CNT_IBUS2_ABANDON_CNT_Pos = 0x0
	// Bit mask of IBUS2_ABANDON_CNT field.
	EXTMEM_IBUS2_ABANDON_CNT_IBUS2_ABANDON_CNT_Msk = 0xffff

	// IBUS1_ABANDON_CNT: register description
	// Position of IBUS1_ABANDON_CNT field.
	EXTMEM_IBUS1_ABANDON_CNT_IBUS1_ABANDON_CNT_Pos = 0x0
	// Bit mask of IBUS1_ABANDON_CNT field.
	EXTMEM_IBUS1_ABANDON_CNT_IBUS1_ABANDON_CNT_Msk = 0xffff

	// IBUS0_ABANDON_CNT: register description
	// Position of IBUS0_ABANDON_CNT field.
	EXTMEM_IBUS0_ABANDON_CNT_IBUS0_ABANDON_CNT_Pos = 0x0
	// Bit mask of IBUS0_ABANDON_CNT field.
	EXTMEM_IBUS0_ABANDON_CNT_IBUS0_ABANDON_CNT_Msk = 0xffff

	// IBUS2_ACS_MISS_CNT: register description
	// Position of IBUS2_ACS_MISS_CNT field.
	EXTMEM_IBUS2_ACS_MISS_CNT_IBUS2_ACS_MISS_CNT_Pos = 0x0
	// Bit mask of IBUS2_ACS_MISS_CNT field.
	EXTMEM_IBUS2_ACS_MISS_CNT_IBUS2_ACS_MISS_CNT_Msk = 0xffffffff

	// IBUS1_ACS_MISS_CNT: register description
	// Position of IBUS1_ACS_MISS_CNT field.
	EXTMEM_IBUS1_ACS_MISS_CNT_IBUS1_ACS_MISS_CNT_Pos = 0x0
	// Bit mask of IBUS1_ACS_MISS_CNT field.
	EXTMEM_IBUS1_ACS_MISS_CNT_IBUS1_ACS_MISS_CNT_Msk = 0xffffffff

	// IBUS0_ACS_MISS_CNT: register description
	// Position of IBUS0_ACS_MISS_CNT field.
	EXTMEM_IBUS0_ACS_MISS_CNT_IBUS0_ACS_MISS_CNT_Pos = 0x0
	// Bit mask of IBUS0_ACS_MISS_CNT field.
	EXTMEM_IBUS0_ACS_MISS_CNT_IBUS0_ACS_MISS_CNT_Msk = 0xffffffff

	// IBUS2_ACS_CNT: register description
	// Position of IBUS2_ACS_CNT field.
	EXTMEM_IBUS2_ACS_CNT_IBUS2_ACS_CNT_Pos = 0x0
	// Bit mask of IBUS2_ACS_CNT field.
	EXTMEM_IBUS2_ACS_CNT_IBUS2_ACS_CNT_Msk = 0xffffffff

	// IBUS1_ACS_CNT: register description
	// Position of IBUS1_ACS_CNT field.
	EXTMEM_IBUS1_ACS_CNT_IBUS1_ACS_CNT_Pos = 0x0
	// Bit mask of IBUS1_ACS_CNT field.
	EXTMEM_IBUS1_ACS_CNT_IBUS1_ACS_CNT_Msk = 0xffffffff

	// IBUS0_ACS_CNT: register description
	// Position of IBUS0_ACS_CNT field.
	EXTMEM_IBUS0_ACS_CNT_IBUS0_ACS_CNT_Pos = 0x0
	// Bit mask of IBUS0_ACS_CNT field.
	EXTMEM_IBUS0_ACS_CNT_IBUS0_ACS_CNT_Msk = 0xffffffff

	// DC_PRELOAD_CNT: register description
	// Position of DC_PRELOAD_CNT field.
	EXTMEM_DC_PRELOAD_CNT_DC_PRELOAD_CNT_Pos = 0x0
	// Bit mask of DC_PRELOAD_CNT field.
	EXTMEM_DC_PRELOAD_CNT_DC_PRELOAD_CNT_Msk = 0xffff

	// DC_PRELOAD_EVICT_CNT: register description
	// Position of DC_PRELOAD_EVICT_CNT field.
	EXTMEM_DC_PRELOAD_EVICT_CNT_DC_PRELOAD_EVICT_CNT_Pos = 0x0
	// Bit mask of DC_PRELOAD_EVICT_CNT field.
	EXTMEM_DC_PRELOAD_EVICT_CNT_DC_PRELOAD_EVICT_CNT_Msk = 0xffff

	// DC_PRELOAD_MISS_CNT: register description
	// Position of DC_PRELOAD_MISS_CNT field.
	EXTMEM_DC_PRELOAD_MISS_CNT_DC_PRELOAD_MISS_CNT_Pos = 0x0
	// Bit mask of DC_PRELOAD_MISS_CNT field.
	EXTMEM_DC_PRELOAD_MISS_CNT_DC_PRELOAD_MISS_CNT_Msk = 0xffff

	// DBUS2_ABANDON_CNT: register description
	// Position of DBUS2_ABANDON_CNT field.
	EXTMEM_DBUS2_ABANDON_CNT_DBUS2_ABANDON_CNT_Pos = 0x0
	// Bit mask of DBUS2_ABANDON_CNT field.
	EXTMEM_DBUS2_ABANDON_CNT_DBUS2_ABANDON_CNT_Msk = 0xffff

	// DBUS1_ABANDON_CNT: register description
	// Position of DBUS1_ABANDON_CNT field.
	EXTMEM_DBUS1_ABANDON_CNT_DBUS1_ABANDON_CNT_Pos = 0x0
	// Bit mask of DBUS1_ABANDON_CNT field.
	EXTMEM_DBUS1_ABANDON_CNT_DBUS1_ABANDON_CNT_Msk = 0xffff

	// DBUS0_ABANDON_CNT: register description
	// Position of DBUS0_ABANDON_CNT field.
	EXTMEM_DBUS0_ABANDON_CNT_DBUS0_ABANDON_CNT_Pos = 0x0
	// Bit mask of DBUS0_ABANDON_CNT field.
	EXTMEM_DBUS0_ABANDON_CNT_DBUS0_ABANDON_CNT_Msk = 0xffff

	// DBUS2_ACS_WB_CNT: register description
	// Position of DBUS2_ACS_WB_CNT field.
	EXTMEM_DBUS2_ACS_WB_CNT_DBUS2_ACS_WB_CNT_Pos = 0x0
	// Bit mask of DBUS2_ACS_WB_CNT field.
	EXTMEM_DBUS2_ACS_WB_CNT_DBUS2_ACS_WB_CNT_Msk = 0xfffff

	// DBUS1_ACS_WB_CNT: register description
	// Position of DBUS1_ACS_WB_CNT field.
	EXTMEM_DBUS1_ACS_WB_CNT_DBUS1_ACS_WB_CNT_Pos = 0x0
	// Bit mask of DBUS1_ACS_WB_CNT field.
	EXTMEM_DBUS1_ACS_WB_CNT_DBUS1_ACS_WB_CNT_Msk = 0xfffff

	// DBUS0_ACS_WB_CNT: register description
	// Position of DBUS0_ACS_WB_CNT field.
	EXTMEM_DBUS0_ACS_WB_CNT_DBUS0_ACS_WB_CNT_Pos = 0x0
	// Bit mask of DBUS0_ACS_WB_CNT field.
	EXTMEM_DBUS0_ACS_WB_CNT_DBUS0_ACS_WB_CNT_Msk = 0xfffff

	// DBUS2_ACS_MISS_CNT: register description
	// Position of DBUS2_ACS_MISS_CNT field.
	EXTMEM_DBUS2_ACS_MISS_CNT_DBUS2_ACS_MISS_CNT_Pos = 0x0
	// Bit mask of DBUS2_ACS_MISS_CNT field.
	EXTMEM_DBUS2_ACS_MISS_CNT_DBUS2_ACS_MISS_CNT_Msk = 0xffffffff

	// DBUS1_ACS_MISS_CNT: register description
	// Position of DBUS1_ACS_MISS_CNT field.
	EXTMEM_DBUS1_ACS_MISS_CNT_DBUS1_ACS_MISS_CNT_Pos = 0x0
	// Bit mask of DBUS1_ACS_MISS_CNT field.
	EXTMEM_DBUS1_ACS_MISS_CNT_DBUS1_ACS_MISS_CNT_Msk = 0xffffffff

	// DBUS0_ACS_MISS_CNT: register description
	// Position of DBUS0_ACS_MISS_CNT field.
	EXTMEM_DBUS0_ACS_MISS_CNT_DBUS0_ACS_MISS_CNT_Pos = 0x0
	// Bit mask of DBUS0_ACS_MISS_CNT field.
	EXTMEM_DBUS0_ACS_MISS_CNT_DBUS0_ACS_MISS_CNT_Msk = 0xffffffff

	// DBUS2_ACS_CNT: register description
	// Position of DBUS2_ACS_CNT field.
	EXTMEM_DBUS2_ACS_CNT_DBUS2_ACS_CNT_Pos = 0x0
	// Bit mask of DBUS2_ACS_CNT field.
	EXTMEM_DBUS2_ACS_CNT_DBUS2_ACS_CNT_Msk = 0xffffffff

	// DBUS1_ACS_CNT: register description
	// Position of DBUS1_ACS_CNT field.
	EXTMEM_DBUS1_ACS_CNT_DBUS1_ACS_CNT_Pos = 0x0
	// Bit mask of DBUS1_ACS_CNT field.
	EXTMEM_DBUS1_ACS_CNT_DBUS1_ACS_CNT_Msk = 0xffffffff

	// DBUS0_ACS_CNT: register description
	// Position of DBUS0_ACS_CNT field.
	EXTMEM_DBUS0_ACS_CNT_DBUS0_ACS_CNT_Pos = 0x0
	// Bit mask of DBUS0_ACS_CNT field.
	EXTMEM_DBUS0_ACS_CNT_DBUS0_ACS_CNT_Msk = 0xffffffff

	// CACHE_DBG_INT_ENA: register description
	// Position of CACHE_DBG_EN field.
	EXTMEM_CACHE_DBG_INT_ENA_CACHE_DBG_EN_Pos = 0x0
	// Bit mask of CACHE_DBG_EN field.
	EXTMEM_CACHE_DBG_INT_ENA_CACHE_DBG_EN_Msk = 0x1
	// Bit CACHE_DBG_EN.
	EXTMEM_CACHE_DBG_INT_ENA_CACHE_DBG_EN = 0x1
	// Position of IBUS_ACS_MSK_IC_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IBUS_ACS_MSK_IC_INT_ENA_Pos = 0x2
	// Bit mask of IBUS_ACS_MSK_IC_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IBUS_ACS_MSK_IC_INT_ENA_Msk = 0x4
	// Bit IBUS_ACS_MSK_IC_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_IBUS_ACS_MSK_IC_INT_ENA = 0x4
	// Position of IBUS_CNT_OVF_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IBUS_CNT_OVF_INT_ENA_Pos = 0x3
	// Bit mask of IBUS_CNT_OVF_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IBUS_CNT_OVF_INT_ENA_Msk = 0x8
	// Bit IBUS_CNT_OVF_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_IBUS_CNT_OVF_INT_ENA = 0x8
	// Position of IC_SYNC_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IC_SYNC_SIZE_FAULT_INT_ENA_Pos = 0x4
	// Bit mask of IC_SYNC_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IC_SYNC_SIZE_FAULT_INT_ENA_Msk = 0x10
	// Bit IC_SYNC_SIZE_FAULT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_IC_SYNC_SIZE_FAULT_INT_ENA = 0x10
	// Position of IC_PRELOAD_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IC_PRELOAD_SIZE_FAULT_INT_ENA_Pos = 0x5
	// Bit mask of IC_PRELOAD_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_IC_PRELOAD_SIZE_FAULT_INT_ENA_Msk = 0x20
	// Bit IC_PRELOAD_SIZE_FAULT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_IC_PRELOAD_SIZE_FAULT_INT_ENA = 0x20
	// Position of ICACHE_REJECT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_REJECT_INT_ENA_Pos = 0x6
	// Bit mask of ICACHE_REJECT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_REJECT_INT_ENA_Msk = 0x40
	// Bit ICACHE_REJECT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_REJECT_INT_ENA = 0x40
	// Position of ICACHE_SET_PRELOAD_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_PRELOAD_ILG_INT_ENA_Pos = 0x7
	// Bit mask of ICACHE_SET_PRELOAD_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_PRELOAD_ILG_INT_ENA_Msk = 0x80
	// Bit ICACHE_SET_PRELOAD_ILG_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_PRELOAD_ILG_INT_ENA = 0x80
	// Position of ICACHE_SET_SYNC_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_SYNC_ILG_INT_ENA_Pos = 0x8
	// Bit mask of ICACHE_SET_SYNC_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_SYNC_ILG_INT_ENA_Msk = 0x100
	// Bit ICACHE_SET_SYNC_ILG_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_SYNC_ILG_INT_ENA = 0x100
	// Position of ICACHE_SET_LOCK_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_LOCK_ILG_INT_ENA_Pos = 0x9
	// Bit mask of ICACHE_SET_LOCK_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_LOCK_ILG_INT_ENA_Msk = 0x200
	// Bit ICACHE_SET_LOCK_ILG_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_ICACHE_SET_LOCK_ILG_INT_ENA = 0x200
	// Position of DBUS_ACS_MSK_DC_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DBUS_ACS_MSK_DC_INT_ENA_Pos = 0xa
	// Bit mask of DBUS_ACS_MSK_DC_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DBUS_ACS_MSK_DC_INT_ENA_Msk = 0x400
	// Bit DBUS_ACS_MSK_DC_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DBUS_ACS_MSK_DC_INT_ENA = 0x400
	// Position of DBUS_CNT_OVF_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DBUS_CNT_OVF_INT_ENA_Pos = 0xb
	// Bit mask of DBUS_CNT_OVF_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DBUS_CNT_OVF_INT_ENA_Msk = 0x800
	// Bit DBUS_CNT_OVF_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DBUS_CNT_OVF_INT_ENA = 0x800
	// Position of DC_SYNC_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DC_SYNC_SIZE_FAULT_INT_ENA_Pos = 0xc
	// Bit mask of DC_SYNC_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DC_SYNC_SIZE_FAULT_INT_ENA_Msk = 0x1000
	// Bit DC_SYNC_SIZE_FAULT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DC_SYNC_SIZE_FAULT_INT_ENA = 0x1000
	// Position of DC_PRELOAD_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DC_PRELOAD_SIZE_FAULT_INT_ENA_Pos = 0xd
	// Bit mask of DC_PRELOAD_SIZE_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DC_PRELOAD_SIZE_FAULT_INT_ENA_Msk = 0x2000
	// Bit DC_PRELOAD_SIZE_FAULT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DC_PRELOAD_SIZE_FAULT_INT_ENA = 0x2000
	// Position of DCACHE_WRITE_FLASH_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_WRITE_FLASH_INT_ENA_Pos = 0xe
	// Bit mask of DCACHE_WRITE_FLASH_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_WRITE_FLASH_INT_ENA_Msk = 0x4000
	// Bit DCACHE_WRITE_FLASH_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_WRITE_FLASH_INT_ENA = 0x4000
	// Position of DCACHE_REJECT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_REJECT_INT_ENA_Pos = 0xf
	// Bit mask of DCACHE_REJECT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_REJECT_INT_ENA_Msk = 0x8000
	// Bit DCACHE_REJECT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_REJECT_INT_ENA = 0x8000
	// Position of DCACHE_SET_PRELOAD_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_PRELOAD_ILG_INT_ENA_Pos = 0x10
	// Bit mask of DCACHE_SET_PRELOAD_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_PRELOAD_ILG_INT_ENA_Msk = 0x10000
	// Bit DCACHE_SET_PRELOAD_ILG_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_PRELOAD_ILG_INT_ENA = 0x10000
	// Position of DCACHE_SET_SYNC_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_SYNC_ILG_INT_ENA_Pos = 0x11
	// Bit mask of DCACHE_SET_SYNC_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_SYNC_ILG_INT_ENA_Msk = 0x20000
	// Bit DCACHE_SET_SYNC_ILG_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_SYNC_ILG_INT_ENA = 0x20000
	// Position of DCACHE_SET_LOCK_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_LOCK_ILG_INT_ENA_Pos = 0x12
	// Bit mask of DCACHE_SET_LOCK_ILG_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_LOCK_ILG_INT_ENA_Msk = 0x40000
	// Bit DCACHE_SET_LOCK_ILG_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_DCACHE_SET_LOCK_ILG_INT_ENA = 0x40000
	// Position of MMU_ENTRY_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_MMU_ENTRY_FAULT_INT_ENA_Pos = 0x13
	// Bit mask of MMU_ENTRY_FAULT_INT_ENA field.
	EXTMEM_CACHE_DBG_INT_ENA_MMU_ENTRY_FAULT_INT_ENA_Msk = 0x80000
	// Bit MMU_ENTRY_FAULT_INT_ENA.
	EXTMEM_CACHE_DBG_INT_ENA_MMU_ENTRY_FAULT_INT_ENA = 0x80000

	// CACHE_DBG_INT_CLR: register description
	// Position of IBUS_ACS_MSK_IC_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IBUS_ACS_MSK_IC_INT_CLR_Pos = 0x0
	// Bit mask of IBUS_ACS_MSK_IC_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IBUS_ACS_MSK_IC_INT_CLR_Msk = 0x1
	// Bit IBUS_ACS_MSK_IC_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_IBUS_ACS_MSK_IC_INT_CLR = 0x1
	// Position of IBUS_CNT_OVF_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IBUS_CNT_OVF_INT_CLR_Pos = 0x1
	// Bit mask of IBUS_CNT_OVF_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IBUS_CNT_OVF_INT_CLR_Msk = 0x2
	// Bit IBUS_CNT_OVF_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_IBUS_CNT_OVF_INT_CLR = 0x2
	// Position of IC_SYNC_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IC_SYNC_SIZE_FAULT_INT_CLR_Pos = 0x2
	// Bit mask of IC_SYNC_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IC_SYNC_SIZE_FAULT_INT_CLR_Msk = 0x4
	// Bit IC_SYNC_SIZE_FAULT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_IC_SYNC_SIZE_FAULT_INT_CLR = 0x4
	// Position of IC_PRELOAD_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IC_PRELOAD_SIZE_FAULT_INT_CLR_Pos = 0x3
	// Bit mask of IC_PRELOAD_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_IC_PRELOAD_SIZE_FAULT_INT_CLR_Msk = 0x8
	// Bit IC_PRELOAD_SIZE_FAULT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_IC_PRELOAD_SIZE_FAULT_INT_CLR = 0x8
	// Position of ICACHE_REJECT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_ICACHE_REJECT_INT_CLR_Pos = 0x4
	// Bit mask of ICACHE_REJECT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_ICACHE_REJECT_INT_CLR_Msk = 0x10
	// Bit ICACHE_REJECT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_ICACHE_REJECT_INT_CLR = 0x10
	// Position of ICACHE_SET_ILG_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_ICACHE_SET_ILG_INT_CLR_Pos = 0x5
	// Bit mask of ICACHE_SET_ILG_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_ICACHE_SET_ILG_INT_CLR_Msk = 0x20
	// Bit ICACHE_SET_ILG_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_ICACHE_SET_ILG_INT_CLR = 0x20
	// Position of DBUS_ACS_MSK_DC_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DBUS_ACS_MSK_DC_INT_CLR_Pos = 0x6
	// Bit mask of DBUS_ACS_MSK_DC_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DBUS_ACS_MSK_DC_INT_CLR_Msk = 0x40
	// Bit DBUS_ACS_MSK_DC_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DBUS_ACS_MSK_DC_INT_CLR = 0x40
	// Position of DBUS_CNT_OVF_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DBUS_CNT_OVF_INT_CLR_Pos = 0x7
	// Bit mask of DBUS_CNT_OVF_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DBUS_CNT_OVF_INT_CLR_Msk = 0x80
	// Bit DBUS_CNT_OVF_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DBUS_CNT_OVF_INT_CLR = 0x80
	// Position of DC_SYNC_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DC_SYNC_SIZE_FAULT_INT_CLR_Pos = 0x8
	// Bit mask of DC_SYNC_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DC_SYNC_SIZE_FAULT_INT_CLR_Msk = 0x100
	// Bit DC_SYNC_SIZE_FAULT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DC_SYNC_SIZE_FAULT_INT_CLR = 0x100
	// Position of DC_PRELOAD_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DC_PRELOAD_SIZE_FAULT_INT_CLR_Pos = 0x9
	// Bit mask of DC_PRELOAD_SIZE_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DC_PRELOAD_SIZE_FAULT_INT_CLR_Msk = 0x200
	// Bit DC_PRELOAD_SIZE_FAULT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DC_PRELOAD_SIZE_FAULT_INT_CLR = 0x200
	// Position of DCACHE_WRITE_FLASH_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_WRITE_FLASH_INT_CLR_Pos = 0xa
	// Bit mask of DCACHE_WRITE_FLASH_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_WRITE_FLASH_INT_CLR_Msk = 0x400
	// Bit DCACHE_WRITE_FLASH_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_WRITE_FLASH_INT_CLR = 0x400
	// Position of DCACHE_REJECT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_REJECT_INT_CLR_Pos = 0xb
	// Bit mask of DCACHE_REJECT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_REJECT_INT_CLR_Msk = 0x800
	// Bit DCACHE_REJECT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_REJECT_INT_CLR = 0x800
	// Position of DCACHE_SET_ILG_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_SET_ILG_INT_CLR_Pos = 0xc
	// Bit mask of DCACHE_SET_ILG_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_SET_ILG_INT_CLR_Msk = 0x1000
	// Bit DCACHE_SET_ILG_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_DCACHE_SET_ILG_INT_CLR = 0x1000
	// Position of MMU_ENTRY_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_MMU_ENTRY_FAULT_INT_CLR_Pos = 0xd
	// Bit mask of MMU_ENTRY_FAULT_INT_CLR field.
	EXTMEM_CACHE_DBG_INT_CLR_MMU_ENTRY_FAULT_INT_CLR_Msk = 0x2000
	// Bit MMU_ENTRY_FAULT_INT_CLR.
	EXTMEM_CACHE_DBG_INT_CLR_MMU_ENTRY_FAULT_INT_CLR = 0x2000

	// CACHE_DBG_STATUS0: register description
	// Position of IBUS0_ACS_MSK_ICACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_MSK_ICACHE_ST_Pos = 0x0
	// Bit mask of IBUS0_ACS_MSK_ICACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_MSK_ICACHE_ST_Msk = 0x1
	// Bit IBUS0_ACS_MSK_ICACHE_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_MSK_ICACHE_ST = 0x1
	// Position of IBUS1_ACS_MSK_ICACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_MSK_ICACHE_ST_Pos = 0x1
	// Bit mask of IBUS1_ACS_MSK_ICACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_MSK_ICACHE_ST_Msk = 0x2
	// Bit IBUS1_ACS_MSK_ICACHE_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_MSK_ICACHE_ST = 0x2
	// Position of IBUS2_ACS_MSK_ICACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_MSK_ICACHE_ST_Pos = 0x2
	// Bit mask of IBUS2_ACS_MSK_ICACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_MSK_ICACHE_ST_Msk = 0x4
	// Bit IBUS2_ACS_MSK_ICACHE_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_MSK_ICACHE_ST = 0x4
	// Position of IBUS0_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_CNT_OVF_ST_Pos = 0x4
	// Bit mask of IBUS0_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_CNT_OVF_ST_Msk = 0x10
	// Bit IBUS0_ACS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_CNT_OVF_ST = 0x10
	// Position of IBUS1_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_CNT_OVF_ST_Pos = 0x5
	// Bit mask of IBUS1_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_CNT_OVF_ST_Msk = 0x20
	// Bit IBUS1_ACS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_CNT_OVF_ST = 0x20
	// Position of IBUS2_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_CNT_OVF_ST_Pos = 0x6
	// Bit mask of IBUS2_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_CNT_OVF_ST_Msk = 0x40
	// Bit IBUS2_ACS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_CNT_OVF_ST = 0x40
	// Position of IBUS0_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_MISS_CNT_OVF_ST_Pos = 0x8
	// Bit mask of IBUS0_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_MISS_CNT_OVF_ST_Msk = 0x100
	// Bit IBUS0_ACS_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ACS_MISS_CNT_OVF_ST = 0x100
	// Position of IBUS1_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_MISS_CNT_OVF_ST_Pos = 0x9
	// Bit mask of IBUS1_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_MISS_CNT_OVF_ST_Msk = 0x200
	// Bit IBUS1_ACS_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ACS_MISS_CNT_OVF_ST = 0x200
	// Position of IBUS2_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_MISS_CNT_OVF_ST_Pos = 0xa
	// Bit mask of IBUS2_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_MISS_CNT_OVF_ST_Msk = 0x400
	// Bit IBUS2_ACS_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ACS_MISS_CNT_OVF_ST = 0x400
	// Position of IBUS0_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ABANDON_CNT_OVF_ST_Pos = 0xc
	// Bit mask of IBUS0_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ABANDON_CNT_OVF_ST_Msk = 0x1000
	// Bit IBUS0_ABANDON_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS0_ABANDON_CNT_OVF_ST = 0x1000
	// Position of IBUS1_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ABANDON_CNT_OVF_ST_Pos = 0xd
	// Bit mask of IBUS1_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ABANDON_CNT_OVF_ST_Msk = 0x2000
	// Bit IBUS1_ABANDON_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS1_ABANDON_CNT_OVF_ST = 0x2000
	// Position of IBUS2_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ABANDON_CNT_OVF_ST_Pos = 0xe
	// Bit mask of IBUS2_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ABANDON_CNT_OVF_ST_Msk = 0x4000
	// Bit IBUS2_ABANDON_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IBUS2_ABANDON_CNT_OVF_ST = 0x4000
	// Position of IC_PRELOAD_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_MISS_CNT_OVF_ST_Pos = 0x10
	// Bit mask of IC_PRELOAD_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_MISS_CNT_OVF_ST_Msk = 0x10000
	// Bit IC_PRELOAD_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_MISS_CNT_OVF_ST = 0x10000
	// Position of IC_PRELOAD_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_CNT_OVF_ST_Pos = 0x12
	// Bit mask of IC_PRELOAD_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_CNT_OVF_ST_Msk = 0x40000
	// Bit IC_PRELOAD_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_CNT_OVF_ST = 0x40000
	// Position of IC_SYNC_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_SYNC_SIZE_FAULT_ST_Pos = 0x13
	// Bit mask of IC_SYNC_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_SYNC_SIZE_FAULT_ST_Msk = 0x80000
	// Bit IC_SYNC_SIZE_FAULT_ST.
	EXTMEM_CACHE_DBG_STATUS0_IC_SYNC_SIZE_FAULT_ST = 0x80000
	// Position of IC_PRELOAD_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_SIZE_FAULT_ST_Pos = 0x14
	// Bit mask of IC_PRELOAD_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_SIZE_FAULT_ST_Msk = 0x100000
	// Bit IC_PRELOAD_SIZE_FAULT_ST.
	EXTMEM_CACHE_DBG_STATUS0_IC_PRELOAD_SIZE_FAULT_ST = 0x100000
	// Position of ICACHE_REJECT_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_REJECT_ST_Pos = 0x15
	// Bit mask of ICACHE_REJECT_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_REJECT_ST_Msk = 0x200000
	// Bit ICACHE_REJECT_ST.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_REJECT_ST = 0x200000
	// Position of ICACHE_SET_PRELOAD_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_PRELOAD_ILG_ST_Pos = 0x16
	// Bit mask of ICACHE_SET_PRELOAD_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_PRELOAD_ILG_ST_Msk = 0x400000
	// Bit ICACHE_SET_PRELOAD_ILG_ST.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_PRELOAD_ILG_ST = 0x400000
	// Position of ICACHE_SET_SYNC_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_SYNC_ILG_ST_Pos = 0x17
	// Bit mask of ICACHE_SET_SYNC_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_SYNC_ILG_ST_Msk = 0x800000
	// Bit ICACHE_SET_SYNC_ILG_ST.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_SYNC_ILG_ST = 0x800000
	// Position of ICACHE_SET_LOCK_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_LOCK_ILG_ST_Pos = 0x18
	// Bit mask of ICACHE_SET_LOCK_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_LOCK_ILG_ST_Msk = 0x1000000
	// Bit ICACHE_SET_LOCK_ILG_ST.
	EXTMEM_CACHE_DBG_STATUS0_ICACHE_SET_LOCK_ILG_ST = 0x1000000

	// CACHE_DBG_STATUS1: register description
	// Position of DBUS0_ACS_MSK_DCACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_MSK_DCACHE_ST_Pos = 0x0
	// Bit mask of DBUS0_ACS_MSK_DCACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_MSK_DCACHE_ST_Msk = 0x1
	// Bit DBUS0_ACS_MSK_DCACHE_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_MSK_DCACHE_ST = 0x1
	// Position of DBUS1_ACS_MSK_DCACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_MSK_DCACHE_ST_Pos = 0x1
	// Bit mask of DBUS1_ACS_MSK_DCACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_MSK_DCACHE_ST_Msk = 0x2
	// Bit DBUS1_ACS_MSK_DCACHE_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_MSK_DCACHE_ST = 0x2
	// Position of DBUS2_ACS_MSK_DCACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_MSK_DCACHE_ST_Pos = 0x2
	// Bit mask of DBUS2_ACS_MSK_DCACHE_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_MSK_DCACHE_ST_Msk = 0x4
	// Bit DBUS2_ACS_MSK_DCACHE_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_MSK_DCACHE_ST = 0x4
	// Position of DBUS0_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_CNT_OVF_ST_Pos = 0x4
	// Bit mask of DBUS0_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_CNT_OVF_ST_Msk = 0x10
	// Bit DBUS0_ACS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_CNT_OVF_ST = 0x10
	// Position of DBUS1_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_CNT_OVF_ST_Pos = 0x5
	// Bit mask of DBUS1_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_CNT_OVF_ST_Msk = 0x20
	// Bit DBUS1_ACS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_CNT_OVF_ST = 0x20
	// Position of DBUS2_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_CNT_OVF_ST_Pos = 0x6
	// Bit mask of DBUS2_ACS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_CNT_OVF_ST_Msk = 0x40
	// Bit DBUS2_ACS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_CNT_OVF_ST = 0x40
	// Position of DBUS0_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_MISS_CNT_OVF_ST_Pos = 0x8
	// Bit mask of DBUS0_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_MISS_CNT_OVF_ST_Msk = 0x100
	// Bit DBUS0_ACS_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_MISS_CNT_OVF_ST = 0x100
	// Position of DBUS1_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_MISS_CNT_OVF_ST_Pos = 0x9
	// Bit mask of DBUS1_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_MISS_CNT_OVF_ST_Msk = 0x200
	// Bit DBUS1_ACS_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_MISS_CNT_OVF_ST = 0x200
	// Position of DBUS2_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_MISS_CNT_OVF_ST_Pos = 0xa
	// Bit mask of DBUS2_ACS_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_MISS_CNT_OVF_ST_Msk = 0x400
	// Bit DBUS2_ACS_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_MISS_CNT_OVF_ST = 0x400
	// Position of DBUS0_ACS_WB_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_WB_CNT_OVF_ST_Pos = 0xc
	// Bit mask of DBUS0_ACS_WB_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_WB_CNT_OVF_ST_Msk = 0x1000
	// Bit DBUS0_ACS_WB_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ACS_WB_CNT_OVF_ST = 0x1000
	// Position of DBUS1_ACS_WB_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_WB_CNT_OVF_ST_Pos = 0xd
	// Bit mask of DBUS1_ACS_WB_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_WB_CNT_OVF_ST_Msk = 0x2000
	// Bit DBUS1_ACS_WB_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ACS_WB_CNT_OVF_ST = 0x2000
	// Position of DBUS2_ACS_WB_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_WB_CNT_OVF_ST_Pos = 0xe
	// Bit mask of DBUS2_ACS_WB_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_WB_CNT_OVF_ST_Msk = 0x4000
	// Bit DBUS2_ACS_WB_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ACS_WB_CNT_OVF_ST = 0x4000
	// Position of DBUS0_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ABANDON_CNT_OVF_ST_Pos = 0x10
	// Bit mask of DBUS0_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ABANDON_CNT_OVF_ST_Msk = 0x10000
	// Bit DBUS0_ABANDON_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS0_ABANDON_CNT_OVF_ST = 0x10000
	// Position of DBUS1_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ABANDON_CNT_OVF_ST_Pos = 0x11
	// Bit mask of DBUS1_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ABANDON_CNT_OVF_ST_Msk = 0x20000
	// Bit DBUS1_ABANDON_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS1_ABANDON_CNT_OVF_ST = 0x20000
	// Position of DBUS2_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ABANDON_CNT_OVF_ST_Pos = 0x12
	// Bit mask of DBUS2_ABANDON_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ABANDON_CNT_OVF_ST_Msk = 0x40000
	// Bit DBUS2_ABANDON_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DBUS2_ABANDON_CNT_OVF_ST = 0x40000
	// Position of DC_PRELOAD_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_MISS_CNT_OVF_ST_Pos = 0x14
	// Bit mask of DC_PRELOAD_MISS_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_MISS_CNT_OVF_ST_Msk = 0x100000
	// Bit DC_PRELOAD_MISS_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_MISS_CNT_OVF_ST = 0x100000
	// Position of DC_PRELOAD_EVICT_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_EVICT_CNT_OVF_ST_Pos = 0x15
	// Bit mask of DC_PRELOAD_EVICT_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_EVICT_CNT_OVF_ST_Msk = 0x200000
	// Bit DC_PRELOAD_EVICT_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_EVICT_CNT_OVF_ST = 0x200000
	// Position of DC_PRELOAD_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_CNT_OVF_ST_Pos = 0x16
	// Bit mask of DC_PRELOAD_CNT_OVF_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_CNT_OVF_ST_Msk = 0x400000
	// Bit DC_PRELOAD_CNT_OVF_ST.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_CNT_OVF_ST = 0x400000
	// Position of DC_SYNC_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_SYNC_SIZE_FAULT_ST_Pos = 0x17
	// Bit mask of DC_SYNC_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_SYNC_SIZE_FAULT_ST_Msk = 0x800000
	// Bit DC_SYNC_SIZE_FAULT_ST.
	EXTMEM_CACHE_DBG_STATUS1_DC_SYNC_SIZE_FAULT_ST = 0x800000
	// Position of DC_PRELOAD_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_SIZE_FAULT_ST_Pos = 0x18
	// Bit mask of DC_PRELOAD_SIZE_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_SIZE_FAULT_ST_Msk = 0x1000000
	// Bit DC_PRELOAD_SIZE_FAULT_ST.
	EXTMEM_CACHE_DBG_STATUS1_DC_PRELOAD_SIZE_FAULT_ST = 0x1000000
	// Position of DCACHE_WRITE_FLASH_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_WRITE_FLASH_ST_Pos = 0x19
	// Bit mask of DCACHE_WRITE_FLASH_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_WRITE_FLASH_ST_Msk = 0x2000000
	// Bit DCACHE_WRITE_FLASH_ST.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_WRITE_FLASH_ST = 0x2000000
	// Position of DCACHE_REJECT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_REJECT_ST_Pos = 0x1a
	// Bit mask of DCACHE_REJECT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_REJECT_ST_Msk = 0x4000000
	// Bit DCACHE_REJECT_ST.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_REJECT_ST = 0x4000000
	// Position of DCACHE_SET_PRELOAD_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_PRELOAD_ILG_ST_Pos = 0x1b
	// Bit mask of DCACHE_SET_PRELOAD_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_PRELOAD_ILG_ST_Msk = 0x8000000
	// Bit DCACHE_SET_PRELOAD_ILG_ST.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_PRELOAD_ILG_ST = 0x8000000
	// Position of DCACHE_SET_SYNC_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_SYNC_ILG_ST_Pos = 0x1c
	// Bit mask of DCACHE_SET_SYNC_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_SYNC_ILG_ST_Msk = 0x10000000
	// Bit DCACHE_SET_SYNC_ILG_ST.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_SYNC_ILG_ST = 0x10000000
	// Position of DCACHE_SET_LOCK_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_LOCK_ILG_ST_Pos = 0x1d
	// Bit mask of DCACHE_SET_LOCK_ILG_ST field.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_LOCK_ILG_ST_Msk = 0x20000000
	// Bit DCACHE_SET_LOCK_ILG_ST.
	EXTMEM_CACHE_DBG_STATUS1_DCACHE_SET_LOCK_ILG_ST = 0x20000000
	// Position of MMU_ENTRY_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_MMU_ENTRY_FAULT_ST_Pos = 0x1e
	// Bit mask of MMU_ENTRY_FAULT_ST field.
	EXTMEM_CACHE_DBG_STATUS1_MMU_ENTRY_FAULT_ST_Msk = 0x40000000
	// Bit MMU_ENTRY_FAULT_ST.
	EXTMEM_CACHE_DBG_STATUS1_MMU_ENTRY_FAULT_ST = 0x40000000

	// PRO_CACHE_ACS_CNT_CLR: register description
	// Position of PRO_DCACHE_ACS_CNT_CLR field.
	EXTMEM_PRO_CACHE_ACS_CNT_CLR_PRO_DCACHE_ACS_CNT_CLR_Pos = 0x0
	// Bit mask of PRO_DCACHE_ACS_CNT_CLR field.
	EXTMEM_PRO_CACHE_ACS_CNT_CLR_PRO_DCACHE_ACS_CNT_CLR_Msk = 0x1
	// Bit PRO_DCACHE_ACS_CNT_CLR.
	EXTMEM_PRO_CACHE_ACS_CNT_CLR_PRO_DCACHE_ACS_CNT_CLR = 0x1
	// Position of PRO_ICACHE_ACS_CNT_CLR field.
	EXTMEM_PRO_CACHE_ACS_CNT_CLR_PRO_ICACHE_ACS_CNT_CLR_Pos = 0x1
	// Bit mask of PRO_ICACHE_ACS_CNT_CLR field.
	EXTMEM_PRO_CACHE_ACS_CNT_CLR_PRO_ICACHE_ACS_CNT_CLR_Msk = 0x2
	// Bit PRO_ICACHE_ACS_CNT_CLR.
	EXTMEM_PRO_CACHE_ACS_CNT_CLR_PRO_ICACHE_ACS_CNT_CLR = 0x2

	// PRO_DCACHE_REJECT_ST: register description
	// Position of PRO_DCACHE_TAG_ATTR field.
	EXTMEM_PRO_DCACHE_REJECT_ST_PRO_DCACHE_TAG_ATTR_Pos = 0x0
	// Bit mask of PRO_DCACHE_TAG_ATTR field.
	EXTMEM_PRO_DCACHE_REJECT_ST_PRO_DCACHE_TAG_ATTR_Msk = 0x7
	// Position of PRO_DCACHE_CPU_ATTR field.
	EXTMEM_PRO_DCACHE_REJECT_ST_PRO_DCACHE_CPU_ATTR_Pos = 0x3
	// Bit mask of PRO_DCACHE_CPU_ATTR field.
	EXTMEM_PRO_DCACHE_REJECT_ST_PRO_DCACHE_CPU_ATTR_Msk = 0x38

	// PRO_DCACHE_REJECT_VADDR: register description
	// Position of PRO_DCACHE_CPU_VADDR field.
	EXTMEM_PRO_DCACHE_REJECT_VADDR_PRO_DCACHE_CPU_VADDR_Pos = 0x0
	// Bit mask of PRO_DCACHE_CPU_VADDR field.
	EXTMEM_PRO_DCACHE_REJECT_VADDR_PRO_DCACHE_CPU_VADDR_Msk = 0xffffffff

	// PRO_ICACHE_REJECT_ST: register description
	// Position of PRO_ICACHE_TAG_ATTR field.
	EXTMEM_PRO_ICACHE_REJECT_ST_PRO_ICACHE_TAG_ATTR_Pos = 0x0
	// Bit mask of PRO_ICACHE_TAG_ATTR field.
	EXTMEM_PRO_ICACHE_REJECT_ST_PRO_ICACHE_TAG_ATTR_Msk = 0x7
	// Position of PRO_ICACHE_CPU_ATTR field.
	EXTMEM_PRO_ICACHE_REJECT_ST_PRO_ICACHE_CPU_ATTR_Pos = 0x3
	// Bit mask of PRO_ICACHE_CPU_ATTR field.
	EXTMEM_PRO_ICACHE_REJECT_ST_PRO_ICACHE_CPU_ATTR_Msk = 0x38

	// PRO_ICACHE_REJECT_VADDR: register description
	// Position of PRO_ICACHE_CPU_VADDR field.
	EXTMEM_PRO_ICACHE_REJECT_VADDR_PRO_ICACHE_CPU_VADDR_Pos = 0x0
	// Bit mask of PRO_ICACHE_CPU_VADDR field.
	EXTMEM_PRO_ICACHE_REJECT_VADDR_PRO_ICACHE_CPU_VADDR_Msk = 0xffffffff

	// PRO_CACHE_MMU_FAULT_CONTENT: register description
	// Position of PRO_CACHE_MMU_FAULT_CONTENT field.
	EXTMEM_PRO_CACHE_MMU_FAULT_CONTENT_PRO_CACHE_MMU_FAULT_CONTENT_Pos = 0x0
	// Bit mask of PRO_CACHE_MMU_FAULT_CONTENT field.
	EXTMEM_PRO_CACHE_MMU_FAULT_CONTENT_PRO_CACHE_MMU_FAULT_CONTENT_Msk = 0x1ffff
	// Position of PRO_CACHE_MMU_FAULT_CODE field.
	EXTMEM_PRO_CACHE_MMU_FAULT_CONTENT_PRO_CACHE_MMU_FAULT_CODE_Pos = 0x11
	// Bit mask of PRO_CACHE_MMU_FAULT_CODE field.
	EXTMEM_PRO_CACHE_MMU_FAULT_CONTENT_PRO_CACHE_MMU_FAULT_CODE_Msk = 0xe0000

	// PRO_CACHE_MMU_FAULT_VADDR: register description
	// Position of PRO_CACHE_MMU_FAULT_VADDR field.
	EXTMEM_PRO_CACHE_MMU_FAULT_VADDR_PRO_CACHE_MMU_FAULT_VADDR_Pos = 0x0
	// Bit mask of PRO_CACHE_MMU_FAULT_VADDR field.
	EXTMEM_PRO_CACHE_MMU_FAULT_VADDR_PRO_CACHE_MMU_FAULT_VADDR_Msk = 0xffffffff

	// PRO_CACHE_WRAP_AROUND_CTRL: register description
	// Position of PRO_CACHE_FLASH_WRAP_AROUND field.
	EXTMEM_PRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_FLASH_WRAP_AROUND_Pos = 0x0
	// Bit mask of PRO_CACHE_FLASH_WRAP_AROUND field.
	EXTMEM_PRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_FLASH_WRAP_AROUND_Msk = 0x1
	// Bit PRO_CACHE_FLASH_WRAP_AROUND.
	EXTMEM_PRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_FLASH_WRAP_AROUND = 0x1
	// Position of PRO_CACHE_SRAM_RD_WRAP_AROUND field.
	EXTMEM_PRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_SRAM_RD_WRAP_AROUND_Pos = 0x1
	// Bit mask of PRO_CACHE_SRAM_RD_WRAP_AROUND field.
	EXTMEM_PRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_SRAM_RD_WRAP_AROUND_Msk = 0x2
	// Bit PRO_CACHE_SRAM_RD_WRAP_AROUND.
	EXTMEM_PRO_CACHE_WRAP_AROUND_CTRL_PRO_CACHE_SRAM_RD_WRAP_AROUND = 0x2

	// PRO_CACHE_MMU_POWER_CTRL: register description
	// Position of PRO_CACHE_MMU_MEM_FORCE_ON field.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_ON_Pos = 0x0
	// Bit mask of PRO_CACHE_MMU_MEM_FORCE_ON field.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_ON_Msk = 0x1
	// Bit PRO_CACHE_MMU_MEM_FORCE_ON.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_ON = 0x1
	// Position of PRO_CACHE_MMU_MEM_FORCE_PD field.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PD_Pos = 0x1
	// Bit mask of PRO_CACHE_MMU_MEM_FORCE_PD field.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PD_Msk = 0x2
	// Bit PRO_CACHE_MMU_MEM_FORCE_PD.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PD = 0x2
	// Position of PRO_CACHE_MMU_MEM_FORCE_PU field.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of PRO_CACHE_MMU_MEM_FORCE_PU field.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PU_Msk = 0x4
	// Bit PRO_CACHE_MMU_MEM_FORCE_PU.
	EXTMEM_PRO_CACHE_MMU_POWER_CTRL_PRO_CACHE_MMU_MEM_FORCE_PU = 0x4

	// PRO_CACHE_STATE: register description
	// Position of PRO_ICACHE_STATE field.
	EXTMEM_PRO_CACHE_STATE_PRO_ICACHE_STATE_Pos = 0x0
	// Bit mask of PRO_ICACHE_STATE field.
	EXTMEM_PRO_CACHE_STATE_PRO_ICACHE_STATE_Msk = 0xfff
	// Position of PRO_DCACHE_STATE field.
	EXTMEM_PRO_CACHE_STATE_PRO_DCACHE_STATE_Pos = 0xc
	// Bit mask of PRO_DCACHE_STATE field.
	EXTMEM_PRO_CACHE_STATE_PRO_DCACHE_STATE_Msk = 0xfff000

	// CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE: register description
	// Position of RECORD_DISABLE_DB_ENCRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_DB_ENCRYPT_Pos = 0x0
	// Bit mask of RECORD_DISABLE_DB_ENCRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_DB_ENCRYPT_Msk = 0x1
	// Bit RECORD_DISABLE_DB_ENCRYPT.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_DB_ENCRYPT = 0x1
	// Position of RECORD_DISABLE_G0CB_DECRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_G0CB_DECRYPT_Pos = 0x1
	// Bit mask of RECORD_DISABLE_G0CB_DECRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_G0CB_DECRYPT_Msk = 0x2
	// Bit RECORD_DISABLE_G0CB_DECRYPT.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE_RECORD_DISABLE_G0CB_DECRYPT = 0x2

	// CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON: register description
	// Position of CLK_FORCE_ON_DB_ENCRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_DB_ENCRYPT_Pos = 0x0
	// Bit mask of CLK_FORCE_ON_DB_ENCRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_DB_ENCRYPT_Msk = 0x1
	// Bit CLK_FORCE_ON_DB_ENCRYPT.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_DB_ENCRYPT = 0x1
	// Position of CLK_FORCE_ON_G0CB_DECRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_G0CB_DECRYPT_Pos = 0x1
	// Bit mask of CLK_FORCE_ON_G0CB_DECRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_G0CB_DECRYPT_Msk = 0x2
	// Bit CLK_FORCE_ON_G0CB_DECRYPT.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_G0CB_DECRYPT = 0x2
	// Position of CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT_Pos = 0x2
	// Bit mask of CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT field.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT_Msk = 0x4
	// Bit CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT.
	EXTMEM_CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON_CLK_FORCE_ON_AUTOMATIC_ENCRYPT_DECRYPT = 0x4

	// CACHE_BRIDGE_ARBITER_CTRL: register description
	// Position of ALLOC_WB_HOLD_ARBITER field.
	EXTMEM_CACHE_BRIDGE_ARBITER_CTRL_ALLOC_WB_HOLD_ARBITER_Pos = 0x0
	// Bit mask of ALLOC_WB_HOLD_ARBITER field.
	EXTMEM_CACHE_BRIDGE_ARBITER_CTRL_ALLOC_WB_HOLD_ARBITER_Msk = 0x1
	// Bit ALLOC_WB_HOLD_ARBITER.
	EXTMEM_CACHE_BRIDGE_ARBITER_CTRL_ALLOC_WB_HOLD_ARBITER = 0x1

	// CACHE_PRELOAD_INT_CTRL: register description
	// Position of PRO_ICACHE_PRELOAD_INT_ST field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ST_Pos = 0x0
	// Bit mask of PRO_ICACHE_PRELOAD_INT_ST field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ST_Msk = 0x1
	// Bit PRO_ICACHE_PRELOAD_INT_ST.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ST = 0x1
	// Position of PRO_ICACHE_PRELOAD_INT_ENA field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ENA_Pos = 0x1
	// Bit mask of PRO_ICACHE_PRELOAD_INT_ENA field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ENA_Msk = 0x2
	// Bit PRO_ICACHE_PRELOAD_INT_ENA.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_ENA = 0x2
	// Position of PRO_ICACHE_PRELOAD_INT_CLR field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_CLR_Pos = 0x2
	// Bit mask of PRO_ICACHE_PRELOAD_INT_CLR field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_CLR_Msk = 0x4
	// Bit PRO_ICACHE_PRELOAD_INT_CLR.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_ICACHE_PRELOAD_INT_CLR = 0x4
	// Position of PRO_DCACHE_PRELOAD_INT_ST field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ST_Pos = 0x3
	// Bit mask of PRO_DCACHE_PRELOAD_INT_ST field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ST_Msk = 0x8
	// Bit PRO_DCACHE_PRELOAD_INT_ST.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ST = 0x8
	// Position of PRO_DCACHE_PRELOAD_INT_ENA field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ENA_Pos = 0x4
	// Bit mask of PRO_DCACHE_PRELOAD_INT_ENA field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ENA_Msk = 0x10
	// Bit PRO_DCACHE_PRELOAD_INT_ENA.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_ENA = 0x10
	// Position of PRO_DCACHE_PRELOAD_INT_CLR field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_CLR_Pos = 0x5
	// Bit mask of PRO_DCACHE_PRELOAD_INT_CLR field.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_CLR_Msk = 0x20
	// Bit PRO_DCACHE_PRELOAD_INT_CLR.
	EXTMEM_CACHE_PRELOAD_INT_CTRL_PRO_DCACHE_PRELOAD_INT_CLR = 0x20

	// CACHE_SYNC_INT_CTRL: register description
	// Position of PRO_ICACHE_SYNC_INT_ST field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ST_Pos = 0x0
	// Bit mask of PRO_ICACHE_SYNC_INT_ST field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ST_Msk = 0x1
	// Bit PRO_ICACHE_SYNC_INT_ST.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ST = 0x1
	// Position of PRO_ICACHE_SYNC_INT_ENA field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ENA_Pos = 0x1
	// Bit mask of PRO_ICACHE_SYNC_INT_ENA field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ENA_Msk = 0x2
	// Bit PRO_ICACHE_SYNC_INT_ENA.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_ENA = 0x2
	// Position of PRO_ICACHE_SYNC_INT_CLR field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_CLR_Pos = 0x2
	// Bit mask of PRO_ICACHE_SYNC_INT_CLR field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_CLR_Msk = 0x4
	// Bit PRO_ICACHE_SYNC_INT_CLR.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_ICACHE_SYNC_INT_CLR = 0x4
	// Position of PRO_DCACHE_SYNC_INT_ST field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ST_Pos = 0x3
	// Bit mask of PRO_DCACHE_SYNC_INT_ST field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ST_Msk = 0x8
	// Bit PRO_DCACHE_SYNC_INT_ST.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ST = 0x8
	// Position of PRO_DCACHE_SYNC_INT_ENA field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ENA_Pos = 0x4
	// Bit mask of PRO_DCACHE_SYNC_INT_ENA field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ENA_Msk = 0x10
	// Bit PRO_DCACHE_SYNC_INT_ENA.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_ENA = 0x10
	// Position of PRO_DCACHE_SYNC_INT_CLR field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_CLR_Pos = 0x5
	// Bit mask of PRO_DCACHE_SYNC_INT_CLR field.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_CLR_Msk = 0x20
	// Bit PRO_DCACHE_SYNC_INT_CLR.
	EXTMEM_CACHE_SYNC_INT_CTRL_PRO_DCACHE_SYNC_INT_CLR = 0x20

	// CACHE_CONF_MISC: register description
	// Position of PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT field.
	EXTMEM_CACHE_CONF_MISC_PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT_Pos = 0x0
	// Bit mask of PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT field.
	EXTMEM_CACHE_CONF_MISC_PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT_Msk = 0x1
	// Bit PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT.
	EXTMEM_CACHE_CONF_MISC_PRO_CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT = 0x1
	// Position of PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT field.
	EXTMEM_CACHE_CONF_MISC_PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT_Pos = 0x1
	// Bit mask of PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT field.
	EXTMEM_CACHE_CONF_MISC_PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT_Msk = 0x2
	// Bit PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT.
	EXTMEM_CACHE_CONF_MISC_PRO_CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT = 0x2

	// CLOCK_GATE: register description
	// Position of CLK_EN field.
	EXTMEM_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	EXTMEM_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	EXTMEM_CLOCK_GATE_CLK_EN = 0x1

	// PRO_EXTMEM_REG_DATE: register description
	// Position of PRO_EXTMEM_REG_DATE field.
	EXTMEM_PRO_EXTMEM_REG_DATE_PRO_EXTMEM_REG_DATE_Pos = 0x0
	// Bit mask of PRO_EXTMEM_REG_DATE field.
	EXTMEM_PRO_EXTMEM_REG_DATE_PRO_EXTMEM_REG_DATE_Msk = 0xfffffff
)

// Constants for GPIO: General Purpose Input/Output
const (
	// BT_SELECT: GPIO bit select register
	// Position of BT_SEL field.
	GPIO_BT_SELECT_BT_SEL_Pos = 0x0
	// Bit mask of BT_SEL field.
	GPIO_BT_SELECT_BT_SEL_Msk = 0xffffffff

	// OUT: GPIO0 ~ 31 output register
	// Position of DATA_ORIG field.
	GPIO_OUT_DATA_ORIG_Pos = 0x0
	// Bit mask of DATA_ORIG field.
	GPIO_OUT_DATA_ORIG_Msk = 0xffffffff

	// OUT_W1TS: GPIO0 ~ 31 output bit set register
	// Position of OUT_W1TS field.
	GPIO_OUT_W1TS_OUT_W1TS_Pos = 0x0
	// Bit mask of OUT_W1TS field.
	GPIO_OUT_W1TS_OUT_W1TS_Msk = 0xffffffff

	// OUT_W1TC: GPIO0 ~ 31 output bit clear register
	// Position of OUT_W1TC field.
	GPIO_OUT_W1TC_OUT_W1TC_Pos = 0x0
	// Bit mask of OUT_W1TC field.
	GPIO_OUT_W1TC_OUT_W1TC_Msk = 0xffffffff

	// OUT1: GPIO32 ~ 53 output register
	// Position of DATA_ORIG field.
	GPIO_OUT1_DATA_ORIG_Pos = 0x0
	// Bit mask of DATA_ORIG field.
	GPIO_OUT1_DATA_ORIG_Msk = 0x3fffff

	// OUT1_W1TS: GPIO32 ~ 53 output bit set register
	// Position of OUT1_W1TS field.
	GPIO_OUT1_W1TS_OUT1_W1TS_Pos = 0x0
	// Bit mask of OUT1_W1TS field.
	GPIO_OUT1_W1TS_OUT1_W1TS_Msk = 0x3fffff

	// OUT1_W1TC: GPIO32 ~ 53 output bit clear register
	// Position of OUT1_W1TC field.
	GPIO_OUT1_W1TC_OUT1_W1TC_Pos = 0x0
	// Bit mask of OUT1_W1TC field.
	GPIO_OUT1_W1TC_OUT1_W1TC_Msk = 0x3fffff

	// SDIO_SELECT: GPIO SDIO selection register
	// Position of SDIO_SEL field.
	GPIO_SDIO_SELECT_SDIO_SEL_Pos = 0x0
	// Bit mask of SDIO_SEL field.
	GPIO_SDIO_SELECT_SDIO_SEL_Msk = 0xff

	// ENABLE: GPIO0 ~ 31 output enable register
	// Position of DATA field.
	GPIO_ENABLE_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GPIO_ENABLE_DATA_Msk = 0xffffffff

	// ENABLE_W1TS: GPIO0 ~ 31 output enable bit set register
	// Position of ENABLE_W1TS field.
	GPIO_ENABLE_W1TS_ENABLE_W1TS_Pos = 0x0
	// Bit mask of ENABLE_W1TS field.
	GPIO_ENABLE_W1TS_ENABLE_W1TS_Msk = 0xffffffff

	// ENABLE_W1TC: GPIO0 ~ 31 output enable bit clear register
	// Position of ENABLE_W1TC field.
	GPIO_ENABLE_W1TC_ENABLE_W1TC_Pos = 0x0
	// Bit mask of ENABLE_W1TC field.
	GPIO_ENABLE_W1TC_ENABLE_W1TC_Msk = 0xffffffff

	// ENABLE1: GPIO32 ~ 53 output enable register
	// Position of DATA field.
	GPIO_ENABLE1_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GPIO_ENABLE1_DATA_Msk = 0x3fffff

	// ENABLE1_W1TS: GPIO32 ~ 53 output enable bit set register
	// Position of ENABLE1_W1TS field.
	GPIO_ENABLE1_W1TS_ENABLE1_W1TS_Pos = 0x0
	// Bit mask of ENABLE1_W1TS field.
	GPIO_ENABLE1_W1TS_ENABLE1_W1TS_Msk = 0x3fffff

	// ENABLE1_W1TC: GPIO32 ~ 53 output enable bit clear register
	// Position of ENABLE1_W1TC field.
	GPIO_ENABLE1_W1TC_ENABLE1_W1TC_Pos = 0x0
	// Bit mask of ENABLE1_W1TC field.
	GPIO_ENABLE1_W1TC_ENABLE1_W1TC_Msk = 0x3fffff

	// STRAP: Bootstrap pin value register
	// Position of STRAPPING field.
	GPIO_STRAP_STRAPPING_Pos = 0x0
	// Bit mask of STRAPPING field.
	GPIO_STRAP_STRAPPING_Msk = 0xffff

	// IN: GPIO0 ~ 31 input register
	// Position of DATA_NEXT field.
	GPIO_IN_DATA_NEXT_Pos = 0x0
	// Bit mask of DATA_NEXT field.
	GPIO_IN_DATA_NEXT_Msk = 0xffffffff

	// IN1: GPIO32 ~ 53 input register
	// Position of IN_DATA1_NEXT field.
	GPIO_IN1_IN_DATA1_NEXT_Pos = 0x0
	// Bit mask of IN_DATA1_NEXT field.
	GPIO_IN1_IN_DATA1_NEXT_Msk = 0x3fffff

	// STATUS: GPIO0 ~ 31 interrupt status register
	// Position of INTERRUPT field.
	GPIO_STATUS_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	GPIO_STATUS_INTERRUPT_Msk = 0xffffffff

	// STATUS_W1TS: GPIO0 ~ 31 interrupt status bit set register
	// Position of STATUS_W1TS field.
	GPIO_STATUS_W1TS_STATUS_W1TS_Pos = 0x0
	// Bit mask of STATUS_W1TS field.
	GPIO_STATUS_W1TS_STATUS_W1TS_Msk = 0xffffffff

	// STATUS_W1TC: GPIO0 ~ 31 interrupt status bit clear register
	// Position of STATUS_W1TC field.
	GPIO_STATUS_W1TC_STATUS_W1TC_Pos = 0x0
	// Bit mask of STATUS_W1TC field.
	GPIO_STATUS_W1TC_STATUS_W1TC_Msk = 0xffffffff

	// STATUS1: GPIO32 ~ 53 interrupt status register
	// Position of INTERRUPT field.
	GPIO_STATUS1_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	GPIO_STATUS1_INTERRUPT_Msk = 0x3fffff

	// STATUS1_W1TS: GPIO32 ~ 53 interrupt status bit set register
	// Position of STATUS1_W1TS field.
	GPIO_STATUS1_W1TS_STATUS1_W1TS_Pos = 0x0
	// Bit mask of STATUS1_W1TS field.
	GPIO_STATUS1_W1TS_STATUS1_W1TS_Msk = 0x3fffff

	// STATUS1_W1TC: GPIO32 ~ 53 interrupt status bit clear register
	// Position of STATUS1_W1TC field.
	GPIO_STATUS1_W1TC_STATUS1_W1TC_Pos = 0x0
	// Bit mask of STATUS1_W1TC field.
	GPIO_STATUS1_W1TC_STATUS1_W1TC_Msk = 0x3fffff

	// PCPU_INT: GPIO0 ~ 31 PRO_CPU interrupt status register
	// Position of PROCPU_INT field.
	GPIO_PCPU_INT_PROCPU_INT_Pos = 0x0
	// Bit mask of PROCPU_INT field.
	GPIO_PCPU_INT_PROCPU_INT_Msk = 0xffffffff

	// PCPU_NMI_INT: GPIO0 ~ 31 PRO_CPU non-maskable interrupt status register
	// Position of PROCPU_NMI_INT field.
	GPIO_PCPU_NMI_INT_PROCPU_NMI_INT_Pos = 0x0
	// Bit mask of PROCPU_NMI_INT field.
	GPIO_PCPU_NMI_INT_PROCPU_NMI_INT_Msk = 0xffffffff

	// CPUSDIO_INT: GPIO0 ~ 31 CPU SDIO interrupt status register
	// Position of SDIO_INT field.
	GPIO_CPUSDIO_INT_SDIO_INT_Pos = 0x0
	// Bit mask of SDIO_INT field.
	GPIO_CPUSDIO_INT_SDIO_INT_Msk = 0xffffffff

	// PCPU_INT1: GPIO32 ~ 53 PRO_CPU interrupt status register
	// Position of PROCPU1_INT field.
	GPIO_PCPU_INT1_PROCPU1_INT_Pos = 0x0
	// Bit mask of PROCPU1_INT field.
	GPIO_PCPU_INT1_PROCPU1_INT_Msk = 0x3fffff

	// PCPU_NMI_INT1: GPIO32 ~ 53 PRO_CPU non-maskable interrupt status register
	// Position of PROCPU_NMI1_INT field.
	GPIO_PCPU_NMI_INT1_PROCPU_NMI1_INT_Pos = 0x0
	// Bit mask of PROCPU_NMI1_INT field.
	GPIO_PCPU_NMI_INT1_PROCPU_NMI1_INT_Msk = 0x3fffff

	// CPUSDIO_INT1: GPIO32 ~ 53 CPU SDIO interrupt status register
	// Position of SDIO1_INT field.
	GPIO_CPUSDIO_INT1_SDIO1_INT_Pos = 0x0
	// Bit mask of SDIO1_INT field.
	GPIO_CPUSDIO_INT1_SDIO1_INT_Msk = 0x3fffff

	// PIN0: Configuration for GPIO pin %s
	// Position of SYNC2_BYPASS field.
	GPIO_PIN_SYNC2_BYPASS_Pos = 0x0
	// Bit mask of SYNC2_BYPASS field.
	GPIO_PIN_SYNC2_BYPASS_Msk = 0x3
	// Position of PAD_DRIVER field.
	GPIO_PIN_PAD_DRIVER_Pos = 0x2
	// Bit mask of PAD_DRIVER field.
	GPIO_PIN_PAD_DRIVER_Msk = 0x4
	// Bit PAD_DRIVER.
	GPIO_PIN_PAD_DRIVER = 0x4
	// Position of SYNC1_BYPASS field.
	GPIO_PIN_SYNC1_BYPASS_Pos = 0x3
	// Bit mask of SYNC1_BYPASS field.
	GPIO_PIN_SYNC1_BYPASS_Msk = 0x18
	// Position of INT_TYPE field.
	GPIO_PIN_INT_TYPE_Pos = 0x7
	// Bit mask of INT_TYPE field.
	GPIO_PIN_INT_TYPE_Msk = 0x380
	// Position of WAKEUP_ENABLE field.
	GPIO_PIN_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of WAKEUP_ENABLE field.
	GPIO_PIN_WAKEUP_ENABLE_Msk = 0x400
	// Bit WAKEUP_ENABLE.
	GPIO_PIN_WAKEUP_ENABLE = 0x400
	// Position of CONFIG field.
	GPIO_PIN_CONFIG_Pos = 0xb
	// Bit mask of CONFIG field.
	GPIO_PIN_CONFIG_Msk = 0x1800
	// Position of INT_ENA field.
	GPIO_PIN_INT_ENA_Pos = 0xd
	// Bit mask of INT_ENA field.
	GPIO_PIN_INT_ENA_Msk = 0x3e000

	// STATUS_NEXT: GPIO0 ~ 31 interrupt source register
	// Position of STATUS_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT_STATUS_INTERRUPT_NEXT_Pos = 0x0
	// Bit mask of STATUS_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT_STATUS_INTERRUPT_NEXT_Msk = 0xffffffff

	// STATUS_NEXT1: GPIO32 ~ 53 interrupt source register
	// Position of STATUS1_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT1_STATUS1_INTERRUPT_NEXT_Pos = 0x0
	// Bit mask of STATUS1_INTERRUPT_NEXT field.
	GPIO_STATUS_NEXT1_STATUS1_INTERRUPT_NEXT_Msk = 0x3fffff

	// FUNC0_IN_SEL_CFG: Peripheral function %s input selection register
	// Position of IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_SEL_Pos = 0x0
	// Bit mask of IN_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_SEL_Msk = 0x3f
	// Position of IN_INV_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_INV_SEL_Pos = 0x6
	// Bit mask of IN_INV_SEL field.
	GPIO_FUNC_IN_SEL_CFG_IN_INV_SEL_Msk = 0x40
	// Bit IN_INV_SEL.
	GPIO_FUNC_IN_SEL_CFG_IN_INV_SEL = 0x40
	// Position of SEL field.
	GPIO_FUNC_IN_SEL_CFG_SEL_Pos = 0x7
	// Bit mask of SEL field.
	GPIO_FUNC_IN_SEL_CFG_SEL_Msk = 0x80
	// Bit SEL.
	GPIO_FUNC_IN_SEL_CFG_SEL = 0x80

	// FUNC0_OUT_SEL_CFG: Peripheral output selection for GPIO %s
	// Position of OUT_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OUT_SEL_Pos = 0x0
	// Bit mask of OUT_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OUT_SEL_Msk = 0x1ff
	// Position of INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_INV_SEL_Pos = 0x9
	// Bit mask of INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_INV_SEL_Msk = 0x200
	// Bit INV_SEL.
	GPIO_FUNC_OUT_SEL_CFG_INV_SEL = 0x200
	// Position of OEN_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_SEL_Pos = 0xa
	// Bit mask of OEN_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_SEL_Msk = 0x400
	// Bit OEN_SEL.
	GPIO_FUNC_OUT_SEL_CFG_OEN_SEL = 0x400
	// Position of OEN_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_INV_SEL_Pos = 0xb
	// Bit mask of OEN_INV_SEL field.
	GPIO_FUNC_OUT_SEL_CFG_OEN_INV_SEL_Msk = 0x800
	// Bit OEN_INV_SEL.
	GPIO_FUNC_OUT_SEL_CFG_OEN_INV_SEL = 0x800

	// CLOCK_GATE: GPIO clock gating register
	// Position of CLK_EN field.
	GPIO_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	GPIO_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	GPIO_CLOCK_GATE_CLK_EN = 0x1

	// REG_DATE: Version control register
	// Position of DATE field.
	GPIO_REG_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	GPIO_REG_DATE_DATE_Msk = 0xfffffff
)

// Constants for GPIO_SD: Sigma-Delta Modulation
const (
	// SIGMADELTA0: Duty-cycle configuration register of SDM%s
	// Position of SD_IN field.
	GPIOSD_SIGMADELTA_SD_IN_Pos = 0x0
	// Bit mask of SD_IN field.
	GPIOSD_SIGMADELTA_SD_IN_Msk = 0xff
	// Position of SD_PRESCALE field.
	GPIOSD_SIGMADELTA_SD_PRESCALE_Pos = 0x8
	// Bit mask of SD_PRESCALE field.
	GPIOSD_SIGMADELTA_SD_PRESCALE_Msk = 0xff00

	// SIGMADELTA_CG: Clock gating configuration register
	// Position of CLK_EN field.
	GPIOSD_SIGMADELTA_CG_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	GPIOSD_SIGMADELTA_CG_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	GPIOSD_SIGMADELTA_CG_CLK_EN = 0x80000000

	// SIGMADELTA_MISC: MISC register
	// Position of FUNCTION_CLK_EN field.
	GPIOSD_SIGMADELTA_MISC_FUNCTION_CLK_EN_Pos = 0x1e
	// Bit mask of FUNCTION_CLK_EN field.
	GPIOSD_SIGMADELTA_MISC_FUNCTION_CLK_EN_Msk = 0x40000000
	// Bit FUNCTION_CLK_EN.
	GPIOSD_SIGMADELTA_MISC_FUNCTION_CLK_EN = 0x40000000
	// Position of SPI_SWAP field.
	GPIOSD_SIGMADELTA_MISC_SPI_SWAP_Pos = 0x1f
	// Bit mask of SPI_SWAP field.
	GPIOSD_SIGMADELTA_MISC_SPI_SWAP_Msk = 0x80000000
	// Bit SPI_SWAP.
	GPIOSD_SIGMADELTA_MISC_SPI_SWAP = 0x80000000

	// SIGMADELTA_VERSION: Version control register
	// Position of GPIO_SD_DATE field.
	GPIOSD_SIGMADELTA_VERSION_GPIO_SD_DATE_Pos = 0x0
	// Bit mask of GPIO_SD_DATE field.
	GPIOSD_SIGMADELTA_VERSION_GPIO_SD_DATE_Msk = 0xfffffff
)

// Constants for HMAC: HMAC (Hash-based Message Authentication Code) Accelerator
const (
	// SET_START: HMAC start control register
	// Position of SET_START field.
	HMAC_SET_START_SET_START_Pos = 0x0
	// Bit mask of SET_START field.
	HMAC_SET_START_SET_START_Msk = 0x1
	// Bit SET_START.
	HMAC_SET_START_SET_START = 0x1

	// SET_PARA_PURPOSE: HMAC parameter configuration register
	// Position of PURPOSE_SET field.
	HMAC_SET_PARA_PURPOSE_PURPOSE_SET_Pos = 0x0
	// Bit mask of PURPOSE_SET field.
	HMAC_SET_PARA_PURPOSE_PURPOSE_SET_Msk = 0xf

	// SET_PARA_KEY: HMAC key configuration register
	// Position of KEY_SET field.
	HMAC_SET_PARA_KEY_KEY_SET_Pos = 0x0
	// Bit mask of KEY_SET field.
	HMAC_SET_PARA_KEY_KEY_SET_Msk = 0x7

	// SET_PARA_FINISH: HMAC configuration completion register
	// Position of SET_PARA_END field.
	HMAC_SET_PARA_FINISH_SET_PARA_END_Pos = 0x0
	// Bit mask of SET_PARA_END field.
	HMAC_SET_PARA_FINISH_SET_PARA_END_Msk = 0x1
	// Bit SET_PARA_END.
	HMAC_SET_PARA_FINISH_SET_PARA_END = 0x1

	// SET_MESSAGE_ONE: HMAC one message control register
	// Position of SET_TEXT_ONE field.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE_Pos = 0x0
	// Bit mask of SET_TEXT_ONE field.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE_Msk = 0x1
	// Bit SET_TEXT_ONE.
	HMAC_SET_MESSAGE_ONE_SET_TEXT_ONE = 0x1

	// SET_MESSAGE_ING: HMAC message continue register
	// Position of SET_TEXT_ING field.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING_Pos = 0x0
	// Bit mask of SET_TEXT_ING field.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING_Msk = 0x1
	// Bit SET_TEXT_ING.
	HMAC_SET_MESSAGE_ING_SET_TEXT_ING = 0x1

	// SET_MESSAGE_END: HMAC message end register
	// Position of SET_TEXT_END field.
	HMAC_SET_MESSAGE_END_SET_TEXT_END_Pos = 0x0
	// Bit mask of SET_TEXT_END field.
	HMAC_SET_MESSAGE_END_SET_TEXT_END_Msk = 0x1
	// Bit SET_TEXT_END.
	HMAC_SET_MESSAGE_END_SET_TEXT_END = 0x1

	// SET_RESULT_FINISH: HMAC read result completion register
	// Position of SET_RESULT_END field.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END_Pos = 0x0
	// Bit mask of SET_RESULT_END field.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END_Msk = 0x1
	// Bit SET_RESULT_END.
	HMAC_SET_RESULT_FINISH_SET_RESULT_END = 0x1

	// SET_INVALIDATE_JTAG: Invalidate JTAG result register
	// Position of SET_INVALIDATE_JTAG field.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG_Pos = 0x0
	// Bit mask of SET_INVALIDATE_JTAG field.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG_Msk = 0x1
	// Bit SET_INVALIDATE_JTAG.
	HMAC_SET_INVALIDATE_JTAG_SET_INVALIDATE_JTAG = 0x1

	// SET_INVALIDATE_DS: Invalidate digital signature result register
	// Position of SET_INVALIDATE_DS field.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS_Pos = 0x0
	// Bit mask of SET_INVALIDATE_DS field.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS_Msk = 0x1
	// Bit SET_INVALIDATE_DS.
	HMAC_SET_INVALIDATE_DS_SET_INVALIDATE_DS = 0x1

	// QUERY_ERROR: The matching result between key and purpose user configured
	// Position of QUERY_CHECK field.
	HMAC_QUERY_ERROR_QUERY_CHECK_Pos = 0x0
	// Bit mask of QUERY_CHECK field.
	HMAC_QUERY_ERROR_QUERY_CHECK_Msk = 0x1
	// Bit QUERY_CHECK.
	HMAC_QUERY_ERROR_QUERY_CHECK = 0x1

	// QUERY_BUSY: The busy state of HMAC module
	// Position of BUSY_STATE field.
	HMAC_QUERY_BUSY_BUSY_STATE_Pos = 0x0
	// Bit mask of BUSY_STATE field.
	HMAC_QUERY_BUSY_BUSY_STATE_Msk = 0x1
	// Bit BUSY_STATE.
	HMAC_QUERY_BUSY_BUSY_STATE = 0x1

	// WR_MESSAGE_0: Message register %s
	// Position of WDATA field.
	HMAC_WR_MESSAGE_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	HMAC_WR_MESSAGE_WDATA_Msk = 0xffffffff

	// RD_RESULT_0: Hash result register %s
	// Position of RDATA field.
	HMAC_RD_RESULT_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	HMAC_RD_RESULT_RDATA_Msk = 0xffffffff

	// SET_MESSAGE_PAD: Software padding register
	// Position of SET_TEXT_PAD field.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD_Pos = 0x0
	// Bit mask of SET_TEXT_PAD field.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD_Msk = 0x1
	// Bit SET_TEXT_PAD.
	HMAC_SET_MESSAGE_PAD_SET_TEXT_PAD = 0x1

	// ONE_BLOCK: One block message register.
	// Position of SET_ONE_BLOCK field.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK_Pos = 0x0
	// Bit mask of SET_ONE_BLOCK field.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK_Msk = 0x1
	// Bit SET_ONE_BLOCK.
	HMAC_ONE_BLOCK_SET_ONE_BLOCK = 0x1

	// DATE: Version control register
	// Position of DATE field.
	HMAC_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	HMAC_DATE_DATE_Msk = 0x3fffffff
)

// Constants for I2C0: I2C (Inter-Integrated Circuit) Controller 0
const (
	// SCL_LOW_PERIOD: Configures the low level width of the SCL clock
	// Position of SCL_LOW_PERIOD field.
	I2C_SCL_LOW_PERIOD_SCL_LOW_PERIOD_Pos = 0x0
	// Bit mask of SCL_LOW_PERIOD field.
	I2C_SCL_LOW_PERIOD_SCL_LOW_PERIOD_Msk = 0x3fff

	// CTR: Transmission setting
	// Position of SDA_FORCE_OUT field.
	I2C_CTR_SDA_FORCE_OUT_Pos = 0x0
	// Bit mask of SDA_FORCE_OUT field.
	I2C_CTR_SDA_FORCE_OUT_Msk = 0x1
	// Bit SDA_FORCE_OUT.
	I2C_CTR_SDA_FORCE_OUT = 0x1
	// Position of SCL_FORCE_OUT field.
	I2C_CTR_SCL_FORCE_OUT_Pos = 0x1
	// Bit mask of SCL_FORCE_OUT field.
	I2C_CTR_SCL_FORCE_OUT_Msk = 0x2
	// Bit SCL_FORCE_OUT.
	I2C_CTR_SCL_FORCE_OUT = 0x2
	// Position of SAMPLE_SCL_LEVEL field.
	I2C_CTR_SAMPLE_SCL_LEVEL_Pos = 0x2
	// Bit mask of SAMPLE_SCL_LEVEL field.
	I2C_CTR_SAMPLE_SCL_LEVEL_Msk = 0x4
	// Bit SAMPLE_SCL_LEVEL.
	I2C_CTR_SAMPLE_SCL_LEVEL = 0x4
	// Position of RX_FULL_ACK_LEVEL field.
	I2C_CTR_RX_FULL_ACK_LEVEL_Pos = 0x3
	// Bit mask of RX_FULL_ACK_LEVEL field.
	I2C_CTR_RX_FULL_ACK_LEVEL_Msk = 0x8
	// Bit RX_FULL_ACK_LEVEL.
	I2C_CTR_RX_FULL_ACK_LEVEL = 0x8
	// Position of MS_MODE field.
	I2C_CTR_MS_MODE_Pos = 0x4
	// Bit mask of MS_MODE field.
	I2C_CTR_MS_MODE_Msk = 0x10
	// Bit MS_MODE.
	I2C_CTR_MS_MODE = 0x10
	// Position of TRANS_START field.
	I2C_CTR_TRANS_START_Pos = 0x5
	// Bit mask of TRANS_START field.
	I2C_CTR_TRANS_START_Msk = 0x20
	// Bit TRANS_START.
	I2C_CTR_TRANS_START = 0x20
	// Position of TX_LSB_FIRST field.
	I2C_CTR_TX_LSB_FIRST_Pos = 0x6
	// Bit mask of TX_LSB_FIRST field.
	I2C_CTR_TX_LSB_FIRST_Msk = 0x40
	// Bit TX_LSB_FIRST.
	I2C_CTR_TX_LSB_FIRST = 0x40
	// Position of RX_LSB_FIRST field.
	I2C_CTR_RX_LSB_FIRST_Pos = 0x7
	// Bit mask of RX_LSB_FIRST field.
	I2C_CTR_RX_LSB_FIRST_Msk = 0x80
	// Bit RX_LSB_FIRST.
	I2C_CTR_RX_LSB_FIRST = 0x80
	// Position of CLK_EN field.
	I2C_CTR_CLK_EN_Pos = 0x8
	// Bit mask of CLK_EN field.
	I2C_CTR_CLK_EN_Msk = 0x100
	// Bit CLK_EN.
	I2C_CTR_CLK_EN = 0x100
	// Position of ARBITRATION_EN field.
	I2C_CTR_ARBITRATION_EN_Pos = 0x9
	// Bit mask of ARBITRATION_EN field.
	I2C_CTR_ARBITRATION_EN_Msk = 0x200
	// Bit ARBITRATION_EN.
	I2C_CTR_ARBITRATION_EN = 0x200
	// Position of FSM_RST field.
	I2C_CTR_FSM_RST_Pos = 0xa
	// Bit mask of FSM_RST field.
	I2C_CTR_FSM_RST_Msk = 0x400
	// Bit FSM_RST.
	I2C_CTR_FSM_RST = 0x400
	// Position of REF_ALWAYS_ON field.
	I2C_CTR_REF_ALWAYS_ON_Pos = 0xb
	// Bit mask of REF_ALWAYS_ON field.
	I2C_CTR_REF_ALWAYS_ON_Msk = 0x800
	// Bit REF_ALWAYS_ON.
	I2C_CTR_REF_ALWAYS_ON = 0x800

	// SR: Describe I2C work status
	// Position of RESP_REC field.
	I2C_SR_RESP_REC_Pos = 0x0
	// Bit mask of RESP_REC field.
	I2C_SR_RESP_REC_Msk = 0x1
	// Bit RESP_REC.
	I2C_SR_RESP_REC = 0x1
	// Position of SLAVE_RW field.
	I2C_SR_SLAVE_RW_Pos = 0x1
	// Bit mask of SLAVE_RW field.
	I2C_SR_SLAVE_RW_Msk = 0x2
	// Bit SLAVE_RW.
	I2C_SR_SLAVE_RW = 0x2
	// Position of TIME_OUT field.
	I2C_SR_TIME_OUT_Pos = 0x2
	// Bit mask of TIME_OUT field.
	I2C_SR_TIME_OUT_Msk = 0x4
	// Bit TIME_OUT.
	I2C_SR_TIME_OUT = 0x4
	// Position of ARB_LOST field.
	I2C_SR_ARB_LOST_Pos = 0x3
	// Bit mask of ARB_LOST field.
	I2C_SR_ARB_LOST_Msk = 0x8
	// Bit ARB_LOST.
	I2C_SR_ARB_LOST = 0x8
	// Position of BUS_BUSY field.
	I2C_SR_BUS_BUSY_Pos = 0x4
	// Bit mask of BUS_BUSY field.
	I2C_SR_BUS_BUSY_Msk = 0x10
	// Bit BUS_BUSY.
	I2C_SR_BUS_BUSY = 0x10
	// Position of SLAVE_ADDRESSED field.
	I2C_SR_SLAVE_ADDRESSED_Pos = 0x5
	// Bit mask of SLAVE_ADDRESSED field.
	I2C_SR_SLAVE_ADDRESSED_Msk = 0x20
	// Bit SLAVE_ADDRESSED.
	I2C_SR_SLAVE_ADDRESSED = 0x20
	// Position of BYTE_TRANS field.
	I2C_SR_BYTE_TRANS_Pos = 0x6
	// Bit mask of BYTE_TRANS field.
	I2C_SR_BYTE_TRANS_Msk = 0x40
	// Bit BYTE_TRANS.
	I2C_SR_BYTE_TRANS = 0x40
	// Position of RXFIFO_CNT field.
	I2C_SR_RXFIFO_CNT_Pos = 0x8
	// Bit mask of RXFIFO_CNT field.
	I2C_SR_RXFIFO_CNT_Msk = 0x3f00
	// Position of STRETCH_CAUSE field.
	I2C_SR_STRETCH_CAUSE_Pos = 0xe
	// Bit mask of STRETCH_CAUSE field.
	I2C_SR_STRETCH_CAUSE_Msk = 0xc000
	// Position of TXFIFO_CNT field.
	I2C_SR_TXFIFO_CNT_Pos = 0x12
	// Bit mask of TXFIFO_CNT field.
	I2C_SR_TXFIFO_CNT_Msk = 0xfc0000
	// Position of SCL_MAIN_STATE_LAST field.
	I2C_SR_SCL_MAIN_STATE_LAST_Pos = 0x18
	// Bit mask of SCL_MAIN_STATE_LAST field.
	I2C_SR_SCL_MAIN_STATE_LAST_Msk = 0x7000000
	// Position of SCL_STATE_LAST field.
	I2C_SR_SCL_STATE_LAST_Pos = 0x1c
	// Bit mask of SCL_STATE_LAST field.
	I2C_SR_SCL_STATE_LAST_Msk = 0x70000000

	// TO: Setting time out control for receiving data
	// Position of TIME_OUT_VALUE field.
	I2C_TO_TIME_OUT_VALUE_Pos = 0x0
	// Bit mask of TIME_OUT_VALUE field.
	I2C_TO_TIME_OUT_VALUE_Msk = 0xffffff
	// Position of TIME_OUT_EN field.
	I2C_TO_TIME_OUT_EN_Pos = 0x18
	// Bit mask of TIME_OUT_EN field.
	I2C_TO_TIME_OUT_EN_Msk = 0x1000000
	// Bit TIME_OUT_EN.
	I2C_TO_TIME_OUT_EN = 0x1000000

	// SLAVE_ADDR: Local slave address setting
	// Position of SLAVE_ADDR field.
	I2C_SLAVE_ADDR_SLAVE_ADDR_Pos = 0x0
	// Bit mask of SLAVE_ADDR field.
	I2C_SLAVE_ADDR_SLAVE_ADDR_Msk = 0x7fff
	// Position of ADDR_10BIT_EN field.
	I2C_SLAVE_ADDR_ADDR_10BIT_EN_Pos = 0x1f
	// Bit mask of ADDR_10BIT_EN field.
	I2C_SLAVE_ADDR_ADDR_10BIT_EN_Msk = 0x80000000
	// Bit ADDR_10BIT_EN.
	I2C_SLAVE_ADDR_ADDR_10BIT_EN = 0x80000000

	// FIFO_ST: FIFO status register
	// Position of RXFIFO_START_ADDR field.
	I2C_FIFO_ST_RXFIFO_START_ADDR_Pos = 0x0
	// Bit mask of RXFIFO_START_ADDR field.
	I2C_FIFO_ST_RXFIFO_START_ADDR_Msk = 0x1f
	// Position of RXFIFO_END_ADDR field.
	I2C_FIFO_ST_RXFIFO_END_ADDR_Pos = 0x5
	// Bit mask of RXFIFO_END_ADDR field.
	I2C_FIFO_ST_RXFIFO_END_ADDR_Msk = 0x3e0
	// Position of TXFIFO_START_ADDR field.
	I2C_FIFO_ST_TXFIFO_START_ADDR_Pos = 0xa
	// Bit mask of TXFIFO_START_ADDR field.
	I2C_FIFO_ST_TXFIFO_START_ADDR_Msk = 0x7c00
	// Position of TXFIFO_END_ADDR field.
	I2C_FIFO_ST_TXFIFO_END_ADDR_Pos = 0xf
	// Bit mask of TXFIFO_END_ADDR field.
	I2C_FIFO_ST_TXFIFO_END_ADDR_Msk = 0xf8000
	// Position of RX_UPDATE field.
	I2C_FIFO_ST_RX_UPDATE_Pos = 0x14
	// Bit mask of RX_UPDATE field.
	I2C_FIFO_ST_RX_UPDATE_Msk = 0x100000
	// Bit RX_UPDATE.
	I2C_FIFO_ST_RX_UPDATE = 0x100000
	// Position of TX_UPDATE field.
	I2C_FIFO_ST_TX_UPDATE_Pos = 0x15
	// Bit mask of TX_UPDATE field.
	I2C_FIFO_ST_TX_UPDATE_Msk = 0x200000
	// Bit TX_UPDATE.
	I2C_FIFO_ST_TX_UPDATE = 0x200000
	// Position of SLAVE_RW_POINT field.
	I2C_FIFO_ST_SLAVE_RW_POINT_Pos = 0x16
	// Bit mask of SLAVE_RW_POINT field.
	I2C_FIFO_ST_SLAVE_RW_POINT_Msk = 0x3fc00000

	// FIFO_CONF: FIFO configuration register
	// Position of RXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_RXFIFO_WM_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_RXFIFO_WM_THRHD_Msk = 0x1f
	// Position of TXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_TXFIFO_WM_THRHD_Pos = 0x5
	// Bit mask of TXFIFO_WM_THRHD field.
	I2C_FIFO_CONF_TXFIFO_WM_THRHD_Msk = 0x3e0
	// Position of NONFIFO_EN field.
	I2C_FIFO_CONF_NONFIFO_EN_Pos = 0xa
	// Bit mask of NONFIFO_EN field.
	I2C_FIFO_CONF_NONFIFO_EN_Msk = 0x400
	// Bit NONFIFO_EN.
	I2C_FIFO_CONF_NONFIFO_EN = 0x400
	// Position of FIFO_ADDR_CFG_EN field.
	I2C_FIFO_CONF_FIFO_ADDR_CFG_EN_Pos = 0xb
	// Bit mask of FIFO_ADDR_CFG_EN field.
	I2C_FIFO_CONF_FIFO_ADDR_CFG_EN_Msk = 0x800
	// Bit FIFO_ADDR_CFG_EN.
	I2C_FIFO_CONF_FIFO_ADDR_CFG_EN = 0x800
	// Position of RX_FIFO_RST field.
	I2C_FIFO_CONF_RX_FIFO_RST_Pos = 0xc
	// Bit mask of RX_FIFO_RST field.
	I2C_FIFO_CONF_RX_FIFO_RST_Msk = 0x1000
	// Bit RX_FIFO_RST.
	I2C_FIFO_CONF_RX_FIFO_RST = 0x1000
	// Position of TX_FIFO_RST field.
	I2C_FIFO_CONF_TX_FIFO_RST_Pos = 0xd
	// Bit mask of TX_FIFO_RST field.
	I2C_FIFO_CONF_TX_FIFO_RST_Msk = 0x2000
	// Bit TX_FIFO_RST.
	I2C_FIFO_CONF_TX_FIFO_RST = 0x2000
	// Position of NONFIFO_RX_THRES field.
	I2C_FIFO_CONF_NONFIFO_RX_THRES_Pos = 0xe
	// Bit mask of NONFIFO_RX_THRES field.
	I2C_FIFO_CONF_NONFIFO_RX_THRES_Msk = 0xfc000
	// Position of NONFIFO_TX_THRES field.
	I2C_FIFO_CONF_NONFIFO_TX_THRES_Pos = 0x14
	// Bit mask of NONFIFO_TX_THRES field.
	I2C_FIFO_CONF_NONFIFO_TX_THRES_Msk = 0x3f00000
	// Position of FIFO_PRT_EN field.
	I2C_FIFO_CONF_FIFO_PRT_EN_Pos = 0x1a
	// Bit mask of FIFO_PRT_EN field.
	I2C_FIFO_CONF_FIFO_PRT_EN_Msk = 0x4000000
	// Bit FIFO_PRT_EN.
	I2C_FIFO_CONF_FIFO_PRT_EN = 0x4000000

	// DATA: RX FIFO read data
	// Position of FIFO_RDATA field.
	I2C_DATA_FIFO_RDATA_Pos = 0x0
	// Bit mask of FIFO_RDATA field.
	I2C_DATA_FIFO_RDATA_Msk = 0xff

	// INT_RAW: Raw interrupt status
	// Position of RXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_RXFIFO_WM_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_RXFIFO_WM_INT_RAW_Msk = 0x1
	// Bit RXFIFO_WM_INT_RAW.
	I2C_INT_RAW_RXFIFO_WM_INT_RAW = 0x1
	// Position of TXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_TXFIFO_WM_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_RAW field.
	I2C_INT_RAW_TXFIFO_WM_INT_RAW_Msk = 0x2
	// Bit TXFIFO_WM_INT_RAW.
	I2C_INT_RAW_TXFIFO_WM_INT_RAW = 0x2
	// Position of RXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x4
	// Bit RXFIFO_OVF_INT_RAW.
	I2C_INT_RAW_RXFIFO_OVF_INT_RAW = 0x4
	// Position of END_DETECT_INT_RAW field.
	I2C_INT_RAW_END_DETECT_INT_RAW_Pos = 0x3
	// Bit mask of END_DETECT_INT_RAW field.
	I2C_INT_RAW_END_DETECT_INT_RAW_Msk = 0x8
	// Bit END_DETECT_INT_RAW.
	I2C_INT_RAW_END_DETECT_INT_RAW = 0x8
	// Position of BYTE_TRANS_DONE_INT_RAW field.
	I2C_INT_RAW_BYTE_TRANS_DONE_INT_RAW_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_RAW field.
	I2C_INT_RAW_BYTE_TRANS_DONE_INT_RAW_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_RAW.
	I2C_INT_RAW_BYTE_TRANS_DONE_INT_RAW = 0x10
	// Position of ARBITRATION_LOST_INT_RAW field.
	I2C_INT_RAW_ARBITRATION_LOST_INT_RAW_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_RAW field.
	I2C_INT_RAW_ARBITRATION_LOST_INT_RAW_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_RAW.
	I2C_INT_RAW_ARBITRATION_LOST_INT_RAW = 0x20
	// Position of MST_TXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_MST_TXFIFO_UDF_INT_RAW_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_MST_TXFIFO_UDF_INT_RAW_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_RAW.
	I2C_INT_RAW_MST_TXFIFO_UDF_INT_RAW = 0x40
	// Position of TRANS_COMPLETE_INT_RAW field.
	I2C_INT_RAW_TRANS_COMPLETE_INT_RAW_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_RAW field.
	I2C_INT_RAW_TRANS_COMPLETE_INT_RAW_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_RAW.
	I2C_INT_RAW_TRANS_COMPLETE_INT_RAW = 0x80
	// Position of TIME_OUT_INT_RAW field.
	I2C_INT_RAW_TIME_OUT_INT_RAW_Pos = 0x8
	// Bit mask of TIME_OUT_INT_RAW field.
	I2C_INT_RAW_TIME_OUT_INT_RAW_Msk = 0x100
	// Bit TIME_OUT_INT_RAW.
	I2C_INT_RAW_TIME_OUT_INT_RAW = 0x100
	// Position of TRANS_START_INT_RAW field.
	I2C_INT_RAW_TRANS_START_INT_RAW_Pos = 0x9
	// Bit mask of TRANS_START_INT_RAW field.
	I2C_INT_RAW_TRANS_START_INT_RAW_Msk = 0x200
	// Bit TRANS_START_INT_RAW.
	I2C_INT_RAW_TRANS_START_INT_RAW = 0x200
	// Position of NACK_INT_RAW field.
	I2C_INT_RAW_NACK_INT_RAW_Pos = 0xa
	// Bit mask of NACK_INT_RAW field.
	I2C_INT_RAW_NACK_INT_RAW_Msk = 0x400
	// Bit NACK_INT_RAW.
	I2C_INT_RAW_NACK_INT_RAW = 0x400
	// Position of TXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_TXFIFO_OVF_INT_RAW_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_RAW field.
	I2C_INT_RAW_TXFIFO_OVF_INT_RAW_Msk = 0x800
	// Bit TXFIFO_OVF_INT_RAW.
	I2C_INT_RAW_TXFIFO_OVF_INT_RAW = 0x800
	// Position of RXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_UDF_INT_RAW_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_RAW field.
	I2C_INT_RAW_RXFIFO_UDF_INT_RAW_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_RAW.
	I2C_INT_RAW_RXFIFO_UDF_INT_RAW = 0x1000
	// Position of SCL_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_ST_TO_INT_RAW_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_ST_TO_INT_RAW_Msk = 0x2000
	// Bit SCL_ST_TO_INT_RAW.
	I2C_INT_RAW_SCL_ST_TO_INT_RAW = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_MAIN_ST_TO_INT_RAW_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_RAW field.
	I2C_INT_RAW_SCL_MAIN_ST_TO_INT_RAW_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_RAW.
	I2C_INT_RAW_SCL_MAIN_ST_TO_INT_RAW = 0x4000
	// Position of DET_START_INT_RAW field.
	I2C_INT_RAW_DET_START_INT_RAW_Pos = 0xf
	// Bit mask of DET_START_INT_RAW field.
	I2C_INT_RAW_DET_START_INT_RAW_Msk = 0x8000
	// Bit DET_START_INT_RAW.
	I2C_INT_RAW_DET_START_INT_RAW = 0x8000
	// Position of SLAVE_STRETCH_INT_RAW field.
	I2C_INT_RAW_SLAVE_STRETCH_INT_RAW_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_RAW field.
	I2C_INT_RAW_SLAVE_STRETCH_INT_RAW_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_RAW.
	I2C_INT_RAW_SLAVE_STRETCH_INT_RAW = 0x10000

	// INT_CLR: Interrupt clear bits
	// Position of RXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_RXFIFO_WM_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_RXFIFO_WM_INT_CLR_Msk = 0x1
	// Bit RXFIFO_WM_INT_CLR.
	I2C_INT_CLR_RXFIFO_WM_INT_CLR = 0x1
	// Position of TXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_TXFIFO_WM_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_CLR field.
	I2C_INT_CLR_TXFIFO_WM_INT_CLR_Msk = 0x2
	// Bit TXFIFO_WM_INT_CLR.
	I2C_INT_CLR_TXFIFO_WM_INT_CLR = 0x2
	// Position of RXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x4
	// Bit RXFIFO_OVF_INT_CLR.
	I2C_INT_CLR_RXFIFO_OVF_INT_CLR = 0x4
	// Position of END_DETECT_INT_CLR field.
	I2C_INT_CLR_END_DETECT_INT_CLR_Pos = 0x3
	// Bit mask of END_DETECT_INT_CLR field.
	I2C_INT_CLR_END_DETECT_INT_CLR_Msk = 0x8
	// Bit END_DETECT_INT_CLR.
	I2C_INT_CLR_END_DETECT_INT_CLR = 0x8
	// Position of BYTE_TRANS_DONE_INT_CLR field.
	I2C_INT_CLR_BYTE_TRANS_DONE_INT_CLR_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_CLR field.
	I2C_INT_CLR_BYTE_TRANS_DONE_INT_CLR_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_CLR.
	I2C_INT_CLR_BYTE_TRANS_DONE_INT_CLR = 0x10
	// Position of ARBITRATION_LOST_INT_CLR field.
	I2C_INT_CLR_ARBITRATION_LOST_INT_CLR_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_CLR field.
	I2C_INT_CLR_ARBITRATION_LOST_INT_CLR_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_CLR.
	I2C_INT_CLR_ARBITRATION_LOST_INT_CLR = 0x20
	// Position of MST_TXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_MST_TXFIFO_UDF_INT_CLR_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_MST_TXFIFO_UDF_INT_CLR_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_CLR.
	I2C_INT_CLR_MST_TXFIFO_UDF_INT_CLR = 0x40
	// Position of TRANS_COMPLETE_INT_CLR field.
	I2C_INT_CLR_TRANS_COMPLETE_INT_CLR_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_CLR field.
	I2C_INT_CLR_TRANS_COMPLETE_INT_CLR_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_CLR.
	I2C_INT_CLR_TRANS_COMPLETE_INT_CLR = 0x80
	// Position of TIME_OUT_INT_CLR field.
	I2C_INT_CLR_TIME_OUT_INT_CLR_Pos = 0x8
	// Bit mask of TIME_OUT_INT_CLR field.
	I2C_INT_CLR_TIME_OUT_INT_CLR_Msk = 0x100
	// Bit TIME_OUT_INT_CLR.
	I2C_INT_CLR_TIME_OUT_INT_CLR = 0x100
	// Position of TRANS_START_INT_CLR field.
	I2C_INT_CLR_TRANS_START_INT_CLR_Pos = 0x9
	// Bit mask of TRANS_START_INT_CLR field.
	I2C_INT_CLR_TRANS_START_INT_CLR_Msk = 0x200
	// Bit TRANS_START_INT_CLR.
	I2C_INT_CLR_TRANS_START_INT_CLR = 0x200
	// Position of NACK_INT_CLR field.
	I2C_INT_CLR_NACK_INT_CLR_Pos = 0xa
	// Bit mask of NACK_INT_CLR field.
	I2C_INT_CLR_NACK_INT_CLR_Msk = 0x400
	// Bit NACK_INT_CLR.
	I2C_INT_CLR_NACK_INT_CLR = 0x400
	// Position of TXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_TXFIFO_OVF_INT_CLR_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_CLR field.
	I2C_INT_CLR_TXFIFO_OVF_INT_CLR_Msk = 0x800
	// Bit TXFIFO_OVF_INT_CLR.
	I2C_INT_CLR_TXFIFO_OVF_INT_CLR = 0x800
	// Position of RXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_UDF_INT_CLR_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_CLR field.
	I2C_INT_CLR_RXFIFO_UDF_INT_CLR_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_CLR.
	I2C_INT_CLR_RXFIFO_UDF_INT_CLR = 0x1000
	// Position of SCL_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_ST_TO_INT_CLR_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_ST_TO_INT_CLR_Msk = 0x2000
	// Bit SCL_ST_TO_INT_CLR.
	I2C_INT_CLR_SCL_ST_TO_INT_CLR = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_MAIN_ST_TO_INT_CLR_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_CLR field.
	I2C_INT_CLR_SCL_MAIN_ST_TO_INT_CLR_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_CLR.
	I2C_INT_CLR_SCL_MAIN_ST_TO_INT_CLR = 0x4000
	// Position of DET_START_INT_CLR field.
	I2C_INT_CLR_DET_START_INT_CLR_Pos = 0xf
	// Bit mask of DET_START_INT_CLR field.
	I2C_INT_CLR_DET_START_INT_CLR_Msk = 0x8000
	// Bit DET_START_INT_CLR.
	I2C_INT_CLR_DET_START_INT_CLR = 0x8000
	// Position of SLAVE_STRETCH_INT_CLR field.
	I2C_INT_CLR_SLAVE_STRETCH_INT_CLR_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_CLR field.
	I2C_INT_CLR_SLAVE_STRETCH_INT_CLR_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_CLR.
	I2C_INT_CLR_SLAVE_STRETCH_INT_CLR = 0x10000

	// INT_ENA: Interrupt enable bits
	// Position of RXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_RXFIFO_WM_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_RXFIFO_WM_INT_ENA_Msk = 0x1
	// Bit RXFIFO_WM_INT_ENA.
	I2C_INT_ENA_RXFIFO_WM_INT_ENA = 0x1
	// Position of TXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_TXFIFO_WM_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_ENA field.
	I2C_INT_ENA_TXFIFO_WM_INT_ENA_Msk = 0x2
	// Bit TXFIFO_WM_INT_ENA.
	I2C_INT_ENA_TXFIFO_WM_INT_ENA = 0x2
	// Position of RXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x4
	// Bit RXFIFO_OVF_INT_ENA.
	I2C_INT_ENA_RXFIFO_OVF_INT_ENA = 0x4
	// Position of END_DETECT_INT_ENA field.
	I2C_INT_ENA_END_DETECT_INT_ENA_Pos = 0x3
	// Bit mask of END_DETECT_INT_ENA field.
	I2C_INT_ENA_END_DETECT_INT_ENA_Msk = 0x8
	// Bit END_DETECT_INT_ENA.
	I2C_INT_ENA_END_DETECT_INT_ENA = 0x8
	// Position of BYTE_TRANS_DONE_INT_ENA field.
	I2C_INT_ENA_BYTE_TRANS_DONE_INT_ENA_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_ENA field.
	I2C_INT_ENA_BYTE_TRANS_DONE_INT_ENA_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_ENA.
	I2C_INT_ENA_BYTE_TRANS_DONE_INT_ENA = 0x10
	// Position of ARBITRATION_LOST_INT_ENA field.
	I2C_INT_ENA_ARBITRATION_LOST_INT_ENA_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_ENA field.
	I2C_INT_ENA_ARBITRATION_LOST_INT_ENA_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_ENA.
	I2C_INT_ENA_ARBITRATION_LOST_INT_ENA = 0x20
	// Position of MST_TXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_MST_TXFIFO_UDF_INT_ENA_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_MST_TXFIFO_UDF_INT_ENA_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_ENA.
	I2C_INT_ENA_MST_TXFIFO_UDF_INT_ENA = 0x40
	// Position of TRANS_COMPLETE_INT_ENA field.
	I2C_INT_ENA_TRANS_COMPLETE_INT_ENA_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_ENA field.
	I2C_INT_ENA_TRANS_COMPLETE_INT_ENA_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_ENA.
	I2C_INT_ENA_TRANS_COMPLETE_INT_ENA = 0x80
	// Position of TIME_OUT_INT_ENA field.
	I2C_INT_ENA_TIME_OUT_INT_ENA_Pos = 0x8
	// Bit mask of TIME_OUT_INT_ENA field.
	I2C_INT_ENA_TIME_OUT_INT_ENA_Msk = 0x100
	// Bit TIME_OUT_INT_ENA.
	I2C_INT_ENA_TIME_OUT_INT_ENA = 0x100
	// Position of TRANS_START_INT_ENA field.
	I2C_INT_ENA_TRANS_START_INT_ENA_Pos = 0x9
	// Bit mask of TRANS_START_INT_ENA field.
	I2C_INT_ENA_TRANS_START_INT_ENA_Msk = 0x200
	// Bit TRANS_START_INT_ENA.
	I2C_INT_ENA_TRANS_START_INT_ENA = 0x200
	// Position of NACK_INT_ENA field.
	I2C_INT_ENA_NACK_INT_ENA_Pos = 0xa
	// Bit mask of NACK_INT_ENA field.
	I2C_INT_ENA_NACK_INT_ENA_Msk = 0x400
	// Bit NACK_INT_ENA.
	I2C_INT_ENA_NACK_INT_ENA = 0x400
	// Position of TXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_TXFIFO_OVF_INT_ENA_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_ENA field.
	I2C_INT_ENA_TXFIFO_OVF_INT_ENA_Msk = 0x800
	// Bit TXFIFO_OVF_INT_ENA.
	I2C_INT_ENA_TXFIFO_OVF_INT_ENA = 0x800
	// Position of RXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_UDF_INT_ENA_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_ENA field.
	I2C_INT_ENA_RXFIFO_UDF_INT_ENA_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_ENA.
	I2C_INT_ENA_RXFIFO_UDF_INT_ENA = 0x1000
	// Position of SCL_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_ST_TO_INT_ENA_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_ST_TO_INT_ENA_Msk = 0x2000
	// Bit SCL_ST_TO_INT_ENA.
	I2C_INT_ENA_SCL_ST_TO_INT_ENA = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_MAIN_ST_TO_INT_ENA_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_ENA field.
	I2C_INT_ENA_SCL_MAIN_ST_TO_INT_ENA_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_ENA.
	I2C_INT_ENA_SCL_MAIN_ST_TO_INT_ENA = 0x4000
	// Position of DET_START_INT_ENA field.
	I2C_INT_ENA_DET_START_INT_ENA_Pos = 0xf
	// Bit mask of DET_START_INT_ENA field.
	I2C_INT_ENA_DET_START_INT_ENA_Msk = 0x8000
	// Bit DET_START_INT_ENA.
	I2C_INT_ENA_DET_START_INT_ENA = 0x8000
	// Position of SLAVE_STRETCH_INT_ENA field.
	I2C_INT_ENA_SLAVE_STRETCH_INT_ENA_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_ENA field.
	I2C_INT_ENA_SLAVE_STRETCH_INT_ENA_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_ENA.
	I2C_INT_ENA_SLAVE_STRETCH_INT_ENA = 0x10000

	// INT_STATUS: Status of captured I2C communication events
	// Position of RXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_RXFIFO_WM_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_RXFIFO_WM_INT_ST_Msk = 0x1
	// Bit RXFIFO_WM_INT_ST.
	I2C_INT_STATUS_RXFIFO_WM_INT_ST = 0x1
	// Position of TXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_TXFIFO_WM_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_WM_INT_ST field.
	I2C_INT_STATUS_TXFIFO_WM_INT_ST_Msk = 0x2
	// Bit TXFIFO_WM_INT_ST.
	I2C_INT_STATUS_TXFIFO_WM_INT_ST = 0x2
	// Position of RXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_OVF_INT_ST_Pos = 0x2
	// Bit mask of RXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_OVF_INT_ST_Msk = 0x4
	// Bit RXFIFO_OVF_INT_ST.
	I2C_INT_STATUS_RXFIFO_OVF_INT_ST = 0x4
	// Position of END_DETECT_INT_ST field.
	I2C_INT_STATUS_END_DETECT_INT_ST_Pos = 0x3
	// Bit mask of END_DETECT_INT_ST field.
	I2C_INT_STATUS_END_DETECT_INT_ST_Msk = 0x8
	// Bit END_DETECT_INT_ST.
	I2C_INT_STATUS_END_DETECT_INT_ST = 0x8
	// Position of BYTE_TRANS_DONE_INT_ST field.
	I2C_INT_STATUS_BYTE_TRANS_DONE_INT_ST_Pos = 0x4
	// Bit mask of BYTE_TRANS_DONE_INT_ST field.
	I2C_INT_STATUS_BYTE_TRANS_DONE_INT_ST_Msk = 0x10
	// Bit BYTE_TRANS_DONE_INT_ST.
	I2C_INT_STATUS_BYTE_TRANS_DONE_INT_ST = 0x10
	// Position of ARBITRATION_LOST_INT_ST field.
	I2C_INT_STATUS_ARBITRATION_LOST_INT_ST_Pos = 0x5
	// Bit mask of ARBITRATION_LOST_INT_ST field.
	I2C_INT_STATUS_ARBITRATION_LOST_INT_ST_Msk = 0x20
	// Bit ARBITRATION_LOST_INT_ST.
	I2C_INT_STATUS_ARBITRATION_LOST_INT_ST = 0x20
	// Position of MST_TXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_MST_TXFIFO_UDF_INT_ST_Pos = 0x6
	// Bit mask of MST_TXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_MST_TXFIFO_UDF_INT_ST_Msk = 0x40
	// Bit MST_TXFIFO_UDF_INT_ST.
	I2C_INT_STATUS_MST_TXFIFO_UDF_INT_ST = 0x40
	// Position of TRANS_COMPLETE_INT_ST field.
	I2C_INT_STATUS_TRANS_COMPLETE_INT_ST_Pos = 0x7
	// Bit mask of TRANS_COMPLETE_INT_ST field.
	I2C_INT_STATUS_TRANS_COMPLETE_INT_ST_Msk = 0x80
	// Bit TRANS_COMPLETE_INT_ST.
	I2C_INT_STATUS_TRANS_COMPLETE_INT_ST = 0x80
	// Position of TIME_OUT_INT_ST field.
	I2C_INT_STATUS_TIME_OUT_INT_ST_Pos = 0x8
	// Bit mask of TIME_OUT_INT_ST field.
	I2C_INT_STATUS_TIME_OUT_INT_ST_Msk = 0x100
	// Bit TIME_OUT_INT_ST.
	I2C_INT_STATUS_TIME_OUT_INT_ST = 0x100
	// Position of TRANS_START_INT_ST field.
	I2C_INT_STATUS_TRANS_START_INT_ST_Pos = 0x9
	// Bit mask of TRANS_START_INT_ST field.
	I2C_INT_STATUS_TRANS_START_INT_ST_Msk = 0x200
	// Bit TRANS_START_INT_ST.
	I2C_INT_STATUS_TRANS_START_INT_ST = 0x200
	// Position of NACK_INT_ST field.
	I2C_INT_STATUS_NACK_INT_ST_Pos = 0xa
	// Bit mask of NACK_INT_ST field.
	I2C_INT_STATUS_NACK_INT_ST_Msk = 0x400
	// Bit NACK_INT_ST.
	I2C_INT_STATUS_NACK_INT_ST = 0x400
	// Position of TXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_TXFIFO_OVF_INT_ST_Pos = 0xb
	// Bit mask of TXFIFO_OVF_INT_ST field.
	I2C_INT_STATUS_TXFIFO_OVF_INT_ST_Msk = 0x800
	// Bit TXFIFO_OVF_INT_ST.
	I2C_INT_STATUS_TXFIFO_OVF_INT_ST = 0x800
	// Position of RXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_UDF_INT_ST_Pos = 0xc
	// Bit mask of RXFIFO_UDF_INT_ST field.
	I2C_INT_STATUS_RXFIFO_UDF_INT_ST_Msk = 0x1000
	// Bit RXFIFO_UDF_INT_ST.
	I2C_INT_STATUS_RXFIFO_UDF_INT_ST = 0x1000
	// Position of SCL_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_ST_TO_INT_ST_Pos = 0xd
	// Bit mask of SCL_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_ST_TO_INT_ST_Msk = 0x2000
	// Bit SCL_ST_TO_INT_ST.
	I2C_INT_STATUS_SCL_ST_TO_INT_ST = 0x2000
	// Position of SCL_MAIN_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_MAIN_ST_TO_INT_ST_Pos = 0xe
	// Bit mask of SCL_MAIN_ST_TO_INT_ST field.
	I2C_INT_STATUS_SCL_MAIN_ST_TO_INT_ST_Msk = 0x4000
	// Bit SCL_MAIN_ST_TO_INT_ST.
	I2C_INT_STATUS_SCL_MAIN_ST_TO_INT_ST = 0x4000
	// Position of DET_START_INT_ST field.
	I2C_INT_STATUS_DET_START_INT_ST_Pos = 0xf
	// Bit mask of DET_START_INT_ST field.
	I2C_INT_STATUS_DET_START_INT_ST_Msk = 0x8000
	// Bit DET_START_INT_ST.
	I2C_INT_STATUS_DET_START_INT_ST = 0x8000
	// Position of SLAVE_STRETCH_INT_ST field.
	I2C_INT_STATUS_SLAVE_STRETCH_INT_ST_Pos = 0x10
	// Bit mask of SLAVE_STRETCH_INT_ST field.
	I2C_INT_STATUS_SLAVE_STRETCH_INT_ST_Msk = 0x10000
	// Bit SLAVE_STRETCH_INT_ST.
	I2C_INT_STATUS_SLAVE_STRETCH_INT_ST = 0x10000

	// SDA_HOLD: Configures the hold time after a negative SCL edge
	// Position of TIME field.
	I2C_SDA_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SDA_HOLD_TIME_Msk = 0x3ff

	// SDA_SAMPLE: Configures the sample time after a positive SCL edge
	// Position of TIME field.
	I2C_SDA_SAMPLE_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SDA_SAMPLE_TIME_Msk = 0x3ff

	// SCL_HIGH_PERIOD: Configures the high level width of the SCL clock
	// Position of SCL_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_HIGH_PERIOD_Pos = 0x0
	// Bit mask of SCL_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_HIGH_PERIOD_Msk = 0x3fff
	// Position of SCL_WAIT_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD_Pos = 0xe
	// Bit mask of SCL_WAIT_HIGH_PERIOD field.
	I2C_SCL_HIGH_PERIOD_SCL_WAIT_HIGH_PERIOD_Msk = 0xfffc000

	// SCL_START_HOLD: Configures the interval between pulling SDA low and pulling SCL low when the master generates a START condition
	// Position of TIME field.
	I2C_SCL_START_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_START_HOLD_TIME_Msk = 0x3ff

	// SCL_RSTART_SETUP: Configures the interval between the positive edge of SCL and the negative edge of SDA
	// Position of TIME field.
	I2C_SCL_RSTART_SETUP_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_RSTART_SETUP_TIME_Msk = 0x3ff

	// SCL_STOP_HOLD: Configures the delay after the SCL clock edge for a stop condition
	// Position of TIME field.
	I2C_SCL_STOP_HOLD_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_STOP_HOLD_TIME_Msk = 0x3fff

	// SCL_STOP_SETUP: Configures the delay between the SDA and SCL positive edge for a stop condition
	// Position of TIME field.
	I2C_SCL_STOP_SETUP_TIME_Pos = 0x0
	// Bit mask of TIME field.
	I2C_SCL_STOP_SETUP_TIME_Msk = 0x3ff

	// SCL_FILTER_CFG: SCL filter configuration register
	// Position of SCL_FILTER_THRES field.
	I2C_SCL_FILTER_CFG_SCL_FILTER_THRES_Pos = 0x0
	// Bit mask of SCL_FILTER_THRES field.
	I2C_SCL_FILTER_CFG_SCL_FILTER_THRES_Msk = 0xf
	// Position of SCL_FILTER_EN field.
	I2C_SCL_FILTER_CFG_SCL_FILTER_EN_Pos = 0x4
	// Bit mask of SCL_FILTER_EN field.
	I2C_SCL_FILTER_CFG_SCL_FILTER_EN_Msk = 0x10
	// Bit SCL_FILTER_EN.
	I2C_SCL_FILTER_CFG_SCL_FILTER_EN = 0x10

	// SDA_FILTER_CFG: SDA filter configuration register
	// Position of SDA_FILTER_THRES field.
	I2C_SDA_FILTER_CFG_SDA_FILTER_THRES_Pos = 0x0
	// Bit mask of SDA_FILTER_THRES field.
	I2C_SDA_FILTER_CFG_SDA_FILTER_THRES_Msk = 0xf
	// Position of SDA_FILTER_EN field.
	I2C_SDA_FILTER_CFG_SDA_FILTER_EN_Pos = 0x4
	// Bit mask of SDA_FILTER_EN field.
	I2C_SDA_FILTER_CFG_SDA_FILTER_EN_Msk = 0x10
	// Bit SDA_FILTER_EN.
	I2C_SDA_FILTER_CFG_SDA_FILTER_EN = 0x10

	// COMD0: I2C command register %s
	// Position of COMMAND field.
	I2C_COMD_COMMAND_Pos = 0x0
	// Bit mask of COMMAND field.
	I2C_COMD_COMMAND_Msk = 0x3fff
	// Position of COMMAND_DONE field.
	I2C_COMD_COMMAND_DONE_Pos = 0x1f
	// Bit mask of COMMAND_DONE field.
	I2C_COMD_COMMAND_DONE_Msk = 0x80000000
	// Bit COMMAND_DONE.
	I2C_COMD_COMMAND_DONE = 0x80000000

	// SCL_ST_TIME_OUT: SCL status time out register
	// Position of SCL_ST_TO field.
	I2C_SCL_ST_TIME_OUT_SCL_ST_TO_Pos = 0x0
	// Bit mask of SCL_ST_TO field.
	I2C_SCL_ST_TIME_OUT_SCL_ST_TO_Msk = 0xffffff

	// SCL_MAIN_ST_TIME_OUT: SCL main status time out register
	// Position of SCL_MAIN_ST_TO field.
	I2C_SCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_Pos = 0x0
	// Bit mask of SCL_MAIN_ST_TO field.
	I2C_SCL_MAIN_ST_TIME_OUT_SCL_MAIN_ST_TO_Msk = 0xffffff

	// SCL_SP_CONF: Power configuration register
	// Position of SCL_RST_SLV_EN field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_EN_Pos = 0x0
	// Bit mask of SCL_RST_SLV_EN field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_EN_Msk = 0x1
	// Bit SCL_RST_SLV_EN.
	I2C_SCL_SP_CONF_SCL_RST_SLV_EN = 0x1
	// Position of SCL_RST_SLV_NUM field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_NUM_Pos = 0x1
	// Bit mask of SCL_RST_SLV_NUM field.
	I2C_SCL_SP_CONF_SCL_RST_SLV_NUM_Msk = 0x3e
	// Position of SCL_PD_EN field.
	I2C_SCL_SP_CONF_SCL_PD_EN_Pos = 0x6
	// Bit mask of SCL_PD_EN field.
	I2C_SCL_SP_CONF_SCL_PD_EN_Msk = 0x40
	// Bit SCL_PD_EN.
	I2C_SCL_SP_CONF_SCL_PD_EN = 0x40
	// Position of SDA_PD_EN field.
	I2C_SCL_SP_CONF_SDA_PD_EN_Pos = 0x7
	// Bit mask of SDA_PD_EN field.
	I2C_SCL_SP_CONF_SDA_PD_EN_Msk = 0x80
	// Bit SDA_PD_EN.
	I2C_SCL_SP_CONF_SDA_PD_EN = 0x80

	// SCL_STRETCH_CONF: Set SCL stretch of I2C slave
	// Position of STRETCH_PROTECT_NUM field.
	I2C_SCL_STRETCH_CONF_STRETCH_PROTECT_NUM_Pos = 0x0
	// Bit mask of STRETCH_PROTECT_NUM field.
	I2C_SCL_STRETCH_CONF_STRETCH_PROTECT_NUM_Msk = 0x3ff
	// Position of SLAVE_SCL_STRETCH_EN field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN_Pos = 0xa
	// Bit mask of SLAVE_SCL_STRETCH_EN field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN_Msk = 0x400
	// Bit SLAVE_SCL_STRETCH_EN.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_EN = 0x400
	// Position of SLAVE_SCL_STRETCH_CLR field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR_Pos = 0xb
	// Bit mask of SLAVE_SCL_STRETCH_CLR field.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR_Msk = 0x800
	// Bit SLAVE_SCL_STRETCH_CLR.
	I2C_SCL_STRETCH_CONF_SLAVE_SCL_STRETCH_CLR = 0x800

	// DATE: Version control register
	// Position of DATE field.
	I2C_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	I2C_DATE_DATE_Msk = 0xffffffff
)

// Constants for I2S0: I2S (Inter-IC Sound) Controller 0
const (
	// CONF: I2S configuration register
	// Position of TX_RESET field.
	I2S_CONF_TX_RESET_Pos = 0x0
	// Bit mask of TX_RESET field.
	I2S_CONF_TX_RESET_Msk = 0x1
	// Bit TX_RESET.
	I2S_CONF_TX_RESET = 0x1
	// Position of RX_RESET field.
	I2S_CONF_RX_RESET_Pos = 0x1
	// Bit mask of RX_RESET field.
	I2S_CONF_RX_RESET_Msk = 0x2
	// Bit RX_RESET.
	I2S_CONF_RX_RESET = 0x2
	// Position of TX_FIFO_RESET field.
	I2S_CONF_TX_FIFO_RESET_Pos = 0x2
	// Bit mask of TX_FIFO_RESET field.
	I2S_CONF_TX_FIFO_RESET_Msk = 0x4
	// Bit TX_FIFO_RESET.
	I2S_CONF_TX_FIFO_RESET = 0x4
	// Position of RX_FIFO_RESET field.
	I2S_CONF_RX_FIFO_RESET_Pos = 0x3
	// Bit mask of RX_FIFO_RESET field.
	I2S_CONF_RX_FIFO_RESET_Msk = 0x8
	// Bit RX_FIFO_RESET.
	I2S_CONF_RX_FIFO_RESET = 0x8
	// Position of TX_START field.
	I2S_CONF_TX_START_Pos = 0x4
	// Bit mask of TX_START field.
	I2S_CONF_TX_START_Msk = 0x10
	// Bit TX_START.
	I2S_CONF_TX_START = 0x10
	// Position of RX_START field.
	I2S_CONF_RX_START_Pos = 0x5
	// Bit mask of RX_START field.
	I2S_CONF_RX_START_Msk = 0x20
	// Bit RX_START.
	I2S_CONF_RX_START = 0x20
	// Position of TX_SLAVE_MOD field.
	I2S_CONF_TX_SLAVE_MOD_Pos = 0x6
	// Bit mask of TX_SLAVE_MOD field.
	I2S_CONF_TX_SLAVE_MOD_Msk = 0x40
	// Bit TX_SLAVE_MOD.
	I2S_CONF_TX_SLAVE_MOD = 0x40
	// Position of RX_SLAVE_MOD field.
	I2S_CONF_RX_SLAVE_MOD_Pos = 0x7
	// Bit mask of RX_SLAVE_MOD field.
	I2S_CONF_RX_SLAVE_MOD_Msk = 0x80
	// Bit RX_SLAVE_MOD.
	I2S_CONF_RX_SLAVE_MOD = 0x80
	// Position of TX_RIGHT_FIRST field.
	I2S_CONF_TX_RIGHT_FIRST_Pos = 0x8
	// Bit mask of TX_RIGHT_FIRST field.
	I2S_CONF_TX_RIGHT_FIRST_Msk = 0x100
	// Bit TX_RIGHT_FIRST.
	I2S_CONF_TX_RIGHT_FIRST = 0x100
	// Position of RX_RIGHT_FIRST field.
	I2S_CONF_RX_RIGHT_FIRST_Pos = 0x9
	// Bit mask of RX_RIGHT_FIRST field.
	I2S_CONF_RX_RIGHT_FIRST_Msk = 0x200
	// Bit RX_RIGHT_FIRST.
	I2S_CONF_RX_RIGHT_FIRST = 0x200
	// Position of TX_MSB_SHIFT field.
	I2S_CONF_TX_MSB_SHIFT_Pos = 0xa
	// Bit mask of TX_MSB_SHIFT field.
	I2S_CONF_TX_MSB_SHIFT_Msk = 0x400
	// Bit TX_MSB_SHIFT.
	I2S_CONF_TX_MSB_SHIFT = 0x400
	// Position of RX_MSB_SHIFT field.
	I2S_CONF_RX_MSB_SHIFT_Pos = 0xb
	// Bit mask of RX_MSB_SHIFT field.
	I2S_CONF_RX_MSB_SHIFT_Msk = 0x800
	// Bit RX_MSB_SHIFT.
	I2S_CONF_RX_MSB_SHIFT = 0x800
	// Position of TX_SHORT_SYNC field.
	I2S_CONF_TX_SHORT_SYNC_Pos = 0xc
	// Bit mask of TX_SHORT_SYNC field.
	I2S_CONF_TX_SHORT_SYNC_Msk = 0x1000
	// Bit TX_SHORT_SYNC.
	I2S_CONF_TX_SHORT_SYNC = 0x1000
	// Position of RX_SHORT_SYNC field.
	I2S_CONF_RX_SHORT_SYNC_Pos = 0xd
	// Bit mask of RX_SHORT_SYNC field.
	I2S_CONF_RX_SHORT_SYNC_Msk = 0x2000
	// Bit RX_SHORT_SYNC.
	I2S_CONF_RX_SHORT_SYNC = 0x2000
	// Position of TX_MONO field.
	I2S_CONF_TX_MONO_Pos = 0xe
	// Bit mask of TX_MONO field.
	I2S_CONF_TX_MONO_Msk = 0x4000
	// Bit TX_MONO.
	I2S_CONF_TX_MONO = 0x4000
	// Position of RX_MONO field.
	I2S_CONF_RX_MONO_Pos = 0xf
	// Bit mask of RX_MONO field.
	I2S_CONF_RX_MONO_Msk = 0x8000
	// Bit RX_MONO.
	I2S_CONF_RX_MONO = 0x8000
	// Position of TX_MSB_RIGHT field.
	I2S_CONF_TX_MSB_RIGHT_Pos = 0x10
	// Bit mask of TX_MSB_RIGHT field.
	I2S_CONF_TX_MSB_RIGHT_Msk = 0x10000
	// Bit TX_MSB_RIGHT.
	I2S_CONF_TX_MSB_RIGHT = 0x10000
	// Position of RX_MSB_RIGHT field.
	I2S_CONF_RX_MSB_RIGHT_Pos = 0x11
	// Bit mask of RX_MSB_RIGHT field.
	I2S_CONF_RX_MSB_RIGHT_Msk = 0x20000
	// Bit RX_MSB_RIGHT.
	I2S_CONF_RX_MSB_RIGHT = 0x20000
	// Position of TX_LSB_FIRST_DMA field.
	I2S_CONF_TX_LSB_FIRST_DMA_Pos = 0x12
	// Bit mask of TX_LSB_FIRST_DMA field.
	I2S_CONF_TX_LSB_FIRST_DMA_Msk = 0x40000
	// Bit TX_LSB_FIRST_DMA.
	I2S_CONF_TX_LSB_FIRST_DMA = 0x40000
	// Position of RX_LSB_FIRST_DMA field.
	I2S_CONF_RX_LSB_FIRST_DMA_Pos = 0x13
	// Bit mask of RX_LSB_FIRST_DMA field.
	I2S_CONF_RX_LSB_FIRST_DMA_Msk = 0x80000
	// Bit RX_LSB_FIRST_DMA.
	I2S_CONF_RX_LSB_FIRST_DMA = 0x80000
	// Position of SIG_LOOPBACK field.
	I2S_CONF_SIG_LOOPBACK_Pos = 0x14
	// Bit mask of SIG_LOOPBACK field.
	I2S_CONF_SIG_LOOPBACK_Msk = 0x100000
	// Bit SIG_LOOPBACK.
	I2S_CONF_SIG_LOOPBACK = 0x100000
	// Position of TX_FIFO_RESET_ST field.
	I2S_CONF_TX_FIFO_RESET_ST_Pos = 0x15
	// Bit mask of TX_FIFO_RESET_ST field.
	I2S_CONF_TX_FIFO_RESET_ST_Msk = 0x200000
	// Bit TX_FIFO_RESET_ST.
	I2S_CONF_TX_FIFO_RESET_ST = 0x200000
	// Position of RX_FIFO_RESET_ST field.
	I2S_CONF_RX_FIFO_RESET_ST_Pos = 0x16
	// Bit mask of RX_FIFO_RESET_ST field.
	I2S_CONF_RX_FIFO_RESET_ST_Msk = 0x400000
	// Bit RX_FIFO_RESET_ST.
	I2S_CONF_RX_FIFO_RESET_ST = 0x400000
	// Position of TX_RESET_ST field.
	I2S_CONF_TX_RESET_ST_Pos = 0x17
	// Bit mask of TX_RESET_ST field.
	I2S_CONF_TX_RESET_ST_Msk = 0x800000
	// Bit TX_RESET_ST.
	I2S_CONF_TX_RESET_ST = 0x800000
	// Position of TX_DMA_EQUAL field.
	I2S_CONF_TX_DMA_EQUAL_Pos = 0x18
	// Bit mask of TX_DMA_EQUAL field.
	I2S_CONF_TX_DMA_EQUAL_Msk = 0x1000000
	// Bit TX_DMA_EQUAL.
	I2S_CONF_TX_DMA_EQUAL = 0x1000000
	// Position of RX_DMA_EQUAL field.
	I2S_CONF_RX_DMA_EQUAL_Pos = 0x19
	// Bit mask of RX_DMA_EQUAL field.
	I2S_CONF_RX_DMA_EQUAL_Msk = 0x2000000
	// Bit RX_DMA_EQUAL.
	I2S_CONF_RX_DMA_EQUAL = 0x2000000
	// Position of PRE_REQ_EN field.
	I2S_CONF_PRE_REQ_EN_Pos = 0x1a
	// Bit mask of PRE_REQ_EN field.
	I2S_CONF_PRE_REQ_EN_Msk = 0x4000000
	// Bit PRE_REQ_EN.
	I2S_CONF_PRE_REQ_EN = 0x4000000
	// Position of TX_BIG_ENDIAN field.
	I2S_CONF_TX_BIG_ENDIAN_Pos = 0x1b
	// Bit mask of TX_BIG_ENDIAN field.
	I2S_CONF_TX_BIG_ENDIAN_Msk = 0x8000000
	// Bit TX_BIG_ENDIAN.
	I2S_CONF_TX_BIG_ENDIAN = 0x8000000
	// Position of RX_BIG_ENDIAN field.
	I2S_CONF_RX_BIG_ENDIAN_Pos = 0x1c
	// Bit mask of RX_BIG_ENDIAN field.
	I2S_CONF_RX_BIG_ENDIAN_Msk = 0x10000000
	// Bit RX_BIG_ENDIAN.
	I2S_CONF_RX_BIG_ENDIAN = 0x10000000
	// Position of RX_RESET_ST field.
	I2S_CONF_RX_RESET_ST_Pos = 0x1d
	// Bit mask of RX_RESET_ST field.
	I2S_CONF_RX_RESET_ST_Msk = 0x20000000
	// Bit RX_RESET_ST.
	I2S_CONF_RX_RESET_ST = 0x20000000

	// INT_RAW: Raw interrupt status
	// Position of RX_TAKE_DATA_INT_RAW field.
	I2S_INT_RAW_RX_TAKE_DATA_INT_RAW_Pos = 0x0
	// Bit mask of RX_TAKE_DATA_INT_RAW field.
	I2S_INT_RAW_RX_TAKE_DATA_INT_RAW_Msk = 0x1
	// Bit RX_TAKE_DATA_INT_RAW.
	I2S_INT_RAW_RX_TAKE_DATA_INT_RAW = 0x1
	// Position of TX_PUT_DATA_INT_RAW field.
	I2S_INT_RAW_TX_PUT_DATA_INT_RAW_Pos = 0x1
	// Bit mask of TX_PUT_DATA_INT_RAW field.
	I2S_INT_RAW_TX_PUT_DATA_INT_RAW_Msk = 0x2
	// Bit TX_PUT_DATA_INT_RAW.
	I2S_INT_RAW_TX_PUT_DATA_INT_RAW = 0x2
	// Position of RX_WFULL_INT_RAW field.
	I2S_INT_RAW_RX_WFULL_INT_RAW_Pos = 0x2
	// Bit mask of RX_WFULL_INT_RAW field.
	I2S_INT_RAW_RX_WFULL_INT_RAW_Msk = 0x4
	// Bit RX_WFULL_INT_RAW.
	I2S_INT_RAW_RX_WFULL_INT_RAW = 0x4
	// Position of RX_REMPTY_INT_RAW field.
	I2S_INT_RAW_RX_REMPTY_INT_RAW_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_RAW field.
	I2S_INT_RAW_RX_REMPTY_INT_RAW_Msk = 0x8
	// Bit RX_REMPTY_INT_RAW.
	I2S_INT_RAW_RX_REMPTY_INT_RAW = 0x8
	// Position of TX_WFULL_INT_RAW field.
	I2S_INT_RAW_TX_WFULL_INT_RAW_Pos = 0x4
	// Bit mask of TX_WFULL_INT_RAW field.
	I2S_INT_RAW_TX_WFULL_INT_RAW_Msk = 0x10
	// Bit TX_WFULL_INT_RAW.
	I2S_INT_RAW_TX_WFULL_INT_RAW = 0x10
	// Position of TX_REMPTY_INT_RAW field.
	I2S_INT_RAW_TX_REMPTY_INT_RAW_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_RAW field.
	I2S_INT_RAW_TX_REMPTY_INT_RAW_Msk = 0x20
	// Bit TX_REMPTY_INT_RAW.
	I2S_INT_RAW_TX_REMPTY_INT_RAW = 0x20
	// Position of RX_HUNG_INT_RAW field.
	I2S_INT_RAW_RX_HUNG_INT_RAW_Pos = 0x6
	// Bit mask of RX_HUNG_INT_RAW field.
	I2S_INT_RAW_RX_HUNG_INT_RAW_Msk = 0x40
	// Bit RX_HUNG_INT_RAW.
	I2S_INT_RAW_RX_HUNG_INT_RAW = 0x40
	// Position of TX_HUNG_INT_RAW field.
	I2S_INT_RAW_TX_HUNG_INT_RAW_Pos = 0x7
	// Bit mask of TX_HUNG_INT_RAW field.
	I2S_INT_RAW_TX_HUNG_INT_RAW_Msk = 0x80
	// Bit TX_HUNG_INT_RAW.
	I2S_INT_RAW_TX_HUNG_INT_RAW = 0x80
	// Position of IN_DONE_INT_RAW field.
	I2S_INT_RAW_IN_DONE_INT_RAW_Pos = 0x8
	// Bit mask of IN_DONE_INT_RAW field.
	I2S_INT_RAW_IN_DONE_INT_RAW_Msk = 0x100
	// Bit IN_DONE_INT_RAW.
	I2S_INT_RAW_IN_DONE_INT_RAW = 0x100
	// Position of IN_SUC_EOF_INT_RAW field.
	I2S_INT_RAW_IN_SUC_EOF_INT_RAW_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_RAW field.
	I2S_INT_RAW_IN_SUC_EOF_INT_RAW_Msk = 0x200
	// Bit IN_SUC_EOF_INT_RAW.
	I2S_INT_RAW_IN_SUC_EOF_INT_RAW = 0x200
	// Position of IN_ERR_EOF_INT_RAW field.
	I2S_INT_RAW_IN_ERR_EOF_INT_RAW_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_RAW field.
	I2S_INT_RAW_IN_ERR_EOF_INT_RAW_Msk = 0x400
	// Bit IN_ERR_EOF_INT_RAW.
	I2S_INT_RAW_IN_ERR_EOF_INT_RAW = 0x400
	// Position of OUT_DONE_INT_RAW field.
	I2S_INT_RAW_OUT_DONE_INT_RAW_Pos = 0xb
	// Bit mask of OUT_DONE_INT_RAW field.
	I2S_INT_RAW_OUT_DONE_INT_RAW_Msk = 0x800
	// Bit OUT_DONE_INT_RAW.
	I2S_INT_RAW_OUT_DONE_INT_RAW = 0x800
	// Position of OUT_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_EOF_INT_RAW_Pos = 0xc
	// Bit mask of OUT_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_EOF_INT_RAW_Msk = 0x1000
	// Bit OUT_EOF_INT_RAW.
	I2S_INT_RAW_OUT_EOF_INT_RAW = 0x1000
	// Position of IN_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_ERR_INT_RAW_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_ERR_INT_RAW_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_RAW.
	I2S_INT_RAW_IN_DSCR_ERR_INT_RAW = 0x2000
	// Position of OUT_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_OUT_DSCR_ERR_INT_RAW_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_RAW field.
	I2S_INT_RAW_OUT_DSCR_ERR_INT_RAW_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_RAW.
	I2S_INT_RAW_OUT_DSCR_ERR_INT_RAW = 0x4000
	// Position of IN_DSCR_EMPTY_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_RAW field.
	I2S_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_RAW.
	I2S_INT_RAW_IN_DSCR_EMPTY_INT_RAW = 0x8000
	// Position of OUT_TOTAL_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_RAW field.
	I2S_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_RAW.
	I2S_INT_RAW_OUT_TOTAL_EOF_INT_RAW = 0x10000
	// Position of V_SYNC_INT_RAW field.
	I2S_INT_RAW_V_SYNC_INT_RAW_Pos = 0x11
	// Bit mask of V_SYNC_INT_RAW field.
	I2S_INT_RAW_V_SYNC_INT_RAW_Msk = 0x20000
	// Bit V_SYNC_INT_RAW.
	I2S_INT_RAW_V_SYNC_INT_RAW = 0x20000

	// INT_ST: Masked interrupt status
	// Position of RX_TAKE_DATA_INT_ST field.
	I2S_INT_ST_RX_TAKE_DATA_INT_ST_Pos = 0x0
	// Bit mask of RX_TAKE_DATA_INT_ST field.
	I2S_INT_ST_RX_TAKE_DATA_INT_ST_Msk = 0x1
	// Bit RX_TAKE_DATA_INT_ST.
	I2S_INT_ST_RX_TAKE_DATA_INT_ST = 0x1
	// Position of TX_PUT_DATA_INT_ST field.
	I2S_INT_ST_TX_PUT_DATA_INT_ST_Pos = 0x1
	// Bit mask of TX_PUT_DATA_INT_ST field.
	I2S_INT_ST_TX_PUT_DATA_INT_ST_Msk = 0x2
	// Bit TX_PUT_DATA_INT_ST.
	I2S_INT_ST_TX_PUT_DATA_INT_ST = 0x2
	// Position of RX_WFULL_INT_ST field.
	I2S_INT_ST_RX_WFULL_INT_ST_Pos = 0x2
	// Bit mask of RX_WFULL_INT_ST field.
	I2S_INT_ST_RX_WFULL_INT_ST_Msk = 0x4
	// Bit RX_WFULL_INT_ST.
	I2S_INT_ST_RX_WFULL_INT_ST = 0x4
	// Position of RX_REMPTY_INT_ST field.
	I2S_INT_ST_RX_REMPTY_INT_ST_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_ST field.
	I2S_INT_ST_RX_REMPTY_INT_ST_Msk = 0x8
	// Bit RX_REMPTY_INT_ST.
	I2S_INT_ST_RX_REMPTY_INT_ST = 0x8
	// Position of TX_WFULL_INT_ST field.
	I2S_INT_ST_TX_WFULL_INT_ST_Pos = 0x4
	// Bit mask of TX_WFULL_INT_ST field.
	I2S_INT_ST_TX_WFULL_INT_ST_Msk = 0x10
	// Bit TX_WFULL_INT_ST.
	I2S_INT_ST_TX_WFULL_INT_ST = 0x10
	// Position of TX_REMPTY_INT_ST field.
	I2S_INT_ST_TX_REMPTY_INT_ST_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_ST field.
	I2S_INT_ST_TX_REMPTY_INT_ST_Msk = 0x20
	// Bit TX_REMPTY_INT_ST.
	I2S_INT_ST_TX_REMPTY_INT_ST = 0x20
	// Position of RX_HUNG_INT_ST field.
	I2S_INT_ST_RX_HUNG_INT_ST_Pos = 0x6
	// Bit mask of RX_HUNG_INT_ST field.
	I2S_INT_ST_RX_HUNG_INT_ST_Msk = 0x40
	// Bit RX_HUNG_INT_ST.
	I2S_INT_ST_RX_HUNG_INT_ST = 0x40
	// Position of TX_HUNG_INT_ST field.
	I2S_INT_ST_TX_HUNG_INT_ST_Pos = 0x7
	// Bit mask of TX_HUNG_INT_ST field.
	I2S_INT_ST_TX_HUNG_INT_ST_Msk = 0x80
	// Bit TX_HUNG_INT_ST.
	I2S_INT_ST_TX_HUNG_INT_ST = 0x80
	// Position of IN_DONE_INT_ST field.
	I2S_INT_ST_IN_DONE_INT_ST_Pos = 0x8
	// Bit mask of IN_DONE_INT_ST field.
	I2S_INT_ST_IN_DONE_INT_ST_Msk = 0x100
	// Bit IN_DONE_INT_ST.
	I2S_INT_ST_IN_DONE_INT_ST = 0x100
	// Position of IN_SUC_EOF_INT_ST field.
	I2S_INT_ST_IN_SUC_EOF_INT_ST_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_ST field.
	I2S_INT_ST_IN_SUC_EOF_INT_ST_Msk = 0x200
	// Bit IN_SUC_EOF_INT_ST.
	I2S_INT_ST_IN_SUC_EOF_INT_ST = 0x200
	// Position of IN_ERR_EOF_INT_ST field.
	I2S_INT_ST_IN_ERR_EOF_INT_ST_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_ST field.
	I2S_INT_ST_IN_ERR_EOF_INT_ST_Msk = 0x400
	// Bit IN_ERR_EOF_INT_ST.
	I2S_INT_ST_IN_ERR_EOF_INT_ST = 0x400
	// Position of OUT_DONE_INT_ST field.
	I2S_INT_ST_OUT_DONE_INT_ST_Pos = 0xb
	// Bit mask of OUT_DONE_INT_ST field.
	I2S_INT_ST_OUT_DONE_INT_ST_Msk = 0x800
	// Bit OUT_DONE_INT_ST.
	I2S_INT_ST_OUT_DONE_INT_ST = 0x800
	// Position of OUT_EOF_INT_ST field.
	I2S_INT_ST_OUT_EOF_INT_ST_Pos = 0xc
	// Bit mask of OUT_EOF_INT_ST field.
	I2S_INT_ST_OUT_EOF_INT_ST_Msk = 0x1000
	// Bit OUT_EOF_INT_ST.
	I2S_INT_ST_OUT_EOF_INT_ST = 0x1000
	// Position of IN_DSCR_ERR_INT_ST field.
	I2S_INT_ST_IN_DSCR_ERR_INT_ST_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_ST field.
	I2S_INT_ST_IN_DSCR_ERR_INT_ST_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_ST.
	I2S_INT_ST_IN_DSCR_ERR_INT_ST = 0x2000
	// Position of OUT_DSCR_ERR_INT_ST field.
	I2S_INT_ST_OUT_DSCR_ERR_INT_ST_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_ST field.
	I2S_INT_ST_OUT_DSCR_ERR_INT_ST_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_ST.
	I2S_INT_ST_OUT_DSCR_ERR_INT_ST = 0x4000
	// Position of IN_DSCR_EMPTY_INT_ST field.
	I2S_INT_ST_IN_DSCR_EMPTY_INT_ST_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_ST field.
	I2S_INT_ST_IN_DSCR_EMPTY_INT_ST_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_ST.
	I2S_INT_ST_IN_DSCR_EMPTY_INT_ST = 0x8000
	// Position of OUT_TOTAL_EOF_INT_ST field.
	I2S_INT_ST_OUT_TOTAL_EOF_INT_ST_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_ST field.
	I2S_INT_ST_OUT_TOTAL_EOF_INT_ST_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_ST.
	I2S_INT_ST_OUT_TOTAL_EOF_INT_ST = 0x10000
	// Position of V_SYNC_INT_ST field.
	I2S_INT_ST_V_SYNC_INT_ST_Pos = 0x11
	// Bit mask of V_SYNC_INT_ST field.
	I2S_INT_ST_V_SYNC_INT_ST_Msk = 0x20000
	// Bit V_SYNC_INT_ST.
	I2S_INT_ST_V_SYNC_INT_ST = 0x20000

	// INT_ENA: Interrupt enable bits
	// Position of RX_TAKE_DATA_INT_ENA field.
	I2S_INT_ENA_RX_TAKE_DATA_INT_ENA_Pos = 0x0
	// Bit mask of RX_TAKE_DATA_INT_ENA field.
	I2S_INT_ENA_RX_TAKE_DATA_INT_ENA_Msk = 0x1
	// Bit RX_TAKE_DATA_INT_ENA.
	I2S_INT_ENA_RX_TAKE_DATA_INT_ENA = 0x1
	// Position of TX_PUT_DATA_INT_ENA field.
	I2S_INT_ENA_TX_PUT_DATA_INT_ENA_Pos = 0x1
	// Bit mask of TX_PUT_DATA_INT_ENA field.
	I2S_INT_ENA_TX_PUT_DATA_INT_ENA_Msk = 0x2
	// Bit TX_PUT_DATA_INT_ENA.
	I2S_INT_ENA_TX_PUT_DATA_INT_ENA = 0x2
	// Position of RX_WFULL_INT_ENA field.
	I2S_INT_ENA_RX_WFULL_INT_ENA_Pos = 0x2
	// Bit mask of RX_WFULL_INT_ENA field.
	I2S_INT_ENA_RX_WFULL_INT_ENA_Msk = 0x4
	// Bit RX_WFULL_INT_ENA.
	I2S_INT_ENA_RX_WFULL_INT_ENA = 0x4
	// Position of RX_REMPTY_INT_ENA field.
	I2S_INT_ENA_RX_REMPTY_INT_ENA_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_ENA field.
	I2S_INT_ENA_RX_REMPTY_INT_ENA_Msk = 0x8
	// Bit RX_REMPTY_INT_ENA.
	I2S_INT_ENA_RX_REMPTY_INT_ENA = 0x8
	// Position of TX_WFULL_INT_ENA field.
	I2S_INT_ENA_TX_WFULL_INT_ENA_Pos = 0x4
	// Bit mask of TX_WFULL_INT_ENA field.
	I2S_INT_ENA_TX_WFULL_INT_ENA_Msk = 0x10
	// Bit TX_WFULL_INT_ENA.
	I2S_INT_ENA_TX_WFULL_INT_ENA = 0x10
	// Position of TX_REMPTY_INT_ENA field.
	I2S_INT_ENA_TX_REMPTY_INT_ENA_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_ENA field.
	I2S_INT_ENA_TX_REMPTY_INT_ENA_Msk = 0x20
	// Bit TX_REMPTY_INT_ENA.
	I2S_INT_ENA_TX_REMPTY_INT_ENA = 0x20
	// Position of RX_HUNG_INT_ENA field.
	I2S_INT_ENA_RX_HUNG_INT_ENA_Pos = 0x6
	// Bit mask of RX_HUNG_INT_ENA field.
	I2S_INT_ENA_RX_HUNG_INT_ENA_Msk = 0x40
	// Bit RX_HUNG_INT_ENA.
	I2S_INT_ENA_RX_HUNG_INT_ENA = 0x40
	// Position of TX_HUNG_INT_ENA field.
	I2S_INT_ENA_TX_HUNG_INT_ENA_Pos = 0x7
	// Bit mask of TX_HUNG_INT_ENA field.
	I2S_INT_ENA_TX_HUNG_INT_ENA_Msk = 0x80
	// Bit TX_HUNG_INT_ENA.
	I2S_INT_ENA_TX_HUNG_INT_ENA = 0x80
	// Position of IN_DONE_INT_ENA field.
	I2S_INT_ENA_IN_DONE_INT_ENA_Pos = 0x8
	// Bit mask of IN_DONE_INT_ENA field.
	I2S_INT_ENA_IN_DONE_INT_ENA_Msk = 0x100
	// Bit IN_DONE_INT_ENA.
	I2S_INT_ENA_IN_DONE_INT_ENA = 0x100
	// Position of IN_SUC_EOF_INT_ENA field.
	I2S_INT_ENA_IN_SUC_EOF_INT_ENA_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_ENA field.
	I2S_INT_ENA_IN_SUC_EOF_INT_ENA_Msk = 0x200
	// Bit IN_SUC_EOF_INT_ENA.
	I2S_INT_ENA_IN_SUC_EOF_INT_ENA = 0x200
	// Position of IN_ERR_EOF_INT_ENA field.
	I2S_INT_ENA_IN_ERR_EOF_INT_ENA_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_ENA field.
	I2S_INT_ENA_IN_ERR_EOF_INT_ENA_Msk = 0x400
	// Bit IN_ERR_EOF_INT_ENA.
	I2S_INT_ENA_IN_ERR_EOF_INT_ENA = 0x400
	// Position of OUT_DONE_INT_ENA field.
	I2S_INT_ENA_OUT_DONE_INT_ENA_Pos = 0xb
	// Bit mask of OUT_DONE_INT_ENA field.
	I2S_INT_ENA_OUT_DONE_INT_ENA_Msk = 0x800
	// Bit OUT_DONE_INT_ENA.
	I2S_INT_ENA_OUT_DONE_INT_ENA = 0x800
	// Position of OUT_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_EOF_INT_ENA_Pos = 0xc
	// Bit mask of OUT_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_EOF_INT_ENA_Msk = 0x1000
	// Bit OUT_EOF_INT_ENA.
	I2S_INT_ENA_OUT_EOF_INT_ENA = 0x1000
	// Position of IN_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_ERR_INT_ENA_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_ERR_INT_ENA_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_ENA.
	I2S_INT_ENA_IN_DSCR_ERR_INT_ENA = 0x2000
	// Position of OUT_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_OUT_DSCR_ERR_INT_ENA_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_ENA field.
	I2S_INT_ENA_OUT_DSCR_ERR_INT_ENA_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_ENA.
	I2S_INT_ENA_OUT_DSCR_ERR_INT_ENA = 0x4000
	// Position of IN_DSCR_EMPTY_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_ENA field.
	I2S_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_ENA.
	I2S_INT_ENA_IN_DSCR_EMPTY_INT_ENA = 0x8000
	// Position of OUT_TOTAL_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_ENA field.
	I2S_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_ENA.
	I2S_INT_ENA_OUT_TOTAL_EOF_INT_ENA = 0x10000
	// Position of V_SYNC_INT_ENA field.
	I2S_INT_ENA_V_SYNC_INT_ENA_Pos = 0x11
	// Bit mask of V_SYNC_INT_ENA field.
	I2S_INT_ENA_V_SYNC_INT_ENA_Msk = 0x20000
	// Bit V_SYNC_INT_ENA.
	I2S_INT_ENA_V_SYNC_INT_ENA = 0x20000

	// INT_CLR: Interrupt clear bits
	// Position of TAKE_DATA_INT_CLR field.
	I2S_INT_CLR_TAKE_DATA_INT_CLR_Pos = 0x0
	// Bit mask of TAKE_DATA_INT_CLR field.
	I2S_INT_CLR_TAKE_DATA_INT_CLR_Msk = 0x1
	// Bit TAKE_DATA_INT_CLR.
	I2S_INT_CLR_TAKE_DATA_INT_CLR = 0x1
	// Position of PUT_DATA_INT_CLR field.
	I2S_INT_CLR_PUT_DATA_INT_CLR_Pos = 0x1
	// Bit mask of PUT_DATA_INT_CLR field.
	I2S_INT_CLR_PUT_DATA_INT_CLR_Msk = 0x2
	// Bit PUT_DATA_INT_CLR.
	I2S_INT_CLR_PUT_DATA_INT_CLR = 0x2
	// Position of RX_WFULL_INT_CLR field.
	I2S_INT_CLR_RX_WFULL_INT_CLR_Pos = 0x2
	// Bit mask of RX_WFULL_INT_CLR field.
	I2S_INT_CLR_RX_WFULL_INT_CLR_Msk = 0x4
	// Bit RX_WFULL_INT_CLR.
	I2S_INT_CLR_RX_WFULL_INT_CLR = 0x4
	// Position of RX_REMPTY_INT_CLR field.
	I2S_INT_CLR_RX_REMPTY_INT_CLR_Pos = 0x3
	// Bit mask of RX_REMPTY_INT_CLR field.
	I2S_INT_CLR_RX_REMPTY_INT_CLR_Msk = 0x8
	// Bit RX_REMPTY_INT_CLR.
	I2S_INT_CLR_RX_REMPTY_INT_CLR = 0x8
	// Position of TX_WFULL_INT_CLR field.
	I2S_INT_CLR_TX_WFULL_INT_CLR_Pos = 0x4
	// Bit mask of TX_WFULL_INT_CLR field.
	I2S_INT_CLR_TX_WFULL_INT_CLR_Msk = 0x10
	// Bit TX_WFULL_INT_CLR.
	I2S_INT_CLR_TX_WFULL_INT_CLR = 0x10
	// Position of TX_REMPTY_INT_CLR field.
	I2S_INT_CLR_TX_REMPTY_INT_CLR_Pos = 0x5
	// Bit mask of TX_REMPTY_INT_CLR field.
	I2S_INT_CLR_TX_REMPTY_INT_CLR_Msk = 0x20
	// Bit TX_REMPTY_INT_CLR.
	I2S_INT_CLR_TX_REMPTY_INT_CLR = 0x20
	// Position of RX_HUNG_INT_CLR field.
	I2S_INT_CLR_RX_HUNG_INT_CLR_Pos = 0x6
	// Bit mask of RX_HUNG_INT_CLR field.
	I2S_INT_CLR_RX_HUNG_INT_CLR_Msk = 0x40
	// Bit RX_HUNG_INT_CLR.
	I2S_INT_CLR_RX_HUNG_INT_CLR = 0x40
	// Position of TX_HUNG_INT_CLR field.
	I2S_INT_CLR_TX_HUNG_INT_CLR_Pos = 0x7
	// Bit mask of TX_HUNG_INT_CLR field.
	I2S_INT_CLR_TX_HUNG_INT_CLR_Msk = 0x80
	// Bit TX_HUNG_INT_CLR.
	I2S_INT_CLR_TX_HUNG_INT_CLR = 0x80
	// Position of IN_DONE_INT_CLR field.
	I2S_INT_CLR_IN_DONE_INT_CLR_Pos = 0x8
	// Bit mask of IN_DONE_INT_CLR field.
	I2S_INT_CLR_IN_DONE_INT_CLR_Msk = 0x100
	// Bit IN_DONE_INT_CLR.
	I2S_INT_CLR_IN_DONE_INT_CLR = 0x100
	// Position of IN_SUC_EOF_INT_CLR field.
	I2S_INT_CLR_IN_SUC_EOF_INT_CLR_Pos = 0x9
	// Bit mask of IN_SUC_EOF_INT_CLR field.
	I2S_INT_CLR_IN_SUC_EOF_INT_CLR_Msk = 0x200
	// Bit IN_SUC_EOF_INT_CLR.
	I2S_INT_CLR_IN_SUC_EOF_INT_CLR = 0x200
	// Position of IN_ERR_EOF_INT_CLR field.
	I2S_INT_CLR_IN_ERR_EOF_INT_CLR_Pos = 0xa
	// Bit mask of IN_ERR_EOF_INT_CLR field.
	I2S_INT_CLR_IN_ERR_EOF_INT_CLR_Msk = 0x400
	// Bit IN_ERR_EOF_INT_CLR.
	I2S_INT_CLR_IN_ERR_EOF_INT_CLR = 0x400
	// Position of OUT_DONE_INT_CLR field.
	I2S_INT_CLR_OUT_DONE_INT_CLR_Pos = 0xb
	// Bit mask of OUT_DONE_INT_CLR field.
	I2S_INT_CLR_OUT_DONE_INT_CLR_Msk = 0x800
	// Bit OUT_DONE_INT_CLR.
	I2S_INT_CLR_OUT_DONE_INT_CLR = 0x800
	// Position of OUT_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_EOF_INT_CLR_Pos = 0xc
	// Bit mask of OUT_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_EOF_INT_CLR_Msk = 0x1000
	// Bit OUT_EOF_INT_CLR.
	I2S_INT_CLR_OUT_EOF_INT_CLR = 0x1000
	// Position of IN_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_ERR_INT_CLR_Pos = 0xd
	// Bit mask of IN_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_ERR_INT_CLR_Msk = 0x2000
	// Bit IN_DSCR_ERR_INT_CLR.
	I2S_INT_CLR_IN_DSCR_ERR_INT_CLR = 0x2000
	// Position of OUT_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_OUT_DSCR_ERR_INT_CLR_Pos = 0xe
	// Bit mask of OUT_DSCR_ERR_INT_CLR field.
	I2S_INT_CLR_OUT_DSCR_ERR_INT_CLR_Msk = 0x4000
	// Bit OUT_DSCR_ERR_INT_CLR.
	I2S_INT_CLR_OUT_DSCR_ERR_INT_CLR = 0x4000
	// Position of IN_DSCR_EMPTY_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Pos = 0xf
	// Bit mask of IN_DSCR_EMPTY_INT_CLR field.
	I2S_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Msk = 0x8000
	// Bit IN_DSCR_EMPTY_INT_CLR.
	I2S_INT_CLR_IN_DSCR_EMPTY_INT_CLR = 0x8000
	// Position of OUT_TOTAL_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Pos = 0x10
	// Bit mask of OUT_TOTAL_EOF_INT_CLR field.
	I2S_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Msk = 0x10000
	// Bit OUT_TOTAL_EOF_INT_CLR.
	I2S_INT_CLR_OUT_TOTAL_EOF_INT_CLR = 0x10000
	// Position of V_SYNC_INT_CLR field.
	I2S_INT_CLR_V_SYNC_INT_CLR_Pos = 0x11
	// Bit mask of V_SYNC_INT_CLR field.
	I2S_INT_CLR_V_SYNC_INT_CLR_Msk = 0x20000
	// Bit V_SYNC_INT_CLR.
	I2S_INT_CLR_V_SYNC_INT_CLR = 0x20000

	// TIMING: I2S timing register
	// Position of TX_BCK_IN_DELAY field.
	I2S_TIMING_TX_BCK_IN_DELAY_Pos = 0x0
	// Bit mask of TX_BCK_IN_DELAY field.
	I2S_TIMING_TX_BCK_IN_DELAY_Msk = 0x3
	// Position of TX_WS_IN_DELAY field.
	I2S_TIMING_TX_WS_IN_DELAY_Pos = 0x2
	// Bit mask of TX_WS_IN_DELAY field.
	I2S_TIMING_TX_WS_IN_DELAY_Msk = 0xc
	// Position of RX_BCK_IN_DELAY field.
	I2S_TIMING_RX_BCK_IN_DELAY_Pos = 0x4
	// Bit mask of RX_BCK_IN_DELAY field.
	I2S_TIMING_RX_BCK_IN_DELAY_Msk = 0x30
	// Position of RX_WS_IN_DELAY field.
	I2S_TIMING_RX_WS_IN_DELAY_Pos = 0x6
	// Bit mask of RX_WS_IN_DELAY field.
	I2S_TIMING_RX_WS_IN_DELAY_Msk = 0xc0
	// Position of RX_SD_IN_DELAY field.
	I2S_TIMING_RX_SD_IN_DELAY_Pos = 0x8
	// Bit mask of RX_SD_IN_DELAY field.
	I2S_TIMING_RX_SD_IN_DELAY_Msk = 0x300
	// Position of TX_BCK_OUT_DELAY field.
	I2S_TIMING_TX_BCK_OUT_DELAY_Pos = 0xa
	// Bit mask of TX_BCK_OUT_DELAY field.
	I2S_TIMING_TX_BCK_OUT_DELAY_Msk = 0xc00
	// Position of TX_WS_OUT_DELAY field.
	I2S_TIMING_TX_WS_OUT_DELAY_Pos = 0xc
	// Bit mask of TX_WS_OUT_DELAY field.
	I2S_TIMING_TX_WS_OUT_DELAY_Msk = 0x3000
	// Position of TX_SD_OUT_DELAY field.
	I2S_TIMING_TX_SD_OUT_DELAY_Pos = 0xe
	// Bit mask of TX_SD_OUT_DELAY field.
	I2S_TIMING_TX_SD_OUT_DELAY_Msk = 0xc000
	// Position of RX_WS_OUT_DELAY field.
	I2S_TIMING_RX_WS_OUT_DELAY_Pos = 0x10
	// Bit mask of RX_WS_OUT_DELAY field.
	I2S_TIMING_RX_WS_OUT_DELAY_Msk = 0x30000
	// Position of RX_BCK_OUT_DELAY field.
	I2S_TIMING_RX_BCK_OUT_DELAY_Pos = 0x12
	// Bit mask of RX_BCK_OUT_DELAY field.
	I2S_TIMING_RX_BCK_OUT_DELAY_Msk = 0xc0000
	// Position of TX_DSYNC_SW field.
	I2S_TIMING_TX_DSYNC_SW_Pos = 0x14
	// Bit mask of TX_DSYNC_SW field.
	I2S_TIMING_TX_DSYNC_SW_Msk = 0x100000
	// Bit TX_DSYNC_SW.
	I2S_TIMING_TX_DSYNC_SW = 0x100000
	// Position of RX_DSYNC_SW field.
	I2S_TIMING_RX_DSYNC_SW_Pos = 0x15
	// Bit mask of RX_DSYNC_SW field.
	I2S_TIMING_RX_DSYNC_SW_Msk = 0x200000
	// Bit RX_DSYNC_SW.
	I2S_TIMING_RX_DSYNC_SW = 0x200000
	// Position of DATA_ENABLE_DELAY field.
	I2S_TIMING_DATA_ENABLE_DELAY_Pos = 0x16
	// Bit mask of DATA_ENABLE_DELAY field.
	I2S_TIMING_DATA_ENABLE_DELAY_Msk = 0xc00000
	// Position of TX_BCK_IN_INV field.
	I2S_TIMING_TX_BCK_IN_INV_Pos = 0x18
	// Bit mask of TX_BCK_IN_INV field.
	I2S_TIMING_TX_BCK_IN_INV_Msk = 0x1000000
	// Bit TX_BCK_IN_INV.
	I2S_TIMING_TX_BCK_IN_INV = 0x1000000

	// FIFO_CONF: I2S FIFO configuration register
	// Position of RX_DATA_NUM field.
	I2S_FIFO_CONF_RX_DATA_NUM_Pos = 0x0
	// Bit mask of RX_DATA_NUM field.
	I2S_FIFO_CONF_RX_DATA_NUM_Msk = 0x3f
	// Position of TX_DATA_NUM field.
	I2S_FIFO_CONF_TX_DATA_NUM_Pos = 0x6
	// Bit mask of TX_DATA_NUM field.
	I2S_FIFO_CONF_TX_DATA_NUM_Msk = 0xfc0
	// Position of DSCR_EN field.
	I2S_FIFO_CONF_DSCR_EN_Pos = 0xc
	// Bit mask of DSCR_EN field.
	I2S_FIFO_CONF_DSCR_EN_Msk = 0x1000
	// Bit DSCR_EN.
	I2S_FIFO_CONF_DSCR_EN = 0x1000
	// Position of TX_FIFO_MOD field.
	I2S_FIFO_CONF_TX_FIFO_MOD_Pos = 0xd
	// Bit mask of TX_FIFO_MOD field.
	I2S_FIFO_CONF_TX_FIFO_MOD_Msk = 0xe000
	// Position of RX_FIFO_MOD field.
	I2S_FIFO_CONF_RX_FIFO_MOD_Pos = 0x10
	// Bit mask of RX_FIFO_MOD field.
	I2S_FIFO_CONF_RX_FIFO_MOD_Msk = 0x70000
	// Position of TX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_TX_FIFO_MOD_FORCE_EN_Pos = 0x13
	// Bit mask of TX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_TX_FIFO_MOD_FORCE_EN_Msk = 0x80000
	// Bit TX_FIFO_MOD_FORCE_EN.
	I2S_FIFO_CONF_TX_FIFO_MOD_FORCE_EN = 0x80000
	// Position of RX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_RX_FIFO_MOD_FORCE_EN_Pos = 0x14
	// Bit mask of RX_FIFO_MOD_FORCE_EN field.
	I2S_FIFO_CONF_RX_FIFO_MOD_FORCE_EN_Msk = 0x100000
	// Bit RX_FIFO_MOD_FORCE_EN.
	I2S_FIFO_CONF_RX_FIFO_MOD_FORCE_EN = 0x100000
	// Position of RX_FIFO_SYNC field.
	I2S_FIFO_CONF_RX_FIFO_SYNC_Pos = 0x15
	// Bit mask of RX_FIFO_SYNC field.
	I2S_FIFO_CONF_RX_FIFO_SYNC_Msk = 0x200000
	// Bit RX_FIFO_SYNC.
	I2S_FIFO_CONF_RX_FIFO_SYNC = 0x200000
	// Position of RX_24MSB_EN field.
	I2S_FIFO_CONF_RX_24MSB_EN_Pos = 0x16
	// Bit mask of RX_24MSB_EN field.
	I2S_FIFO_CONF_RX_24MSB_EN_Msk = 0x400000
	// Bit RX_24MSB_EN.
	I2S_FIFO_CONF_RX_24MSB_EN = 0x400000
	// Position of TX_24MSB_EN field.
	I2S_FIFO_CONF_TX_24MSB_EN_Pos = 0x17
	// Bit mask of TX_24MSB_EN field.
	I2S_FIFO_CONF_TX_24MSB_EN_Msk = 0x800000
	// Bit TX_24MSB_EN.
	I2S_FIFO_CONF_TX_24MSB_EN = 0x800000

	// RXEOF_NUM: I2S DMA RX EOF data length
	// Position of RX_EOF_NUM field.
	I2S_RXEOF_NUM_RX_EOF_NUM_Pos = 0x0
	// Bit mask of RX_EOF_NUM field.
	I2S_RXEOF_NUM_RX_EOF_NUM_Msk = 0xffffffff

	// CONF_SIGLE_DATA: Constant single channel data
	// Position of SIGLE_DATA field.
	I2S_CONF_SIGLE_DATA_SIGLE_DATA_Pos = 0x0
	// Bit mask of SIGLE_DATA field.
	I2S_CONF_SIGLE_DATA_SIGLE_DATA_Msk = 0xffffffff

	// CONF_CHAN: I2S channel configuration register
	// Position of TX_CHAN_MOD field.
	I2S_CONF_CHAN_TX_CHAN_MOD_Pos = 0x0
	// Bit mask of TX_CHAN_MOD field.
	I2S_CONF_CHAN_TX_CHAN_MOD_Msk = 0x7
	// Position of RX_CHAN_MOD field.
	I2S_CONF_CHAN_RX_CHAN_MOD_Pos = 0x3
	// Bit mask of RX_CHAN_MOD field.
	I2S_CONF_CHAN_RX_CHAN_MOD_Msk = 0x18

	// OUT_LINK: I2S DMA TX configuration register
	// Position of OUTLINK_ADDR field.
	I2S_OUT_LINK_OUTLINK_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_ADDR field.
	I2S_OUT_LINK_OUTLINK_ADDR_Msk = 0xfffff
	// Position of OUTLINK_STOP field.
	I2S_OUT_LINK_OUTLINK_STOP_Pos = 0x1c
	// Bit mask of OUTLINK_STOP field.
	I2S_OUT_LINK_OUTLINK_STOP_Msk = 0x10000000
	// Bit OUTLINK_STOP.
	I2S_OUT_LINK_OUTLINK_STOP = 0x10000000
	// Position of OUTLINK_START field.
	I2S_OUT_LINK_OUTLINK_START_Pos = 0x1d
	// Bit mask of OUTLINK_START field.
	I2S_OUT_LINK_OUTLINK_START_Msk = 0x20000000
	// Bit OUTLINK_START.
	I2S_OUT_LINK_OUTLINK_START = 0x20000000
	// Position of OUTLINK_RESTART field.
	I2S_OUT_LINK_OUTLINK_RESTART_Pos = 0x1e
	// Bit mask of OUTLINK_RESTART field.
	I2S_OUT_LINK_OUTLINK_RESTART_Msk = 0x40000000
	// Bit OUTLINK_RESTART.
	I2S_OUT_LINK_OUTLINK_RESTART = 0x40000000
	// Position of OUTLINK_PARK field.
	I2S_OUT_LINK_OUTLINK_PARK_Pos = 0x1f
	// Bit mask of OUTLINK_PARK field.
	I2S_OUT_LINK_OUTLINK_PARK_Msk = 0x80000000
	// Bit OUTLINK_PARK.
	I2S_OUT_LINK_OUTLINK_PARK = 0x80000000

	// IN_LINK: I2S DMA RX configuration register
	// Position of INLINK_ADDR field.
	I2S_IN_LINK_INLINK_ADDR_Pos = 0x0
	// Bit mask of INLINK_ADDR field.
	I2S_IN_LINK_INLINK_ADDR_Msk = 0xfffff
	// Position of INLINK_STOP field.
	I2S_IN_LINK_INLINK_STOP_Pos = 0x1c
	// Bit mask of INLINK_STOP field.
	I2S_IN_LINK_INLINK_STOP_Msk = 0x10000000
	// Bit INLINK_STOP.
	I2S_IN_LINK_INLINK_STOP = 0x10000000
	// Position of INLINK_START field.
	I2S_IN_LINK_INLINK_START_Pos = 0x1d
	// Bit mask of INLINK_START field.
	I2S_IN_LINK_INLINK_START_Msk = 0x20000000
	// Bit INLINK_START.
	I2S_IN_LINK_INLINK_START = 0x20000000
	// Position of INLINK_RESTART field.
	I2S_IN_LINK_INLINK_RESTART_Pos = 0x1e
	// Bit mask of INLINK_RESTART field.
	I2S_IN_LINK_INLINK_RESTART_Msk = 0x40000000
	// Bit INLINK_RESTART.
	I2S_IN_LINK_INLINK_RESTART = 0x40000000
	// Position of INLINK_PARK field.
	I2S_IN_LINK_INLINK_PARK_Pos = 0x1f
	// Bit mask of INLINK_PARK field.
	I2S_IN_LINK_INLINK_PARK_Msk = 0x80000000
	// Bit INLINK_PARK.
	I2S_IN_LINK_INLINK_PARK = 0x80000000

	// OUT_EOF_DES_ADDR: Address of outlink descriptor that produces EOF
	// Position of OUT_EOF_DES_ADDR field.
	I2S_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_DES_ADDR field.
	I2S_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Msk = 0xffffffff

	// IN_EOF_DES_ADDR: Address of inlink descriptor that produces EOF
	// Position of IN_SUC_EOF_DES_ADDR field.
	I2S_IN_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_SUC_EOF_DES_ADDR field.
	I2S_IN_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Msk = 0xffffffff

	// OUT_EOF_BFR_DES_ADDR: Address of buffer relative to the outlink descriptor that produces EOF
	// Position of OUT_EOF_BFR_DES_ADDR field.
	I2S_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_BFR_DES_ADDR field.
	I2S_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Msk = 0xffffffff

	// INLINK_DSCR: Address of current inlink descriptor
	// Position of INLINK_DSCR field.
	I2S_INLINK_DSCR_INLINK_DSCR_Pos = 0x0
	// Bit mask of INLINK_DSCR field.
	I2S_INLINK_DSCR_INLINK_DSCR_Msk = 0xffffffff

	// INLINK_DSCR_BF0: Address of next inlink descriptor
	// Position of INLINK_DSCR_BF0 field.
	I2S_INLINK_DSCR_BF0_INLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF0 field.
	I2S_INLINK_DSCR_BF0_INLINK_DSCR_BF0_Msk = 0xffffffff

	// INLINK_DSCR_BF1: Address of next inlink data buffer
	// Position of INLINK_DSCR_BF1 field.
	I2S_INLINK_DSCR_BF1_INLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF1 field.
	I2S_INLINK_DSCR_BF1_INLINK_DSCR_BF1_Msk = 0xffffffff

	// OUTLINK_DSCR: Address of current outlink descriptor
	// Position of OUTLINK_DSCR field.
	I2S_OUTLINK_DSCR_OUTLINK_DSCR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR field.
	I2S_OUTLINK_DSCR_OUTLINK_DSCR_Msk = 0xffffffff

	// OUTLINK_DSCR_BF0: Address of next outlink descriptor
	// Position of OUTLINK_DSCR_BF0 field.
	I2S_OUTLINK_DSCR_BF0_OUTLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF0 field.
	I2S_OUTLINK_DSCR_BF0_OUTLINK_DSCR_BF0_Msk = 0xffffffff

	// OUTLINK_DSCR_BF1: Address of next outlink data buffer
	// Position of OUTLINK_DSCR_BF1 field.
	I2S_OUTLINK_DSCR_BF1_OUTLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF1 field.
	I2S_OUTLINK_DSCR_BF1_OUTLINK_DSCR_BF1_Msk = 0xffffffff

	// LC_CONF: I2S DMA configuration register
	// Position of IN_RST field.
	I2S_LC_CONF_IN_RST_Pos = 0x0
	// Bit mask of IN_RST field.
	I2S_LC_CONF_IN_RST_Msk = 0x1
	// Bit IN_RST.
	I2S_LC_CONF_IN_RST = 0x1
	// Position of OUT_RST field.
	I2S_LC_CONF_OUT_RST_Pos = 0x1
	// Bit mask of OUT_RST field.
	I2S_LC_CONF_OUT_RST_Msk = 0x2
	// Bit OUT_RST.
	I2S_LC_CONF_OUT_RST = 0x2
	// Position of AHBM_FIFO_RST field.
	I2S_LC_CONF_AHBM_FIFO_RST_Pos = 0x2
	// Bit mask of AHBM_FIFO_RST field.
	I2S_LC_CONF_AHBM_FIFO_RST_Msk = 0x4
	// Bit AHBM_FIFO_RST.
	I2S_LC_CONF_AHBM_FIFO_RST = 0x4
	// Position of AHBM_RST field.
	I2S_LC_CONF_AHBM_RST_Pos = 0x3
	// Bit mask of AHBM_RST field.
	I2S_LC_CONF_AHBM_RST_Msk = 0x8
	// Bit AHBM_RST.
	I2S_LC_CONF_AHBM_RST = 0x8
	// Position of OUT_LOOP_TEST field.
	I2S_LC_CONF_OUT_LOOP_TEST_Pos = 0x4
	// Bit mask of OUT_LOOP_TEST field.
	I2S_LC_CONF_OUT_LOOP_TEST_Msk = 0x10
	// Bit OUT_LOOP_TEST.
	I2S_LC_CONF_OUT_LOOP_TEST = 0x10
	// Position of IN_LOOP_TEST field.
	I2S_LC_CONF_IN_LOOP_TEST_Pos = 0x5
	// Bit mask of IN_LOOP_TEST field.
	I2S_LC_CONF_IN_LOOP_TEST_Msk = 0x20
	// Bit IN_LOOP_TEST.
	I2S_LC_CONF_IN_LOOP_TEST = 0x20
	// Position of OUT_AUTO_WRBACK field.
	I2S_LC_CONF_OUT_AUTO_WRBACK_Pos = 0x6
	// Bit mask of OUT_AUTO_WRBACK field.
	I2S_LC_CONF_OUT_AUTO_WRBACK_Msk = 0x40
	// Bit OUT_AUTO_WRBACK.
	I2S_LC_CONF_OUT_AUTO_WRBACK = 0x40
	// Position of OUT_NO_RESTART_CLR field.
	I2S_LC_CONF_OUT_NO_RESTART_CLR_Pos = 0x7
	// Bit mask of OUT_NO_RESTART_CLR field.
	I2S_LC_CONF_OUT_NO_RESTART_CLR_Msk = 0x80
	// Bit OUT_NO_RESTART_CLR.
	I2S_LC_CONF_OUT_NO_RESTART_CLR = 0x80
	// Position of OUT_EOF_MODE field.
	I2S_LC_CONF_OUT_EOF_MODE_Pos = 0x8
	// Bit mask of OUT_EOF_MODE field.
	I2S_LC_CONF_OUT_EOF_MODE_Msk = 0x100
	// Bit OUT_EOF_MODE.
	I2S_LC_CONF_OUT_EOF_MODE = 0x100
	// Position of OUTDSCR_BURST_EN field.
	I2S_LC_CONF_OUTDSCR_BURST_EN_Pos = 0x9
	// Bit mask of OUTDSCR_BURST_EN field.
	I2S_LC_CONF_OUTDSCR_BURST_EN_Msk = 0x200
	// Bit OUTDSCR_BURST_EN.
	I2S_LC_CONF_OUTDSCR_BURST_EN = 0x200
	// Position of INDSCR_BURST_EN field.
	I2S_LC_CONF_INDSCR_BURST_EN_Pos = 0xa
	// Bit mask of INDSCR_BURST_EN field.
	I2S_LC_CONF_INDSCR_BURST_EN_Msk = 0x400
	// Bit INDSCR_BURST_EN.
	I2S_LC_CONF_INDSCR_BURST_EN = 0x400
	// Position of OUT_DATA_BURST_EN field.
	I2S_LC_CONF_OUT_DATA_BURST_EN_Pos = 0xb
	// Bit mask of OUT_DATA_BURST_EN field.
	I2S_LC_CONF_OUT_DATA_BURST_EN_Msk = 0x800
	// Bit OUT_DATA_BURST_EN.
	I2S_LC_CONF_OUT_DATA_BURST_EN = 0x800
	// Position of CHECK_OWNER field.
	I2S_LC_CONF_CHECK_OWNER_Pos = 0xc
	// Bit mask of CHECK_OWNER field.
	I2S_LC_CONF_CHECK_OWNER_Msk = 0x1000
	// Bit CHECK_OWNER.
	I2S_LC_CONF_CHECK_OWNER = 0x1000
	// Position of MEM_TRANS_EN field.
	I2S_LC_CONF_MEM_TRANS_EN_Pos = 0xd
	// Bit mask of MEM_TRANS_EN field.
	I2S_LC_CONF_MEM_TRANS_EN_Msk = 0x2000
	// Bit MEM_TRANS_EN.
	I2S_LC_CONF_MEM_TRANS_EN = 0x2000
	// Position of EXT_MEM_BK_SIZE field.
	I2S_LC_CONF_EXT_MEM_BK_SIZE_Pos = 0xe
	// Bit mask of EXT_MEM_BK_SIZE field.
	I2S_LC_CONF_EXT_MEM_BK_SIZE_Msk = 0xc000

	// OUTFIFO_PUSH: APB out FIFO mode register
	// Position of OUTFIFO_WDATA field.
	I2S_OUTFIFO_PUSH_OUTFIFO_WDATA_Pos = 0x0
	// Bit mask of OUTFIFO_WDATA field.
	I2S_OUTFIFO_PUSH_OUTFIFO_WDATA_Msk = 0x1ff
	// Position of OUTFIFO_PUSH field.
	I2S_OUTFIFO_PUSH_OUTFIFO_PUSH_Pos = 0x10
	// Bit mask of OUTFIFO_PUSH field.
	I2S_OUTFIFO_PUSH_OUTFIFO_PUSH_Msk = 0x10000
	// Bit OUTFIFO_PUSH.
	I2S_OUTFIFO_PUSH_OUTFIFO_PUSH = 0x10000

	// INFIFO_POP: APB in FIFO mode register
	// Position of INFIFO_RDATA field.
	I2S_INFIFO_POP_INFIFO_RDATA_Pos = 0x0
	// Bit mask of INFIFO_RDATA field.
	I2S_INFIFO_POP_INFIFO_RDATA_Msk = 0xfff
	// Position of INFIFO_POP field.
	I2S_INFIFO_POP_INFIFO_POP_Pos = 0x10
	// Bit mask of INFIFO_POP field.
	I2S_INFIFO_POP_INFIFO_POP_Msk = 0x10000
	// Bit INFIFO_POP.
	I2S_INFIFO_POP_INFIFO_POP = 0x10000

	// LC_STATE0: I2S DMA TX status
	// Position of OUTLINK_DSCR_ADDR field.
	I2S_LC_STATE0_OUTLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_ADDR field.
	I2S_LC_STATE0_OUTLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of OUT_DSCR_STATE field.
	I2S_LC_STATE0_OUT_DSCR_STATE_Pos = 0x12
	// Bit mask of OUT_DSCR_STATE field.
	I2S_LC_STATE0_OUT_DSCR_STATE_Msk = 0xc0000
	// Position of OUT_STATE field.
	I2S_LC_STATE0_OUT_STATE_Pos = 0x14
	// Bit mask of OUT_STATE field.
	I2S_LC_STATE0_OUT_STATE_Msk = 0x700000
	// Position of OUTFIFO_CNT field.
	I2S_LC_STATE0_OUTFIFO_CNT_Pos = 0x17
	// Bit mask of OUTFIFO_CNT field.
	I2S_LC_STATE0_OUTFIFO_CNT_Msk = 0x3f800000
	// Position of OUT_FULL field.
	I2S_LC_STATE0_OUT_FULL_Pos = 0x1e
	// Bit mask of OUT_FULL field.
	I2S_LC_STATE0_OUT_FULL_Msk = 0x40000000
	// Bit OUT_FULL.
	I2S_LC_STATE0_OUT_FULL = 0x40000000
	// Position of OUT_EMPTY field.
	I2S_LC_STATE0_OUT_EMPTY_Pos = 0x1f
	// Bit mask of OUT_EMPTY field.
	I2S_LC_STATE0_OUT_EMPTY_Msk = 0x80000000
	// Bit OUT_EMPTY.
	I2S_LC_STATE0_OUT_EMPTY = 0x80000000

	// LC_STATE1: I2S DMA RX status
	// Position of INLINK_DSCR_ADDR field.
	I2S_LC_STATE1_INLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of INLINK_DSCR_ADDR field.
	I2S_LC_STATE1_INLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of IN_DSCR_STATE field.
	I2S_LC_STATE1_IN_DSCR_STATE_Pos = 0x12
	// Bit mask of IN_DSCR_STATE field.
	I2S_LC_STATE1_IN_DSCR_STATE_Msk = 0xc0000
	// Position of IN_STATE field.
	I2S_LC_STATE1_IN_STATE_Pos = 0x14
	// Bit mask of IN_STATE field.
	I2S_LC_STATE1_IN_STATE_Msk = 0x700000
	// Position of INFIFO_CNT_DEBUG field.
	I2S_LC_STATE1_INFIFO_CNT_DEBUG_Pos = 0x17
	// Bit mask of INFIFO_CNT_DEBUG field.
	I2S_LC_STATE1_INFIFO_CNT_DEBUG_Msk = 0x3f800000
	// Position of IN_FULL field.
	I2S_LC_STATE1_IN_FULL_Pos = 0x1e
	// Bit mask of IN_FULL field.
	I2S_LC_STATE1_IN_FULL_Msk = 0x40000000
	// Bit IN_FULL.
	I2S_LC_STATE1_IN_FULL = 0x40000000
	// Position of IN_EMPTY field.
	I2S_LC_STATE1_IN_EMPTY_Pos = 0x1f
	// Bit mask of IN_EMPTY field.
	I2S_LC_STATE1_IN_EMPTY_Msk = 0x80000000
	// Bit IN_EMPTY.
	I2S_LC_STATE1_IN_EMPTY = 0x80000000

	// LC_HUNG_CONF: I2S Hung configuration register
	// Position of LC_FIFO_TIMEOUT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_Pos = 0x0
	// Bit mask of LC_FIFO_TIMEOUT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_Msk = 0xff
	// Position of LC_FIFO_TIMEOUT_SHIFT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT_Pos = 0x8
	// Bit mask of LC_FIFO_TIMEOUT_SHIFT field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_SHIFT_Msk = 0x700
	// Position of LC_FIFO_TIMEOUT_ENA field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA_Pos = 0xb
	// Bit mask of LC_FIFO_TIMEOUT_ENA field.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA_Msk = 0x800
	// Bit LC_FIFO_TIMEOUT_ENA.
	I2S_LC_HUNG_CONF_LC_FIFO_TIMEOUT_ENA = 0x800

	// CONF1: I2S configuration register 1
	// Position of TX_PCM_CONF field.
	I2S_CONF1_TX_PCM_CONF_Pos = 0x0
	// Bit mask of TX_PCM_CONF field.
	I2S_CONF1_TX_PCM_CONF_Msk = 0x7
	// Position of TX_PCM_BYPASS field.
	I2S_CONF1_TX_PCM_BYPASS_Pos = 0x3
	// Bit mask of TX_PCM_BYPASS field.
	I2S_CONF1_TX_PCM_BYPASS_Msk = 0x8
	// Bit TX_PCM_BYPASS.
	I2S_CONF1_TX_PCM_BYPASS = 0x8
	// Position of RX_PCM_CONF field.
	I2S_CONF1_RX_PCM_CONF_Pos = 0x4
	// Bit mask of RX_PCM_CONF field.
	I2S_CONF1_RX_PCM_CONF_Msk = 0x70
	// Position of RX_PCM_BYPASS field.
	I2S_CONF1_RX_PCM_BYPASS_Pos = 0x7
	// Bit mask of RX_PCM_BYPASS field.
	I2S_CONF1_RX_PCM_BYPASS_Msk = 0x80
	// Bit RX_PCM_BYPASS.
	I2S_CONF1_RX_PCM_BYPASS = 0x80
	// Position of TX_STOP_EN field.
	I2S_CONF1_TX_STOP_EN_Pos = 0x8
	// Bit mask of TX_STOP_EN field.
	I2S_CONF1_TX_STOP_EN_Msk = 0x100
	// Bit TX_STOP_EN.
	I2S_CONF1_TX_STOP_EN = 0x100
	// Position of TX_ZEROS_RM_EN field.
	I2S_CONF1_TX_ZEROS_RM_EN_Pos = 0x9
	// Bit mask of TX_ZEROS_RM_EN field.
	I2S_CONF1_TX_ZEROS_RM_EN_Msk = 0x200
	// Bit TX_ZEROS_RM_EN.
	I2S_CONF1_TX_ZEROS_RM_EN = 0x200

	// PD_CONF: I2S power-down configuration register
	// Position of FIFO_FORCE_PD field.
	I2S_PD_CONF_FIFO_FORCE_PD_Pos = 0x0
	// Bit mask of FIFO_FORCE_PD field.
	I2S_PD_CONF_FIFO_FORCE_PD_Msk = 0x1
	// Bit FIFO_FORCE_PD.
	I2S_PD_CONF_FIFO_FORCE_PD = 0x1
	// Position of FIFO_FORCE_PU field.
	I2S_PD_CONF_FIFO_FORCE_PU_Pos = 0x1
	// Bit mask of FIFO_FORCE_PU field.
	I2S_PD_CONF_FIFO_FORCE_PU_Msk = 0x2
	// Bit FIFO_FORCE_PU.
	I2S_PD_CONF_FIFO_FORCE_PU = 0x2
	// Position of PLC_MEM_FORCE_PD field.
	I2S_PD_CONF_PLC_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of PLC_MEM_FORCE_PD field.
	I2S_PD_CONF_PLC_MEM_FORCE_PD_Msk = 0x4
	// Bit PLC_MEM_FORCE_PD.
	I2S_PD_CONF_PLC_MEM_FORCE_PD = 0x4
	// Position of PLC_MEM_FORCE_PU field.
	I2S_PD_CONF_PLC_MEM_FORCE_PU_Pos = 0x3
	// Bit mask of PLC_MEM_FORCE_PU field.
	I2S_PD_CONF_PLC_MEM_FORCE_PU_Msk = 0x8
	// Bit PLC_MEM_FORCE_PU.
	I2S_PD_CONF_PLC_MEM_FORCE_PU = 0x8
	// Position of DMA_RAM_FORCE_PD field.
	I2S_PD_CONF_DMA_RAM_FORCE_PD_Pos = 0x4
	// Bit mask of DMA_RAM_FORCE_PD field.
	I2S_PD_CONF_DMA_RAM_FORCE_PD_Msk = 0x10
	// Bit DMA_RAM_FORCE_PD.
	I2S_PD_CONF_DMA_RAM_FORCE_PD = 0x10
	// Position of DMA_RAM_FORCE_PU field.
	I2S_PD_CONF_DMA_RAM_FORCE_PU_Pos = 0x5
	// Bit mask of DMA_RAM_FORCE_PU field.
	I2S_PD_CONF_DMA_RAM_FORCE_PU_Msk = 0x20
	// Bit DMA_RAM_FORCE_PU.
	I2S_PD_CONF_DMA_RAM_FORCE_PU = 0x20
	// Position of DMA_RAM_CLK_FO field.
	I2S_PD_CONF_DMA_RAM_CLK_FO_Pos = 0x6
	// Bit mask of DMA_RAM_CLK_FO field.
	I2S_PD_CONF_DMA_RAM_CLK_FO_Msk = 0x40
	// Bit DMA_RAM_CLK_FO.
	I2S_PD_CONF_DMA_RAM_CLK_FO = 0x40

	// CONF2: I2S configuration register 2
	// Position of CAMERA_EN field.
	I2S_CONF2_CAMERA_EN_Pos = 0x0
	// Bit mask of CAMERA_EN field.
	I2S_CONF2_CAMERA_EN_Msk = 0x1
	// Bit CAMERA_EN.
	I2S_CONF2_CAMERA_EN = 0x1
	// Position of LCD_TX_WRX2_EN field.
	I2S_CONF2_LCD_TX_WRX2_EN_Pos = 0x1
	// Bit mask of LCD_TX_WRX2_EN field.
	I2S_CONF2_LCD_TX_WRX2_EN_Msk = 0x2
	// Bit LCD_TX_WRX2_EN.
	I2S_CONF2_LCD_TX_WRX2_EN = 0x2
	// Position of LCD_TX_SDX2_EN field.
	I2S_CONF2_LCD_TX_SDX2_EN_Pos = 0x2
	// Bit mask of LCD_TX_SDX2_EN field.
	I2S_CONF2_LCD_TX_SDX2_EN_Msk = 0x4
	// Bit LCD_TX_SDX2_EN.
	I2S_CONF2_LCD_TX_SDX2_EN = 0x4
	// Position of DATA_ENABLE_TEST_EN field.
	I2S_CONF2_DATA_ENABLE_TEST_EN_Pos = 0x3
	// Bit mask of DATA_ENABLE_TEST_EN field.
	I2S_CONF2_DATA_ENABLE_TEST_EN_Msk = 0x8
	// Bit DATA_ENABLE_TEST_EN.
	I2S_CONF2_DATA_ENABLE_TEST_EN = 0x8
	// Position of DATA_ENABLE field.
	I2S_CONF2_DATA_ENABLE_Pos = 0x4
	// Bit mask of DATA_ENABLE field.
	I2S_CONF2_DATA_ENABLE_Msk = 0x10
	// Bit DATA_ENABLE.
	I2S_CONF2_DATA_ENABLE = 0x10
	// Position of LCD_EN field.
	I2S_CONF2_LCD_EN_Pos = 0x5
	// Bit mask of LCD_EN field.
	I2S_CONF2_LCD_EN_Msk = 0x20
	// Bit LCD_EN.
	I2S_CONF2_LCD_EN = 0x20
	// Position of EXT_ADC_START_EN field.
	I2S_CONF2_EXT_ADC_START_EN_Pos = 0x6
	// Bit mask of EXT_ADC_START_EN field.
	I2S_CONF2_EXT_ADC_START_EN_Msk = 0x40
	// Bit EXT_ADC_START_EN.
	I2S_CONF2_EXT_ADC_START_EN = 0x40
	// Position of INTER_VALID_EN field.
	I2S_CONF2_INTER_VALID_EN_Pos = 0x7
	// Bit mask of INTER_VALID_EN field.
	I2S_CONF2_INTER_VALID_EN_Msk = 0x80
	// Bit INTER_VALID_EN.
	I2S_CONF2_INTER_VALID_EN = 0x80
	// Position of CAM_SYNC_FIFO_RESET field.
	I2S_CONF2_CAM_SYNC_FIFO_RESET_Pos = 0x8
	// Bit mask of CAM_SYNC_FIFO_RESET field.
	I2S_CONF2_CAM_SYNC_FIFO_RESET_Msk = 0x100
	// Bit CAM_SYNC_FIFO_RESET.
	I2S_CONF2_CAM_SYNC_FIFO_RESET = 0x100
	// Position of CAM_CLK_LOOPBACK field.
	I2S_CONF2_CAM_CLK_LOOPBACK_Pos = 0x9
	// Bit mask of CAM_CLK_LOOPBACK field.
	I2S_CONF2_CAM_CLK_LOOPBACK_Msk = 0x200
	// Bit CAM_CLK_LOOPBACK.
	I2S_CONF2_CAM_CLK_LOOPBACK = 0x200
	// Position of VSYNC_FILTER_EN field.
	I2S_CONF2_VSYNC_FILTER_EN_Pos = 0xa
	// Bit mask of VSYNC_FILTER_EN field.
	I2S_CONF2_VSYNC_FILTER_EN_Msk = 0x400
	// Bit VSYNC_FILTER_EN.
	I2S_CONF2_VSYNC_FILTER_EN = 0x400
	// Position of VSYNC_FILTER_THRES field.
	I2S_CONF2_VSYNC_FILTER_THRES_Pos = 0xb
	// Bit mask of VSYNC_FILTER_THRES field.
	I2S_CONF2_VSYNC_FILTER_THRES_Msk = 0x3800

	// CLKM_CONF: I2S module clock configuration register
	// Position of CLKM_DIV_NUM field.
	I2S_CLKM_CONF_CLKM_DIV_NUM_Pos = 0x0
	// Bit mask of CLKM_DIV_NUM field.
	I2S_CLKM_CONF_CLKM_DIV_NUM_Msk = 0xff
	// Position of CLKM_DIV_B field.
	I2S_CLKM_CONF_CLKM_DIV_B_Pos = 0x8
	// Bit mask of CLKM_DIV_B field.
	I2S_CLKM_CONF_CLKM_DIV_B_Msk = 0x3f00
	// Position of CLKM_DIV_A field.
	I2S_CLKM_CONF_CLKM_DIV_A_Pos = 0xe
	// Bit mask of CLKM_DIV_A field.
	I2S_CLKM_CONF_CLKM_DIV_A_Msk = 0xfc000
	// Position of CLK_EN field.
	I2S_CLKM_CONF_CLK_EN_Pos = 0x14
	// Bit mask of CLK_EN field.
	I2S_CLKM_CONF_CLK_EN_Msk = 0x100000
	// Bit CLK_EN.
	I2S_CLKM_CONF_CLK_EN = 0x100000
	// Position of CLK_SEL field.
	I2S_CLKM_CONF_CLK_SEL_Pos = 0x15
	// Bit mask of CLK_SEL field.
	I2S_CLKM_CONF_CLK_SEL_Msk = 0x600000

	// SAMPLE_RATE_CONF: I2S sample rate register
	// Position of TX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_TX_BCK_DIV_NUM_Pos = 0x0
	// Bit mask of TX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_TX_BCK_DIV_NUM_Msk = 0x3f
	// Position of RX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_RX_BCK_DIV_NUM_Pos = 0x6
	// Bit mask of RX_BCK_DIV_NUM field.
	I2S_SAMPLE_RATE_CONF_RX_BCK_DIV_NUM_Msk = 0xfc0
	// Position of TX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_TX_BITS_MOD_Pos = 0xc
	// Bit mask of TX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_TX_BITS_MOD_Msk = 0x3f000
	// Position of RX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_RX_BITS_MOD_Pos = 0x12
	// Bit mask of RX_BITS_MOD field.
	I2S_SAMPLE_RATE_CONF_RX_BITS_MOD_Msk = 0xfc0000

	// STATE: I2S TX status register
	// Position of TX_IDLE field.
	I2S_STATE_TX_IDLE_Pos = 0x0
	// Bit mask of TX_IDLE field.
	I2S_STATE_TX_IDLE_Msk = 0x1
	// Bit TX_IDLE.
	I2S_STATE_TX_IDLE = 0x1

	// DATE: Version control register
	// Position of DATE field.
	I2S_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	I2S_DATE_DATE_Msk = 0xffffffff
)

// Constants for INTERRUPT_CORE0: Interrupt Controller (Core 0)
const (
	// PRO_MAC_INTR_MAP: MAC_INTR interrupt configuration register
	// Position of PRO_MAC_INTR_MAP field.
	INTERRUPT_CORE0_PRO_MAC_INTR_MAP_PRO_MAC_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_MAC_INTR_MAP field.
	INTERRUPT_CORE0_PRO_MAC_INTR_MAP_PRO_MAC_INTR_MAP_Msk = 0x1f

	// PRO_MAC_NMI_MAP: MAC_NMI interrupt configuration register
	// Position of PRO_MAC_NMI_MAP field.
	INTERRUPT_CORE0_PRO_MAC_NMI_MAP_PRO_MAC_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_MAC_NMI_MAP field.
	INTERRUPT_CORE0_PRO_MAC_NMI_MAP_PRO_MAC_NMI_MAP_Msk = 0x1f

	// PRO_PWR_INTR_MAP: PWR_INTR interrupt configuration register
	// Position of PRO_PWR_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWR_INTR_MAP_PRO_PWR_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWR_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWR_INTR_MAP_PRO_PWR_INTR_MAP_Msk = 0x1f

	// PRO_BB_INT_MAP: BB_INT interrupt configuration register
	// Position of PRO_BB_INT_MAP field.
	INTERRUPT_CORE0_PRO_BB_INT_MAP_PRO_BB_INT_MAP_Pos = 0x0
	// Bit mask of PRO_BB_INT_MAP field.
	INTERRUPT_CORE0_PRO_BB_INT_MAP_PRO_BB_INT_MAP_Msk = 0x1f

	// PRO_BT_MAC_INT_MAP: BT_MAC_INT interrupt configuration register
	// Position of PRO_BT_MAC_INT_MAP field.
	INTERRUPT_CORE0_PRO_BT_MAC_INT_MAP_PRO_BT_MAC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_BT_MAC_INT_MAP field.
	INTERRUPT_CORE0_PRO_BT_MAC_INT_MAP_PRO_BT_MAC_INT_MAP_Msk = 0x1f

	// PRO_BT_BB_INT_MAP: BT_BB_INT interrupt configuration register
	// Position of PRO_BT_BB_INT_MAP field.
	INTERRUPT_CORE0_PRO_BT_BB_INT_MAP_PRO_BT_BB_INT_MAP_Pos = 0x0
	// Bit mask of PRO_BT_BB_INT_MAP field.
	INTERRUPT_CORE0_PRO_BT_BB_INT_MAP_PRO_BT_BB_INT_MAP_Msk = 0x1f

	// PRO_BT_BB_NMI_MAP: BT_BB_NMI interrupt configuration register
	// Position of PRO_BT_BB_NMI_MAP field.
	INTERRUPT_CORE0_PRO_BT_BB_NMI_MAP_PRO_BT_BB_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_BT_BB_NMI_MAP field.
	INTERRUPT_CORE0_PRO_BT_BB_NMI_MAP_PRO_BT_BB_NMI_MAP_Msk = 0x1f

	// PRO_RWBT_IRQ_MAP: RWBT_IRQ interrupt configuration register
	// Position of PRO_RWBT_IRQ_MAP field.
	INTERRUPT_CORE0_PRO_RWBT_IRQ_MAP_PRO_RWBT_IRQ_MAP_Pos = 0x0
	// Bit mask of PRO_RWBT_IRQ_MAP field.
	INTERRUPT_CORE0_PRO_RWBT_IRQ_MAP_PRO_RWBT_IRQ_MAP_Msk = 0x1f

	// PRO_RWBLE_IRQ_MAP: RWBLE_IRQ interrupt configuration register
	// Position of PRO_RWBLE_IRQ_MAP field.
	INTERRUPT_CORE0_PRO_RWBLE_IRQ_MAP_PRO_RWBLE_IRQ_MAP_Pos = 0x0
	// Bit mask of PRO_RWBLE_IRQ_MAP field.
	INTERRUPT_CORE0_PRO_RWBLE_IRQ_MAP_PRO_RWBLE_IRQ_MAP_Msk = 0x1f

	// PRO_RWBT_NMI_MAP: RWBT_NMI interrupt configuration register
	// Position of PRO_RWBT_NMI_MAP field.
	INTERRUPT_CORE0_PRO_RWBT_NMI_MAP_PRO_RWBT_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_RWBT_NMI_MAP field.
	INTERRUPT_CORE0_PRO_RWBT_NMI_MAP_PRO_RWBT_NMI_MAP_Msk = 0x1f

	// PRO_RWBLE_NMI_MAP: RWBLE_NMI interrupt configuration register
	// Position of PRO_RWBLE_NMI_MAP field.
	INTERRUPT_CORE0_PRO_RWBLE_NMI_MAP_PRO_RWBLE_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_RWBLE_NMI_MAP field.
	INTERRUPT_CORE0_PRO_RWBLE_NMI_MAP_PRO_RWBLE_NMI_MAP_Msk = 0x1f

	// PRO_SLC0_INTR_MAP: SLC0_INTR interrupt configuration register
	// Position of PRO_SLC0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SLC0_INTR_MAP_PRO_SLC0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SLC0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SLC0_INTR_MAP_PRO_SLC0_INTR_MAP_Msk = 0x1f

	// PRO_SLC1_INTR_MAP: SLC1_INTR interrupt configuration register
	// Position of PRO_SLC1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SLC1_INTR_MAP_PRO_SLC1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SLC1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SLC1_INTR_MAP_PRO_SLC1_INTR_MAP_Msk = 0x1f

	// PRO_UHCI0_INTR_MAP: UHCI0_INTR interrupt configuration register
	// Position of PRO_UHCI0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UHCI0_INTR_MAP_PRO_UHCI0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UHCI0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UHCI0_INTR_MAP_PRO_UHCI0_INTR_MAP_Msk = 0x1f

	// PRO_UHCI1_INTR_MAP: UHCI1_INTR interrupt configuration register
	// Position of PRO_UHCI1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UHCI1_INTR_MAP_PRO_UHCI1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UHCI1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UHCI1_INTR_MAP_PRO_UHCI1_INTR_MAP_Msk = 0x1f

	// PRO_TG_T0_LEVEL_INT_MAP: TG_T0_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_T0_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T0_LEVEL_INT_MAP_PRO_TG_T0_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T0_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T0_LEVEL_INT_MAP_PRO_TG_T0_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG_T1_LEVEL_INT_MAP: TG_T1_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_T1_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T1_LEVEL_INT_MAP_PRO_TG_T1_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T1_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T1_LEVEL_INT_MAP_PRO_TG_T1_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG_WDT_LEVEL_INT_MAP: TG_WDT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_WDT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_WDT_LEVEL_INT_MAP_PRO_TG_WDT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_WDT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_WDT_LEVEL_INT_MAP_PRO_TG_WDT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG_LACT_LEVEL_INT_MAP: TG_LACT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG_LACT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_LACT_LEVEL_INT_MAP_PRO_TG_LACT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_LACT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_LACT_LEVEL_INT_MAP_PRO_TG_LACT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_T0_LEVEL_INT_MAP: TG1_T0_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_T0_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T0_LEVEL_INT_MAP_PRO_TG1_T0_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T0_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T0_LEVEL_INT_MAP_PRO_TG1_T0_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_T1_LEVEL_INT_MAP: TG1_T1_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_T1_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T1_LEVEL_INT_MAP_PRO_TG1_T1_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T1_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T1_LEVEL_INT_MAP_PRO_TG1_T1_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_WDT_LEVEL_INT_MAP: TG1_WDT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_WDT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_WDT_LEVEL_INT_MAP_PRO_TG1_WDT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_WDT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_WDT_LEVEL_INT_MAP_PRO_TG1_WDT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_TG1_LACT_LEVEL_INT_MAP: TG1_LACT_LEVEL_INT interrupt configuration register
	// Position of PRO_TG1_LACT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_LACT_LEVEL_INT_MAP_PRO_TG1_LACT_LEVEL_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_LACT_LEVEL_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_LACT_LEVEL_INT_MAP_PRO_TG1_LACT_LEVEL_INT_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_PRO_MAP: GPIO_INTERRUPT_PRO interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_PRO_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_PRO_MAP_PRO_GPIO_INTERRUPT_PRO_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_PRO_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_PRO_MAP_PRO_GPIO_INTERRUPT_PRO_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_PRO_NMI_MAP: GPIO_INTERRUPT_PRO_NMI interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_PRO_NMI_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_PRO_NMI_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_APP_MAP: GPIO_INTERRUPT_APP interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_APP_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_APP_MAP_PRO_GPIO_INTERRUPT_APP_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_APP_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_APP_MAP_PRO_GPIO_INTERRUPT_APP_MAP_Msk = 0x1f

	// PRO_GPIO_INTERRUPT_APP_NMI_MAP: GPIO_INTERRUPT_APP_NMI interrupt configuration register
	// Position of PRO_GPIO_INTERRUPT_APP_NMI_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_APP_NMI_MAP_PRO_GPIO_INTERRUPT_APP_NMI_MAP_Pos = 0x0
	// Bit mask of PRO_GPIO_INTERRUPT_APP_NMI_MAP field.
	INTERRUPT_CORE0_PRO_GPIO_INTERRUPT_APP_NMI_MAP_PRO_GPIO_INTERRUPT_APP_NMI_MAP_Msk = 0x1f

	// PRO_DEDICATED_GPIO_IN_INTR_MAP: DEDICATED_GPIO_IN_INTR interrupt configuration register
	// Position of PRO_DEDICATED_GPIO_IN_INTR_MAP field.
	INTERRUPT_CORE0_PRO_DEDICATED_GPIO_IN_INTR_MAP_PRO_DEDICATED_GPIO_IN_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_DEDICATED_GPIO_IN_INTR_MAP field.
	INTERRUPT_CORE0_PRO_DEDICATED_GPIO_IN_INTR_MAP_PRO_DEDICATED_GPIO_IN_INTR_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_0_MAP: CPU_INTR_FROM_CPU_0 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_0_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_0_MAP_PRO_CPU_INTR_FROM_CPU_0_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_0_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_0_MAP_PRO_CPU_INTR_FROM_CPU_0_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_1_MAP: CPU_INTR_FROM_CPU_1 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_1_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_1_MAP_PRO_CPU_INTR_FROM_CPU_1_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_1_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_1_MAP_PRO_CPU_INTR_FROM_CPU_1_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_2_MAP: CPU_INTR_FROM_CPU_2 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_2_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_2_MAP_PRO_CPU_INTR_FROM_CPU_2_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_2_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_2_MAP_PRO_CPU_INTR_FROM_CPU_2_MAP_Msk = 0x1f

	// PRO_CPU_INTR_FROM_CPU_3_MAP: CPU_INTR_FROM_CPU_3 interrupt configuration register
	// Position of PRO_CPU_INTR_FROM_CPU_3_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_3_MAP_PRO_CPU_INTR_FROM_CPU_3_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_INTR_FROM_CPU_3_MAP field.
	INTERRUPT_CORE0_PRO_CPU_INTR_FROM_CPU_3_MAP_PRO_CPU_INTR_FROM_CPU_3_MAP_Msk = 0x1f

	// PRO_SPI_INTR_1_MAP: SPI_INTR_1 interrupt configuration register
	// Position of PRO_SPI_INTR_1_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_1_MAP_PRO_SPI_INTR_1_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_1_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_1_MAP_PRO_SPI_INTR_1_MAP_Msk = 0x1f

	// PRO_SPI_INTR_2_MAP: SPI_INTR_2 interrupt configuration register
	// Position of PRO_SPI_INTR_2_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_2_MAP_PRO_SPI_INTR_2_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_2_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_2_MAP_PRO_SPI_INTR_2_MAP_Msk = 0x1f

	// PRO_SPI_INTR_3_MAP: SPI_INTR_3 interrupt configuration register
	// Position of PRO_SPI_INTR_3_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_3_MAP_PRO_SPI_INTR_3_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_3_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_3_MAP_PRO_SPI_INTR_3_MAP_Msk = 0x1f

	// PRO_I2S0_INT_MAP: I2S0_INT interrupt configuration register
	// Position of PRO_I2S0_INT_MAP field.
	INTERRUPT_CORE0_PRO_I2S0_INT_MAP_PRO_I2S0_INT_MAP_Pos = 0x0
	// Bit mask of PRO_I2S0_INT_MAP field.
	INTERRUPT_CORE0_PRO_I2S0_INT_MAP_PRO_I2S0_INT_MAP_Msk = 0x1f

	// PRO_I2S1_INT_MAP: I2S1_INT interrupt configuration register
	// Position of PRO_I2S1_INT_MAP field.
	INTERRUPT_CORE0_PRO_I2S1_INT_MAP_PRO_I2S1_INT_MAP_Pos = 0x0
	// Bit mask of PRO_I2S1_INT_MAP field.
	INTERRUPT_CORE0_PRO_I2S1_INT_MAP_PRO_I2S1_INT_MAP_Msk = 0x1f

	// PRO_UART_INTR_MAP: UART_INT interrupt configuration register
	// Position of PRO_UART_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UART_INTR_MAP_PRO_UART_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UART_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UART_INTR_MAP_PRO_UART_INTR_MAP_Msk = 0x1f

	// PRO_UART1_INTR_MAP: UART1_INT interrupt configuration register
	// Position of PRO_UART1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UART1_INTR_MAP_PRO_UART1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UART1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UART1_INTR_MAP_PRO_UART1_INTR_MAP_Msk = 0x1f

	// PRO_UART2_INTR_MAP: UART2_INT interrupt configuration register
	// Position of PRO_UART2_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UART2_INTR_MAP_PRO_UART2_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_UART2_INTR_MAP field.
	INTERRUPT_CORE0_PRO_UART2_INTR_MAP_PRO_UART2_INTR_MAP_Msk = 0x1f

	// PRO_SDIO_HOST_INTERRUPT_MAP: SDIO_HOST_INTERRUPT configuration register
	// Position of PRO_SDIO_HOST_INTERRUPT_MAP field.
	INTERRUPT_CORE0_PRO_SDIO_HOST_INTERRUPT_MAP_PRO_SDIO_HOST_INTERRUPT_MAP_Pos = 0x0
	// Bit mask of PRO_SDIO_HOST_INTERRUPT_MAP field.
	INTERRUPT_CORE0_PRO_SDIO_HOST_INTERRUPT_MAP_PRO_SDIO_HOST_INTERRUPT_MAP_Msk = 0x1f

	// PRO_PWM0_INTR_MAP: PWM0_INTR interrupt configuration register
	// Position of PRO_PWM0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM0_INTR_MAP_PRO_PWM0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM0_INTR_MAP_PRO_PWM0_INTR_MAP_Msk = 0x1f

	// PRO_PWM1_INTR_MAP: PWM1_INTR interrupt configuration register
	// Position of PRO_PWM1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM1_INTR_MAP_PRO_PWM1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM1_INTR_MAP_PRO_PWM1_INTR_MAP_Msk = 0x1f

	// PRO_PWM2_INTR_MAP: PWM2_INTR interrupt configuration register
	// Position of PRO_PWM2_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM2_INTR_MAP_PRO_PWM2_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM2_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM2_INTR_MAP_PRO_PWM2_INTR_MAP_Msk = 0x1f

	// PRO_PWM3_INTR_MAP: PWM3_INTR interrupt configuration register
	// Position of PRO_PWM3_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM3_INTR_MAP_PRO_PWM3_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PWM3_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PWM3_INTR_MAP_PRO_PWM3_INTR_MAP_Msk = 0x1f

	// PRO_LEDC_INT_MAP: LEDC_INTR interrupt configuration register
	// Position of PRO_LEDC_INT_MAP field.
	INTERRUPT_CORE0_PRO_LEDC_INT_MAP_PRO_LEDC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_LEDC_INT_MAP field.
	INTERRUPT_CORE0_PRO_LEDC_INT_MAP_PRO_LEDC_INT_MAP_Msk = 0x1f

	// PRO_EFUSE_INT_MAP: EFUSE_INT interrupt configuration register
	// Position of PRO_EFUSE_INT_MAP field.
	INTERRUPT_CORE0_PRO_EFUSE_INT_MAP_PRO_EFUSE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_EFUSE_INT_MAP field.
	INTERRUPT_CORE0_PRO_EFUSE_INT_MAP_PRO_EFUSE_INT_MAP_Msk = 0x1f

	// PRO_CAN_INT_MAP: CAN_INT interrupt configuration register
	// Position of PRO_CAN_INT_MAP field.
	INTERRUPT_CORE0_PRO_CAN_INT_MAP_PRO_CAN_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CAN_INT_MAP field.
	INTERRUPT_CORE0_PRO_CAN_INT_MAP_PRO_CAN_INT_MAP_Msk = 0x1f

	// PRO_USB_INTR_MAP: USB_INT interrupt configuration register
	// Position of PRO_USB_INTR_MAP field.
	INTERRUPT_CORE0_PRO_USB_INTR_MAP_PRO_USB_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_USB_INTR_MAP field.
	INTERRUPT_CORE0_PRO_USB_INTR_MAP_PRO_USB_INTR_MAP_Msk = 0x1f

	// PRO_RTC_CORE_INTR_MAP: RTC_CORE_INTR interrupt configuration register
	// Position of PRO_RTC_CORE_INTR_MAP field.
	INTERRUPT_CORE0_PRO_RTC_CORE_INTR_MAP_PRO_RTC_CORE_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_RTC_CORE_INTR_MAP field.
	INTERRUPT_CORE0_PRO_RTC_CORE_INTR_MAP_PRO_RTC_CORE_INTR_MAP_Msk = 0x1f

	// PRO_RMT_INTR_MAP: RMT_INTR interrupt configuration register
	// Position of PRO_RMT_INTR_MAP field.
	INTERRUPT_CORE0_PRO_RMT_INTR_MAP_PRO_RMT_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_RMT_INTR_MAP field.
	INTERRUPT_CORE0_PRO_RMT_INTR_MAP_PRO_RMT_INTR_MAP_Msk = 0x1f

	// PRO_PCNT_INTR_MAP: PCNT_INTR interrupt configuration register
	// Position of PRO_PCNT_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PCNT_INTR_MAP_PRO_PCNT_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PCNT_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PCNT_INTR_MAP_PRO_PCNT_INTR_MAP_Msk = 0x1f

	// PRO_I2C_EXT0_INTR_MAP: I2C_EXT0_INTR interrupt configuration register
	// Position of PRO_I2C_EXT0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_I2C_EXT0_INTR_MAP_PRO_I2C_EXT0_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_I2C_EXT0_INTR_MAP field.
	INTERRUPT_CORE0_PRO_I2C_EXT0_INTR_MAP_PRO_I2C_EXT0_INTR_MAP_Msk = 0x1f

	// PRO_I2C_EXT1_INTR_MAP: I2C_EXT1_INTR interrupt configuration register
	// Position of PRO_I2C_EXT1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_I2C_EXT1_INTR_MAP_PRO_I2C_EXT1_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_I2C_EXT1_INTR_MAP field.
	INTERRUPT_CORE0_PRO_I2C_EXT1_INTR_MAP_PRO_I2C_EXT1_INTR_MAP_Msk = 0x1f

	// PRO_RSA_INTR_MAP: RSA_INTR interrupt configuration register
	// Position of PRO_RSA_INTR_MAP field.
	INTERRUPT_CORE0_PRO_RSA_INTR_MAP_PRO_RSA_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_RSA_INTR_MAP field.
	INTERRUPT_CORE0_PRO_RSA_INTR_MAP_PRO_RSA_INTR_MAP_Msk = 0x1f

	// PRO_SHA_INTR_MAP: SHA_INTR interrupt configuration register
	// Position of PRO_SHA_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SHA_INTR_MAP_PRO_SHA_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SHA_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SHA_INTR_MAP_PRO_SHA_INTR_MAP_Msk = 0x1f

	// PRO_AES_INTR_MAP: AES_INTR interrupt configuration register
	// Position of PRO_AES_INTR_MAP field.
	INTERRUPT_CORE0_PRO_AES_INTR_MAP_PRO_AES_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_AES_INTR_MAP field.
	INTERRUPT_CORE0_PRO_AES_INTR_MAP_PRO_AES_INTR_MAP_Msk = 0x1f

	// PRO_SPI2_DMA_INT_MAP: SPI2_DMA_INT interrupt configuration register
	// Position of PRO_SPI2_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_SPI2_DMA_INT_MAP_PRO_SPI2_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SPI2_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_SPI2_DMA_INT_MAP_PRO_SPI2_DMA_INT_MAP_Msk = 0x1f

	// PRO_SPI3_DMA_INT_MAP: SPI3_DMA_INT interrupt configuration register
	// Position of PRO_SPI3_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_SPI3_DMA_INT_MAP_PRO_SPI3_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SPI3_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_SPI3_DMA_INT_MAP_PRO_SPI3_DMA_INT_MAP_Msk = 0x1f

	// PRO_WDG_INT_MAP: WDG_INT interrupt configuration register
	// Position of PRO_WDG_INT_MAP field.
	INTERRUPT_CORE0_PRO_WDG_INT_MAP_PRO_WDG_INT_MAP_Pos = 0x0
	// Bit mask of PRO_WDG_INT_MAP field.
	INTERRUPT_CORE0_PRO_WDG_INT_MAP_PRO_WDG_INT_MAP_Msk = 0x1f

	// PRO_TIMER_INT1_MAP: TIMER_INT1 interrupt configuration register
	// Position of PRO_TIMER_INT1_MAP field.
	INTERRUPT_CORE0_PRO_TIMER_INT1_MAP_PRO_TIMER_INT1_MAP_Pos = 0x0
	// Bit mask of PRO_TIMER_INT1_MAP field.
	INTERRUPT_CORE0_PRO_TIMER_INT1_MAP_PRO_TIMER_INT1_MAP_Msk = 0x1f

	// PRO_TIMER_INT2_MAP: TIMER_INT2 interrupt configuration register
	// Position of PRO_TIMER_INT2_MAP field.
	INTERRUPT_CORE0_PRO_TIMER_INT2_MAP_PRO_TIMER_INT2_MAP_Pos = 0x0
	// Bit mask of PRO_TIMER_INT2_MAP field.
	INTERRUPT_CORE0_PRO_TIMER_INT2_MAP_PRO_TIMER_INT2_MAP_Msk = 0x1f

	// PRO_TG_T0_EDGE_INT_MAP: TG_T0_EDGE_INT interrupt configuration register
	// Position of PRO_TG_T0_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T0_EDGE_INT_MAP_PRO_TG_T0_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T0_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T0_EDGE_INT_MAP_PRO_TG_T0_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG_T1_EDGE_INT_MAP: TG_T1_EDGE_INT interrupt configuration register
	// Position of PRO_TG_T1_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T1_EDGE_INT_MAP_PRO_TG_T1_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_T1_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_T1_EDGE_INT_MAP_PRO_TG_T1_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG_WDT_EDGE_INT_MAP: TG_WDT_EDGE_INT interrupt configuration register
	// Position of PRO_TG_WDT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_WDT_EDGE_INT_MAP_PRO_TG_WDT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_WDT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_WDT_EDGE_INT_MAP_PRO_TG_WDT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG_LACT_EDGE_INT_MAP: TG_LACT_EDGE_INT interrupt configuration register
	// Position of PRO_TG_LACT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_LACT_EDGE_INT_MAP_PRO_TG_LACT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG_LACT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG_LACT_EDGE_INT_MAP_PRO_TG_LACT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_T0_EDGE_INT_MAP: TG1_T0_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_T0_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T0_EDGE_INT_MAP_PRO_TG1_T0_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T0_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T0_EDGE_INT_MAP_PRO_TG1_T0_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_T1_EDGE_INT_MAP: TG1_T1_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_T1_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T1_EDGE_INT_MAP_PRO_TG1_T1_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_T1_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_T1_EDGE_INT_MAP_PRO_TG1_T1_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_WDT_EDGE_INT_MAP: TG1_WDT_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_WDT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_WDT_EDGE_INT_MAP_PRO_TG1_WDT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_WDT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_WDT_EDGE_INT_MAP_PRO_TG1_WDT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_TG1_LACT_EDGE_INT_MAP: TG1_LACT_EDGE_INT interrupt configuration register
	// Position of PRO_TG1_LACT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_LACT_EDGE_INT_MAP_PRO_TG1_LACT_EDGE_INT_MAP_Pos = 0x0
	// Bit mask of PRO_TG1_LACT_EDGE_INT_MAP field.
	INTERRUPT_CORE0_PRO_TG1_LACT_EDGE_INT_MAP_PRO_TG1_LACT_EDGE_INT_MAP_Msk = 0x1f

	// PRO_CACHE_IA_INT_MAP: CACHE_IA_INT interrupt configuration register
	// Position of PRO_CACHE_IA_INT_MAP field.
	INTERRUPT_CORE0_PRO_CACHE_IA_INT_MAP_PRO_CACHE_IA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CACHE_IA_INT_MAP field.
	INTERRUPT_CORE0_PRO_CACHE_IA_INT_MAP_PRO_CACHE_IA_INT_MAP_Msk = 0x1f

	// PRO_SYSTIMER_TARGET0_INT_MAP: SYSTIMER_TARGET0_INT interrupt configuration register
	// Position of PRO_SYSTIMER_TARGET0_INT_MAP field.
	INTERRUPT_CORE0_PRO_SYSTIMER_TARGET0_INT_MAP_PRO_SYSTIMER_TARGET0_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SYSTIMER_TARGET0_INT_MAP field.
	INTERRUPT_CORE0_PRO_SYSTIMER_TARGET0_INT_MAP_PRO_SYSTIMER_TARGET0_INT_MAP_Msk = 0x1f

	// PRO_SYSTIMER_TARGET1_INT_MAP: SYSTIMER_TARGET1_INT interrupt configuration register
	// Position of PRO_SYSTIMER_TARGET1_INT_MAP field.
	INTERRUPT_CORE0_PRO_SYSTIMER_TARGET1_INT_MAP_PRO_SYSTIMER_TARGET1_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SYSTIMER_TARGET1_INT_MAP field.
	INTERRUPT_CORE0_PRO_SYSTIMER_TARGET1_INT_MAP_PRO_SYSTIMER_TARGET1_INT_MAP_Msk = 0x1f

	// PRO_SYSTIMER_TARGET2_INT_MAP: SYSTIMER_TARGET2_INT interrupt configuration register
	// Position of PRO_SYSTIMER_TARGET2_INT_MAP field.
	INTERRUPT_CORE0_PRO_SYSTIMER_TARGET2_INT_MAP_PRO_SYSTIMER_TARGET2_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SYSTIMER_TARGET2_INT_MAP field.
	INTERRUPT_CORE0_PRO_SYSTIMER_TARGET2_INT_MAP_PRO_SYSTIMER_TARGET2_INT_MAP_Msk = 0x1f

	// PRO_ASSIST_DEBUG_INTR_MAP: ASSIST_DEBUG_INTR interrupt configuration register
	// Position of PRO_ASSIST_DEBUG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_ASSIST_DEBUG_INTR_MAP_PRO_ASSIST_DEBUG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_ASSIST_DEBUG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_ASSIST_DEBUG_INTR_MAP_PRO_ASSIST_DEBUG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_IRAM0_ILG_INTR_MAP: PMS_PRO_IRAM0_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_IRAM0_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_IRAM0_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_PRO_PMS_PRO_IRAM0_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_DRAM0_ILG_INTR_MAP: PMS_PRO_DRAM0_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_DRAM0_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_DRAM0_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_PRO_PMS_PRO_DRAM0_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_DPORT_ILG_INTR_MAP: PMS_PRO_DPORT_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_DPORT_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_DPORT_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_AHB_ILG_INTR_MAP: PMS_PRO_AHB_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_AHB_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_AHB_ILG_INTR_MAP_PRO_PMS_PRO_AHB_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_AHB_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_AHB_ILG_INTR_MAP_PRO_PMS_PRO_AHB_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_PRO_CACHE_ILG_INTR_MAP: PMS_PRO_CACHE_ILG interrupt configuration register
	// Position of PRO_PMS_PRO_CACHE_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_PRO_CACHE_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_DMA_APB_I_ILG_INTR_MAP: PMS_DMA_APB_I_ILG interrupt configuration register
	// Position of PRO_PMS_DMA_APB_I_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_DMA_APB_I_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_DMA_RX_I_ILG_INTR_MAP: PMS_DMA_RX_I_ILG interrupt configuration register
	// Position of PRO_PMS_DMA_RX_I_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_DMA_RX_I_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_Msk = 0x1f

	// PRO_PMS_DMA_TX_I_ILG_INTR_MAP: PMS_DMA_TX_I_ILG interrupt configuration register
	// Position of PRO_PMS_DMA_TX_I_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_PMS_DMA_TX_I_ILG_INTR_MAP field.
	INTERRUPT_CORE0_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_Msk = 0x1f

	// PRO_SPI_MEM_REJECT_INTR_MAP: SPI_MEM_REJECT_INTR interrupt configuration register
	// Position of PRO_SPI_MEM_REJECT_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SPI_MEM_REJECT_INTR_MAP_PRO_SPI_MEM_REJECT_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_MEM_REJECT_INTR_MAP field.
	INTERRUPT_CORE0_PRO_SPI_MEM_REJECT_INTR_MAP_PRO_SPI_MEM_REJECT_INTR_MAP_Msk = 0x1f

	// PRO_DMA_COPY_INTR_MAP: DMA_COPY_INTR interrupt configuration register
	// Position of PRO_DMA_COPY_INTR_MAP field.
	INTERRUPT_CORE0_PRO_DMA_COPY_INTR_MAP_PRO_DMA_COPY_INTR_MAP_Pos = 0x0
	// Bit mask of PRO_DMA_COPY_INTR_MAP field.
	INTERRUPT_CORE0_PRO_DMA_COPY_INTR_MAP_PRO_DMA_COPY_INTR_MAP_Msk = 0x1f

	// PRO_SPI4_DMA_INT_MAP: SPI4_DMA_INT interrupt configuration register
	// Position of PRO_SPI4_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_SPI4_DMA_INT_MAP_PRO_SPI4_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_SPI4_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_SPI4_DMA_INT_MAP_PRO_SPI4_DMA_INT_MAP_Msk = 0x1f

	// PRO_SPI_INTR_4_MAP: SPI_INTR_4 interrupt configuration register
	// Position of PRO_SPI_INTR_4_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_4_MAP_PRO_SPI_INTR_4_MAP_Pos = 0x0
	// Bit mask of PRO_SPI_INTR_4_MAP field.
	INTERRUPT_CORE0_PRO_SPI_INTR_4_MAP_PRO_SPI_INTR_4_MAP_Msk = 0x1f

	// PRO_DCACHE_PRELOAD_INT_MAP: DCACHE_PRELOAD_INT interrupt configuration register
	// Position of PRO_DCACHE_PRELOAD_INT_MAP field.
	INTERRUPT_CORE0_PRO_DCACHE_PRELOAD_INT_MAP_PRO_DCACHE_PRELOAD_INT_MAP_Pos = 0x0
	// Bit mask of PRO_DCACHE_PRELOAD_INT_MAP field.
	INTERRUPT_CORE0_PRO_DCACHE_PRELOAD_INT_MAP_PRO_DCACHE_PRELOAD_INT_MAP_Msk = 0x1f

	// PRO_ICACHE_PRELOAD_INT_MAP: ICACHE_PRELOAD_INT interrupt configuration register
	// Position of PRO_ICACHE_PRELOAD_INT_MAP field.
	INTERRUPT_CORE0_PRO_ICACHE_PRELOAD_INT_MAP_PRO_ICACHE_PRELOAD_INT_MAP_Pos = 0x0
	// Bit mask of PRO_ICACHE_PRELOAD_INT_MAP field.
	INTERRUPT_CORE0_PRO_ICACHE_PRELOAD_INT_MAP_PRO_ICACHE_PRELOAD_INT_MAP_Msk = 0x1f

	// PRO_APB_ADC_INT_MAP: APB_ADC_INT interrupt configuration register
	// Position of PRO_APB_ADC_INT_MAP field.
	INTERRUPT_CORE0_PRO_APB_ADC_INT_MAP_PRO_APB_ADC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_APB_ADC_INT_MAP field.
	INTERRUPT_CORE0_PRO_APB_ADC_INT_MAP_PRO_APB_ADC_INT_MAP_Msk = 0x1f

	// PRO_CRYPTO_DMA_INT_MAP: CRYPTO_DMA_INT interrupt configuration register
	// Position of PRO_CRYPTO_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_CRYPTO_DMA_INT_MAP_PRO_CRYPTO_DMA_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CRYPTO_DMA_INT_MAP field.
	INTERRUPT_CORE0_PRO_CRYPTO_DMA_INT_MAP_PRO_CRYPTO_DMA_INT_MAP_Msk = 0x1f

	// PRO_CPU_PERI_ERROR_INT_MAP: CPU_PERI_ERROR_INT interrupt configuration register
	// Position of PRO_CPU_PERI_ERROR_INT_MAP field.
	INTERRUPT_CORE0_PRO_CPU_PERI_ERROR_INT_MAP_PRO_CPU_PERI_ERROR_INT_MAP_Pos = 0x0
	// Bit mask of PRO_CPU_PERI_ERROR_INT_MAP field.
	INTERRUPT_CORE0_PRO_CPU_PERI_ERROR_INT_MAP_PRO_CPU_PERI_ERROR_INT_MAP_Msk = 0x1f

	// PRO_APB_PERI_ERROR_INT_MAP: APB_PERI_ERROR_INT interrupt configuration register
	// Position of PRO_APB_PERI_ERROR_INT_MAP field.
	INTERRUPT_CORE0_PRO_APB_PERI_ERROR_INT_MAP_PRO_APB_PERI_ERROR_INT_MAP_Pos = 0x0
	// Bit mask of PRO_APB_PERI_ERROR_INT_MAP field.
	INTERRUPT_CORE0_PRO_APB_PERI_ERROR_INT_MAP_PRO_APB_PERI_ERROR_INT_MAP_Msk = 0x1f

	// PRO_DCACHE_SYNC_INT_MAP: DCACHE_SYNC_INT interrupt configuration register
	// Position of PRO_DCACHE_SYNC_INT_MAP field.
	INTERRUPT_CORE0_PRO_DCACHE_SYNC_INT_MAP_PRO_DCACHE_SYNC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_DCACHE_SYNC_INT_MAP field.
	INTERRUPT_CORE0_PRO_DCACHE_SYNC_INT_MAP_PRO_DCACHE_SYNC_INT_MAP_Msk = 0x1f

	// PRO_ICACHE_SYNC_INT_MAP: ICACHE_SYNC_INT interrupt configuration register
	// Position of PRO_ICACHE_SYNC_INT_MAP field.
	INTERRUPT_CORE0_PRO_ICACHE_SYNC_INT_MAP_PRO_ICACHE_SYNC_INT_MAP_Pos = 0x0
	// Bit mask of PRO_ICACHE_SYNC_INT_MAP field.
	INTERRUPT_CORE0_PRO_ICACHE_SYNC_INT_MAP_PRO_ICACHE_SYNC_INT_MAP_Msk = 0x1f

	// PRO_INTR_STATUS_0: Interrupt status register 0
	// Position of PRO_INTR_STATUS_0 field.
	INTERRUPT_CORE0_PRO_INTR_STATUS_0_PRO_INTR_STATUS_0_Pos = 0x0
	// Bit mask of PRO_INTR_STATUS_0 field.
	INTERRUPT_CORE0_PRO_INTR_STATUS_0_PRO_INTR_STATUS_0_Msk = 0xffffffff

	// PRO_INTR_STATUS_1: Interrupt status register 1
	// Position of PRO_INTR_STATUS_1 field.
	INTERRUPT_CORE0_PRO_INTR_STATUS_1_PRO_INTR_STATUS_1_Pos = 0x0
	// Bit mask of PRO_INTR_STATUS_1 field.
	INTERRUPT_CORE0_PRO_INTR_STATUS_1_PRO_INTR_STATUS_1_Msk = 0xffffffff

	// PRO_INTR_STATUS_2: Interrupt status register 2
	// Position of PRO_INTR_STATUS_2 field.
	INTERRUPT_CORE0_PRO_INTR_STATUS_2_PRO_INTR_STATUS_2_Pos = 0x0
	// Bit mask of PRO_INTR_STATUS_2 field.
	INTERRUPT_CORE0_PRO_INTR_STATUS_2_PRO_INTR_STATUS_2_Msk = 0xffffffff

	// CLOCK_GATE: NMI interrupt signals mask register
	// Position of CLK_EN field.
	INTERRUPT_CORE0_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	INTERRUPT_CORE0_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	INTERRUPT_CORE0_CLOCK_GATE_CLK_EN = 0x1
	// Position of PRO_NMI_MASK_HW field.
	INTERRUPT_CORE0_CLOCK_GATE_PRO_NMI_MASK_HW_Pos = 0x1
	// Bit mask of PRO_NMI_MASK_HW field.
	INTERRUPT_CORE0_CLOCK_GATE_PRO_NMI_MASK_HW_Msk = 0x2
	// Bit PRO_NMI_MASK_HW.
	INTERRUPT_CORE0_CLOCK_GATE_PRO_NMI_MASK_HW = 0x2

	// REG_DATE: Version control register
	// Position of INTERRUPT_REG_DATE field.
	INTERRUPT_CORE0_REG_DATE_INTERRUPT_REG_DATE_Pos = 0x0
	// Bit mask of INTERRUPT_REG_DATE field.
	INTERRUPT_CORE0_REG_DATE_INTERRUPT_REG_DATE_Msk = 0xfffffff
)

// Constants for IO_MUX: Input/Output Multiplexer
const (
	// PIN_CTRL: Clock output configuration register
	// Position of PIN_CLK_OUT1 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT1_Pos = 0x0
	// Bit mask of PIN_CLK_OUT1 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT1_Msk = 0xf
	// Position of PIN_CLK_OUT2 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT2_Pos = 0x4
	// Bit mask of PIN_CLK_OUT2 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT2_Msk = 0xf0
	// Position of PIN_CLK_OUT3 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT3_Pos = 0x8
	// Bit mask of PIN_CLK_OUT3 field.
	IO_MUX_PIN_CTRL_PIN_CLK_OUT3_Msk = 0xf00
	// Position of SWITCH_PRT_NUM field.
	IO_MUX_PIN_CTRL_SWITCH_PRT_NUM_Pos = 0xc
	// Bit mask of SWITCH_PRT_NUM field.
	IO_MUX_PIN_CTRL_SWITCH_PRT_NUM_Msk = 0x7000
	// Position of PAD_POWER_CTRL field.
	IO_MUX_PIN_CTRL_PAD_POWER_CTRL_Pos = 0xf
	// Bit mask of PAD_POWER_CTRL field.
	IO_MUX_PIN_CTRL_PAD_POWER_CTRL_Msk = 0x8000
	// Bit PAD_POWER_CTRL.
	IO_MUX_PIN_CTRL_PAD_POWER_CTRL = 0x8000

	// GPIO0: Configuration register for pin GPIO0
	// Position of MCU_OE field.
	IO_MUX_GPIO0_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO0_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO0_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO0_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO0_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO0_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO0_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO0_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO0_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO0_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO0_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO0_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO0_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO0_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO0_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO0_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO0_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO0_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO0_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO0_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO0_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO0_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO0_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO0_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO0_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO0_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO0_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO0_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO0_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO0_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO0_FILTER_EN = 0x8000

	// GPIO1: Configuration register for pin GPIO1
	// Position of MCU_OE field.
	IO_MUX_GPIO1_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO1_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO1_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO1_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO1_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO1_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO1_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO1_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO1_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO1_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO1_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO1_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO1_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO1_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO1_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO1_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO1_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO1_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO1_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO1_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO1_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO1_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO1_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO1_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO1_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO1_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO1_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO1_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO1_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO1_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO1_FILTER_EN = 0x8000

	// GPIO2: Configuration register for pin GPIO2
	// Position of MCU_OE field.
	IO_MUX_GPIO2_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO2_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO2_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO2_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO2_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO2_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO2_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO2_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO2_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO2_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO2_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO2_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO2_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO2_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO2_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO2_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO2_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO2_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO2_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO2_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO2_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO2_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO2_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO2_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO2_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO2_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO2_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO2_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO2_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO2_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO2_FILTER_EN = 0x8000

	// GPIO3: Configuration register for pin GPIO3
	// Position of MCU_OE field.
	IO_MUX_GPIO3_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO3_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO3_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO3_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO3_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO3_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO3_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO3_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO3_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO3_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO3_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO3_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO3_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO3_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO3_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO3_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO3_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO3_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO3_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO3_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO3_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO3_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO3_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO3_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO3_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO3_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO3_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO3_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO3_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO3_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO3_FILTER_EN = 0x8000

	// GPIO4: Configuration register for pin GPIO4
	// Position of MCU_OE field.
	IO_MUX_GPIO4_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO4_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO4_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO4_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO4_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO4_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO4_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO4_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO4_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO4_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO4_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO4_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO4_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO4_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO4_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO4_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO4_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO4_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO4_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO4_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO4_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO4_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO4_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO4_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO4_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO4_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO4_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO4_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO4_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO4_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO4_FILTER_EN = 0x8000

	// GPIO5: Configuration register for pin GPIO5
	// Position of MCU_OE field.
	IO_MUX_GPIO5_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO5_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO5_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO5_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO5_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO5_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO5_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO5_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO5_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO5_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO5_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO5_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO5_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO5_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO5_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO5_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO5_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO5_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO5_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO5_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO5_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO5_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO5_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO5_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO5_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO5_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO5_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO5_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO5_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO5_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO5_FILTER_EN = 0x8000

	// GPIO6: Configuration register for pin GPIO6
	// Position of MCU_OE field.
	IO_MUX_GPIO6_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO6_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO6_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO6_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO6_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO6_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO6_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO6_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO6_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO6_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO6_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO6_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO6_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO6_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO6_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO6_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO6_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO6_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO6_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO6_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO6_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO6_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO6_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO6_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO6_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO6_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO6_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO6_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO6_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO6_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO6_FILTER_EN = 0x8000

	// GPIO7: Configuration register for pin GPIO7
	// Position of MCU_OE field.
	IO_MUX_GPIO7_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO7_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO7_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO7_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO7_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO7_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO7_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO7_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO7_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO7_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO7_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO7_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO7_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO7_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO7_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO7_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO7_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO7_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO7_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO7_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO7_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO7_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO7_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO7_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO7_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO7_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO7_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO7_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO7_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO7_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO7_FILTER_EN = 0x8000

	// GPIO8: Configuration register for pin GPIO8
	// Position of MCU_OE field.
	IO_MUX_GPIO8_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO8_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO8_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO8_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO8_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO8_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO8_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO8_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO8_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO8_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO8_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO8_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO8_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO8_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO8_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO8_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO8_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO8_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO8_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO8_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO8_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO8_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO8_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO8_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO8_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO8_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO8_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO8_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO8_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO8_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO8_FILTER_EN = 0x8000

	// GPIO9: Configuration register for pin GPIO9
	// Position of MCU_OE field.
	IO_MUX_GPIO9_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO9_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO9_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO9_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO9_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO9_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO9_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO9_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO9_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO9_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO9_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO9_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO9_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO9_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO9_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO9_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO9_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO9_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO9_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO9_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO9_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO9_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO9_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO9_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO9_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO9_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO9_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO9_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO9_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO9_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO9_FILTER_EN = 0x8000

	// GPIO10: Configuration register for pin GPIO10
	// Position of MCU_OE field.
	IO_MUX_GPIO10_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO10_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO10_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO10_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO10_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO10_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO10_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO10_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO10_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO10_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO10_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO10_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO10_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO10_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO10_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO10_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO10_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO10_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO10_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO10_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO10_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO10_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO10_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO10_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO10_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO10_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO10_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO10_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO10_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO10_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO10_FILTER_EN = 0x8000

	// GPIO11: Configuration register for pin GPIO11
	// Position of MCU_OE field.
	IO_MUX_GPIO11_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO11_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO11_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO11_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO11_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO11_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO11_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO11_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO11_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO11_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO11_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO11_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO11_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO11_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO11_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO11_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO11_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO11_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO11_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO11_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO11_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO11_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO11_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO11_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO11_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO11_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO11_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO11_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO11_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO11_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO11_FILTER_EN = 0x8000

	// GPIO12: Configuration register for pin GPIO12
	// Position of MCU_OE field.
	IO_MUX_GPIO12_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO12_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO12_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO12_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO12_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO12_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO12_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO12_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO12_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO12_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO12_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO12_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO12_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO12_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO12_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO12_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO12_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO12_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO12_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO12_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO12_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO12_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO12_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO12_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO12_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO12_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO12_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO12_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO12_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO12_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO12_FILTER_EN = 0x8000

	// GPIO13: Configuration register for pin GPIO13
	// Position of MCU_OE field.
	IO_MUX_GPIO13_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO13_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO13_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO13_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO13_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO13_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO13_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO13_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO13_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO13_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO13_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO13_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO13_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO13_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO13_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO13_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO13_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO13_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO13_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO13_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO13_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO13_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO13_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO13_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO13_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO13_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO13_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO13_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO13_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO13_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO13_FILTER_EN = 0x8000

	// GPIO14: Configuration register for pin GPIO14
	// Position of MCU_OE field.
	IO_MUX_GPIO14_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO14_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO14_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO14_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO14_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO14_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO14_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO14_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO14_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO14_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO14_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO14_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO14_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO14_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO14_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO14_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO14_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO14_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO14_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO14_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO14_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO14_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO14_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO14_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO14_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO14_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO14_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO14_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO14_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO14_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO14_FILTER_EN = 0x8000

	// GPIO15: Configuration register for pin GPIO15
	// Position of MCU_OE field.
	IO_MUX_GPIO15_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO15_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO15_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO15_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO15_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO15_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO15_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO15_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO15_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO15_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO15_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO15_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO15_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO15_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO15_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO15_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO15_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO15_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO15_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO15_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO15_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO15_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO15_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO15_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO15_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO15_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO15_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO15_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO15_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO15_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO15_FILTER_EN = 0x8000

	// GPIO16: Configuration register for pin GPIO16
	// Position of MCU_OE field.
	IO_MUX_GPIO16_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO16_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO16_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO16_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO16_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO16_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO16_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO16_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO16_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO16_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO16_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO16_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO16_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO16_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO16_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO16_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO16_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO16_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO16_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO16_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO16_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO16_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO16_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO16_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO16_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO16_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO16_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO16_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO16_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO16_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO16_FILTER_EN = 0x8000

	// GPIO17: Configuration register for pin GPIO17
	// Position of MCU_OE field.
	IO_MUX_GPIO17_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO17_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO17_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO17_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO17_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO17_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO17_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO17_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO17_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO17_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO17_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO17_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO17_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO17_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO17_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO17_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO17_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO17_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO17_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO17_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO17_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO17_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO17_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO17_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO17_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO17_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO17_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO17_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO17_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO17_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO17_FILTER_EN = 0x8000

	// GPIO18: Configuration register for pin GPIO18
	// Position of MCU_OE field.
	IO_MUX_GPIO18_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO18_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO18_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO18_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO18_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO18_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO18_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO18_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO18_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO18_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO18_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO18_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO18_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO18_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO18_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO18_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO18_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO18_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO18_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO18_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO18_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO18_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO18_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO18_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO18_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO18_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO18_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO18_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO18_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO18_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO18_FILTER_EN = 0x8000

	// GPIO19: Configuration register for pin GPIO19
	// Position of MCU_OE field.
	IO_MUX_GPIO19_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO19_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO19_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO19_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO19_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO19_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO19_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO19_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO19_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO19_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO19_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO19_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO19_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO19_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO19_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO19_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO19_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO19_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO19_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO19_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO19_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO19_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO19_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO19_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO19_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO19_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO19_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO19_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO19_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO19_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO19_FILTER_EN = 0x8000

	// GPIO20: Configuration register for pin GPIO20
	// Position of MCU_OE field.
	IO_MUX_GPIO20_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO20_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO20_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO20_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO20_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO20_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO20_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO20_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO20_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO20_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO20_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO20_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO20_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO20_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO20_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO20_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO20_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO20_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO20_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO20_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO20_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO20_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO20_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO20_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO20_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO20_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO20_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO20_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO20_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO20_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO20_FILTER_EN = 0x8000

	// GPIO21: Configuration register for pin GPIO21
	// Position of MCU_OE field.
	IO_MUX_GPIO21_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO21_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO21_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO21_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO21_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO21_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO21_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO21_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO21_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO21_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO21_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO21_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO21_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO21_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO21_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO21_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO21_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO21_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO21_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO21_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO21_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO21_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO21_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO21_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO21_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO21_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO21_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO21_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO21_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO21_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO21_FILTER_EN = 0x8000

	// GPIO26: Configuration register for pin GPIO26
	// Position of MCU_OE field.
	IO_MUX_GPIO26_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO26_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO26_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO26_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO26_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO26_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO26_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO26_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO26_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO26_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO26_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO26_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO26_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO26_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO26_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO26_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO26_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO26_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO26_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO26_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO26_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO26_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO26_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO26_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO26_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO26_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO26_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO26_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO26_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO26_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO26_FILTER_EN = 0x8000

	// GPIO27: Configuration register for pin GPIO27
	// Position of MCU_OE field.
	IO_MUX_GPIO27_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO27_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO27_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO27_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO27_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO27_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO27_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO27_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO27_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO27_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO27_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO27_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO27_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO27_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO27_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO27_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO27_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO27_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO27_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO27_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO27_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO27_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO27_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO27_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO27_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO27_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO27_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO27_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO27_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO27_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO27_FILTER_EN = 0x8000

	// GPIO28: Configuration register for pin GPIO28
	// Position of MCU_OE field.
	IO_MUX_GPIO28_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO28_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO28_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO28_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO28_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO28_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO28_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO28_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO28_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO28_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO28_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO28_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO28_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO28_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO28_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO28_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO28_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO28_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO28_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO28_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO28_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO28_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO28_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO28_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO28_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO28_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO28_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO28_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO28_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO28_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO28_FILTER_EN = 0x8000

	// GPIO29: Configuration register for pin GPIO29
	// Position of MCU_OE field.
	IO_MUX_GPIO29_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO29_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO29_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO29_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO29_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO29_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO29_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO29_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO29_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO29_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO29_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO29_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO29_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO29_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO29_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO29_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO29_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO29_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO29_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO29_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO29_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO29_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO29_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO29_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO29_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO29_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO29_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO29_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO29_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO29_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO29_FILTER_EN = 0x8000

	// GPIO30: Configuration register for pin GPIO30
	// Position of MCU_OE field.
	IO_MUX_GPIO30_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO30_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO30_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO30_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO30_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO30_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO30_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO30_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO30_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO30_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO30_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO30_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO30_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO30_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO30_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO30_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO30_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO30_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO30_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO30_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO30_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO30_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO30_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO30_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO30_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO30_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO30_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO30_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO30_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO30_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO30_FILTER_EN = 0x8000

	// GPIO31: Configuration register for pin GPIO31
	// Position of MCU_OE field.
	IO_MUX_GPIO31_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO31_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO31_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO31_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO31_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO31_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO31_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO31_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO31_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO31_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO31_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO31_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO31_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO31_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO31_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO31_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO31_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO31_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO31_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO31_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO31_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO31_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO31_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO31_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO31_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO31_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO31_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO31_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO31_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO31_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO31_FILTER_EN = 0x8000

	// GPIO32: Configuration register for pin GPIO32
	// Position of MCU_OE field.
	IO_MUX_GPIO32_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO32_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO32_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO32_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO32_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO32_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO32_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO32_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO32_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO32_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO32_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO32_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO32_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO32_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO32_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO32_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO32_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO32_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO32_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO32_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO32_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO32_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO32_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO32_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO32_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO32_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO32_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO32_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO32_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO32_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO32_FILTER_EN = 0x8000

	// GPIO33: Configuration register for pin GPIO33
	// Position of MCU_OE field.
	IO_MUX_GPIO33_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO33_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO33_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO33_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO33_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO33_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO33_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO33_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO33_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO33_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO33_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO33_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO33_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO33_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO33_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO33_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO33_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO33_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO33_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO33_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO33_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO33_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO33_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO33_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO33_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO33_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO33_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO33_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO33_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO33_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO33_FILTER_EN = 0x8000

	// GPIO34: Configuration register for pin GPIO34
	// Position of MCU_OE field.
	IO_MUX_GPIO34_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO34_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO34_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO34_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO34_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO34_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO34_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO34_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO34_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO34_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO34_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO34_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO34_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO34_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO34_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO34_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO34_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO34_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO34_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO34_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO34_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO34_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO34_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO34_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO34_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO34_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO34_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO34_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO34_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO34_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO34_FILTER_EN = 0x8000

	// GPIO35: Configuration register for pin GPIO35
	// Position of MCU_OE field.
	IO_MUX_GPIO35_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO35_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO35_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO35_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO35_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO35_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO35_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO35_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO35_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO35_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO35_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO35_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO35_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO35_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO35_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO35_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO35_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO35_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO35_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO35_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO35_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO35_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO35_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO35_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO35_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO35_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO35_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO35_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO35_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO35_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO35_FILTER_EN = 0x8000

	// GPIO36: Configuration register for pin GPIO36
	// Position of MCU_OE field.
	IO_MUX_GPIO36_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO36_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO36_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO36_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO36_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO36_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO36_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO36_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO36_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO36_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO36_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO36_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO36_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO36_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO36_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO36_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO36_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO36_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO36_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO36_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO36_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO36_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO36_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO36_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO36_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO36_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO36_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO36_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO36_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO36_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO36_FILTER_EN = 0x8000

	// GPIO37: Configuration register for pin GPIO37
	// Position of MCU_OE field.
	IO_MUX_GPIO37_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO37_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO37_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO37_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO37_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO37_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO37_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO37_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO37_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO37_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO37_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO37_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO37_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO37_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO37_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO37_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO37_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO37_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO37_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO37_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO37_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO37_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO37_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO37_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO37_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO37_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO37_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO37_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO37_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO37_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO37_FILTER_EN = 0x8000

	// GPIO38: Configuration register for pin GPIO38
	// Position of MCU_OE field.
	IO_MUX_GPIO38_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO38_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO38_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO38_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO38_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO38_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO38_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO38_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO38_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO38_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO38_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO38_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO38_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO38_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO38_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO38_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO38_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO38_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO38_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO38_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO38_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO38_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO38_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO38_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO38_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO38_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO38_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO38_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO38_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO38_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO38_FILTER_EN = 0x8000

	// GPIO39: Configuration register for pin GPIO39
	// Position of MCU_OE field.
	IO_MUX_GPIO39_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO39_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO39_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO39_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO39_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO39_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO39_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO39_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO39_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO39_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO39_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO39_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO39_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO39_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO39_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO39_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO39_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO39_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO39_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO39_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO39_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO39_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO39_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO39_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO39_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO39_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO39_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO39_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO39_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO39_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO39_FILTER_EN = 0x8000

	// GPIO40: Configuration register for pin GPIO40
	// Position of MCU_OE field.
	IO_MUX_GPIO40_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO40_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO40_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO40_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO40_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO40_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO40_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO40_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO40_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO40_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO40_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO40_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO40_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO40_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO40_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO40_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO40_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO40_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO40_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO40_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO40_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO40_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO40_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO40_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO40_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO40_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO40_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO40_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO40_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO40_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO40_FILTER_EN = 0x8000

	// GPIO41: Configuration register for pin GPIO41
	// Position of MCU_OE field.
	IO_MUX_GPIO41_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO41_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO41_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO41_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO41_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO41_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO41_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO41_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO41_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO41_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO41_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO41_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO41_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO41_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO41_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO41_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO41_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO41_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO41_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO41_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO41_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO41_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO41_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO41_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO41_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO41_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO41_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO41_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO41_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO41_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO41_FILTER_EN = 0x8000

	// GPIO42: Configuration register for pin GPIO42
	// Position of MCU_OE field.
	IO_MUX_GPIO42_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO42_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO42_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO42_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO42_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO42_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO42_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO42_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO42_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO42_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO42_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO42_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO42_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO42_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO42_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO42_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO42_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO42_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO42_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO42_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO42_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO42_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO42_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO42_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO42_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO42_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO42_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO42_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO42_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO42_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO42_FILTER_EN = 0x8000

	// GPIO43: Configuration register for pin GPIO43
	// Position of MCU_OE field.
	IO_MUX_GPIO43_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO43_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO43_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO43_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO43_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO43_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO43_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO43_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO43_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO43_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO43_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO43_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO43_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO43_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO43_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO43_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO43_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO43_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO43_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO43_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO43_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO43_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO43_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO43_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO43_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO43_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO43_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO43_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO43_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO43_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO43_FILTER_EN = 0x8000

	// GPIO44: Configuration register for pin GPIO44
	// Position of MCU_OE field.
	IO_MUX_GPIO44_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO44_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO44_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO44_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO44_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO44_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO44_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO44_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO44_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO44_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO44_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO44_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO44_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO44_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO44_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO44_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO44_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO44_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO44_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO44_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO44_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO44_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO44_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO44_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO44_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO44_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO44_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO44_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO44_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO44_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO44_FILTER_EN = 0x8000

	// GPIO45: Configuration register for pin GPIO45
	// Position of MCU_OE field.
	IO_MUX_GPIO45_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO45_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO45_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO45_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO45_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO45_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO45_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO45_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO45_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO45_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO45_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO45_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO45_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO45_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO45_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO45_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO45_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO45_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO45_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO45_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO45_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO45_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO45_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO45_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO45_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO45_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO45_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO45_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO45_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO45_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO45_FILTER_EN = 0x8000

	// GPIO46: Configuration register for pin GPIO46
	// Position of MCU_OE field.
	IO_MUX_GPIO46_MCU_OE_Pos = 0x0
	// Bit mask of MCU_OE field.
	IO_MUX_GPIO46_MCU_OE_Msk = 0x1
	// Bit MCU_OE.
	IO_MUX_GPIO46_MCU_OE = 0x1
	// Position of SLP_SEL field.
	IO_MUX_GPIO46_SLP_SEL_Pos = 0x1
	// Bit mask of SLP_SEL field.
	IO_MUX_GPIO46_SLP_SEL_Msk = 0x2
	// Bit SLP_SEL.
	IO_MUX_GPIO46_SLP_SEL = 0x2
	// Position of MCU_WPD field.
	IO_MUX_GPIO46_MCU_WPD_Pos = 0x2
	// Bit mask of MCU_WPD field.
	IO_MUX_GPIO46_MCU_WPD_Msk = 0x4
	// Bit MCU_WPD.
	IO_MUX_GPIO46_MCU_WPD = 0x4
	// Position of MCU_WPU field.
	IO_MUX_GPIO46_MCU_WPU_Pos = 0x3
	// Bit mask of MCU_WPU field.
	IO_MUX_GPIO46_MCU_WPU_Msk = 0x8
	// Bit MCU_WPU.
	IO_MUX_GPIO46_MCU_WPU = 0x8
	// Position of MCU_IE field.
	IO_MUX_GPIO46_MCU_IE_Pos = 0x4
	// Bit mask of MCU_IE field.
	IO_MUX_GPIO46_MCU_IE_Msk = 0x10
	// Bit MCU_IE.
	IO_MUX_GPIO46_MCU_IE = 0x10
	// Position of FUN_WPD field.
	IO_MUX_GPIO46_FUN_WPD_Pos = 0x7
	// Bit mask of FUN_WPD field.
	IO_MUX_GPIO46_FUN_WPD_Msk = 0x80
	// Bit FUN_WPD.
	IO_MUX_GPIO46_FUN_WPD = 0x80
	// Position of FUN_WPU field.
	IO_MUX_GPIO46_FUN_WPU_Pos = 0x8
	// Bit mask of FUN_WPU field.
	IO_MUX_GPIO46_FUN_WPU_Msk = 0x100
	// Bit FUN_WPU.
	IO_MUX_GPIO46_FUN_WPU = 0x100
	// Position of FUN_IE field.
	IO_MUX_GPIO46_FUN_IE_Pos = 0x9
	// Bit mask of FUN_IE field.
	IO_MUX_GPIO46_FUN_IE_Msk = 0x200
	// Bit FUN_IE.
	IO_MUX_GPIO46_FUN_IE = 0x200
	// Position of FUN_DRV field.
	IO_MUX_GPIO46_FUN_DRV_Pos = 0xa
	// Bit mask of FUN_DRV field.
	IO_MUX_GPIO46_FUN_DRV_Msk = 0xc00
	// Position of MCU_SEL field.
	IO_MUX_GPIO46_MCU_SEL_Pos = 0xc
	// Bit mask of MCU_SEL field.
	IO_MUX_GPIO46_MCU_SEL_Msk = 0x7000
	// Position of FILTER_EN field.
	IO_MUX_GPIO46_FILTER_EN_Pos = 0xf
	// Bit mask of FILTER_EN field.
	IO_MUX_GPIO46_FILTER_EN_Msk = 0x8000
	// Bit FILTER_EN.
	IO_MUX_GPIO46_FILTER_EN = 0x8000

	// DATE: Version control register
	// Position of VERSION field.
	IO_MUX_DATE_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	IO_MUX_DATE_VERSION_Msk = 0xfffffff
)

// Constants for LEDC: LED Control PWM (Pulse Width Modulation)
const (
	// CH0_CONF0: Configuration register 0 for channel %s
	// Position of TIMER_SEL field.
	LEDC_CH_CONF0_TIMER_SEL_Pos = 0x0
	// Bit mask of TIMER_SEL field.
	LEDC_CH_CONF0_TIMER_SEL_Msk = 0x3
	// Position of SIG_OUT_EN field.
	LEDC_CH_CONF0_SIG_OUT_EN_Pos = 0x2
	// Bit mask of SIG_OUT_EN field.
	LEDC_CH_CONF0_SIG_OUT_EN_Msk = 0x4
	// Bit SIG_OUT_EN.
	LEDC_CH_CONF0_SIG_OUT_EN = 0x4
	// Position of IDLE_LV field.
	LEDC_CH_CONF0_IDLE_LV_Pos = 0x3
	// Bit mask of IDLE_LV field.
	LEDC_CH_CONF0_IDLE_LV_Msk = 0x8
	// Bit IDLE_LV.
	LEDC_CH_CONF0_IDLE_LV = 0x8
	// Position of PARA_UP field.
	LEDC_CH_CONF0_PARA_UP_Pos = 0x4
	// Bit mask of PARA_UP field.
	LEDC_CH_CONF0_PARA_UP_Msk = 0x10
	// Bit PARA_UP.
	LEDC_CH_CONF0_PARA_UP = 0x10
	// Position of OVF_NUM field.
	LEDC_CH_CONF0_OVF_NUM_Pos = 0x5
	// Bit mask of OVF_NUM field.
	LEDC_CH_CONF0_OVF_NUM_Msk = 0x7fe0
	// Position of OVF_CNT_EN field.
	LEDC_CH_CONF0_OVF_CNT_EN_Pos = 0xf
	// Bit mask of OVF_CNT_EN field.
	LEDC_CH_CONF0_OVF_CNT_EN_Msk = 0x8000
	// Bit OVF_CNT_EN.
	LEDC_CH_CONF0_OVF_CNT_EN = 0x8000
	// Position of OVF_CNT_RESET field.
	LEDC_CH_CONF0_OVF_CNT_RESET_Pos = 0x10
	// Bit mask of OVF_CNT_RESET field.
	LEDC_CH_CONF0_OVF_CNT_RESET_Msk = 0x10000
	// Bit OVF_CNT_RESET.
	LEDC_CH_CONF0_OVF_CNT_RESET = 0x10000
	// Position of OVF_CNT_RESET_ST field.
	LEDC_CH_CONF0_OVF_CNT_RESET_ST_Pos = 0x11
	// Bit mask of OVF_CNT_RESET_ST field.
	LEDC_CH_CONF0_OVF_CNT_RESET_ST_Msk = 0x20000
	// Bit OVF_CNT_RESET_ST.
	LEDC_CH_CONF0_OVF_CNT_RESET_ST = 0x20000

	// CH0_HPOINT: High point register for channel %s
	// Position of HPOINT field.
	LEDC_CH_HPOINT_HPOINT_Pos = 0x0
	// Bit mask of HPOINT field.
	LEDC_CH_HPOINT_HPOINT_Msk = 0x3fff

	// CH0_DUTY: Initial duty cycle for channel %s
	// Position of DUTY field.
	LEDC_CH_DUTY_DUTY_Pos = 0x0
	// Bit mask of DUTY field.
	LEDC_CH_DUTY_DUTY_Msk = 0x7ffff

	// CH0_CONF1: Configuration register 1 for channel %s
	// Position of DUTY_SCALE field.
	LEDC_CH_CONF1_DUTY_SCALE_Pos = 0x0
	// Bit mask of DUTY_SCALE field.
	LEDC_CH_CONF1_DUTY_SCALE_Msk = 0x3ff
	// Position of DUTY_CYCLE field.
	LEDC_CH_CONF1_DUTY_CYCLE_Pos = 0xa
	// Bit mask of DUTY_CYCLE field.
	LEDC_CH_CONF1_DUTY_CYCLE_Msk = 0xffc00
	// Position of DUTY_NUM field.
	LEDC_CH_CONF1_DUTY_NUM_Pos = 0x14
	// Bit mask of DUTY_NUM field.
	LEDC_CH_CONF1_DUTY_NUM_Msk = 0x3ff00000
	// Position of DUTY_INC field.
	LEDC_CH_CONF1_DUTY_INC_Pos = 0x1e
	// Bit mask of DUTY_INC field.
	LEDC_CH_CONF1_DUTY_INC_Msk = 0x40000000
	// Bit DUTY_INC.
	LEDC_CH_CONF1_DUTY_INC = 0x40000000
	// Position of DUTY_START field.
	LEDC_CH_CONF1_DUTY_START_Pos = 0x1f
	// Bit mask of DUTY_START field.
	LEDC_CH_CONF1_DUTY_START_Msk = 0x80000000
	// Bit DUTY_START.
	LEDC_CH_CONF1_DUTY_START = 0x80000000

	// CH0_DUTY_R: Current duty cycle for channel %s
	// Position of DUTY_R field.
	LEDC_CH_DUTY_R_DUTY_R_Pos = 0x0
	// Bit mask of DUTY_R field.
	LEDC_CH_DUTY_R_DUTY_R_Msk = 0x7ffff

	// TIMER0_CONF: Timer %s configuration
	// Position of DUTY_RES field.
	LEDC_TIMER_CONF_DUTY_RES_Pos = 0x0
	// Bit mask of DUTY_RES field.
	LEDC_TIMER_CONF_DUTY_RES_Msk = 0xf
	// Position of CLK_DIV field.
	LEDC_TIMER_CONF_CLK_DIV_Pos = 0x4
	// Bit mask of CLK_DIV field.
	LEDC_TIMER_CONF_CLK_DIV_Msk = 0x3ffff0
	// Position of PAUSE field.
	LEDC_TIMER_CONF_PAUSE_Pos = 0x16
	// Bit mask of PAUSE field.
	LEDC_TIMER_CONF_PAUSE_Msk = 0x400000
	// Bit PAUSE.
	LEDC_TIMER_CONF_PAUSE = 0x400000
	// Position of RST field.
	LEDC_TIMER_CONF_RST_Pos = 0x17
	// Bit mask of RST field.
	LEDC_TIMER_CONF_RST_Msk = 0x800000
	// Bit RST.
	LEDC_TIMER_CONF_RST = 0x800000
	// Position of TICK_SEL field.
	LEDC_TIMER_CONF_TICK_SEL_Pos = 0x18
	// Bit mask of TICK_SEL field.
	LEDC_TIMER_CONF_TICK_SEL_Msk = 0x1000000
	// Bit TICK_SEL.
	LEDC_TIMER_CONF_TICK_SEL = 0x1000000
	// Position of PARA_UP field.
	LEDC_TIMER_CONF_PARA_UP_Pos = 0x19
	// Bit mask of PARA_UP field.
	LEDC_TIMER_CONF_PARA_UP_Msk = 0x2000000
	// Bit PARA_UP.
	LEDC_TIMER_CONF_PARA_UP = 0x2000000

	// TIMER0_VALUE: Timer %s current counter value
	// Position of CNT field.
	LEDC_TIMER_VALUE_CNT_Pos = 0x0
	// Bit mask of CNT field.
	LEDC_TIMER_VALUE_CNT_Msk = 0x3fff

	// INT_RAW: Raw interrupt status
	// Position of TIMER0_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW_Msk = 0x1
	// Bit TIMER0_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER0_OVF_INT_RAW = 0x1
	// Position of TIMER1_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW_Msk = 0x2
	// Bit TIMER1_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER1_OVF_INT_RAW = 0x2
	// Position of TIMER2_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW_Msk = 0x4
	// Bit TIMER2_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER2_OVF_INT_RAW = 0x4
	// Position of TIMER3_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_RAW field.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW_Msk = 0x8
	// Bit TIMER3_OVF_INT_RAW.
	LEDC_INT_RAW_TIMER3_OVF_INT_RAW = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH0_INT_RAW = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH1_INT_RAW = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH2_INT_RAW = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH3_INT_RAW = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH4_INT_RAW = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH5_INT_RAW = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH6_INT_RAW_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH6_INT_RAW_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH6_INT_RAW = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH7_INT_RAW_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_RAW field.
	LEDC_INT_RAW_DUTY_CHNG_END_CH7_INT_RAW_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_RAW.
	LEDC_INT_RAW_DUTY_CHNG_END_CH7_INT_RAW = 0x800
	// Position of OVF_CNT_CH0_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH0_INT_RAW = 0x1000
	// Position of OVF_CNT_CH1_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH1_INT_RAW = 0x2000
	// Position of OVF_CNT_CH2_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH2_INT_RAW = 0x4000
	// Position of OVF_CNT_CH3_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH3_INT_RAW = 0x8000
	// Position of OVF_CNT_CH4_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH4_INT_RAW = 0x10000
	// Position of OVF_CNT_CH5_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH5_INT_RAW = 0x20000
	// Position of OVF_CNT_CH6_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH6_INT_RAW_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH6_INT_RAW_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH6_INT_RAW = 0x40000
	// Position of OVF_CNT_CH7_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH7_INT_RAW_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_RAW field.
	LEDC_INT_RAW_OVF_CNT_CH7_INT_RAW_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_RAW.
	LEDC_INT_RAW_OVF_CNT_CH7_INT_RAW = 0x80000

	// INT_ST: Masked interrupt status
	// Position of TIMER0_OVF_INT_ST field.
	LEDC_INT_ST_TIMER0_OVF_INT_ST_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_ST field.
	LEDC_INT_ST_TIMER0_OVF_INT_ST_Msk = 0x1
	// Bit TIMER0_OVF_INT_ST.
	LEDC_INT_ST_TIMER0_OVF_INT_ST = 0x1
	// Position of TIMER1_OVF_INT_ST field.
	LEDC_INT_ST_TIMER1_OVF_INT_ST_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_ST field.
	LEDC_INT_ST_TIMER1_OVF_INT_ST_Msk = 0x2
	// Bit TIMER1_OVF_INT_ST.
	LEDC_INT_ST_TIMER1_OVF_INT_ST = 0x2
	// Position of TIMER2_OVF_INT_ST field.
	LEDC_INT_ST_TIMER2_OVF_INT_ST_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_ST field.
	LEDC_INT_ST_TIMER2_OVF_INT_ST_Msk = 0x4
	// Bit TIMER2_OVF_INT_ST.
	LEDC_INT_ST_TIMER2_OVF_INT_ST = 0x4
	// Position of TIMER3_OVF_INT_ST field.
	LEDC_INT_ST_TIMER3_OVF_INT_ST_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_ST field.
	LEDC_INT_ST_TIMER3_OVF_INT_ST_Msk = 0x8
	// Bit TIMER3_OVF_INT_ST.
	LEDC_INT_ST_TIMER3_OVF_INT_ST = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH0_INT_ST = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH1_INT_ST = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH2_INT_ST = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH3_INT_ST = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH4_INT_ST = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH5_INT_ST = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH6_INT_ST_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH6_INT_ST_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH6_INT_ST = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH7_INT_ST_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_ST field.
	LEDC_INT_ST_DUTY_CHNG_END_CH7_INT_ST_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_ST.
	LEDC_INT_ST_DUTY_CHNG_END_CH7_INT_ST = 0x800
	// Position of OVF_CNT_CH0_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH0_INT_ST = 0x1000
	// Position of OVF_CNT_CH1_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH1_INT_ST = 0x2000
	// Position of OVF_CNT_CH2_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH2_INT_ST = 0x4000
	// Position of OVF_CNT_CH3_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH3_INT_ST = 0x8000
	// Position of OVF_CNT_CH4_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH4_INT_ST = 0x10000
	// Position of OVF_CNT_CH5_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH5_INT_ST = 0x20000
	// Position of OVF_CNT_CH6_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH6_INT_ST_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH6_INT_ST_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH6_INT_ST = 0x40000
	// Position of OVF_CNT_CH7_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH7_INT_ST_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_ST field.
	LEDC_INT_ST_OVF_CNT_CH7_INT_ST_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_ST.
	LEDC_INT_ST_OVF_CNT_CH7_INT_ST = 0x80000

	// INT_ENA: Interrupt enable bits
	// Position of TIMER0_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA_Msk = 0x1
	// Bit TIMER0_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER0_OVF_INT_ENA = 0x1
	// Position of TIMER1_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA_Msk = 0x2
	// Bit TIMER1_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER1_OVF_INT_ENA = 0x2
	// Position of TIMER2_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA_Msk = 0x4
	// Bit TIMER2_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER2_OVF_INT_ENA = 0x4
	// Position of TIMER3_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_ENA field.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA_Msk = 0x8
	// Bit TIMER3_OVF_INT_ENA.
	LEDC_INT_ENA_TIMER3_OVF_INT_ENA = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH0_INT_ENA = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH1_INT_ENA = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH2_INT_ENA = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH3_INT_ENA = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH4_INT_ENA = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH5_INT_ENA = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH6_INT_ENA_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH6_INT_ENA_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH6_INT_ENA = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH7_INT_ENA_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_ENA field.
	LEDC_INT_ENA_DUTY_CHNG_END_CH7_INT_ENA_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_ENA.
	LEDC_INT_ENA_DUTY_CHNG_END_CH7_INT_ENA = 0x800
	// Position of OVF_CNT_CH0_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH0_INT_ENA = 0x1000
	// Position of OVF_CNT_CH1_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH1_INT_ENA = 0x2000
	// Position of OVF_CNT_CH2_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH2_INT_ENA = 0x4000
	// Position of OVF_CNT_CH3_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH3_INT_ENA = 0x8000
	// Position of OVF_CNT_CH4_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH4_INT_ENA = 0x10000
	// Position of OVF_CNT_CH5_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH5_INT_ENA = 0x20000
	// Position of OVF_CNT_CH6_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH6_INT_ENA_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH6_INT_ENA_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH6_INT_ENA = 0x40000
	// Position of OVF_CNT_CH7_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH7_INT_ENA_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_ENA field.
	LEDC_INT_ENA_OVF_CNT_CH7_INT_ENA_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_ENA.
	LEDC_INT_ENA_OVF_CNT_CH7_INT_ENA = 0x80000

	// INT_CLR: Interrupt clear bits
	// Position of TIMER0_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR_Pos = 0x0
	// Bit mask of TIMER0_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR_Msk = 0x1
	// Bit TIMER0_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER0_OVF_INT_CLR = 0x1
	// Position of TIMER1_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR_Pos = 0x1
	// Bit mask of TIMER1_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR_Msk = 0x2
	// Bit TIMER1_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER1_OVF_INT_CLR = 0x2
	// Position of TIMER2_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR_Pos = 0x2
	// Bit mask of TIMER2_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR_Msk = 0x4
	// Bit TIMER2_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER2_OVF_INT_CLR = 0x4
	// Position of TIMER3_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR_Pos = 0x3
	// Bit mask of TIMER3_OVF_INT_CLR field.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR_Msk = 0x8
	// Bit TIMER3_OVF_INT_CLR.
	LEDC_INT_CLR_TIMER3_OVF_INT_CLR = 0x8
	// Position of DUTY_CHNG_END_CH0_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR_Pos = 0x4
	// Bit mask of DUTY_CHNG_END_CH0_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR_Msk = 0x10
	// Bit DUTY_CHNG_END_CH0_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH0_INT_CLR = 0x10
	// Position of DUTY_CHNG_END_CH1_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR_Pos = 0x5
	// Bit mask of DUTY_CHNG_END_CH1_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR_Msk = 0x20
	// Bit DUTY_CHNG_END_CH1_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH1_INT_CLR = 0x20
	// Position of DUTY_CHNG_END_CH2_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR_Pos = 0x6
	// Bit mask of DUTY_CHNG_END_CH2_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR_Msk = 0x40
	// Bit DUTY_CHNG_END_CH2_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH2_INT_CLR = 0x40
	// Position of DUTY_CHNG_END_CH3_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR_Pos = 0x7
	// Bit mask of DUTY_CHNG_END_CH3_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR_Msk = 0x80
	// Bit DUTY_CHNG_END_CH3_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH3_INT_CLR = 0x80
	// Position of DUTY_CHNG_END_CH4_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR_Pos = 0x8
	// Bit mask of DUTY_CHNG_END_CH4_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR_Msk = 0x100
	// Bit DUTY_CHNG_END_CH4_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH4_INT_CLR = 0x100
	// Position of DUTY_CHNG_END_CH5_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR_Pos = 0x9
	// Bit mask of DUTY_CHNG_END_CH5_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR_Msk = 0x200
	// Bit DUTY_CHNG_END_CH5_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH5_INT_CLR = 0x200
	// Position of DUTY_CHNG_END_CH6_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH6_INT_CLR_Pos = 0xa
	// Bit mask of DUTY_CHNG_END_CH6_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH6_INT_CLR_Msk = 0x400
	// Bit DUTY_CHNG_END_CH6_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH6_INT_CLR = 0x400
	// Position of DUTY_CHNG_END_CH7_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH7_INT_CLR_Pos = 0xb
	// Bit mask of DUTY_CHNG_END_CH7_INT_CLR field.
	LEDC_INT_CLR_DUTY_CHNG_END_CH7_INT_CLR_Msk = 0x800
	// Bit DUTY_CHNG_END_CH7_INT_CLR.
	LEDC_INT_CLR_DUTY_CHNG_END_CH7_INT_CLR = 0x800
	// Position of OVF_CNT_CH0_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR_Pos = 0xc
	// Bit mask of OVF_CNT_CH0_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR_Msk = 0x1000
	// Bit OVF_CNT_CH0_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH0_INT_CLR = 0x1000
	// Position of OVF_CNT_CH1_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR_Pos = 0xd
	// Bit mask of OVF_CNT_CH1_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR_Msk = 0x2000
	// Bit OVF_CNT_CH1_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH1_INT_CLR = 0x2000
	// Position of OVF_CNT_CH2_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR_Pos = 0xe
	// Bit mask of OVF_CNT_CH2_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR_Msk = 0x4000
	// Bit OVF_CNT_CH2_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH2_INT_CLR = 0x4000
	// Position of OVF_CNT_CH3_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR_Pos = 0xf
	// Bit mask of OVF_CNT_CH3_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR_Msk = 0x8000
	// Bit OVF_CNT_CH3_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH3_INT_CLR = 0x8000
	// Position of OVF_CNT_CH4_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR_Pos = 0x10
	// Bit mask of OVF_CNT_CH4_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR_Msk = 0x10000
	// Bit OVF_CNT_CH4_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH4_INT_CLR = 0x10000
	// Position of OVF_CNT_CH5_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR_Pos = 0x11
	// Bit mask of OVF_CNT_CH5_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR_Msk = 0x20000
	// Bit OVF_CNT_CH5_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH5_INT_CLR = 0x20000
	// Position of OVF_CNT_CH6_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH6_INT_CLR_Pos = 0x12
	// Bit mask of OVF_CNT_CH6_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH6_INT_CLR_Msk = 0x40000
	// Bit OVF_CNT_CH6_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH6_INT_CLR = 0x40000
	// Position of OVF_CNT_CH7_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH7_INT_CLR_Pos = 0x13
	// Bit mask of OVF_CNT_CH7_INT_CLR field.
	LEDC_INT_CLR_OVF_CNT_CH7_INT_CLR_Msk = 0x80000
	// Bit OVF_CNT_CH7_INT_CLR.
	LEDC_INT_CLR_OVF_CNT_CH7_INT_CLR = 0x80000

	// CONF: Global ledc configuration register
	// Position of APB_CLK_SEL field.
	LEDC_CONF_APB_CLK_SEL_Pos = 0x0
	// Bit mask of APB_CLK_SEL field.
	LEDC_CONF_APB_CLK_SEL_Msk = 0x3
	// Position of CLK_EN field.
	LEDC_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	LEDC_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	LEDC_CONF_CLK_EN = 0x80000000

	// DATE: Version control register
	// Position of DATE field.
	LEDC_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	LEDC_DATE_DATE_Msk = 0xffffffff
)

// Constants for PCNT: Pulse Count Controller
const (
	// U0_CONF0: Configuration register 0 for unit %s
	// Position of FILTER_THRES field.
	PCNT_U_CONF0_FILTER_THRES_Pos = 0x0
	// Bit mask of FILTER_THRES field.
	PCNT_U_CONF0_FILTER_THRES_Msk = 0x3ff
	// Position of FILTER_EN field.
	PCNT_U_CONF0_FILTER_EN_Pos = 0xa
	// Bit mask of FILTER_EN field.
	PCNT_U_CONF0_FILTER_EN_Msk = 0x400
	// Bit FILTER_EN.
	PCNT_U_CONF0_FILTER_EN = 0x400
	// Position of THR_ZERO_EN field.
	PCNT_U_CONF0_THR_ZERO_EN_Pos = 0xb
	// Bit mask of THR_ZERO_EN field.
	PCNT_U_CONF0_THR_ZERO_EN_Msk = 0x800
	// Bit THR_ZERO_EN.
	PCNT_U_CONF0_THR_ZERO_EN = 0x800
	// Position of THR_H_LIM_EN field.
	PCNT_U_CONF0_THR_H_LIM_EN_Pos = 0xc
	// Bit mask of THR_H_LIM_EN field.
	PCNT_U_CONF0_THR_H_LIM_EN_Msk = 0x1000
	// Bit THR_H_LIM_EN.
	PCNT_U_CONF0_THR_H_LIM_EN = 0x1000
	// Position of THR_L_LIM_EN field.
	PCNT_U_CONF0_THR_L_LIM_EN_Pos = 0xd
	// Bit mask of THR_L_LIM_EN field.
	PCNT_U_CONF0_THR_L_LIM_EN_Msk = 0x2000
	// Bit THR_L_LIM_EN.
	PCNT_U_CONF0_THR_L_LIM_EN = 0x2000
	// Position of THR_THRES0_EN field.
	PCNT_U_CONF0_THR_THRES0_EN_Pos = 0xe
	// Bit mask of THR_THRES0_EN field.
	PCNT_U_CONF0_THR_THRES0_EN_Msk = 0x4000
	// Bit THR_THRES0_EN.
	PCNT_U_CONF0_THR_THRES0_EN = 0x4000
	// Position of THR_THRES1_EN field.
	PCNT_U_CONF0_THR_THRES1_EN_Pos = 0xf
	// Bit mask of THR_THRES1_EN field.
	PCNT_U_CONF0_THR_THRES1_EN_Msk = 0x8000
	// Bit THR_THRES1_EN.
	PCNT_U_CONF0_THR_THRES1_EN = 0x8000
	// Position of CH0_NEG_MODE field.
	PCNT_U_CONF0_CH0_NEG_MODE_Pos = 0x10
	// Bit mask of CH0_NEG_MODE field.
	PCNT_U_CONF0_CH0_NEG_MODE_Msk = 0x30000
	// Position of CH0_POS_MODE field.
	PCNT_U_CONF0_CH0_POS_MODE_Pos = 0x12
	// Bit mask of CH0_POS_MODE field.
	PCNT_U_CONF0_CH0_POS_MODE_Msk = 0xc0000
	// Position of CH0_HCTRL_MODE field.
	PCNT_U_CONF0_CH0_HCTRL_MODE_Pos = 0x14
	// Bit mask of CH0_HCTRL_MODE field.
	PCNT_U_CONF0_CH0_HCTRL_MODE_Msk = 0x300000
	// Position of CH0_LCTRL_MODE field.
	PCNT_U_CONF0_CH0_LCTRL_MODE_Pos = 0x16
	// Bit mask of CH0_LCTRL_MODE field.
	PCNT_U_CONF0_CH0_LCTRL_MODE_Msk = 0xc00000
	// Position of CH1_NEG_MODE field.
	PCNT_U_CONF0_CH1_NEG_MODE_Pos = 0x18
	// Bit mask of CH1_NEG_MODE field.
	PCNT_U_CONF0_CH1_NEG_MODE_Msk = 0x3000000
	// Position of CH1_POS_MODE field.
	PCNT_U_CONF0_CH1_POS_MODE_Pos = 0x1a
	// Bit mask of CH1_POS_MODE field.
	PCNT_U_CONF0_CH1_POS_MODE_Msk = 0xc000000
	// Position of CH1_HCTRL_MODE field.
	PCNT_U_CONF0_CH1_HCTRL_MODE_Pos = 0x1c
	// Bit mask of CH1_HCTRL_MODE field.
	PCNT_U_CONF0_CH1_HCTRL_MODE_Msk = 0x30000000
	// Position of CH1_LCTRL_MODE field.
	PCNT_U_CONF0_CH1_LCTRL_MODE_Pos = 0x1e
	// Bit mask of CH1_LCTRL_MODE field.
	PCNT_U_CONF0_CH1_LCTRL_MODE_Msk = 0xc0000000

	// U0_CONF1: Configuration register 1 for unit %s
	// Position of CNT_THRES0 field.
	PCNT_U_CONF1_CNT_THRES0_Pos = 0x0
	// Bit mask of CNT_THRES0 field.
	PCNT_U_CONF1_CNT_THRES0_Msk = 0xffff
	// Position of CNT_THRES1 field.
	PCNT_U_CONF1_CNT_THRES1_Pos = 0x10
	// Bit mask of CNT_THRES1 field.
	PCNT_U_CONF1_CNT_THRES1_Msk = 0xffff0000

	// U0_CONF2: Configuration register 2 for unit %s
	// Position of CNT_H_LIM field.
	PCNT_U_CONF2_CNT_H_LIM_Pos = 0x0
	// Bit mask of CNT_H_LIM field.
	PCNT_U_CONF2_CNT_H_LIM_Msk = 0xffff
	// Position of CNT_L_LIM field.
	PCNT_U_CONF2_CNT_L_LIM_Pos = 0x10
	// Bit mask of CNT_L_LIM field.
	PCNT_U_CONF2_CNT_L_LIM_Msk = 0xffff0000

	// U0_CNT: Counter value for unit %s
	// Position of CNT field.
	PCNT_U_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PCNT_U_CNT_CNT_Msk = 0xffff

	// INT_RAW: Interrupt raw status register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_RAW_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_RAW_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_RAW_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_RAW_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_RAW_CNT_THR_EVENT_U3 = 0x8

	// INT_ST: Interrupt status register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_ST_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_ST_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_ST_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_ST_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_ST_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_ST_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_ST_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_ST_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_ST_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_ST_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_ST_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_ST_CNT_THR_EVENT_U3 = 0x8

	// INT_ENA: Interrupt enable register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_ENA_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_ENA_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_ENA_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_ENA_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_ENA_CNT_THR_EVENT_U3 = 0x8

	// INT_CLR: Interrupt clear register
	// Position of CNT_THR_EVENT_U0 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_Pos = 0x0
	// Bit mask of CNT_THR_EVENT_U0 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U0_Msk = 0x1
	// Bit CNT_THR_EVENT_U0.
	PCNT_INT_CLR_CNT_THR_EVENT_U0 = 0x1
	// Position of CNT_THR_EVENT_U1 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_Pos = 0x1
	// Bit mask of CNT_THR_EVENT_U1 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U1_Msk = 0x2
	// Bit CNT_THR_EVENT_U1.
	PCNT_INT_CLR_CNT_THR_EVENT_U1 = 0x2
	// Position of CNT_THR_EVENT_U2 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_Pos = 0x2
	// Bit mask of CNT_THR_EVENT_U2 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U2_Msk = 0x4
	// Bit CNT_THR_EVENT_U2.
	PCNT_INT_CLR_CNT_THR_EVENT_U2 = 0x4
	// Position of CNT_THR_EVENT_U3 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_Pos = 0x3
	// Bit mask of CNT_THR_EVENT_U3 field.
	PCNT_INT_CLR_CNT_THR_EVENT_U3_Msk = 0x8
	// Bit CNT_THR_EVENT_U3.
	PCNT_INT_CLR_CNT_THR_EVENT_U3 = 0x8

	// U0_STATUS: PNCT UNIT%s status register
	// Position of ZERO_MODE field.
	PCNT_U_STATUS_ZERO_MODE_Pos = 0x0
	// Bit mask of ZERO_MODE field.
	PCNT_U_STATUS_ZERO_MODE_Msk = 0x3
	// Position of THRES1 field.
	PCNT_U_STATUS_THRES1_Pos = 0x2
	// Bit mask of THRES1 field.
	PCNT_U_STATUS_THRES1_Msk = 0x4
	// Bit THRES1.
	PCNT_U_STATUS_THRES1 = 0x4
	// Position of THRES0 field.
	PCNT_U_STATUS_THRES0_Pos = 0x3
	// Bit mask of THRES0 field.
	PCNT_U_STATUS_THRES0_Msk = 0x8
	// Bit THRES0.
	PCNT_U_STATUS_THRES0 = 0x8
	// Position of L_LIM field.
	PCNT_U_STATUS_L_LIM_Pos = 0x4
	// Bit mask of L_LIM field.
	PCNT_U_STATUS_L_LIM_Msk = 0x10
	// Bit L_LIM.
	PCNT_U_STATUS_L_LIM = 0x10
	// Position of H_LIM field.
	PCNT_U_STATUS_H_LIM_Pos = 0x5
	// Bit mask of H_LIM field.
	PCNT_U_STATUS_H_LIM_Msk = 0x20
	// Bit H_LIM.
	PCNT_U_STATUS_H_LIM = 0x20
	// Position of ZERO field.
	PCNT_U_STATUS_ZERO_Pos = 0x6
	// Bit mask of ZERO field.
	PCNT_U_STATUS_ZERO_Msk = 0x40
	// Bit ZERO.
	PCNT_U_STATUS_ZERO = 0x40

	// CTRL: Control register for all counters
	// Position of CNT_RST_U0 field.
	PCNT_CTRL_CNT_RST_U0_Pos = 0x0
	// Bit mask of CNT_RST_U0 field.
	PCNT_CTRL_CNT_RST_U0_Msk = 0x1
	// Bit CNT_RST_U0.
	PCNT_CTRL_CNT_RST_U0 = 0x1
	// Position of CNT_PAUSE_U0 field.
	PCNT_CTRL_CNT_PAUSE_U0_Pos = 0x1
	// Bit mask of CNT_PAUSE_U0 field.
	PCNT_CTRL_CNT_PAUSE_U0_Msk = 0x2
	// Bit CNT_PAUSE_U0.
	PCNT_CTRL_CNT_PAUSE_U0 = 0x2
	// Position of CNT_RST_U1 field.
	PCNT_CTRL_CNT_RST_U1_Pos = 0x2
	// Bit mask of CNT_RST_U1 field.
	PCNT_CTRL_CNT_RST_U1_Msk = 0x4
	// Bit CNT_RST_U1.
	PCNT_CTRL_CNT_RST_U1 = 0x4
	// Position of CNT_PAUSE_U1 field.
	PCNT_CTRL_CNT_PAUSE_U1_Pos = 0x3
	// Bit mask of CNT_PAUSE_U1 field.
	PCNT_CTRL_CNT_PAUSE_U1_Msk = 0x8
	// Bit CNT_PAUSE_U1.
	PCNT_CTRL_CNT_PAUSE_U1 = 0x8
	// Position of CNT_RST_U2 field.
	PCNT_CTRL_CNT_RST_U2_Pos = 0x4
	// Bit mask of CNT_RST_U2 field.
	PCNT_CTRL_CNT_RST_U2_Msk = 0x10
	// Bit CNT_RST_U2.
	PCNT_CTRL_CNT_RST_U2 = 0x10
	// Position of CNT_PAUSE_U2 field.
	PCNT_CTRL_CNT_PAUSE_U2_Pos = 0x5
	// Bit mask of CNT_PAUSE_U2 field.
	PCNT_CTRL_CNT_PAUSE_U2_Msk = 0x20
	// Bit CNT_PAUSE_U2.
	PCNT_CTRL_CNT_PAUSE_U2 = 0x20
	// Position of CNT_RST_U3 field.
	PCNT_CTRL_CNT_RST_U3_Pos = 0x6
	// Bit mask of CNT_RST_U3 field.
	PCNT_CTRL_CNT_RST_U3_Msk = 0x40
	// Bit CNT_RST_U3.
	PCNT_CTRL_CNT_RST_U3 = 0x40
	// Position of CNT_PAUSE_U3 field.
	PCNT_CTRL_CNT_PAUSE_U3_Pos = 0x7
	// Bit mask of CNT_PAUSE_U3 field.
	PCNT_CTRL_CNT_PAUSE_U3_Msk = 0x80
	// Bit CNT_PAUSE_U3.
	PCNT_CTRL_CNT_PAUSE_U3 = 0x80
	// Position of CLK_EN field.
	PCNT_CTRL_CLK_EN_Pos = 0x10
	// Bit mask of CLK_EN field.
	PCNT_CTRL_CLK_EN_Msk = 0x10000
	// Bit CLK_EN.
	PCNT_CTRL_CLK_EN = 0x10000

	// DATE: PCNT version control register
	// Position of DATE field.
	PCNT_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PCNT_DATE_DATE_Msk = 0xffffffff
)

// Constants for PMS: Permissions Controller
const (
	// SDIO_0: SDIO permission control register 0.
	// Position of SDIO_LOCK field.
	PMS_SDIO_0_SDIO_LOCK_Pos = 0x0
	// Bit mask of SDIO_LOCK field.
	PMS_SDIO_0_SDIO_LOCK_Msk = 0x1
	// Bit SDIO_LOCK.
	PMS_SDIO_0_SDIO_LOCK = 0x1

	// SDIO_1: SDIO permission control register 1.
	// Position of SDIO_DISABLE field.
	PMS_SDIO_1_SDIO_DISABLE_Pos = 0x0
	// Bit mask of SDIO_DISABLE field.
	PMS_SDIO_1_SDIO_DISABLE_Msk = 0x1
	// Bit SDIO_DISABLE.
	PMS_SDIO_1_SDIO_DISABLE = 0x1

	// MAC_DUMP_0: MAC dump permission control register 0.
	// Position of MAC_DUMP_LOCK field.
	PMS_MAC_DUMP_0_MAC_DUMP_LOCK_Pos = 0x0
	// Bit mask of MAC_DUMP_LOCK field.
	PMS_MAC_DUMP_0_MAC_DUMP_LOCK_Msk = 0x1
	// Bit MAC_DUMP_LOCK.
	PMS_MAC_DUMP_0_MAC_DUMP_LOCK = 0x1

	// MAC_DUMP_1: MAC dump permission control register 1.
	// Position of MAC_DUMP_CONNECT field.
	PMS_MAC_DUMP_1_MAC_DUMP_CONNECT_Pos = 0x0
	// Bit mask of MAC_DUMP_CONNECT field.
	PMS_MAC_DUMP_1_MAC_DUMP_CONNECT_Msk = 0xfff

	// PRO_IRAM0_0: IBUS permission control register 0.
	// Position of PRO_IRAM0_LOCK field.
	PMS_PRO_IRAM0_0_PRO_IRAM0_LOCK_Pos = 0x0
	// Bit mask of PRO_IRAM0_LOCK field.
	PMS_PRO_IRAM0_0_PRO_IRAM0_LOCK_Msk = 0x1
	// Bit PRO_IRAM0_LOCK.
	PMS_PRO_IRAM0_0_PRO_IRAM0_LOCK = 0x1

	// PRO_IRAM0_1: IBUS permission control register 1.
	// Position of PRO_IRAM0_SRAM_0_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_F_Pos = 0x0
	// Bit mask of PRO_IRAM0_SRAM_0_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_F_Msk = 0x1
	// Bit PRO_IRAM0_SRAM_0_F.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_F = 0x1
	// Position of PRO_IRAM0_SRAM_0_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_R_Pos = 0x1
	// Bit mask of PRO_IRAM0_SRAM_0_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_R_Msk = 0x2
	// Bit PRO_IRAM0_SRAM_0_R.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_R = 0x2
	// Position of PRO_IRAM0_SRAM_0_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_W_Pos = 0x2
	// Bit mask of PRO_IRAM0_SRAM_0_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_W_Msk = 0x4
	// Bit PRO_IRAM0_SRAM_0_W.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_0_W = 0x4
	// Position of PRO_IRAM0_SRAM_1_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_F_Pos = 0x3
	// Bit mask of PRO_IRAM0_SRAM_1_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_F_Msk = 0x8
	// Bit PRO_IRAM0_SRAM_1_F.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_F = 0x8
	// Position of PRO_IRAM0_SRAM_1_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_R_Pos = 0x4
	// Bit mask of PRO_IRAM0_SRAM_1_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_R_Msk = 0x10
	// Bit PRO_IRAM0_SRAM_1_R.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_R = 0x10
	// Position of PRO_IRAM0_SRAM_1_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_W_Pos = 0x5
	// Bit mask of PRO_IRAM0_SRAM_1_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_W_Msk = 0x20
	// Bit PRO_IRAM0_SRAM_1_W.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_1_W = 0x20
	// Position of PRO_IRAM0_SRAM_2_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_F_Pos = 0x6
	// Bit mask of PRO_IRAM0_SRAM_2_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_F_Msk = 0x40
	// Bit PRO_IRAM0_SRAM_2_F.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_F = 0x40
	// Position of PRO_IRAM0_SRAM_2_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_R_Pos = 0x7
	// Bit mask of PRO_IRAM0_SRAM_2_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_R_Msk = 0x80
	// Bit PRO_IRAM0_SRAM_2_R.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_R = 0x80
	// Position of PRO_IRAM0_SRAM_2_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_W_Pos = 0x8
	// Bit mask of PRO_IRAM0_SRAM_2_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_W_Msk = 0x100
	// Bit PRO_IRAM0_SRAM_2_W.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_2_W = 0x100
	// Position of PRO_IRAM0_SRAM_3_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_F_Pos = 0x9
	// Bit mask of PRO_IRAM0_SRAM_3_F field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_F_Msk = 0x200
	// Bit PRO_IRAM0_SRAM_3_F.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_F = 0x200
	// Position of PRO_IRAM0_SRAM_3_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_R_Pos = 0xa
	// Bit mask of PRO_IRAM0_SRAM_3_R field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_R_Msk = 0x400
	// Bit PRO_IRAM0_SRAM_3_R.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_R = 0x400
	// Position of PRO_IRAM0_SRAM_3_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_W_Pos = 0xb
	// Bit mask of PRO_IRAM0_SRAM_3_W field.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_W_Msk = 0x800
	// Bit PRO_IRAM0_SRAM_3_W.
	PMS_PRO_IRAM0_1_PRO_IRAM0_SRAM_3_W = 0x800

	// PRO_IRAM0_2: IBUS permission control register 2.
	// Position of PRO_IRAM0_SRAM_4_SPLTADDR field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_SPLTADDR_Pos = 0x0
	// Bit mask of PRO_IRAM0_SRAM_4_SPLTADDR field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_SPLTADDR_Msk = 0x1ffff
	// Position of PRO_IRAM0_SRAM_4_L_F field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_F_Pos = 0x11
	// Bit mask of PRO_IRAM0_SRAM_4_L_F field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_F_Msk = 0x20000
	// Bit PRO_IRAM0_SRAM_4_L_F.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_F = 0x20000
	// Position of PRO_IRAM0_SRAM_4_L_R field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_R_Pos = 0x12
	// Bit mask of PRO_IRAM0_SRAM_4_L_R field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_R_Msk = 0x40000
	// Bit PRO_IRAM0_SRAM_4_L_R.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_R = 0x40000
	// Position of PRO_IRAM0_SRAM_4_L_W field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_W_Pos = 0x13
	// Bit mask of PRO_IRAM0_SRAM_4_L_W field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_W_Msk = 0x80000
	// Bit PRO_IRAM0_SRAM_4_L_W.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_L_W = 0x80000
	// Position of PRO_IRAM0_SRAM_4_H_F field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_F_Pos = 0x14
	// Bit mask of PRO_IRAM0_SRAM_4_H_F field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_F_Msk = 0x100000
	// Bit PRO_IRAM0_SRAM_4_H_F.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_F = 0x100000
	// Position of PRO_IRAM0_SRAM_4_H_R field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_R_Pos = 0x15
	// Bit mask of PRO_IRAM0_SRAM_4_H_R field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_R_Msk = 0x200000
	// Bit PRO_IRAM0_SRAM_4_H_R.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_R = 0x200000
	// Position of PRO_IRAM0_SRAM_4_H_W field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_W_Pos = 0x16
	// Bit mask of PRO_IRAM0_SRAM_4_H_W field.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_W_Msk = 0x400000
	// Bit PRO_IRAM0_SRAM_4_H_W.
	PMS_PRO_IRAM0_2_PRO_IRAM0_SRAM_4_H_W = 0x400000

	// PRO_IRAM0_3: IBUS permission control register 3.
	// Position of PRO_IRAM0_RTCFAST_SPLTADDR field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_SPLTADDR_Pos = 0x0
	// Bit mask of PRO_IRAM0_RTCFAST_SPLTADDR field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_SPLTADDR_Msk = 0x7ff
	// Position of PRO_IRAM0_RTCFAST_L_F field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_F_Pos = 0xb
	// Bit mask of PRO_IRAM0_RTCFAST_L_F field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_F_Msk = 0x800
	// Bit PRO_IRAM0_RTCFAST_L_F.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_F = 0x800
	// Position of PRO_IRAM0_RTCFAST_L_R field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_R_Pos = 0xc
	// Bit mask of PRO_IRAM0_RTCFAST_L_R field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_R_Msk = 0x1000
	// Bit PRO_IRAM0_RTCFAST_L_R.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_R = 0x1000
	// Position of PRO_IRAM0_RTCFAST_L_W field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_W_Pos = 0xd
	// Bit mask of PRO_IRAM0_RTCFAST_L_W field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_W_Msk = 0x2000
	// Bit PRO_IRAM0_RTCFAST_L_W.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_L_W = 0x2000
	// Position of PRO_IRAM0_RTCFAST_H_F field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_F_Pos = 0xe
	// Bit mask of PRO_IRAM0_RTCFAST_H_F field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_F_Msk = 0x4000
	// Bit PRO_IRAM0_RTCFAST_H_F.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_F = 0x4000
	// Position of PRO_IRAM0_RTCFAST_H_R field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_R_Pos = 0xf
	// Bit mask of PRO_IRAM0_RTCFAST_H_R field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_R_Msk = 0x8000
	// Bit PRO_IRAM0_RTCFAST_H_R.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_R = 0x8000
	// Position of PRO_IRAM0_RTCFAST_H_W field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_W_Pos = 0x10
	// Bit mask of PRO_IRAM0_RTCFAST_H_W field.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_W_Msk = 0x10000
	// Bit PRO_IRAM0_RTCFAST_H_W.
	PMS_PRO_IRAM0_3_PRO_IRAM0_RTCFAST_H_W = 0x10000

	// PRO_IRAM0_4: IBUS permission control register 4.
	// Position of PRO_IRAM0_ILG_CLR field.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_CLR_Pos = 0x0
	// Bit mask of PRO_IRAM0_ILG_CLR field.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_CLR_Msk = 0x1
	// Bit PRO_IRAM0_ILG_CLR.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_CLR = 0x1
	// Position of PRO_IRAM0_ILG_EN field.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_EN_Pos = 0x1
	// Bit mask of PRO_IRAM0_ILG_EN field.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_EN_Msk = 0x2
	// Bit PRO_IRAM0_ILG_EN.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_EN = 0x2
	// Position of PRO_IRAM0_ILG_INTR field.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_INTR_Pos = 0x2
	// Bit mask of PRO_IRAM0_ILG_INTR field.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_INTR_Msk = 0x4
	// Bit PRO_IRAM0_ILG_INTR.
	PMS_PRO_IRAM0_4_PRO_IRAM0_ILG_INTR = 0x4

	// PRO_IRAM0_5: IBUS status register.
	// Position of PRO_IRAM0_ILG_ST field.
	PMS_PRO_IRAM0_5_PRO_IRAM0_ILG_ST_Pos = 0x0
	// Bit mask of PRO_IRAM0_ILG_ST field.
	PMS_PRO_IRAM0_5_PRO_IRAM0_ILG_ST_Msk = 0x3fffff

	// PRO_DRAM0_0: DBUS permission control register 0.
	// Position of PRO_DRAM0_LOCK field.
	PMS_PRO_DRAM0_0_PRO_DRAM0_LOCK_Pos = 0x0
	// Bit mask of PRO_DRAM0_LOCK field.
	PMS_PRO_DRAM0_0_PRO_DRAM0_LOCK_Msk = 0x1
	// Bit PRO_DRAM0_LOCK.
	PMS_PRO_DRAM0_0_PRO_DRAM0_LOCK = 0x1

	// PRO_DRAM0_1: DBUS permission control register 1.
	// Position of PRO_DRAM0_SRAM_0_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_0_R_Pos = 0x0
	// Bit mask of PRO_DRAM0_SRAM_0_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_0_R_Msk = 0x1
	// Bit PRO_DRAM0_SRAM_0_R.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_0_R = 0x1
	// Position of PRO_DRAM0_SRAM_0_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_0_W_Pos = 0x1
	// Bit mask of PRO_DRAM0_SRAM_0_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_0_W_Msk = 0x2
	// Bit PRO_DRAM0_SRAM_0_W.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_0_W = 0x2
	// Position of PRO_DRAM0_SRAM_1_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_1_R_Pos = 0x2
	// Bit mask of PRO_DRAM0_SRAM_1_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_1_R_Msk = 0x4
	// Bit PRO_DRAM0_SRAM_1_R.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_1_R = 0x4
	// Position of PRO_DRAM0_SRAM_1_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_1_W_Pos = 0x3
	// Bit mask of PRO_DRAM0_SRAM_1_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_1_W_Msk = 0x8
	// Bit PRO_DRAM0_SRAM_1_W.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_1_W = 0x8
	// Position of PRO_DRAM0_SRAM_2_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_2_R_Pos = 0x4
	// Bit mask of PRO_DRAM0_SRAM_2_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_2_R_Msk = 0x10
	// Bit PRO_DRAM0_SRAM_2_R.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_2_R = 0x10
	// Position of PRO_DRAM0_SRAM_2_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_2_W_Pos = 0x5
	// Bit mask of PRO_DRAM0_SRAM_2_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_2_W_Msk = 0x20
	// Bit PRO_DRAM0_SRAM_2_W.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_2_W = 0x20
	// Position of PRO_DRAM0_SRAM_3_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_3_R_Pos = 0x6
	// Bit mask of PRO_DRAM0_SRAM_3_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_3_R_Msk = 0x40
	// Bit PRO_DRAM0_SRAM_3_R.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_3_R = 0x40
	// Position of PRO_DRAM0_SRAM_3_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_3_W_Pos = 0x7
	// Bit mask of PRO_DRAM0_SRAM_3_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_3_W_Msk = 0x80
	// Bit PRO_DRAM0_SRAM_3_W.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_3_W = 0x80
	// Position of PRO_DRAM0_SRAM_4_SPLTADDR field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_SPLTADDR_Pos = 0x8
	// Bit mask of PRO_DRAM0_SRAM_4_SPLTADDR field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_SPLTADDR_Msk = 0x1ffff00
	// Position of PRO_DRAM0_SRAM_4_L_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_R_Pos = 0x19
	// Bit mask of PRO_DRAM0_SRAM_4_L_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_R_Msk = 0x2000000
	// Bit PRO_DRAM0_SRAM_4_L_R.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_R = 0x2000000
	// Position of PRO_DRAM0_SRAM_4_L_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_W_Pos = 0x1a
	// Bit mask of PRO_DRAM0_SRAM_4_L_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_W_Msk = 0x4000000
	// Bit PRO_DRAM0_SRAM_4_L_W.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_L_W = 0x4000000
	// Position of PRO_DRAM0_SRAM_4_H_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_R_Pos = 0x1b
	// Bit mask of PRO_DRAM0_SRAM_4_H_R field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_R_Msk = 0x8000000
	// Bit PRO_DRAM0_SRAM_4_H_R.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_R = 0x8000000
	// Position of PRO_DRAM0_SRAM_4_H_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_W_Pos = 0x1c
	// Bit mask of PRO_DRAM0_SRAM_4_H_W field.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_W_Msk = 0x10000000
	// Bit PRO_DRAM0_SRAM_4_H_W.
	PMS_PRO_DRAM0_1_PRO_DRAM0_SRAM_4_H_W = 0x10000000

	// PRO_DRAM0_2: DBUS permission control register 2.
	// Position of PRO_DRAM0_RTCFAST_SPLTADDR field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_SPLTADDR_Pos = 0x0
	// Bit mask of PRO_DRAM0_RTCFAST_SPLTADDR field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_SPLTADDR_Msk = 0x7ff
	// Position of PRO_DRAM0_RTCFAST_L_R field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_R_Pos = 0xb
	// Bit mask of PRO_DRAM0_RTCFAST_L_R field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_R_Msk = 0x800
	// Bit PRO_DRAM0_RTCFAST_L_R.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_R = 0x800
	// Position of PRO_DRAM0_RTCFAST_L_W field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_W_Pos = 0xc
	// Bit mask of PRO_DRAM0_RTCFAST_L_W field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_W_Msk = 0x1000
	// Bit PRO_DRAM0_RTCFAST_L_W.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_L_W = 0x1000
	// Position of PRO_DRAM0_RTCFAST_H_R field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_R_Pos = 0xd
	// Bit mask of PRO_DRAM0_RTCFAST_H_R field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_R_Msk = 0x2000
	// Bit PRO_DRAM0_RTCFAST_H_R.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_R = 0x2000
	// Position of PRO_DRAM0_RTCFAST_H_W field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_W_Pos = 0xe
	// Bit mask of PRO_DRAM0_RTCFAST_H_W field.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_W_Msk = 0x4000
	// Bit PRO_DRAM0_RTCFAST_H_W.
	PMS_PRO_DRAM0_2_PRO_DRAM0_RTCFAST_H_W = 0x4000

	// PRO_DRAM0_3: DBUS permission control register 3.
	// Position of PRO_DRAM0_ILG_CLR field.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_CLR_Pos = 0x0
	// Bit mask of PRO_DRAM0_ILG_CLR field.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_CLR_Msk = 0x1
	// Bit PRO_DRAM0_ILG_CLR.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_CLR = 0x1
	// Position of PRO_DRAM0_ILG_EN field.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_EN_Pos = 0x1
	// Bit mask of PRO_DRAM0_ILG_EN field.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_EN_Msk = 0x2
	// Bit PRO_DRAM0_ILG_EN.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_EN = 0x2
	// Position of PRO_DRAM0_ILG_INTR field.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_INTR_Pos = 0x2
	// Bit mask of PRO_DRAM0_ILG_INTR field.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_INTR_Msk = 0x4
	// Bit PRO_DRAM0_ILG_INTR.
	PMS_PRO_DRAM0_3_PRO_DRAM0_ILG_INTR = 0x4

	// PRO_DRAM0_4: DBUS status register.
	// Position of PRO_DRAM0_ILG_ST field.
	PMS_PRO_DRAM0_4_PRO_DRAM0_ILG_ST_Pos = 0x0
	// Bit mask of PRO_DRAM0_ILG_ST field.
	PMS_PRO_DRAM0_4_PRO_DRAM0_ILG_ST_Msk = 0x3ffffff

	// PRO_DPORT_0: PeriBus1 permission control register 0.
	// Position of PRO_DPORT_LOCK field.
	PMS_PRO_DPORT_0_PRO_DPORT_LOCK_Pos = 0x0
	// Bit mask of PRO_DPORT_LOCK field.
	PMS_PRO_DPORT_0_PRO_DPORT_LOCK_Msk = 0x1
	// Bit PRO_DPORT_LOCK.
	PMS_PRO_DPORT_0_PRO_DPORT_LOCK = 0x1

	// PRO_DPORT_1: PeriBus1 permission control register 1.
	// Position of PRO_DPORT_APB_PERIPHERAL_FORBID field.
	PMS_PRO_DPORT_1_PRO_DPORT_APB_PERIPHERAL_FORBID_Pos = 0x0
	// Bit mask of PRO_DPORT_APB_PERIPHERAL_FORBID field.
	PMS_PRO_DPORT_1_PRO_DPORT_APB_PERIPHERAL_FORBID_Msk = 0x1
	// Bit PRO_DPORT_APB_PERIPHERAL_FORBID.
	PMS_PRO_DPORT_1_PRO_DPORT_APB_PERIPHERAL_FORBID = 0x1
	// Position of PRO_DPORT_RTCSLOW_SPLTADDR field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_SPLTADDR_Pos = 0x1
	// Bit mask of PRO_DPORT_RTCSLOW_SPLTADDR field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_SPLTADDR_Msk = 0xffe
	// Position of PRO_DPORT_RTCSLOW_L_R field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_L_R_Pos = 0xc
	// Bit mask of PRO_DPORT_RTCSLOW_L_R field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_L_R_Msk = 0x1000
	// Bit PRO_DPORT_RTCSLOW_L_R.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_L_R = 0x1000
	// Position of PRO_DPORT_RTCSLOW_L_W field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_L_W_Pos = 0xd
	// Bit mask of PRO_DPORT_RTCSLOW_L_W field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_L_W_Msk = 0x2000
	// Bit PRO_DPORT_RTCSLOW_L_W.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_L_W = 0x2000
	// Position of PRO_DPORT_RTCSLOW_H_R field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_H_R_Pos = 0xe
	// Bit mask of PRO_DPORT_RTCSLOW_H_R field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_H_R_Msk = 0x4000
	// Bit PRO_DPORT_RTCSLOW_H_R.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_H_R = 0x4000
	// Position of PRO_DPORT_RTCSLOW_H_W field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_H_W_Pos = 0xf
	// Bit mask of PRO_DPORT_RTCSLOW_H_W field.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_H_W_Msk = 0x8000
	// Bit PRO_DPORT_RTCSLOW_H_W.
	PMS_PRO_DPORT_1_PRO_DPORT_RTCSLOW_H_W = 0x8000
	// Position of PRO_DPORT_RESERVE_FIFO_VALID field.
	PMS_PRO_DPORT_1_PRO_DPORT_RESERVE_FIFO_VALID_Pos = 0x10
	// Bit mask of PRO_DPORT_RESERVE_FIFO_VALID field.
	PMS_PRO_DPORT_1_PRO_DPORT_RESERVE_FIFO_VALID_Msk = 0xf0000

	// PRO_DPORT_2: PeriBus1 permission control register 2.
	// Position of PRO_DPORT_RESERVE_FIFO_0 field.
	PMS_PRO_DPORT_2_PRO_DPORT_RESERVE_FIFO_0_Pos = 0x0
	// Bit mask of PRO_DPORT_RESERVE_FIFO_0 field.
	PMS_PRO_DPORT_2_PRO_DPORT_RESERVE_FIFO_0_Msk = 0x3ffff

	// PRO_DPORT_3: PeriBus1 permission control register 3.
	// Position of PRO_DPORT_RESERVE_FIFO_1 field.
	PMS_PRO_DPORT_3_PRO_DPORT_RESERVE_FIFO_1_Pos = 0x0
	// Bit mask of PRO_DPORT_RESERVE_FIFO_1 field.
	PMS_PRO_DPORT_3_PRO_DPORT_RESERVE_FIFO_1_Msk = 0x3ffff

	// PRO_DPORT_4: PeriBus1 permission control register 4.
	// Position of PRO_DPORT_RESERVE_FIFO_2 field.
	PMS_PRO_DPORT_4_PRO_DPORT_RESERVE_FIFO_2_Pos = 0x0
	// Bit mask of PRO_DPORT_RESERVE_FIFO_2 field.
	PMS_PRO_DPORT_4_PRO_DPORT_RESERVE_FIFO_2_Msk = 0x3ffff

	// PRO_DPORT_5: PeriBus1 permission control register 5.
	// Position of PRO_DPORT_RESERVE_FIFO_3 field.
	PMS_PRO_DPORT_5_PRO_DPORT_RESERVE_FIFO_3_Pos = 0x0
	// Bit mask of PRO_DPORT_RESERVE_FIFO_3 field.
	PMS_PRO_DPORT_5_PRO_DPORT_RESERVE_FIFO_3_Msk = 0x3ffff

	// PRO_DPORT_6: PeriBus1 permission control register 6.
	// Position of PRO_DPORT_ILG_CLR field.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_CLR_Pos = 0x0
	// Bit mask of PRO_DPORT_ILG_CLR field.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_CLR_Msk = 0x1
	// Bit PRO_DPORT_ILG_CLR.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_CLR = 0x1
	// Position of PRO_DPORT_ILG_EN field.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_EN_Pos = 0x1
	// Bit mask of PRO_DPORT_ILG_EN field.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_EN_Msk = 0x2
	// Bit PRO_DPORT_ILG_EN.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_EN = 0x2
	// Position of PRO_DPORT_ILG_INTR field.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_INTR_Pos = 0x2
	// Bit mask of PRO_DPORT_ILG_INTR field.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_INTR_Msk = 0x4
	// Bit PRO_DPORT_ILG_INTR.
	PMS_PRO_DPORT_6_PRO_DPORT_ILG_INTR = 0x4

	// PRO_DPORT_7: PeriBus1 status register.
	// Position of PRO_DPORT_ILG_ST field.
	PMS_PRO_DPORT_7_PRO_DPORT_ILG_ST_Pos = 0x0
	// Bit mask of PRO_DPORT_ILG_ST field.
	PMS_PRO_DPORT_7_PRO_DPORT_ILG_ST_Msk = 0x3ffffff

	// PRO_AHB_0: PeriBus2 permission control register 0.
	// Position of PRO_AHB_LOCK field.
	PMS_PRO_AHB_0_PRO_AHB_LOCK_Pos = 0x0
	// Bit mask of PRO_AHB_LOCK field.
	PMS_PRO_AHB_0_PRO_AHB_LOCK_Msk = 0x1
	// Bit PRO_AHB_LOCK.
	PMS_PRO_AHB_0_PRO_AHB_LOCK = 0x1

	// PRO_AHB_1: PeriBus2 permission control register 1.
	// Position of PRO_AHB_RTCSLOW_0_SPLTADDR field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_SPLTADDR_Pos = 0x0
	// Bit mask of PRO_AHB_RTCSLOW_0_SPLTADDR field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_SPLTADDR_Msk = 0x7ff
	// Position of PRO_AHB_RTCSLOW_0_L_F field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_F_Pos = 0xb
	// Bit mask of PRO_AHB_RTCSLOW_0_L_F field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_F_Msk = 0x800
	// Bit PRO_AHB_RTCSLOW_0_L_F.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_F = 0x800
	// Position of PRO_AHB_RTCSLOW_0_L_R field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_R_Pos = 0xc
	// Bit mask of PRO_AHB_RTCSLOW_0_L_R field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_R_Msk = 0x1000
	// Bit PRO_AHB_RTCSLOW_0_L_R.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_R = 0x1000
	// Position of PRO_AHB_RTCSLOW_0_L_W field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_W_Pos = 0xd
	// Bit mask of PRO_AHB_RTCSLOW_0_L_W field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_W_Msk = 0x2000
	// Bit PRO_AHB_RTCSLOW_0_L_W.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_L_W = 0x2000
	// Position of PRO_AHB_RTCSLOW_0_H_F field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_F_Pos = 0xe
	// Bit mask of PRO_AHB_RTCSLOW_0_H_F field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_F_Msk = 0x4000
	// Bit PRO_AHB_RTCSLOW_0_H_F.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_F = 0x4000
	// Position of PRO_AHB_RTCSLOW_0_H_R field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_R_Pos = 0xf
	// Bit mask of PRO_AHB_RTCSLOW_0_H_R field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_R_Msk = 0x8000
	// Bit PRO_AHB_RTCSLOW_0_H_R.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_R = 0x8000
	// Position of PRO_AHB_RTCSLOW_0_H_W field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_W_Pos = 0x10
	// Bit mask of PRO_AHB_RTCSLOW_0_H_W field.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_W_Msk = 0x10000
	// Bit PRO_AHB_RTCSLOW_0_H_W.
	PMS_PRO_AHB_1_PRO_AHB_RTCSLOW_0_H_W = 0x10000

	// PRO_AHB_2: PeriBus2 permission control register 2.
	// Position of PRO_AHB_RTCSLOW_1_SPLTADDR field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_SPLTADDR_Pos = 0x0
	// Bit mask of PRO_AHB_RTCSLOW_1_SPLTADDR field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_SPLTADDR_Msk = 0x7ff
	// Position of PRO_AHB_RTCSLOW_1_L_F field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_F_Pos = 0xb
	// Bit mask of PRO_AHB_RTCSLOW_1_L_F field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_F_Msk = 0x800
	// Bit PRO_AHB_RTCSLOW_1_L_F.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_F = 0x800
	// Position of PRO_AHB_RTCSLOW_1_L_R field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_R_Pos = 0xc
	// Bit mask of PRO_AHB_RTCSLOW_1_L_R field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_R_Msk = 0x1000
	// Bit PRO_AHB_RTCSLOW_1_L_R.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_R = 0x1000
	// Position of PRO_AHB_RTCSLOW_1_L_W field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_W_Pos = 0xd
	// Bit mask of PRO_AHB_RTCSLOW_1_L_W field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_W_Msk = 0x2000
	// Bit PRO_AHB_RTCSLOW_1_L_W.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_L_W = 0x2000
	// Position of PRO_AHB_RTCSLOW_1_H_F field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_F_Pos = 0xe
	// Bit mask of PRO_AHB_RTCSLOW_1_H_F field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_F_Msk = 0x4000
	// Bit PRO_AHB_RTCSLOW_1_H_F.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_F = 0x4000
	// Position of PRO_AHB_RTCSLOW_1_H_R field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_R_Pos = 0xf
	// Bit mask of PRO_AHB_RTCSLOW_1_H_R field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_R_Msk = 0x8000
	// Bit PRO_AHB_RTCSLOW_1_H_R.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_R = 0x8000
	// Position of PRO_AHB_RTCSLOW_1_H_W field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_W_Pos = 0x10
	// Bit mask of PRO_AHB_RTCSLOW_1_H_W field.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_W_Msk = 0x10000
	// Bit PRO_AHB_RTCSLOW_1_H_W.
	PMS_PRO_AHB_2_PRO_AHB_RTCSLOW_1_H_W = 0x10000

	// PRO_AHB_3: PeriBus2 permission control register 3.
	// Position of PRO_AHB_ILG_CLR field.
	PMS_PRO_AHB_3_PRO_AHB_ILG_CLR_Pos = 0x0
	// Bit mask of PRO_AHB_ILG_CLR field.
	PMS_PRO_AHB_3_PRO_AHB_ILG_CLR_Msk = 0x1
	// Bit PRO_AHB_ILG_CLR.
	PMS_PRO_AHB_3_PRO_AHB_ILG_CLR = 0x1
	// Position of PRO_AHB_ILG_EN field.
	PMS_PRO_AHB_3_PRO_AHB_ILG_EN_Pos = 0x1
	// Bit mask of PRO_AHB_ILG_EN field.
	PMS_PRO_AHB_3_PRO_AHB_ILG_EN_Msk = 0x2
	// Bit PRO_AHB_ILG_EN.
	PMS_PRO_AHB_3_PRO_AHB_ILG_EN = 0x2
	// Position of PRO_AHB_ILG_INTR field.
	PMS_PRO_AHB_3_PRO_AHB_ILG_INTR_Pos = 0x2
	// Bit mask of PRO_AHB_ILG_INTR field.
	PMS_PRO_AHB_3_PRO_AHB_ILG_INTR_Msk = 0x4
	// Bit PRO_AHB_ILG_INTR.
	PMS_PRO_AHB_3_PRO_AHB_ILG_INTR = 0x4

	// PRO_AHB_4: PeriBus2 status register.
	// Position of PRO_AHB_ILG_ST field.
	PMS_PRO_AHB_4_PRO_AHB_ILG_ST_Pos = 0x0
	// Bit mask of PRO_AHB_ILG_ST field.
	PMS_PRO_AHB_4_PRO_AHB_ILG_ST_Msk = 0xffffffff

	// PRO_TRACE_0: Trace memory permission control register 0.
	// Position of PRO_TRACE_LOCK field.
	PMS_PRO_TRACE_0_PRO_TRACE_LOCK_Pos = 0x0
	// Bit mask of PRO_TRACE_LOCK field.
	PMS_PRO_TRACE_0_PRO_TRACE_LOCK_Msk = 0x1
	// Bit PRO_TRACE_LOCK.
	PMS_PRO_TRACE_0_PRO_TRACE_LOCK = 0x1

	// PRO_TRACE_1: Trace memory permission control register 1.
	// Position of PRO_TRACE_DISABLE field.
	PMS_PRO_TRACE_1_PRO_TRACE_DISABLE_Pos = 0x0
	// Bit mask of PRO_TRACE_DISABLE field.
	PMS_PRO_TRACE_1_PRO_TRACE_DISABLE_Msk = 0x1
	// Bit PRO_TRACE_DISABLE.
	PMS_PRO_TRACE_1_PRO_TRACE_DISABLE = 0x1

	// PRO_CACHE_0: Cache permission control register 0.
	// Position of PRO_CACHE_LOCK field.
	PMS_PRO_CACHE_0_PRO_CACHE_LOCK_Pos = 0x0
	// Bit mask of PRO_CACHE_LOCK field.
	PMS_PRO_CACHE_0_PRO_CACHE_LOCK_Msk = 0x1
	// Bit PRO_CACHE_LOCK.
	PMS_PRO_CACHE_0_PRO_CACHE_LOCK = 0x1

	// PRO_CACHE_1: Cache permission control register 1.
	// Position of PRO_CACHE_CONNECT field.
	PMS_PRO_CACHE_1_PRO_CACHE_CONNECT_Pos = 0x0
	// Bit mask of PRO_CACHE_CONNECT field.
	PMS_PRO_CACHE_1_PRO_CACHE_CONNECT_Msk = 0xffff

	// PRO_CACHE_2: Cache permission control register 2.
	// Position of PRO_CACHE_ILG_CLR field.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_CLR_Pos = 0x0
	// Bit mask of PRO_CACHE_ILG_CLR field.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_CLR_Msk = 0x1
	// Bit PRO_CACHE_ILG_CLR.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_CLR = 0x1
	// Position of PRO_CACHE_ILG_EN field.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_EN_Pos = 0x1
	// Bit mask of PRO_CACHE_ILG_EN field.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_EN_Msk = 0x2
	// Bit PRO_CACHE_ILG_EN.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_EN = 0x2
	// Position of PRO_CACHE_ILG_INTR field.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_INTR_Pos = 0x2
	// Bit mask of PRO_CACHE_ILG_INTR field.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_INTR_Msk = 0x4
	// Bit PRO_CACHE_ILG_INTR.
	PMS_PRO_CACHE_2_PRO_CACHE_ILG_INTR = 0x4

	// PRO_CACHE_3: Icache status register.
	// Position of PRO_CACHE_ILG_ST_I field.
	PMS_PRO_CACHE_3_PRO_CACHE_ILG_ST_I_Pos = 0x0
	// Bit mask of PRO_CACHE_ILG_ST_I field.
	PMS_PRO_CACHE_3_PRO_CACHE_ILG_ST_I_Msk = 0x1ffff

	// PRO_CACHE_4: Dcache status register.
	// Position of PRO_CACHE_ILG_ST_D field.
	PMS_PRO_CACHE_4_PRO_CACHE_ILG_ST_D_Pos = 0x0
	// Bit mask of PRO_CACHE_ILG_ST_D field.
	PMS_PRO_CACHE_4_PRO_CACHE_ILG_ST_D_Msk = 0x1ffff

	// DMA_APB_I_0: Internal DMA permission control register 0.
	// Position of DMA_APB_I_LOCK field.
	PMS_DMA_APB_I_0_DMA_APB_I_LOCK_Pos = 0x0
	// Bit mask of DMA_APB_I_LOCK field.
	PMS_DMA_APB_I_0_DMA_APB_I_LOCK_Msk = 0x1
	// Bit DMA_APB_I_LOCK.
	PMS_DMA_APB_I_0_DMA_APB_I_LOCK = 0x1

	// DMA_APB_I_1: Internal DMA permission control register 1.
	// Position of DMA_APB_I_SRAM_0_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_0_R_Pos = 0x0
	// Bit mask of DMA_APB_I_SRAM_0_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_0_R_Msk = 0x1
	// Bit DMA_APB_I_SRAM_0_R.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_0_R = 0x1
	// Position of DMA_APB_I_SRAM_0_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_0_W_Pos = 0x1
	// Bit mask of DMA_APB_I_SRAM_0_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_0_W_Msk = 0x2
	// Bit DMA_APB_I_SRAM_0_W.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_0_W = 0x2
	// Position of DMA_APB_I_SRAM_1_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_1_R_Pos = 0x2
	// Bit mask of DMA_APB_I_SRAM_1_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_1_R_Msk = 0x4
	// Bit DMA_APB_I_SRAM_1_R.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_1_R = 0x4
	// Position of DMA_APB_I_SRAM_1_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_1_W_Pos = 0x3
	// Bit mask of DMA_APB_I_SRAM_1_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_1_W_Msk = 0x8
	// Bit DMA_APB_I_SRAM_1_W.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_1_W = 0x8
	// Position of DMA_APB_I_SRAM_2_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_2_R_Pos = 0x4
	// Bit mask of DMA_APB_I_SRAM_2_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_2_R_Msk = 0x10
	// Bit DMA_APB_I_SRAM_2_R.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_2_R = 0x10
	// Position of DMA_APB_I_SRAM_2_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_2_W_Pos = 0x5
	// Bit mask of DMA_APB_I_SRAM_2_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_2_W_Msk = 0x20
	// Bit DMA_APB_I_SRAM_2_W.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_2_W = 0x20
	// Position of DMA_APB_I_SRAM_3_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_3_R_Pos = 0x6
	// Bit mask of DMA_APB_I_SRAM_3_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_3_R_Msk = 0x40
	// Bit DMA_APB_I_SRAM_3_R.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_3_R = 0x40
	// Position of DMA_APB_I_SRAM_3_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_3_W_Pos = 0x7
	// Bit mask of DMA_APB_I_SRAM_3_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_3_W_Msk = 0x80
	// Bit DMA_APB_I_SRAM_3_W.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_3_W = 0x80
	// Position of DMA_APB_I_SRAM_4_SPLTADDR field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_SPLTADDR_Pos = 0x8
	// Bit mask of DMA_APB_I_SRAM_4_SPLTADDR field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_SPLTADDR_Msk = 0x1ffff00
	// Position of DMA_APB_I_SRAM_4_L_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_L_R_Pos = 0x19
	// Bit mask of DMA_APB_I_SRAM_4_L_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_L_R_Msk = 0x2000000
	// Bit DMA_APB_I_SRAM_4_L_R.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_L_R = 0x2000000
	// Position of DMA_APB_I_SRAM_4_L_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_L_W_Pos = 0x1a
	// Bit mask of DMA_APB_I_SRAM_4_L_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_L_W_Msk = 0x4000000
	// Bit DMA_APB_I_SRAM_4_L_W.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_L_W = 0x4000000
	// Position of DMA_APB_I_SRAM_4_H_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_H_R_Pos = 0x1b
	// Bit mask of DMA_APB_I_SRAM_4_H_R field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_H_R_Msk = 0x8000000
	// Bit DMA_APB_I_SRAM_4_H_R.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_H_R = 0x8000000
	// Position of DMA_APB_I_SRAM_4_H_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_H_W_Pos = 0x1c
	// Bit mask of DMA_APB_I_SRAM_4_H_W field.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_H_W_Msk = 0x10000000
	// Bit DMA_APB_I_SRAM_4_H_W.
	PMS_DMA_APB_I_1_DMA_APB_I_SRAM_4_H_W = 0x10000000

	// DMA_APB_I_2: Internal DMA permission control register 2.
	// Position of DMA_APB_I_ILG_CLR field.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_CLR_Pos = 0x0
	// Bit mask of DMA_APB_I_ILG_CLR field.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_CLR_Msk = 0x1
	// Bit DMA_APB_I_ILG_CLR.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_CLR = 0x1
	// Position of DMA_APB_I_ILG_EN field.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_EN_Pos = 0x1
	// Bit mask of DMA_APB_I_ILG_EN field.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_EN_Msk = 0x2
	// Bit DMA_APB_I_ILG_EN.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_EN = 0x2
	// Position of DMA_APB_I_ILG_INTR field.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_INTR_Pos = 0x2
	// Bit mask of DMA_APB_I_ILG_INTR field.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_INTR_Msk = 0x4
	// Bit DMA_APB_I_ILG_INTR.
	PMS_DMA_APB_I_2_DMA_APB_I_ILG_INTR = 0x4

	// DMA_APB_I_3: Internal DMA status register.
	// Position of DMA_APB_I_ILG_ST field.
	PMS_DMA_APB_I_3_DMA_APB_I_ILG_ST_Pos = 0x0
	// Bit mask of DMA_APB_I_ILG_ST field.
	PMS_DMA_APB_I_3_DMA_APB_I_ILG_ST_Msk = 0x7fffff

	// DMA_RX_I_0: RX Copy DMA permission control register 0.
	// Position of DMA_RX_I_LOCK field.
	PMS_DMA_RX_I_0_DMA_RX_I_LOCK_Pos = 0x0
	// Bit mask of DMA_RX_I_LOCK field.
	PMS_DMA_RX_I_0_DMA_RX_I_LOCK_Msk = 0x1
	// Bit DMA_RX_I_LOCK.
	PMS_DMA_RX_I_0_DMA_RX_I_LOCK = 0x1

	// DMA_RX_I_1: RX Copy DMA permission control register 1.
	// Position of DMA_RX_I_SRAM_0_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_0_R_Pos = 0x0
	// Bit mask of DMA_RX_I_SRAM_0_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_0_R_Msk = 0x1
	// Bit DMA_RX_I_SRAM_0_R.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_0_R = 0x1
	// Position of DMA_RX_I_SRAM_0_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_0_W_Pos = 0x1
	// Bit mask of DMA_RX_I_SRAM_0_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_0_W_Msk = 0x2
	// Bit DMA_RX_I_SRAM_0_W.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_0_W = 0x2
	// Position of DMA_RX_I_SRAM_1_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_1_R_Pos = 0x2
	// Bit mask of DMA_RX_I_SRAM_1_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_1_R_Msk = 0x4
	// Bit DMA_RX_I_SRAM_1_R.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_1_R = 0x4
	// Position of DMA_RX_I_SRAM_1_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_1_W_Pos = 0x3
	// Bit mask of DMA_RX_I_SRAM_1_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_1_W_Msk = 0x8
	// Bit DMA_RX_I_SRAM_1_W.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_1_W = 0x8
	// Position of DMA_RX_I_SRAM_2_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_2_R_Pos = 0x4
	// Bit mask of DMA_RX_I_SRAM_2_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_2_R_Msk = 0x10
	// Bit DMA_RX_I_SRAM_2_R.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_2_R = 0x10
	// Position of DMA_RX_I_SRAM_2_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_2_W_Pos = 0x5
	// Bit mask of DMA_RX_I_SRAM_2_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_2_W_Msk = 0x20
	// Bit DMA_RX_I_SRAM_2_W.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_2_W = 0x20
	// Position of DMA_RX_I_SRAM_3_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_3_R_Pos = 0x6
	// Bit mask of DMA_RX_I_SRAM_3_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_3_R_Msk = 0x40
	// Bit DMA_RX_I_SRAM_3_R.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_3_R = 0x40
	// Position of DMA_RX_I_SRAM_3_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_3_W_Pos = 0x7
	// Bit mask of DMA_RX_I_SRAM_3_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_3_W_Msk = 0x80
	// Bit DMA_RX_I_SRAM_3_W.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_3_W = 0x80
	// Position of DMA_RX_I_SRAM_4_SPLTADDR field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_SPLTADDR_Pos = 0x8
	// Bit mask of DMA_RX_I_SRAM_4_SPLTADDR field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_SPLTADDR_Msk = 0x1ffff00
	// Position of DMA_RX_I_SRAM_4_L_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_L_R_Pos = 0x19
	// Bit mask of DMA_RX_I_SRAM_4_L_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_L_R_Msk = 0x2000000
	// Bit DMA_RX_I_SRAM_4_L_R.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_L_R = 0x2000000
	// Position of DMA_RX_I_SRAM_4_L_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_L_W_Pos = 0x1a
	// Bit mask of DMA_RX_I_SRAM_4_L_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_L_W_Msk = 0x4000000
	// Bit DMA_RX_I_SRAM_4_L_W.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_L_W = 0x4000000
	// Position of DMA_RX_I_SRAM_4_H_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_H_R_Pos = 0x1b
	// Bit mask of DMA_RX_I_SRAM_4_H_R field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_H_R_Msk = 0x8000000
	// Bit DMA_RX_I_SRAM_4_H_R.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_H_R = 0x8000000
	// Position of DMA_RX_I_SRAM_4_H_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_H_W_Pos = 0x1c
	// Bit mask of DMA_RX_I_SRAM_4_H_W field.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_H_W_Msk = 0x10000000
	// Bit DMA_RX_I_SRAM_4_H_W.
	PMS_DMA_RX_I_1_DMA_RX_I_SRAM_4_H_W = 0x10000000

	// DMA_RX_I_2: RX Copy DMA permission control register 2.
	// Position of DMA_RX_I_ILG_CLR field.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_CLR_Pos = 0x0
	// Bit mask of DMA_RX_I_ILG_CLR field.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_CLR_Msk = 0x1
	// Bit DMA_RX_I_ILG_CLR.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_CLR = 0x1
	// Position of DMA_RX_I_ILG_EN field.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_EN_Pos = 0x1
	// Bit mask of DMA_RX_I_ILG_EN field.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_EN_Msk = 0x2
	// Bit DMA_RX_I_ILG_EN.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_EN = 0x2
	// Position of DMA_RX_I_ILG_INTR field.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_INTR_Pos = 0x2
	// Bit mask of DMA_RX_I_ILG_INTR field.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_INTR_Msk = 0x4
	// Bit DMA_RX_I_ILG_INTR.
	PMS_DMA_RX_I_2_DMA_RX_I_ILG_INTR = 0x4

	// DMA_RX_I_3: RX Copy DMA status register.
	// Position of DMA_RX_I_ILG_ST field.
	PMS_DMA_RX_I_3_DMA_RX_I_ILG_ST_Pos = 0x0
	// Bit mask of DMA_RX_I_ILG_ST field.
	PMS_DMA_RX_I_3_DMA_RX_I_ILG_ST_Msk = 0x7fffff

	// DMA_TX_I_0: TX Copy DMA permission control register 0.
	// Position of DMA_TX_I_LOCK field.
	PMS_DMA_TX_I_0_DMA_TX_I_LOCK_Pos = 0x0
	// Bit mask of DMA_TX_I_LOCK field.
	PMS_DMA_TX_I_0_DMA_TX_I_LOCK_Msk = 0x1
	// Bit DMA_TX_I_LOCK.
	PMS_DMA_TX_I_0_DMA_TX_I_LOCK = 0x1

	// DMA_TX_I_1: TX Copy DMA permission control register 1.
	// Position of DMA_TX_I_SRAM_0_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_0_R_Pos = 0x0
	// Bit mask of DMA_TX_I_SRAM_0_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_0_R_Msk = 0x1
	// Bit DMA_TX_I_SRAM_0_R.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_0_R = 0x1
	// Position of DMA_TX_I_SRAM_0_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_0_W_Pos = 0x1
	// Bit mask of DMA_TX_I_SRAM_0_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_0_W_Msk = 0x2
	// Bit DMA_TX_I_SRAM_0_W.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_0_W = 0x2
	// Position of DMA_TX_I_SRAM_1_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_1_R_Pos = 0x2
	// Bit mask of DMA_TX_I_SRAM_1_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_1_R_Msk = 0x4
	// Bit DMA_TX_I_SRAM_1_R.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_1_R = 0x4
	// Position of DMA_TX_I_SRAM_1_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_1_W_Pos = 0x3
	// Bit mask of DMA_TX_I_SRAM_1_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_1_W_Msk = 0x8
	// Bit DMA_TX_I_SRAM_1_W.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_1_W = 0x8
	// Position of DMA_TX_I_SRAM_2_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_2_R_Pos = 0x4
	// Bit mask of DMA_TX_I_SRAM_2_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_2_R_Msk = 0x10
	// Bit DMA_TX_I_SRAM_2_R.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_2_R = 0x10
	// Position of DMA_TX_I_SRAM_2_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_2_W_Pos = 0x5
	// Bit mask of DMA_TX_I_SRAM_2_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_2_W_Msk = 0x20
	// Bit DMA_TX_I_SRAM_2_W.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_2_W = 0x20
	// Position of DMA_TX_I_SRAM_3_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_3_R_Pos = 0x6
	// Bit mask of DMA_TX_I_SRAM_3_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_3_R_Msk = 0x40
	// Bit DMA_TX_I_SRAM_3_R.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_3_R = 0x40
	// Position of DMA_TX_I_SRAM_3_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_3_W_Pos = 0x7
	// Bit mask of DMA_TX_I_SRAM_3_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_3_W_Msk = 0x80
	// Bit DMA_TX_I_SRAM_3_W.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_3_W = 0x80
	// Position of DMA_TX_I_SRAM_4_SPLTADDR field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_SPLTADDR_Pos = 0x8
	// Bit mask of DMA_TX_I_SRAM_4_SPLTADDR field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_SPLTADDR_Msk = 0x1ffff00
	// Position of DMA_TX_I_SRAM_4_L_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_L_R_Pos = 0x19
	// Bit mask of DMA_TX_I_SRAM_4_L_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_L_R_Msk = 0x2000000
	// Bit DMA_TX_I_SRAM_4_L_R.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_L_R = 0x2000000
	// Position of DMA_TX_I_SRAM_4_L_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_L_W_Pos = 0x1a
	// Bit mask of DMA_TX_I_SRAM_4_L_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_L_W_Msk = 0x4000000
	// Bit DMA_TX_I_SRAM_4_L_W.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_L_W = 0x4000000
	// Position of DMA_TX_I_SRAM_4_H_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_H_R_Pos = 0x1b
	// Bit mask of DMA_TX_I_SRAM_4_H_R field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_H_R_Msk = 0x8000000
	// Bit DMA_TX_I_SRAM_4_H_R.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_H_R = 0x8000000
	// Position of DMA_TX_I_SRAM_4_H_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_H_W_Pos = 0x1c
	// Bit mask of DMA_TX_I_SRAM_4_H_W field.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_H_W_Msk = 0x10000000
	// Bit DMA_TX_I_SRAM_4_H_W.
	PMS_DMA_TX_I_1_DMA_TX_I_SRAM_4_H_W = 0x10000000

	// DMA_TX_I_2: TX Copy DMA permission control register 2.
	// Position of DMA_TX_I_ILG_CLR field.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_CLR_Pos = 0x0
	// Bit mask of DMA_TX_I_ILG_CLR field.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_CLR_Msk = 0x1
	// Bit DMA_TX_I_ILG_CLR.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_CLR = 0x1
	// Position of DMA_TX_I_ILG_EN field.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_EN_Pos = 0x1
	// Bit mask of DMA_TX_I_ILG_EN field.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_EN_Msk = 0x2
	// Bit DMA_TX_I_ILG_EN.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_EN = 0x2
	// Position of DMA_TX_I_ILG_INTR field.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_INTR_Pos = 0x2
	// Bit mask of DMA_TX_I_ILG_INTR field.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_INTR_Msk = 0x4
	// Bit DMA_TX_I_ILG_INTR.
	PMS_DMA_TX_I_2_DMA_TX_I_ILG_INTR = 0x4

	// DMA_TX_I_3: TX Copy DMA status register.
	// Position of DMA_TX_I_ILG_ST field.
	PMS_DMA_TX_I_3_DMA_TX_I_ILG_ST_Pos = 0x0
	// Bit mask of DMA_TX_I_ILG_ST field.
	PMS_DMA_TX_I_3_DMA_TX_I_ILG_ST_Msk = 0x7fffff

	// PRO_BOOT_LOCATION_0: Boot permission control register 0.
	// Position of PRO_BOOT_LOCATION_LOCK field.
	PMS_PRO_BOOT_LOCATION_0_PRO_BOOT_LOCATION_LOCK_Pos = 0x0
	// Bit mask of PRO_BOOT_LOCATION_LOCK field.
	PMS_PRO_BOOT_LOCATION_0_PRO_BOOT_LOCATION_LOCK_Msk = 0x1
	// Bit PRO_BOOT_LOCATION_LOCK.
	PMS_PRO_BOOT_LOCATION_0_PRO_BOOT_LOCATION_LOCK = 0x1

	// PRO_BOOT_LOCATION_1: Boot permission control register 1.
	// Position of PRO_BOOT_REMAP field.
	PMS_PRO_BOOT_LOCATION_1_PRO_BOOT_REMAP_Pos = 0x0
	// Bit mask of PRO_BOOT_REMAP field.
	PMS_PRO_BOOT_LOCATION_1_PRO_BOOT_REMAP_Msk = 0x1
	// Bit PRO_BOOT_REMAP.
	PMS_PRO_BOOT_LOCATION_1_PRO_BOOT_REMAP = 0x1

	// CACHE_SOURCE_0: Cache access permission control register 0.
	// Position of CACHE_SOURCE_LOCK field.
	PMS_CACHE_SOURCE_0_CACHE_SOURCE_LOCK_Pos = 0x0
	// Bit mask of CACHE_SOURCE_LOCK field.
	PMS_CACHE_SOURCE_0_CACHE_SOURCE_LOCK_Msk = 0x1
	// Bit CACHE_SOURCE_LOCK.
	PMS_CACHE_SOURCE_0_CACHE_SOURCE_LOCK = 0x1

	// CACHE_SOURCE_1: Cache access permission control register 1.
	// Position of PRO_CACHE_I_SOURCE_PRO_IRAM1 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IRAM1_Pos = 0x0
	// Bit mask of PRO_CACHE_I_SOURCE_PRO_IRAM1 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IRAM1_Msk = 0x1
	// Bit PRO_CACHE_I_SOURCE_PRO_IRAM1.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IRAM1 = 0x1
	// Position of PRO_CACHE_I_SOURCE_PRO_IROM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IROM0_Pos = 0x1
	// Bit mask of PRO_CACHE_I_SOURCE_PRO_IROM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IROM0_Msk = 0x2
	// Bit PRO_CACHE_I_SOURCE_PRO_IROM0.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_IROM0 = 0x2
	// Position of PRO_CACHE_I_SOURCE_PRO_DROM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_DROM0_Pos = 0x2
	// Bit mask of PRO_CACHE_I_SOURCE_PRO_DROM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_DROM0_Msk = 0x4
	// Bit PRO_CACHE_I_SOURCE_PRO_DROM0.
	PMS_CACHE_SOURCE_1_PRO_CACHE_I_SOURCE_PRO_DROM0 = 0x4
	// Position of PRO_CACHE_D_SOURCE_PRO_DRAM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DRAM0_Pos = 0x3
	// Bit mask of PRO_CACHE_D_SOURCE_PRO_DRAM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DRAM0_Msk = 0x8
	// Bit PRO_CACHE_D_SOURCE_PRO_DRAM0.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DRAM0 = 0x8
	// Position of PRO_CACHE_D_SOURCE_PRO_DPORT field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DPORT_Pos = 0x4
	// Bit mask of PRO_CACHE_D_SOURCE_PRO_DPORT field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DPORT_Msk = 0x10
	// Bit PRO_CACHE_D_SOURCE_PRO_DPORT.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DPORT = 0x10
	// Position of PRO_CACHE_D_SOURCE_PRO_DROM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DROM0_Pos = 0x5
	// Bit mask of PRO_CACHE_D_SOURCE_PRO_DROM0 field.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DROM0_Msk = 0x20
	// Bit PRO_CACHE_D_SOURCE_PRO_DROM0.
	PMS_CACHE_SOURCE_1_PRO_CACHE_D_SOURCE_PRO_DROM0 = 0x20

	// APB_PERIPHERAL_0: Peripheral access permission control register 0.
	// Position of APB_PERIPHERAL_LOCK field.
	PMS_APB_PERIPHERAL_0_APB_PERIPHERAL_LOCK_Pos = 0x0
	// Bit mask of APB_PERIPHERAL_LOCK field.
	PMS_APB_PERIPHERAL_0_APB_PERIPHERAL_LOCK_Msk = 0x1
	// Bit APB_PERIPHERAL_LOCK.
	PMS_APB_PERIPHERAL_0_APB_PERIPHERAL_LOCK = 0x1

	// APB_PERIPHERAL_1: Peripheral access permission control register 1.
	// Position of APB_PERIPHERAL_SPLIT_BURST field.
	PMS_APB_PERIPHERAL_1_APB_PERIPHERAL_SPLIT_BURST_Pos = 0x0
	// Bit mask of APB_PERIPHERAL_SPLIT_BURST field.
	PMS_APB_PERIPHERAL_1_APB_PERIPHERAL_SPLIT_BURST_Msk = 0x1
	// Bit APB_PERIPHERAL_SPLIT_BURST.
	PMS_APB_PERIPHERAL_1_APB_PERIPHERAL_SPLIT_BURST = 0x1

	// OCCUPY_0: Occupy permission control register 0.
	// Position of OCCUPY_LOCK field.
	PMS_OCCUPY_0_OCCUPY_LOCK_Pos = 0x0
	// Bit mask of OCCUPY_LOCK field.
	PMS_OCCUPY_0_OCCUPY_LOCK_Msk = 0x1
	// Bit OCCUPY_LOCK.
	PMS_OCCUPY_0_OCCUPY_LOCK = 0x1

	// OCCUPY_1: Occupy permission control register 1.
	// Position of OCCUPY_CACHE field.
	PMS_OCCUPY_1_OCCUPY_CACHE_Pos = 0x0
	// Bit mask of OCCUPY_CACHE field.
	PMS_OCCUPY_1_OCCUPY_CACHE_Msk = 0xf

	// OCCUPY_2: Occupy permission control register 2.
	// Position of OCCUPY_MAC_DUMP field.
	PMS_OCCUPY_2_OCCUPY_MAC_DUMP_Pos = 0x0
	// Bit mask of OCCUPY_MAC_DUMP field.
	PMS_OCCUPY_2_OCCUPY_MAC_DUMP_Msk = 0xf

	// OCCUPY_3: Occupy permission control register 3.
	// Position of OCCUPY_PRO_TRACE field.
	PMS_OCCUPY_3_OCCUPY_PRO_TRACE_Pos = 0x0
	// Bit mask of OCCUPY_PRO_TRACE field.
	PMS_OCCUPY_3_OCCUPY_PRO_TRACE_Msk = 0x3ffff

	// CACHE_TAG_ACCESS_0: Cache tag permission control register 0.
	// Position of CACHE_TAG_ACCESS_LOCK field.
	PMS_CACHE_TAG_ACCESS_0_CACHE_TAG_ACCESS_LOCK_Pos = 0x0
	// Bit mask of CACHE_TAG_ACCESS_LOCK field.
	PMS_CACHE_TAG_ACCESS_0_CACHE_TAG_ACCESS_LOCK_Msk = 0x1
	// Bit CACHE_TAG_ACCESS_LOCK.
	PMS_CACHE_TAG_ACCESS_0_CACHE_TAG_ACCESS_LOCK = 0x1

	// CACHE_TAG_ACCESS_1: Cache tag permission control register 1.
	// Position of PRO_I_TAG_RD_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_I_TAG_RD_ACS_Pos = 0x0
	// Bit mask of PRO_I_TAG_RD_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_I_TAG_RD_ACS_Msk = 0x1
	// Bit PRO_I_TAG_RD_ACS.
	PMS_CACHE_TAG_ACCESS_1_PRO_I_TAG_RD_ACS = 0x1
	// Position of PRO_I_TAG_WR_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_I_TAG_WR_ACS_Pos = 0x1
	// Bit mask of PRO_I_TAG_WR_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_I_TAG_WR_ACS_Msk = 0x2
	// Bit PRO_I_TAG_WR_ACS.
	PMS_CACHE_TAG_ACCESS_1_PRO_I_TAG_WR_ACS = 0x2
	// Position of PRO_D_TAG_RD_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_D_TAG_RD_ACS_Pos = 0x2
	// Bit mask of PRO_D_TAG_RD_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_D_TAG_RD_ACS_Msk = 0x4
	// Bit PRO_D_TAG_RD_ACS.
	PMS_CACHE_TAG_ACCESS_1_PRO_D_TAG_RD_ACS = 0x4
	// Position of PRO_D_TAG_WR_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_D_TAG_WR_ACS_Pos = 0x3
	// Bit mask of PRO_D_TAG_WR_ACS field.
	PMS_CACHE_TAG_ACCESS_1_PRO_D_TAG_WR_ACS_Msk = 0x8
	// Bit PRO_D_TAG_WR_ACS.
	PMS_CACHE_TAG_ACCESS_1_PRO_D_TAG_WR_ACS = 0x8

	// CACHE_MMU_ACCESS_0: Cache MMU permission control register 0.
	// Position of CACHE_MMU_ACCESS_LOCK field.
	PMS_CACHE_MMU_ACCESS_0_CACHE_MMU_ACCESS_LOCK_Pos = 0x0
	// Bit mask of CACHE_MMU_ACCESS_LOCK field.
	PMS_CACHE_MMU_ACCESS_0_CACHE_MMU_ACCESS_LOCK_Msk = 0x1
	// Bit CACHE_MMU_ACCESS_LOCK.
	PMS_CACHE_MMU_ACCESS_0_CACHE_MMU_ACCESS_LOCK = 0x1

	// CACHE_MMU_ACCESS_1: Cache MMU permission control register 1.
	// Position of PRO_MMU_RD_ACS field.
	PMS_CACHE_MMU_ACCESS_1_PRO_MMU_RD_ACS_Pos = 0x0
	// Bit mask of PRO_MMU_RD_ACS field.
	PMS_CACHE_MMU_ACCESS_1_PRO_MMU_RD_ACS_Msk = 0x1
	// Bit PRO_MMU_RD_ACS.
	PMS_CACHE_MMU_ACCESS_1_PRO_MMU_RD_ACS = 0x1
	// Position of PRO_MMU_WR_ACS field.
	PMS_CACHE_MMU_ACCESS_1_PRO_MMU_WR_ACS_Pos = 0x1
	// Bit mask of PRO_MMU_WR_ACS field.
	PMS_CACHE_MMU_ACCESS_1_PRO_MMU_WR_ACS_Msk = 0x2
	// Bit PRO_MMU_WR_ACS.
	PMS_CACHE_MMU_ACCESS_1_PRO_MMU_WR_ACS = 0x2

	// APB_PERIPHERAL_INTR: PeribBus2 permission control register.
	// Position of APB_PERI_BYTE_ERROR_CLR field.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_CLR_Pos = 0x0
	// Bit mask of APB_PERI_BYTE_ERROR_CLR field.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_CLR_Msk = 0x1
	// Bit APB_PERI_BYTE_ERROR_CLR.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_CLR = 0x1
	// Position of APB_PERI_BYTE_ERROR_EN field.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_EN_Pos = 0x1
	// Bit mask of APB_PERI_BYTE_ERROR_EN field.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_EN_Msk = 0x2
	// Bit APB_PERI_BYTE_ERROR_EN.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_EN = 0x2
	// Position of APB_PERI_BYTE_ERROR_INTR field.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_INTR_Pos = 0x2
	// Bit mask of APB_PERI_BYTE_ERROR_INTR field.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_INTR_Msk = 0x4
	// Bit APB_PERI_BYTE_ERROR_INTR.
	PMS_APB_PERIPHERAL_INTR_APB_PERI_BYTE_ERROR_INTR = 0x4

	// APB_PERIPHERAL_STATUS: PeribBus2 peripheral access status register.
	// Position of APB_PERI_BYTE_ERROR_ADDR field.
	PMS_APB_PERIPHERAL_STATUS_APB_PERI_BYTE_ERROR_ADDR_Pos = 0x0
	// Bit mask of APB_PERI_BYTE_ERROR_ADDR field.
	PMS_APB_PERIPHERAL_STATUS_APB_PERI_BYTE_ERROR_ADDR_Msk = 0xffffffff

	// CPU_PERIPHERAL_INTR: PeribBus1 permission control register.
	// Position of CPU_PERI_BYTE_ERROR_CLR field.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_CLR_Pos = 0x0
	// Bit mask of CPU_PERI_BYTE_ERROR_CLR field.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_CLR_Msk = 0x1
	// Bit CPU_PERI_BYTE_ERROR_CLR.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_CLR = 0x1
	// Position of CPU_PERI_BYTE_ERROR_EN field.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_EN_Pos = 0x1
	// Bit mask of CPU_PERI_BYTE_ERROR_EN field.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_EN_Msk = 0x2
	// Bit CPU_PERI_BYTE_ERROR_EN.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_EN = 0x2
	// Position of CPU_PERI_BYTE_ERROR_INTR field.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_INTR_Pos = 0x2
	// Bit mask of CPU_PERI_BYTE_ERROR_INTR field.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_INTR_Msk = 0x4
	// Bit CPU_PERI_BYTE_ERROR_INTR.
	PMS_CPU_PERIPHERAL_INTR_CPU_PERI_BYTE_ERROR_INTR = 0x4

	// CPU_PERIPHERAL_STATUS: PeribBus1 peripheral access status register.
	// Position of CPU_PERI_BYTE_ERROR_ADDR field.
	PMS_CPU_PERIPHERAL_STATUS_CPU_PERI_BYTE_ERROR_ADDR_Pos = 0x0
	// Bit mask of CPU_PERI_BYTE_ERROR_ADDR field.
	PMS_CPU_PERIPHERAL_STATUS_CPU_PERI_BYTE_ERROR_ADDR_Msk = 0xffffffff

	// CLOCK_GATE: Clock gate register of permission control.
	// Position of CLK_EN field.
	PMS_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	PMS_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	PMS_CLOCK_GATE_CLK_EN = 0x1

	// DATE: Version control register.
	// Position of DATE field.
	PMS_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	PMS_DATE_DATE_Msk = 0xfffffff
)

// Constants for RMT: Remote Control
const (
	// CH0DATA: The read and write data register for CHANNEL%s by apb fifo access.
	// Position of DATA field.
	RMT_CHDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	RMT_CHDATA_DATA_Msk = 0xffffffff

	// CH0CONF0: Channel %s configure register 0
	// Position of DIV_CNT field.
	RMT_CHCONF0_DIV_CNT_Pos = 0x0
	// Bit mask of DIV_CNT field.
	RMT_CHCONF0_DIV_CNT_Msk = 0xff
	// Position of IDLE_THRES field.
	RMT_CHCONF0_IDLE_THRES_Pos = 0x8
	// Bit mask of IDLE_THRES field.
	RMT_CHCONF0_IDLE_THRES_Msk = 0xffff00
	// Position of MEM_SIZE field.
	RMT_CHCONF0_MEM_SIZE_Pos = 0x18
	// Bit mask of MEM_SIZE field.
	RMT_CHCONF0_MEM_SIZE_Msk = 0x7000000
	// Position of CARRIER_EFF_EN field.
	RMT_CHCONF0_CARRIER_EFF_EN_Pos = 0x1b
	// Bit mask of CARRIER_EFF_EN field.
	RMT_CHCONF0_CARRIER_EFF_EN_Msk = 0x8000000
	// Bit CARRIER_EFF_EN.
	RMT_CHCONF0_CARRIER_EFF_EN = 0x8000000
	// Position of CARRIER_EN field.
	RMT_CHCONF0_CARRIER_EN_Pos = 0x1c
	// Bit mask of CARRIER_EN field.
	RMT_CHCONF0_CARRIER_EN_Msk = 0x10000000
	// Bit CARRIER_EN.
	RMT_CHCONF0_CARRIER_EN = 0x10000000
	// Position of CARRIER_OUT_LV field.
	RMT_CHCONF0_CARRIER_OUT_LV_Pos = 0x1d
	// Bit mask of CARRIER_OUT_LV field.
	RMT_CHCONF0_CARRIER_OUT_LV_Msk = 0x20000000
	// Bit CARRIER_OUT_LV.
	RMT_CHCONF0_CARRIER_OUT_LV = 0x20000000

	// CH0CONF1: Channel %s configure register 1
	// Position of TX_START field.
	RMT_CHCONF1_TX_START_Pos = 0x0
	// Bit mask of TX_START field.
	RMT_CHCONF1_TX_START_Msk = 0x1
	// Bit TX_START.
	RMT_CHCONF1_TX_START = 0x1
	// Position of RX_EN field.
	RMT_CHCONF1_RX_EN_Pos = 0x1
	// Bit mask of RX_EN field.
	RMT_CHCONF1_RX_EN_Msk = 0x2
	// Bit RX_EN.
	RMT_CHCONF1_RX_EN = 0x2
	// Position of MEM_WR_RST field.
	RMT_CHCONF1_MEM_WR_RST_Pos = 0x2
	// Bit mask of MEM_WR_RST field.
	RMT_CHCONF1_MEM_WR_RST_Msk = 0x4
	// Bit MEM_WR_RST.
	RMT_CHCONF1_MEM_WR_RST = 0x4
	// Position of MEM_RD_RST field.
	RMT_CHCONF1_MEM_RD_RST_Pos = 0x3
	// Bit mask of MEM_RD_RST field.
	RMT_CHCONF1_MEM_RD_RST_Msk = 0x8
	// Bit MEM_RD_RST.
	RMT_CHCONF1_MEM_RD_RST = 0x8
	// Position of APB_MEM_RST field.
	RMT_CHCONF1_APB_MEM_RST_Pos = 0x4
	// Bit mask of APB_MEM_RST field.
	RMT_CHCONF1_APB_MEM_RST_Msk = 0x10
	// Bit APB_MEM_RST.
	RMT_CHCONF1_APB_MEM_RST = 0x10
	// Position of MEM_OWNER field.
	RMT_CHCONF1_MEM_OWNER_Pos = 0x5
	// Bit mask of MEM_OWNER field.
	RMT_CHCONF1_MEM_OWNER_Msk = 0x20
	// Bit MEM_OWNER.
	RMT_CHCONF1_MEM_OWNER = 0x20
	// Position of TX_CONTI_MODE field.
	RMT_CHCONF1_TX_CONTI_MODE_Pos = 0x6
	// Bit mask of TX_CONTI_MODE field.
	RMT_CHCONF1_TX_CONTI_MODE_Msk = 0x40
	// Bit TX_CONTI_MODE.
	RMT_CHCONF1_TX_CONTI_MODE = 0x40
	// Position of RX_FILTER_EN field.
	RMT_CHCONF1_RX_FILTER_EN_Pos = 0x7
	// Bit mask of RX_FILTER_EN field.
	RMT_CHCONF1_RX_FILTER_EN_Msk = 0x80
	// Bit RX_FILTER_EN.
	RMT_CHCONF1_RX_FILTER_EN = 0x80
	// Position of RX_FILTER_THRES field.
	RMT_CHCONF1_RX_FILTER_THRES_Pos = 0x8
	// Bit mask of RX_FILTER_THRES field.
	RMT_CHCONF1_RX_FILTER_THRES_Msk = 0xff00
	// Position of CHK_RX_CARRIER_EN field.
	RMT_CHCONF1_CHK_RX_CARRIER_EN_Pos = 0x10
	// Bit mask of CHK_RX_CARRIER_EN field.
	RMT_CHCONF1_CHK_RX_CARRIER_EN_Msk = 0x10000
	// Bit CHK_RX_CARRIER_EN.
	RMT_CHCONF1_CHK_RX_CARRIER_EN = 0x10000
	// Position of REF_ALWAYS_ON field.
	RMT_CHCONF1_REF_ALWAYS_ON_Pos = 0x11
	// Bit mask of REF_ALWAYS_ON field.
	RMT_CHCONF1_REF_ALWAYS_ON_Msk = 0x20000
	// Bit REF_ALWAYS_ON.
	RMT_CHCONF1_REF_ALWAYS_ON = 0x20000
	// Position of IDLE_OUT_LV field.
	RMT_CHCONF1_IDLE_OUT_LV_Pos = 0x12
	// Bit mask of IDLE_OUT_LV field.
	RMT_CHCONF1_IDLE_OUT_LV_Msk = 0x40000
	// Bit IDLE_OUT_LV.
	RMT_CHCONF1_IDLE_OUT_LV = 0x40000
	// Position of IDLE_OUT_EN field.
	RMT_CHCONF1_IDLE_OUT_EN_Pos = 0x13
	// Bit mask of IDLE_OUT_EN field.
	RMT_CHCONF1_IDLE_OUT_EN_Msk = 0x80000
	// Bit IDLE_OUT_EN.
	RMT_CHCONF1_IDLE_OUT_EN = 0x80000
	// Position of TX_STOP field.
	RMT_CHCONF1_TX_STOP_Pos = 0x14
	// Bit mask of TX_STOP field.
	RMT_CHCONF1_TX_STOP_Msk = 0x100000
	// Bit TX_STOP.
	RMT_CHCONF1_TX_STOP = 0x100000

	// CH0STATUS: Channel %s status register
	// Position of MEM_WADDR_EX field.
	RMT_CHSTATUS_MEM_WADDR_EX_Pos = 0x0
	// Bit mask of MEM_WADDR_EX field.
	RMT_CHSTATUS_MEM_WADDR_EX_Msk = 0x1ff
	// Position of MEM_RADDR_EX field.
	RMT_CHSTATUS_MEM_RADDR_EX_Pos = 0xa
	// Bit mask of MEM_RADDR_EX field.
	RMT_CHSTATUS_MEM_RADDR_EX_Msk = 0x7fc00
	// Position of STATE field.
	RMT_CHSTATUS_STATE_Pos = 0x14
	// Bit mask of STATE field.
	RMT_CHSTATUS_STATE_Msk = 0x700000
	// Position of MEM_OWNER_ERR field.
	RMT_CHSTATUS_MEM_OWNER_ERR_Pos = 0x17
	// Bit mask of MEM_OWNER_ERR field.
	RMT_CHSTATUS_MEM_OWNER_ERR_Msk = 0x800000
	// Bit MEM_OWNER_ERR.
	RMT_CHSTATUS_MEM_OWNER_ERR = 0x800000
	// Position of MEM_FULL field.
	RMT_CHSTATUS_MEM_FULL_Pos = 0x18
	// Bit mask of MEM_FULL field.
	RMT_CHSTATUS_MEM_FULL_Msk = 0x1000000
	// Bit MEM_FULL.
	RMT_CHSTATUS_MEM_FULL = 0x1000000
	// Position of MEM_EMPTY field.
	RMT_CHSTATUS_MEM_EMPTY_Pos = 0x19
	// Bit mask of MEM_EMPTY field.
	RMT_CHSTATUS_MEM_EMPTY_Msk = 0x2000000
	// Bit MEM_EMPTY.
	RMT_CHSTATUS_MEM_EMPTY = 0x2000000
	// Position of APB_MEM_WR_ERR field.
	RMT_CHSTATUS_APB_MEM_WR_ERR_Pos = 0x1a
	// Bit mask of APB_MEM_WR_ERR field.
	RMT_CHSTATUS_APB_MEM_WR_ERR_Msk = 0x4000000
	// Bit APB_MEM_WR_ERR.
	RMT_CHSTATUS_APB_MEM_WR_ERR = 0x4000000
	// Position of APB_MEM_RD_ERR field.
	RMT_CHSTATUS_APB_MEM_RD_ERR_Pos = 0x1b
	// Bit mask of APB_MEM_RD_ERR field.
	RMT_CHSTATUS_APB_MEM_RD_ERR_Msk = 0x8000000
	// Bit APB_MEM_RD_ERR.
	RMT_CHSTATUS_APB_MEM_RD_ERR = 0x8000000

	// CH0ADDR: Channel %s address register
	// Position of APB_MEM_WADDR field.
	RMT_CHADDR_APB_MEM_WADDR_Pos = 0x0
	// Bit mask of APB_MEM_WADDR field.
	RMT_CHADDR_APB_MEM_WADDR_Msk = 0x1ff
	// Position of APB_MEM_RADDR field.
	RMT_CHADDR_APB_MEM_RADDR_Pos = 0xa
	// Bit mask of APB_MEM_RADDR field.
	RMT_CHADDR_APB_MEM_RADDR_Msk = 0x7fc00

	// INT_RAW: Raw interrupt status
	// Position of CH_s_TX_END field.
	RMT_INT_RAW_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_RAW_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_RAW_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_RAW_CH_s_RX_END_Pos = 0x1
	// Bit mask of CH_s_RX_END field.
	RMT_INT_RAW_CH_s_RX_END_Msk = 0x2
	// Bit CH_s_RX_END.
	RMT_INT_RAW_CH_s_RX_END = 0x2
	// Position of CH_s_ERR field.
	RMT_INT_RAW_CH_s_ERR_Pos = 0x2
	// Bit mask of CH_s_ERR field.
	RMT_INT_RAW_CH_s_ERR_Msk = 0x4
	// Bit CH_s_ERR.
	RMT_INT_RAW_CH_s_ERR = 0x4
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_RAW_CH_s_TX_THR_EVENT_Pos = 0xc
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_RAW_CH_s_TX_THR_EVENT_Msk = 0x1000
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_RAW_CH_s_TX_THR_EVENT = 0x1000
	// Position of CH_s_TX_LOOP field.
	RMT_INT_RAW_CH_s_TX_LOOP_Pos = 0x10
	// Bit mask of CH_s_TX_LOOP field.
	RMT_INT_RAW_CH_s_TX_LOOP_Msk = 0x10000
	// Bit CH_s_TX_LOOP.
	RMT_INT_RAW_CH_s_TX_LOOP = 0x10000

	// INT_ST: Masked interrupt status
	// Position of CH_s_TX_END field.
	RMT_INT_ST_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_ST_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_ST_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_ST_CH_s_RX_END_Pos = 0x1
	// Bit mask of CH_s_RX_END field.
	RMT_INT_ST_CH_s_RX_END_Msk = 0x2
	// Bit CH_s_RX_END.
	RMT_INT_ST_CH_s_RX_END = 0x2
	// Position of CH_s_ERR field.
	RMT_INT_ST_CH_s_ERR_Pos = 0x2
	// Bit mask of CH_s_ERR field.
	RMT_INT_ST_CH_s_ERR_Msk = 0x4
	// Bit CH_s_ERR.
	RMT_INT_ST_CH_s_ERR = 0x4
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_ST_CH_s_TX_THR_EVENT_Pos = 0xc
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_ST_CH_s_TX_THR_EVENT_Msk = 0x1000
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_ST_CH_s_TX_THR_EVENT = 0x1000
	// Position of CH_s_TX_LOOP field.
	RMT_INT_ST_CH_s_TX_LOOP_Pos = 0x10
	// Bit mask of CH_s_TX_LOOP field.
	RMT_INT_ST_CH_s_TX_LOOP_Msk = 0x10000
	// Bit CH_s_TX_LOOP.
	RMT_INT_ST_CH_s_TX_LOOP = 0x10000

	// INT_ENA: Interrupt enable bits
	// Position of CH_s_TX_END field.
	RMT_INT_ENA_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_ENA_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_ENA_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_ENA_CH_s_RX_END_Pos = 0x1
	// Bit mask of CH_s_RX_END field.
	RMT_INT_ENA_CH_s_RX_END_Msk = 0x2
	// Bit CH_s_RX_END.
	RMT_INT_ENA_CH_s_RX_END = 0x2
	// Position of CH_s_ERR field.
	RMT_INT_ENA_CH_s_ERR_Pos = 0x2
	// Bit mask of CH_s_ERR field.
	RMT_INT_ENA_CH_s_ERR_Msk = 0x4
	// Bit CH_s_ERR.
	RMT_INT_ENA_CH_s_ERR = 0x4
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_ENA_CH_s_TX_THR_EVENT_Pos = 0xc
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_ENA_CH_s_TX_THR_EVENT_Msk = 0x1000
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_ENA_CH_s_TX_THR_EVENT = 0x1000
	// Position of CH_s_TX_LOOP field.
	RMT_INT_ENA_CH_s_TX_LOOP_Pos = 0x10
	// Bit mask of CH_s_TX_LOOP field.
	RMT_INT_ENA_CH_s_TX_LOOP_Msk = 0x10000
	// Bit CH_s_TX_LOOP.
	RMT_INT_ENA_CH_s_TX_LOOP = 0x10000

	// INT_CLR: Interrupt clear bits
	// Position of CH_s_TX_END field.
	RMT_INT_CLR_CH_s_TX_END_Pos = 0x0
	// Bit mask of CH_s_TX_END field.
	RMT_INT_CLR_CH_s_TX_END_Msk = 0x1
	// Bit CH_s_TX_END.
	RMT_INT_CLR_CH_s_TX_END = 0x1
	// Position of CH_s_RX_END field.
	RMT_INT_CLR_CH_s_RX_END_Pos = 0x1
	// Bit mask of CH_s_RX_END field.
	RMT_INT_CLR_CH_s_RX_END_Msk = 0x2
	// Bit CH_s_RX_END.
	RMT_INT_CLR_CH_s_RX_END = 0x2
	// Position of CH_s_ERR field.
	RMT_INT_CLR_CH_s_ERR_Pos = 0x2
	// Bit mask of CH_s_ERR field.
	RMT_INT_CLR_CH_s_ERR_Msk = 0x4
	// Bit CH_s_ERR.
	RMT_INT_CLR_CH_s_ERR = 0x4
	// Position of CH_s_TX_THR_EVENT field.
	RMT_INT_CLR_CH_s_TX_THR_EVENT_Pos = 0xc
	// Bit mask of CH_s_TX_THR_EVENT field.
	RMT_INT_CLR_CH_s_TX_THR_EVENT_Msk = 0x1000
	// Bit CH_s_TX_THR_EVENT.
	RMT_INT_CLR_CH_s_TX_THR_EVENT = 0x1000
	// Position of CH_s_TX_LOOP field.
	RMT_INT_CLR_CH_s_TX_LOOP_Pos = 0x10
	// Bit mask of CH_s_TX_LOOP field.
	RMT_INT_CLR_CH_s_TX_LOOP_Msk = 0x10000
	// Bit CH_s_TX_LOOP.
	RMT_INT_CLR_CH_s_TX_LOOP = 0x10000

	// CH0CARRIER_DUTY: Channel %s duty cycle configuration register
	// Position of CARRIER_LOW field.
	RMT_CHCARRIER_DUTY_CARRIER_LOW_Pos = 0x0
	// Bit mask of CARRIER_LOW field.
	RMT_CHCARRIER_DUTY_CARRIER_LOW_Msk = 0xffff
	// Position of CARRIER_HIGH field.
	RMT_CHCARRIER_DUTY_CARRIER_HIGH_Pos = 0x10
	// Bit mask of CARRIER_HIGH field.
	RMT_CHCARRIER_DUTY_CARRIER_HIGH_Msk = 0xffff0000

	// CH0_TX_LIM: Channel %s Tx event configuration register
	// Position of TX_LIM field.
	RMT_CH_TX_LIM_TX_LIM_Pos = 0x0
	// Bit mask of TX_LIM field.
	RMT_CH_TX_LIM_TX_LIM_Msk = 0x1ff
	// Position of TX_LOOP_NUM field.
	RMT_CH_TX_LIM_TX_LOOP_NUM_Pos = 0x9
	// Bit mask of TX_LOOP_NUM field.
	RMT_CH_TX_LIM_TX_LOOP_NUM_Msk = 0x7fe00
	// Position of TX_LOOP_CNT_EN field.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_Pos = 0x13
	// Bit mask of TX_LOOP_CNT_EN field.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN_Msk = 0x80000
	// Bit TX_LOOP_CNT_EN.
	RMT_CH_TX_LIM_TX_LOOP_CNT_EN = 0x80000
	// Position of LOOP_COUNT_RESET field.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_Pos = 0x14
	// Bit mask of LOOP_COUNT_RESET field.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET_Msk = 0x100000
	// Bit LOOP_COUNT_RESET.
	RMT_CH_TX_LIM_LOOP_COUNT_RESET = 0x100000

	// APB_CONF: RMT apb configuration register
	// Position of APB_FIFO_MASK field.
	RMT_APB_CONF_APB_FIFO_MASK_Pos = 0x0
	// Bit mask of APB_FIFO_MASK field.
	RMT_APB_CONF_APB_FIFO_MASK_Msk = 0x1
	// Bit APB_FIFO_MASK.
	RMT_APB_CONF_APB_FIFO_MASK = 0x1
	// Position of MEM_TX_WRAP_EN field.
	RMT_APB_CONF_MEM_TX_WRAP_EN_Pos = 0x1
	// Bit mask of MEM_TX_WRAP_EN field.
	RMT_APB_CONF_MEM_TX_WRAP_EN_Msk = 0x2
	// Bit MEM_TX_WRAP_EN.
	RMT_APB_CONF_MEM_TX_WRAP_EN = 0x2
	// Position of MEM_CLK_FORCE_ON field.
	RMT_APB_CONF_MEM_CLK_FORCE_ON_Pos = 0x2
	// Bit mask of MEM_CLK_FORCE_ON field.
	RMT_APB_CONF_MEM_CLK_FORCE_ON_Msk = 0x4
	// Bit MEM_CLK_FORCE_ON.
	RMT_APB_CONF_MEM_CLK_FORCE_ON = 0x4
	// Position of MEM_FORCE_PD field.
	RMT_APB_CONF_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of MEM_FORCE_PD field.
	RMT_APB_CONF_MEM_FORCE_PD_Msk = 0x8
	// Bit MEM_FORCE_PD.
	RMT_APB_CONF_MEM_FORCE_PD = 0x8
	// Position of MEM_FORCE_PU field.
	RMT_APB_CONF_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of MEM_FORCE_PU field.
	RMT_APB_CONF_MEM_FORCE_PU_Msk = 0x10
	// Bit MEM_FORCE_PU.
	RMT_APB_CONF_MEM_FORCE_PU = 0x10
	// Position of CLK_EN field.
	RMT_APB_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	RMT_APB_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	RMT_APB_CONF_CLK_EN = 0x80000000

	// TX_SIM: RMT TX synchronous register
	// Position of CH0 field.
	RMT_TX_SIM_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	RMT_TX_SIM_CH0_Msk = 0x1
	// Bit CH0.
	RMT_TX_SIM_CH0 = 0x1
	// Position of CH1 field.
	RMT_TX_SIM_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	RMT_TX_SIM_CH1_Msk = 0x2
	// Bit CH1.
	RMT_TX_SIM_CH1 = 0x2
	// Position of CH2 field.
	RMT_TX_SIM_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	RMT_TX_SIM_CH2_Msk = 0x4
	// Bit CH2.
	RMT_TX_SIM_CH2 = 0x4
	// Position of CH3 field.
	RMT_TX_SIM_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	RMT_TX_SIM_CH3_Msk = 0x8
	// Bit CH3.
	RMT_TX_SIM_CH3 = 0x8
	// Position of EN field.
	RMT_TX_SIM_EN_Pos = 0x4
	// Bit mask of EN field.
	RMT_TX_SIM_EN_Msk = 0x10
	// Bit EN.
	RMT_TX_SIM_EN = 0x10

	// REF_CNT_RST: RMT clock divider reset register
	// Position of CH0 field.
	RMT_REF_CNT_RST_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	RMT_REF_CNT_RST_CH0_Msk = 0x1
	// Bit CH0.
	RMT_REF_CNT_RST_CH0 = 0x1
	// Position of CH1 field.
	RMT_REF_CNT_RST_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	RMT_REF_CNT_RST_CH1_Msk = 0x2
	// Bit CH1.
	RMT_REF_CNT_RST_CH1 = 0x2
	// Position of CH2 field.
	RMT_REF_CNT_RST_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	RMT_REF_CNT_RST_CH2_Msk = 0x4
	// Bit CH2.
	RMT_REF_CNT_RST_CH2 = 0x4
	// Position of CH3 field.
	RMT_REF_CNT_RST_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	RMT_REF_CNT_RST_CH3_Msk = 0x8
	// Bit CH3.
	RMT_REF_CNT_RST_CH3 = 0x8

	// CH0_RX_CARRIER_RM: Channel %s carrier remove register
	// Position of CARRIER_LOW_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_LOW_THRES_Pos = 0x0
	// Bit mask of CARRIER_LOW_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_LOW_THRES_Msk = 0xffff
	// Position of CARRIER_HIGH_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_HIGH_THRES_Pos = 0x10
	// Bit mask of CARRIER_HIGH_THRES field.
	RMT_CH_RX_CARRIER_RM_CARRIER_HIGH_THRES_Msk = 0xffff0000

	// DATE: RMT version register
	// Position of DATE field.
	RMT_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	RMT_DATE_DATE_Msk = 0xffffffff
)

// Constants for RNG: Hardware Random Number Generator
const ()

// Constants for RSA: RSA (Rivest Shamir Adleman) Accelerator
const (
	// M_PRIME: Register to store M'
	// Position of M_PRIME field.
	RSA_M_PRIME_M_PRIME_Pos = 0x0
	// Bit mask of M_PRIME field.
	RSA_M_PRIME_M_PRIME_Msk = 0xffffffff

	// MODE: RSA length mode
	// Position of MODE field.
	RSA_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	RSA_MODE_MODE_Msk = 0x7f

	// CLEAN: RSA clean register
	// Position of CLEAN field.
	RSA_CLEAN_CLEAN_Pos = 0x0
	// Bit mask of CLEAN field.
	RSA_CLEAN_CLEAN_Msk = 0x1
	// Bit CLEAN.
	RSA_CLEAN_CLEAN = 0x1

	// MODEXP_START: Modular exponentiation starting bit
	// Position of MODEXP_START field.
	RSA_MODEXP_START_MODEXP_START_Pos = 0x0
	// Bit mask of MODEXP_START field.
	RSA_MODEXP_START_MODEXP_START_Msk = 0x1
	// Bit MODEXP_START.
	RSA_MODEXP_START_MODEXP_START = 0x1

	// MODMULT_START: Modular multiplication starting bit
	// Position of MODMULT_START field.
	RSA_MODMULT_START_MODMULT_START_Pos = 0x0
	// Bit mask of MODMULT_START field.
	RSA_MODMULT_START_MODMULT_START_Msk = 0x1
	// Bit MODMULT_START.
	RSA_MODMULT_START_MODMULT_START = 0x1

	// MULT_START: Normal multiplication starting bit
	// Position of MULT_START field.
	RSA_MULT_START_MULT_START_Pos = 0x0
	// Bit mask of MULT_START field.
	RSA_MULT_START_MULT_START_Msk = 0x1
	// Bit MULT_START.
	RSA_MULT_START_MULT_START = 0x1

	// IDLE: RSA idle register
	// Position of IDLE field.
	RSA_IDLE_IDLE_Pos = 0x0
	// Bit mask of IDLE field.
	RSA_IDLE_IDLE_Msk = 0x1
	// Bit IDLE.
	RSA_IDLE_IDLE = 0x1

	// CLEAR_INTERRUPT: RSA clear interrupt register
	// Position of CLEAR_INTERRUPT field.
	RSA_CLEAR_INTERRUPT_CLEAR_INTERRUPT_Pos = 0x0
	// Bit mask of CLEAR_INTERRUPT field.
	RSA_CLEAR_INTERRUPT_CLEAR_INTERRUPT_Msk = 0x1
	// Bit CLEAR_INTERRUPT.
	RSA_CLEAR_INTERRUPT_CLEAR_INTERRUPT = 0x1

	// CONSTANT_TIME: The constant_time option
	// Position of CONSTANT_TIME field.
	RSA_CONSTANT_TIME_CONSTANT_TIME_Pos = 0x0
	// Bit mask of CONSTANT_TIME field.
	RSA_CONSTANT_TIME_CONSTANT_TIME_Msk = 0x1
	// Bit CONSTANT_TIME.
	RSA_CONSTANT_TIME_CONSTANT_TIME = 0x1

	// SEARCH_ENABLE: The search option
	// Position of SEARCH_ENABLE field.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE_Pos = 0x0
	// Bit mask of SEARCH_ENABLE field.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE_Msk = 0x1
	// Bit SEARCH_ENABLE.
	RSA_SEARCH_ENABLE_SEARCH_ENABLE = 0x1

	// SEARCH_POS: The search position
	// Position of SEARCH_POS field.
	RSA_SEARCH_POS_SEARCH_POS_Pos = 0x0
	// Bit mask of SEARCH_POS field.
	RSA_SEARCH_POS_SEARCH_POS_Msk = 0xfff

	// INTERRUPT_ENA: RSA interrupt enable register
	// Position of INTERRUPT_ENA field.
	RSA_INTERRUPT_ENA_INTERRUPT_ENA_Pos = 0x0
	// Bit mask of INTERRUPT_ENA field.
	RSA_INTERRUPT_ENA_INTERRUPT_ENA_Msk = 0x1
	// Bit INTERRUPT_ENA.
	RSA_INTERRUPT_ENA_INTERRUPT_ENA = 0x1

	// DATE: Version control register
	// Position of DATE field.
	RSA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	RSA_DATE_DATE_Msk = 0x3fffffff
)

// Constants for RTC_IO: Low-power Input/Output
const (
	// RTC_GPIO_OUT: RTC GPIO output register
	// Position of GPIO_OUT_DATA field.
	RTCIO_RTC_GPIO_OUT_GPIO_OUT_DATA_Pos = 0xa
	// Bit mask of GPIO_OUT_DATA field.
	RTCIO_RTC_GPIO_OUT_GPIO_OUT_DATA_Msk = 0xfffffc00

	// RTC_GPIO_OUT_W1TS: RTC GPIO output bit set register
	// Position of GPIO_OUT_DATA_W1TS field.
	RTCIO_RTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS_Pos = 0xa
	// Bit mask of GPIO_OUT_DATA_W1TS field.
	RTCIO_RTC_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS_Msk = 0xfffffc00

	// RTC_GPIO_OUT_W1TC: RTC GPIO output bit clear register
	// Position of GPIO_OUT_DATA_W1TC field.
	RTCIO_RTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC_Pos = 0xa
	// Bit mask of GPIO_OUT_DATA_W1TC field.
	RTCIO_RTC_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC_Msk = 0xfffffc00

	// RTC_GPIO_ENABLE: RTC GPIO output enable register
	// Position of REG_RTCIO_REG_GPIO_ENABLE field.
	RTCIO_RTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE_Pos = 0xa
	// Bit mask of REG_RTCIO_REG_GPIO_ENABLE field.
	RTCIO_RTC_GPIO_ENABLE_REG_RTCIO_REG_GPIO_ENABLE_Msk = 0xfffffc00

	// RTC_GPIO_ENABLE_W1TS: RTC GPIO output enable bit set register
	// Position of REG_RTCIO_REG_GPIO_ENABLE_W1TS field.
	RTCIO_RTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS_Pos = 0xa
	// Bit mask of REG_RTCIO_REG_GPIO_ENABLE_W1TS field.
	RTCIO_RTC_GPIO_ENABLE_W1TS_REG_RTCIO_REG_GPIO_ENABLE_W1TS_Msk = 0xfffffc00

	// ENABLE_W1TC: RTC GPIO output enable bit clear register
	// Position of ENABLE_W1TC field.
	RTCIO_ENABLE_W1TC_ENABLE_W1TC_Pos = 0xa
	// Bit mask of ENABLE_W1TC field.
	RTCIO_ENABLE_W1TC_ENABLE_W1TC_Msk = 0xfffffc00

	// RTC_GPIO_STATUS: RTC GPIO interrupt status register
	// Position of GPIO_STATUS_INT field.
	RTCIO_RTC_GPIO_STATUS_GPIO_STATUS_INT_Pos = 0xa
	// Bit mask of GPIO_STATUS_INT field.
	RTCIO_RTC_GPIO_STATUS_GPIO_STATUS_INT_Msk = 0xfffffc00

	// RTC_GPIO_STATUS_W1TS: RTC GPIO interrupt status bit set register
	// Position of GPIO_STATUS_INT_W1TS field.
	RTCIO_RTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS_Pos = 0xa
	// Bit mask of GPIO_STATUS_INT_W1TS field.
	RTCIO_RTC_GPIO_STATUS_W1TS_GPIO_STATUS_INT_W1TS_Msk = 0xfffffc00

	// RTC_GPIO_STATUS_W1TC: RTC GPIO interrupt status bit clear register
	// Position of GPIO_STATUS_INT_W1TC field.
	RTCIO_RTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC_Pos = 0xa
	// Bit mask of GPIO_STATUS_INT_W1TC field.
	RTCIO_RTC_GPIO_STATUS_W1TC_GPIO_STATUS_INT_W1TC_Msk = 0xfffffc00

	// RTC_GPIO_IN: RTC GPIO input register
	// Position of GPIO_IN_NEXT field.
	RTCIO_RTC_GPIO_IN_GPIO_IN_NEXT_Pos = 0xa
	// Bit mask of GPIO_IN_NEXT field.
	RTCIO_RTC_GPIO_IN_GPIO_IN_NEXT_Msk = 0xfffffc00

	// PIN0: RTC configuration for pin %s
	// Position of PAD_DRIVER field.
	RTCIO_PIN_PAD_DRIVER_Pos = 0x2
	// Bit mask of PAD_DRIVER field.
	RTCIO_PIN_PAD_DRIVER_Msk = 0x4
	// Bit PAD_DRIVER.
	RTCIO_PIN_PAD_DRIVER = 0x4
	// Position of GPIO_PIN_INT_TYPE field.
	RTCIO_PIN_GPIO_PIN_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN_INT_TYPE field.
	RTCIO_PIN_GPIO_PIN_INT_TYPE_Msk = 0x380
	// Position of GPIO_PIN_WAKEUP_ENABLE field.
	RTCIO_PIN_GPIO_PIN_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN_WAKEUP_ENABLE field.
	RTCIO_PIN_GPIO_PIN_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN_WAKEUP_ENABLE.
	RTCIO_PIN_GPIO_PIN_WAKEUP_ENABLE = 0x400

	// RTC_DEBUG_SEL: RTC debug select register
	// Position of RTC_DEBUG_SEL0 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL0_Pos = 0x0
	// Bit mask of RTC_DEBUG_SEL0 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL0_Msk = 0x1f
	// Position of RTC_DEBUG_SEL1 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL1_Pos = 0x5
	// Bit mask of RTC_DEBUG_SEL1 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL1_Msk = 0x3e0
	// Position of RTC_DEBUG_SEL2 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL2_Pos = 0xa
	// Bit mask of RTC_DEBUG_SEL2 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL2_Msk = 0x7c00
	// Position of RTC_DEBUG_SEL3 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL3_Pos = 0xf
	// Bit mask of RTC_DEBUG_SEL3 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL3_Msk = 0xf8000
	// Position of RTC_DEBUG_SEL4 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL4_Pos = 0x14
	// Bit mask of RTC_DEBUG_SEL4 field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_SEL4_Msk = 0x1f00000
	// Position of RTC_DEBUG_12M_NO_GATING field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING_Pos = 0x19
	// Bit mask of RTC_DEBUG_12M_NO_GATING field.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING_Msk = 0x2000000
	// Bit RTC_DEBUG_12M_NO_GATING.
	RTCIO_RTC_DEBUG_SEL_RTC_DEBUG_12M_NO_GATING = 0x2000000

	// TOUCH_PAD0: Touch pad %s configuration register
	// Position of FUN_IE field.
	RTCIO_TOUCH_PAD_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_TOUCH_PAD_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_TOUCH_PAD_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_TOUCH_PAD_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_TOUCH_PAD_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_TOUCH_PAD_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_TOUCH_PAD_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_TOUCH_PAD_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_TOUCH_PAD_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_TOUCH_PAD_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_TOUCH_PAD_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_TOUCH_PAD_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_TOUCH_PAD_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_TOUCH_PAD_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_TOUCH_PAD_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_TOUCH_PAD_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_TOUCH_PAD_MUX_SEL = 0x80000
	// Position of XPD field.
	RTCIO_TOUCH_PAD_XPD_Pos = 0x14
	// Bit mask of XPD field.
	RTCIO_TOUCH_PAD_XPD_Msk = 0x100000
	// Bit XPD.
	RTCIO_TOUCH_PAD_XPD = 0x100000
	// Position of TIE_OPT field.
	RTCIO_TOUCH_PAD_TIE_OPT_Pos = 0x15
	// Bit mask of TIE_OPT field.
	RTCIO_TOUCH_PAD_TIE_OPT_Msk = 0x200000
	// Bit TIE_OPT.
	RTCIO_TOUCH_PAD_TIE_OPT = 0x200000
	// Position of START field.
	RTCIO_TOUCH_PAD_START_Pos = 0x16
	// Bit mask of START field.
	RTCIO_TOUCH_PAD_START_Msk = 0x400000
	// Bit START.
	RTCIO_TOUCH_PAD_START = 0x400000
	// Position of DAC field.
	RTCIO_TOUCH_PAD_DAC_Pos = 0x17
	// Bit mask of DAC field.
	RTCIO_TOUCH_PAD_DAC_Msk = 0x3800000
	// Position of RUE field.
	RTCIO_TOUCH_PAD_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_TOUCH_PAD_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_TOUCH_PAD_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_TOUCH_PAD_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_TOUCH_PAD_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_TOUCH_PAD_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_TOUCH_PAD_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_TOUCH_PAD_DRV_Msk = 0x60000000

	// XTAL_32P_PAD: 32KHz crystal P-pad configuration register
	// Position of X32P_FUN_IE field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_IE_Pos = 0xd
	// Bit mask of X32P_FUN_IE field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_IE_Msk = 0x2000
	// Bit X32P_FUN_IE.
	RTCIO_XTAL_32P_PAD_X32P_FUN_IE = 0x2000
	// Position of X32P_SLP_OE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_OE_Pos = 0xe
	// Bit mask of X32P_SLP_OE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_OE_Msk = 0x4000
	// Bit X32P_SLP_OE.
	RTCIO_XTAL_32P_PAD_X32P_SLP_OE = 0x4000
	// Position of X32P_SLP_IE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_IE_Pos = 0xf
	// Bit mask of X32P_SLP_IE field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_IE_Msk = 0x8000
	// Bit X32P_SLP_IE.
	RTCIO_XTAL_32P_PAD_X32P_SLP_IE = 0x8000
	// Position of X32P_SLP_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_SEL_Pos = 0x10
	// Bit mask of X32P_SLP_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_SLP_SEL_Msk = 0x10000
	// Bit X32P_SLP_SEL.
	RTCIO_XTAL_32P_PAD_X32P_SLP_SEL = 0x10000
	// Position of X32P_FUN_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_SEL_Pos = 0x11
	// Bit mask of X32P_FUN_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_FUN_SEL_Msk = 0x60000
	// Position of X32P_MUX_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_MUX_SEL_Pos = 0x13
	// Bit mask of X32P_MUX_SEL field.
	RTCIO_XTAL_32P_PAD_X32P_MUX_SEL_Msk = 0x80000
	// Bit X32P_MUX_SEL.
	RTCIO_XTAL_32P_PAD_X32P_MUX_SEL = 0x80000
	// Position of X32P_RUE field.
	RTCIO_XTAL_32P_PAD_X32P_RUE_Pos = 0x1b
	// Bit mask of X32P_RUE field.
	RTCIO_XTAL_32P_PAD_X32P_RUE_Msk = 0x8000000
	// Bit X32P_RUE.
	RTCIO_XTAL_32P_PAD_X32P_RUE = 0x8000000
	// Position of X32P_RDE field.
	RTCIO_XTAL_32P_PAD_X32P_RDE_Pos = 0x1c
	// Bit mask of X32P_RDE field.
	RTCIO_XTAL_32P_PAD_X32P_RDE_Msk = 0x10000000
	// Bit X32P_RDE.
	RTCIO_XTAL_32P_PAD_X32P_RDE = 0x10000000
	// Position of X32P_DRV field.
	RTCIO_XTAL_32P_PAD_X32P_DRV_Pos = 0x1d
	// Bit mask of X32P_DRV field.
	RTCIO_XTAL_32P_PAD_X32P_DRV_Msk = 0x60000000

	// XTAL_32N_PAD: 32KHz crystal N-pad configuration register
	// Position of X32N_FUN_IE field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_IE_Pos = 0xd
	// Bit mask of X32N_FUN_IE field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_IE_Msk = 0x2000
	// Bit X32N_FUN_IE.
	RTCIO_XTAL_32N_PAD_X32N_FUN_IE = 0x2000
	// Position of X32N_SLP_OE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_OE_Pos = 0xe
	// Bit mask of X32N_SLP_OE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_OE_Msk = 0x4000
	// Bit X32N_SLP_OE.
	RTCIO_XTAL_32N_PAD_X32N_SLP_OE = 0x4000
	// Position of X32N_SLP_IE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_IE_Pos = 0xf
	// Bit mask of X32N_SLP_IE field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_IE_Msk = 0x8000
	// Bit X32N_SLP_IE.
	RTCIO_XTAL_32N_PAD_X32N_SLP_IE = 0x8000
	// Position of X32N_SLP_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_SEL_Pos = 0x10
	// Bit mask of X32N_SLP_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_SLP_SEL_Msk = 0x10000
	// Bit X32N_SLP_SEL.
	RTCIO_XTAL_32N_PAD_X32N_SLP_SEL = 0x10000
	// Position of X32N_FUN_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_SEL_Pos = 0x11
	// Bit mask of X32N_FUN_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_FUN_SEL_Msk = 0x60000
	// Position of X32N_MUX_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_MUX_SEL_Pos = 0x13
	// Bit mask of X32N_MUX_SEL field.
	RTCIO_XTAL_32N_PAD_X32N_MUX_SEL_Msk = 0x80000
	// Bit X32N_MUX_SEL.
	RTCIO_XTAL_32N_PAD_X32N_MUX_SEL = 0x80000
	// Position of X32N_RUE field.
	RTCIO_XTAL_32N_PAD_X32N_RUE_Pos = 0x1b
	// Bit mask of X32N_RUE field.
	RTCIO_XTAL_32N_PAD_X32N_RUE_Msk = 0x8000000
	// Bit X32N_RUE.
	RTCIO_XTAL_32N_PAD_X32N_RUE = 0x8000000
	// Position of X32N_RDE field.
	RTCIO_XTAL_32N_PAD_X32N_RDE_Pos = 0x1c
	// Bit mask of X32N_RDE field.
	RTCIO_XTAL_32N_PAD_X32N_RDE_Msk = 0x10000000
	// Bit X32N_RDE.
	RTCIO_XTAL_32N_PAD_X32N_RDE = 0x10000000
	// Position of X32N_DRV field.
	RTCIO_XTAL_32N_PAD_X32N_DRV_Pos = 0x1d
	// Bit mask of X32N_DRV field.
	RTCIO_XTAL_32N_PAD_X32N_DRV_Msk = 0x60000000

	// PAD_DAC1: DAC1 configuration register
	// Position of PDAC1_DAC field.
	RTCIO_PAD_DAC1_PDAC1_DAC_Pos = 0x3
	// Bit mask of PDAC1_DAC field.
	RTCIO_PAD_DAC1_PDAC1_DAC_Msk = 0x7f8
	// Position of PDAC1_XPD_DAC field.
	RTCIO_PAD_DAC1_PDAC1_XPD_DAC_Pos = 0xb
	// Bit mask of PDAC1_XPD_DAC field.
	RTCIO_PAD_DAC1_PDAC1_XPD_DAC_Msk = 0x800
	// Bit PDAC1_XPD_DAC.
	RTCIO_PAD_DAC1_PDAC1_XPD_DAC = 0x800
	// Position of PDAC1_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC1_PDAC1_DAC_XPD_FORCE_Pos = 0xc
	// Bit mask of PDAC1_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC1_PDAC1_DAC_XPD_FORCE_Msk = 0x1000
	// Bit PDAC1_DAC_XPD_FORCE.
	RTCIO_PAD_DAC1_PDAC1_DAC_XPD_FORCE = 0x1000
	// Position of PDAC1_FUN_IE field.
	RTCIO_PAD_DAC1_PDAC1_FUN_IE_Pos = 0xd
	// Bit mask of PDAC1_FUN_IE field.
	RTCIO_PAD_DAC1_PDAC1_FUN_IE_Msk = 0x2000
	// Bit PDAC1_FUN_IE.
	RTCIO_PAD_DAC1_PDAC1_FUN_IE = 0x2000
	// Position of PDAC1_SLP_OE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_OE_Pos = 0xe
	// Bit mask of PDAC1_SLP_OE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_OE_Msk = 0x4000
	// Bit PDAC1_SLP_OE.
	RTCIO_PAD_DAC1_PDAC1_SLP_OE = 0x4000
	// Position of PDAC1_SLP_IE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_IE_Pos = 0xf
	// Bit mask of PDAC1_SLP_IE field.
	RTCIO_PAD_DAC1_PDAC1_SLP_IE_Msk = 0x8000
	// Bit PDAC1_SLP_IE.
	RTCIO_PAD_DAC1_PDAC1_SLP_IE = 0x8000
	// Position of PDAC1_SLP_SEL field.
	RTCIO_PAD_DAC1_PDAC1_SLP_SEL_Pos = 0x10
	// Bit mask of PDAC1_SLP_SEL field.
	RTCIO_PAD_DAC1_PDAC1_SLP_SEL_Msk = 0x10000
	// Bit PDAC1_SLP_SEL.
	RTCIO_PAD_DAC1_PDAC1_SLP_SEL = 0x10000
	// Position of PDAC1_FUN_SEL field.
	RTCIO_PAD_DAC1_PDAC1_FUN_SEL_Pos = 0x11
	// Bit mask of PDAC1_FUN_SEL field.
	RTCIO_PAD_DAC1_PDAC1_FUN_SEL_Msk = 0x60000
	// Position of PDAC1_MUX_SEL field.
	RTCIO_PAD_DAC1_PDAC1_MUX_SEL_Pos = 0x13
	// Bit mask of PDAC1_MUX_SEL field.
	RTCIO_PAD_DAC1_PDAC1_MUX_SEL_Msk = 0x80000
	// Bit PDAC1_MUX_SEL.
	RTCIO_PAD_DAC1_PDAC1_MUX_SEL = 0x80000
	// Position of PDAC1_RUE field.
	RTCIO_PAD_DAC1_PDAC1_RUE_Pos = 0x1b
	// Bit mask of PDAC1_RUE field.
	RTCIO_PAD_DAC1_PDAC1_RUE_Msk = 0x8000000
	// Bit PDAC1_RUE.
	RTCIO_PAD_DAC1_PDAC1_RUE = 0x8000000
	// Position of PDAC1_RDE field.
	RTCIO_PAD_DAC1_PDAC1_RDE_Pos = 0x1c
	// Bit mask of PDAC1_RDE field.
	RTCIO_PAD_DAC1_PDAC1_RDE_Msk = 0x10000000
	// Bit PDAC1_RDE.
	RTCIO_PAD_DAC1_PDAC1_RDE = 0x10000000
	// Position of PDAC1_DRV field.
	RTCIO_PAD_DAC1_PDAC1_DRV_Pos = 0x1d
	// Bit mask of PDAC1_DRV field.
	RTCIO_PAD_DAC1_PDAC1_DRV_Msk = 0x60000000

	// PAD_DAC2: DAC2 configuration register
	// Position of PDAC2_DAC field.
	RTCIO_PAD_DAC2_PDAC2_DAC_Pos = 0x3
	// Bit mask of PDAC2_DAC field.
	RTCIO_PAD_DAC2_PDAC2_DAC_Msk = 0x7f8
	// Position of PDAC2_XPD_DAC field.
	RTCIO_PAD_DAC2_PDAC2_XPD_DAC_Pos = 0xb
	// Bit mask of PDAC2_XPD_DAC field.
	RTCIO_PAD_DAC2_PDAC2_XPD_DAC_Msk = 0x800
	// Bit PDAC2_XPD_DAC.
	RTCIO_PAD_DAC2_PDAC2_XPD_DAC = 0x800
	// Position of PDAC2_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC2_PDAC2_DAC_XPD_FORCE_Pos = 0xc
	// Bit mask of PDAC2_DAC_XPD_FORCE field.
	RTCIO_PAD_DAC2_PDAC2_DAC_XPD_FORCE_Msk = 0x1000
	// Bit PDAC2_DAC_XPD_FORCE.
	RTCIO_PAD_DAC2_PDAC2_DAC_XPD_FORCE = 0x1000
	// Position of PDAC2_FUN_IE field.
	RTCIO_PAD_DAC2_PDAC2_FUN_IE_Pos = 0xd
	// Bit mask of PDAC2_FUN_IE field.
	RTCIO_PAD_DAC2_PDAC2_FUN_IE_Msk = 0x2000
	// Bit PDAC2_FUN_IE.
	RTCIO_PAD_DAC2_PDAC2_FUN_IE = 0x2000
	// Position of PDAC2_SLP_OE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_OE_Pos = 0xe
	// Bit mask of PDAC2_SLP_OE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_OE_Msk = 0x4000
	// Bit PDAC2_SLP_OE.
	RTCIO_PAD_DAC2_PDAC2_SLP_OE = 0x4000
	// Position of PDAC2_SLP_IE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_IE_Pos = 0xf
	// Bit mask of PDAC2_SLP_IE field.
	RTCIO_PAD_DAC2_PDAC2_SLP_IE_Msk = 0x8000
	// Bit PDAC2_SLP_IE.
	RTCIO_PAD_DAC2_PDAC2_SLP_IE = 0x8000
	// Position of PDAC2_SLP_SEL field.
	RTCIO_PAD_DAC2_PDAC2_SLP_SEL_Pos = 0x10
	// Bit mask of PDAC2_SLP_SEL field.
	RTCIO_PAD_DAC2_PDAC2_SLP_SEL_Msk = 0x10000
	// Bit PDAC2_SLP_SEL.
	RTCIO_PAD_DAC2_PDAC2_SLP_SEL = 0x10000
	// Position of PDAC2_FUN_SEL field.
	RTCIO_PAD_DAC2_PDAC2_FUN_SEL_Pos = 0x11
	// Bit mask of PDAC2_FUN_SEL field.
	RTCIO_PAD_DAC2_PDAC2_FUN_SEL_Msk = 0x60000
	// Position of PDAC2_MUX_SEL field.
	RTCIO_PAD_DAC2_PDAC2_MUX_SEL_Pos = 0x13
	// Bit mask of PDAC2_MUX_SEL field.
	RTCIO_PAD_DAC2_PDAC2_MUX_SEL_Msk = 0x80000
	// Bit PDAC2_MUX_SEL.
	RTCIO_PAD_DAC2_PDAC2_MUX_SEL = 0x80000
	// Position of PDAC2_RUE field.
	RTCIO_PAD_DAC2_PDAC2_RUE_Pos = 0x1b
	// Bit mask of PDAC2_RUE field.
	RTCIO_PAD_DAC2_PDAC2_RUE_Msk = 0x8000000
	// Bit PDAC2_RUE.
	RTCIO_PAD_DAC2_PDAC2_RUE = 0x8000000
	// Position of PDAC2_RDE field.
	RTCIO_PAD_DAC2_PDAC2_RDE_Pos = 0x1c
	// Bit mask of PDAC2_RDE field.
	RTCIO_PAD_DAC2_PDAC2_RDE_Msk = 0x10000000
	// Bit PDAC2_RDE.
	RTCIO_PAD_DAC2_PDAC2_RDE = 0x10000000
	// Position of PDAC2_DRV field.
	RTCIO_PAD_DAC2_PDAC2_DRV_Pos = 0x1d
	// Bit mask of PDAC2_DRV field.
	RTCIO_PAD_DAC2_PDAC2_DRV_Msk = 0x60000000

	// RTC_PAD19: Touch pad 19 configuration register
	// Position of FUN_IE field.
	RTCIO_RTC_PAD19_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_RTC_PAD19_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_RTC_PAD19_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_RTC_PAD19_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_RTC_PAD19_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_RTC_PAD19_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_RTC_PAD19_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_RTC_PAD19_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_RTC_PAD19_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_RTC_PAD19_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_RTC_PAD19_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_RTC_PAD19_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_RTC_PAD19_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_RTC_PAD19_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_RTC_PAD19_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_RTC_PAD19_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_RTC_PAD19_MUX_SEL = 0x80000
	// Position of RUE field.
	RTCIO_RTC_PAD19_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_RTC_PAD19_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_RTC_PAD19_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_RTC_PAD19_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_RTC_PAD19_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_RTC_PAD19_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_RTC_PAD19_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_RTC_PAD19_DRV_Msk = 0x60000000

	// RTC_PAD20: Touch pad 20 configuration register
	// Position of FUN_IE field.
	RTCIO_RTC_PAD20_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_RTC_PAD20_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_RTC_PAD20_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_RTC_PAD20_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_RTC_PAD20_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_RTC_PAD20_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_RTC_PAD20_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_RTC_PAD20_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_RTC_PAD20_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_RTC_PAD20_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_RTC_PAD20_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_RTC_PAD20_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_RTC_PAD20_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_RTC_PAD20_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_RTC_PAD20_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_RTC_PAD20_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_RTC_PAD20_MUX_SEL = 0x80000
	// Position of RUE field.
	RTCIO_RTC_PAD20_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_RTC_PAD20_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_RTC_PAD20_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_RTC_PAD20_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_RTC_PAD20_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_RTC_PAD20_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_RTC_PAD20_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_RTC_PAD20_DRV_Msk = 0x60000000

	// RTC_PAD21: Touch pad 21 configuration register
	// Position of FUN_IE field.
	RTCIO_RTC_PAD21_FUN_IE_Pos = 0xd
	// Bit mask of FUN_IE field.
	RTCIO_RTC_PAD21_FUN_IE_Msk = 0x2000
	// Bit FUN_IE.
	RTCIO_RTC_PAD21_FUN_IE = 0x2000
	// Position of SLP_OE field.
	RTCIO_RTC_PAD21_SLP_OE_Pos = 0xe
	// Bit mask of SLP_OE field.
	RTCIO_RTC_PAD21_SLP_OE_Msk = 0x4000
	// Bit SLP_OE.
	RTCIO_RTC_PAD21_SLP_OE = 0x4000
	// Position of SLP_IE field.
	RTCIO_RTC_PAD21_SLP_IE_Pos = 0xf
	// Bit mask of SLP_IE field.
	RTCIO_RTC_PAD21_SLP_IE_Msk = 0x8000
	// Bit SLP_IE.
	RTCIO_RTC_PAD21_SLP_IE = 0x8000
	// Position of SLP_SEL field.
	RTCIO_RTC_PAD21_SLP_SEL_Pos = 0x10
	// Bit mask of SLP_SEL field.
	RTCIO_RTC_PAD21_SLP_SEL_Msk = 0x10000
	// Bit SLP_SEL.
	RTCIO_RTC_PAD21_SLP_SEL = 0x10000
	// Position of FUN_SEL field.
	RTCIO_RTC_PAD21_FUN_SEL_Pos = 0x11
	// Bit mask of FUN_SEL field.
	RTCIO_RTC_PAD21_FUN_SEL_Msk = 0x60000
	// Position of MUX_SEL field.
	RTCIO_RTC_PAD21_MUX_SEL_Pos = 0x13
	// Bit mask of MUX_SEL field.
	RTCIO_RTC_PAD21_MUX_SEL_Msk = 0x80000
	// Bit MUX_SEL.
	RTCIO_RTC_PAD21_MUX_SEL = 0x80000
	// Position of RUE field.
	RTCIO_RTC_PAD21_RUE_Pos = 0x1b
	// Bit mask of RUE field.
	RTCIO_RTC_PAD21_RUE_Msk = 0x8000000
	// Bit RUE.
	RTCIO_RTC_PAD21_RUE = 0x8000000
	// Position of RDE field.
	RTCIO_RTC_PAD21_RDE_Pos = 0x1c
	// Bit mask of RDE field.
	RTCIO_RTC_PAD21_RDE_Msk = 0x10000000
	// Bit RDE.
	RTCIO_RTC_PAD21_RDE = 0x10000000
	// Position of DRV field.
	RTCIO_RTC_PAD21_DRV_Pos = 0x1d
	// Bit mask of DRV field.
	RTCIO_RTC_PAD21_DRV_Msk = 0x60000000

	// EXT_WAKEUP0: External wake up configuration register
	// Position of SEL field.
	RTCIO_EXT_WAKEUP0_SEL_Pos = 0x1b
	// Bit mask of SEL field.
	RTCIO_EXT_WAKEUP0_SEL_Msk = 0xf8000000

	// XTL_EXT_CTR: Crystal power down enable GPIO source
	// Position of SEL field.
	RTCIO_XTL_EXT_CTR_SEL_Pos = 0x1b
	// Bit mask of SEL field.
	RTCIO_XTL_EXT_CTR_SEL_Msk = 0xf8000000

	// SAR_I2C_IO: RTC I2C pad selection
	// Position of SAR_DEBUG_BIT_SEL field.
	RTCIO_SAR_I2C_IO_SAR_DEBUG_BIT_SEL_Pos = 0x17
	// Bit mask of SAR_DEBUG_BIT_SEL field.
	RTCIO_SAR_I2C_IO_SAR_DEBUG_BIT_SEL_Msk = 0xf800000
	// Position of SAR_I2C_SCL_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SCL_SEL_Pos = 0x1c
	// Bit mask of SAR_I2C_SCL_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SCL_SEL_Msk = 0x30000000
	// Position of SAR_I2C_SDA_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SDA_SEL_Pos = 0x1e
	// Bit mask of SAR_I2C_SDA_SEL field.
	RTCIO_SAR_I2C_IO_SAR_I2C_SDA_SEL_Msk = 0xc0000000

	// RTC_IO_TOUCH_CTRL: Touch control register
	// Position of IO_TOUCH_BUFSEL field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL_Pos = 0x0
	// Bit mask of IO_TOUCH_BUFSEL field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFSEL_Msk = 0xf
	// Position of IO_TOUCH_BUFMODE field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE_Pos = 0x4
	// Bit mask of IO_TOUCH_BUFMODE field.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE_Msk = 0x10
	// Bit IO_TOUCH_BUFMODE.
	RTCIO_RTC_IO_TOUCH_CTRL_IO_TOUCH_BUFMODE = 0x10

	// RTC_IO_DATE: Version control register
	// Position of IO_DATE field.
	RTCIO_RTC_IO_DATE_IO_DATE_Pos = 0x0
	// Bit mask of IO_DATE field.
	RTCIO_RTC_IO_DATE_IO_DATE_Msk = 0xfffffff
)

// Constants for RTC_CNTL: Real-Time Clock Control
const (
	// OPTIONS0: Sets the power options of crystal and PLL clocks, and initiates reset by software
	// Position of SW_STALL_APPCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_APPCPU_C0_Pos = 0x0
	// Bit mask of SW_STALL_APPCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_APPCPU_C0_Msk = 0x3
	// Position of SW_STALL_PROCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_PROCPU_C0_Pos = 0x2
	// Bit mask of SW_STALL_PROCPU_C0 field.
	RTC_CNTL_OPTIONS0_SW_STALL_PROCPU_C0_Msk = 0xc
	// Position of SW_APPCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST_Pos = 0x4
	// Bit mask of SW_APPCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST_Msk = 0x10
	// Bit SW_APPCPU_RST.
	RTC_CNTL_OPTIONS0_SW_APPCPU_RST = 0x10
	// Position of SW_PROCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST_Pos = 0x5
	// Bit mask of SW_PROCPU_RST field.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST_Msk = 0x20
	// Bit SW_PROCPU_RST.
	RTC_CNTL_OPTIONS0_SW_PROCPU_RST = 0x20
	// Position of BB_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD_Pos = 0x6
	// Bit mask of BB_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD_Msk = 0x40
	// Bit BB_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PD = 0x40
	// Position of BB_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU_Pos = 0x7
	// Bit mask of BB_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU_Msk = 0x80
	// Bit BB_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BB_I2C_FORCE_PU = 0x80
	// Position of BBPLL_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD_Pos = 0x8
	// Bit mask of BBPLL_I2C_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD_Msk = 0x100
	// Bit BBPLL_I2C_FORCE_PD.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PD = 0x100
	// Position of BBPLL_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU_Pos = 0x9
	// Bit mask of BBPLL_I2C_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU_Msk = 0x200
	// Bit BBPLL_I2C_FORCE_PU.
	RTC_CNTL_OPTIONS0_BBPLL_I2C_FORCE_PU = 0x200
	// Position of BBPLL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD_Pos = 0xa
	// Bit mask of BBPLL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD_Msk = 0x400
	// Bit BBPLL_FORCE_PD.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PD = 0x400
	// Position of BBPLL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU_Pos = 0xb
	// Bit mask of BBPLL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU_Msk = 0x800
	// Bit BBPLL_FORCE_PU.
	RTC_CNTL_OPTIONS0_BBPLL_FORCE_PU = 0x800
	// Position of XTL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD_Pos = 0xc
	// Bit mask of XTL_FORCE_PD field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD_Msk = 0x1000
	// Bit XTL_FORCE_PD.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PD = 0x1000
	// Position of XTL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU_Pos = 0xd
	// Bit mask of XTL_FORCE_PU field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU_Msk = 0x2000
	// Bit XTL_FORCE_PU.
	RTC_CNTL_OPTIONS0_XTL_FORCE_PU = 0x2000
	// Position of XTL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO_Pos = 0x17
	// Bit mask of XTL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO_Msk = 0x800000
	// Bit XTL_FORCE_ISO.
	RTC_CNTL_OPTIONS0_XTL_FORCE_ISO = 0x800000
	// Position of PLL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO_Pos = 0x18
	// Bit mask of PLL_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO_Msk = 0x1000000
	// Bit PLL_FORCE_ISO.
	RTC_CNTL_OPTIONS0_PLL_FORCE_ISO = 0x1000000
	// Position of ANALOG_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO_Pos = 0x19
	// Bit mask of ANALOG_FORCE_ISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO_Msk = 0x2000000
	// Bit ANALOG_FORCE_ISO.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_ISO = 0x2000000
	// Position of XTL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO_Pos = 0x1a
	// Bit mask of XTL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO_Msk = 0x4000000
	// Bit XTL_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_XTL_FORCE_NOISO = 0x4000000
	// Position of PLL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO_Pos = 0x1b
	// Bit mask of PLL_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO_Msk = 0x8000000
	// Bit PLL_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_PLL_FORCE_NOISO = 0x8000000
	// Position of ANALOG_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO_Pos = 0x1c
	// Bit mask of ANALOG_FORCE_NOISO field.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO_Msk = 0x10000000
	// Bit ANALOG_FORCE_NOISO.
	RTC_CNTL_OPTIONS0_ANALOG_FORCE_NOISO = 0x10000000
	// Position of DG_WRAP_FORCE_RST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST_Pos = 0x1d
	// Bit mask of DG_WRAP_FORCE_RST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST_Msk = 0x20000000
	// Bit DG_WRAP_FORCE_RST.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_RST = 0x20000000
	// Position of DG_WRAP_FORCE_NORST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST_Pos = 0x1e
	// Bit mask of DG_WRAP_FORCE_NORST field.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST_Msk = 0x40000000
	// Bit DG_WRAP_FORCE_NORST.
	RTC_CNTL_OPTIONS0_DG_WRAP_FORCE_NORST = 0x40000000
	// Position of SW_SYS_RST field.
	RTC_CNTL_OPTIONS0_SW_SYS_RST_Pos = 0x1f
	// Bit mask of SW_SYS_RST field.
	RTC_CNTL_OPTIONS0_SW_SYS_RST_Msk = 0x80000000
	// Bit SW_SYS_RST.
	RTC_CNTL_OPTIONS0_SW_SYS_RST = 0x80000000

	// SLP_TIMER0: RTC timer threshold register 0
	// Position of SLP_VAL_LO field.
	RTC_CNTL_SLP_TIMER0_SLP_VAL_LO_Pos = 0x0
	// Bit mask of SLP_VAL_LO field.
	RTC_CNTL_SLP_TIMER0_SLP_VAL_LO_Msk = 0xffffffff

	// SLP_TIMER1: RTC timer threshold register 1
	// Position of SLP_VAL_HI field.
	RTC_CNTL_SLP_TIMER1_SLP_VAL_HI_Pos = 0x0
	// Bit mask of SLP_VAL_HI field.
	RTC_CNTL_SLP_TIMER1_SLP_VAL_HI_Msk = 0xffff
	// Position of MAIN_TIMER_ALARM_EN field.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN_Pos = 0x10
	// Bit mask of MAIN_TIMER_ALARM_EN field.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN_Msk = 0x10000
	// Bit MAIN_TIMER_ALARM_EN.
	RTC_CNTL_SLP_TIMER1_MAIN_TIMER_ALARM_EN = 0x10000

	// TIME_UPDATE: RTC timer update control register
	// Position of TIMER_SYS_STALL field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_STALL_Pos = 0x1b
	// Bit mask of TIMER_SYS_STALL field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_STALL_Msk = 0x8000000
	// Bit TIMER_SYS_STALL.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_STALL = 0x8000000
	// Position of TIMER_XTL_OFF field.
	RTC_CNTL_TIME_UPDATE_TIMER_XTL_OFF_Pos = 0x1c
	// Bit mask of TIMER_XTL_OFF field.
	RTC_CNTL_TIME_UPDATE_TIMER_XTL_OFF_Msk = 0x10000000
	// Bit TIMER_XTL_OFF.
	RTC_CNTL_TIME_UPDATE_TIMER_XTL_OFF = 0x10000000
	// Position of TIMER_SYS_RST field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_RST_Pos = 0x1d
	// Bit mask of TIMER_SYS_RST field.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_RST_Msk = 0x20000000
	// Bit TIMER_SYS_RST.
	RTC_CNTL_TIME_UPDATE_TIMER_SYS_RST = 0x20000000
	// Position of TIME_UPDATE field.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE_Pos = 0x1f
	// Bit mask of TIME_UPDATE field.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE_Msk = 0x80000000
	// Bit TIME_UPDATE.
	RTC_CNTL_TIME_UPDATE_TIME_UPDATE = 0x80000000

	// TIME_LOW0: Stores the lower 32 bits of RTC timer 0.
	// Position of TIMER_VALUE0_LOW field.
	RTC_CNTL_TIME_LOW0_TIMER_VALUE0_LOW_Pos = 0x0
	// Bit mask of TIMER_VALUE0_LOW field.
	RTC_CNTL_TIME_LOW0_TIMER_VALUE0_LOW_Msk = 0xffffffff

	// TIME_HIGH0: Stores the higher 16 bits of RTC timer 0
	// Position of TIMER_VALUE0_HIGH field.
	RTC_CNTL_TIME_HIGH0_TIMER_VALUE0_HIGH_Pos = 0x0
	// Bit mask of TIMER_VALUE0_HIGH field.
	RTC_CNTL_TIME_HIGH0_TIMER_VALUE0_HIGH_Msk = 0xffff

	// STATE0: Configures the sleep / reject / wakeup state
	// Position of SW_CPU_INT field.
	RTC_CNTL_STATE0_SW_CPU_INT_Pos = 0x0
	// Bit mask of SW_CPU_INT field.
	RTC_CNTL_STATE0_SW_CPU_INT_Msk = 0x1
	// Bit SW_CPU_INT.
	RTC_CNTL_STATE0_SW_CPU_INT = 0x1
	// Position of SLP_REJECT_CAUSE_CLR field.
	RTC_CNTL_STATE0_SLP_REJECT_CAUSE_CLR_Pos = 0x1
	// Bit mask of SLP_REJECT_CAUSE_CLR field.
	RTC_CNTL_STATE0_SLP_REJECT_CAUSE_CLR_Msk = 0x2
	// Bit SLP_REJECT_CAUSE_CLR.
	RTC_CNTL_STATE0_SLP_REJECT_CAUSE_CLR = 0x2
	// Position of APB2RTC_BRIDGE_SEL field.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL_Pos = 0x16
	// Bit mask of APB2RTC_BRIDGE_SEL field.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL_Msk = 0x400000
	// Bit APB2RTC_BRIDGE_SEL.
	RTC_CNTL_STATE0_APB2RTC_BRIDGE_SEL = 0x400000
	// Position of SDIO_ACTIVE_IND field.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND_Pos = 0x1c
	// Bit mask of SDIO_ACTIVE_IND field.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND_Msk = 0x10000000
	// Bit SDIO_ACTIVE_IND.
	RTC_CNTL_STATE0_SDIO_ACTIVE_IND = 0x10000000
	// Position of SLP_WAKEUP field.
	RTC_CNTL_STATE0_SLP_WAKEUP_Pos = 0x1d
	// Bit mask of SLP_WAKEUP field.
	RTC_CNTL_STATE0_SLP_WAKEUP_Msk = 0x20000000
	// Bit SLP_WAKEUP.
	RTC_CNTL_STATE0_SLP_WAKEUP = 0x20000000
	// Position of SLP_REJECT field.
	RTC_CNTL_STATE0_SLP_REJECT_Pos = 0x1e
	// Bit mask of SLP_REJECT field.
	RTC_CNTL_STATE0_SLP_REJECT_Msk = 0x40000000
	// Bit SLP_REJECT.
	RTC_CNTL_STATE0_SLP_REJECT = 0x40000000
	// Position of SLEEP_EN field.
	RTC_CNTL_STATE0_SLEEP_EN_Pos = 0x1f
	// Bit mask of SLEEP_EN field.
	RTC_CNTL_STATE0_SLEEP_EN_Msk = 0x80000000
	// Bit SLEEP_EN.
	RTC_CNTL_STATE0_SLEEP_EN = 0x80000000

	// TIMER1: Configures CPU stall options
	// Position of CPU_STALL_EN field.
	RTC_CNTL_TIMER1_CPU_STALL_EN_Pos = 0x0
	// Bit mask of CPU_STALL_EN field.
	RTC_CNTL_TIMER1_CPU_STALL_EN_Msk = 0x1
	// Bit CPU_STALL_EN.
	RTC_CNTL_TIMER1_CPU_STALL_EN = 0x1
	// Position of CPU_STALL_WAIT field.
	RTC_CNTL_TIMER1_CPU_STALL_WAIT_Pos = 0x1
	// Bit mask of CPU_STALL_WAIT field.
	RTC_CNTL_TIMER1_CPU_STALL_WAIT_Msk = 0x3e
	// Position of CK8M_WAIT field.
	RTC_CNTL_TIMER1_CK8M_WAIT_Pos = 0x6
	// Bit mask of CK8M_WAIT field.
	RTC_CNTL_TIMER1_CK8M_WAIT_Msk = 0x3fc0
	// Position of XTL_BUF_WAIT field.
	RTC_CNTL_TIMER1_XTL_BUF_WAIT_Pos = 0xe
	// Bit mask of XTL_BUF_WAIT field.
	RTC_CNTL_TIMER1_XTL_BUF_WAIT_Msk = 0xffc000
	// Position of PLL_BUF_WAIT field.
	RTC_CNTL_TIMER1_PLL_BUF_WAIT_Pos = 0x18
	// Bit mask of PLL_BUF_WAIT field.
	RTC_CNTL_TIMER1_PLL_BUF_WAIT_Msk = 0xff000000

	// TIMER2: Configures RTC slow clock and touch controller
	// Position of ULPCP_TOUCH_START_WAIT field.
	RTC_CNTL_TIMER2_ULPCP_TOUCH_START_WAIT_Pos = 0xf
	// Bit mask of ULPCP_TOUCH_START_WAIT field.
	RTC_CNTL_TIMER2_ULPCP_TOUCH_START_WAIT_Msk = 0xff8000
	// Position of MIN_TIME_CK8M_OFF field.
	RTC_CNTL_TIMER2_MIN_TIME_CK8M_OFF_Pos = 0x18
	// Bit mask of MIN_TIME_CK8M_OFF field.
	RTC_CNTL_TIMER2_MIN_TIME_CK8M_OFF_Msk = 0xff000000

	// TIMER3: configure some wait time for power on
	// Position of WIFI_WAIT_TIMER field.
	RTC_CNTL_TIMER3_WIFI_WAIT_TIMER_Pos = 0x0
	// Bit mask of WIFI_WAIT_TIMER field.
	RTC_CNTL_TIMER3_WIFI_WAIT_TIMER_Msk = 0x1ff
	// Position of WIFI_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_WIFI_POWERUP_TIMER_Pos = 0x9
	// Bit mask of WIFI_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_WIFI_POWERUP_TIMER_Msk = 0xfe00
	// Position of ROM_RAM_WAIT_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_WAIT_TIMER_Pos = 0x10
	// Bit mask of ROM_RAM_WAIT_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_WAIT_TIMER_Msk = 0x1ff0000
	// Position of ROM_RAM_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_POWERUP_TIMER_Pos = 0x19
	// Bit mask of ROM_RAM_POWERUP_TIMER field.
	RTC_CNTL_TIMER3_ROM_RAM_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER4: configure some wait time for power on
	// Position of WAIT_TIMER field.
	RTC_CNTL_TIMER4_WAIT_TIMER_Pos = 0x0
	// Bit mask of WAIT_TIMER field.
	RTC_CNTL_TIMER4_WAIT_TIMER_Msk = 0x1ff
	// Position of POWERUP_TIMER field.
	RTC_CNTL_TIMER4_POWERUP_TIMER_Pos = 0x9
	// Bit mask of POWERUP_TIMER field.
	RTC_CNTL_TIMER4_POWERUP_TIMER_Msk = 0xfe00
	// Position of DG_WRAP_WAIT_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_WAIT_TIMER_Pos = 0x10
	// Bit mask of DG_WRAP_WAIT_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_WAIT_TIMER_Msk = 0x1ff0000
	// Position of DG_WRAP_POWERUP_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_POWERUP_TIMER_Pos = 0x19
	// Bit mask of DG_WRAP_POWERUP_TIMER field.
	RTC_CNTL_TIMER4_DG_WRAP_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER5: Configures the minimal sleep cycles
	// Position of MIN_SLP_VAL field.
	RTC_CNTL_TIMER5_MIN_SLP_VAL_Pos = 0x8
	// Bit mask of MIN_SLP_VAL field.
	RTC_CNTL_TIMER5_MIN_SLP_VAL_Msk = 0xff00
	// Position of RTCMEM_WAIT_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_WAIT_TIMER_Pos = 0x10
	// Bit mask of RTCMEM_WAIT_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_WAIT_TIMER_Msk = 0x1ff0000
	// Position of RTCMEM_POWERUP_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_POWERUP_TIMER_Pos = 0x19
	// Bit mask of RTCMEM_POWERUP_TIMER field.
	RTC_CNTL_TIMER5_RTCMEM_POWERUP_TIMER_Msk = 0xfe000000

	// TIMER6: Configure minimal sleep cycles register
	// Position of DG_DCDC_WAIT_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_WAIT_TIMER_Pos = 0x10
	// Bit mask of DG_DCDC_WAIT_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_WAIT_TIMER_Msk = 0x1ff0000
	// Position of DG_DCDC_POWERUP_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_POWERUP_TIMER_Pos = 0x19
	// Bit mask of DG_DCDC_POWERUP_TIMER field.
	RTC_CNTL_TIMER6_DG_DCDC_POWERUP_TIMER_Msk = 0xfe000000

	// ANA_CONF: Configures the power options for I2C and PLLA
	// Position of I2C_RESET_POR_FORCE_PD field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PD_Pos = 0x12
	// Bit mask of I2C_RESET_POR_FORCE_PD field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PD_Msk = 0x40000
	// Bit I2C_RESET_POR_FORCE_PD.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PD = 0x40000
	// Position of I2C_RESET_POR_FORCE_PU field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PU_Pos = 0x13
	// Bit mask of I2C_RESET_POR_FORCE_PU field.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PU_Msk = 0x80000
	// Bit I2C_RESET_POR_FORCE_PU.
	RTC_CNTL_ANA_CONF_I2C_RESET_POR_FORCE_PU = 0x80000
	// Position of GLITCH_RST_EN field.
	RTC_CNTL_ANA_CONF_GLITCH_RST_EN_Pos = 0x14
	// Bit mask of GLITCH_RST_EN field.
	RTC_CNTL_ANA_CONF_GLITCH_RST_EN_Msk = 0x100000
	// Bit GLITCH_RST_EN.
	RTC_CNTL_ANA_CONF_GLITCH_RST_EN = 0x100000
	// Position of SAR_I2C_FORCE_PD field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PD_Pos = 0x15
	// Bit mask of SAR_I2C_FORCE_PD field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PD_Msk = 0x200000
	// Bit SAR_I2C_FORCE_PD.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PD = 0x200000
	// Position of SAR_I2C_FORCE_PU field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PU_Pos = 0x16
	// Bit mask of SAR_I2C_FORCE_PU field.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PU_Msk = 0x400000
	// Bit SAR_I2C_FORCE_PU.
	RTC_CNTL_ANA_CONF_SAR_I2C_FORCE_PU = 0x400000
	// Position of PLLA_FORCE_PD field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD_Pos = 0x17
	// Bit mask of PLLA_FORCE_PD field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD_Msk = 0x800000
	// Bit PLLA_FORCE_PD.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PD = 0x800000
	// Position of PLLA_FORCE_PU field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU_Pos = 0x18
	// Bit mask of PLLA_FORCE_PU field.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU_Msk = 0x1000000
	// Bit PLLA_FORCE_PU.
	RTC_CNTL_ANA_CONF_PLLA_FORCE_PU = 0x1000000
	// Position of BBPLL_CAL_SLP_START field.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START_Pos = 0x19
	// Bit mask of BBPLL_CAL_SLP_START field.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START_Msk = 0x2000000
	// Bit BBPLL_CAL_SLP_START.
	RTC_CNTL_ANA_CONF_BBPLL_CAL_SLP_START = 0x2000000
	// Position of PVTMON_PU field.
	RTC_CNTL_ANA_CONF_PVTMON_PU_Pos = 0x1a
	// Bit mask of PVTMON_PU field.
	RTC_CNTL_ANA_CONF_PVTMON_PU_Msk = 0x4000000
	// Bit PVTMON_PU.
	RTC_CNTL_ANA_CONF_PVTMON_PU = 0x4000000
	// Position of TXRF_I2C_PU field.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU_Pos = 0x1b
	// Bit mask of TXRF_I2C_PU field.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU_Msk = 0x8000000
	// Bit TXRF_I2C_PU.
	RTC_CNTL_ANA_CONF_TXRF_I2C_PU = 0x8000000
	// Position of RFRX_PBUS_PU field.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU_Pos = 0x1c
	// Bit mask of RFRX_PBUS_PU field.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU_Msk = 0x10000000
	// Bit RFRX_PBUS_PU.
	RTC_CNTL_ANA_CONF_RFRX_PBUS_PU = 0x10000000
	// Position of CKGEN_I2C_PU field.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU_Pos = 0x1e
	// Bit mask of CKGEN_I2C_PU field.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU_Msk = 0x40000000
	// Bit CKGEN_I2C_PU.
	RTC_CNTL_ANA_CONF_CKGEN_I2C_PU = 0x40000000
	// Position of PLL_I2C_PU field.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU_Pos = 0x1f
	// Bit mask of PLL_I2C_PU field.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU_Msk = 0x80000000
	// Bit PLL_I2C_PU.
	RTC_CNTL_ANA_CONF_PLL_I2C_PU = 0x80000000

	// RESET_STATE: Indicates the CPU reset source. For more information about the reset cause, please refer to Table \ref{table:resetreasons} in Chapter \ref{module:ResetandClock} \textit{\nameref{module:ResetandClock}}.
	// Position of RESET_CAUSE_PROCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_PROCPU_Pos = 0x0
	// Bit mask of RESET_CAUSE_PROCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_PROCPU_Msk = 0x3f
	// Position of RESET_CAUSE_APPCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_APPCPU_Pos = 0x6
	// Bit mask of RESET_CAUSE_APPCPU field.
	RTC_CNTL_RESET_STATE_RESET_CAUSE_APPCPU_Msk = 0xfc0
	// Position of APPCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL_Pos = 0xc
	// Bit mask of APPCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL_Msk = 0x1000
	// Bit APPCPU_STAT_VECTOR_SEL.
	RTC_CNTL_RESET_STATE_APPCPU_STAT_VECTOR_SEL = 0x1000
	// Position of PROCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL_Pos = 0xd
	// Bit mask of PROCPU_STAT_VECTOR_SEL field.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL_Msk = 0x2000
	// Bit PROCPU_STAT_VECTOR_SEL.
	RTC_CNTL_RESET_STATE_PROCPU_STAT_VECTOR_SEL = 0x2000

	// WAKEUP_STATE: Wakeup bitmap enabling register
	// Position of WAKEUP_ENA field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_ENA_Pos = 0xf
	// Bit mask of WAKEUP_ENA field.
	RTC_CNTL_WAKEUP_STATE_WAKEUP_ENA_Msk = 0xffff8000

	// INT_ENA_RTC: RTC interrupt enabling register
	// Position of SLP_WAKEUP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_WAKEUP_INT_ENA_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_WAKEUP_INT_ENA_Msk = 0x1
	// Bit SLP_WAKEUP_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SLP_WAKEUP_INT_ENA = 0x1
	// Position of SLP_REJECT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_REJECT_INT_ENA_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SLP_REJECT_INT_ENA_Msk = 0x2
	// Bit SLP_REJECT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SLP_REJECT_INT_ENA = 0x2
	// Position of SDIO_IDLE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SDIO_IDLE_INT_ENA_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SDIO_IDLE_INT_ENA_Msk = 0x4
	// Bit SDIO_IDLE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SDIO_IDLE_INT_ENA = 0x4
	// Position of WDT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_WDT_INT_ENA_Pos = 0x3
	// Bit mask of WDT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_WDT_INT_ENA_Msk = 0x8
	// Bit WDT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_WDT_INT_ENA = 0x8
	// Position of TOUCH_SCAN_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_SCAN_DONE_INT_ENA = 0x10
	// Position of ULP_CP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_ULP_CP_INT_ENA_Pos = 0x5
	// Bit mask of ULP_CP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_ULP_CP_INT_ENA_Msk = 0x20
	// Bit ULP_CP_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_ULP_CP_INT_ENA = 0x20
	// Position of TOUCH_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_DONE_INT_ENA_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_DONE_INT_ENA_Msk = 0x40
	// Bit TOUCH_DONE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_DONE_INT_ENA = 0x40
	// Position of TOUCH_ACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_ACTIVE_INT_ENA_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_ACTIVE_INT_ENA_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_ACTIVE_INT_ENA = 0x80
	// Position of TOUCH_INACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_INACTIVE_INT_ENA_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_INACTIVE_INT_ENA_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_INACTIVE_INT_ENA = 0x100
	// Position of BROWN_OUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_BROWN_OUT_INT_ENA_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_BROWN_OUT_INT_ENA_Msk = 0x200
	// Bit BROWN_OUT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_BROWN_OUT_INT_ENA = 0x200
	// Position of MAIN_TIMER_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_MAIN_TIMER_INT_ENA_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_MAIN_TIMER_INT_ENA_Msk = 0x400
	// Bit MAIN_TIMER_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_MAIN_TIMER_INT_ENA = 0x400
	// Position of SARADC1_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC1_INT_ENA_Pos = 0xb
	// Bit mask of SARADC1_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC1_INT_ENA_Msk = 0x800
	// Bit SARADC1_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SARADC1_INT_ENA = 0x800
	// Position of TSENS_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TSENS_INT_ENA_Pos = 0xc
	// Bit mask of TSENS_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TSENS_INT_ENA_Msk = 0x1000
	// Bit TSENS_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TSENS_INT_ENA = 0x1000
	// Position of COCPU_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_INT_ENA_Pos = 0xd
	// Bit mask of COCPU_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_INT_ENA_Msk = 0x2000
	// Bit COCPU_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_COCPU_INT_ENA = 0x2000
	// Position of SARADC2_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC2_INT_ENA_Pos = 0xe
	// Bit mask of SARADC2_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SARADC2_INT_ENA_Msk = 0x4000
	// Bit SARADC2_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SARADC2_INT_ENA = 0x4000
	// Position of SWD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SWD_INT_ENA_Pos = 0xf
	// Bit mask of SWD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_SWD_INT_ENA_Msk = 0x8000
	// Bit SWD_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_SWD_INT_ENA = 0x8000
	// Position of XTAL32K_DEAD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_XTAL32K_DEAD_INT_ENA_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_XTAL32K_DEAD_INT_ENA_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_XTAL32K_DEAD_INT_ENA = 0x10000
	// Position of COCPU_TRAP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_TRAP_INT_ENA_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_COCPU_TRAP_INT_ENA_Msk = 0x20000
	// Bit COCPU_TRAP_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_COCPU_TRAP_INT_ENA = 0x20000
	// Position of TOUCH_TIMEOUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_TOUCH_TIMEOUT_INT_ENA = 0x40000
	// Position of GLITCH_DET_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_GLITCH_DET_INT_ENA_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_ENA field.
	RTC_CNTL_INT_ENA_RTC_GLITCH_DET_INT_ENA_Msk = 0x80000
	// Bit GLITCH_DET_INT_ENA.
	RTC_CNTL_INT_ENA_RTC_GLITCH_DET_INT_ENA = 0x80000

	// INT_RAW_RTC: RTC interrupt raw register
	// Position of SLP_WAKEUP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_WAKEUP_INT_RAW_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_WAKEUP_INT_RAW_Msk = 0x1
	// Bit SLP_WAKEUP_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SLP_WAKEUP_INT_RAW = 0x1
	// Position of SLP_REJECT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_REJECT_INT_RAW_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SLP_REJECT_INT_RAW_Msk = 0x2
	// Bit SLP_REJECT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SLP_REJECT_INT_RAW = 0x2
	// Position of SDIO_IDLE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SDIO_IDLE_INT_RAW_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SDIO_IDLE_INT_RAW_Msk = 0x4
	// Bit SDIO_IDLE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SDIO_IDLE_INT_RAW = 0x4
	// Position of WDT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_WDT_INT_RAW_Pos = 0x3
	// Bit mask of WDT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_WDT_INT_RAW_Msk = 0x8
	// Bit WDT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_WDT_INT_RAW = 0x8
	// Position of TOUCH_SCAN_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_SCAN_DONE_INT_RAW = 0x10
	// Position of ULP_CP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_ULP_CP_INT_RAW_Pos = 0x5
	// Bit mask of ULP_CP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_ULP_CP_INT_RAW_Msk = 0x20
	// Bit ULP_CP_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_ULP_CP_INT_RAW = 0x20
	// Position of TOUCH_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_DONE_INT_RAW_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_DONE_INT_RAW_Msk = 0x40
	// Bit TOUCH_DONE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_DONE_INT_RAW = 0x40
	// Position of TOUCH_ACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_ACTIVE_INT_RAW_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_ACTIVE_INT_RAW_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_ACTIVE_INT_RAW = 0x80
	// Position of TOUCH_INACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_INACTIVE_INT_RAW_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_INACTIVE_INT_RAW_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_INACTIVE_INT_RAW = 0x100
	// Position of BROWN_OUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_BROWN_OUT_INT_RAW_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_BROWN_OUT_INT_RAW_Msk = 0x200
	// Bit BROWN_OUT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_BROWN_OUT_INT_RAW = 0x200
	// Position of MAIN_TIMER_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_MAIN_TIMER_INT_RAW_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_MAIN_TIMER_INT_RAW_Msk = 0x400
	// Bit MAIN_TIMER_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_MAIN_TIMER_INT_RAW = 0x400
	// Position of SARADC1_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC1_INT_RAW_Pos = 0xb
	// Bit mask of SARADC1_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC1_INT_RAW_Msk = 0x800
	// Bit SARADC1_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SARADC1_INT_RAW = 0x800
	// Position of TSENS_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TSENS_INT_RAW_Pos = 0xc
	// Bit mask of TSENS_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TSENS_INT_RAW_Msk = 0x1000
	// Bit TSENS_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TSENS_INT_RAW = 0x1000
	// Position of COCPU_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_INT_RAW_Pos = 0xd
	// Bit mask of COCPU_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_INT_RAW_Msk = 0x2000
	// Bit COCPU_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_COCPU_INT_RAW = 0x2000
	// Position of SARADC2_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC2_INT_RAW_Pos = 0xe
	// Bit mask of SARADC2_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SARADC2_INT_RAW_Msk = 0x4000
	// Bit SARADC2_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SARADC2_INT_RAW = 0x4000
	// Position of SWD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SWD_INT_RAW_Pos = 0xf
	// Bit mask of SWD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_SWD_INT_RAW_Msk = 0x8000
	// Bit SWD_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_SWD_INT_RAW = 0x8000
	// Position of XTAL32K_DEAD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_XTAL32K_DEAD_INT_RAW_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_XTAL32K_DEAD_INT_RAW_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_XTAL32K_DEAD_INT_RAW = 0x10000
	// Position of COCPU_TRAP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_TRAP_INT_RAW_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_COCPU_TRAP_INT_RAW_Msk = 0x20000
	// Bit COCPU_TRAP_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_COCPU_TRAP_INT_RAW = 0x20000
	// Position of TOUCH_TIMEOUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_TOUCH_TIMEOUT_INT_RAW = 0x40000
	// Position of GLITCH_DET_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_GLITCH_DET_INT_RAW_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_RAW field.
	RTC_CNTL_INT_RAW_RTC_GLITCH_DET_INT_RAW_Msk = 0x80000
	// Bit GLITCH_DET_INT_RAW.
	RTC_CNTL_INT_RAW_RTC_GLITCH_DET_INT_RAW = 0x80000

	// INT_ST_RTC: RTC interrupt state register
	// Position of SLP_WAKEUP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_WAKEUP_INT_ST_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_WAKEUP_INT_ST_Msk = 0x1
	// Bit SLP_WAKEUP_INT_ST.
	RTC_CNTL_INT_ST_RTC_SLP_WAKEUP_INT_ST = 0x1
	// Position of SLP_REJECT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_REJECT_INT_ST_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SLP_REJECT_INT_ST_Msk = 0x2
	// Bit SLP_REJECT_INT_ST.
	RTC_CNTL_INT_ST_RTC_SLP_REJECT_INT_ST = 0x2
	// Position of SDIO_IDLE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SDIO_IDLE_INT_ST_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SDIO_IDLE_INT_ST_Msk = 0x4
	// Bit SDIO_IDLE_INT_ST.
	RTC_CNTL_INT_ST_RTC_SDIO_IDLE_INT_ST = 0x4
	// Position of WDT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_WDT_INT_ST_Pos = 0x3
	// Bit mask of WDT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_WDT_INT_ST_Msk = 0x8
	// Bit WDT_INT_ST.
	RTC_CNTL_INT_ST_RTC_WDT_INT_ST = 0x8
	// Position of TOUCH_SCAN_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_SCAN_DONE_INT_ST_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_SCAN_DONE_INT_ST_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_SCAN_DONE_INT_ST = 0x10
	// Position of ULP_CP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_ULP_CP_INT_ST_Pos = 0x5
	// Bit mask of ULP_CP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_ULP_CP_INT_ST_Msk = 0x20
	// Bit ULP_CP_INT_ST.
	RTC_CNTL_INT_ST_RTC_ULP_CP_INT_ST = 0x20
	// Position of TOUCH_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_DONE_INT_ST_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_DONE_INT_ST_Msk = 0x40
	// Bit TOUCH_DONE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_DONE_INT_ST = 0x40
	// Position of TOUCH_ACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_ACTIVE_INT_ST_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_ACTIVE_INT_ST_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_ACTIVE_INT_ST = 0x80
	// Position of TOUCH_INACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_INACTIVE_INT_ST_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_INACTIVE_INT_ST_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_INACTIVE_INT_ST = 0x100
	// Position of BROWN_OUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_BROWN_OUT_INT_ST_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_BROWN_OUT_INT_ST_Msk = 0x200
	// Bit BROWN_OUT_INT_ST.
	RTC_CNTL_INT_ST_RTC_BROWN_OUT_INT_ST = 0x200
	// Position of MAIN_TIMER_INT_ST field.
	RTC_CNTL_INT_ST_RTC_MAIN_TIMER_INT_ST_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_ST field.
	RTC_CNTL_INT_ST_RTC_MAIN_TIMER_INT_ST_Msk = 0x400
	// Bit MAIN_TIMER_INT_ST.
	RTC_CNTL_INT_ST_RTC_MAIN_TIMER_INT_ST = 0x400
	// Position of SARADC1_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC1_INT_ST_Pos = 0xb
	// Bit mask of SARADC1_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC1_INT_ST_Msk = 0x800
	// Bit SARADC1_INT_ST.
	RTC_CNTL_INT_ST_RTC_SARADC1_INT_ST = 0x800
	// Position of TSENS_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TSENS_INT_ST_Pos = 0xc
	// Bit mask of TSENS_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TSENS_INT_ST_Msk = 0x1000
	// Bit TSENS_INT_ST.
	RTC_CNTL_INT_ST_RTC_TSENS_INT_ST = 0x1000
	// Position of COCPU_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_INT_ST_Pos = 0xd
	// Bit mask of COCPU_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_INT_ST_Msk = 0x2000
	// Bit COCPU_INT_ST.
	RTC_CNTL_INT_ST_RTC_COCPU_INT_ST = 0x2000
	// Position of SARADC2_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC2_INT_ST_Pos = 0xe
	// Bit mask of SARADC2_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SARADC2_INT_ST_Msk = 0x4000
	// Bit SARADC2_INT_ST.
	RTC_CNTL_INT_ST_RTC_SARADC2_INT_ST = 0x4000
	// Position of SWD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SWD_INT_ST_Pos = 0xf
	// Bit mask of SWD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_SWD_INT_ST_Msk = 0x8000
	// Bit SWD_INT_ST.
	RTC_CNTL_INT_ST_RTC_SWD_INT_ST = 0x8000
	// Position of XTAL32K_DEAD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_XTAL32K_DEAD_INT_ST_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_ST field.
	RTC_CNTL_INT_ST_RTC_XTAL32K_DEAD_INT_ST_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_ST.
	RTC_CNTL_INT_ST_RTC_XTAL32K_DEAD_INT_ST = 0x10000
	// Position of COCPU_TRAP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_TRAP_INT_ST_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_ST field.
	RTC_CNTL_INT_ST_RTC_COCPU_TRAP_INT_ST_Msk = 0x20000
	// Bit COCPU_TRAP_INT_ST.
	RTC_CNTL_INT_ST_RTC_COCPU_TRAP_INT_ST = 0x20000
	// Position of TOUCH_TIMEOUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_TIMEOUT_INT_ST_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_ST field.
	RTC_CNTL_INT_ST_RTC_TOUCH_TIMEOUT_INT_ST_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_ST.
	RTC_CNTL_INT_ST_RTC_TOUCH_TIMEOUT_INT_ST = 0x40000
	// Position of GLITCH_DET_INT_ST field.
	RTC_CNTL_INT_ST_RTC_GLITCH_DET_INT_ST_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_ST field.
	RTC_CNTL_INT_ST_RTC_GLITCH_DET_INT_ST_Msk = 0x80000
	// Bit GLITCH_DET_INT_ST.
	RTC_CNTL_INT_ST_RTC_GLITCH_DET_INT_ST = 0x80000

	// INT_CLR_RTC: RTC interrupt clear register
	// Position of SLP_WAKEUP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_WAKEUP_INT_CLR_Pos = 0x0
	// Bit mask of SLP_WAKEUP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_WAKEUP_INT_CLR_Msk = 0x1
	// Bit SLP_WAKEUP_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SLP_WAKEUP_INT_CLR = 0x1
	// Position of SLP_REJECT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_REJECT_INT_CLR_Pos = 0x1
	// Bit mask of SLP_REJECT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SLP_REJECT_INT_CLR_Msk = 0x2
	// Bit SLP_REJECT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SLP_REJECT_INT_CLR = 0x2
	// Position of SDIO_IDLE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SDIO_IDLE_INT_CLR_Pos = 0x2
	// Bit mask of SDIO_IDLE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SDIO_IDLE_INT_CLR_Msk = 0x4
	// Bit SDIO_IDLE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SDIO_IDLE_INT_CLR = 0x4
	// Position of WDT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_WDT_INT_CLR_Pos = 0x3
	// Bit mask of WDT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_WDT_INT_CLR_Msk = 0x8
	// Bit WDT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_WDT_INT_CLR = 0x8
	// Position of TOUCH_SCAN_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR_Pos = 0x4
	// Bit mask of TOUCH_SCAN_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR_Msk = 0x10
	// Bit TOUCH_SCAN_DONE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_SCAN_DONE_INT_CLR = 0x10
	// Position of ULP_CP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_ULP_CP_INT_CLR_Pos = 0x5
	// Bit mask of ULP_CP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_ULP_CP_INT_CLR_Msk = 0x20
	// Bit ULP_CP_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_ULP_CP_INT_CLR = 0x20
	// Position of TOUCH_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_DONE_INT_CLR_Pos = 0x6
	// Bit mask of TOUCH_DONE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_DONE_INT_CLR_Msk = 0x40
	// Bit TOUCH_DONE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_DONE_INT_CLR = 0x40
	// Position of TOUCH_ACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_ACTIVE_INT_CLR_Pos = 0x7
	// Bit mask of TOUCH_ACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_ACTIVE_INT_CLR_Msk = 0x80
	// Bit TOUCH_ACTIVE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_ACTIVE_INT_CLR = 0x80
	// Position of TOUCH_INACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_INACTIVE_INT_CLR_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_INACTIVE_INT_CLR_Msk = 0x100
	// Bit TOUCH_INACTIVE_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_INACTIVE_INT_CLR = 0x100
	// Position of BROWN_OUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_BROWN_OUT_INT_CLR_Pos = 0x9
	// Bit mask of BROWN_OUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_BROWN_OUT_INT_CLR_Msk = 0x200
	// Bit BROWN_OUT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_BROWN_OUT_INT_CLR = 0x200
	// Position of MAIN_TIMER_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_MAIN_TIMER_INT_CLR_Pos = 0xa
	// Bit mask of MAIN_TIMER_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_MAIN_TIMER_INT_CLR_Msk = 0x400
	// Bit MAIN_TIMER_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_MAIN_TIMER_INT_CLR = 0x400
	// Position of SARADC1_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC1_INT_CLR_Pos = 0xb
	// Bit mask of SARADC1_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC1_INT_CLR_Msk = 0x800
	// Bit SARADC1_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SARADC1_INT_CLR = 0x800
	// Position of TSENS_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TSENS_INT_CLR_Pos = 0xc
	// Bit mask of TSENS_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TSENS_INT_CLR_Msk = 0x1000
	// Bit TSENS_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TSENS_INT_CLR = 0x1000
	// Position of COCPU_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_INT_CLR_Pos = 0xd
	// Bit mask of COCPU_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_INT_CLR_Msk = 0x2000
	// Bit COCPU_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_COCPU_INT_CLR = 0x2000
	// Position of SARADC2_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC2_INT_CLR_Pos = 0xe
	// Bit mask of SARADC2_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SARADC2_INT_CLR_Msk = 0x4000
	// Bit SARADC2_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SARADC2_INT_CLR = 0x4000
	// Position of SWD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SWD_INT_CLR_Pos = 0xf
	// Bit mask of SWD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_SWD_INT_CLR_Msk = 0x8000
	// Bit SWD_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_SWD_INT_CLR = 0x8000
	// Position of XTAL32K_DEAD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_XTAL32K_DEAD_INT_CLR_Pos = 0x10
	// Bit mask of XTAL32K_DEAD_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_XTAL32K_DEAD_INT_CLR_Msk = 0x10000
	// Bit XTAL32K_DEAD_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_XTAL32K_DEAD_INT_CLR = 0x10000
	// Position of COCPU_TRAP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_TRAP_INT_CLR_Pos = 0x11
	// Bit mask of COCPU_TRAP_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_COCPU_TRAP_INT_CLR_Msk = 0x20000
	// Bit COCPU_TRAP_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_COCPU_TRAP_INT_CLR = 0x20000
	// Position of TOUCH_TIMEOUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR_Pos = 0x12
	// Bit mask of TOUCH_TIMEOUT_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR_Msk = 0x40000
	// Bit TOUCH_TIMEOUT_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_TOUCH_TIMEOUT_INT_CLR = 0x40000
	// Position of GLITCH_DET_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_GLITCH_DET_INT_CLR_Pos = 0x13
	// Bit mask of GLITCH_DET_INT_CLR field.
	RTC_CNTL_INT_CLR_RTC_GLITCH_DET_INT_CLR_Msk = 0x80000
	// Bit GLITCH_DET_INT_CLR.
	RTC_CNTL_INT_CLR_RTC_GLITCH_DET_INT_CLR = 0x80000

	// STORE0: Reservation register 0
	// Position of SCRATCH0 field.
	RTC_CNTL_STORE0_SCRATCH0_Pos = 0x0
	// Bit mask of SCRATCH0 field.
	RTC_CNTL_STORE0_SCRATCH0_Msk = 0xffffffff

	// STORE1: Reservation register 1
	// Position of SCRATCH1 field.
	RTC_CNTL_STORE1_SCRATCH1_Pos = 0x0
	// Bit mask of SCRATCH1 field.
	RTC_CNTL_STORE1_SCRATCH1_Msk = 0xffffffff

	// STORE2: Reservation register 2
	// Position of SCRATCH2 field.
	RTC_CNTL_STORE2_SCRATCH2_Pos = 0x0
	// Bit mask of SCRATCH2 field.
	RTC_CNTL_STORE2_SCRATCH2_Msk = 0xffffffff

	// STORE3: Reservation register 3
	// Position of SCRATCH3 field.
	RTC_CNTL_STORE3_SCRATCH3_Pos = 0x0
	// Bit mask of SCRATCH3 field.
	RTC_CNTL_STORE3_SCRATCH3_Msk = 0xffffffff

	// EXT_XTL_CONF: 32 kHz crystal oscillator configuration register
	// Position of XTAL32K_WDT_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_EN_Pos = 0x0
	// Bit mask of XTAL32K_WDT_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_EN_Msk = 0x1
	// Bit XTAL32K_WDT_EN.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_EN = 0x1
	// Position of XTAL32K_WDT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_CLK_FO_Pos = 0x1
	// Bit mask of XTAL32K_WDT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_CLK_FO_Msk = 0x2
	// Bit XTAL32K_WDT_CLK_FO.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_CLK_FO = 0x2
	// Position of XTAL32K_WDT_RESET field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_RESET_Pos = 0x2
	// Bit mask of XTAL32K_WDT_RESET field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_RESET_Msk = 0x4
	// Bit XTAL32K_WDT_RESET.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_WDT_RESET = 0x4
	// Position of XTAL32K_EXT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_EXT_CLK_FO_Pos = 0x3
	// Bit mask of XTAL32K_EXT_CLK_FO field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_EXT_CLK_FO_Msk = 0x8
	// Bit XTAL32K_EXT_CLK_FO.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_EXT_CLK_FO = 0x8
	// Position of XTAL32K_AUTO_BACKUP field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_BACKUP_Pos = 0x4
	// Bit mask of XTAL32K_AUTO_BACKUP field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_BACKUP_Msk = 0x10
	// Bit XTAL32K_AUTO_BACKUP.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_BACKUP = 0x10
	// Position of XTAL32K_AUTO_RESTART field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RESTART_Pos = 0x5
	// Bit mask of XTAL32K_AUTO_RESTART field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RESTART_Msk = 0x20
	// Bit XTAL32K_AUTO_RESTART.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RESTART = 0x20
	// Position of XTAL32K_AUTO_RETURN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RETURN_Pos = 0x6
	// Bit mask of XTAL32K_AUTO_RETURN field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RETURN_Msk = 0x40
	// Bit XTAL32K_AUTO_RETURN.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_AUTO_RETURN = 0x40
	// Position of XTAL32K_XPD_FORCE field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_XPD_FORCE_Pos = 0x7
	// Bit mask of XTAL32K_XPD_FORCE field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_XPD_FORCE_Msk = 0x80
	// Bit XTAL32K_XPD_FORCE.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_XPD_FORCE = 0x80
	// Position of ENCKINIT_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_ENCKINIT_XTAL_32K_Pos = 0x8
	// Bit mask of ENCKINIT_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_ENCKINIT_XTAL_32K_Msk = 0x100
	// Bit ENCKINIT_XTAL_32K.
	RTC_CNTL_EXT_XTL_CONF_ENCKINIT_XTAL_32K = 0x100
	// Position of DBUF_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DBUF_XTAL_32K_Pos = 0x9
	// Bit mask of DBUF_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DBUF_XTAL_32K_Msk = 0x200
	// Bit DBUF_XTAL_32K.
	RTC_CNTL_EXT_XTL_CONF_DBUF_XTAL_32K = 0x200
	// Position of DGM_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DGM_XTAL_32K_Pos = 0xa
	// Bit mask of DGM_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DGM_XTAL_32K_Msk = 0x1c00
	// Position of DRES_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DRES_XTAL_32K_Pos = 0xd
	// Bit mask of DRES_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DRES_XTAL_32K_Msk = 0xe000
	// Position of XPD_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_XPD_XTAL_32K_Pos = 0x10
	// Bit mask of XPD_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_XPD_XTAL_32K_Msk = 0x10000
	// Bit XPD_XTAL_32K.
	RTC_CNTL_EXT_XTL_CONF_XPD_XTAL_32K = 0x10000
	// Position of DAC_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DAC_XTAL_32K_Pos = 0x11
	// Bit mask of DAC_XTAL_32K field.
	RTC_CNTL_EXT_XTL_CONF_DAC_XTAL_32K_Msk = 0xe0000
	// Position of WDT_STATE field.
	RTC_CNTL_EXT_XTL_CONF_WDT_STATE_Pos = 0x14
	// Bit mask of WDT_STATE field.
	RTC_CNTL_EXT_XTL_CONF_WDT_STATE_Msk = 0x700000
	// Position of XTAL32K_GPIO_SEL field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_GPIO_SEL_Pos = 0x17
	// Bit mask of XTAL32K_GPIO_SEL field.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_GPIO_SEL_Msk = 0x800000
	// Bit XTAL32K_GPIO_SEL.
	RTC_CNTL_EXT_XTL_CONF_XTAL32K_GPIO_SEL = 0x800000
	// Position of XTL_EXT_CTR_LV field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV_Pos = 0x1e
	// Bit mask of XTL_EXT_CTR_LV field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV_Msk = 0x40000000
	// Bit XTL_EXT_CTR_LV.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_LV = 0x40000000
	// Position of XTL_EXT_CTR_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN_Pos = 0x1f
	// Bit mask of XTL_EXT_CTR_EN field.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN_Msk = 0x80000000
	// Bit XTL_EXT_CTR_EN.
	RTC_CNTL_EXT_XTL_CONF_XTL_EXT_CTR_EN = 0x80000000

	// EXT_WAKEUP_CONF: GPIO wakeup configuration register
	// Position of GPIO_WAKEUP_FILTER field.
	RTC_CNTL_EXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER_Pos = 0x1d
	// Bit mask of GPIO_WAKEUP_FILTER field.
	RTC_CNTL_EXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER_Msk = 0x20000000
	// Bit GPIO_WAKEUP_FILTER.
	RTC_CNTL_EXT_WAKEUP_CONF_GPIO_WAKEUP_FILTER = 0x20000000
	// Position of EXT_WAKEUP0_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV_Pos = 0x1e
	// Bit mask of EXT_WAKEUP0_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV_Msk = 0x40000000
	// Bit EXT_WAKEUP0_LV.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP0_LV = 0x40000000
	// Position of EXT_WAKEUP1_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV_Pos = 0x1f
	// Bit mask of EXT_WAKEUP1_LV field.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV_Msk = 0x80000000
	// Bit EXT_WAKEUP1_LV.
	RTC_CNTL_EXT_WAKEUP_CONF_EXT_WAKEUP1_LV = 0x80000000

	// SLP_REJECT_CONF: Configures sleep / reject options
	// Position of SLEEP_REJECT_ENA field.
	RTC_CNTL_SLP_REJECT_CONF_SLEEP_REJECT_ENA_Pos = 0xd
	// Bit mask of SLEEP_REJECT_ENA field.
	RTC_CNTL_SLP_REJECT_CONF_SLEEP_REJECT_ENA_Msk = 0x3fffe000
	// Position of LIGHT_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN_Pos = 0x1e
	// Bit mask of LIGHT_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN_Msk = 0x40000000
	// Bit LIGHT_SLP_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_LIGHT_SLP_REJECT_EN = 0x40000000
	// Position of DEEP_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN_Pos = 0x1f
	// Bit mask of DEEP_SLP_REJECT_EN field.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN_Msk = 0x80000000
	// Bit DEEP_SLP_REJECT_EN.
	RTC_CNTL_SLP_REJECT_CONF_DEEP_SLP_REJECT_EN = 0x80000000

	// CPU_PERIOD_CONF: CPU sel option
	// Position of CPUSEL_CONF field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF_Pos = 0x1d
	// Bit mask of CPUSEL_CONF field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF_Msk = 0x20000000
	// Bit CPUSEL_CONF.
	RTC_CNTL_CPU_PERIOD_CONF_CPUSEL_CONF = 0x20000000
	// Position of CPUPERIOD_SEL field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUPERIOD_SEL_Pos = 0x1e
	// Bit mask of CPUPERIOD_SEL field.
	RTC_CNTL_CPU_PERIOD_CONF_CPUPERIOD_SEL_Msk = 0xc0000000

	// SDIO_ACT_CONF: configure sdio active register
	// Position of SDIO_ACT_DNUM field.
	RTC_CNTL_SDIO_ACT_CONF_SDIO_ACT_DNUM_Pos = 0x16
	// Bit mask of SDIO_ACT_DNUM field.
	RTC_CNTL_SDIO_ACT_CONF_SDIO_ACT_DNUM_Msk = 0xffc00000

	// CLK_CONF: RTC clock configuration register
	// Position of CK8M_DIV_SEL_VLD field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_VLD_Pos = 0x3
	// Bit mask of CK8M_DIV_SEL_VLD field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_VLD_Msk = 0x8
	// Bit CK8M_DIV_SEL_VLD.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_VLD = 0x8
	// Position of CK8M_DIV field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_Pos = 0x4
	// Bit mask of CK8M_DIV field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_Msk = 0x30
	// Position of ENB_CK8M field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_Pos = 0x6
	// Bit mask of ENB_CK8M field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_Msk = 0x40
	// Bit ENB_CK8M.
	RTC_CNTL_CLK_CONF_ENB_CK8M = 0x40
	// Position of ENB_CK8M_DIV field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_Pos = 0x7
	// Bit mask of ENB_CK8M_DIV field.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV_Msk = 0x80
	// Bit ENB_CK8M_DIV.
	RTC_CNTL_CLK_CONF_ENB_CK8M_DIV = 0x80
	// Position of DIG_XTAL32K_EN field.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN_Pos = 0x8
	// Bit mask of DIG_XTAL32K_EN field.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN_Msk = 0x100
	// Bit DIG_XTAL32K_EN.
	RTC_CNTL_CLK_CONF_DIG_XTAL32K_EN = 0x100
	// Position of DIG_CLK8M_D256_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN_Pos = 0x9
	// Bit mask of DIG_CLK8M_D256_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN_Msk = 0x200
	// Bit DIG_CLK8M_D256_EN.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_D256_EN = 0x200
	// Position of DIG_CLK8M_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN_Pos = 0xa
	// Bit mask of DIG_CLK8M_EN field.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN_Msk = 0x400
	// Bit DIG_CLK8M_EN.
	RTC_CNTL_CLK_CONF_DIG_CLK8M_EN = 0x400
	// Position of CK8M_DIV_SEL field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_Pos = 0xc
	// Bit mask of CK8M_DIV_SEL field.
	RTC_CNTL_CLK_CONF_CK8M_DIV_SEL_Msk = 0x7000
	// Position of XTAL_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING_Pos = 0xf
	// Bit mask of XTAL_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING_Msk = 0x8000
	// Bit XTAL_FORCE_NOGATING.
	RTC_CNTL_CLK_CONF_XTAL_FORCE_NOGATING = 0x8000
	// Position of CK8M_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING_Pos = 0x10
	// Bit mask of CK8M_FORCE_NOGATING field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING_Msk = 0x10000
	// Bit CK8M_FORCE_NOGATING.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_NOGATING = 0x10000
	// Position of CK8M_DFREQ field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_Pos = 0x11
	// Bit mask of CK8M_DFREQ field.
	RTC_CNTL_CLK_CONF_CK8M_DFREQ_Msk = 0x1fe0000
	// Position of CK8M_FORCE_PD field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD_Pos = 0x19
	// Bit mask of CK8M_FORCE_PD field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD_Msk = 0x2000000
	// Bit CK8M_FORCE_PD.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PD = 0x2000000
	// Position of CK8M_FORCE_PU field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU_Pos = 0x1a
	// Bit mask of CK8M_FORCE_PU field.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU_Msk = 0x4000000
	// Bit CK8M_FORCE_PU.
	RTC_CNTL_CLK_CONF_CK8M_FORCE_PU = 0x4000000
	// Position of FAST_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_Pos = 0x1d
	// Bit mask of FAST_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL_Msk = 0x20000000
	// Bit FAST_CLK_RTC_SEL.
	RTC_CNTL_CLK_CONF_FAST_CLK_RTC_SEL = 0x20000000
	// Position of ANA_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_Pos = 0x1e
	// Bit mask of ANA_CLK_RTC_SEL field.
	RTC_CNTL_CLK_CONF_ANA_CLK_RTC_SEL_Msk = 0xc0000000

	// SLOW_CLK_CONF: RTC slow clock configuration register
	// Position of ANA_CLK_DIV_VLD field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_VLD_Pos = 0x16
	// Bit mask of ANA_CLK_DIV_VLD field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_VLD_Msk = 0x400000
	// Bit ANA_CLK_DIV_VLD.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_VLD = 0x400000
	// Position of ANA_CLK_DIV field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_Pos = 0x17
	// Bit mask of ANA_CLK_DIV field.
	RTC_CNTL_SLOW_CLK_CONF_ANA_CLK_DIV_Msk = 0x7f800000
	// Position of SLOW_CLK_NEXT_EDGE field.
	RTC_CNTL_SLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE_Pos = 0x1f
	// Bit mask of SLOW_CLK_NEXT_EDGE field.
	RTC_CNTL_SLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE_Msk = 0x80000000
	// Bit SLOW_CLK_NEXT_EDGE.
	RTC_CNTL_SLOW_CLK_CONF_SLOW_CLK_NEXT_EDGE = 0x80000000

	// SDIO_CONF: configure vddsdio register
	// Position of SDIO_TIMER_TARGET field.
	RTC_CNTL_SDIO_CONF_SDIO_TIMER_TARGET_Pos = 0x0
	// Bit mask of SDIO_TIMER_TARGET field.
	RTC_CNTL_SDIO_CONF_SDIO_TIMER_TARGET_Msk = 0xff
	// Position of SDIO_DTHDRV field.
	RTC_CNTL_SDIO_CONF_SDIO_DTHDRV_Pos = 0x9
	// Bit mask of SDIO_DTHDRV field.
	RTC_CNTL_SDIO_CONF_SDIO_DTHDRV_Msk = 0x600
	// Position of SDIO_DCAP field.
	RTC_CNTL_SDIO_CONF_SDIO_DCAP_Pos = 0xb
	// Bit mask of SDIO_DCAP field.
	RTC_CNTL_SDIO_CONF_SDIO_DCAP_Msk = 0x1800
	// Position of SDIO_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_INITI_Pos = 0xd
	// Bit mask of SDIO_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_INITI_Msk = 0x6000
	// Position of SDIO_EN_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_EN_INITI_Pos = 0xf
	// Bit mask of SDIO_EN_INITI field.
	RTC_CNTL_SDIO_CONF_SDIO_EN_INITI_Msk = 0x8000
	// Bit SDIO_EN_INITI.
	RTC_CNTL_SDIO_CONF_SDIO_EN_INITI = 0x8000
	// Position of SDIO_DCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_DCURLIM_Pos = 0x10
	// Bit mask of SDIO_DCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_DCURLIM_Msk = 0x70000
	// Position of SDIO_MODECURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_MODECURLIM_Pos = 0x13
	// Bit mask of SDIO_MODECURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_MODECURLIM_Msk = 0x80000
	// Bit SDIO_MODECURLIM.
	RTC_CNTL_SDIO_CONF_SDIO_MODECURLIM = 0x80000
	// Position of SDIO_ENCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_ENCURLIM_Pos = 0x14
	// Bit mask of SDIO_ENCURLIM field.
	RTC_CNTL_SDIO_CONF_SDIO_ENCURLIM_Msk = 0x100000
	// Bit SDIO_ENCURLIM.
	RTC_CNTL_SDIO_CONF_SDIO_ENCURLIM = 0x100000
	// Position of SDIO_REG_PD_EN field.
	RTC_CNTL_SDIO_CONF_SDIO_REG_PD_EN_Pos = 0x15
	// Bit mask of SDIO_REG_PD_EN field.
	RTC_CNTL_SDIO_CONF_SDIO_REG_PD_EN_Msk = 0x200000
	// Bit SDIO_REG_PD_EN.
	RTC_CNTL_SDIO_CONF_SDIO_REG_PD_EN = 0x200000
	// Position of SDIO_FORCE field.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE_Pos = 0x16
	// Bit mask of SDIO_FORCE field.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE_Msk = 0x400000
	// Bit SDIO_FORCE.
	RTC_CNTL_SDIO_CONF_SDIO_FORCE = 0x400000
	// Position of SDIO_TIEH field.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH_Pos = 0x17
	// Bit mask of SDIO_TIEH field.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH_Msk = 0x800000
	// Bit SDIO_TIEH.
	RTC_CNTL_SDIO_CONF_SDIO_TIEH = 0x800000
	// Position of REG1P8_READY field.
	RTC_CNTL_SDIO_CONF_REG1P8_READY_Pos = 0x18
	// Bit mask of REG1P8_READY field.
	RTC_CNTL_SDIO_CONF_REG1P8_READY_Msk = 0x1000000
	// Bit REG1P8_READY.
	RTC_CNTL_SDIO_CONF_REG1P8_READY = 0x1000000
	// Position of DREFL_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFL_SDIO_Pos = 0x19
	// Bit mask of DREFL_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFL_SDIO_Msk = 0x6000000
	// Position of DREFM_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFM_SDIO_Pos = 0x1b
	// Bit mask of DREFM_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFM_SDIO_Msk = 0x18000000
	// Position of DREFH_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFH_SDIO_Pos = 0x1d
	// Bit mask of DREFH_SDIO field.
	RTC_CNTL_SDIO_CONF_DREFH_SDIO_Msk = 0x60000000
	// Position of XPD_SDIO field.
	RTC_CNTL_SDIO_CONF_XPD_SDIO_Pos = 0x1f
	// Bit mask of XPD_SDIO field.
	RTC_CNTL_SDIO_CONF_XPD_SDIO_Msk = 0x80000000
	// Bit XPD_SDIO.
	RTC_CNTL_SDIO_CONF_XPD_SDIO = 0x80000000

	// BIAS_CONF: configure power register
	// Position of BIAS_BUF_IDLE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_IDLE_Pos = 0xa
	// Bit mask of BIAS_BUF_IDLE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_IDLE_Msk = 0x400
	// Bit BIAS_BUF_IDLE.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_IDLE = 0x400
	// Position of BIAS_BUF_WAKE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_WAKE_Pos = 0xb
	// Bit mask of BIAS_BUF_WAKE field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_WAKE_Msk = 0x800
	// Bit BIAS_BUF_WAKE.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_WAKE = 0x800
	// Position of BIAS_BUF_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_DEEP_SLP_Pos = 0xc
	// Bit mask of BIAS_BUF_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_DEEP_SLP_Msk = 0x1000
	// Bit BIAS_BUF_DEEP_SLP.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_DEEP_SLP = 0x1000
	// Position of BIAS_BUF_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_MONITOR_Pos = 0xd
	// Bit mask of BIAS_BUF_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_MONITOR_Msk = 0x2000
	// Bit BIAS_BUF_MONITOR.
	RTC_CNTL_BIAS_CONF_BIAS_BUF_MONITOR = 0x2000
	// Position of PD_CUR_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_PD_CUR_DEEP_SLP_Pos = 0xe
	// Bit mask of PD_CUR_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_PD_CUR_DEEP_SLP_Msk = 0x4000
	// Bit PD_CUR_DEEP_SLP.
	RTC_CNTL_BIAS_CONF_PD_CUR_DEEP_SLP = 0x4000
	// Position of PD_CUR_MONITOR field.
	RTC_CNTL_BIAS_CONF_PD_CUR_MONITOR_Pos = 0xf
	// Bit mask of PD_CUR_MONITOR field.
	RTC_CNTL_BIAS_CONF_PD_CUR_MONITOR_Msk = 0x8000
	// Bit PD_CUR_MONITOR.
	RTC_CNTL_BIAS_CONF_PD_CUR_MONITOR = 0x8000
	// Position of BIAS_SLEEP_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_DEEP_SLP_Pos = 0x10
	// Bit mask of BIAS_SLEEP_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_DEEP_SLP_Msk = 0x10000
	// Bit BIAS_SLEEP_DEEP_SLP.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_DEEP_SLP = 0x10000
	// Position of BIAS_SLEEP_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_MONITOR_Pos = 0x11
	// Bit mask of BIAS_SLEEP_MONITOR field.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_MONITOR_Msk = 0x20000
	// Bit BIAS_SLEEP_MONITOR.
	RTC_CNTL_BIAS_CONF_BIAS_SLEEP_MONITOR = 0x20000
	// Position of DBG_ATTEN_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_DEEP_SLP_Pos = 0x12
	// Bit mask of DBG_ATTEN_DEEP_SLP field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_DEEP_SLP_Msk = 0x3c0000
	// Position of DBG_ATTEN_MONITOR field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_MONITOR_Pos = 0x16
	// Bit mask of DBG_ATTEN_MONITOR field.
	RTC_CNTL_BIAS_CONF_DBG_ATTEN_MONITOR_Msk = 0x3c00000
	// Position of ENB_SCK_XTAL field.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL_Pos = 0x1a
	// Bit mask of ENB_SCK_XTAL field.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL_Msk = 0x4000000
	// Bit ENB_SCK_XTAL.
	RTC_CNTL_BIAS_CONF_ENB_SCK_XTAL = 0x4000000
	// Position of INC_HEARTBEAT_REFRESH field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH_Pos = 0x1b
	// Bit mask of INC_HEARTBEAT_REFRESH field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH_Msk = 0x8000000
	// Bit INC_HEARTBEAT_REFRESH.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_REFRESH = 0x8000000
	// Position of DEC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD_Pos = 0x1c
	// Bit mask of DEC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD_Msk = 0x10000000
	// Bit DEC_HEARTBEAT_PERIOD.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_PERIOD = 0x10000000
	// Position of INC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD_Pos = 0x1d
	// Bit mask of INC_HEARTBEAT_PERIOD field.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD_Msk = 0x20000000
	// Bit INC_HEARTBEAT_PERIOD.
	RTC_CNTL_BIAS_CONF_INC_HEARTBEAT_PERIOD = 0x20000000
	// Position of DEC_HEARTBEAT_WIDTH field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH_Pos = 0x1e
	// Bit mask of DEC_HEARTBEAT_WIDTH field.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH_Msk = 0x40000000
	// Bit DEC_HEARTBEAT_WIDTH.
	RTC_CNTL_BIAS_CONF_DEC_HEARTBEAT_WIDTH = 0x40000000
	// Position of RST_BIAS_I2C field.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C_Pos = 0x1f
	// Bit mask of RST_BIAS_I2C field.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C_Msk = 0x80000000
	// Bit RST_BIAS_I2C.
	RTC_CNTL_BIAS_CONF_RST_BIAS_I2C = 0x80000000

	// REG: RTC/DIG regulator configuration register
	// Position of DIG_REG_DBIAS_SLP field.
	RTC_CNTL_REG_DIG_REG_DBIAS_SLP_Pos = 0x8
	// Bit mask of DIG_REG_DBIAS_SLP field.
	RTC_CNTL_REG_DIG_REG_DBIAS_SLP_Msk = 0x700
	// Position of DIG_REG_DBIAS_WAK field.
	RTC_CNTL_REG_DIG_REG_DBIAS_WAK_Pos = 0xb
	// Bit mask of DIG_REG_DBIAS_WAK field.
	RTC_CNTL_REG_DIG_REG_DBIAS_WAK_Msk = 0x3800
	// Position of SCK_DCAP field.
	RTC_CNTL_REG_SCK_DCAP_Pos = 0xe
	// Bit mask of SCK_DCAP field.
	RTC_CNTL_REG_SCK_DCAP_Msk = 0x3fc000
	// Position of DBIAS_SLP field.
	RTC_CNTL_REG_DBIAS_SLP_Pos = 0x16
	// Bit mask of DBIAS_SLP field.
	RTC_CNTL_REG_DBIAS_SLP_Msk = 0x1c00000
	// Position of DBIAS_WAK field.
	RTC_CNTL_REG_DBIAS_WAK_Pos = 0x19
	// Bit mask of DBIAS_WAK field.
	RTC_CNTL_REG_DBIAS_WAK_Msk = 0xe000000
	// Position of DBOOST_FORCE_PD field.
	RTC_CNTL_REG_DBOOST_FORCE_PD_Pos = 0x1c
	// Bit mask of DBOOST_FORCE_PD field.
	RTC_CNTL_REG_DBOOST_FORCE_PD_Msk = 0x10000000
	// Bit DBOOST_FORCE_PD.
	RTC_CNTL_REG_DBOOST_FORCE_PD = 0x10000000
	// Position of DBOOST_FORCE_PU field.
	RTC_CNTL_REG_DBOOST_FORCE_PU_Pos = 0x1d
	// Bit mask of DBOOST_FORCE_PU field.
	RTC_CNTL_REG_DBOOST_FORCE_PU_Msk = 0x20000000
	// Bit DBOOST_FORCE_PU.
	RTC_CNTL_REG_DBOOST_FORCE_PU = 0x20000000
	// Position of REGULATOR_FORCE_PD field.
	RTC_CNTL_REG_REGULATOR_FORCE_PD_Pos = 0x1e
	// Bit mask of REGULATOR_FORCE_PD field.
	RTC_CNTL_REG_REGULATOR_FORCE_PD_Msk = 0x40000000
	// Bit REGULATOR_FORCE_PD.
	RTC_CNTL_REG_REGULATOR_FORCE_PD = 0x40000000
	// Position of REGULATOR_FORCE_PU field.
	RTC_CNTL_REG_REGULATOR_FORCE_PU_Pos = 0x1f
	// Bit mask of REGULATOR_FORCE_PU field.
	RTC_CNTL_REG_REGULATOR_FORCE_PU_Msk = 0x80000000
	// Bit REGULATOR_FORCE_PU.
	RTC_CNTL_REG_REGULATOR_FORCE_PU = 0x80000000

	// PWC: RTC power configuraiton register
	// Position of FASTMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO_Pos = 0x0
	// Bit mask of FASTMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO_Msk = 0x1
	// Bit FASTMEM_FORCE_NOISO.
	RTC_CNTL_PWC_FASTMEM_FORCE_NOISO = 0x1
	// Position of FASTMEM_FORCE_ISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO_Pos = 0x1
	// Bit mask of FASTMEM_FORCE_ISO field.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO_Msk = 0x2
	// Bit FASTMEM_FORCE_ISO.
	RTC_CNTL_PWC_FASTMEM_FORCE_ISO = 0x2
	// Position of SLOWMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO_Pos = 0x2
	// Bit mask of SLOWMEM_FORCE_NOISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO_Msk = 0x4
	// Bit SLOWMEM_FORCE_NOISO.
	RTC_CNTL_PWC_SLOWMEM_FORCE_NOISO = 0x4
	// Position of SLOWMEM_FORCE_ISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO_Pos = 0x3
	// Bit mask of SLOWMEM_FORCE_ISO field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO_Msk = 0x8
	// Bit SLOWMEM_FORCE_ISO.
	RTC_CNTL_PWC_SLOWMEM_FORCE_ISO = 0x8
	// Position of FORCE_ISO field.
	RTC_CNTL_PWC_FORCE_ISO_Pos = 0x4
	// Bit mask of FORCE_ISO field.
	RTC_CNTL_PWC_FORCE_ISO_Msk = 0x10
	// Bit FORCE_ISO.
	RTC_CNTL_PWC_FORCE_ISO = 0x10
	// Position of FORCE_NOISO field.
	RTC_CNTL_PWC_FORCE_NOISO_Pos = 0x5
	// Bit mask of FORCE_NOISO field.
	RTC_CNTL_PWC_FORCE_NOISO_Msk = 0x20
	// Bit FORCE_NOISO.
	RTC_CNTL_PWC_FORCE_NOISO = 0x20
	// Position of FASTMEM_FOLW_CPU field.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU_Pos = 0x6
	// Bit mask of FASTMEM_FOLW_CPU field.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU_Msk = 0x40
	// Bit FASTMEM_FOLW_CPU.
	RTC_CNTL_PWC_FASTMEM_FOLW_CPU = 0x40
	// Position of FASTMEM_FORCE_LPD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD_Pos = 0x7
	// Bit mask of FASTMEM_FORCE_LPD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD_Msk = 0x80
	// Bit FASTMEM_FORCE_LPD.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPD = 0x80
	// Position of FASTMEM_FORCE_LPU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU_Pos = 0x8
	// Bit mask of FASTMEM_FORCE_LPU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU_Msk = 0x100
	// Bit FASTMEM_FORCE_LPU.
	RTC_CNTL_PWC_FASTMEM_FORCE_LPU = 0x100
	// Position of SLOWMEM_FOLW_CPU field.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU_Pos = 0x9
	// Bit mask of SLOWMEM_FOLW_CPU field.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU_Msk = 0x200
	// Bit SLOWMEM_FOLW_CPU.
	RTC_CNTL_PWC_SLOWMEM_FOLW_CPU = 0x200
	// Position of SLOWMEM_FORCE_LPD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD_Pos = 0xa
	// Bit mask of SLOWMEM_FORCE_LPD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD_Msk = 0x400
	// Bit SLOWMEM_FORCE_LPD.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPD = 0x400
	// Position of SLOWMEM_FORCE_LPU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU_Pos = 0xb
	// Bit mask of SLOWMEM_FORCE_LPU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU_Msk = 0x800
	// Bit SLOWMEM_FORCE_LPU.
	RTC_CNTL_PWC_SLOWMEM_FORCE_LPU = 0x800
	// Position of FASTMEM_FORCE_PD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD_Pos = 0xc
	// Bit mask of FASTMEM_FORCE_PD field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD_Msk = 0x1000
	// Bit FASTMEM_FORCE_PD.
	RTC_CNTL_PWC_FASTMEM_FORCE_PD = 0x1000
	// Position of FASTMEM_FORCE_PU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU_Pos = 0xd
	// Bit mask of FASTMEM_FORCE_PU field.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU_Msk = 0x2000
	// Bit FASTMEM_FORCE_PU.
	RTC_CNTL_PWC_FASTMEM_FORCE_PU = 0x2000
	// Position of FASTMEM_PD_EN field.
	RTC_CNTL_PWC_FASTMEM_PD_EN_Pos = 0xe
	// Bit mask of FASTMEM_PD_EN field.
	RTC_CNTL_PWC_FASTMEM_PD_EN_Msk = 0x4000
	// Bit FASTMEM_PD_EN.
	RTC_CNTL_PWC_FASTMEM_PD_EN = 0x4000
	// Position of SLOWMEM_FORCE_PD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD_Pos = 0xf
	// Bit mask of SLOWMEM_FORCE_PD field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD_Msk = 0x8000
	// Bit SLOWMEM_FORCE_PD.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PD = 0x8000
	// Position of SLOWMEM_FORCE_PU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU_Pos = 0x10
	// Bit mask of SLOWMEM_FORCE_PU field.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU_Msk = 0x10000
	// Bit SLOWMEM_FORCE_PU.
	RTC_CNTL_PWC_SLOWMEM_FORCE_PU = 0x10000
	// Position of SLOWMEM_PD_EN field.
	RTC_CNTL_PWC_SLOWMEM_PD_EN_Pos = 0x11
	// Bit mask of SLOWMEM_PD_EN field.
	RTC_CNTL_PWC_SLOWMEM_PD_EN_Msk = 0x20000
	// Bit SLOWMEM_PD_EN.
	RTC_CNTL_PWC_SLOWMEM_PD_EN = 0x20000
	// Position of FORCE_PD field.
	RTC_CNTL_PWC_FORCE_PD_Pos = 0x12
	// Bit mask of FORCE_PD field.
	RTC_CNTL_PWC_FORCE_PD_Msk = 0x40000
	// Bit FORCE_PD.
	RTC_CNTL_PWC_FORCE_PD = 0x40000
	// Position of FORCE_PU field.
	RTC_CNTL_PWC_FORCE_PU_Pos = 0x13
	// Bit mask of FORCE_PU field.
	RTC_CNTL_PWC_FORCE_PU_Msk = 0x80000
	// Bit FORCE_PU.
	RTC_CNTL_PWC_FORCE_PU = 0x80000
	// Position of PD_EN field.
	RTC_CNTL_PWC_PD_EN_Pos = 0x14
	// Bit mask of PD_EN field.
	RTC_CNTL_PWC_PD_EN_Msk = 0x100000
	// Bit PD_EN.
	RTC_CNTL_PWC_PD_EN = 0x100000
	// Position of PAD_FORCE_HOLD field.
	RTC_CNTL_PWC_PAD_FORCE_HOLD_Pos = 0x15
	// Bit mask of PAD_FORCE_HOLD field.
	RTC_CNTL_PWC_PAD_FORCE_HOLD_Msk = 0x200000
	// Bit PAD_FORCE_HOLD.
	RTC_CNTL_PWC_PAD_FORCE_HOLD = 0x200000

	// DIG_PWC: Digital system power configuraiton register
	// Position of LSLP_MEM_FORCE_PD field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of LSLP_MEM_FORCE_PD field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD_Msk = 0x8
	// Bit LSLP_MEM_FORCE_PD.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PD = 0x8
	// Position of LSLP_MEM_FORCE_PU field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of LSLP_MEM_FORCE_PU field.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU_Msk = 0x10
	// Bit LSLP_MEM_FORCE_PU.
	RTC_CNTL_DIG_PWC_LSLP_MEM_FORCE_PU = 0x10
	// Position of ROM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD_Pos = 0x5
	// Bit mask of ROM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD_Msk = 0x20
	// Bit ROM0_FORCE_PD.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PD = 0x20
	// Position of ROM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU_Pos = 0x6
	// Bit mask of ROM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU_Msk = 0x40
	// Bit ROM0_FORCE_PU.
	RTC_CNTL_DIG_PWC_ROM0_FORCE_PU = 0x40
	// Position of INTER_RAM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD_Pos = 0x7
	// Bit mask of INTER_RAM0_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD_Msk = 0x80
	// Bit INTER_RAM0_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PD = 0x80
	// Position of INTER_RAM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU_Pos = 0x8
	// Bit mask of INTER_RAM0_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU_Msk = 0x100
	// Bit INTER_RAM0_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM0_FORCE_PU = 0x100
	// Position of INTER_RAM1_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD_Pos = 0x9
	// Bit mask of INTER_RAM1_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD_Msk = 0x200
	// Bit INTER_RAM1_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PD = 0x200
	// Position of INTER_RAM1_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU_Pos = 0xa
	// Bit mask of INTER_RAM1_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU_Msk = 0x400
	// Bit INTER_RAM1_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM1_FORCE_PU = 0x400
	// Position of INTER_RAM2_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD_Pos = 0xb
	// Bit mask of INTER_RAM2_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD_Msk = 0x800
	// Bit INTER_RAM2_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PD = 0x800
	// Position of INTER_RAM2_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU_Pos = 0xc
	// Bit mask of INTER_RAM2_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU_Msk = 0x1000
	// Bit INTER_RAM2_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM2_FORCE_PU = 0x1000
	// Position of INTER_RAM3_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD_Pos = 0xd
	// Bit mask of INTER_RAM3_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD_Msk = 0x2000
	// Bit INTER_RAM3_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PD = 0x2000
	// Position of INTER_RAM3_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU_Pos = 0xe
	// Bit mask of INTER_RAM3_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU_Msk = 0x4000
	// Bit INTER_RAM3_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM3_FORCE_PU = 0x4000
	// Position of INTER_RAM4_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD_Pos = 0xf
	// Bit mask of INTER_RAM4_FORCE_PD field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD_Msk = 0x8000
	// Bit INTER_RAM4_FORCE_PD.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PD = 0x8000
	// Position of INTER_RAM4_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU_Pos = 0x10
	// Bit mask of INTER_RAM4_FORCE_PU field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU_Msk = 0x10000
	// Bit INTER_RAM4_FORCE_PU.
	RTC_CNTL_DIG_PWC_INTER_RAM4_FORCE_PU = 0x10000
	// Position of WIFI_FORCE_PD field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD_Pos = 0x11
	// Bit mask of WIFI_FORCE_PD field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD_Msk = 0x20000
	// Bit WIFI_FORCE_PD.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PD = 0x20000
	// Position of WIFI_FORCE_PU field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU_Pos = 0x12
	// Bit mask of WIFI_FORCE_PU field.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU_Msk = 0x40000
	// Bit WIFI_FORCE_PU.
	RTC_CNTL_DIG_PWC_WIFI_FORCE_PU = 0x40000
	// Position of DG_WRAP_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD_Pos = 0x13
	// Bit mask of DG_WRAP_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD_Msk = 0x80000
	// Bit DG_WRAP_FORCE_PD.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PD = 0x80000
	// Position of DG_WRAP_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU_Pos = 0x14
	// Bit mask of DG_WRAP_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU_Msk = 0x100000
	// Bit DG_WRAP_FORCE_PU.
	RTC_CNTL_DIG_PWC_DG_WRAP_FORCE_PU = 0x100000
	// Position of DG_DCDC_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PD_Pos = 0x15
	// Bit mask of DG_DCDC_FORCE_PD field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PD_Msk = 0x200000
	// Bit DG_DCDC_FORCE_PD.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PD = 0x200000
	// Position of DG_DCDC_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PU_Pos = 0x16
	// Bit mask of DG_DCDC_FORCE_PU field.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PU_Msk = 0x400000
	// Bit DG_DCDC_FORCE_PU.
	RTC_CNTL_DIG_PWC_DG_DCDC_FORCE_PU = 0x400000
	// Position of DG_DCDC_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_DCDC_PD_EN_Pos = 0x17
	// Bit mask of DG_DCDC_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_DCDC_PD_EN_Msk = 0x800000
	// Bit DG_DCDC_PD_EN.
	RTC_CNTL_DIG_PWC_DG_DCDC_PD_EN = 0x800000
	// Position of ROM0_PD_EN field.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN_Pos = 0x18
	// Bit mask of ROM0_PD_EN field.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN_Msk = 0x1000000
	// Bit ROM0_PD_EN.
	RTC_CNTL_DIG_PWC_ROM0_PD_EN = 0x1000000
	// Position of INTER_RAM0_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN_Pos = 0x19
	// Bit mask of INTER_RAM0_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN_Msk = 0x2000000
	// Bit INTER_RAM0_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM0_PD_EN = 0x2000000
	// Position of INTER_RAM1_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN_Pos = 0x1a
	// Bit mask of INTER_RAM1_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN_Msk = 0x4000000
	// Bit INTER_RAM1_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM1_PD_EN = 0x4000000
	// Position of INTER_RAM2_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN_Pos = 0x1b
	// Bit mask of INTER_RAM2_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN_Msk = 0x8000000
	// Bit INTER_RAM2_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM2_PD_EN = 0x8000000
	// Position of INTER_RAM3_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN_Pos = 0x1c
	// Bit mask of INTER_RAM3_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN_Msk = 0x10000000
	// Bit INTER_RAM3_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM3_PD_EN = 0x10000000
	// Position of INTER_RAM4_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN_Pos = 0x1d
	// Bit mask of INTER_RAM4_PD_EN field.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN_Msk = 0x20000000
	// Bit INTER_RAM4_PD_EN.
	RTC_CNTL_DIG_PWC_INTER_RAM4_PD_EN = 0x20000000
	// Position of WIFI_PD_EN field.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN_Pos = 0x1e
	// Bit mask of WIFI_PD_EN field.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN_Msk = 0x40000000
	// Bit WIFI_PD_EN.
	RTC_CNTL_DIG_PWC_WIFI_PD_EN = 0x40000000
	// Position of DG_WRAP_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN_Pos = 0x1f
	// Bit mask of DG_WRAP_PD_EN field.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN_Msk = 0x80000000
	// Bit DG_WRAP_PD_EN.
	RTC_CNTL_DIG_PWC_DG_WRAP_PD_EN = 0x80000000

	// DIG_ISO: Digital system ISO configuration register
	// Position of FORCE_OFF field.
	RTC_CNTL_DIG_ISO_FORCE_OFF_Pos = 0x7
	// Bit mask of FORCE_OFF field.
	RTC_CNTL_DIG_ISO_FORCE_OFF_Msk = 0x80
	// Bit FORCE_OFF.
	RTC_CNTL_DIG_ISO_FORCE_OFF = 0x80
	// Position of FORCE_ON field.
	RTC_CNTL_DIG_ISO_FORCE_ON_Pos = 0x8
	// Bit mask of FORCE_ON field.
	RTC_CNTL_DIG_ISO_FORCE_ON_Msk = 0x100
	// Bit FORCE_ON.
	RTC_CNTL_DIG_ISO_FORCE_ON = 0x100
	// Position of DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_Pos = 0x9
	// Bit mask of DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_Msk = 0x200
	// Bit DG_PAD_AUTOHOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD = 0x200
	// Position of CLR_DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD_Pos = 0xa
	// Bit mask of CLR_DG_PAD_AUTOHOLD field.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD_Msk = 0x400
	// Bit CLR_DG_PAD_AUTOHOLD.
	RTC_CNTL_DIG_ISO_CLR_DG_PAD_AUTOHOLD = 0x400
	// Position of DG_PAD_AUTOHOLD_EN field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN_Pos = 0xb
	// Bit mask of DG_PAD_AUTOHOLD_EN field.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN_Msk = 0x800
	// Bit DG_PAD_AUTOHOLD_EN.
	RTC_CNTL_DIG_ISO_DG_PAD_AUTOHOLD_EN = 0x800
	// Position of DG_PAD_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO_Pos = 0xc
	// Bit mask of DG_PAD_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO_Msk = 0x1000
	// Bit DG_PAD_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_NOISO = 0x1000
	// Position of DG_PAD_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO_Pos = 0xd
	// Bit mask of DG_PAD_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO_Msk = 0x2000
	// Bit DG_PAD_FORCE_ISO.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_ISO = 0x2000
	// Position of DG_PAD_FORCE_UNHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD_Pos = 0xe
	// Bit mask of DG_PAD_FORCE_UNHOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD_Msk = 0x4000
	// Bit DG_PAD_FORCE_UNHOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_UNHOLD = 0x4000
	// Position of DG_PAD_FORCE_HOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD_Pos = 0xf
	// Bit mask of DG_PAD_FORCE_HOLD field.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD_Msk = 0x8000
	// Bit DG_PAD_FORCE_HOLD.
	RTC_CNTL_DIG_ISO_DG_PAD_FORCE_HOLD = 0x8000
	// Position of ROM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO_Pos = 0x10
	// Bit mask of ROM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO_Msk = 0x10000
	// Bit ROM0_FORCE_ISO.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_ISO = 0x10000
	// Position of ROM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO_Pos = 0x11
	// Bit mask of ROM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO_Msk = 0x20000
	// Bit ROM0_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_ROM0_FORCE_NOISO = 0x20000
	// Position of INTER_RAM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO_Pos = 0x12
	// Bit mask of INTER_RAM0_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO_Msk = 0x40000
	// Bit INTER_RAM0_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_ISO = 0x40000
	// Position of INTER_RAM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO_Pos = 0x13
	// Bit mask of INTER_RAM0_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO_Msk = 0x80000
	// Bit INTER_RAM0_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM0_FORCE_NOISO = 0x80000
	// Position of INTER_RAM1_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO_Pos = 0x14
	// Bit mask of INTER_RAM1_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO_Msk = 0x100000
	// Bit INTER_RAM1_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_ISO = 0x100000
	// Position of INTER_RAM1_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO_Pos = 0x15
	// Bit mask of INTER_RAM1_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO_Msk = 0x200000
	// Bit INTER_RAM1_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM1_FORCE_NOISO = 0x200000
	// Position of INTER_RAM2_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO_Pos = 0x16
	// Bit mask of INTER_RAM2_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO_Msk = 0x400000
	// Bit INTER_RAM2_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_ISO = 0x400000
	// Position of INTER_RAM2_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO_Pos = 0x17
	// Bit mask of INTER_RAM2_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO_Msk = 0x800000
	// Bit INTER_RAM2_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM2_FORCE_NOISO = 0x800000
	// Position of INTER_RAM3_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO_Pos = 0x18
	// Bit mask of INTER_RAM3_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO_Msk = 0x1000000
	// Bit INTER_RAM3_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_ISO = 0x1000000
	// Position of INTER_RAM3_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO_Pos = 0x19
	// Bit mask of INTER_RAM3_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO_Msk = 0x2000000
	// Bit INTER_RAM3_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM3_FORCE_NOISO = 0x2000000
	// Position of INTER_RAM4_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO_Pos = 0x1a
	// Bit mask of INTER_RAM4_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO_Msk = 0x4000000
	// Bit INTER_RAM4_FORCE_ISO.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_ISO = 0x4000000
	// Position of INTER_RAM4_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO_Pos = 0x1b
	// Bit mask of INTER_RAM4_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO_Msk = 0x8000000
	// Bit INTER_RAM4_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_INTER_RAM4_FORCE_NOISO = 0x8000000
	// Position of WIFI_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO_Pos = 0x1c
	// Bit mask of WIFI_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO_Msk = 0x10000000
	// Bit WIFI_FORCE_ISO.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_ISO = 0x10000000
	// Position of WIFI_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO_Pos = 0x1d
	// Bit mask of WIFI_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO_Msk = 0x20000000
	// Bit WIFI_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_WIFI_FORCE_NOISO = 0x20000000
	// Position of DG_WRAP_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO_Pos = 0x1e
	// Bit mask of DG_WRAP_FORCE_ISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO_Msk = 0x40000000
	// Bit DG_WRAP_FORCE_ISO.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_ISO = 0x40000000
	// Position of DG_WRAP_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO_Pos = 0x1f
	// Bit mask of DG_WRAP_FORCE_NOISO field.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO_Msk = 0x80000000
	// Bit DG_WRAP_FORCE_NOISO.
	RTC_CNTL_DIG_ISO_DG_WRAP_FORCE_NOISO = 0x80000000

	// WDTCONFIG0: RTC watchdog configuration register
	// Position of WDT_CHIP_RESET_WIDTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_WIDTH_Pos = 0x0
	// Bit mask of WDT_CHIP_RESET_WIDTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_WIDTH_Msk = 0xff
	// Position of WDT_CHIP_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_EN_Pos = 0x8
	// Bit mask of WDT_CHIP_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_EN_Msk = 0x100
	// Bit WDT_CHIP_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_CHIP_RESET_EN = 0x100
	// Position of WDT_PAUSE_IN_SLP field.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP_Pos = 0x9
	// Bit mask of WDT_PAUSE_IN_SLP field.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP_Msk = 0x200
	// Bit WDT_PAUSE_IN_SLP.
	RTC_CNTL_WDTCONFIG0_WDT_PAUSE_IN_SLP = 0x200
	// Position of WDT_APPCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0xa
	// Bit mask of WDT_APPCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x400
	// Bit WDT_APPCPU_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x400
	// Position of WDT_PROCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0xb
	// Bit mask of WDT_PROCPU_RESET_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x800
	// Bit WDT_PROCPU_RESET_EN.
	RTC_CNTL_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x800
	// Position of WDT_FLASHBOOT_MOD_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xc
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x1000
	// Bit WDT_FLASHBOOT_MOD_EN.
	RTC_CNTL_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x1000
	// Position of WDT_SYS_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xd
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0xe000
	// Position of WDT_CPU_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0x10
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	RTC_CNTL_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x70000
	// Position of WDT_STG3 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG3_Pos = 0x13
	// Bit mask of WDT_STG3 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG3_Msk = 0x380000
	// Position of WDT_STG2 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG2_Pos = 0x16
	// Bit mask of WDT_STG2 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG2_Msk = 0x1c00000
	// Position of WDT_STG1 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG1_Pos = 0x19
	// Bit mask of WDT_STG1 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG1_Msk = 0xe000000
	// Position of WDT_STG0 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG0_Pos = 0x1c
	// Bit mask of WDT_STG0 field.
	RTC_CNTL_WDTCONFIG0_WDT_STG0_Msk = 0x70000000
	// Position of WDT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	RTC_CNTL_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	RTC_CNTL_WDTCONFIG0_WDT_EN = 0x80000000

	// WDTCONFIG1: Configures the hold time of RTC watchdog at level 1
	// Position of WDT_STG0_HOLD field.
	RTC_CNTL_WDTCONFIG1_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	RTC_CNTL_WDTCONFIG1_WDT_STG0_HOLD_Msk = 0xffffffff

	// WDTCONFIG2: Configures the hold time of RTC watchdog at level 2
	// Position of WDT_STG1_HOLD field.
	RTC_CNTL_WDTCONFIG2_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	RTC_CNTL_WDTCONFIG2_WDT_STG1_HOLD_Msk = 0xffffffff

	// WDTCONFIG3: Configures the hold time of RTC watchdog at level 3
	// Position of WDT_STG2_HOLD field.
	RTC_CNTL_WDTCONFIG3_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	RTC_CNTL_WDTCONFIG3_WDT_STG2_HOLD_Msk = 0xffffffff

	// WDTCONFIG4: Configures the hold time of RTC watchdog at level 4
	// Position of WDT_STG3_HOLD field.
	RTC_CNTL_WDTCONFIG4_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	RTC_CNTL_WDTCONFIG4_WDT_STG3_HOLD_Msk = 0xffffffff

	// WDTFEED: RTC watchdog SW feed configuration register
	// Position of WDT_FEED field.
	RTC_CNTL_WDTFEED_WDT_FEED_Pos = 0x1f
	// Bit mask of WDT_FEED field.
	RTC_CNTL_WDTFEED_WDT_FEED_Msk = 0x80000000
	// Bit WDT_FEED.
	RTC_CNTL_WDTFEED_WDT_FEED = 0x80000000

	// WDTWPROTECT: RTC watchdog write protection configuration register
	// Position of WDT_WKEY field.
	RTC_CNTL_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	RTC_CNTL_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// SWD_CONF: Super watchdog configuration register
	// Position of SWD_RESET_FLAG field.
	RTC_CNTL_SWD_CONF_SWD_RESET_FLAG_Pos = 0x0
	// Bit mask of SWD_RESET_FLAG field.
	RTC_CNTL_SWD_CONF_SWD_RESET_FLAG_Msk = 0x1
	// Bit SWD_RESET_FLAG.
	RTC_CNTL_SWD_CONF_SWD_RESET_FLAG = 0x1
	// Position of SWD_FEED_INT field.
	RTC_CNTL_SWD_CONF_SWD_FEED_INT_Pos = 0x1
	// Bit mask of SWD_FEED_INT field.
	RTC_CNTL_SWD_CONF_SWD_FEED_INT_Msk = 0x2
	// Bit SWD_FEED_INT.
	RTC_CNTL_SWD_CONF_SWD_FEED_INT = 0x2
	// Position of SWD_SIGNAL_WIDTH field.
	RTC_CNTL_SWD_CONF_SWD_SIGNAL_WIDTH_Pos = 0x12
	// Bit mask of SWD_SIGNAL_WIDTH field.
	RTC_CNTL_SWD_CONF_SWD_SIGNAL_WIDTH_Msk = 0xffc0000
	// Position of SWD_RST_FLAG_CLR field.
	RTC_CNTL_SWD_CONF_SWD_RST_FLAG_CLR_Pos = 0x1c
	// Bit mask of SWD_RST_FLAG_CLR field.
	RTC_CNTL_SWD_CONF_SWD_RST_FLAG_CLR_Msk = 0x10000000
	// Bit SWD_RST_FLAG_CLR.
	RTC_CNTL_SWD_CONF_SWD_RST_FLAG_CLR = 0x10000000
	// Position of SWD_FEED field.
	RTC_CNTL_SWD_CONF_SWD_FEED_Pos = 0x1d
	// Bit mask of SWD_FEED field.
	RTC_CNTL_SWD_CONF_SWD_FEED_Msk = 0x20000000
	// Bit SWD_FEED.
	RTC_CNTL_SWD_CONF_SWD_FEED = 0x20000000
	// Position of SWD_DISABLE field.
	RTC_CNTL_SWD_CONF_SWD_DISABLE_Pos = 0x1e
	// Bit mask of SWD_DISABLE field.
	RTC_CNTL_SWD_CONF_SWD_DISABLE_Msk = 0x40000000
	// Bit SWD_DISABLE.
	RTC_CNTL_SWD_CONF_SWD_DISABLE = 0x40000000
	// Position of SWD_AUTO_FEED_EN field.
	RTC_CNTL_SWD_CONF_SWD_AUTO_FEED_EN_Pos = 0x1f
	// Bit mask of SWD_AUTO_FEED_EN field.
	RTC_CNTL_SWD_CONF_SWD_AUTO_FEED_EN_Msk = 0x80000000
	// Bit SWD_AUTO_FEED_EN.
	RTC_CNTL_SWD_CONF_SWD_AUTO_FEED_EN = 0x80000000

	// SWD_WPROTECT: Super watchdog write protection configuration register
	// Position of SWD_WKEY field.
	RTC_CNTL_SWD_WPROTECT_SWD_WKEY_Pos = 0x0
	// Bit mask of SWD_WKEY field.
	RTC_CNTL_SWD_WPROTECT_SWD_WKEY_Msk = 0xffffffff

	// SW_CPU_STALL: CPU stall configuration register
	// Position of SW_STALL_APPCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_APPCPU_C1_Pos = 0x14
	// Bit mask of SW_STALL_APPCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_APPCPU_C1_Msk = 0x3f00000
	// Position of SW_STALL_PROCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_PROCPU_C1_Pos = 0x1a
	// Bit mask of SW_STALL_PROCPU_C1 field.
	RTC_CNTL_SW_CPU_STALL_SW_STALL_PROCPU_C1_Msk = 0xfc000000

	// STORE4: Reservation register 4
	// Position of SCRATCH4 field.
	RTC_CNTL_STORE4_SCRATCH4_Pos = 0x0
	// Bit mask of SCRATCH4 field.
	RTC_CNTL_STORE4_SCRATCH4_Msk = 0xffffffff

	// STORE5: Reservation register 5
	// Position of SCRATCH5 field.
	RTC_CNTL_STORE5_SCRATCH5_Pos = 0x0
	// Bit mask of SCRATCH5 field.
	RTC_CNTL_STORE5_SCRATCH5_Msk = 0xffffffff

	// STORE6: Reservation register 6
	// Position of SCRATCH6 field.
	RTC_CNTL_STORE6_SCRATCH6_Pos = 0x0
	// Bit mask of SCRATCH6 field.
	RTC_CNTL_STORE6_SCRATCH6_Msk = 0xffffffff

	// STORE7: Reservation register 7
	// Position of SCRATCH7 field.
	RTC_CNTL_STORE7_SCRATCH7_Pos = 0x0
	// Bit mask of SCRATCH7 field.
	RTC_CNTL_STORE7_SCRATCH7_Msk = 0xffffffff

	// LOW_POWER_ST: RTC main state machine status register
	// Position of XPD_ROM0 field.
	RTC_CNTL_LOW_POWER_ST_XPD_ROM0_Pos = 0x0
	// Bit mask of XPD_ROM0 field.
	RTC_CNTL_LOW_POWER_ST_XPD_ROM0_Msk = 0x1
	// Bit XPD_ROM0.
	RTC_CNTL_LOW_POWER_ST_XPD_ROM0 = 0x1
	// Position of XPD_DIG_DCDC field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_DCDC_Pos = 0x2
	// Bit mask of XPD_DIG_DCDC field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_DCDC_Msk = 0x4
	// Bit XPD_DIG_DCDC.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_DCDC = 0x4
	// Position of PERI_ISO field.
	RTC_CNTL_LOW_POWER_ST_PERI_ISO_Pos = 0x3
	// Bit mask of PERI_ISO field.
	RTC_CNTL_LOW_POWER_ST_PERI_ISO_Msk = 0x8
	// Bit PERI_ISO.
	RTC_CNTL_LOW_POWER_ST_PERI_ISO = 0x8
	// Position of XPD_RTC_PERI field.
	RTC_CNTL_LOW_POWER_ST_XPD_RTC_PERI_Pos = 0x4
	// Bit mask of XPD_RTC_PERI field.
	RTC_CNTL_LOW_POWER_ST_XPD_RTC_PERI_Msk = 0x10
	// Bit XPD_RTC_PERI.
	RTC_CNTL_LOW_POWER_ST_XPD_RTC_PERI = 0x10
	// Position of WIFI_ISO field.
	RTC_CNTL_LOW_POWER_ST_WIFI_ISO_Pos = 0x5
	// Bit mask of WIFI_ISO field.
	RTC_CNTL_LOW_POWER_ST_WIFI_ISO_Msk = 0x20
	// Bit WIFI_ISO.
	RTC_CNTL_LOW_POWER_ST_WIFI_ISO = 0x20
	// Position of XPD_WIFI field.
	RTC_CNTL_LOW_POWER_ST_XPD_WIFI_Pos = 0x6
	// Bit mask of XPD_WIFI field.
	RTC_CNTL_LOW_POWER_ST_XPD_WIFI_Msk = 0x40
	// Bit XPD_WIFI.
	RTC_CNTL_LOW_POWER_ST_XPD_WIFI = 0x40
	// Position of DIG_ISO field.
	RTC_CNTL_LOW_POWER_ST_DIG_ISO_Pos = 0x7
	// Bit mask of DIG_ISO field.
	RTC_CNTL_LOW_POWER_ST_DIG_ISO_Msk = 0x80
	// Bit DIG_ISO.
	RTC_CNTL_LOW_POWER_ST_DIG_ISO = 0x80
	// Position of XPD_DIG field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_Pos = 0x8
	// Bit mask of XPD_DIG field.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG_Msk = 0x100
	// Bit XPD_DIG.
	RTC_CNTL_LOW_POWER_ST_XPD_DIG = 0x100
	// Position of TOUCH_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_START_Pos = 0x9
	// Bit mask of TOUCH_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_START_Msk = 0x200
	// Bit TOUCH_STATE_START.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_START = 0x200
	// Position of TOUCH_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SWITCH_Pos = 0xa
	// Bit mask of TOUCH_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SWITCH_Msk = 0x400
	// Bit TOUCH_STATE_SWITCH.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SWITCH = 0x400
	// Position of TOUCH_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SLP_Pos = 0xb
	// Bit mask of TOUCH_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SLP_Msk = 0x800
	// Bit TOUCH_STATE_SLP.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_SLP = 0x800
	// Position of TOUCH_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_DONE_Pos = 0xc
	// Bit mask of TOUCH_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_DONE_Msk = 0x1000
	// Bit TOUCH_STATE_DONE.
	RTC_CNTL_LOW_POWER_ST_TOUCH_STATE_DONE = 0x1000
	// Position of COCPU_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_START_Pos = 0xd
	// Bit mask of COCPU_STATE_START field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_START_Msk = 0x2000
	// Bit COCPU_STATE_START.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_START = 0x2000
	// Position of COCPU_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SWITCH_Pos = 0xe
	// Bit mask of COCPU_STATE_SWITCH field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SWITCH_Msk = 0x4000
	// Bit COCPU_STATE_SWITCH.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SWITCH = 0x4000
	// Position of COCPU_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SLP_Pos = 0xf
	// Bit mask of COCPU_STATE_SLP field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SLP_Msk = 0x8000
	// Bit COCPU_STATE_SLP.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_SLP = 0x8000
	// Position of COCPU_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_DONE_Pos = 0x10
	// Bit mask of COCPU_STATE_DONE field.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_DONE_Msk = 0x10000
	// Bit COCPU_STATE_DONE.
	RTC_CNTL_LOW_POWER_ST_COCPU_STATE_DONE = 0x10000
	// Position of MAIN_STATE_XTAL_ISO field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_XTAL_ISO_Pos = 0x11
	// Bit mask of MAIN_STATE_XTAL_ISO field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_XTAL_ISO_Msk = 0x20000
	// Bit MAIN_STATE_XTAL_ISO.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_XTAL_ISO = 0x20000
	// Position of MAIN_STATE_PLL_ON field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_PLL_ON_Pos = 0x12
	// Bit mask of MAIN_STATE_PLL_ON field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_PLL_ON_Msk = 0x40000
	// Bit MAIN_STATE_PLL_ON.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_PLL_ON = 0x40000
	// Position of RDY_FOR_WAKEUP field.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP_Pos = 0x13
	// Bit mask of RDY_FOR_WAKEUP field.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP_Msk = 0x80000
	// Bit RDY_FOR_WAKEUP.
	RTC_CNTL_LOW_POWER_ST_RDY_FOR_WAKEUP = 0x80000
	// Position of MAIN_STATE_WAIT_END field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_WAIT_END_Pos = 0x14
	// Bit mask of MAIN_STATE_WAIT_END field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_WAIT_END_Msk = 0x100000
	// Bit MAIN_STATE_WAIT_END.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_WAIT_END = 0x100000
	// Position of IN_WAKEUP_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_WAKEUP_STATE_Pos = 0x15
	// Bit mask of IN_WAKEUP_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_WAKEUP_STATE_Msk = 0x200000
	// Bit IN_WAKEUP_STATE.
	RTC_CNTL_LOW_POWER_ST_IN_WAKEUP_STATE = 0x200000
	// Position of IN_LOW_POWER_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_LOW_POWER_STATE_Pos = 0x16
	// Bit mask of IN_LOW_POWER_STATE field.
	RTC_CNTL_LOW_POWER_ST_IN_LOW_POWER_STATE_Msk = 0x400000
	// Bit IN_LOW_POWER_STATE.
	RTC_CNTL_LOW_POWER_ST_IN_LOW_POWER_STATE = 0x400000
	// Position of MAIN_STATE_IN_WAIT_8M field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_8M_Pos = 0x17
	// Bit mask of MAIN_STATE_IN_WAIT_8M field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_8M_Msk = 0x800000
	// Bit MAIN_STATE_IN_WAIT_8M.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_8M = 0x800000
	// Position of MAIN_STATE_IN_WAIT_PLL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL_Pos = 0x18
	// Bit mask of MAIN_STATE_IN_WAIT_PLL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL_Msk = 0x1000000
	// Bit MAIN_STATE_IN_WAIT_PLL.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_PLL = 0x1000000
	// Position of MAIN_STATE_IN_WAIT_XTL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL_Pos = 0x19
	// Bit mask of MAIN_STATE_IN_WAIT_XTL field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL_Msk = 0x2000000
	// Bit MAIN_STATE_IN_WAIT_XTL.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_WAIT_XTL = 0x2000000
	// Position of MAIN_STATE_IN_SLP field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_SLP_Pos = 0x1a
	// Bit mask of MAIN_STATE_IN_SLP field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_SLP_Msk = 0x4000000
	// Bit MAIN_STATE_IN_SLP.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_SLP = 0x4000000
	// Position of MAIN_STATE_IN_IDLE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_IDLE_Pos = 0x1b
	// Bit mask of MAIN_STATE_IN_IDLE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_IDLE_Msk = 0x8000000
	// Bit MAIN_STATE_IN_IDLE.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_IN_IDLE = 0x8000000
	// Position of MAIN_STATE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_Pos = 0x1c
	// Bit mask of MAIN_STATE field.
	RTC_CNTL_LOW_POWER_ST_MAIN_STATE_Msk = 0xf0000000

	// DIAG0: debug register
	// Position of LOW_POWER_DIAG1 field.
	RTC_CNTL_DIAG0_LOW_POWER_DIAG1_Pos = 0x0
	// Bit mask of LOW_POWER_DIAG1 field.
	RTC_CNTL_DIAG0_LOW_POWER_DIAG1_Msk = 0xffffffff

	// PAD_HOLD: Configures the hold options for RTC GPIOs
	// Position of TOUCH_PAD0_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD0_HOLD_Pos = 0x0
	// Bit mask of TOUCH_PAD0_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD0_HOLD_Msk = 0x1
	// Bit TOUCH_PAD0_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD0_HOLD = 0x1
	// Position of TOUCH_PAD1_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD1_HOLD_Pos = 0x1
	// Bit mask of TOUCH_PAD1_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD1_HOLD_Msk = 0x2
	// Bit TOUCH_PAD1_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD1_HOLD = 0x2
	// Position of TOUCH_PAD2_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD2_HOLD_Pos = 0x2
	// Bit mask of TOUCH_PAD2_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD2_HOLD_Msk = 0x4
	// Bit TOUCH_PAD2_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD2_HOLD = 0x4
	// Position of TOUCH_PAD3_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD3_HOLD_Pos = 0x3
	// Bit mask of TOUCH_PAD3_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD3_HOLD_Msk = 0x8
	// Bit TOUCH_PAD3_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD3_HOLD = 0x8
	// Position of TOUCH_PAD4_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD4_HOLD_Pos = 0x4
	// Bit mask of TOUCH_PAD4_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD4_HOLD_Msk = 0x10
	// Bit TOUCH_PAD4_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD4_HOLD = 0x10
	// Position of TOUCH_PAD5_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD5_HOLD_Pos = 0x5
	// Bit mask of TOUCH_PAD5_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD5_HOLD_Msk = 0x20
	// Bit TOUCH_PAD5_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD5_HOLD = 0x20
	// Position of TOUCH_PAD6_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD6_HOLD_Pos = 0x6
	// Bit mask of TOUCH_PAD6_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD6_HOLD_Msk = 0x40
	// Bit TOUCH_PAD6_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD6_HOLD = 0x40
	// Position of TOUCH_PAD7_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD7_HOLD_Pos = 0x7
	// Bit mask of TOUCH_PAD7_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD7_HOLD_Msk = 0x80
	// Bit TOUCH_PAD7_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD7_HOLD = 0x80
	// Position of TOUCH_PAD8_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD8_HOLD_Pos = 0x8
	// Bit mask of TOUCH_PAD8_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD8_HOLD_Msk = 0x100
	// Bit TOUCH_PAD8_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD8_HOLD = 0x100
	// Position of TOUCH_PAD9_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD9_HOLD_Pos = 0x9
	// Bit mask of TOUCH_PAD9_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD9_HOLD_Msk = 0x200
	// Bit TOUCH_PAD9_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD9_HOLD = 0x200
	// Position of TOUCH_PAD10_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD10_HOLD_Pos = 0xa
	// Bit mask of TOUCH_PAD10_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD10_HOLD_Msk = 0x400
	// Bit TOUCH_PAD10_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD10_HOLD = 0x400
	// Position of TOUCH_PAD11_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD11_HOLD_Pos = 0xb
	// Bit mask of TOUCH_PAD11_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD11_HOLD_Msk = 0x800
	// Bit TOUCH_PAD11_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD11_HOLD = 0x800
	// Position of TOUCH_PAD12_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD12_HOLD_Pos = 0xc
	// Bit mask of TOUCH_PAD12_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD12_HOLD_Msk = 0x1000
	// Bit TOUCH_PAD12_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD12_HOLD = 0x1000
	// Position of TOUCH_PAD13_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD13_HOLD_Pos = 0xd
	// Bit mask of TOUCH_PAD13_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD13_HOLD_Msk = 0x2000
	// Bit TOUCH_PAD13_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD13_HOLD = 0x2000
	// Position of TOUCH_PAD14_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD14_HOLD_Pos = 0xe
	// Bit mask of TOUCH_PAD14_HOLD field.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD14_HOLD_Msk = 0x4000
	// Bit TOUCH_PAD14_HOLD.
	RTC_CNTL_PAD_HOLD_TOUCH_PAD14_HOLD = 0x4000
	// Position of X32P_HOLD field.
	RTC_CNTL_PAD_HOLD_X32P_HOLD_Pos = 0xf
	// Bit mask of X32P_HOLD field.
	RTC_CNTL_PAD_HOLD_X32P_HOLD_Msk = 0x8000
	// Bit X32P_HOLD.
	RTC_CNTL_PAD_HOLD_X32P_HOLD = 0x8000
	// Position of X32N_HOLD field.
	RTC_CNTL_PAD_HOLD_X32N_HOLD_Pos = 0x10
	// Bit mask of X32N_HOLD field.
	RTC_CNTL_PAD_HOLD_X32N_HOLD_Msk = 0x10000
	// Bit X32N_HOLD.
	RTC_CNTL_PAD_HOLD_X32N_HOLD = 0x10000
	// Position of PDAC1_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC1_HOLD_Pos = 0x11
	// Bit mask of PDAC1_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC1_HOLD_Msk = 0x20000
	// Bit PDAC1_HOLD.
	RTC_CNTL_PAD_HOLD_PDAC1_HOLD = 0x20000
	// Position of PDAC2_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC2_HOLD_Pos = 0x12
	// Bit mask of PDAC2_HOLD field.
	RTC_CNTL_PAD_HOLD_PDAC2_HOLD_Msk = 0x40000
	// Bit PDAC2_HOLD.
	RTC_CNTL_PAD_HOLD_PDAC2_HOLD = 0x40000
	// Position of PAD19_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD19_HOLD_Pos = 0x13
	// Bit mask of PAD19_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD19_HOLD_Msk = 0x80000
	// Bit PAD19_HOLD.
	RTC_CNTL_PAD_HOLD_PAD19_HOLD = 0x80000
	// Position of PAD20_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD20_HOLD_Pos = 0x14
	// Bit mask of PAD20_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD20_HOLD_Msk = 0x100000
	// Bit PAD20_HOLD.
	RTC_CNTL_PAD_HOLD_PAD20_HOLD = 0x100000
	// Position of PAD21_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD21_HOLD_Pos = 0x15
	// Bit mask of PAD21_HOLD field.
	RTC_CNTL_PAD_HOLD_PAD21_HOLD_Msk = 0x200000
	// Bit PAD21_HOLD.
	RTC_CNTL_PAD_HOLD_PAD21_HOLD = 0x200000

	// DIG_PAD_HOLD: Configures the hold option for digital GPIOs
	// Position of DIG_PAD_HOLD field.
	RTC_CNTL_DIG_PAD_HOLD_DIG_PAD_HOLD_Pos = 0x0
	// Bit mask of DIG_PAD_HOLD field.
	RTC_CNTL_DIG_PAD_HOLD_DIG_PAD_HOLD_Msk = 0xffffffff

	// EXT_WAKEUP1: EXT1 wakeup configuration register
	// Position of SEL field.
	RTC_CNTL_EXT_WAKEUP1_SEL_Pos = 0x0
	// Bit mask of SEL field.
	RTC_CNTL_EXT_WAKEUP1_SEL_Msk = 0x3fffff
	// Position of STATUS_CLR field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_Pos = 0x16
	// Bit mask of STATUS_CLR field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_Msk = 0x400000
	// Bit STATUS_CLR.
	RTC_CNTL_EXT_WAKEUP1_STATUS_CLR = 0x400000

	// EXT_WAKEUP1_STATUS: EXT1 wakeup source register
	// Position of EXT_WAKEUP1_STATUS field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_EXT_WAKEUP1_STATUS_Pos = 0x0
	// Bit mask of EXT_WAKEUP1_STATUS field.
	RTC_CNTL_EXT_WAKEUP1_STATUS_EXT_WAKEUP1_STATUS_Msk = 0x3fffff

	// BROWN_OUT: Brownout configuration register
	// Position of BROWN_OUT2_ENA field.
	RTC_CNTL_BROWN_OUT_BROWN_OUT2_ENA_Pos = 0x0
	// Bit mask of BROWN_OUT2_ENA field.
	RTC_CNTL_BROWN_OUT_BROWN_OUT2_ENA_Msk = 0x1
	// Bit BROWN_OUT2_ENA.
	RTC_CNTL_BROWN_OUT_BROWN_OUT2_ENA = 0x1
	// Position of INT_WAIT field.
	RTC_CNTL_BROWN_OUT_INT_WAIT_Pos = 0x4
	// Bit mask of INT_WAIT field.
	RTC_CNTL_BROWN_OUT_INT_WAIT_Msk = 0x3ff0
	// Position of CLOSE_FLASH_ENA field.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_Pos = 0xe
	// Bit mask of CLOSE_FLASH_ENA field.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_Msk = 0x4000
	// Bit CLOSE_FLASH_ENA.
	RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA = 0x4000
	// Position of PD_RF_ENA field.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA_Pos = 0xf
	// Bit mask of PD_RF_ENA field.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA_Msk = 0x8000
	// Bit PD_RF_ENA.
	RTC_CNTL_BROWN_OUT_PD_RF_ENA = 0x8000
	// Position of RST_WAIT field.
	RTC_CNTL_BROWN_OUT_RST_WAIT_Pos = 0x10
	// Bit mask of RST_WAIT field.
	RTC_CNTL_BROWN_OUT_RST_WAIT_Msk = 0x3ff0000
	// Position of RST_ENA field.
	RTC_CNTL_BROWN_OUT_RST_ENA_Pos = 0x1a
	// Bit mask of RST_ENA field.
	RTC_CNTL_BROWN_OUT_RST_ENA_Msk = 0x4000000
	// Bit RST_ENA.
	RTC_CNTL_BROWN_OUT_RST_ENA = 0x4000000
	// Position of RST_SEL field.
	RTC_CNTL_BROWN_OUT_RST_SEL_Pos = 0x1b
	// Bit mask of RST_SEL field.
	RTC_CNTL_BROWN_OUT_RST_SEL_Msk = 0x8000000
	// Bit RST_SEL.
	RTC_CNTL_BROWN_OUT_RST_SEL = 0x8000000
	// Position of CNT_CLR field.
	RTC_CNTL_BROWN_OUT_CNT_CLR_Pos = 0x1d
	// Bit mask of CNT_CLR field.
	RTC_CNTL_BROWN_OUT_CNT_CLR_Msk = 0x20000000
	// Bit CNT_CLR.
	RTC_CNTL_BROWN_OUT_CNT_CLR = 0x20000000
	// Position of ENA field.
	RTC_CNTL_BROWN_OUT_ENA_Pos = 0x1e
	// Bit mask of ENA field.
	RTC_CNTL_BROWN_OUT_ENA_Msk = 0x40000000
	// Bit ENA.
	RTC_CNTL_BROWN_OUT_ENA = 0x40000000
	// Position of DET field.
	RTC_CNTL_BROWN_OUT_DET_Pos = 0x1f
	// Bit mask of DET field.
	RTC_CNTL_BROWN_OUT_DET_Msk = 0x80000000
	// Bit DET.
	RTC_CNTL_BROWN_OUT_DET = 0x80000000

	// TIME_LOW1: Stores the lower 32 bits of RTC timer 1
	// Position of TIMER_VALUE1_LOW field.
	RTC_CNTL_TIME_LOW1_TIMER_VALUE1_LOW_Pos = 0x0
	// Bit mask of TIMER_VALUE1_LOW field.
	RTC_CNTL_TIME_LOW1_TIMER_VALUE1_LOW_Msk = 0xffffffff

	// TIME_HIGH1: Stores the higher 16 bits of RTC timer 1
	// Position of TIMER_VALUE1_HIGH field.
	RTC_CNTL_TIME_HIGH1_TIMER_VALUE1_HIGH_Pos = 0x0
	// Bit mask of TIMER_VALUE1_HIGH field.
	RTC_CNTL_TIME_HIGH1_TIMER_VALUE1_HIGH_Msk = 0xffff

	// XTAL32K_CLK_FACTOR: Configures the divider factor for the backup clock of 32 kHz crystal oscillator
	// Position of XTAL32K_CLK_FACTOR field.
	RTC_CNTL_XTAL32K_CLK_FACTOR_XTAL32K_CLK_FACTOR_Pos = 0x0
	// Bit mask of XTAL32K_CLK_FACTOR field.
	RTC_CNTL_XTAL32K_CLK_FACTOR_XTAL32K_CLK_FACTOR_Msk = 0xffffffff

	// XTAL32K_CONF: 32 kHz crystal oscillator configuration register
	// Position of XTAL32K_RETURN_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RETURN_WAIT_Pos = 0x0
	// Bit mask of XTAL32K_RETURN_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RETURN_WAIT_Msk = 0xf
	// Position of XTAL32K_RESTART_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RESTART_WAIT_Pos = 0x4
	// Bit mask of XTAL32K_RESTART_WAIT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_RESTART_WAIT_Msk = 0xffff0
	// Position of XTAL32K_WDT_TIMEOUT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_WDT_TIMEOUT_Pos = 0x14
	// Bit mask of XTAL32K_WDT_TIMEOUT field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_WDT_TIMEOUT_Msk = 0xff00000
	// Position of XTAL32K_STABLE_THRES field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_STABLE_THRES_Pos = 0x1c
	// Bit mask of XTAL32K_STABLE_THRES field.
	RTC_CNTL_XTAL32K_CONF_XTAL32K_STABLE_THRES_Msk = 0xf0000000

	// ULP_CP_TIMER: Configure coprocessor timer
	// Position of ULP_CP_PC_INIT field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_PC_INIT_Pos = 0x0
	// Bit mask of ULP_CP_PC_INIT field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_PC_INIT_Msk = 0x7ff
	// Position of ULP_CP_GPIO_WAKEUP_ENA field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA_Pos = 0x1d
	// Bit mask of ULP_CP_GPIO_WAKEUP_ENA field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA_Msk = 0x20000000
	// Bit ULP_CP_GPIO_WAKEUP_ENA.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_ENA = 0x20000000
	// Position of ULP_CP_GPIO_WAKEUP_CLR field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR_Pos = 0x1e
	// Bit mask of ULP_CP_GPIO_WAKEUP_CLR field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR_Msk = 0x40000000
	// Bit ULP_CP_GPIO_WAKEUP_CLR.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_GPIO_WAKEUP_CLR = 0x40000000
	// Position of ULP_CP_SLP_TIMER_EN field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_SLP_TIMER_EN_Pos = 0x1f
	// Bit mask of ULP_CP_SLP_TIMER_EN field.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_SLP_TIMER_EN_Msk = 0x80000000
	// Bit ULP_CP_SLP_TIMER_EN.
	RTC_CNTL_ULP_CP_TIMER_ULP_CP_SLP_TIMER_EN = 0x80000000

	// ULP_CP_CTRL: ULP-FSM configuration register
	// Position of ULP_CP_MEM_ADDR_INIT field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT_Pos = 0x0
	// Bit mask of ULP_CP_MEM_ADDR_INIT field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_INIT_Msk = 0x7ff
	// Position of ULP_CP_MEM_ADDR_SIZE field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE_Pos = 0xb
	// Bit mask of ULP_CP_MEM_ADDR_SIZE field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_ADDR_SIZE_Msk = 0x3ff800
	// Position of ULP_CP_MEM_OFFSET_CLR field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR_Pos = 0x16
	// Bit mask of ULP_CP_MEM_OFFSET_CLR field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR_Msk = 0x400000
	// Bit ULP_CP_MEM_OFFSET_CLR.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_MEM_OFFSET_CLR = 0x400000
	// Position of ULP_CP_CLK_FO field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_CLK_FO_Pos = 0x1c
	// Bit mask of ULP_CP_CLK_FO field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_CLK_FO_Msk = 0x10000000
	// Bit ULP_CP_CLK_FO.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_CLK_FO = 0x10000000
	// Position of ULP_CP_RESET field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_RESET_Pos = 0x1d
	// Bit mask of ULP_CP_RESET field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_RESET_Msk = 0x20000000
	// Bit ULP_CP_RESET.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_RESET = 0x20000000
	// Position of ULP_CP_FORCE_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_FORCE_START_TOP_Pos = 0x1e
	// Bit mask of ULP_CP_FORCE_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_FORCE_START_TOP_Msk = 0x40000000
	// Bit ULP_CP_FORCE_START_TOP.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_FORCE_START_TOP = 0x40000000
	// Position of ULP_CP_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_START_TOP_Pos = 0x1f
	// Bit mask of ULP_CP_START_TOP field.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_START_TOP_Msk = 0x80000000
	// Bit ULP_CP_START_TOP.
	RTC_CNTL_ULP_CP_CTRL_ULP_CP_START_TOP = 0x80000000

	// COCPU_CTRL: ULP-RISCV configuration register
	// Position of COCPU_CLK_FO field.
	RTC_CNTL_COCPU_CTRL_COCPU_CLK_FO_Pos = 0x0
	// Bit mask of COCPU_CLK_FO field.
	RTC_CNTL_COCPU_CTRL_COCPU_CLK_FO_Msk = 0x1
	// Bit COCPU_CLK_FO.
	RTC_CNTL_COCPU_CTRL_COCPU_CLK_FO = 0x1
	// Position of COCPU_START_2_RESET_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_RESET_DIS_Pos = 0x1
	// Bit mask of COCPU_START_2_RESET_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_RESET_DIS_Msk = 0x7e
	// Position of COCPU_START_2_INTR_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_INTR_EN_Pos = 0x7
	// Bit mask of COCPU_START_2_INTR_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_START_2_INTR_EN_Msk = 0x1f80
	// Position of COCPU_SHUT field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_Pos = 0xd
	// Bit mask of COCPU_SHUT field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_Msk = 0x2000
	// Bit COCPU_SHUT.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT = 0x2000
	// Position of COCPU_SHUT_2_CLK_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_2_CLK_DIS_Pos = 0xe
	// Bit mask of COCPU_SHUT_2_CLK_DIS field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_2_CLK_DIS_Msk = 0x3fc000
	// Position of COCPU_SHUT_RESET_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_RESET_EN_Pos = 0x16
	// Bit mask of COCPU_SHUT_RESET_EN field.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_RESET_EN_Msk = 0x400000
	// Bit COCPU_SHUT_RESET_EN.
	RTC_CNTL_COCPU_CTRL_COCPU_SHUT_RESET_EN = 0x400000
	// Position of COCPU_SEL field.
	RTC_CNTL_COCPU_CTRL_COCPU_SEL_Pos = 0x17
	// Bit mask of COCPU_SEL field.
	RTC_CNTL_COCPU_CTRL_COCPU_SEL_Msk = 0x800000
	// Bit COCPU_SEL.
	RTC_CNTL_COCPU_CTRL_COCPU_SEL = 0x800000
	// Position of COCPU_DONE_FORCE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_FORCE_Pos = 0x18
	// Bit mask of COCPU_DONE_FORCE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_FORCE_Msk = 0x1000000
	// Bit COCPU_DONE_FORCE.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_FORCE = 0x1000000
	// Position of COCPU_DONE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_Pos = 0x19
	// Bit mask of COCPU_DONE field.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE_Msk = 0x2000000
	// Bit COCPU_DONE.
	RTC_CNTL_COCPU_CTRL_COCPU_DONE = 0x2000000
	// Position of COCPU_SW_INT_TRIGGER field.
	RTC_CNTL_COCPU_CTRL_COCPU_SW_INT_TRIGGER_Pos = 0x1a
	// Bit mask of COCPU_SW_INT_TRIGGER field.
	RTC_CNTL_COCPU_CTRL_COCPU_SW_INT_TRIGGER_Msk = 0x4000000
	// Bit COCPU_SW_INT_TRIGGER.
	RTC_CNTL_COCPU_CTRL_COCPU_SW_INT_TRIGGER = 0x4000000

	// TOUCH_CTRL1: Touch control register
	// Position of TOUCH_SLEEP_CYCLES field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_SLEEP_CYCLES_Pos = 0x0
	// Bit mask of TOUCH_SLEEP_CYCLES field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_SLEEP_CYCLES_Msk = 0xffff
	// Position of TOUCH_MEAS_NUM field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_MEAS_NUM_Pos = 0x10
	// Bit mask of TOUCH_MEAS_NUM field.
	RTC_CNTL_TOUCH_CTRL1_TOUCH_MEAS_NUM_Msk = 0xffff0000

	// TOUCH_CTRL2: Touch control register
	// Position of TOUCH_DRANGE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DRANGE_Pos = 0x2
	// Bit mask of TOUCH_DRANGE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DRANGE_Msk = 0xc
	// Position of TOUCH_DREFL field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFL_Pos = 0x4
	// Bit mask of TOUCH_DREFL field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFL_Msk = 0x30
	// Position of TOUCH_DREFH field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFH_Pos = 0x6
	// Bit mask of TOUCH_DREFH field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DREFH_Msk = 0xc0
	// Position of TOUCH_XPD_BIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_BIAS_Pos = 0x8
	// Bit mask of TOUCH_XPD_BIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_BIAS_Msk = 0x100
	// Bit TOUCH_XPD_BIAS.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_BIAS = 0x100
	// Position of TOUCH_REFC field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_REFC_Pos = 0x9
	// Bit mask of TOUCH_REFC field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_REFC_Msk = 0xe00
	// Position of TOUCH_DBIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DBIAS_Pos = 0xc
	// Bit mask of TOUCH_DBIAS field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DBIAS_Msk = 0x1000
	// Bit TOUCH_DBIAS.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_DBIAS = 0x1000
	// Position of TOUCH_SLP_TIMER_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_TIMER_EN_Pos = 0xd
	// Bit mask of TOUCH_SLP_TIMER_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_TIMER_EN_Msk = 0x2000
	// Bit TOUCH_SLP_TIMER_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_TIMER_EN = 0x2000
	// Position of TOUCH_START_FSM_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FSM_EN_Pos = 0xe
	// Bit mask of TOUCH_START_FSM_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FSM_EN_Msk = 0x4000
	// Bit TOUCH_START_FSM_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FSM_EN = 0x4000
	// Position of TOUCH_START_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_EN_Pos = 0xf
	// Bit mask of TOUCH_START_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_EN_Msk = 0x8000
	// Bit TOUCH_START_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_EN = 0x8000
	// Position of TOUCH_START_FORCE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FORCE_Pos = 0x10
	// Bit mask of TOUCH_START_FORCE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FORCE_Msk = 0x10000
	// Bit TOUCH_START_FORCE.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_START_FORCE = 0x10000
	// Position of TOUCH_XPD_WAIT field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_WAIT_Pos = 0x11
	// Bit mask of TOUCH_XPD_WAIT field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_XPD_WAIT_Msk = 0x1fe0000
	// Position of TOUCH_SLP_CYC_DIV field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_CYC_DIV_Pos = 0x19
	// Bit mask of TOUCH_SLP_CYC_DIV field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_SLP_CYC_DIV_Msk = 0x6000000
	// Position of TOUCH_TIMER_FORCE_DONE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE_Pos = 0x1b
	// Bit mask of TOUCH_TIMER_FORCE_DONE field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_TIMER_FORCE_DONE_Msk = 0x18000000
	// Position of TOUCH_RESET field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_RESET_Pos = 0x1d
	// Bit mask of TOUCH_RESET field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_RESET_Msk = 0x20000000
	// Bit TOUCH_RESET.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_RESET = 0x20000000
	// Position of TOUCH_CLK_FO field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLK_FO_Pos = 0x1e
	// Bit mask of TOUCH_CLK_FO field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLK_FO_Msk = 0x40000000
	// Bit TOUCH_CLK_FO.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLK_FO = 0x40000000
	// Position of TOUCH_CLKGATE_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLKGATE_EN_Pos = 0x1f
	// Bit mask of TOUCH_CLKGATE_EN field.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLKGATE_EN_Msk = 0x80000000
	// Bit TOUCH_CLKGATE_EN.
	RTC_CNTL_TOUCH_CTRL2_TOUCH_CLKGATE_EN = 0x80000000

	// TOUCH_SCAN_CTRL: Configure touch scan settings
	// Position of TOUCH_DENOISE_RES field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_RES_Pos = 0x0
	// Bit mask of TOUCH_DENOISE_RES field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_RES_Msk = 0x3
	// Position of TOUCH_DENOISE_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_EN_Pos = 0x2
	// Bit mask of TOUCH_DENOISE_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_EN_Msk = 0x4
	// Bit TOUCH_DENOISE_EN.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_DENOISE_EN = 0x4
	// Position of TOUCH_INACTIVE_CONNECTION field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION_Pos = 0x8
	// Bit mask of TOUCH_INACTIVE_CONNECTION field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION_Msk = 0x100
	// Bit TOUCH_INACTIVE_CONNECTION.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_INACTIVE_CONNECTION = 0x100
	// Position of TOUCH_SHIELD_PAD_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN_Pos = 0x9
	// Bit mask of TOUCH_SHIELD_PAD_EN field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN_Msk = 0x200
	// Bit TOUCH_SHIELD_PAD_EN.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SHIELD_PAD_EN = 0x200
	// Position of TOUCH_SCAN_PAD_MAP field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP_Pos = 0xa
	// Bit mask of TOUCH_SCAN_PAD_MAP field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_SCAN_PAD_MAP_Msk = 0x1fffc00
	// Position of TOUCH_BUFDRV field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_BUFDRV_Pos = 0x19
	// Bit mask of TOUCH_BUFDRV field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_BUFDRV_Msk = 0xe000000
	// Position of TOUCH_OUT_RING field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_OUT_RING_Pos = 0x1c
	// Bit mask of TOUCH_OUT_RING field.
	RTC_CNTL_TOUCH_SCAN_CTRL_TOUCH_OUT_RING_Msk = 0xf0000000

	// TOUCH_SLP_THRES: Configure the settings of touch sleep pad
	// Position of TOUCH_SLP_TH field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_TH_Pos = 0x0
	// Bit mask of TOUCH_SLP_TH field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_TH_Msk = 0x3fffff
	// Position of TOUCH_SLP_APPROACH_EN field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN_Pos = 0x1a
	// Bit mask of TOUCH_SLP_APPROACH_EN field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN_Msk = 0x4000000
	// Bit TOUCH_SLP_APPROACH_EN.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_APPROACH_EN = 0x4000000
	// Position of TOUCH_SLP_PAD field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_PAD_Pos = 0x1b
	// Bit mask of TOUCH_SLP_PAD field.
	RTC_CNTL_TOUCH_SLP_THRES_TOUCH_SLP_PAD_Msk = 0xf8000000

	// TOUCH_APPROACH: Configure touch approach settings
	// Position of TOUCH_SLP_CHANNEL_CLR field.
	RTC_CNTL_TOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR_Pos = 0x17
	// Bit mask of TOUCH_SLP_CHANNEL_CLR field.
	RTC_CNTL_TOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR_Msk = 0x800000
	// Bit TOUCH_SLP_CHANNEL_CLR.
	RTC_CNTL_TOUCH_APPROACH_TOUCH_SLP_CHANNEL_CLR = 0x800000
	// Position of MEAS_TIME field.
	RTC_CNTL_TOUCH_APPROACH_MEAS_TIME_Pos = 0x18
	// Bit mask of MEAS_TIME field.
	RTC_CNTL_TOUCH_APPROACH_MEAS_TIME_Msk = 0xff000000

	// TOUCH_FILTER_CTRL: Configure touch filter settings
	// Position of TOUCH_SMOOTH_LVL field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL_Pos = 0x9
	// Bit mask of TOUCH_SMOOTH_LVL field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_SMOOTH_LVL_Msk = 0x600
	// Position of TOUCH_JITTER_STEP field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_JITTER_STEP_Pos = 0xb
	// Bit mask of TOUCH_JITTER_STEP field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_JITTER_STEP_Msk = 0x7800
	// Position of TOUCH_NEG_NOISE_LIMIT field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT_Pos = 0xf
	// Bit mask of TOUCH_NEG_NOISE_LIMIT field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_LIMIT_Msk = 0x78000
	// Position of TOUCH_NEG_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES_Pos = 0x13
	// Bit mask of TOUCH_NEG_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NEG_NOISE_THRES_Msk = 0x180000
	// Position of TOUCH_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NOISE_THRES_Pos = 0x15
	// Bit mask of TOUCH_NOISE_THRES field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_NOISE_THRES_Msk = 0x600000
	// Position of TOUCH_HYSTERESIS field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_HYSTERESIS_Pos = 0x17
	// Bit mask of TOUCH_HYSTERESIS field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_HYSTERESIS_Msk = 0x1800000
	// Position of TOUCH_DEBOUNCE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_DEBOUNCE_Pos = 0x19
	// Bit mask of TOUCH_DEBOUNCE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_DEBOUNCE_Msk = 0xe000000
	// Position of TOUCH_FILTER_MODE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_MODE_Pos = 0x1c
	// Bit mask of TOUCH_FILTER_MODE field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_MODE_Msk = 0x70000000
	// Position of TOUCH_FILTER_EN field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_EN_Pos = 0x1f
	// Bit mask of TOUCH_FILTER_EN field.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_EN_Msk = 0x80000000
	// Bit TOUCH_FILTER_EN.
	RTC_CNTL_TOUCH_FILTER_CTRL_TOUCH_FILTER_EN = 0x80000000

	// USB_CONF: configure usb control register
	// Position of USB_VREFH field.
	RTC_CNTL_USB_CONF_USB_VREFH_Pos = 0x0
	// Bit mask of USB_VREFH field.
	RTC_CNTL_USB_CONF_USB_VREFH_Msk = 0x3
	// Position of USB_VREFL field.
	RTC_CNTL_USB_CONF_USB_VREFL_Pos = 0x2
	// Bit mask of USB_VREFL field.
	RTC_CNTL_USB_CONF_USB_VREFL_Msk = 0xc
	// Position of USB_VREF_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_VREF_OVERRIDE_Pos = 0x4
	// Bit mask of USB_VREF_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_VREF_OVERRIDE_Msk = 0x10
	// Bit USB_VREF_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_VREF_OVERRIDE = 0x10
	// Position of USB_PAD_PULL_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_PULL_OVERRIDE_Pos = 0x5
	// Bit mask of USB_PAD_PULL_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_PULL_OVERRIDE_Msk = 0x20
	// Bit USB_PAD_PULL_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_PAD_PULL_OVERRIDE = 0x20
	// Position of USB_DP_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DP_PULLUP_Pos = 0x6
	// Bit mask of USB_DP_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DP_PULLUP_Msk = 0x40
	// Bit USB_DP_PULLUP.
	RTC_CNTL_USB_CONF_USB_DP_PULLUP = 0x40
	// Position of USB_DP_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DP_PULLDOWN_Pos = 0x7
	// Bit mask of USB_DP_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DP_PULLDOWN_Msk = 0x80
	// Bit USB_DP_PULLDOWN.
	RTC_CNTL_USB_CONF_USB_DP_PULLDOWN = 0x80
	// Position of USB_DM_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DM_PULLUP_Pos = 0x8
	// Bit mask of USB_DM_PULLUP field.
	RTC_CNTL_USB_CONF_USB_DM_PULLUP_Msk = 0x100
	// Bit USB_DM_PULLUP.
	RTC_CNTL_USB_CONF_USB_DM_PULLUP = 0x100
	// Position of USB_DM_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DM_PULLDOWN_Pos = 0x9
	// Bit mask of USB_DM_PULLDOWN field.
	RTC_CNTL_USB_CONF_USB_DM_PULLDOWN_Msk = 0x200
	// Bit USB_DM_PULLDOWN.
	RTC_CNTL_USB_CONF_USB_DM_PULLDOWN = 0x200
	// Position of USB_PULLUP_VALUE field.
	RTC_CNTL_USB_CONF_USB_PULLUP_VALUE_Pos = 0xa
	// Bit mask of USB_PULLUP_VALUE field.
	RTC_CNTL_USB_CONF_USB_PULLUP_VALUE_Msk = 0x400
	// Bit USB_PULLUP_VALUE.
	RTC_CNTL_USB_CONF_USB_PULLUP_VALUE = 0x400
	// Position of USB_PAD_ENABLE_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_OVERRIDE_Pos = 0xb
	// Bit mask of USB_PAD_ENABLE_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_OVERRIDE_Msk = 0x800
	// Bit USB_PAD_ENABLE_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_OVERRIDE = 0x800
	// Position of USB_PAD_ENABLE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_Pos = 0xc
	// Bit mask of USB_PAD_ENABLE field.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE_Msk = 0x1000
	// Bit USB_PAD_ENABLE.
	RTC_CNTL_USB_CONF_USB_PAD_ENABLE = 0x1000
	// Position of USB_TXM field.
	RTC_CNTL_USB_CONF_USB_TXM_Pos = 0xd
	// Bit mask of USB_TXM field.
	RTC_CNTL_USB_CONF_USB_TXM_Msk = 0x2000
	// Bit USB_TXM.
	RTC_CNTL_USB_CONF_USB_TXM = 0x2000
	// Position of USB_TXP field.
	RTC_CNTL_USB_CONF_USB_TXP_Pos = 0xe
	// Bit mask of USB_TXP field.
	RTC_CNTL_USB_CONF_USB_TXP_Msk = 0x4000
	// Bit USB_TXP.
	RTC_CNTL_USB_CONF_USB_TXP = 0x4000
	// Position of USB_TX_EN field.
	RTC_CNTL_USB_CONF_USB_TX_EN_Pos = 0xf
	// Bit mask of USB_TX_EN field.
	RTC_CNTL_USB_CONF_USB_TX_EN_Msk = 0x8000
	// Bit USB_TX_EN.
	RTC_CNTL_USB_CONF_USB_TX_EN = 0x8000
	// Position of USB_TX_EN_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_TX_EN_OVERRIDE_Pos = 0x10
	// Bit mask of USB_TX_EN_OVERRIDE field.
	RTC_CNTL_USB_CONF_USB_TX_EN_OVERRIDE_Msk = 0x10000
	// Bit USB_TX_EN_OVERRIDE.
	RTC_CNTL_USB_CONF_USB_TX_EN_OVERRIDE = 0x10000
	// Position of USB_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_USB_RESET_DISABLE_Pos = 0x11
	// Bit mask of USB_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_USB_RESET_DISABLE_Msk = 0x20000
	// Bit USB_RESET_DISABLE.
	RTC_CNTL_USB_CONF_USB_RESET_DISABLE = 0x20000
	// Position of IO_MUX_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_IO_MUX_RESET_DISABLE_Pos = 0x12
	// Bit mask of IO_MUX_RESET_DISABLE field.
	RTC_CNTL_USB_CONF_IO_MUX_RESET_DISABLE_Msk = 0x40000
	// Bit IO_MUX_RESET_DISABLE.
	RTC_CNTL_USB_CONF_IO_MUX_RESET_DISABLE = 0x40000

	// TOUCH_TIMEOUT_CTRL: Configure touch timeout settings
	// Position of TOUCH_TIMEOUT_NUM field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM_Pos = 0x0
	// Bit mask of TOUCH_TIMEOUT_NUM field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_NUM_Msk = 0x3fffff
	// Position of TOUCH_TIMEOUT_EN field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN_Pos = 0x16
	// Bit mask of TOUCH_TIMEOUT_EN field.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN_Msk = 0x400000
	// Bit TOUCH_TIMEOUT_EN.
	RTC_CNTL_TOUCH_TIMEOUT_CTRL_TOUCH_TIMEOUT_EN = 0x400000

	// SLP_REJECT_CAUSE: Stores the reject-to-sleep cause.
	// Position of REJECT_CAUSE field.
	RTC_CNTL_SLP_REJECT_CAUSE_REJECT_CAUSE_Pos = 0x0
	// Bit mask of REJECT_CAUSE field.
	RTC_CNTL_SLP_REJECT_CAUSE_REJECT_CAUSE_Msk = 0x1ffff

	// OPTIONS1: RTC option register
	// Position of FORCE_DOWNLOAD_BOOT field.
	RTC_CNTL_OPTIONS1_FORCE_DOWNLOAD_BOOT_Pos = 0x0
	// Bit mask of FORCE_DOWNLOAD_BOOT field.
	RTC_CNTL_OPTIONS1_FORCE_DOWNLOAD_BOOT_Msk = 0x1
	// Bit FORCE_DOWNLOAD_BOOT.
	RTC_CNTL_OPTIONS1_FORCE_DOWNLOAD_BOOT = 0x1

	// SLP_WAKEUP_CAUSE: Stores the sleep-to-wakeup cause.
	// Position of WAKEUP_CAUSE field.
	RTC_CNTL_SLP_WAKEUP_CAUSE_WAKEUP_CAUSE_Pos = 0x0
	// Bit mask of WAKEUP_CAUSE field.
	RTC_CNTL_SLP_WAKEUP_CAUSE_WAKEUP_CAUSE_Msk = 0x1ffff

	// ULP_CP_TIMER_1: Configure sleep cycle of the timer
	// Position of ULP_CP_TIMER_SLP_CYCLE field.
	RTC_CNTL_ULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE_Pos = 0x8
	// Bit mask of ULP_CP_TIMER_SLP_CYCLE field.
	RTC_CNTL_ULP_CP_TIMER_1_ULP_CP_TIMER_SLP_CYCLE_Msk = 0xffffff00

	// DATE
	// Position of CNTL_DATE field.
	RTC_CNTL_DATE_CNTL_DATE_Pos = 0x0
	// Bit mask of CNTL_DATE field.
	RTC_CNTL_DATE_CNTL_DATE_Msk = 0xfffffff
)

// Constants for RTC_I2C: Low-power I2C (Inter-Integrated Circuit) Controller
const (
	// SCL_LOW: Configure the low level width of SCL
	// Position of PERIOD field.
	RTC_I2C_SCL_LOW_PERIOD_Pos = 0x0
	// Bit mask of PERIOD field.
	RTC_I2C_SCL_LOW_PERIOD_Msk = 0xfffff

	// CTRL: Transmission setting
	// Position of SDA_FORCE_OUT field.
	RTC_I2C_CTRL_SDA_FORCE_OUT_Pos = 0x0
	// Bit mask of SDA_FORCE_OUT field.
	RTC_I2C_CTRL_SDA_FORCE_OUT_Msk = 0x1
	// Bit SDA_FORCE_OUT.
	RTC_I2C_CTRL_SDA_FORCE_OUT = 0x1
	// Position of SCL_FORCE_OUT field.
	RTC_I2C_CTRL_SCL_FORCE_OUT_Pos = 0x1
	// Bit mask of SCL_FORCE_OUT field.
	RTC_I2C_CTRL_SCL_FORCE_OUT_Msk = 0x2
	// Bit SCL_FORCE_OUT.
	RTC_I2C_CTRL_SCL_FORCE_OUT = 0x2
	// Position of MS_MODE field.
	RTC_I2C_CTRL_MS_MODE_Pos = 0x2
	// Bit mask of MS_MODE field.
	RTC_I2C_CTRL_MS_MODE_Msk = 0x4
	// Bit MS_MODE.
	RTC_I2C_CTRL_MS_MODE = 0x4
	// Position of TRANS_START field.
	RTC_I2C_CTRL_TRANS_START_Pos = 0x3
	// Bit mask of TRANS_START field.
	RTC_I2C_CTRL_TRANS_START_Msk = 0x8
	// Bit TRANS_START.
	RTC_I2C_CTRL_TRANS_START = 0x8
	// Position of TX_LSB_FIRST field.
	RTC_I2C_CTRL_TX_LSB_FIRST_Pos = 0x4
	// Bit mask of TX_LSB_FIRST field.
	RTC_I2C_CTRL_TX_LSB_FIRST_Msk = 0x10
	// Bit TX_LSB_FIRST.
	RTC_I2C_CTRL_TX_LSB_FIRST = 0x10
	// Position of RX_LSB_FIRST field.
	RTC_I2C_CTRL_RX_LSB_FIRST_Pos = 0x5
	// Bit mask of RX_LSB_FIRST field.
	RTC_I2C_CTRL_RX_LSB_FIRST_Msk = 0x20
	// Bit RX_LSB_FIRST.
	RTC_I2C_CTRL_RX_LSB_FIRST = 0x20
	// Position of CLK_GATE_EN field.
	RTC_I2C_CTRL_CLK_GATE_EN_Pos = 0x1d
	// Bit mask of CLK_GATE_EN field.
	RTC_I2C_CTRL_CLK_GATE_EN_Msk = 0x20000000
	// Bit CLK_GATE_EN.
	RTC_I2C_CTRL_CLK_GATE_EN = 0x20000000
	// Position of RESET field.
	RTC_I2C_CTRL_RESET_Pos = 0x1e
	// Bit mask of RESET field.
	RTC_I2C_CTRL_RESET_Msk = 0x40000000
	// Bit RESET.
	RTC_I2C_CTRL_RESET = 0x40000000
	// Position of CLK_EN field.
	RTC_I2C_CTRL_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	RTC_I2C_CTRL_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	RTC_I2C_CTRL_CLK_EN = 0x80000000

	// STATUS: RTC I2C status
	// Position of ACK_REC field.
	RTC_I2C_STATUS_ACK_REC_Pos = 0x0
	// Bit mask of ACK_REC field.
	RTC_I2C_STATUS_ACK_REC_Msk = 0x1
	// Bit ACK_REC.
	RTC_I2C_STATUS_ACK_REC = 0x1
	// Position of SLAVE_RW field.
	RTC_I2C_STATUS_SLAVE_RW_Pos = 0x1
	// Bit mask of SLAVE_RW field.
	RTC_I2C_STATUS_SLAVE_RW_Msk = 0x2
	// Bit SLAVE_RW.
	RTC_I2C_STATUS_SLAVE_RW = 0x2
	// Position of ARB_LOST field.
	RTC_I2C_STATUS_ARB_LOST_Pos = 0x2
	// Bit mask of ARB_LOST field.
	RTC_I2C_STATUS_ARB_LOST_Msk = 0x4
	// Bit ARB_LOST.
	RTC_I2C_STATUS_ARB_LOST = 0x4
	// Position of BUS_BUSY field.
	RTC_I2C_STATUS_BUS_BUSY_Pos = 0x3
	// Bit mask of BUS_BUSY field.
	RTC_I2C_STATUS_BUS_BUSY_Msk = 0x8
	// Bit BUS_BUSY.
	RTC_I2C_STATUS_BUS_BUSY = 0x8
	// Position of SLAVE_ADDRESSED field.
	RTC_I2C_STATUS_SLAVE_ADDRESSED_Pos = 0x4
	// Bit mask of SLAVE_ADDRESSED field.
	RTC_I2C_STATUS_SLAVE_ADDRESSED_Msk = 0x10
	// Bit SLAVE_ADDRESSED.
	RTC_I2C_STATUS_SLAVE_ADDRESSED = 0x10
	// Position of BYTE_TRANS field.
	RTC_I2C_STATUS_BYTE_TRANS_Pos = 0x5
	// Bit mask of BYTE_TRANS field.
	RTC_I2C_STATUS_BYTE_TRANS_Msk = 0x20
	// Bit BYTE_TRANS.
	RTC_I2C_STATUS_BYTE_TRANS = 0x20
	// Position of OP_CNT field.
	RTC_I2C_STATUS_OP_CNT_Pos = 0x6
	// Bit mask of OP_CNT field.
	RTC_I2C_STATUS_OP_CNT_Msk = 0xc0
	// Position of SHIFT field.
	RTC_I2C_STATUS_SHIFT_Pos = 0x10
	// Bit mask of SHIFT field.
	RTC_I2C_STATUS_SHIFT_Msk = 0xff0000
	// Position of SCL_MAIN_STATE_LAST field.
	RTC_I2C_STATUS_SCL_MAIN_STATE_LAST_Pos = 0x18
	// Bit mask of SCL_MAIN_STATE_LAST field.
	RTC_I2C_STATUS_SCL_MAIN_STATE_LAST_Msk = 0x7000000
	// Position of SCL_STATE_LAST field.
	RTC_I2C_STATUS_SCL_STATE_LAST_Pos = 0x1c
	// Bit mask of SCL_STATE_LAST field.
	RTC_I2C_STATUS_SCL_STATE_LAST_Msk = 0x70000000

	// TO: Configure RTC I2C timeout
	// Position of TIME_OUT field.
	RTC_I2C_TO_TIME_OUT_Pos = 0x0
	// Bit mask of TIME_OUT field.
	RTC_I2C_TO_TIME_OUT_Msk = 0xfffff

	// SLAVE_ADDR: Configure slave address
	// Position of SLAVE_ADDR field.
	RTC_I2C_SLAVE_ADDR_SLAVE_ADDR_Pos = 0x0
	// Bit mask of SLAVE_ADDR field.
	RTC_I2C_SLAVE_ADDR_SLAVE_ADDR_Msk = 0x7fff
	// Position of ADDR_10BIT_EN field.
	RTC_I2C_SLAVE_ADDR_ADDR_10BIT_EN_Pos = 0x1f
	// Bit mask of ADDR_10BIT_EN field.
	RTC_I2C_SLAVE_ADDR_ADDR_10BIT_EN_Msk = 0x80000000
	// Bit ADDR_10BIT_EN.
	RTC_I2C_SLAVE_ADDR_ADDR_10BIT_EN = 0x80000000

	// SCL_HIGH: Configure the high level width of SCL
	// Position of PERIOD field.
	RTC_I2C_SCL_HIGH_PERIOD_Pos = 0x0
	// Bit mask of PERIOD field.
	RTC_I2C_SCL_HIGH_PERIOD_Msk = 0xfffff

	// SDA_DUTY: Configure the SDA hold time after a negative SCL edge
	// Position of NUM field.
	RTC_I2C_SDA_DUTY_NUM_Pos = 0x0
	// Bit mask of NUM field.
	RTC_I2C_SDA_DUTY_NUM_Msk = 0xfffff

	// SCL_START_PERIOD: Configure the delay between the SDA and SCL negative edge for a start condition
	// Position of SCL_START_PERIOD field.
	RTC_I2C_SCL_START_PERIOD_SCL_START_PERIOD_Pos = 0x0
	// Bit mask of SCL_START_PERIOD field.
	RTC_I2C_SCL_START_PERIOD_SCL_START_PERIOD_Msk = 0xfffff

	// SCL_STOP_PERIOD: Configure the delay between SDA and SCL positive edge for a stop condition
	// Position of SCL_STOP_PERIOD field.
	RTC_I2C_SCL_STOP_PERIOD_SCL_STOP_PERIOD_Pos = 0x0
	// Bit mask of SCL_STOP_PERIOD field.
	RTC_I2C_SCL_STOP_PERIOD_SCL_STOP_PERIOD_Msk = 0xfffff

	// INT_CLR: Clear RTC I2C interrupt
	// Position of SLAVE_TRAN_COMP_INT_CLR field.
	RTC_I2C_INT_CLR_SLAVE_TRAN_COMP_INT_CLR_Pos = 0x0
	// Bit mask of SLAVE_TRAN_COMP_INT_CLR field.
	RTC_I2C_INT_CLR_SLAVE_TRAN_COMP_INT_CLR_Msk = 0x1
	// Bit SLAVE_TRAN_COMP_INT_CLR.
	RTC_I2C_INT_CLR_SLAVE_TRAN_COMP_INT_CLR = 0x1
	// Position of ARBITRATION_LOST_INT_CLR field.
	RTC_I2C_INT_CLR_ARBITRATION_LOST_INT_CLR_Pos = 0x1
	// Bit mask of ARBITRATION_LOST_INT_CLR field.
	RTC_I2C_INT_CLR_ARBITRATION_LOST_INT_CLR_Msk = 0x2
	// Bit ARBITRATION_LOST_INT_CLR.
	RTC_I2C_INT_CLR_ARBITRATION_LOST_INT_CLR = 0x2
	// Position of MASTER_TRAN_COMP_INT_CLR field.
	RTC_I2C_INT_CLR_MASTER_TRAN_COMP_INT_CLR_Pos = 0x2
	// Bit mask of MASTER_TRAN_COMP_INT_CLR field.
	RTC_I2C_INT_CLR_MASTER_TRAN_COMP_INT_CLR_Msk = 0x4
	// Bit MASTER_TRAN_COMP_INT_CLR.
	RTC_I2C_INT_CLR_MASTER_TRAN_COMP_INT_CLR = 0x4
	// Position of TRANS_COMPLETE_INT_CLR field.
	RTC_I2C_INT_CLR_TRANS_COMPLETE_INT_CLR_Pos = 0x3
	// Bit mask of TRANS_COMPLETE_INT_CLR field.
	RTC_I2C_INT_CLR_TRANS_COMPLETE_INT_CLR_Msk = 0x8
	// Bit TRANS_COMPLETE_INT_CLR.
	RTC_I2C_INT_CLR_TRANS_COMPLETE_INT_CLR = 0x8
	// Position of TIME_OUT_INT_CLR field.
	RTC_I2C_INT_CLR_TIME_OUT_INT_CLR_Pos = 0x4
	// Bit mask of TIME_OUT_INT_CLR field.
	RTC_I2C_INT_CLR_TIME_OUT_INT_CLR_Msk = 0x10
	// Bit TIME_OUT_INT_CLR.
	RTC_I2C_INT_CLR_TIME_OUT_INT_CLR = 0x10
	// Position of ACK_ERR_INT_CLR field.
	RTC_I2C_INT_CLR_ACK_ERR_INT_CLR_Pos = 0x5
	// Bit mask of ACK_ERR_INT_CLR field.
	RTC_I2C_INT_CLR_ACK_ERR_INT_CLR_Msk = 0x20
	// Bit ACK_ERR_INT_CLR.
	RTC_I2C_INT_CLR_ACK_ERR_INT_CLR = 0x20
	// Position of RX_DATA_INT_CLR field.
	RTC_I2C_INT_CLR_RX_DATA_INT_CLR_Pos = 0x6
	// Bit mask of RX_DATA_INT_CLR field.
	RTC_I2C_INT_CLR_RX_DATA_INT_CLR_Msk = 0x40
	// Bit RX_DATA_INT_CLR.
	RTC_I2C_INT_CLR_RX_DATA_INT_CLR = 0x40
	// Position of TX_DATA_INT_CLR field.
	RTC_I2C_INT_CLR_TX_DATA_INT_CLR_Pos = 0x7
	// Bit mask of TX_DATA_INT_CLR field.
	RTC_I2C_INT_CLR_TX_DATA_INT_CLR_Msk = 0x80
	// Bit TX_DATA_INT_CLR.
	RTC_I2C_INT_CLR_TX_DATA_INT_CLR = 0x80
	// Position of DETECT_START_INT_CLR field.
	RTC_I2C_INT_CLR_DETECT_START_INT_CLR_Pos = 0x8
	// Bit mask of DETECT_START_INT_CLR field.
	RTC_I2C_INT_CLR_DETECT_START_INT_CLR_Msk = 0x100
	// Bit DETECT_START_INT_CLR.
	RTC_I2C_INT_CLR_DETECT_START_INT_CLR = 0x100

	// INT_RAW: RTC I2C raw interrupt
	// Position of SLAVE_TRAN_COMP_INT_RAW field.
	RTC_I2C_INT_RAW_SLAVE_TRAN_COMP_INT_RAW_Pos = 0x0
	// Bit mask of SLAVE_TRAN_COMP_INT_RAW field.
	RTC_I2C_INT_RAW_SLAVE_TRAN_COMP_INT_RAW_Msk = 0x1
	// Bit SLAVE_TRAN_COMP_INT_RAW.
	RTC_I2C_INT_RAW_SLAVE_TRAN_COMP_INT_RAW = 0x1
	// Position of ARBITRATION_LOST_INT_RAW field.
	RTC_I2C_INT_RAW_ARBITRATION_LOST_INT_RAW_Pos = 0x1
	// Bit mask of ARBITRATION_LOST_INT_RAW field.
	RTC_I2C_INT_RAW_ARBITRATION_LOST_INT_RAW_Msk = 0x2
	// Bit ARBITRATION_LOST_INT_RAW.
	RTC_I2C_INT_RAW_ARBITRATION_LOST_INT_RAW = 0x2
	// Position of MASTER_TRAN_COMP_INT_RAW field.
	RTC_I2C_INT_RAW_MASTER_TRAN_COMP_INT_RAW_Pos = 0x2
	// Bit mask of MASTER_TRAN_COMP_INT_RAW field.
	RTC_I2C_INT_RAW_MASTER_TRAN_COMP_INT_RAW_Msk = 0x4
	// Bit MASTER_TRAN_COMP_INT_RAW.
	RTC_I2C_INT_RAW_MASTER_TRAN_COMP_INT_RAW = 0x4
	// Position of TRANS_COMPLETE_INT_RAW field.
	RTC_I2C_INT_RAW_TRANS_COMPLETE_INT_RAW_Pos = 0x3
	// Bit mask of TRANS_COMPLETE_INT_RAW field.
	RTC_I2C_INT_RAW_TRANS_COMPLETE_INT_RAW_Msk = 0x8
	// Bit TRANS_COMPLETE_INT_RAW.
	RTC_I2C_INT_RAW_TRANS_COMPLETE_INT_RAW = 0x8
	// Position of TIME_OUT_INT_RAW field.
	RTC_I2C_INT_RAW_TIME_OUT_INT_RAW_Pos = 0x4
	// Bit mask of TIME_OUT_INT_RAW field.
	RTC_I2C_INT_RAW_TIME_OUT_INT_RAW_Msk = 0x10
	// Bit TIME_OUT_INT_RAW.
	RTC_I2C_INT_RAW_TIME_OUT_INT_RAW = 0x10
	// Position of ACK_ERR_INT_RAW field.
	RTC_I2C_INT_RAW_ACK_ERR_INT_RAW_Pos = 0x5
	// Bit mask of ACK_ERR_INT_RAW field.
	RTC_I2C_INT_RAW_ACK_ERR_INT_RAW_Msk = 0x20
	// Bit ACK_ERR_INT_RAW.
	RTC_I2C_INT_RAW_ACK_ERR_INT_RAW = 0x20
	// Position of RX_DATA_INT_RAW field.
	RTC_I2C_INT_RAW_RX_DATA_INT_RAW_Pos = 0x6
	// Bit mask of RX_DATA_INT_RAW field.
	RTC_I2C_INT_RAW_RX_DATA_INT_RAW_Msk = 0x40
	// Bit RX_DATA_INT_RAW.
	RTC_I2C_INT_RAW_RX_DATA_INT_RAW = 0x40
	// Position of TX_DATA_INT_RAW field.
	RTC_I2C_INT_RAW_TX_DATA_INT_RAW_Pos = 0x7
	// Bit mask of TX_DATA_INT_RAW field.
	RTC_I2C_INT_RAW_TX_DATA_INT_RAW_Msk = 0x80
	// Bit TX_DATA_INT_RAW.
	RTC_I2C_INT_RAW_TX_DATA_INT_RAW = 0x80
	// Position of DETECT_START_INT_RAW field.
	RTC_I2C_INT_RAW_DETECT_START_INT_RAW_Pos = 0x8
	// Bit mask of DETECT_START_INT_RAW field.
	RTC_I2C_INT_RAW_DETECT_START_INT_RAW_Msk = 0x100
	// Bit DETECT_START_INT_RAW.
	RTC_I2C_INT_RAW_DETECT_START_INT_RAW = 0x100

	// INT_ST: RTC I2C interrupt status
	// Position of SLAVE_TRAN_COMP_INT_ST field.
	RTC_I2C_INT_ST_SLAVE_TRAN_COMP_INT_ST_Pos = 0x0
	// Bit mask of SLAVE_TRAN_COMP_INT_ST field.
	RTC_I2C_INT_ST_SLAVE_TRAN_COMP_INT_ST_Msk = 0x1
	// Bit SLAVE_TRAN_COMP_INT_ST.
	RTC_I2C_INT_ST_SLAVE_TRAN_COMP_INT_ST = 0x1
	// Position of ARBITRATION_LOST_INT_ST field.
	RTC_I2C_INT_ST_ARBITRATION_LOST_INT_ST_Pos = 0x1
	// Bit mask of ARBITRATION_LOST_INT_ST field.
	RTC_I2C_INT_ST_ARBITRATION_LOST_INT_ST_Msk = 0x2
	// Bit ARBITRATION_LOST_INT_ST.
	RTC_I2C_INT_ST_ARBITRATION_LOST_INT_ST = 0x2
	// Position of MASTER_TRAN_COMP_INT_ST field.
	RTC_I2C_INT_ST_MASTER_TRAN_COMP_INT_ST_Pos = 0x2
	// Bit mask of MASTER_TRAN_COMP_INT_ST field.
	RTC_I2C_INT_ST_MASTER_TRAN_COMP_INT_ST_Msk = 0x4
	// Bit MASTER_TRAN_COMP_INT_ST.
	RTC_I2C_INT_ST_MASTER_TRAN_COMP_INT_ST = 0x4
	// Position of TRANS_COMPLETE_INT_ST field.
	RTC_I2C_INT_ST_TRANS_COMPLETE_INT_ST_Pos = 0x3
	// Bit mask of TRANS_COMPLETE_INT_ST field.
	RTC_I2C_INT_ST_TRANS_COMPLETE_INT_ST_Msk = 0x8
	// Bit TRANS_COMPLETE_INT_ST.
	RTC_I2C_INT_ST_TRANS_COMPLETE_INT_ST = 0x8
	// Position of TIME_OUT_INT_ST field.
	RTC_I2C_INT_ST_TIME_OUT_INT_ST_Pos = 0x4
	// Bit mask of TIME_OUT_INT_ST field.
	RTC_I2C_INT_ST_TIME_OUT_INT_ST_Msk = 0x10
	// Bit TIME_OUT_INT_ST.
	RTC_I2C_INT_ST_TIME_OUT_INT_ST = 0x10
	// Position of ACK_ERR_INT_ST field.
	RTC_I2C_INT_ST_ACK_ERR_INT_ST_Pos = 0x5
	// Bit mask of ACK_ERR_INT_ST field.
	RTC_I2C_INT_ST_ACK_ERR_INT_ST_Msk = 0x20
	// Bit ACK_ERR_INT_ST.
	RTC_I2C_INT_ST_ACK_ERR_INT_ST = 0x20
	// Position of RX_DATA_INT_ST field.
	RTC_I2C_INT_ST_RX_DATA_INT_ST_Pos = 0x6
	// Bit mask of RX_DATA_INT_ST field.
	RTC_I2C_INT_ST_RX_DATA_INT_ST_Msk = 0x40
	// Bit RX_DATA_INT_ST.
	RTC_I2C_INT_ST_RX_DATA_INT_ST = 0x40
	// Position of TX_DATA_INT_ST field.
	RTC_I2C_INT_ST_TX_DATA_INT_ST_Pos = 0x7
	// Bit mask of TX_DATA_INT_ST field.
	RTC_I2C_INT_ST_TX_DATA_INT_ST_Msk = 0x80
	// Bit TX_DATA_INT_ST.
	RTC_I2C_INT_ST_TX_DATA_INT_ST = 0x80
	// Position of DETECT_START_INT_ST field.
	RTC_I2C_INT_ST_DETECT_START_INT_ST_Pos = 0x8
	// Bit mask of DETECT_START_INT_ST field.
	RTC_I2C_INT_ST_DETECT_START_INT_ST_Msk = 0x100
	// Bit DETECT_START_INT_ST.
	RTC_I2C_INT_ST_DETECT_START_INT_ST = 0x100

	// INT_ENA: Enable RTC I2C interrupt
	// Position of SLAVE_TRAN_COMP_INT_ENA field.
	RTC_I2C_INT_ENA_SLAVE_TRAN_COMP_INT_ENA_Pos = 0x0
	// Bit mask of SLAVE_TRAN_COMP_INT_ENA field.
	RTC_I2C_INT_ENA_SLAVE_TRAN_COMP_INT_ENA_Msk = 0x1
	// Bit SLAVE_TRAN_COMP_INT_ENA.
	RTC_I2C_INT_ENA_SLAVE_TRAN_COMP_INT_ENA = 0x1
	// Position of ARBITRATION_LOST_INT_ENA field.
	RTC_I2C_INT_ENA_ARBITRATION_LOST_INT_ENA_Pos = 0x1
	// Bit mask of ARBITRATION_LOST_INT_ENA field.
	RTC_I2C_INT_ENA_ARBITRATION_LOST_INT_ENA_Msk = 0x2
	// Bit ARBITRATION_LOST_INT_ENA.
	RTC_I2C_INT_ENA_ARBITRATION_LOST_INT_ENA = 0x2
	// Position of MASTER_TRAN_COMP_INT_ENA field.
	RTC_I2C_INT_ENA_MASTER_TRAN_COMP_INT_ENA_Pos = 0x2
	// Bit mask of MASTER_TRAN_COMP_INT_ENA field.
	RTC_I2C_INT_ENA_MASTER_TRAN_COMP_INT_ENA_Msk = 0x4
	// Bit MASTER_TRAN_COMP_INT_ENA.
	RTC_I2C_INT_ENA_MASTER_TRAN_COMP_INT_ENA = 0x4
	// Position of TRANS_COMPLETE_INT_ENA field.
	RTC_I2C_INT_ENA_TRANS_COMPLETE_INT_ENA_Pos = 0x3
	// Bit mask of TRANS_COMPLETE_INT_ENA field.
	RTC_I2C_INT_ENA_TRANS_COMPLETE_INT_ENA_Msk = 0x8
	// Bit TRANS_COMPLETE_INT_ENA.
	RTC_I2C_INT_ENA_TRANS_COMPLETE_INT_ENA = 0x8
	// Position of TIME_OUT_INT_ENA field.
	RTC_I2C_INT_ENA_TIME_OUT_INT_ENA_Pos = 0x4
	// Bit mask of TIME_OUT_INT_ENA field.
	RTC_I2C_INT_ENA_TIME_OUT_INT_ENA_Msk = 0x10
	// Bit TIME_OUT_INT_ENA.
	RTC_I2C_INT_ENA_TIME_OUT_INT_ENA = 0x10
	// Position of ACK_ERR_INT_ENA field.
	RTC_I2C_INT_ENA_ACK_ERR_INT_ENA_Pos = 0x5
	// Bit mask of ACK_ERR_INT_ENA field.
	RTC_I2C_INT_ENA_ACK_ERR_INT_ENA_Msk = 0x20
	// Bit ACK_ERR_INT_ENA.
	RTC_I2C_INT_ENA_ACK_ERR_INT_ENA = 0x20
	// Position of RX_DATA_INT_ENA field.
	RTC_I2C_INT_ENA_RX_DATA_INT_ENA_Pos = 0x6
	// Bit mask of RX_DATA_INT_ENA field.
	RTC_I2C_INT_ENA_RX_DATA_INT_ENA_Msk = 0x40
	// Bit RX_DATA_INT_ENA.
	RTC_I2C_INT_ENA_RX_DATA_INT_ENA = 0x40
	// Position of TX_DATA_INT_ENA field.
	RTC_I2C_INT_ENA_TX_DATA_INT_ENA_Pos = 0x7
	// Bit mask of TX_DATA_INT_ENA field.
	RTC_I2C_INT_ENA_TX_DATA_INT_ENA_Msk = 0x80
	// Bit TX_DATA_INT_ENA.
	RTC_I2C_INT_ENA_TX_DATA_INT_ENA = 0x80
	// Position of DETECT_START_INT_ENA field.
	RTC_I2C_INT_ENA_DETECT_START_INT_ENA_Pos = 0x8
	// Bit mask of DETECT_START_INT_ENA field.
	RTC_I2C_INT_ENA_DETECT_START_INT_ENA_Msk = 0x100
	// Bit DETECT_START_INT_ENA.
	RTC_I2C_INT_ENA_DETECT_START_INT_ENA = 0x100

	// DATA: RTC I2C read data
	// Position of RDATA field.
	RTC_I2C_DATA_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	RTC_I2C_DATA_RDATA_Msk = 0xff
	// Position of SLAVE_TX_DATA field.
	RTC_I2C_DATA_SLAVE_TX_DATA_Pos = 0x8
	// Bit mask of SLAVE_TX_DATA field.
	RTC_I2C_DATA_SLAVE_TX_DATA_Msk = 0xff00
	// Position of DONE field.
	RTC_I2C_DATA_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	RTC_I2C_DATA_DONE_Msk = 0x80000000
	// Bit DONE.
	RTC_I2C_DATA_DONE = 0x80000000

	// CMD0: RTC I2C Command %s
	// Position of COMMAND field.
	RTC_I2C_CMD_COMMAND_Pos = 0x0
	// Bit mask of COMMAND field.
	RTC_I2C_CMD_COMMAND_Msk = 0x3fff
	// Position of COMMAND_DONE field.
	RTC_I2C_CMD_COMMAND_DONE_Pos = 0x1f
	// Bit mask of COMMAND_DONE field.
	RTC_I2C_CMD_COMMAND_DONE_Msk = 0x80000000
	// Bit COMMAND_DONE.
	RTC_I2C_CMD_COMMAND_DONE = 0x80000000

	// DATE: Version control register
	// Position of DATE field.
	RTC_I2C_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	RTC_I2C_DATE_DATE_Msk = 0xfffffff
)

// Constants for SENS: SENS Peripheral
const (
	// SAR_READER1_CTRL: RTC ADC1 data and sampling control
	// Position of SAR1_CLK_DIV field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_DIV_Pos = 0x0
	// Bit mask of SAR1_CLK_DIV field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_DIV_Msk = 0xff
	// Position of SAR1_CLK_GATED field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_GATED_Pos = 0x12
	// Bit mask of SAR1_CLK_GATED field.
	SENS_SAR_READER1_CTRL_SAR1_CLK_GATED_Msk = 0x40000
	// Bit SAR1_CLK_GATED.
	SENS_SAR_READER1_CTRL_SAR1_CLK_GATED = 0x40000
	// Position of SAR1_SAMPLE_NUM field.
	SENS_SAR_READER1_CTRL_SAR1_SAMPLE_NUM_Pos = 0x13
	// Bit mask of SAR1_SAMPLE_NUM field.
	SENS_SAR_READER1_CTRL_SAR1_SAMPLE_NUM_Msk = 0x7f80000
	// Position of SAR1_DATA_INV field.
	SENS_SAR_READER1_CTRL_SAR1_DATA_INV_Pos = 0x1c
	// Bit mask of SAR1_DATA_INV field.
	SENS_SAR_READER1_CTRL_SAR1_DATA_INV_Msk = 0x10000000
	// Bit SAR1_DATA_INV.
	SENS_SAR_READER1_CTRL_SAR1_DATA_INV = 0x10000000
	// Position of SAR1_INT_EN field.
	SENS_SAR_READER1_CTRL_SAR1_INT_EN_Pos = 0x1d
	// Bit mask of SAR1_INT_EN field.
	SENS_SAR_READER1_CTRL_SAR1_INT_EN_Msk = 0x20000000
	// Bit SAR1_INT_EN.
	SENS_SAR_READER1_CTRL_SAR1_INT_EN = 0x20000000

	// SAR_READER1_STATUS: saradc1 status for debug
	// Position of SAR1_READER_STATUS field.
	SENS_SAR_READER1_STATUS_SAR1_READER_STATUS_Pos = 0x0
	// Bit mask of SAR1_READER_STATUS field.
	SENS_SAR_READER1_STATUS_SAR1_READER_STATUS_Msk = 0xffffffff

	// SAR_MEAS1_CTRL1: Configure RTC ADC1 controller
	// Position of RTC_SARADC_RESET field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_RESET_Pos = 0x16
	// Bit mask of RTC_SARADC_RESET field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_RESET_Msk = 0x400000
	// Bit RTC_SARADC_RESET.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_RESET = 0x400000
	// Position of RTC_SARADC_CLKGATE_EN field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN_Pos = 0x17
	// Bit mask of RTC_SARADC_CLKGATE_EN field.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN_Msk = 0x800000
	// Bit RTC_SARADC_CLKGATE_EN.
	SENS_SAR_MEAS1_CTRL1_RTC_SARADC_CLKGATE_EN = 0x800000
	// Position of FORCE_XPD_AMP field.
	SENS_SAR_MEAS1_CTRL1_FORCE_XPD_AMP_Pos = 0x18
	// Bit mask of FORCE_XPD_AMP field.
	SENS_SAR_MEAS1_CTRL1_FORCE_XPD_AMP_Msk = 0x3000000
	// Position of AMP_RST_FB_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_RST_FB_FORCE_Pos = 0x1a
	// Bit mask of AMP_RST_FB_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_RST_FB_FORCE_Msk = 0xc000000
	// Position of AMP_SHORT_REF_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE_Pos = 0x1c
	// Bit mask of AMP_SHORT_REF_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_FORCE_Msk = 0x30000000
	// Position of AMP_SHORT_REF_GND_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE_Pos = 0x1e
	// Bit mask of AMP_SHORT_REF_GND_FORCE field.
	SENS_SAR_MEAS1_CTRL1_AMP_SHORT_REF_GND_FORCE_Msk = 0xc0000000

	// SAR_MEAS1_CTRL2: Control RTC ADC1 conversion and status
	// Position of MEAS1_DATA_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DATA_SAR_Pos = 0x0
	// Bit mask of MEAS1_DATA_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DATA_SAR_Msk = 0xffff
	// Position of MEAS1_DONE_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DONE_SAR_Pos = 0x10
	// Bit mask of MEAS1_DONE_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DONE_SAR_Msk = 0x10000
	// Bit MEAS1_DONE_SAR.
	SENS_SAR_MEAS1_CTRL2_MEAS1_DONE_SAR = 0x10000
	// Position of MEAS1_START_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_SAR_Pos = 0x11
	// Bit mask of MEAS1_START_SAR field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_SAR_Msk = 0x20000
	// Bit MEAS1_START_SAR.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_SAR = 0x20000
	// Position of MEAS1_START_FORCE field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_FORCE_Pos = 0x12
	// Bit mask of MEAS1_START_FORCE field.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_FORCE_Msk = 0x40000
	// Bit MEAS1_START_FORCE.
	SENS_SAR_MEAS1_CTRL2_MEAS1_START_FORCE = 0x40000
	// Position of SAR1_EN_PAD field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_Pos = 0x13
	// Bit mask of SAR1_EN_PAD field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_Msk = 0x7ff80000
	// Position of SAR1_EN_PAD_FORCE field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE_Pos = 0x1f
	// Bit mask of SAR1_EN_PAD_FORCE field.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE_Msk = 0x80000000
	// Bit SAR1_EN_PAD_FORCE.
	SENS_SAR_MEAS1_CTRL2_SAR1_EN_PAD_FORCE = 0x80000000

	// SAR_MEAS1_MUX: Select the controller for SAR ADC1
	// Position of SAR1_DIG_FORCE field.
	SENS_SAR_MEAS1_MUX_SAR1_DIG_FORCE_Pos = 0x1f
	// Bit mask of SAR1_DIG_FORCE field.
	SENS_SAR_MEAS1_MUX_SAR1_DIG_FORCE_Msk = 0x80000000
	// Bit SAR1_DIG_FORCE.
	SENS_SAR_MEAS1_MUX_SAR1_DIG_FORCE = 0x80000000

	// SAR_ATTEN1: Configure SAR ADC1 attenuation
	// Position of SAR1_ATTEN field.
	SENS_SAR_ATTEN1_SAR1_ATTEN_Pos = 0x0
	// Bit mask of SAR1_ATTEN field.
	SENS_SAR_ATTEN1_SAR1_ATTEN_Msk = 0xffffffff

	// SAR_AMP_CTRL1: AMP control
	// Position of SAR_AMP_WAIT1 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT1_Pos = 0x0
	// Bit mask of SAR_AMP_WAIT1 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT1_Msk = 0xffff
	// Position of SAR_AMP_WAIT2 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT2_Pos = 0x10
	// Bit mask of SAR_AMP_WAIT2 field.
	SENS_SAR_AMP_CTRL1_SAR_AMP_WAIT2_Msk = 0xffff0000

	// SAR_AMP_CTRL2: AMP control
	// Position of SAR1_DAC_XPD_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE_Pos = 0x0
	// Bit mask of SAR1_DAC_XPD_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE_Msk = 0x1
	// Bit SAR1_DAC_XPD_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_SAR1_DAC_XPD_FSM_IDLE = 0x1
	// Position of XPD_SAR_AMP_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE_Pos = 0x1
	// Bit mask of XPD_SAR_AMP_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE_Msk = 0x2
	// Bit XPD_SAR_AMP_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_XPD_SAR_AMP_FSM_IDLE = 0x2
	// Position of AMP_RST_FB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE_Pos = 0x2
	// Bit mask of AMP_RST_FB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE_Msk = 0x4
	// Bit AMP_RST_FB_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_AMP_RST_FB_FSM_IDLE = 0x4
	// Position of AMP_SHORT_REF_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE_Pos = 0x3
	// Bit mask of AMP_SHORT_REF_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE_Msk = 0x8
	// Bit AMP_SHORT_REF_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_FSM_IDLE = 0x8
	// Position of AMP_SHORT_REF_GND_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE_Pos = 0x4
	// Bit mask of AMP_SHORT_REF_GND_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE_Msk = 0x10
	// Bit AMP_SHORT_REF_GND_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_AMP_SHORT_REF_GND_FSM_IDLE = 0x10
	// Position of XPD_SAR_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_FSM_IDLE_Pos = 0x5
	// Bit mask of XPD_SAR_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_XPD_SAR_FSM_IDLE_Msk = 0x20
	// Bit XPD_SAR_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_XPD_SAR_FSM_IDLE = 0x20
	// Position of SAR_RSTB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE_Pos = 0x6
	// Bit mask of SAR_RSTB_FSM_IDLE field.
	SENS_SAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE_Msk = 0x40
	// Bit SAR_RSTB_FSM_IDLE.
	SENS_SAR_AMP_CTRL2_SAR_RSTB_FSM_IDLE = 0x40
	// Position of SAR_AMP_WAIT3 field.
	SENS_SAR_AMP_CTRL2_SAR_AMP_WAIT3_Pos = 0x10
	// Bit mask of SAR_AMP_WAIT3 field.
	SENS_SAR_AMP_CTRL2_SAR_AMP_WAIT3_Msk = 0xffff0000

	// SAR_AMP_CTRL3: AMP control register
	// Position of SAR1_DAC_XPD_FSM field.
	SENS_SAR_AMP_CTRL3_SAR1_DAC_XPD_FSM_Pos = 0x0
	// Bit mask of SAR1_DAC_XPD_FSM field.
	SENS_SAR_AMP_CTRL3_SAR1_DAC_XPD_FSM_Msk = 0xf
	// Position of XPD_SAR_AMP_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_AMP_FSM_Pos = 0x4
	// Bit mask of XPD_SAR_AMP_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_AMP_FSM_Msk = 0xf0
	// Position of AMP_RST_FB_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_RST_FB_FSM_Pos = 0x8
	// Bit mask of AMP_RST_FB_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_RST_FB_FSM_Msk = 0xf00
	// Position of AMP_SHORT_REF_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_FSM_Pos = 0xc
	// Bit mask of AMP_SHORT_REF_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_FSM_Msk = 0xf000
	// Position of AMP_SHORT_REF_GND_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM_Pos = 0x10
	// Bit mask of AMP_SHORT_REF_GND_FSM field.
	SENS_SAR_AMP_CTRL3_AMP_SHORT_REF_GND_FSM_Msk = 0xf0000
	// Position of XPD_SAR_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_FSM_Pos = 0x14
	// Bit mask of XPD_SAR_FSM field.
	SENS_SAR_AMP_CTRL3_XPD_SAR_FSM_Msk = 0xf00000
	// Position of SAR_RSTB_FSM field.
	SENS_SAR_AMP_CTRL3_SAR_RSTB_FSM_Pos = 0x18
	// Bit mask of SAR_RSTB_FSM field.
	SENS_SAR_AMP_CTRL3_SAR_RSTB_FSM_Msk = 0xf000000

	// SAR_READER2_CTRL: RTC ADC2 data and sampling control
	// Position of SAR2_CLK_DIV field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_DIV_Pos = 0x0
	// Bit mask of SAR2_CLK_DIV field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_DIV_Msk = 0xff
	// Position of SAR2_WAIT_ARB_CYCLE field.
	SENS_SAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE_Pos = 0x10
	// Bit mask of SAR2_WAIT_ARB_CYCLE field.
	SENS_SAR_READER2_CTRL_SAR2_WAIT_ARB_CYCLE_Msk = 0x30000
	// Position of SAR2_CLK_GATED field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_GATED_Pos = 0x12
	// Bit mask of SAR2_CLK_GATED field.
	SENS_SAR_READER2_CTRL_SAR2_CLK_GATED_Msk = 0x40000
	// Bit SAR2_CLK_GATED.
	SENS_SAR_READER2_CTRL_SAR2_CLK_GATED = 0x40000
	// Position of SAR2_SAMPLE_NUM field.
	SENS_SAR_READER2_CTRL_SAR2_SAMPLE_NUM_Pos = 0x13
	// Bit mask of SAR2_SAMPLE_NUM field.
	SENS_SAR_READER2_CTRL_SAR2_SAMPLE_NUM_Msk = 0x7f80000
	// Position of SAR2_DATA_INV field.
	SENS_SAR_READER2_CTRL_SAR2_DATA_INV_Pos = 0x1d
	// Bit mask of SAR2_DATA_INV field.
	SENS_SAR_READER2_CTRL_SAR2_DATA_INV_Msk = 0x20000000
	// Bit SAR2_DATA_INV.
	SENS_SAR_READER2_CTRL_SAR2_DATA_INV = 0x20000000
	// Position of SAR2_INT_EN field.
	SENS_SAR_READER2_CTRL_SAR2_INT_EN_Pos = 0x1e
	// Bit mask of SAR2_INT_EN field.
	SENS_SAR_READER2_CTRL_SAR2_INT_EN_Msk = 0x40000000
	// Bit SAR2_INT_EN.
	SENS_SAR_READER2_CTRL_SAR2_INT_EN = 0x40000000

	// SAR_READER2_STATUS: saradc2 status for debug
	// Position of SAR2_READER_STATUS field.
	SENS_SAR_READER2_STATUS_SAR2_READER_STATUS_Pos = 0x0
	// Bit mask of SAR2_READER_STATUS field.
	SENS_SAR_READER2_STATUS_SAR2_READER_STATUS_Msk = 0xffffffff

	// SAR_MEAS2_CTRL1: configure rtc saradc2
	// Position of SAR2_CNTL_STATE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_CNTL_STATE_Pos = 0x0
	// Bit mask of SAR2_CNTL_STATE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_CNTL_STATE_Msk = 0x7
	// Position of SAR2_PWDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN_Pos = 0x3
	// Bit mask of SAR2_PWDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN_Msk = 0x8
	// Bit SAR2_PWDET_CAL_EN.
	SENS_SAR_MEAS2_CTRL1_SAR2_PWDET_CAL_EN = 0x8
	// Position of SAR2_PKDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN_Pos = 0x4
	// Bit mask of SAR2_PKDET_CAL_EN field.
	SENS_SAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN_Msk = 0x10
	// Bit SAR2_PKDET_CAL_EN.
	SENS_SAR_MEAS2_CTRL1_SAR2_PKDET_CAL_EN = 0x10
	// Position of SAR2_EN_TEST field.
	SENS_SAR_MEAS2_CTRL1_SAR2_EN_TEST_Pos = 0x5
	// Bit mask of SAR2_EN_TEST field.
	SENS_SAR_MEAS2_CTRL1_SAR2_EN_TEST_Msk = 0x20
	// Bit SAR2_EN_TEST.
	SENS_SAR_MEAS2_CTRL1_SAR2_EN_TEST = 0x20
	// Position of SAR2_RSTB_FORCE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_FORCE_Pos = 0x6
	// Bit mask of SAR2_RSTB_FORCE field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_FORCE_Msk = 0xc0
	// Position of SAR2_STANDBY_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT_Pos = 0x8
	// Bit mask of SAR2_STANDBY_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_STANDBY_WAIT_Msk = 0xff00
	// Position of SAR2_RSTB_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_WAIT_Pos = 0x10
	// Bit mask of SAR2_RSTB_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_RSTB_WAIT_Msk = 0xff0000
	// Position of SAR2_XPD_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_XPD_WAIT_Pos = 0x18
	// Bit mask of SAR2_XPD_WAIT field.
	SENS_SAR_MEAS2_CTRL1_SAR2_XPD_WAIT_Msk = 0xff000000

	// SAR_MEAS2_CTRL2: Control RTC ADC2 conversion and status
	// Position of MEAS2_DATA_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DATA_SAR_Pos = 0x0
	// Bit mask of MEAS2_DATA_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DATA_SAR_Msk = 0xffff
	// Position of MEAS2_DONE_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DONE_SAR_Pos = 0x10
	// Bit mask of MEAS2_DONE_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DONE_SAR_Msk = 0x10000
	// Bit MEAS2_DONE_SAR.
	SENS_SAR_MEAS2_CTRL2_MEAS2_DONE_SAR = 0x10000
	// Position of MEAS2_START_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_SAR_Pos = 0x11
	// Bit mask of MEAS2_START_SAR field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_SAR_Msk = 0x20000
	// Bit MEAS2_START_SAR.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_SAR = 0x20000
	// Position of MEAS2_START_FORCE field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_FORCE_Pos = 0x12
	// Bit mask of MEAS2_START_FORCE field.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_FORCE_Msk = 0x40000
	// Bit MEAS2_START_FORCE.
	SENS_SAR_MEAS2_CTRL2_MEAS2_START_FORCE = 0x40000
	// Position of SAR2_EN_PAD field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_Pos = 0x13
	// Bit mask of SAR2_EN_PAD field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_Msk = 0x7ff80000
	// Position of SAR2_EN_PAD_FORCE field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE_Pos = 0x1f
	// Bit mask of SAR2_EN_PAD_FORCE field.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE_Msk = 0x80000000
	// Bit SAR2_EN_PAD_FORCE.
	SENS_SAR_MEAS2_CTRL2_SAR2_EN_PAD_FORCE = 0x80000000

	// SAR_MEAS2_MUX: Select the controller for SAR ADC2
	// Position of SAR2_PWDET_CCT field.
	SENS_SAR_MEAS2_MUX_SAR2_PWDET_CCT_Pos = 0x1c
	// Bit mask of SAR2_PWDET_CCT field.
	SENS_SAR_MEAS2_MUX_SAR2_PWDET_CCT_Msk = 0x70000000
	// Position of SAR2_RTC_FORCE field.
	SENS_SAR_MEAS2_MUX_SAR2_RTC_FORCE_Pos = 0x1f
	// Bit mask of SAR2_RTC_FORCE field.
	SENS_SAR_MEAS2_MUX_SAR2_RTC_FORCE_Msk = 0x80000000
	// Bit SAR2_RTC_FORCE.
	SENS_SAR_MEAS2_MUX_SAR2_RTC_FORCE = 0x80000000

	// SAR_ATTEN2: Configure SAR ADC2 attenuation
	// Position of SAR2_ATTEN field.
	SENS_SAR_ATTEN2_SAR2_ATTEN_Pos = 0x0
	// Bit mask of SAR2_ATTEN field.
	SENS_SAR_ATTEN2_SAR2_ATTEN_Msk = 0xffffffff

	// SAR_POWER_XPD_SAR: configure saradc’s power by sw
	// Position of FORCE_XPD_SAR field.
	SENS_SAR_POWER_XPD_SAR_FORCE_XPD_SAR_Pos = 0x1d
	// Bit mask of FORCE_XPD_SAR field.
	SENS_SAR_POWER_XPD_SAR_FORCE_XPD_SAR_Msk = 0x60000000
	// Position of SARCLK_EN field.
	SENS_SAR_POWER_XPD_SAR_SARCLK_EN_Pos = 0x1f
	// Bit mask of SARCLK_EN field.
	SENS_SAR_POWER_XPD_SAR_SARCLK_EN_Msk = 0x80000000
	// Bit SARCLK_EN.
	SENS_SAR_POWER_XPD_SAR_SARCLK_EN = 0x80000000

	// SAR_SLAVE_ADDR1: Configure slave addresses 0-1 of RTC I2C
	// Position of I2C_SLAVE_ADDR1 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR1 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR1_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR0 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR0 field.
	SENS_SAR_SLAVE_ADDR1_I2C_SLAVE_ADDR0_Msk = 0x3ff800
	// Position of MEAS_STATUS field.
	SENS_SAR_SLAVE_ADDR1_MEAS_STATUS_Pos = 0x16
	// Bit mask of MEAS_STATUS field.
	SENS_SAR_SLAVE_ADDR1_MEAS_STATUS_Msk = 0x3fc00000

	// SAR_SLAVE_ADDR2: Configure slave addresses 2-3 of RTC I2C
	// Position of I2C_SLAVE_ADDR3 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR3 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR3_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR2 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR2 field.
	SENS_SAR_SLAVE_ADDR2_I2C_SLAVE_ADDR2_Msk = 0x3ff800

	// SAR_SLAVE_ADDR3: Configure slave addresses 4-5 of RTC I2C
	// Position of I2C_SLAVE_ADDR5 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR5 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR5_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR4 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR4 field.
	SENS_SAR_SLAVE_ADDR3_I2C_SLAVE_ADDR4_Msk = 0x3ff800

	// SAR_SLAVE_ADDR4: Configure slave addresses 6-7 of RTC I2C
	// Position of I2C_SLAVE_ADDR7 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7_Pos = 0x0
	// Bit mask of I2C_SLAVE_ADDR7 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR7_Msk = 0x7ff
	// Position of I2C_SLAVE_ADDR6 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6_Pos = 0xb
	// Bit mask of I2C_SLAVE_ADDR6 field.
	SENS_SAR_SLAVE_ADDR4_I2C_SLAVE_ADDR6_Msk = 0x3ff800

	// SAR_TSENS_CTRL: Temperature sensor data control
	// Position of TSENS_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_OUT_Pos = 0x0
	// Bit mask of TSENS_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_OUT_Msk = 0xff
	// Position of TSENS_READY field.
	SENS_SAR_TSENS_CTRL_TSENS_READY_Pos = 0x8
	// Bit mask of TSENS_READY field.
	SENS_SAR_TSENS_CTRL_TSENS_READY_Msk = 0x100
	// Bit TSENS_READY.
	SENS_SAR_TSENS_CTRL_TSENS_READY = 0x100
	// Position of TSENS_INT_EN field.
	SENS_SAR_TSENS_CTRL_TSENS_INT_EN_Pos = 0xc
	// Bit mask of TSENS_INT_EN field.
	SENS_SAR_TSENS_CTRL_TSENS_INT_EN_Msk = 0x1000
	// Bit TSENS_INT_EN.
	SENS_SAR_TSENS_CTRL_TSENS_INT_EN = 0x1000
	// Position of TSENS_IN_INV field.
	SENS_SAR_TSENS_CTRL_TSENS_IN_INV_Pos = 0xd
	// Bit mask of TSENS_IN_INV field.
	SENS_SAR_TSENS_CTRL_TSENS_IN_INV_Msk = 0x2000
	// Bit TSENS_IN_INV.
	SENS_SAR_TSENS_CTRL_TSENS_IN_INV = 0x2000
	// Position of TSENS_CLK_DIV field.
	SENS_SAR_TSENS_CTRL_TSENS_CLK_DIV_Pos = 0xe
	// Bit mask of TSENS_CLK_DIV field.
	SENS_SAR_TSENS_CTRL_TSENS_CLK_DIV_Msk = 0x3fc000
	// Position of TSENS_POWER_UP field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_Pos = 0x16
	// Bit mask of TSENS_POWER_UP field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_Msk = 0x400000
	// Bit TSENS_POWER_UP.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP = 0x400000
	// Position of TSENS_POWER_UP_FORCE field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_FORCE_Pos = 0x17
	// Bit mask of TSENS_POWER_UP_FORCE field.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_FORCE_Msk = 0x800000
	// Bit TSENS_POWER_UP_FORCE.
	SENS_SAR_TSENS_CTRL_TSENS_POWER_UP_FORCE = 0x800000
	// Position of TSENS_DUMP_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_DUMP_OUT_Pos = 0x18
	// Bit mask of TSENS_DUMP_OUT field.
	SENS_SAR_TSENS_CTRL_TSENS_DUMP_OUT_Msk = 0x1000000
	// Bit TSENS_DUMP_OUT.
	SENS_SAR_TSENS_CTRL_TSENS_DUMP_OUT = 0x1000000

	// SAR_TSENS_CTRL2: Temperature sensor control
	// Position of TSENS_XPD_WAIT field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_WAIT_Pos = 0x0
	// Bit mask of TSENS_XPD_WAIT field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_WAIT_Msk = 0xfff
	// Position of TSENS_XPD_FORCE field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_FORCE_Pos = 0xc
	// Bit mask of TSENS_XPD_FORCE field.
	SENS_SAR_TSENS_CTRL2_TSENS_XPD_FORCE_Msk = 0x3000
	// Position of TSENS_CLK_INV field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLK_INV_Pos = 0xe
	// Bit mask of TSENS_CLK_INV field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLK_INV_Msk = 0x4000
	// Bit TSENS_CLK_INV.
	SENS_SAR_TSENS_CTRL2_TSENS_CLK_INV = 0x4000
	// Position of TSENS_CLKGATE_EN field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLKGATE_EN_Pos = 0xf
	// Bit mask of TSENS_CLKGATE_EN field.
	SENS_SAR_TSENS_CTRL2_TSENS_CLKGATE_EN_Msk = 0x8000
	// Bit TSENS_CLKGATE_EN.
	SENS_SAR_TSENS_CTRL2_TSENS_CLKGATE_EN = 0x8000
	// Position of TSENS_RESET field.
	SENS_SAR_TSENS_CTRL2_TSENS_RESET_Pos = 0x10
	// Bit mask of TSENS_RESET field.
	SENS_SAR_TSENS_CTRL2_TSENS_RESET_Msk = 0x10000
	// Bit TSENS_RESET.
	SENS_SAR_TSENS_CTRL2_TSENS_RESET = 0x10000

	// SAR_I2C_CTRL: Configure RTC I2C transmission
	// Position of SAR_I2C_CTRL field.
	SENS_SAR_I2C_CTRL_SAR_I2C_CTRL_Pos = 0x0
	// Bit mask of SAR_I2C_CTRL field.
	SENS_SAR_I2C_CTRL_SAR_I2C_CTRL_Msk = 0xfffffff
	// Position of SAR_I2C_START field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_Pos = 0x1c
	// Bit mask of SAR_I2C_START field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_Msk = 0x10000000
	// Bit SAR_I2C_START.
	SENS_SAR_I2C_CTRL_SAR_I2C_START = 0x10000000
	// Position of SAR_I2C_START_FORCE field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_FORCE_Pos = 0x1d
	// Bit mask of SAR_I2C_START_FORCE field.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_FORCE_Msk = 0x20000000
	// Bit SAR_I2C_START_FORCE.
	SENS_SAR_I2C_CTRL_SAR_I2C_START_FORCE = 0x20000000

	// SAR_TOUCH_CONF: Touch sensor configuration register
	// Position of TOUCH_OUTEN field.
	SENS_SAR_TOUCH_CONF_TOUCH_OUTEN_Pos = 0x0
	// Bit mask of TOUCH_OUTEN field.
	SENS_SAR_TOUCH_CONF_TOUCH_OUTEN_Msk = 0x7fff
	// Position of TOUCH_STATUS_CLR field.
	SENS_SAR_TOUCH_CONF_TOUCH_STATUS_CLR_Pos = 0xf
	// Bit mask of TOUCH_STATUS_CLR field.
	SENS_SAR_TOUCH_CONF_TOUCH_STATUS_CLR_Msk = 0x8000
	// Bit TOUCH_STATUS_CLR.
	SENS_SAR_TOUCH_CONF_TOUCH_STATUS_CLR = 0x8000
	// Position of TOUCH_DATA_SEL field.
	SENS_SAR_TOUCH_CONF_TOUCH_DATA_SEL_Pos = 0x10
	// Bit mask of TOUCH_DATA_SEL field.
	SENS_SAR_TOUCH_CONF_TOUCH_DATA_SEL_Msk = 0x30000
	// Position of TOUCH_DENOISE_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_DENOISE_END_Pos = 0x12
	// Bit mask of TOUCH_DENOISE_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_DENOISE_END_Msk = 0x40000
	// Bit TOUCH_DENOISE_END.
	SENS_SAR_TOUCH_CONF_TOUCH_DENOISE_END = 0x40000
	// Position of TOUCH_UNIT_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_UNIT_END_Pos = 0x13
	// Bit mask of TOUCH_UNIT_END field.
	SENS_SAR_TOUCH_CONF_TOUCH_UNIT_END_Msk = 0x80000
	// Bit TOUCH_UNIT_END.
	SENS_SAR_TOUCH_CONF_TOUCH_UNIT_END = 0x80000
	// Position of TOUCH_APPROACH_PAD2 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD2_Pos = 0x14
	// Bit mask of TOUCH_APPROACH_PAD2 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD2_Msk = 0xf00000
	// Position of TOUCH_APPROACH_PAD1 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD1_Pos = 0x18
	// Bit mask of TOUCH_APPROACH_PAD1 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD1_Msk = 0xf000000
	// Position of TOUCH_APPROACH_PAD0 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD0_Pos = 0x1c
	// Bit mask of TOUCH_APPROACH_PAD0 field.
	SENS_SAR_TOUCH_CONF_TOUCH_APPROACH_PAD0_Msk = 0xf0000000

	// SAR_TOUCH_THRES1: Finger threshold for touch pad 1
	// Position of TOUCH_OUT_TH1 field.
	SENS_SAR_TOUCH_THRES1_TOUCH_OUT_TH1_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH1 field.
	SENS_SAR_TOUCH_THRES1_TOUCH_OUT_TH1_Msk = 0x3fffff

	// SAR_TOUCH_THRES2: Finger threshold for touch pad 2
	// Position of TOUCH_OUT_TH2 field.
	SENS_SAR_TOUCH_THRES2_TOUCH_OUT_TH2_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH2 field.
	SENS_SAR_TOUCH_THRES2_TOUCH_OUT_TH2_Msk = 0x3fffff

	// SAR_TOUCH_THRES3: Finger threshold for touch pad 3
	// Position of TOUCH_OUT_TH3 field.
	SENS_SAR_TOUCH_THRES3_TOUCH_OUT_TH3_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH3 field.
	SENS_SAR_TOUCH_THRES3_TOUCH_OUT_TH3_Msk = 0x3fffff

	// SAR_TOUCH_THRES4: Finger threshold for touch pad 4
	// Position of TOUCH_OUT_TH4 field.
	SENS_SAR_TOUCH_THRES4_TOUCH_OUT_TH4_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH4 field.
	SENS_SAR_TOUCH_THRES4_TOUCH_OUT_TH4_Msk = 0x3fffff

	// SAR_TOUCH_THRES5: Finger threshold for touch pad 5
	// Position of TOUCH_OUT_TH5 field.
	SENS_SAR_TOUCH_THRES5_TOUCH_OUT_TH5_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH5 field.
	SENS_SAR_TOUCH_THRES5_TOUCH_OUT_TH5_Msk = 0x3fffff

	// SAR_TOUCH_THRES6: Finger threshold for touch pad 6
	// Position of TOUCH_OUT_TH6 field.
	SENS_SAR_TOUCH_THRES6_TOUCH_OUT_TH6_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH6 field.
	SENS_SAR_TOUCH_THRES6_TOUCH_OUT_TH6_Msk = 0x3fffff

	// SAR_TOUCH_THRES7: Finger threshold for touch pad 7
	// Position of TOUCH_OUT_TH7 field.
	SENS_SAR_TOUCH_THRES7_TOUCH_OUT_TH7_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH7 field.
	SENS_SAR_TOUCH_THRES7_TOUCH_OUT_TH7_Msk = 0x3fffff

	// SAR_TOUCH_THRES8: Finger threshold for touch pad 8
	// Position of TOUCH_OUT_TH8 field.
	SENS_SAR_TOUCH_THRES8_TOUCH_OUT_TH8_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH8 field.
	SENS_SAR_TOUCH_THRES8_TOUCH_OUT_TH8_Msk = 0x3fffff

	// SAR_TOUCH_THRES9: Finger threshold for touch pad 9
	// Position of TOUCH_OUT_TH9 field.
	SENS_SAR_TOUCH_THRES9_TOUCH_OUT_TH9_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH9 field.
	SENS_SAR_TOUCH_THRES9_TOUCH_OUT_TH9_Msk = 0x3fffff

	// SAR_TOUCH_THRES10: Finger threshold for touch pad 10
	// Position of TOUCH_OUT_TH10 field.
	SENS_SAR_TOUCH_THRES10_TOUCH_OUT_TH10_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH10 field.
	SENS_SAR_TOUCH_THRES10_TOUCH_OUT_TH10_Msk = 0x3fffff

	// SAR_TOUCH_THRES11: Finger threshold for touch pad 11
	// Position of TOUCH_OUT_TH11 field.
	SENS_SAR_TOUCH_THRES11_TOUCH_OUT_TH11_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH11 field.
	SENS_SAR_TOUCH_THRES11_TOUCH_OUT_TH11_Msk = 0x3fffff

	// SAR_TOUCH_THRES12: Finger threshold for touch pad 12
	// Position of TOUCH_OUT_TH12 field.
	SENS_SAR_TOUCH_THRES12_TOUCH_OUT_TH12_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH12 field.
	SENS_SAR_TOUCH_THRES12_TOUCH_OUT_TH12_Msk = 0x3fffff

	// SAR_TOUCH_THRES13: Finger threshold for touch pad 13
	// Position of TOUCH_OUT_TH13 field.
	SENS_SAR_TOUCH_THRES13_TOUCH_OUT_TH13_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH13 field.
	SENS_SAR_TOUCH_THRES13_TOUCH_OUT_TH13_Msk = 0x3fffff

	// SAR_TOUCH_THRES14: Finger threshold for touch pad 14
	// Position of TOUCH_OUT_TH14 field.
	SENS_SAR_TOUCH_THRES14_TOUCH_OUT_TH14_Pos = 0x0
	// Bit mask of TOUCH_OUT_TH14 field.
	SENS_SAR_TOUCH_THRES14_TOUCH_OUT_TH14_Msk = 0x3fffff

	// SAR_TOUCH_CHN_ST: Touch channel status register
	// Position of TOUCH_PAD_ACTIVE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE_Pos = 0x0
	// Bit mask of TOUCH_PAD_ACTIVE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_PAD_ACTIVE_Msk = 0x7fff
	// Position of TOUCH_CHANNEL_CLR field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR_Pos = 0xf
	// Bit mask of TOUCH_CHANNEL_CLR field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_CHANNEL_CLR_Msk = 0x3fff8000
	// Position of TOUCH_MEAS_DONE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE_Pos = 0x1f
	// Bit mask of TOUCH_MEAS_DONE field.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE_Msk = 0x80000000
	// Bit TOUCH_MEAS_DONE.
	SENS_SAR_TOUCH_CHN_ST_TOUCH_MEAS_DONE = 0x80000000

	// SAR_TOUCH_STATUS0: Status of touch controller
	// Position of TOUCH_DENOISE_DATA field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA_Pos = 0x0
	// Bit mask of TOUCH_DENOISE_DATA field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_DENOISE_DATA_Msk = 0x3fffff
	// Position of TOUCH_SCAN_CURR field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_SCAN_CURR_Pos = 0x16
	// Bit mask of TOUCH_SCAN_CURR field.
	SENS_SAR_TOUCH_STATUS0_TOUCH_SCAN_CURR_Msk = 0x3c00000

	// SAR_TOUCH_STATUS1: Touch pad 1 status
	// Position of TOUCH_PAD1_DATA field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD1_DATA field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD1_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD1_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS1_TOUCH_PAD1_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS2: Touch pad 2 status
	// Position of TOUCH_PAD2_DATA field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD2_DATA field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD2_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD2_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS2_TOUCH_PAD2_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS3: Touch pad 3 status
	// Position of TOUCH_PAD3_DATA field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD3_DATA field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD3_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD3_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS3_TOUCH_PAD3_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS4: Touch pad 4 status
	// Position of TOUCH_PAD4_DATA field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD4_DATA field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD4_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD4_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS4_TOUCH_PAD4_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS5: Touch pad 5 status
	// Position of TOUCH_PAD5_DATA field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD5_DATA field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD5_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD5_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS5_TOUCH_PAD5_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS6: Touch pad 6 status
	// Position of TOUCH_PAD6_DATA field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD6_DATA field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD6_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD6_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS6_TOUCH_PAD6_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS7: Touch pad 7 status
	// Position of TOUCH_PAD7_DATA field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD7_DATA field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD7_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD7_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS7_TOUCH_PAD7_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS8: Touch pad 8 status
	// Position of TOUCH_PAD8_DATA field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD8_DATA field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD8_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD8_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS8_TOUCH_PAD8_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS9: Touch pad 9 status
	// Position of TOUCH_PAD9_DATA field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD9_DATA field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD9_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD9_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS9_TOUCH_PAD9_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS10: Touch pad 10 status
	// Position of TOUCH_PAD10_DATA field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD10_DATA field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD10_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD10_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS10_TOUCH_PAD10_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS11: Touch pad 11 status
	// Position of TOUCH_PAD11_DATA field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD11_DATA field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD11_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD11_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS11_TOUCH_PAD11_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS12: Touch pad 12 status
	// Position of TOUCH_PAD12_DATA field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD12_DATA field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD12_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD12_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS12_TOUCH_PAD12_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS13: Touch pad 13 status
	// Position of TOUCH_PAD13_DATA field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD13_DATA field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD13_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD13_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS13_TOUCH_PAD13_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS14: Touch pad 14 status
	// Position of TOUCH_PAD14_DATA field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DATA_Pos = 0x0
	// Bit mask of TOUCH_PAD14_DATA field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DATA_Msk = 0x3fffff
	// Position of TOUCH_PAD14_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_PAD14_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS14_TOUCH_PAD14_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS15: Touch sleep pad status
	// Position of TOUCH_SLP_DATA field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DATA_Pos = 0x0
	// Bit mask of TOUCH_SLP_DATA field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DATA_Msk = 0x3fffff
	// Position of TOUCH_SLP_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE_Pos = 0x1d
	// Bit mask of TOUCH_SLP_DEBOUNCE field.
	SENS_SAR_TOUCH_STATUS15_TOUCH_SLP_DEBOUNCE_Msk = 0xe0000000

	// SAR_TOUCH_STATUS16: Touch approach count status
	// Position of TOUCH_APPROACH_PAD2_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT_Pos = 0x0
	// Bit mask of TOUCH_APPROACH_PAD2_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD2_CNT_Msk = 0xff
	// Position of TOUCH_APPROACH_PAD1_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT_Pos = 0x8
	// Bit mask of TOUCH_APPROACH_PAD1_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD1_CNT_Msk = 0xff00
	// Position of TOUCH_APPROACH_PAD0_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT_Pos = 0x10
	// Bit mask of TOUCH_APPROACH_PAD0_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_APPROACH_PAD0_CNT_Msk = 0xff0000
	// Position of TOUCH_SLP_APPROACH_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT_Pos = 0x18
	// Bit mask of TOUCH_SLP_APPROACH_CNT field.
	SENS_SAR_TOUCH_STATUS16_TOUCH_SLP_APPROACH_CNT_Msk = 0xff000000

	// SAR_DAC_CTRL1: DAC control
	// Position of SW_FSTEP field.
	SENS_SAR_DAC_CTRL1_SW_FSTEP_Pos = 0x0
	// Bit mask of SW_FSTEP field.
	SENS_SAR_DAC_CTRL1_SW_FSTEP_Msk = 0xffff
	// Position of SW_TONE_EN field.
	SENS_SAR_DAC_CTRL1_SW_TONE_EN_Pos = 0x10
	// Bit mask of SW_TONE_EN field.
	SENS_SAR_DAC_CTRL1_SW_TONE_EN_Msk = 0x10000
	// Bit SW_TONE_EN.
	SENS_SAR_DAC_CTRL1_SW_TONE_EN = 0x10000
	// Position of DEBUG_BIT_SEL field.
	SENS_SAR_DAC_CTRL1_DEBUG_BIT_SEL_Pos = 0x11
	// Bit mask of DEBUG_BIT_SEL field.
	SENS_SAR_DAC_CTRL1_DEBUG_BIT_SEL_Msk = 0x3e0000
	// Position of DAC_DIG_FORCE field.
	SENS_SAR_DAC_CTRL1_DAC_DIG_FORCE_Pos = 0x16
	// Bit mask of DAC_DIG_FORCE field.
	SENS_SAR_DAC_CTRL1_DAC_DIG_FORCE_Msk = 0x400000
	// Bit DAC_DIG_FORCE.
	SENS_SAR_DAC_CTRL1_DAC_DIG_FORCE = 0x400000
	// Position of DAC_CLK_FORCE_LOW field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_LOW_Pos = 0x17
	// Bit mask of DAC_CLK_FORCE_LOW field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_LOW_Msk = 0x800000
	// Bit DAC_CLK_FORCE_LOW.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_LOW = 0x800000
	// Position of DAC_CLK_FORCE_HIGH field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH_Pos = 0x18
	// Bit mask of DAC_CLK_FORCE_HIGH field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH_Msk = 0x1000000
	// Bit DAC_CLK_FORCE_HIGH.
	SENS_SAR_DAC_CTRL1_DAC_CLK_FORCE_HIGH = 0x1000000
	// Position of DAC_CLK_INV field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_INV_Pos = 0x19
	// Bit mask of DAC_CLK_INV field.
	SENS_SAR_DAC_CTRL1_DAC_CLK_INV_Msk = 0x2000000
	// Bit DAC_CLK_INV.
	SENS_SAR_DAC_CTRL1_DAC_CLK_INV = 0x2000000
	// Position of DAC_RESET field.
	SENS_SAR_DAC_CTRL1_DAC_RESET_Pos = 0x1a
	// Bit mask of DAC_RESET field.
	SENS_SAR_DAC_CTRL1_DAC_RESET_Msk = 0x4000000
	// Bit DAC_RESET.
	SENS_SAR_DAC_CTRL1_DAC_RESET = 0x4000000
	// Position of DAC_CLKGATE_EN field.
	SENS_SAR_DAC_CTRL1_DAC_CLKGATE_EN_Pos = 0x1b
	// Bit mask of DAC_CLKGATE_EN field.
	SENS_SAR_DAC_CTRL1_DAC_CLKGATE_EN_Msk = 0x8000000
	// Bit DAC_CLKGATE_EN.
	SENS_SAR_DAC_CTRL1_DAC_CLKGATE_EN = 0x8000000

	// SAR_DAC_CTRL2: DAC output control
	// Position of DAC_DC1 field.
	SENS_SAR_DAC_CTRL2_DAC_DC1_Pos = 0x0
	// Bit mask of DAC_DC1 field.
	SENS_SAR_DAC_CTRL2_DAC_DC1_Msk = 0xff
	// Position of DAC_DC2 field.
	SENS_SAR_DAC_CTRL2_DAC_DC2_Pos = 0x8
	// Bit mask of DAC_DC2 field.
	SENS_SAR_DAC_CTRL2_DAC_DC2_Msk = 0xff00
	// Position of DAC_SCALE1 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE1_Pos = 0x10
	// Bit mask of DAC_SCALE1 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE1_Msk = 0x30000
	// Position of DAC_SCALE2 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE2_Pos = 0x12
	// Bit mask of DAC_SCALE2 field.
	SENS_SAR_DAC_CTRL2_DAC_SCALE2_Msk = 0xc0000
	// Position of DAC_INV1 field.
	SENS_SAR_DAC_CTRL2_DAC_INV1_Pos = 0x14
	// Bit mask of DAC_INV1 field.
	SENS_SAR_DAC_CTRL2_DAC_INV1_Msk = 0x300000
	// Position of DAC_INV2 field.
	SENS_SAR_DAC_CTRL2_DAC_INV2_Pos = 0x16
	// Bit mask of DAC_INV2 field.
	SENS_SAR_DAC_CTRL2_DAC_INV2_Msk = 0xc00000
	// Position of DAC_CW_EN1 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN1_Pos = 0x18
	// Bit mask of DAC_CW_EN1 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN1_Msk = 0x1000000
	// Bit DAC_CW_EN1.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN1 = 0x1000000
	// Position of DAC_CW_EN2 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN2_Pos = 0x19
	// Bit mask of DAC_CW_EN2 field.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN2_Msk = 0x2000000
	// Bit DAC_CW_EN2.
	SENS_SAR_DAC_CTRL2_DAC_CW_EN2 = 0x2000000

	// SAR_COCPU_STATE: ULP-RISCV status
	// Position of COCPU_DBG_TRIGGER field.
	SENS_SAR_COCPU_STATE_COCPU_DBG_TRIGGER_Pos = 0x19
	// Bit mask of COCPU_DBG_TRIGGER field.
	SENS_SAR_COCPU_STATE_COCPU_DBG_TRIGGER_Msk = 0x2000000
	// Bit COCPU_DBG_TRIGGER.
	SENS_SAR_COCPU_STATE_COCPU_DBG_TRIGGER = 0x2000000
	// Position of COCPU_CLK_EN field.
	SENS_SAR_COCPU_STATE_COCPU_CLK_EN_Pos = 0x1a
	// Bit mask of COCPU_CLK_EN field.
	SENS_SAR_COCPU_STATE_COCPU_CLK_EN_Msk = 0x4000000
	// Bit COCPU_CLK_EN.
	SENS_SAR_COCPU_STATE_COCPU_CLK_EN = 0x4000000
	// Position of COCPU_RESET_N field.
	SENS_SAR_COCPU_STATE_COCPU_RESET_N_Pos = 0x1b
	// Bit mask of COCPU_RESET_N field.
	SENS_SAR_COCPU_STATE_COCPU_RESET_N_Msk = 0x8000000
	// Bit COCPU_RESET_N.
	SENS_SAR_COCPU_STATE_COCPU_RESET_N = 0x8000000
	// Position of COCPU_EOI field.
	SENS_SAR_COCPU_STATE_COCPU_EOI_Pos = 0x1c
	// Bit mask of COCPU_EOI field.
	SENS_SAR_COCPU_STATE_COCPU_EOI_Msk = 0x10000000
	// Bit COCPU_EOI.
	SENS_SAR_COCPU_STATE_COCPU_EOI = 0x10000000
	// Position of COCPU_TRAP field.
	SENS_SAR_COCPU_STATE_COCPU_TRAP_Pos = 0x1d
	// Bit mask of COCPU_TRAP field.
	SENS_SAR_COCPU_STATE_COCPU_TRAP_Msk = 0x20000000
	// Bit COCPU_TRAP.
	SENS_SAR_COCPU_STATE_COCPU_TRAP = 0x20000000
	// Position of COCPU_EBREAK field.
	SENS_SAR_COCPU_STATE_COCPU_EBREAK_Pos = 0x1e
	// Bit mask of COCPU_EBREAK field.
	SENS_SAR_COCPU_STATE_COCPU_EBREAK_Msk = 0x40000000
	// Bit COCPU_EBREAK.
	SENS_SAR_COCPU_STATE_COCPU_EBREAK = 0x40000000

	// SAR_COCPU_INT_RAW: Interrupt raw bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_DONE_INT_RAW = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_INACTIVE_INT_RAW = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TOUCH_ACTIVE_INT_RAW = 0x4
	// Position of COCPU_SARADC1_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW_Msk = 0x8
	// Bit COCPU_SARADC1_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC1_INT_RAW = 0x8
	// Position of COCPU_SARADC2_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW_Msk = 0x10
	// Bit COCPU_SARADC2_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SARADC2_INT_RAW = 0x10
	// Position of COCPU_TSENS_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW_Msk = 0x20
	// Bit COCPU_TSENS_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_TSENS_INT_RAW = 0x20
	// Position of COCPU_START_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_START_INT_RAW_Pos = 0x6
	// Bit mask of COCPU_START_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_START_INT_RAW_Msk = 0x40
	// Bit COCPU_START_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_START_INT_RAW = 0x40
	// Position of COCPU_SW_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SW_INT_RAW_Pos = 0x7
	// Bit mask of COCPU_SW_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SW_INT_RAW_Msk = 0x80
	// Bit COCPU_SW_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SW_INT_RAW = 0x80
	// Position of COCPU_SWD_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_RAW field.
	SENS_SAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW_Msk = 0x100
	// Bit COCPU_SWD_INT_RAW.
	SENS_SAR_COCPU_INT_RAW_COCPU_SWD_INT_RAW = 0x100

	// SAR_COCPU_INT_ENA: Interrupt enable bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_DONE_INT_ENA = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_INACTIVE_INT_ENA = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TOUCH_ACTIVE_INT_ENA = 0x4
	// Position of COCPU_SARADC1_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA_Msk = 0x8
	// Bit COCPU_SARADC1_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC1_INT_ENA = 0x8
	// Position of COCPU_SARADC2_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA_Msk = 0x10
	// Bit COCPU_SARADC2_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SARADC2_INT_ENA = 0x10
	// Position of COCPU_TSENS_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA_Msk = 0x20
	// Bit COCPU_TSENS_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_TSENS_INT_ENA = 0x20
	// Position of COCPU_START_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_START_INT_ENA_Pos = 0x6
	// Bit mask of COCPU_START_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_START_INT_ENA_Msk = 0x40
	// Bit COCPU_START_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_START_INT_ENA = 0x40
	// Position of COCPU_SW_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SW_INT_ENA_Pos = 0x7
	// Bit mask of COCPU_SW_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SW_INT_ENA_Msk = 0x80
	// Bit COCPU_SW_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SW_INT_ENA = 0x80
	// Position of COCPU_SWD_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_ENA field.
	SENS_SAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA_Msk = 0x100
	// Bit COCPU_SWD_INT_ENA.
	SENS_SAR_COCPU_INT_ENA_COCPU_SWD_INT_ENA = 0x100

	// SAR_COCPU_INT_ST: Interrupt status bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_DONE_INT_ST = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_INACTIVE_INT_ST = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TOUCH_ACTIVE_INT_ST = 0x4
	// Position of COCPU_SARADC1_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST_Msk = 0x8
	// Bit COCPU_SARADC1_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC1_INT_ST = 0x8
	// Position of COCPU_SARADC2_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST_Msk = 0x10
	// Bit COCPU_SARADC2_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SARADC2_INT_ST = 0x10
	// Position of COCPU_TSENS_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TSENS_INT_ST_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_TSENS_INT_ST_Msk = 0x20
	// Bit COCPU_TSENS_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_TSENS_INT_ST = 0x20
	// Position of COCPU_START_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_START_INT_ST_Pos = 0x6
	// Bit mask of COCPU_START_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_START_INT_ST_Msk = 0x40
	// Bit COCPU_START_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_START_INT_ST = 0x40
	// Position of COCPU_SW_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SW_INT_ST_Pos = 0x7
	// Bit mask of COCPU_SW_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SW_INT_ST_Msk = 0x80
	// Bit COCPU_SW_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SW_INT_ST = 0x80
	// Position of COCPU_SWD_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SWD_INT_ST_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_ST field.
	SENS_SAR_COCPU_INT_ST_COCPU_SWD_INT_ST_Msk = 0x100
	// Bit COCPU_SWD_INT_ST.
	SENS_SAR_COCPU_INT_ST_COCPU_SWD_INT_ST = 0x100

	// SAR_COCPU_INT_CLR: Interrupt clear bit of ULP-RISCV
	// Position of COCPU_TOUCH_DONE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR_Pos = 0x0
	// Bit mask of COCPU_TOUCH_DONE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR_Msk = 0x1
	// Bit COCPU_TOUCH_DONE_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_DONE_INT_CLR = 0x1
	// Position of COCPU_TOUCH_INACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR_Pos = 0x1
	// Bit mask of COCPU_TOUCH_INACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR_Msk = 0x2
	// Bit COCPU_TOUCH_INACTIVE_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_INACTIVE_INT_CLR = 0x2
	// Position of COCPU_TOUCH_ACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR_Pos = 0x2
	// Bit mask of COCPU_TOUCH_ACTIVE_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR_Msk = 0x4
	// Bit COCPU_TOUCH_ACTIVE_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TOUCH_ACTIVE_INT_CLR = 0x4
	// Position of COCPU_SARADC1_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR_Pos = 0x3
	// Bit mask of COCPU_SARADC1_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR_Msk = 0x8
	// Bit COCPU_SARADC1_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC1_INT_CLR = 0x8
	// Position of COCPU_SARADC2_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR_Pos = 0x4
	// Bit mask of COCPU_SARADC2_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR_Msk = 0x10
	// Bit COCPU_SARADC2_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SARADC2_INT_CLR = 0x10
	// Position of COCPU_TSENS_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR_Pos = 0x5
	// Bit mask of COCPU_TSENS_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR_Msk = 0x20
	// Bit COCPU_TSENS_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_TSENS_INT_CLR = 0x20
	// Position of COCPU_START_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_START_INT_CLR_Pos = 0x6
	// Bit mask of COCPU_START_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_START_INT_CLR_Msk = 0x40
	// Bit COCPU_START_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_START_INT_CLR = 0x40
	// Position of COCPU_SW_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SW_INT_CLR_Pos = 0x7
	// Bit mask of COCPU_SW_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SW_INT_CLR_Msk = 0x80
	// Bit COCPU_SW_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SW_INT_CLR = 0x80
	// Position of COCPU_SWD_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR_Pos = 0x8
	// Bit mask of COCPU_SWD_INT_CLR field.
	SENS_SAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR_Msk = 0x100
	// Bit COCPU_SWD_INT_CLR.
	SENS_SAR_COCPU_INT_CLR_COCPU_SWD_INT_CLR = 0x100

	// SAR_COCPU_DEBUG: ULP-RISCV debug register
	// Position of COCPU_PC field.
	SENS_SAR_COCPU_DEBUG_COCPU_PC_Pos = 0x0
	// Bit mask of COCPU_PC field.
	SENS_SAR_COCPU_DEBUG_COCPU_PC_Msk = 0x1fff
	// Position of COCPU_MEM_VLD field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_VLD_Pos = 0xd
	// Bit mask of COCPU_MEM_VLD field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_VLD_Msk = 0x2000
	// Bit COCPU_MEM_VLD.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_VLD = 0x2000
	// Position of COCPU_MEM_RDY field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_RDY_Pos = 0xe
	// Bit mask of COCPU_MEM_RDY field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_RDY_Msk = 0x4000
	// Bit COCPU_MEM_RDY.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_RDY = 0x4000
	// Position of COCPU_MEM_WEN field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_WEN_Pos = 0xf
	// Bit mask of COCPU_MEM_WEN field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_WEN_Msk = 0x78000
	// Position of COCPU_MEM_ADDR field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_ADDR_Pos = 0x13
	// Bit mask of COCPU_MEM_ADDR field.
	SENS_SAR_COCPU_DEBUG_COCPU_MEM_ADDR_Msk = 0xfff80000

	// SAR_HALL_CTRL: hall control
	// Position of XPD_HALL field.
	SENS_SAR_HALL_CTRL_XPD_HALL_Pos = 0x1c
	// Bit mask of XPD_HALL field.
	SENS_SAR_HALL_CTRL_XPD_HALL_Msk = 0x10000000
	// Bit XPD_HALL.
	SENS_SAR_HALL_CTRL_XPD_HALL = 0x10000000
	// Position of XPD_HALL_FORCE field.
	SENS_SAR_HALL_CTRL_XPD_HALL_FORCE_Pos = 0x1d
	// Bit mask of XPD_HALL_FORCE field.
	SENS_SAR_HALL_CTRL_XPD_HALL_FORCE_Msk = 0x20000000
	// Bit XPD_HALL_FORCE.
	SENS_SAR_HALL_CTRL_XPD_HALL_FORCE = 0x20000000
	// Position of HALL_PHASE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_Pos = 0x1e
	// Bit mask of HALL_PHASE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_Msk = 0x40000000
	// Bit HALL_PHASE.
	SENS_SAR_HALL_CTRL_HALL_PHASE = 0x40000000
	// Position of HALL_PHASE_FORCE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_FORCE_Pos = 0x1f
	// Bit mask of HALL_PHASE_FORCE field.
	SENS_SAR_HALL_CTRL_HALL_PHASE_FORCE_Msk = 0x80000000
	// Bit HALL_PHASE_FORCE.
	SENS_SAR_HALL_CTRL_HALL_PHASE_FORCE = 0x80000000

	// SAR_NOUSE: sar nouse
	// Position of SAR_NOUSE field.
	SENS_SAR_NOUSE_SAR_NOUSE_Pos = 0x0
	// Bit mask of SAR_NOUSE field.
	SENS_SAR_NOUSE_SAR_NOUSE_Msk = 0xffffffff

	// SAR_IO_MUX_CONF: Configure and reset IO MUX
	// Position of IOMUX_RESET field.
	SENS_SAR_IO_MUX_CONF_IOMUX_RESET_Pos = 0x1e
	// Bit mask of IOMUX_RESET field.
	SENS_SAR_IO_MUX_CONF_IOMUX_RESET_Msk = 0x40000000
	// Bit IOMUX_RESET.
	SENS_SAR_IO_MUX_CONF_IOMUX_RESET = 0x40000000
	// Position of IOMUX_CLK_GATE_EN field.
	SENS_SAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN_Pos = 0x1f
	// Bit mask of IOMUX_CLK_GATE_EN field.
	SENS_SAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN_Msk = 0x80000000
	// Bit IOMUX_CLK_GATE_EN.
	SENS_SAR_IO_MUX_CONF_IOMUX_CLK_GATE_EN = 0x80000000

	// SARDATE: Version Control Register
	// Position of SAR_DATE field.
	SENS_SARDATE_SAR_DATE_Pos = 0x0
	// Bit mask of SAR_DATE field.
	SENS_SARDATE_SAR_DATE_Msk = 0xfffffff
)

// Constants for SHA: SHA (Secure Hash Algorithm) Accelerator
const (
	// MODE: Defines the algorithm of SHA accelerator
	// Position of MODE field.
	SHA_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SHA_MODE_MODE_Msk = 0x7

	// T_STRING: String content register for calculating initial Hash Value (only effective for SHA-512/t)
	// Position of T_STRING field.
	SHA_T_STRING_T_STRING_Pos = 0x0
	// Bit mask of T_STRING field.
	SHA_T_STRING_T_STRING_Msk = 0xffffffff

	// T_LENGTH: String length register for calculating initial Hash Value (only effective for SHA-512/t)
	// Position of T_LENGTH field.
	SHA_T_LENGTH_T_LENGTH_Pos = 0x0
	// Bit mask of T_LENGTH field.
	SHA_T_LENGTH_T_LENGTH_Msk = 0x3f

	// DMA_BLOCK_NUM: Block number register (only effective for DMA-SHA)
	// Position of DMA_BLOCK_NUM field.
	SHA_DMA_BLOCK_NUM_DMA_BLOCK_NUM_Pos = 0x0
	// Bit mask of DMA_BLOCK_NUM field.
	SHA_DMA_BLOCK_NUM_DMA_BLOCK_NUM_Msk = 0x3f

	// START: Starts the SHA accelerator for Typical SHA operation
	// Position of START field.
	SHA_START_START_Pos = 0x0
	// Bit mask of START field.
	SHA_START_START_Msk = 0x1
	// Bit START.
	SHA_START_START = 0x1

	// CONTINUE: Continues SHA operation (only effective in Typical SHA mode)
	// Position of CONTINUE_OP field.
	SHA_CONTINUE_CONTINUE_OP_Pos = 0x0
	// Bit mask of CONTINUE_OP field.
	SHA_CONTINUE_CONTINUE_OP_Msk = 0x1
	// Bit CONTINUE_OP.
	SHA_CONTINUE_CONTINUE_OP = 0x1

	// BUSY: Indicates if SHA Accelerator is busy or not
	// Position of STATE field.
	SHA_BUSY_STATE_Pos = 0x0
	// Bit mask of STATE field.
	SHA_BUSY_STATE_Msk = 0x1
	// Bit STATE.
	SHA_BUSY_STATE = 0x1

	// DMA_START: Starts the SHA accelerator for DMA-SHA operation
	// Position of DMA_START field.
	SHA_DMA_START_DMA_START_Pos = 0x0
	// Bit mask of DMA_START field.
	SHA_DMA_START_DMA_START_Msk = 0x1
	// Bit DMA_START.
	SHA_DMA_START_DMA_START = 0x1

	// DMA_CONTINUE: Continues SHA operation (only effective in DMA-SHA mode)
	// Position of DMA_CONTINUE field.
	SHA_DMA_CONTINUE_DMA_CONTINUE_Pos = 0x0
	// Bit mask of DMA_CONTINUE field.
	SHA_DMA_CONTINUE_DMA_CONTINUE_Msk = 0x1
	// Bit DMA_CONTINUE.
	SHA_DMA_CONTINUE_DMA_CONTINUE = 0x1

	// INT_CLEAR: DMA-SHA interrupt clear register
	// Position of CLEAR_INTERRUPT field.
	SHA_INT_CLEAR_CLEAR_INTERRUPT_Pos = 0x0
	// Bit mask of CLEAR_INTERRUPT field.
	SHA_INT_CLEAR_CLEAR_INTERRUPT_Msk = 0x1
	// Bit CLEAR_INTERRUPT.
	SHA_INT_CLEAR_CLEAR_INTERRUPT = 0x1

	// INT_ENA: DMA-SHA interrupt enable register
	// Position of INTERRUPT_ENA field.
	SHA_INT_ENA_INTERRUPT_ENA_Pos = 0x0
	// Bit mask of INTERRUPT_ENA field.
	SHA_INT_ENA_INTERRUPT_ENA_Msk = 0x1
	// Bit INTERRUPT_ENA.
	SHA_INT_ENA_INTERRUPT_ENA = 0x1

	// DATE: Version control register
	// Position of DATE field.
	SHA_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SHA_DATE_DATE_Msk = 0x3fffffff

	// H_MEM0: Hash value
	// Position of H field.
	SHA_H_MEM_H_Pos = 0x0
	// Bit mask of H field.
	SHA_H_MEM_H_Msk = 0xffffffff

	// M_MEM0: Message
	// Position of M field.
	SHA_M_MEM_M_Pos = 0x0
	// Bit mask of M field.
	SHA_M_MEM_M_Msk = 0xffffffff
)

// Constants for SPI0: SPI (Serial Peripheral Interface) Controller 0
const (
	// CMD: Command control register
	// Position of CONF_BITLEN field.
	SPI_CMD_CONF_BITLEN_Pos = 0x0
	// Bit mask of CONF_BITLEN field.
	SPI_CMD_CONF_BITLEN_Msk = 0x7fffff
	// Position of USR field.
	SPI_CMD_USR_Pos = 0x18
	// Bit mask of USR field.
	SPI_CMD_USR_Msk = 0x1000000
	// Bit USR.
	SPI_CMD_USR = 0x1000000

	// ADDR: Address value
	// Position of USR_ADDR_VALUE field.
	SPI_ADDR_USR_ADDR_VALUE_Pos = 0x0
	// Bit mask of USR_ADDR_VALUE field.
	SPI_ADDR_USR_ADDR_VALUE_Msk = 0xffffffff

	// CTRL: SPI control register
	// Position of EXT_HOLD_EN field.
	SPI_CTRL_EXT_HOLD_EN_Pos = 0x2
	// Bit mask of EXT_HOLD_EN field.
	SPI_CTRL_EXT_HOLD_EN_Msk = 0x4
	// Bit EXT_HOLD_EN.
	SPI_CTRL_EXT_HOLD_EN = 0x4
	// Position of DUMMY_OUT field.
	SPI_CTRL_DUMMY_OUT_Pos = 0x3
	// Bit mask of DUMMY_OUT field.
	SPI_CTRL_DUMMY_OUT_Msk = 0x8
	// Bit DUMMY_OUT.
	SPI_CTRL_DUMMY_OUT = 0x8
	// Position of FADDR_DUAL field.
	SPI_CTRL_FADDR_DUAL_Pos = 0x5
	// Bit mask of FADDR_DUAL field.
	SPI_CTRL_FADDR_DUAL_Msk = 0x20
	// Bit FADDR_DUAL.
	SPI_CTRL_FADDR_DUAL = 0x20
	// Position of FADDR_QUAD field.
	SPI_CTRL_FADDR_QUAD_Pos = 0x6
	// Bit mask of FADDR_QUAD field.
	SPI_CTRL_FADDR_QUAD_Msk = 0x40
	// Bit FADDR_QUAD.
	SPI_CTRL_FADDR_QUAD = 0x40
	// Position of FADDR_OCT field.
	SPI_CTRL_FADDR_OCT_Pos = 0x7
	// Bit mask of FADDR_OCT field.
	SPI_CTRL_FADDR_OCT_Msk = 0x80
	// Bit FADDR_OCT.
	SPI_CTRL_FADDR_OCT = 0x80
	// Position of FCMD_DUAL field.
	SPI_CTRL_FCMD_DUAL_Pos = 0x8
	// Bit mask of FCMD_DUAL field.
	SPI_CTRL_FCMD_DUAL_Msk = 0x100
	// Bit FCMD_DUAL.
	SPI_CTRL_FCMD_DUAL = 0x100
	// Position of FCMD_QUAD field.
	SPI_CTRL_FCMD_QUAD_Pos = 0x9
	// Bit mask of FCMD_QUAD field.
	SPI_CTRL_FCMD_QUAD_Msk = 0x200
	// Bit FCMD_QUAD.
	SPI_CTRL_FCMD_QUAD = 0x200
	// Position of FCMD_OCT field.
	SPI_CTRL_FCMD_OCT_Pos = 0xa
	// Bit mask of FCMD_OCT field.
	SPI_CTRL_FCMD_OCT_Msk = 0x400
	// Bit FCMD_OCT.
	SPI_CTRL_FCMD_OCT = 0x400
	// Position of FREAD_DUAL field.
	SPI_CTRL_FREAD_DUAL_Pos = 0xe
	// Bit mask of FREAD_DUAL field.
	SPI_CTRL_FREAD_DUAL_Msk = 0x4000
	// Bit FREAD_DUAL.
	SPI_CTRL_FREAD_DUAL = 0x4000
	// Position of FREAD_QUAD field.
	SPI_CTRL_FREAD_QUAD_Pos = 0xf
	// Bit mask of FREAD_QUAD field.
	SPI_CTRL_FREAD_QUAD_Msk = 0x8000
	// Bit FREAD_QUAD.
	SPI_CTRL_FREAD_QUAD = 0x8000
	// Position of FREAD_OCT field.
	SPI_CTRL_FREAD_OCT_Pos = 0x10
	// Bit mask of FREAD_OCT field.
	SPI_CTRL_FREAD_OCT_Msk = 0x10000
	// Bit FREAD_OCT.
	SPI_CTRL_FREAD_OCT = 0x10000
	// Position of Q_POL field.
	SPI_CTRL_Q_POL_Pos = 0x12
	// Bit mask of Q_POL field.
	SPI_CTRL_Q_POL_Msk = 0x40000
	// Bit Q_POL.
	SPI_CTRL_Q_POL = 0x40000
	// Position of D_POL field.
	SPI_CTRL_D_POL_Pos = 0x13
	// Bit mask of D_POL field.
	SPI_CTRL_D_POL_Msk = 0x80000
	// Bit D_POL.
	SPI_CTRL_D_POL = 0x80000
	// Position of WP field.
	SPI_CTRL_WP_Pos = 0x15
	// Bit mask of WP field.
	SPI_CTRL_WP_Msk = 0x200000
	// Bit WP.
	SPI_CTRL_WP = 0x200000
	// Position of RD_BIT_ORDER field.
	SPI_CTRL_RD_BIT_ORDER_Pos = 0x19
	// Bit mask of RD_BIT_ORDER field.
	SPI_CTRL_RD_BIT_ORDER_Msk = 0x2000000
	// Bit RD_BIT_ORDER.
	SPI_CTRL_RD_BIT_ORDER = 0x2000000
	// Position of WR_BIT_ORDER field.
	SPI_CTRL_WR_BIT_ORDER_Pos = 0x1a
	// Bit mask of WR_BIT_ORDER field.
	SPI_CTRL_WR_BIT_ORDER_Msk = 0x4000000
	// Bit WR_BIT_ORDER.
	SPI_CTRL_WR_BIT_ORDER = 0x4000000

	// CTRL1: SPI control register 1
	// Position of CLK_MODE field.
	SPI_CTRL1_CLK_MODE_Pos = 0x0
	// Bit mask of CLK_MODE field.
	SPI_CTRL1_CLK_MODE_Msk = 0x3
	// Position of CLK_MODE_13 field.
	SPI_CTRL1_CLK_MODE_13_Pos = 0x2
	// Bit mask of CLK_MODE_13 field.
	SPI_CTRL1_CLK_MODE_13_Msk = 0x4
	// Bit CLK_MODE_13.
	SPI_CTRL1_CLK_MODE_13 = 0x4
	// Position of RSCK_DATA_OUT field.
	SPI_CTRL1_RSCK_DATA_OUT_Pos = 0x3
	// Bit mask of RSCK_DATA_OUT field.
	SPI_CTRL1_RSCK_DATA_OUT_Msk = 0x8
	// Bit RSCK_DATA_OUT.
	SPI_CTRL1_RSCK_DATA_OUT = 0x8
	// Position of W16_17_WR_ENA field.
	SPI_CTRL1_W16_17_WR_ENA_Pos = 0x4
	// Bit mask of W16_17_WR_ENA field.
	SPI_CTRL1_W16_17_WR_ENA_Msk = 0x10
	// Bit W16_17_WR_ENA.
	SPI_CTRL1_W16_17_WR_ENA = 0x10
	// Position of CS_HOLD_DELAY field.
	SPI_CTRL1_CS_HOLD_DELAY_Pos = 0xe
	// Bit mask of CS_HOLD_DELAY field.
	SPI_CTRL1_CS_HOLD_DELAY_Msk = 0xfc000

	// CTRL2: SPI control register 2
	// Position of CS_SETUP_TIME field.
	SPI_CTRL2_CS_SETUP_TIME_Pos = 0x0
	// Bit mask of CS_SETUP_TIME field.
	SPI_CTRL2_CS_SETUP_TIME_Msk = 0x1fff
	// Position of CS_HOLD_TIME field.
	SPI_CTRL2_CS_HOLD_TIME_Pos = 0xd
	// Bit mask of CS_HOLD_TIME field.
	SPI_CTRL2_CS_HOLD_TIME_Msk = 0x3ffe000
	// Position of CS_DELAY_MODE field.
	SPI_CTRL2_CS_DELAY_MODE_Pos = 0x1a
	// Bit mask of CS_DELAY_MODE field.
	SPI_CTRL2_CS_DELAY_MODE_Msk = 0x1c000000
	// Position of CS_DELAY_NUM field.
	SPI_CTRL2_CS_DELAY_NUM_Pos = 0x1d
	// Bit mask of CS_DELAY_NUM field.
	SPI_CTRL2_CS_DELAY_NUM_Msk = 0x60000000

	// CLOCK: SPI clock control register
	// Position of CLKCNT_L field.
	SPI_CLOCK_CLKCNT_L_Pos = 0x0
	// Bit mask of CLKCNT_L field.
	SPI_CLOCK_CLKCNT_L_Msk = 0x3f
	// Position of CLKCNT_H field.
	SPI_CLOCK_CLKCNT_H_Pos = 0x6
	// Bit mask of CLKCNT_H field.
	SPI_CLOCK_CLKCNT_H_Msk = 0xfc0
	// Position of CLKCNT_N field.
	SPI_CLOCK_CLKCNT_N_Pos = 0xc
	// Bit mask of CLKCNT_N field.
	SPI_CLOCK_CLKCNT_N_Msk = 0x3f000
	// Position of CLKDIV_PRE field.
	SPI_CLOCK_CLKDIV_PRE_Pos = 0x12
	// Bit mask of CLKDIV_PRE field.
	SPI_CLOCK_CLKDIV_PRE_Msk = 0x7ffc0000
	// Position of CLK_EQU_SYSCLK field.
	SPI_CLOCK_CLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of CLK_EQU_SYSCLK field.
	SPI_CLOCK_CLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit CLK_EQU_SYSCLK.
	SPI_CLOCK_CLK_EQU_SYSCLK = 0x80000000

	// USER: SPI USER control register
	// Position of DOUTDIN field.
	SPI_USER_DOUTDIN_Pos = 0x0
	// Bit mask of DOUTDIN field.
	SPI_USER_DOUTDIN_Msk = 0x1
	// Bit DOUTDIN.
	SPI_USER_DOUTDIN = 0x1
	// Position of QPI_MODE field.
	SPI_USER_QPI_MODE_Pos = 0x3
	// Bit mask of QPI_MODE field.
	SPI_USER_QPI_MODE_Msk = 0x8
	// Bit QPI_MODE.
	SPI_USER_QPI_MODE = 0x8
	// Position of OPI_MODE field.
	SPI_USER_OPI_MODE_Pos = 0x4
	// Bit mask of OPI_MODE field.
	SPI_USER_OPI_MODE_Msk = 0x10
	// Bit OPI_MODE.
	SPI_USER_OPI_MODE = 0x10
	// Position of TSCK_I_EDGE field.
	SPI_USER_TSCK_I_EDGE_Pos = 0x5
	// Bit mask of TSCK_I_EDGE field.
	SPI_USER_TSCK_I_EDGE_Msk = 0x20
	// Bit TSCK_I_EDGE.
	SPI_USER_TSCK_I_EDGE = 0x20
	// Position of CS_HOLD field.
	SPI_USER_CS_HOLD_Pos = 0x6
	// Bit mask of CS_HOLD field.
	SPI_USER_CS_HOLD_Msk = 0x40
	// Bit CS_HOLD.
	SPI_USER_CS_HOLD = 0x40
	// Position of CS_SETUP field.
	SPI_USER_CS_SETUP_Pos = 0x7
	// Bit mask of CS_SETUP field.
	SPI_USER_CS_SETUP_Msk = 0x80
	// Bit CS_SETUP.
	SPI_USER_CS_SETUP = 0x80
	// Position of RSCK_I_EDGE field.
	SPI_USER_RSCK_I_EDGE_Pos = 0x8
	// Bit mask of RSCK_I_EDGE field.
	SPI_USER_RSCK_I_EDGE_Msk = 0x100
	// Bit RSCK_I_EDGE.
	SPI_USER_RSCK_I_EDGE = 0x100
	// Position of CK_OUT_EDGE field.
	SPI_USER_CK_OUT_EDGE_Pos = 0x9
	// Bit mask of CK_OUT_EDGE field.
	SPI_USER_CK_OUT_EDGE_Msk = 0x200
	// Bit CK_OUT_EDGE.
	SPI_USER_CK_OUT_EDGE = 0x200
	// Position of RD_BYTE_ORDER field.
	SPI_USER_RD_BYTE_ORDER_Pos = 0xa
	// Bit mask of RD_BYTE_ORDER field.
	SPI_USER_RD_BYTE_ORDER_Msk = 0x400
	// Bit RD_BYTE_ORDER.
	SPI_USER_RD_BYTE_ORDER = 0x400
	// Position of WR_BYTE_ORDER field.
	SPI_USER_WR_BYTE_ORDER_Pos = 0xb
	// Bit mask of WR_BYTE_ORDER field.
	SPI_USER_WR_BYTE_ORDER_Msk = 0x800
	// Bit WR_BYTE_ORDER.
	SPI_USER_WR_BYTE_ORDER = 0x800
	// Position of FWRITE_DUAL field.
	SPI_USER_FWRITE_DUAL_Pos = 0xc
	// Bit mask of FWRITE_DUAL field.
	SPI_USER_FWRITE_DUAL_Msk = 0x1000
	// Bit FWRITE_DUAL.
	SPI_USER_FWRITE_DUAL = 0x1000
	// Position of FWRITE_QUAD field.
	SPI_USER_FWRITE_QUAD_Pos = 0xd
	// Bit mask of FWRITE_QUAD field.
	SPI_USER_FWRITE_QUAD_Msk = 0x2000
	// Bit FWRITE_QUAD.
	SPI_USER_FWRITE_QUAD = 0x2000
	// Position of FWRITE_OCT field.
	SPI_USER_FWRITE_OCT_Pos = 0xe
	// Bit mask of FWRITE_OCT field.
	SPI_USER_FWRITE_OCT_Msk = 0x4000
	// Bit FWRITE_OCT.
	SPI_USER_FWRITE_OCT = 0x4000
	// Position of USR_CONF_NXT field.
	SPI_USER_USR_CONF_NXT_Pos = 0xf
	// Bit mask of USR_CONF_NXT field.
	SPI_USER_USR_CONF_NXT_Msk = 0x8000
	// Bit USR_CONF_NXT.
	SPI_USER_USR_CONF_NXT = 0x8000
	// Position of SIO field.
	SPI_USER_SIO_Pos = 0x10
	// Bit mask of SIO field.
	SPI_USER_SIO_Msk = 0x10000
	// Bit SIO.
	SPI_USER_SIO = 0x10000
	// Position of USR_HOLD_POL field.
	SPI_USER_USR_HOLD_POL_Pos = 0x11
	// Bit mask of USR_HOLD_POL field.
	SPI_USER_USR_HOLD_POL_Msk = 0x20000
	// Bit USR_HOLD_POL.
	SPI_USER_USR_HOLD_POL = 0x20000
	// Position of USR_DOUT_HOLD field.
	SPI_USER_USR_DOUT_HOLD_Pos = 0x12
	// Bit mask of USR_DOUT_HOLD field.
	SPI_USER_USR_DOUT_HOLD_Msk = 0x40000
	// Bit USR_DOUT_HOLD.
	SPI_USER_USR_DOUT_HOLD = 0x40000
	// Position of USR_DIN_HOLD field.
	SPI_USER_USR_DIN_HOLD_Pos = 0x13
	// Bit mask of USR_DIN_HOLD field.
	SPI_USER_USR_DIN_HOLD_Msk = 0x80000
	// Bit USR_DIN_HOLD.
	SPI_USER_USR_DIN_HOLD = 0x80000
	// Position of USR_DUMMY_HOLD field.
	SPI_USER_USR_DUMMY_HOLD_Pos = 0x14
	// Bit mask of USR_DUMMY_HOLD field.
	SPI_USER_USR_DUMMY_HOLD_Msk = 0x100000
	// Bit USR_DUMMY_HOLD.
	SPI_USER_USR_DUMMY_HOLD = 0x100000
	// Position of USR_ADDR_HOLD field.
	SPI_USER_USR_ADDR_HOLD_Pos = 0x15
	// Bit mask of USR_ADDR_HOLD field.
	SPI_USER_USR_ADDR_HOLD_Msk = 0x200000
	// Bit USR_ADDR_HOLD.
	SPI_USER_USR_ADDR_HOLD = 0x200000
	// Position of USR_CMD_HOLD field.
	SPI_USER_USR_CMD_HOLD_Pos = 0x16
	// Bit mask of USR_CMD_HOLD field.
	SPI_USER_USR_CMD_HOLD_Msk = 0x400000
	// Bit USR_CMD_HOLD.
	SPI_USER_USR_CMD_HOLD = 0x400000
	// Position of USR_PREP_HOLD field.
	SPI_USER_USR_PREP_HOLD_Pos = 0x17
	// Bit mask of USR_PREP_HOLD field.
	SPI_USER_USR_PREP_HOLD_Msk = 0x800000
	// Bit USR_PREP_HOLD.
	SPI_USER_USR_PREP_HOLD = 0x800000
	// Position of USR_MISO_HIGHPART field.
	SPI_USER_USR_MISO_HIGHPART_Pos = 0x18
	// Bit mask of USR_MISO_HIGHPART field.
	SPI_USER_USR_MISO_HIGHPART_Msk = 0x1000000
	// Bit USR_MISO_HIGHPART.
	SPI_USER_USR_MISO_HIGHPART = 0x1000000
	// Position of USR_MOSI_HIGHPART field.
	SPI_USER_USR_MOSI_HIGHPART_Pos = 0x19
	// Bit mask of USR_MOSI_HIGHPART field.
	SPI_USER_USR_MOSI_HIGHPART_Msk = 0x2000000
	// Bit USR_MOSI_HIGHPART.
	SPI_USER_USR_MOSI_HIGHPART = 0x2000000
	// Position of USR_DUMMY_IDLE field.
	SPI_USER_USR_DUMMY_IDLE_Pos = 0x1a
	// Bit mask of USR_DUMMY_IDLE field.
	SPI_USER_USR_DUMMY_IDLE_Msk = 0x4000000
	// Bit USR_DUMMY_IDLE.
	SPI_USER_USR_DUMMY_IDLE = 0x4000000
	// Position of USR_MOSI field.
	SPI_USER_USR_MOSI_Pos = 0x1b
	// Bit mask of USR_MOSI field.
	SPI_USER_USR_MOSI_Msk = 0x8000000
	// Bit USR_MOSI.
	SPI_USER_USR_MOSI = 0x8000000
	// Position of USR_MISO field.
	SPI_USER_USR_MISO_Pos = 0x1c
	// Bit mask of USR_MISO field.
	SPI_USER_USR_MISO_Msk = 0x10000000
	// Bit USR_MISO.
	SPI_USER_USR_MISO = 0x10000000
	// Position of USR_DUMMY field.
	SPI_USER_USR_DUMMY_Pos = 0x1d
	// Bit mask of USR_DUMMY field.
	SPI_USER_USR_DUMMY_Msk = 0x20000000
	// Bit USR_DUMMY.
	SPI_USER_USR_DUMMY = 0x20000000
	// Position of USR_ADDR field.
	SPI_USER_USR_ADDR_Pos = 0x1e
	// Bit mask of USR_ADDR field.
	SPI_USER_USR_ADDR_Msk = 0x40000000
	// Bit USR_ADDR.
	SPI_USER_USR_ADDR = 0x40000000
	// Position of USR_COMMAND field.
	SPI_USER_USR_COMMAND_Pos = 0x1f
	// Bit mask of USR_COMMAND field.
	SPI_USER_USR_COMMAND_Msk = 0x80000000
	// Bit USR_COMMAND.
	SPI_USER_USR_COMMAND = 0x80000000

	// USER1: SPI USER control register 1
	// Position of USR_DUMMY_CYCLELEN field.
	SPI_USER1_USR_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of USR_DUMMY_CYCLELEN field.
	SPI_USER1_USR_DUMMY_CYCLELEN_Msk = 0xff
	// Position of USR_ADDR_BITLEN field.
	SPI_USER1_USR_ADDR_BITLEN_Pos = 0x1b
	// Bit mask of USR_ADDR_BITLEN field.
	SPI_USER1_USR_ADDR_BITLEN_Msk = 0xf8000000

	// USER2: SPI USER control register 2
	// Position of USR_COMMAND_VALUE field.
	SPI_USER2_USR_COMMAND_VALUE_Pos = 0x0
	// Bit mask of USR_COMMAND_VALUE field.
	SPI_USER2_USR_COMMAND_VALUE_Msk = 0xffff
	// Position of USR_COMMAND_BITLEN field.
	SPI_USER2_USR_COMMAND_BITLEN_Pos = 0x1c
	// Bit mask of USR_COMMAND_BITLEN field.
	SPI_USER2_USR_COMMAND_BITLEN_Msk = 0xf0000000

	// MOSI_DLEN: MOSI length
	// Position of USR_MOSI_DBITLEN field.
	SPI_MOSI_DLEN_USR_MOSI_DBITLEN_Pos = 0x0
	// Bit mask of USR_MOSI_DBITLEN field.
	SPI_MOSI_DLEN_USR_MOSI_DBITLEN_Msk = 0x7fffff

	// MISO_DLEN: MISO length
	// Position of USR_MISO_DBITLEN field.
	SPI_MISO_DLEN_USR_MISO_DBITLEN_Pos = 0x0
	// Bit mask of USR_MISO_DBITLEN field.
	SPI_MISO_DLEN_USR_MISO_DBITLEN_Msk = 0x7fffff

	// MISC: SPI misc register
	// Position of CS0_DIS field.
	SPI_MISC_CS0_DIS_Pos = 0x0
	// Bit mask of CS0_DIS field.
	SPI_MISC_CS0_DIS_Msk = 0x1
	// Bit CS0_DIS.
	SPI_MISC_CS0_DIS = 0x1
	// Position of CS1_DIS field.
	SPI_MISC_CS1_DIS_Pos = 0x1
	// Bit mask of CS1_DIS field.
	SPI_MISC_CS1_DIS_Msk = 0x2
	// Bit CS1_DIS.
	SPI_MISC_CS1_DIS = 0x2
	// Position of CS2_DIS field.
	SPI_MISC_CS2_DIS_Pos = 0x2
	// Bit mask of CS2_DIS field.
	SPI_MISC_CS2_DIS_Msk = 0x4
	// Bit CS2_DIS.
	SPI_MISC_CS2_DIS = 0x4
	// Position of CS3_DIS field.
	SPI_MISC_CS3_DIS_Pos = 0x3
	// Bit mask of CS3_DIS field.
	SPI_MISC_CS3_DIS_Msk = 0x8
	// Bit CS3_DIS.
	SPI_MISC_CS3_DIS = 0x8
	// Position of CS4_DIS field.
	SPI_MISC_CS4_DIS_Pos = 0x4
	// Bit mask of CS4_DIS field.
	SPI_MISC_CS4_DIS_Msk = 0x10
	// Bit CS4_DIS.
	SPI_MISC_CS4_DIS = 0x10
	// Position of CS5_DIS field.
	SPI_MISC_CS5_DIS_Pos = 0x5
	// Bit mask of CS5_DIS field.
	SPI_MISC_CS5_DIS_Msk = 0x20
	// Bit CS5_DIS.
	SPI_MISC_CS5_DIS = 0x20
	// Position of CK_DIS field.
	SPI_MISC_CK_DIS_Pos = 0x6
	// Bit mask of CK_DIS field.
	SPI_MISC_CK_DIS_Msk = 0x40
	// Bit CK_DIS.
	SPI_MISC_CK_DIS = 0x40
	// Position of MASTER_CS_POL field.
	SPI_MISC_MASTER_CS_POL_Pos = 0x7
	// Bit mask of MASTER_CS_POL field.
	SPI_MISC_MASTER_CS_POL_Msk = 0x1f80
	// Position of CLK_DATA_DTR_EN field.
	SPI_MISC_CLK_DATA_DTR_EN_Pos = 0x10
	// Bit mask of CLK_DATA_DTR_EN field.
	SPI_MISC_CLK_DATA_DTR_EN_Msk = 0x10000
	// Bit CLK_DATA_DTR_EN.
	SPI_MISC_CLK_DATA_DTR_EN = 0x10000
	// Position of DATA_DTR_EN field.
	SPI_MISC_DATA_DTR_EN_Pos = 0x11
	// Bit mask of DATA_DTR_EN field.
	SPI_MISC_DATA_DTR_EN_Msk = 0x20000
	// Bit DATA_DTR_EN.
	SPI_MISC_DATA_DTR_EN = 0x20000
	// Position of ADDR_DTR_EN field.
	SPI_MISC_ADDR_DTR_EN_Pos = 0x12
	// Bit mask of ADDR_DTR_EN field.
	SPI_MISC_ADDR_DTR_EN_Msk = 0x40000
	// Bit ADDR_DTR_EN.
	SPI_MISC_ADDR_DTR_EN = 0x40000
	// Position of CMD_DTR_EN field.
	SPI_MISC_CMD_DTR_EN_Pos = 0x13
	// Bit mask of CMD_DTR_EN field.
	SPI_MISC_CMD_DTR_EN_Msk = 0x80000
	// Bit CMD_DTR_EN.
	SPI_MISC_CMD_DTR_EN = 0x80000
	// Position of CD_DATA_SET field.
	SPI_MISC_CD_DATA_SET_Pos = 0x14
	// Bit mask of CD_DATA_SET field.
	SPI_MISC_CD_DATA_SET_Msk = 0x100000
	// Bit CD_DATA_SET.
	SPI_MISC_CD_DATA_SET = 0x100000
	// Position of CD_DUMMY_SET field.
	SPI_MISC_CD_DUMMY_SET_Pos = 0x15
	// Bit mask of CD_DUMMY_SET field.
	SPI_MISC_CD_DUMMY_SET_Msk = 0x200000
	// Bit CD_DUMMY_SET.
	SPI_MISC_CD_DUMMY_SET = 0x200000
	// Position of CD_ADDR_SET field.
	SPI_MISC_CD_ADDR_SET_Pos = 0x16
	// Bit mask of CD_ADDR_SET field.
	SPI_MISC_CD_ADDR_SET_Msk = 0x400000
	// Bit CD_ADDR_SET.
	SPI_MISC_CD_ADDR_SET = 0x400000
	// Position of SLAVE_CS_POL field.
	SPI_MISC_SLAVE_CS_POL_Pos = 0x17
	// Bit mask of SLAVE_CS_POL field.
	SPI_MISC_SLAVE_CS_POL_Msk = 0x800000
	// Bit SLAVE_CS_POL.
	SPI_MISC_SLAVE_CS_POL = 0x800000
	// Position of DQS_IDLE_EDGE field.
	SPI_MISC_DQS_IDLE_EDGE_Pos = 0x18
	// Bit mask of DQS_IDLE_EDGE field.
	SPI_MISC_DQS_IDLE_EDGE_Msk = 0x1000000
	// Bit DQS_IDLE_EDGE.
	SPI_MISC_DQS_IDLE_EDGE = 0x1000000
	// Position of CD_CMD_SET field.
	SPI_MISC_CD_CMD_SET_Pos = 0x19
	// Bit mask of CD_CMD_SET field.
	SPI_MISC_CD_CMD_SET_Msk = 0x2000000
	// Bit CD_CMD_SET.
	SPI_MISC_CD_CMD_SET = 0x2000000
	// Position of CD_IDLE_EDGE field.
	SPI_MISC_CD_IDLE_EDGE_Pos = 0x1a
	// Bit mask of CD_IDLE_EDGE field.
	SPI_MISC_CD_IDLE_EDGE_Msk = 0x4000000
	// Bit CD_IDLE_EDGE.
	SPI_MISC_CD_IDLE_EDGE = 0x4000000
	// Position of CK_IDLE_EDGE field.
	SPI_MISC_CK_IDLE_EDGE_Pos = 0x1d
	// Bit mask of CK_IDLE_EDGE field.
	SPI_MISC_CK_IDLE_EDGE_Msk = 0x20000000
	// Bit CK_IDLE_EDGE.
	SPI_MISC_CK_IDLE_EDGE = 0x20000000
	// Position of CS_KEEP_ACTIVE field.
	SPI_MISC_CS_KEEP_ACTIVE_Pos = 0x1e
	// Bit mask of CS_KEEP_ACTIVE field.
	SPI_MISC_CS_KEEP_ACTIVE_Msk = 0x40000000
	// Bit CS_KEEP_ACTIVE.
	SPI_MISC_CS_KEEP_ACTIVE = 0x40000000
	// Position of QUAD_DIN_PIN_SWAP field.
	SPI_MISC_QUAD_DIN_PIN_SWAP_Pos = 0x1f
	// Bit mask of QUAD_DIN_PIN_SWAP field.
	SPI_MISC_QUAD_DIN_PIN_SWAP_Msk = 0x80000000
	// Bit QUAD_DIN_PIN_SWAP.
	SPI_MISC_QUAD_DIN_PIN_SWAP = 0x80000000

	// SLAVE: SPI slave control register
	// Position of TRANS_DONE field.
	SPI_SLAVE_TRANS_DONE_Pos = 0x4
	// Bit mask of TRANS_DONE field.
	SPI_SLAVE_TRANS_DONE_Msk = 0x10
	// Bit TRANS_DONE.
	SPI_SLAVE_TRANS_DONE = 0x10
	// Position of INT_RD_BUF_DONE_EN field.
	SPI_SLAVE_INT_RD_BUF_DONE_EN_Pos = 0x5
	// Bit mask of INT_RD_BUF_DONE_EN field.
	SPI_SLAVE_INT_RD_BUF_DONE_EN_Msk = 0x20
	// Bit INT_RD_BUF_DONE_EN.
	SPI_SLAVE_INT_RD_BUF_DONE_EN = 0x20
	// Position of INT_WR_BUF_DONE_EN field.
	SPI_SLAVE_INT_WR_BUF_DONE_EN_Pos = 0x6
	// Bit mask of INT_WR_BUF_DONE_EN field.
	SPI_SLAVE_INT_WR_BUF_DONE_EN_Msk = 0x40
	// Bit INT_WR_BUF_DONE_EN.
	SPI_SLAVE_INT_WR_BUF_DONE_EN = 0x40
	// Position of INT_RD_DMA_DONE_EN field.
	SPI_SLAVE_INT_RD_DMA_DONE_EN_Pos = 0x7
	// Bit mask of INT_RD_DMA_DONE_EN field.
	SPI_SLAVE_INT_RD_DMA_DONE_EN_Msk = 0x80
	// Bit INT_RD_DMA_DONE_EN.
	SPI_SLAVE_INT_RD_DMA_DONE_EN = 0x80
	// Position of INT_WR_DMA_DONE_EN field.
	SPI_SLAVE_INT_WR_DMA_DONE_EN_Pos = 0x8
	// Bit mask of INT_WR_DMA_DONE_EN field.
	SPI_SLAVE_INT_WR_DMA_DONE_EN_Msk = 0x100
	// Bit INT_WR_DMA_DONE_EN.
	SPI_SLAVE_INT_WR_DMA_DONE_EN = 0x100
	// Position of INT_TRANS_DONE_EN field.
	SPI_SLAVE_INT_TRANS_DONE_EN_Pos = 0x9
	// Bit mask of INT_TRANS_DONE_EN field.
	SPI_SLAVE_INT_TRANS_DONE_EN_Msk = 0x200
	// Bit INT_TRANS_DONE_EN.
	SPI_SLAVE_INT_TRANS_DONE_EN = 0x200
	// Position of INT_DMA_SEG_TRANS_EN field.
	SPI_SLAVE_INT_DMA_SEG_TRANS_EN_Pos = 0xa
	// Bit mask of INT_DMA_SEG_TRANS_EN field.
	SPI_SLAVE_INT_DMA_SEG_TRANS_EN_Msk = 0x400
	// Bit INT_DMA_SEG_TRANS_EN.
	SPI_SLAVE_INT_DMA_SEG_TRANS_EN = 0x400
	// Position of SEG_MAGIC_ERR_INT_EN field.
	SPI_SLAVE_SEG_MAGIC_ERR_INT_EN_Pos = 0xb
	// Bit mask of SEG_MAGIC_ERR_INT_EN field.
	SPI_SLAVE_SEG_MAGIC_ERR_INT_EN_Msk = 0x800
	// Bit SEG_MAGIC_ERR_INT_EN.
	SPI_SLAVE_SEG_MAGIC_ERR_INT_EN = 0x800
	// Position of TRANS_CNT field.
	SPI_SLAVE_TRANS_CNT_Pos = 0x17
	// Bit mask of TRANS_CNT field.
	SPI_SLAVE_TRANS_CNT_Msk = 0x7800000
	// Position of TRANS_DONE_AUTO_CLR_EN field.
	SPI_SLAVE_TRANS_DONE_AUTO_CLR_EN_Pos = 0x1d
	// Bit mask of TRANS_DONE_AUTO_CLR_EN field.
	SPI_SLAVE_TRANS_DONE_AUTO_CLR_EN_Msk = 0x20000000
	// Bit TRANS_DONE_AUTO_CLR_EN.
	SPI_SLAVE_TRANS_DONE_AUTO_CLR_EN = 0x20000000
	// Position of MODE field.
	SPI_SLAVE_MODE_Pos = 0x1e
	// Bit mask of MODE field.
	SPI_SLAVE_MODE_Msk = 0x40000000
	// Bit MODE.
	SPI_SLAVE_MODE = 0x40000000
	// Position of SOFT_RESET field.
	SPI_SLAVE_SOFT_RESET_Pos = 0x1f
	// Bit mask of SOFT_RESET field.
	SPI_SLAVE_SOFT_RESET_Msk = 0x80000000
	// Bit SOFT_RESET.
	SPI_SLAVE_SOFT_RESET = 0x80000000

	// SLAVE1: SPI slave control register 1
	// Position of SLV_ADDR_ERR_CLR field.
	SPI_SLAVE1_SLV_ADDR_ERR_CLR_Pos = 0xa
	// Bit mask of SLV_ADDR_ERR_CLR field.
	SPI_SLAVE1_SLV_ADDR_ERR_CLR_Msk = 0x400
	// Bit SLV_ADDR_ERR_CLR.
	SPI_SLAVE1_SLV_ADDR_ERR_CLR = 0x400
	// Position of SLV_CMD_ERR_CLR field.
	SPI_SLAVE1_SLV_CMD_ERR_CLR_Pos = 0xb
	// Bit mask of SLV_CMD_ERR_CLR field.
	SPI_SLAVE1_SLV_CMD_ERR_CLR_Msk = 0x800
	// Bit SLV_CMD_ERR_CLR.
	SPI_SLAVE1_SLV_CMD_ERR_CLR = 0x800
	// Position of SLV_NO_QPI_EN field.
	SPI_SLAVE1_SLV_NO_QPI_EN_Pos = 0xc
	// Bit mask of SLV_NO_QPI_EN field.
	SPI_SLAVE1_SLV_NO_QPI_EN_Msk = 0x1000
	// Bit SLV_NO_QPI_EN.
	SPI_SLAVE1_SLV_NO_QPI_EN = 0x1000
	// Position of SLV_ADDR_ERR field.
	SPI_SLAVE1_SLV_ADDR_ERR_Pos = 0xd
	// Bit mask of SLV_ADDR_ERR field.
	SPI_SLAVE1_SLV_ADDR_ERR_Msk = 0x2000
	// Bit SLV_ADDR_ERR.
	SPI_SLAVE1_SLV_ADDR_ERR = 0x2000
	// Position of SLV_CMD_ERR field.
	SPI_SLAVE1_SLV_CMD_ERR_Pos = 0xe
	// Bit mask of SLV_CMD_ERR field.
	SPI_SLAVE1_SLV_CMD_ERR_Msk = 0x4000
	// Bit SLV_CMD_ERR.
	SPI_SLAVE1_SLV_CMD_ERR = 0x4000
	// Position of SLV_WR_DMA_DONE field.
	SPI_SLAVE1_SLV_WR_DMA_DONE_Pos = 0xf
	// Bit mask of SLV_WR_DMA_DONE field.
	SPI_SLAVE1_SLV_WR_DMA_DONE_Msk = 0x8000
	// Bit SLV_WR_DMA_DONE.
	SPI_SLAVE1_SLV_WR_DMA_DONE = 0x8000
	// Position of SLV_LAST_COMMAND field.
	SPI_SLAVE1_SLV_LAST_COMMAND_Pos = 0x10
	// Bit mask of SLV_LAST_COMMAND field.
	SPI_SLAVE1_SLV_LAST_COMMAND_Msk = 0xff0000
	// Position of SLV_LAST_ADDR field.
	SPI_SLAVE1_SLV_LAST_ADDR_Pos = 0x18
	// Bit mask of SLV_LAST_ADDR field.
	SPI_SLAVE1_SLV_LAST_ADDR_Msk = 0xff000000

	// SLV_WRBUF_DLEN: SPI slave Wr_BUF interrupt and CONF control register
	// Position of SLV_WR_BUF_DONE field.
	SPI_SLV_WRBUF_DLEN_SLV_WR_BUF_DONE_Pos = 0x18
	// Bit mask of SLV_WR_BUF_DONE field.
	SPI_SLV_WRBUF_DLEN_SLV_WR_BUF_DONE_Msk = 0x1000000
	// Bit SLV_WR_BUF_DONE.
	SPI_SLV_WRBUF_DLEN_SLV_WR_BUF_DONE = 0x1000000
	// Position of CONF_BASE_BITLEN field.
	SPI_SLV_WRBUF_DLEN_CONF_BASE_BITLEN_Pos = 0x19
	// Bit mask of CONF_BASE_BITLEN field.
	SPI_SLV_WRBUF_DLEN_CONF_BASE_BITLEN_Msk = 0xfe000000

	// SLV_RDBUF_DLEN: SPI magic error and slave control register
	// Position of SLV_DMA_RD_BYTELEN field.
	SPI_SLV_RDBUF_DLEN_SLV_DMA_RD_BYTELEN_Pos = 0x0
	// Bit mask of SLV_DMA_RD_BYTELEN field.
	SPI_SLV_RDBUF_DLEN_SLV_DMA_RD_BYTELEN_Msk = 0xfffff
	// Position of SLV_RD_BUF_DONE field.
	SPI_SLV_RDBUF_DLEN_SLV_RD_BUF_DONE_Pos = 0x18
	// Bit mask of SLV_RD_BUF_DONE field.
	SPI_SLV_RDBUF_DLEN_SLV_RD_BUF_DONE_Msk = 0x1000000
	// Bit SLV_RD_BUF_DONE.
	SPI_SLV_RDBUF_DLEN_SLV_RD_BUF_DONE = 0x1000000
	// Position of SEG_MAGIC_ERR field.
	SPI_SLV_RDBUF_DLEN_SEG_MAGIC_ERR_Pos = 0x19
	// Bit mask of SEG_MAGIC_ERR field.
	SPI_SLV_RDBUF_DLEN_SEG_MAGIC_ERR_Msk = 0x2000000
	// Bit SEG_MAGIC_ERR.
	SPI_SLV_RDBUF_DLEN_SEG_MAGIC_ERR = 0x2000000

	// SLV_RD_BYTE: SPI interrupt control register
	// Position of SLV_DATA_BYTELEN field.
	SPI_SLV_RD_BYTE_SLV_DATA_BYTELEN_Pos = 0x0
	// Bit mask of SLV_DATA_BYTELEN field.
	SPI_SLV_RD_BYTE_SLV_DATA_BYTELEN_Msk = 0xfffff
	// Position of SLV_RDDMA_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_RDDMA_BYTELEN_EN_Pos = 0x14
	// Bit mask of SLV_RDDMA_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_RDDMA_BYTELEN_EN_Msk = 0x100000
	// Bit SLV_RDDMA_BYTELEN_EN.
	SPI_SLV_RD_BYTE_SLV_RDDMA_BYTELEN_EN = 0x100000
	// Position of SLV_WRDMA_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_WRDMA_BYTELEN_EN_Pos = 0x15
	// Bit mask of SLV_WRDMA_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_WRDMA_BYTELEN_EN_Msk = 0x200000
	// Bit SLV_WRDMA_BYTELEN_EN.
	SPI_SLV_RD_BYTE_SLV_WRDMA_BYTELEN_EN = 0x200000
	// Position of SLV_RDBUF_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_RDBUF_BYTELEN_EN_Pos = 0x16
	// Bit mask of SLV_RDBUF_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_RDBUF_BYTELEN_EN_Msk = 0x400000
	// Bit SLV_RDBUF_BYTELEN_EN.
	SPI_SLV_RD_BYTE_SLV_RDBUF_BYTELEN_EN = 0x400000
	// Position of SLV_WRBUF_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_WRBUF_BYTELEN_EN_Pos = 0x17
	// Bit mask of SLV_WRBUF_BYTELEN_EN field.
	SPI_SLV_RD_BYTE_SLV_WRBUF_BYTELEN_EN_Msk = 0x800000
	// Bit SLV_WRBUF_BYTELEN_EN.
	SPI_SLV_RD_BYTE_SLV_WRBUF_BYTELEN_EN = 0x800000
	// Position of DMA_SEG_MAGIC_VALUE field.
	SPI_SLV_RD_BYTE_DMA_SEG_MAGIC_VALUE_Pos = 0x18
	// Bit mask of DMA_SEG_MAGIC_VALUE field.
	SPI_SLV_RD_BYTE_DMA_SEG_MAGIC_VALUE_Msk = 0xf000000
	// Position of SLV_RD_DMA_DONE field.
	SPI_SLV_RD_BYTE_SLV_RD_DMA_DONE_Pos = 0x1e
	// Bit mask of SLV_RD_DMA_DONE field.
	SPI_SLV_RD_BYTE_SLV_RD_DMA_DONE_Msk = 0x40000000
	// Bit SLV_RD_DMA_DONE.
	SPI_SLV_RD_BYTE_SLV_RD_DMA_DONE = 0x40000000
	// Position of USR_CONF field.
	SPI_SLV_RD_BYTE_USR_CONF_Pos = 0x1f
	// Bit mask of USR_CONF field.
	SPI_SLV_RD_BYTE_USR_CONF_Msk = 0x80000000
	// Bit USR_CONF.
	SPI_SLV_RD_BYTE_USR_CONF = 0x80000000

	// FSM: SPI master status and DMA read byte control register
	// Position of ST field.
	SPI_FSM_ST_Pos = 0x0
	// Bit mask of ST field.
	SPI_FSM_ST_Msk = 0xf
	// Position of MST_DMA_RD_BYTELEN field.
	SPI_FSM_MST_DMA_RD_BYTELEN_Pos = 0xc
	// Bit mask of MST_DMA_RD_BYTELEN field.
	SPI_FSM_MST_DMA_RD_BYTELEN_Msk = 0xfffff000

	// HOLD: SPI hold register
	// Position of INT_HOLD_ENA field.
	SPI_HOLD_INT_HOLD_ENA_Pos = 0x0
	// Bit mask of INT_HOLD_ENA field.
	SPI_HOLD_INT_HOLD_ENA_Msk = 0x3
	// Position of VAL field.
	SPI_HOLD_VAL_Pos = 0x2
	// Bit mask of VAL field.
	SPI_HOLD_VAL_Msk = 0x4
	// Bit VAL.
	SPI_HOLD_VAL = 0x4
	// Position of OUT_EN field.
	SPI_HOLD_OUT_EN_Pos = 0x3
	// Bit mask of OUT_EN field.
	SPI_HOLD_OUT_EN_Msk = 0x8
	// Bit OUT_EN.
	SPI_HOLD_OUT_EN = 0x8
	// Position of OUT_TIME field.
	SPI_HOLD_OUT_TIME_Pos = 0x4
	// Bit mask of OUT_TIME field.
	SPI_HOLD_OUT_TIME_Msk = 0x70
	// Position of DMA_SEG_TRANS_DONE field.
	SPI_HOLD_DMA_SEG_TRANS_DONE_Pos = 0x7
	// Bit mask of DMA_SEG_TRANS_DONE field.
	SPI_HOLD_DMA_SEG_TRANS_DONE_Msk = 0x80
	// Bit DMA_SEG_TRANS_DONE.
	SPI_HOLD_DMA_SEG_TRANS_DONE = 0x80

	// DMA_CONF: SPI DMA control register
	// Position of IN_RST field.
	SPI_DMA_CONF_IN_RST_Pos = 0x2
	// Bit mask of IN_RST field.
	SPI_DMA_CONF_IN_RST_Msk = 0x4
	// Bit IN_RST.
	SPI_DMA_CONF_IN_RST = 0x4
	// Position of OUT_RST field.
	SPI_DMA_CONF_OUT_RST_Pos = 0x3
	// Bit mask of OUT_RST field.
	SPI_DMA_CONF_OUT_RST_Msk = 0x8
	// Bit OUT_RST.
	SPI_DMA_CONF_OUT_RST = 0x8
	// Position of AHBM_FIFO_RST field.
	SPI_DMA_CONF_AHBM_FIFO_RST_Pos = 0x4
	// Bit mask of AHBM_FIFO_RST field.
	SPI_DMA_CONF_AHBM_FIFO_RST_Msk = 0x10
	// Bit AHBM_FIFO_RST.
	SPI_DMA_CONF_AHBM_FIFO_RST = 0x10
	// Position of AHBM_RST field.
	SPI_DMA_CONF_AHBM_RST_Pos = 0x5
	// Bit mask of AHBM_RST field.
	SPI_DMA_CONF_AHBM_RST_Msk = 0x20
	// Bit AHBM_RST.
	SPI_DMA_CONF_AHBM_RST = 0x20
	// Position of IN_LOOP_TEST field.
	SPI_DMA_CONF_IN_LOOP_TEST_Pos = 0x6
	// Bit mask of IN_LOOP_TEST field.
	SPI_DMA_CONF_IN_LOOP_TEST_Msk = 0x40
	// Bit IN_LOOP_TEST.
	SPI_DMA_CONF_IN_LOOP_TEST = 0x40
	// Position of OUT_LOOP_TEST field.
	SPI_DMA_CONF_OUT_LOOP_TEST_Pos = 0x7
	// Bit mask of OUT_LOOP_TEST field.
	SPI_DMA_CONF_OUT_LOOP_TEST_Msk = 0x80
	// Bit OUT_LOOP_TEST.
	SPI_DMA_CONF_OUT_LOOP_TEST = 0x80
	// Position of OUT_AUTO_WRBACK field.
	SPI_DMA_CONF_OUT_AUTO_WRBACK_Pos = 0x8
	// Bit mask of OUT_AUTO_WRBACK field.
	SPI_DMA_CONF_OUT_AUTO_WRBACK_Msk = 0x100
	// Bit OUT_AUTO_WRBACK.
	SPI_DMA_CONF_OUT_AUTO_WRBACK = 0x100
	// Position of OUT_EOF_MODE field.
	SPI_DMA_CONF_OUT_EOF_MODE_Pos = 0x9
	// Bit mask of OUT_EOF_MODE field.
	SPI_DMA_CONF_OUT_EOF_MODE_Msk = 0x200
	// Bit OUT_EOF_MODE.
	SPI_DMA_CONF_OUT_EOF_MODE = 0x200
	// Position of OUTDSCR_BURST_EN field.
	SPI_DMA_CONF_OUTDSCR_BURST_EN_Pos = 0xa
	// Bit mask of OUTDSCR_BURST_EN field.
	SPI_DMA_CONF_OUTDSCR_BURST_EN_Msk = 0x400
	// Bit OUTDSCR_BURST_EN.
	SPI_DMA_CONF_OUTDSCR_BURST_EN = 0x400
	// Position of INDSCR_BURST_EN field.
	SPI_DMA_CONF_INDSCR_BURST_EN_Pos = 0xb
	// Bit mask of INDSCR_BURST_EN field.
	SPI_DMA_CONF_INDSCR_BURST_EN_Msk = 0x800
	// Bit INDSCR_BURST_EN.
	SPI_DMA_CONF_INDSCR_BURST_EN = 0x800
	// Position of OUT_DATA_BURST_EN field.
	SPI_DMA_CONF_OUT_DATA_BURST_EN_Pos = 0xc
	// Bit mask of OUT_DATA_BURST_EN field.
	SPI_DMA_CONF_OUT_DATA_BURST_EN_Msk = 0x1000
	// Bit OUT_DATA_BURST_EN.
	SPI_DMA_CONF_OUT_DATA_BURST_EN = 0x1000
	// Position of MEM_TRANS_EN field.
	SPI_DMA_CONF_MEM_TRANS_EN_Pos = 0xd
	// Bit mask of MEM_TRANS_EN field.
	SPI_DMA_CONF_MEM_TRANS_EN_Msk = 0x2000
	// Bit MEM_TRANS_EN.
	SPI_DMA_CONF_MEM_TRANS_EN = 0x2000
	// Position of DMA_RX_STOP field.
	SPI_DMA_CONF_DMA_RX_STOP_Pos = 0xe
	// Bit mask of DMA_RX_STOP field.
	SPI_DMA_CONF_DMA_RX_STOP_Msk = 0x4000
	// Bit DMA_RX_STOP.
	SPI_DMA_CONF_DMA_RX_STOP = 0x4000
	// Position of DMA_TX_STOP field.
	SPI_DMA_CONF_DMA_TX_STOP_Pos = 0xf
	// Bit mask of DMA_TX_STOP field.
	SPI_DMA_CONF_DMA_TX_STOP_Msk = 0x8000
	// Bit DMA_TX_STOP.
	SPI_DMA_CONF_DMA_TX_STOP = 0x8000
	// Position of DMA_CONTINUE field.
	SPI_DMA_CONF_DMA_CONTINUE_Pos = 0x10
	// Bit mask of DMA_CONTINUE field.
	SPI_DMA_CONF_DMA_CONTINUE_Msk = 0x10000
	// Bit DMA_CONTINUE.
	SPI_DMA_CONF_DMA_CONTINUE = 0x10000
	// Position of SLV_LAST_SEG_POP_CLR field.
	SPI_DMA_CONF_SLV_LAST_SEG_POP_CLR_Pos = 0x11
	// Bit mask of SLV_LAST_SEG_POP_CLR field.
	SPI_DMA_CONF_SLV_LAST_SEG_POP_CLR_Msk = 0x20000
	// Bit SLV_LAST_SEG_POP_CLR.
	SPI_DMA_CONF_SLV_LAST_SEG_POP_CLR = 0x20000
	// Position of DMA_SLV_SEG_TRANS_EN field.
	SPI_DMA_CONF_DMA_SLV_SEG_TRANS_EN_Pos = 0x12
	// Bit mask of DMA_SLV_SEG_TRANS_EN field.
	SPI_DMA_CONF_DMA_SLV_SEG_TRANS_EN_Msk = 0x40000
	// Bit DMA_SLV_SEG_TRANS_EN.
	SPI_DMA_CONF_DMA_SLV_SEG_TRANS_EN = 0x40000
	// Position of SLV_RX_SEG_TRANS_CLR_EN field.
	SPI_DMA_CONF_SLV_RX_SEG_TRANS_CLR_EN_Pos = 0x13
	// Bit mask of SLV_RX_SEG_TRANS_CLR_EN field.
	SPI_DMA_CONF_SLV_RX_SEG_TRANS_CLR_EN_Msk = 0x80000
	// Bit SLV_RX_SEG_TRANS_CLR_EN.
	SPI_DMA_CONF_SLV_RX_SEG_TRANS_CLR_EN = 0x80000
	// Position of SLV_TX_SEG_TRANS_CLR_EN field.
	SPI_DMA_CONF_SLV_TX_SEG_TRANS_CLR_EN_Pos = 0x14
	// Bit mask of SLV_TX_SEG_TRANS_CLR_EN field.
	SPI_DMA_CONF_SLV_TX_SEG_TRANS_CLR_EN_Msk = 0x100000
	// Bit SLV_TX_SEG_TRANS_CLR_EN.
	SPI_DMA_CONF_SLV_TX_SEG_TRANS_CLR_EN = 0x100000
	// Position of RX_EOF_EN field.
	SPI_DMA_CONF_RX_EOF_EN_Pos = 0x15
	// Bit mask of RX_EOF_EN field.
	SPI_DMA_CONF_RX_EOF_EN_Msk = 0x200000
	// Bit RX_EOF_EN.
	SPI_DMA_CONF_RX_EOF_EN = 0x200000
	// Position of DMA_INFIFO_FULL_CLR field.
	SPI_DMA_CONF_DMA_INFIFO_FULL_CLR_Pos = 0x16
	// Bit mask of DMA_INFIFO_FULL_CLR field.
	SPI_DMA_CONF_DMA_INFIFO_FULL_CLR_Msk = 0x400000
	// Bit DMA_INFIFO_FULL_CLR.
	SPI_DMA_CONF_DMA_INFIFO_FULL_CLR = 0x400000
	// Position of DMA_OUTFIFO_EMPTY_CLR field.
	SPI_DMA_CONF_DMA_OUTFIFO_EMPTY_CLR_Pos = 0x17
	// Bit mask of DMA_OUTFIFO_EMPTY_CLR field.
	SPI_DMA_CONF_DMA_OUTFIFO_EMPTY_CLR_Msk = 0x800000
	// Bit DMA_OUTFIFO_EMPTY_CLR.
	SPI_DMA_CONF_DMA_OUTFIFO_EMPTY_CLR = 0x800000
	// Position of EXT_MEM_BK_SIZE field.
	SPI_DMA_CONF_EXT_MEM_BK_SIZE_Pos = 0x1a
	// Bit mask of EXT_MEM_BK_SIZE field.
	SPI_DMA_CONF_EXT_MEM_BK_SIZE_Msk = 0xc000000
	// Position of DMA_SEG_TRANS_CLR field.
	SPI_DMA_CONF_DMA_SEG_TRANS_CLR_Pos = 0x1c
	// Bit mask of DMA_SEG_TRANS_CLR field.
	SPI_DMA_CONF_DMA_SEG_TRANS_CLR_Msk = 0x10000000
	// Bit DMA_SEG_TRANS_CLR.
	SPI_DMA_CONF_DMA_SEG_TRANS_CLR = 0x10000000

	// DMA_OUT_LINK: SPI DMA TX link configuration
	// Position of OUTLINK_ADDR field.
	SPI_DMA_OUT_LINK_OUTLINK_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_ADDR field.
	SPI_DMA_OUT_LINK_OUTLINK_ADDR_Msk = 0xfffff
	// Position of OUTLINK_STOP field.
	SPI_DMA_OUT_LINK_OUTLINK_STOP_Pos = 0x1c
	// Bit mask of OUTLINK_STOP field.
	SPI_DMA_OUT_LINK_OUTLINK_STOP_Msk = 0x10000000
	// Bit OUTLINK_STOP.
	SPI_DMA_OUT_LINK_OUTLINK_STOP = 0x10000000
	// Position of OUTLINK_START field.
	SPI_DMA_OUT_LINK_OUTLINK_START_Pos = 0x1d
	// Bit mask of OUTLINK_START field.
	SPI_DMA_OUT_LINK_OUTLINK_START_Msk = 0x20000000
	// Bit OUTLINK_START.
	SPI_DMA_OUT_LINK_OUTLINK_START = 0x20000000
	// Position of OUTLINK_RESTART field.
	SPI_DMA_OUT_LINK_OUTLINK_RESTART_Pos = 0x1e
	// Bit mask of OUTLINK_RESTART field.
	SPI_DMA_OUT_LINK_OUTLINK_RESTART_Msk = 0x40000000
	// Bit OUTLINK_RESTART.
	SPI_DMA_OUT_LINK_OUTLINK_RESTART = 0x40000000
	// Position of DMA_TX_ENA field.
	SPI_DMA_OUT_LINK_DMA_TX_ENA_Pos = 0x1f
	// Bit mask of DMA_TX_ENA field.
	SPI_DMA_OUT_LINK_DMA_TX_ENA_Msk = 0x80000000
	// Bit DMA_TX_ENA.
	SPI_DMA_OUT_LINK_DMA_TX_ENA = 0x80000000

	// DMA_IN_LINK: SPI DMA RX link configuration
	// Position of INLINK_ADDR field.
	SPI_DMA_IN_LINK_INLINK_ADDR_Pos = 0x0
	// Bit mask of INLINK_ADDR field.
	SPI_DMA_IN_LINK_INLINK_ADDR_Msk = 0xfffff
	// Position of INLINK_AUTO_RET field.
	SPI_DMA_IN_LINK_INLINK_AUTO_RET_Pos = 0x14
	// Bit mask of INLINK_AUTO_RET field.
	SPI_DMA_IN_LINK_INLINK_AUTO_RET_Msk = 0x100000
	// Bit INLINK_AUTO_RET.
	SPI_DMA_IN_LINK_INLINK_AUTO_RET = 0x100000
	// Position of INLINK_STOP field.
	SPI_DMA_IN_LINK_INLINK_STOP_Pos = 0x1c
	// Bit mask of INLINK_STOP field.
	SPI_DMA_IN_LINK_INLINK_STOP_Msk = 0x10000000
	// Bit INLINK_STOP.
	SPI_DMA_IN_LINK_INLINK_STOP = 0x10000000
	// Position of INLINK_START field.
	SPI_DMA_IN_LINK_INLINK_START_Pos = 0x1d
	// Bit mask of INLINK_START field.
	SPI_DMA_IN_LINK_INLINK_START_Msk = 0x20000000
	// Bit INLINK_START.
	SPI_DMA_IN_LINK_INLINK_START = 0x20000000
	// Position of INLINK_RESTART field.
	SPI_DMA_IN_LINK_INLINK_RESTART_Pos = 0x1e
	// Bit mask of INLINK_RESTART field.
	SPI_DMA_IN_LINK_INLINK_RESTART_Msk = 0x40000000
	// Bit INLINK_RESTART.
	SPI_DMA_IN_LINK_INLINK_RESTART = 0x40000000
	// Position of DMA_RX_ENA field.
	SPI_DMA_IN_LINK_DMA_RX_ENA_Pos = 0x1f
	// Bit mask of DMA_RX_ENA field.
	SPI_DMA_IN_LINK_DMA_RX_ENA_Msk = 0x80000000
	// Bit DMA_RX_ENA.
	SPI_DMA_IN_LINK_DMA_RX_ENA = 0x80000000

	// DMA_INT_ENA: SPI DMA interrupt enable register
	// Position of INLINK_DSCR_EMPTY_INT_ENA field.
	SPI_DMA_INT_ENA_INLINK_DSCR_EMPTY_INT_ENA_Pos = 0x0
	// Bit mask of INLINK_DSCR_EMPTY_INT_ENA field.
	SPI_DMA_INT_ENA_INLINK_DSCR_EMPTY_INT_ENA_Msk = 0x1
	// Bit INLINK_DSCR_EMPTY_INT_ENA.
	SPI_DMA_INT_ENA_INLINK_DSCR_EMPTY_INT_ENA = 0x1
	// Position of OUTLINK_DSCR_ERROR_INT_ENA field.
	SPI_DMA_INT_ENA_OUTLINK_DSCR_ERROR_INT_ENA_Pos = 0x1
	// Bit mask of OUTLINK_DSCR_ERROR_INT_ENA field.
	SPI_DMA_INT_ENA_OUTLINK_DSCR_ERROR_INT_ENA_Msk = 0x2
	// Bit OUTLINK_DSCR_ERROR_INT_ENA.
	SPI_DMA_INT_ENA_OUTLINK_DSCR_ERROR_INT_ENA = 0x2
	// Position of INLINK_DSCR_ERROR_INT_ENA field.
	SPI_DMA_INT_ENA_INLINK_DSCR_ERROR_INT_ENA_Pos = 0x2
	// Bit mask of INLINK_DSCR_ERROR_INT_ENA field.
	SPI_DMA_INT_ENA_INLINK_DSCR_ERROR_INT_ENA_Msk = 0x4
	// Bit INLINK_DSCR_ERROR_INT_ENA.
	SPI_DMA_INT_ENA_INLINK_DSCR_ERROR_INT_ENA = 0x4
	// Position of IN_DONE_INT_ENA field.
	SPI_DMA_INT_ENA_IN_DONE_INT_ENA_Pos = 0x3
	// Bit mask of IN_DONE_INT_ENA field.
	SPI_DMA_INT_ENA_IN_DONE_INT_ENA_Msk = 0x8
	// Bit IN_DONE_INT_ENA.
	SPI_DMA_INT_ENA_IN_DONE_INT_ENA = 0x8
	// Position of IN_ERR_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_IN_ERR_EOF_INT_ENA_Pos = 0x4
	// Bit mask of IN_ERR_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_IN_ERR_EOF_INT_ENA_Msk = 0x10
	// Bit IN_ERR_EOF_INT_ENA.
	SPI_DMA_INT_ENA_IN_ERR_EOF_INT_ENA = 0x10
	// Position of IN_SUC_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_IN_SUC_EOF_INT_ENA_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_IN_SUC_EOF_INT_ENA_Msk = 0x20
	// Bit IN_SUC_EOF_INT_ENA.
	SPI_DMA_INT_ENA_IN_SUC_EOF_INT_ENA = 0x20
	// Position of OUT_DONE_INT_ENA field.
	SPI_DMA_INT_ENA_OUT_DONE_INT_ENA_Pos = 0x6
	// Bit mask of OUT_DONE_INT_ENA field.
	SPI_DMA_INT_ENA_OUT_DONE_INT_ENA_Msk = 0x40
	// Bit OUT_DONE_INT_ENA.
	SPI_DMA_INT_ENA_OUT_DONE_INT_ENA = 0x40
	// Position of OUT_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_OUT_EOF_INT_ENA_Pos = 0x7
	// Bit mask of OUT_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_OUT_EOF_INT_ENA_Msk = 0x80
	// Bit OUT_EOF_INT_ENA.
	SPI_DMA_INT_ENA_OUT_EOF_INT_ENA = 0x80
	// Position of OUT_TOTAL_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Pos = 0x8
	// Bit mask of OUT_TOTAL_EOF_INT_ENA field.
	SPI_DMA_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Msk = 0x100
	// Bit OUT_TOTAL_EOF_INT_ENA.
	SPI_DMA_INT_ENA_OUT_TOTAL_EOF_INT_ENA = 0x100
	// Position of INFIFO_FULL_ERR_INT_ENA field.
	SPI_DMA_INT_ENA_INFIFO_FULL_ERR_INT_ENA_Pos = 0x9
	// Bit mask of INFIFO_FULL_ERR_INT_ENA field.
	SPI_DMA_INT_ENA_INFIFO_FULL_ERR_INT_ENA_Msk = 0x200
	// Bit INFIFO_FULL_ERR_INT_ENA.
	SPI_DMA_INT_ENA_INFIFO_FULL_ERR_INT_ENA = 0x200
	// Position of OUTFIFO_EMPTY_ERR_INT_ENA field.
	SPI_DMA_INT_ENA_OUTFIFO_EMPTY_ERR_INT_ENA_Pos = 0xa
	// Bit mask of OUTFIFO_EMPTY_ERR_INT_ENA field.
	SPI_DMA_INT_ENA_OUTFIFO_EMPTY_ERR_INT_ENA_Msk = 0x400
	// Bit OUTFIFO_EMPTY_ERR_INT_ENA.
	SPI_DMA_INT_ENA_OUTFIFO_EMPTY_ERR_INT_ENA = 0x400
	// Position of SLV_CMD6_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD6_INT_ENA_Pos = 0xb
	// Bit mask of SLV_CMD6_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD6_INT_ENA_Msk = 0x800
	// Bit SLV_CMD6_INT_ENA.
	SPI_DMA_INT_ENA_SLV_CMD6_INT_ENA = 0x800
	// Position of SLV_CMD7_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD7_INT_ENA_Pos = 0xc
	// Bit mask of SLV_CMD7_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD7_INT_ENA_Msk = 0x1000
	// Bit SLV_CMD7_INT_ENA.
	SPI_DMA_INT_ENA_SLV_CMD7_INT_ENA = 0x1000
	// Position of SLV_CMD8_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD8_INT_ENA_Pos = 0xd
	// Bit mask of SLV_CMD8_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD8_INT_ENA_Msk = 0x2000
	// Bit SLV_CMD8_INT_ENA.
	SPI_DMA_INT_ENA_SLV_CMD8_INT_ENA = 0x2000
	// Position of SLV_CMD9_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD9_INT_ENA_Pos = 0xe
	// Bit mask of SLV_CMD9_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMD9_INT_ENA_Msk = 0x4000
	// Bit SLV_CMD9_INT_ENA.
	SPI_DMA_INT_ENA_SLV_CMD9_INT_ENA = 0x4000
	// Position of SLV_CMDA_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMDA_INT_ENA_Pos = 0xf
	// Bit mask of SLV_CMDA_INT_ENA field.
	SPI_DMA_INT_ENA_SLV_CMDA_INT_ENA_Msk = 0x8000
	// Bit SLV_CMDA_INT_ENA.
	SPI_DMA_INT_ENA_SLV_CMDA_INT_ENA = 0x8000

	// DMA_INT_RAW: SPI DMA interrupt raw register
	// Position of INLINK_DSCR_EMPTY_INT_RAW field.
	SPI_DMA_INT_RAW_INLINK_DSCR_EMPTY_INT_RAW_Pos = 0x0
	// Bit mask of INLINK_DSCR_EMPTY_INT_RAW field.
	SPI_DMA_INT_RAW_INLINK_DSCR_EMPTY_INT_RAW_Msk = 0x1
	// Bit INLINK_DSCR_EMPTY_INT_RAW.
	SPI_DMA_INT_RAW_INLINK_DSCR_EMPTY_INT_RAW = 0x1
	// Position of OUTLINK_DSCR_ERROR_INT_RAW field.
	SPI_DMA_INT_RAW_OUTLINK_DSCR_ERROR_INT_RAW_Pos = 0x1
	// Bit mask of OUTLINK_DSCR_ERROR_INT_RAW field.
	SPI_DMA_INT_RAW_OUTLINK_DSCR_ERROR_INT_RAW_Msk = 0x2
	// Bit OUTLINK_DSCR_ERROR_INT_RAW.
	SPI_DMA_INT_RAW_OUTLINK_DSCR_ERROR_INT_RAW = 0x2
	// Position of INLINK_DSCR_ERROR_INT_RAW field.
	SPI_DMA_INT_RAW_INLINK_DSCR_ERROR_INT_RAW_Pos = 0x2
	// Bit mask of INLINK_DSCR_ERROR_INT_RAW field.
	SPI_DMA_INT_RAW_INLINK_DSCR_ERROR_INT_RAW_Msk = 0x4
	// Bit INLINK_DSCR_ERROR_INT_RAW.
	SPI_DMA_INT_RAW_INLINK_DSCR_ERROR_INT_RAW = 0x4
	// Position of IN_DONE_INT_RAW field.
	SPI_DMA_INT_RAW_IN_DONE_INT_RAW_Pos = 0x3
	// Bit mask of IN_DONE_INT_RAW field.
	SPI_DMA_INT_RAW_IN_DONE_INT_RAW_Msk = 0x8
	// Bit IN_DONE_INT_RAW.
	SPI_DMA_INT_RAW_IN_DONE_INT_RAW = 0x8
	// Position of IN_ERR_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_IN_ERR_EOF_INT_RAW_Pos = 0x4
	// Bit mask of IN_ERR_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_IN_ERR_EOF_INT_RAW_Msk = 0x10
	// Bit IN_ERR_EOF_INT_RAW.
	SPI_DMA_INT_RAW_IN_ERR_EOF_INT_RAW = 0x10
	// Position of IN_SUC_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_IN_SUC_EOF_INT_RAW_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_IN_SUC_EOF_INT_RAW_Msk = 0x20
	// Bit IN_SUC_EOF_INT_RAW.
	SPI_DMA_INT_RAW_IN_SUC_EOF_INT_RAW = 0x20
	// Position of OUT_DONE_INT_RAW field.
	SPI_DMA_INT_RAW_OUT_DONE_INT_RAW_Pos = 0x6
	// Bit mask of OUT_DONE_INT_RAW field.
	SPI_DMA_INT_RAW_OUT_DONE_INT_RAW_Msk = 0x40
	// Bit OUT_DONE_INT_RAW.
	SPI_DMA_INT_RAW_OUT_DONE_INT_RAW = 0x40
	// Position of OUT_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_OUT_EOF_INT_RAW_Pos = 0x7
	// Bit mask of OUT_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_OUT_EOF_INT_RAW_Msk = 0x80
	// Bit OUT_EOF_INT_RAW.
	SPI_DMA_INT_RAW_OUT_EOF_INT_RAW = 0x80
	// Position of OUT_TOTAL_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Pos = 0x8
	// Bit mask of OUT_TOTAL_EOF_INT_RAW field.
	SPI_DMA_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Msk = 0x100
	// Bit OUT_TOTAL_EOF_INT_RAW.
	SPI_DMA_INT_RAW_OUT_TOTAL_EOF_INT_RAW = 0x100
	// Position of INFIFO_FULL_ERR_INT_RAW field.
	SPI_DMA_INT_RAW_INFIFO_FULL_ERR_INT_RAW_Pos = 0x9
	// Bit mask of INFIFO_FULL_ERR_INT_RAW field.
	SPI_DMA_INT_RAW_INFIFO_FULL_ERR_INT_RAW_Msk = 0x200
	// Bit INFIFO_FULL_ERR_INT_RAW.
	SPI_DMA_INT_RAW_INFIFO_FULL_ERR_INT_RAW = 0x200
	// Position of OUTFIFO_EMPTY_ERR_INT_RAW field.
	SPI_DMA_INT_RAW_OUTFIFO_EMPTY_ERR_INT_RAW_Pos = 0xa
	// Bit mask of OUTFIFO_EMPTY_ERR_INT_RAW field.
	SPI_DMA_INT_RAW_OUTFIFO_EMPTY_ERR_INT_RAW_Msk = 0x400
	// Bit OUTFIFO_EMPTY_ERR_INT_RAW.
	SPI_DMA_INT_RAW_OUTFIFO_EMPTY_ERR_INT_RAW = 0x400
	// Position of SLV_CMD6_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD6_INT_RAW_Pos = 0xb
	// Bit mask of SLV_CMD6_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD6_INT_RAW_Msk = 0x800
	// Bit SLV_CMD6_INT_RAW.
	SPI_DMA_INT_RAW_SLV_CMD6_INT_RAW = 0x800
	// Position of SLV_CMD7_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD7_INT_RAW_Pos = 0xc
	// Bit mask of SLV_CMD7_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD7_INT_RAW_Msk = 0x1000
	// Bit SLV_CMD7_INT_RAW.
	SPI_DMA_INT_RAW_SLV_CMD7_INT_RAW = 0x1000
	// Position of SLV_CMD8_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD8_INT_RAW_Pos = 0xd
	// Bit mask of SLV_CMD8_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD8_INT_RAW_Msk = 0x2000
	// Bit SLV_CMD8_INT_RAW.
	SPI_DMA_INT_RAW_SLV_CMD8_INT_RAW = 0x2000
	// Position of SLV_CMD9_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD9_INT_RAW_Pos = 0xe
	// Bit mask of SLV_CMD9_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMD9_INT_RAW_Msk = 0x4000
	// Bit SLV_CMD9_INT_RAW.
	SPI_DMA_INT_RAW_SLV_CMD9_INT_RAW = 0x4000
	// Position of SLV_CMDA_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMDA_INT_RAW_Pos = 0xf
	// Bit mask of SLV_CMDA_INT_RAW field.
	SPI_DMA_INT_RAW_SLV_CMDA_INT_RAW_Msk = 0x8000
	// Bit SLV_CMDA_INT_RAW.
	SPI_DMA_INT_RAW_SLV_CMDA_INT_RAW = 0x8000

	// DMA_INT_ST: SPI DMA interrupt status register
	// Position of INLINK_DSCR_EMPTY_INT_ST field.
	SPI_DMA_INT_ST_INLINK_DSCR_EMPTY_INT_ST_Pos = 0x0
	// Bit mask of INLINK_DSCR_EMPTY_INT_ST field.
	SPI_DMA_INT_ST_INLINK_DSCR_EMPTY_INT_ST_Msk = 0x1
	// Bit INLINK_DSCR_EMPTY_INT_ST.
	SPI_DMA_INT_ST_INLINK_DSCR_EMPTY_INT_ST = 0x1
	// Position of OUTLINK_DSCR_ERROR_INT_ST field.
	SPI_DMA_INT_ST_OUTLINK_DSCR_ERROR_INT_ST_Pos = 0x1
	// Bit mask of OUTLINK_DSCR_ERROR_INT_ST field.
	SPI_DMA_INT_ST_OUTLINK_DSCR_ERROR_INT_ST_Msk = 0x2
	// Bit OUTLINK_DSCR_ERROR_INT_ST.
	SPI_DMA_INT_ST_OUTLINK_DSCR_ERROR_INT_ST = 0x2
	// Position of INLINK_DSCR_ERROR_INT_ST field.
	SPI_DMA_INT_ST_INLINK_DSCR_ERROR_INT_ST_Pos = 0x2
	// Bit mask of INLINK_DSCR_ERROR_INT_ST field.
	SPI_DMA_INT_ST_INLINK_DSCR_ERROR_INT_ST_Msk = 0x4
	// Bit INLINK_DSCR_ERROR_INT_ST.
	SPI_DMA_INT_ST_INLINK_DSCR_ERROR_INT_ST = 0x4
	// Position of IN_DONE_INT_ST field.
	SPI_DMA_INT_ST_IN_DONE_INT_ST_Pos = 0x3
	// Bit mask of IN_DONE_INT_ST field.
	SPI_DMA_INT_ST_IN_DONE_INT_ST_Msk = 0x8
	// Bit IN_DONE_INT_ST.
	SPI_DMA_INT_ST_IN_DONE_INT_ST = 0x8
	// Position of IN_ERR_EOF_INT_ST field.
	SPI_DMA_INT_ST_IN_ERR_EOF_INT_ST_Pos = 0x4
	// Bit mask of IN_ERR_EOF_INT_ST field.
	SPI_DMA_INT_ST_IN_ERR_EOF_INT_ST_Msk = 0x10
	// Bit IN_ERR_EOF_INT_ST.
	SPI_DMA_INT_ST_IN_ERR_EOF_INT_ST = 0x10
	// Position of IN_SUC_EOF_INT_ST field.
	SPI_DMA_INT_ST_IN_SUC_EOF_INT_ST_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_ST field.
	SPI_DMA_INT_ST_IN_SUC_EOF_INT_ST_Msk = 0x20
	// Bit IN_SUC_EOF_INT_ST.
	SPI_DMA_INT_ST_IN_SUC_EOF_INT_ST = 0x20
	// Position of OUT_DONE_INT_ST field.
	SPI_DMA_INT_ST_OUT_DONE_INT_ST_Pos = 0x6
	// Bit mask of OUT_DONE_INT_ST field.
	SPI_DMA_INT_ST_OUT_DONE_INT_ST_Msk = 0x40
	// Bit OUT_DONE_INT_ST.
	SPI_DMA_INT_ST_OUT_DONE_INT_ST = 0x40
	// Position of OUT_EOF_INT_ST field.
	SPI_DMA_INT_ST_OUT_EOF_INT_ST_Pos = 0x7
	// Bit mask of OUT_EOF_INT_ST field.
	SPI_DMA_INT_ST_OUT_EOF_INT_ST_Msk = 0x80
	// Bit OUT_EOF_INT_ST.
	SPI_DMA_INT_ST_OUT_EOF_INT_ST = 0x80
	// Position of OUT_TOTAL_EOF_INT_ST field.
	SPI_DMA_INT_ST_OUT_TOTAL_EOF_INT_ST_Pos = 0x8
	// Bit mask of OUT_TOTAL_EOF_INT_ST field.
	SPI_DMA_INT_ST_OUT_TOTAL_EOF_INT_ST_Msk = 0x100
	// Bit OUT_TOTAL_EOF_INT_ST.
	SPI_DMA_INT_ST_OUT_TOTAL_EOF_INT_ST = 0x100
	// Position of INFIFO_FULL_ERR_INT_ST field.
	SPI_DMA_INT_ST_INFIFO_FULL_ERR_INT_ST_Pos = 0x9
	// Bit mask of INFIFO_FULL_ERR_INT_ST field.
	SPI_DMA_INT_ST_INFIFO_FULL_ERR_INT_ST_Msk = 0x200
	// Bit INFIFO_FULL_ERR_INT_ST.
	SPI_DMA_INT_ST_INFIFO_FULL_ERR_INT_ST = 0x200
	// Position of OUTFIFO_EMPTY_ERR_INT_ST field.
	SPI_DMA_INT_ST_OUTFIFO_EMPTY_ERR_INT_ST_Pos = 0xa
	// Bit mask of OUTFIFO_EMPTY_ERR_INT_ST field.
	SPI_DMA_INT_ST_OUTFIFO_EMPTY_ERR_INT_ST_Msk = 0x400
	// Bit OUTFIFO_EMPTY_ERR_INT_ST.
	SPI_DMA_INT_ST_OUTFIFO_EMPTY_ERR_INT_ST = 0x400
	// Position of SLV_CMD6_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD6_INT_ST_Pos = 0xb
	// Bit mask of SLV_CMD6_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD6_INT_ST_Msk = 0x800
	// Bit SLV_CMD6_INT_ST.
	SPI_DMA_INT_ST_SLV_CMD6_INT_ST = 0x800
	// Position of SLV_CMD7_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD7_INT_ST_Pos = 0xc
	// Bit mask of SLV_CMD7_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD7_INT_ST_Msk = 0x1000
	// Bit SLV_CMD7_INT_ST.
	SPI_DMA_INT_ST_SLV_CMD7_INT_ST = 0x1000
	// Position of SLV_CMD8_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD8_INT_ST_Pos = 0xd
	// Bit mask of SLV_CMD8_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD8_INT_ST_Msk = 0x2000
	// Bit SLV_CMD8_INT_ST.
	SPI_DMA_INT_ST_SLV_CMD8_INT_ST = 0x2000
	// Position of SLV_CMD9_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD9_INT_ST_Pos = 0xe
	// Bit mask of SLV_CMD9_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMD9_INT_ST_Msk = 0x4000
	// Bit SLV_CMD9_INT_ST.
	SPI_DMA_INT_ST_SLV_CMD9_INT_ST = 0x4000
	// Position of SLV_CMDA_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMDA_INT_ST_Pos = 0xf
	// Bit mask of SLV_CMDA_INT_ST field.
	SPI_DMA_INT_ST_SLV_CMDA_INT_ST_Msk = 0x8000
	// Bit SLV_CMDA_INT_ST.
	SPI_DMA_INT_ST_SLV_CMDA_INT_ST = 0x8000

	// DMA_INT_CLR: SPI DMA interrupt clear register
	// Position of INLINK_DSCR_EMPTY_INT_CLR field.
	SPI_DMA_INT_CLR_INLINK_DSCR_EMPTY_INT_CLR_Pos = 0x0
	// Bit mask of INLINK_DSCR_EMPTY_INT_CLR field.
	SPI_DMA_INT_CLR_INLINK_DSCR_EMPTY_INT_CLR_Msk = 0x1
	// Bit INLINK_DSCR_EMPTY_INT_CLR.
	SPI_DMA_INT_CLR_INLINK_DSCR_EMPTY_INT_CLR = 0x1
	// Position of OUTLINK_DSCR_ERROR_INT_CLR field.
	SPI_DMA_INT_CLR_OUTLINK_DSCR_ERROR_INT_CLR_Pos = 0x1
	// Bit mask of OUTLINK_DSCR_ERROR_INT_CLR field.
	SPI_DMA_INT_CLR_OUTLINK_DSCR_ERROR_INT_CLR_Msk = 0x2
	// Bit OUTLINK_DSCR_ERROR_INT_CLR.
	SPI_DMA_INT_CLR_OUTLINK_DSCR_ERROR_INT_CLR = 0x2
	// Position of INLINK_DSCR_ERROR_INT_CLR field.
	SPI_DMA_INT_CLR_INLINK_DSCR_ERROR_INT_CLR_Pos = 0x2
	// Bit mask of INLINK_DSCR_ERROR_INT_CLR field.
	SPI_DMA_INT_CLR_INLINK_DSCR_ERROR_INT_CLR_Msk = 0x4
	// Bit INLINK_DSCR_ERROR_INT_CLR.
	SPI_DMA_INT_CLR_INLINK_DSCR_ERROR_INT_CLR = 0x4
	// Position of IN_DONE_INT_CLR field.
	SPI_DMA_INT_CLR_IN_DONE_INT_CLR_Pos = 0x3
	// Bit mask of IN_DONE_INT_CLR field.
	SPI_DMA_INT_CLR_IN_DONE_INT_CLR_Msk = 0x8
	// Bit IN_DONE_INT_CLR.
	SPI_DMA_INT_CLR_IN_DONE_INT_CLR = 0x8
	// Position of IN_ERR_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_IN_ERR_EOF_INT_CLR_Pos = 0x4
	// Bit mask of IN_ERR_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_IN_ERR_EOF_INT_CLR_Msk = 0x10
	// Bit IN_ERR_EOF_INT_CLR.
	SPI_DMA_INT_CLR_IN_ERR_EOF_INT_CLR = 0x10
	// Position of IN_SUC_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_IN_SUC_EOF_INT_CLR_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_IN_SUC_EOF_INT_CLR_Msk = 0x20
	// Bit IN_SUC_EOF_INT_CLR.
	SPI_DMA_INT_CLR_IN_SUC_EOF_INT_CLR = 0x20
	// Position of OUT_DONE_INT_CLR field.
	SPI_DMA_INT_CLR_OUT_DONE_INT_CLR_Pos = 0x6
	// Bit mask of OUT_DONE_INT_CLR field.
	SPI_DMA_INT_CLR_OUT_DONE_INT_CLR_Msk = 0x40
	// Bit OUT_DONE_INT_CLR.
	SPI_DMA_INT_CLR_OUT_DONE_INT_CLR = 0x40
	// Position of OUT_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_OUT_EOF_INT_CLR_Pos = 0x7
	// Bit mask of OUT_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_OUT_EOF_INT_CLR_Msk = 0x80
	// Bit OUT_EOF_INT_CLR.
	SPI_DMA_INT_CLR_OUT_EOF_INT_CLR = 0x80
	// Position of OUT_TOTAL_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Pos = 0x8
	// Bit mask of OUT_TOTAL_EOF_INT_CLR field.
	SPI_DMA_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Msk = 0x100
	// Bit OUT_TOTAL_EOF_INT_CLR.
	SPI_DMA_INT_CLR_OUT_TOTAL_EOF_INT_CLR = 0x100
	// Position of INFIFO_FULL_ERR_INT_CLR field.
	SPI_DMA_INT_CLR_INFIFO_FULL_ERR_INT_CLR_Pos = 0x9
	// Bit mask of INFIFO_FULL_ERR_INT_CLR field.
	SPI_DMA_INT_CLR_INFIFO_FULL_ERR_INT_CLR_Msk = 0x200
	// Bit INFIFO_FULL_ERR_INT_CLR.
	SPI_DMA_INT_CLR_INFIFO_FULL_ERR_INT_CLR = 0x200
	// Position of OUTFIFO_EMPTY_ERR_INT_CLR field.
	SPI_DMA_INT_CLR_OUTFIFO_EMPTY_ERR_INT_CLR_Pos = 0xa
	// Bit mask of OUTFIFO_EMPTY_ERR_INT_CLR field.
	SPI_DMA_INT_CLR_OUTFIFO_EMPTY_ERR_INT_CLR_Msk = 0x400
	// Bit OUTFIFO_EMPTY_ERR_INT_CLR.
	SPI_DMA_INT_CLR_OUTFIFO_EMPTY_ERR_INT_CLR = 0x400
	// Position of SLV_CMD6_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD6_INT_CLR_Pos = 0xb
	// Bit mask of SLV_CMD6_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD6_INT_CLR_Msk = 0x800
	// Bit SLV_CMD6_INT_CLR.
	SPI_DMA_INT_CLR_SLV_CMD6_INT_CLR = 0x800
	// Position of SLV_CMD7_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD7_INT_CLR_Pos = 0xc
	// Bit mask of SLV_CMD7_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD7_INT_CLR_Msk = 0x1000
	// Bit SLV_CMD7_INT_CLR.
	SPI_DMA_INT_CLR_SLV_CMD7_INT_CLR = 0x1000
	// Position of SLV_CMD8_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD8_INT_CLR_Pos = 0xd
	// Bit mask of SLV_CMD8_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD8_INT_CLR_Msk = 0x2000
	// Bit SLV_CMD8_INT_CLR.
	SPI_DMA_INT_CLR_SLV_CMD8_INT_CLR = 0x2000
	// Position of SLV_CMD9_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD9_INT_CLR_Pos = 0xe
	// Bit mask of SLV_CMD9_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMD9_INT_CLR_Msk = 0x4000
	// Bit SLV_CMD9_INT_CLR.
	SPI_DMA_INT_CLR_SLV_CMD9_INT_CLR = 0x4000
	// Position of SLV_CMDA_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMDA_INT_CLR_Pos = 0xf
	// Bit mask of SLV_CMDA_INT_CLR field.
	SPI_DMA_INT_CLR_SLV_CMDA_INT_CLR_Msk = 0x8000
	// Bit SLV_CMDA_INT_CLR.
	SPI_DMA_INT_CLR_SLV_CMDA_INT_CLR = 0x8000

	// IN_ERR_EOF_DES_ADDR: The latest SPI DMA RX descriptor address receiving error
	// Position of DMA_IN_ERR_EOF_DES_ADDR field.
	SPI_IN_ERR_EOF_DES_ADDR_DMA_IN_ERR_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of DMA_IN_ERR_EOF_DES_ADDR field.
	SPI_IN_ERR_EOF_DES_ADDR_DMA_IN_ERR_EOF_DES_ADDR_Msk = 0xffffffff

	// IN_SUC_EOF_DES_ADDR: The latest SPI DMA eof RX descriptor address
	// Position of DMA_IN_SUC_EOF_DES_ADDR field.
	SPI_IN_SUC_EOF_DES_ADDR_DMA_IN_SUC_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of DMA_IN_SUC_EOF_DES_ADDR field.
	SPI_IN_SUC_EOF_DES_ADDR_DMA_IN_SUC_EOF_DES_ADDR_Msk = 0xffffffff

	// INLINK_DSCR: Current SPI DMA RX descriptor pointer
	// Position of DMA_INLINK_DSCR field.
	SPI_INLINK_DSCR_DMA_INLINK_DSCR_Pos = 0x0
	// Bit mask of DMA_INLINK_DSCR field.
	SPI_INLINK_DSCR_DMA_INLINK_DSCR_Msk = 0xffffffff

	// INLINK_DSCR_BF0: Next SPI DMA RX descriptor pointer
	// Position of DMA_INLINK_DSCR_BF0 field.
	SPI_INLINK_DSCR_BF0_DMA_INLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of DMA_INLINK_DSCR_BF0 field.
	SPI_INLINK_DSCR_BF0_DMA_INLINK_DSCR_BF0_Msk = 0xffffffff

	// INLINK_DSCR_BF1: Current SPI DMA RX buffer pointer
	// Position of DMA_INLINK_DSCR_BF1 field.
	SPI_INLINK_DSCR_BF1_DMA_INLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of DMA_INLINK_DSCR_BF1 field.
	SPI_INLINK_DSCR_BF1_DMA_INLINK_DSCR_BF1_Msk = 0xffffffff

	// OUT_EOF_BFR_DES_ADDR: The latest SPI DMA eof TX buffer address
	// Position of DMA_OUT_EOF_BFR_DES_ADDR field.
	SPI_OUT_EOF_BFR_DES_ADDR_DMA_OUT_EOF_BFR_DES_ADDR_Pos = 0x0
	// Bit mask of DMA_OUT_EOF_BFR_DES_ADDR field.
	SPI_OUT_EOF_BFR_DES_ADDR_DMA_OUT_EOF_BFR_DES_ADDR_Msk = 0xffffffff

	// OUT_EOF_DES_ADDR: The latest SPI DMA eof TX descriptor address
	// Position of DMA_OUT_EOF_DES_ADDR field.
	SPI_OUT_EOF_DES_ADDR_DMA_OUT_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of DMA_OUT_EOF_DES_ADDR field.
	SPI_OUT_EOF_DES_ADDR_DMA_OUT_EOF_DES_ADDR_Msk = 0xffffffff

	// OUTLINK_DSCR: Current SPI DMA TX descriptor pointer
	// Position of DMA_OUTLINK_DSCR field.
	SPI_OUTLINK_DSCR_DMA_OUTLINK_DSCR_Pos = 0x0
	// Bit mask of DMA_OUTLINK_DSCR field.
	SPI_OUTLINK_DSCR_DMA_OUTLINK_DSCR_Msk = 0xffffffff

	// OUTLINK_DSCR_BF0: Next SPI DMA TX descriptor pointer
	// Position of DMA_OUTLINK_DSCR_BF0 field.
	SPI_OUTLINK_DSCR_BF0_DMA_OUTLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of DMA_OUTLINK_DSCR_BF0 field.
	SPI_OUTLINK_DSCR_BF0_DMA_OUTLINK_DSCR_BF0_Msk = 0xffffffff

	// OUTLINK_DSCR_BF1: Current SPI DMA TX buffer pointer
	// Position of DMA_OUTLINK_DSCR_BF1 field.
	SPI_OUTLINK_DSCR_BF1_DMA_OUTLINK_DSCR_BF1_Pos = 0x0
	// Bit mask of DMA_OUTLINK_DSCR_BF1 field.
	SPI_OUTLINK_DSCR_BF1_DMA_OUTLINK_DSCR_BF1_Msk = 0xffffffff

	// DMA_OUTSTATUS: SPI DMA TX status
	// Position of DMA_OUTDSCR_ADDR field.
	SPI_DMA_OUTSTATUS_DMA_OUTDSCR_ADDR_Pos = 0x0
	// Bit mask of DMA_OUTDSCR_ADDR field.
	SPI_DMA_OUTSTATUS_DMA_OUTDSCR_ADDR_Msk = 0x3ffff
	// Position of DMA_OUTDSCR_STATE field.
	SPI_DMA_OUTSTATUS_DMA_OUTDSCR_STATE_Pos = 0x12
	// Bit mask of DMA_OUTDSCR_STATE field.
	SPI_DMA_OUTSTATUS_DMA_OUTDSCR_STATE_Msk = 0xc0000
	// Position of DMA_OUT_STATE field.
	SPI_DMA_OUTSTATUS_DMA_OUT_STATE_Pos = 0x14
	// Bit mask of DMA_OUT_STATE field.
	SPI_DMA_OUTSTATUS_DMA_OUT_STATE_Msk = 0x700000
	// Position of DMA_OUTFIFO_CNT field.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_CNT_Pos = 0x17
	// Bit mask of DMA_OUTFIFO_CNT field.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_CNT_Msk = 0x3f800000
	// Position of DMA_OUTFIFO_FULL field.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_FULL_Pos = 0x1e
	// Bit mask of DMA_OUTFIFO_FULL field.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_FULL_Msk = 0x40000000
	// Bit DMA_OUTFIFO_FULL.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_FULL = 0x40000000
	// Position of DMA_OUTFIFO_EMPTY field.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_EMPTY_Pos = 0x1f
	// Bit mask of DMA_OUTFIFO_EMPTY field.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_EMPTY_Msk = 0x80000000
	// Bit DMA_OUTFIFO_EMPTY.
	SPI_DMA_OUTSTATUS_DMA_OUTFIFO_EMPTY = 0x80000000

	// DMA_INSTATUS: SPI DMA RX status
	// Position of DMA_INDSCR_ADDR field.
	SPI_DMA_INSTATUS_DMA_INDSCR_ADDR_Pos = 0x0
	// Bit mask of DMA_INDSCR_ADDR field.
	SPI_DMA_INSTATUS_DMA_INDSCR_ADDR_Msk = 0x3ffff
	// Position of DMA_INDSCR_STATE field.
	SPI_DMA_INSTATUS_DMA_INDSCR_STATE_Pos = 0x12
	// Bit mask of DMA_INDSCR_STATE field.
	SPI_DMA_INSTATUS_DMA_INDSCR_STATE_Msk = 0xc0000
	// Position of DMA_IN_STATE field.
	SPI_DMA_INSTATUS_DMA_IN_STATE_Pos = 0x14
	// Bit mask of DMA_IN_STATE field.
	SPI_DMA_INSTATUS_DMA_IN_STATE_Msk = 0x700000
	// Position of DMA_INFIFO_CNT field.
	SPI_DMA_INSTATUS_DMA_INFIFO_CNT_Pos = 0x17
	// Bit mask of DMA_INFIFO_CNT field.
	SPI_DMA_INSTATUS_DMA_INFIFO_CNT_Msk = 0x3f800000
	// Position of DMA_INFIFO_FULL field.
	SPI_DMA_INSTATUS_DMA_INFIFO_FULL_Pos = 0x1e
	// Bit mask of DMA_INFIFO_FULL field.
	SPI_DMA_INSTATUS_DMA_INFIFO_FULL_Msk = 0x40000000
	// Bit DMA_INFIFO_FULL.
	SPI_DMA_INSTATUS_DMA_INFIFO_FULL = 0x40000000
	// Position of DMA_INFIFO_EMPTY field.
	SPI_DMA_INSTATUS_DMA_INFIFO_EMPTY_Pos = 0x1f
	// Bit mask of DMA_INFIFO_EMPTY field.
	SPI_DMA_INSTATUS_DMA_INFIFO_EMPTY_Msk = 0x80000000
	// Bit DMA_INFIFO_EMPTY.
	SPI_DMA_INSTATUS_DMA_INFIFO_EMPTY = 0x80000000

	// W0: Data buffer 0
	// Position of BUF0 field.
	SPI_W0_BUF0_Pos = 0x0
	// Bit mask of BUF0 field.
	SPI_W0_BUF0_Msk = 0xffffffff

	// W1: Data buffer 1
	// Position of BUF1 field.
	SPI_W1_BUF1_Pos = 0x0
	// Bit mask of BUF1 field.
	SPI_W1_BUF1_Msk = 0xffffffff

	// W2: Data buffer 2
	// Position of BUF2 field.
	SPI_W2_BUF2_Pos = 0x0
	// Bit mask of BUF2 field.
	SPI_W2_BUF2_Msk = 0xffffffff

	// W3: Data buffer 3
	// Position of BUF3 field.
	SPI_W3_BUF3_Pos = 0x0
	// Bit mask of BUF3 field.
	SPI_W3_BUF3_Msk = 0xffffffff

	// W4: Data buffer 4
	// Position of BUF4 field.
	SPI_W4_BUF4_Pos = 0x0
	// Bit mask of BUF4 field.
	SPI_W4_BUF4_Msk = 0xffffffff

	// W5: Data buffer 5
	// Position of BUF5 field.
	SPI_W5_BUF5_Pos = 0x0
	// Bit mask of BUF5 field.
	SPI_W5_BUF5_Msk = 0xffffffff

	// W6: Data buffer 6
	// Position of BUF6 field.
	SPI_W6_BUF6_Pos = 0x0
	// Bit mask of BUF6 field.
	SPI_W6_BUF6_Msk = 0xffffffff

	// W7: Data buffer 7
	// Position of BUF7 field.
	SPI_W7_BUF7_Pos = 0x0
	// Bit mask of BUF7 field.
	SPI_W7_BUF7_Msk = 0xffffffff

	// W8: Data buffer 8
	// Position of BUF8 field.
	SPI_W8_BUF8_Pos = 0x0
	// Bit mask of BUF8 field.
	SPI_W8_BUF8_Msk = 0xffffffff

	// W9: Data buffer 9
	// Position of BUF9 field.
	SPI_W9_BUF9_Pos = 0x0
	// Bit mask of BUF9 field.
	SPI_W9_BUF9_Msk = 0xffffffff

	// W10: Data buffer 10
	// Position of BUF10 field.
	SPI_W10_BUF10_Pos = 0x0
	// Bit mask of BUF10 field.
	SPI_W10_BUF10_Msk = 0xffffffff

	// W11: Data buffer 11
	// Position of BUF11 field.
	SPI_W11_BUF11_Pos = 0x0
	// Bit mask of BUF11 field.
	SPI_W11_BUF11_Msk = 0xffffffff

	// W12: Data buffer 12
	// Position of BUF12 field.
	SPI_W12_BUF12_Pos = 0x0
	// Bit mask of BUF12 field.
	SPI_W12_BUF12_Msk = 0xffffffff

	// W13: Data buffer 13
	// Position of BUF13 field.
	SPI_W13_BUF13_Pos = 0x0
	// Bit mask of BUF13 field.
	SPI_W13_BUF13_Msk = 0xffffffff

	// W14: Data buffer 14
	// Position of BUF14 field.
	SPI_W14_BUF14_Pos = 0x0
	// Bit mask of BUF14 field.
	SPI_W14_BUF14_Msk = 0xffffffff

	// W15: Data buffer 15
	// Position of BUF15 field.
	SPI_W15_BUF15_Pos = 0x0
	// Bit mask of BUF15 field.
	SPI_W15_BUF15_Msk = 0xffffffff

	// W16: Data buffer 16
	// Position of BUF16 field.
	SPI_W16_BUF16_Pos = 0x0
	// Bit mask of BUF16 field.
	SPI_W16_BUF16_Msk = 0xffffffff

	// W17: Data buffer 17
	// Position of BUF17 field.
	SPI_W17_BUF17_Pos = 0x0
	// Bit mask of BUF17 field.
	SPI_W17_BUF17_Msk = 0xffffffff

	// DIN_MODE: SPI input delay mode configuration
	// Position of DIN0_MODE field.
	SPI_DIN_MODE_DIN0_MODE_Pos = 0x0
	// Bit mask of DIN0_MODE field.
	SPI_DIN_MODE_DIN0_MODE_Msk = 0x7
	// Position of DIN1_MODE field.
	SPI_DIN_MODE_DIN1_MODE_Pos = 0x3
	// Bit mask of DIN1_MODE field.
	SPI_DIN_MODE_DIN1_MODE_Msk = 0x38
	// Position of DIN2_MODE field.
	SPI_DIN_MODE_DIN2_MODE_Pos = 0x6
	// Bit mask of DIN2_MODE field.
	SPI_DIN_MODE_DIN2_MODE_Msk = 0x1c0
	// Position of DIN3_MODE field.
	SPI_DIN_MODE_DIN3_MODE_Pos = 0x9
	// Bit mask of DIN3_MODE field.
	SPI_DIN_MODE_DIN3_MODE_Msk = 0xe00
	// Position of DIN4_MODE field.
	SPI_DIN_MODE_DIN4_MODE_Pos = 0xc
	// Bit mask of DIN4_MODE field.
	SPI_DIN_MODE_DIN4_MODE_Msk = 0x7000
	// Position of DIN5_MODE field.
	SPI_DIN_MODE_DIN5_MODE_Pos = 0xf
	// Bit mask of DIN5_MODE field.
	SPI_DIN_MODE_DIN5_MODE_Msk = 0x38000
	// Position of DIN6_MODE field.
	SPI_DIN_MODE_DIN6_MODE_Pos = 0x12
	// Bit mask of DIN6_MODE field.
	SPI_DIN_MODE_DIN6_MODE_Msk = 0x1c0000
	// Position of DIN7_MODE field.
	SPI_DIN_MODE_DIN7_MODE_Pos = 0x15
	// Bit mask of DIN7_MODE field.
	SPI_DIN_MODE_DIN7_MODE_Msk = 0xe00000
	// Position of TIMING_CLK_ENA field.
	SPI_DIN_MODE_TIMING_CLK_ENA_Pos = 0x18
	// Bit mask of TIMING_CLK_ENA field.
	SPI_DIN_MODE_TIMING_CLK_ENA_Msk = 0x1000000
	// Bit TIMING_CLK_ENA.
	SPI_DIN_MODE_TIMING_CLK_ENA = 0x1000000

	// DIN_NUM: SPI input delay number configuration
	// Position of DIN0_NUM field.
	SPI_DIN_NUM_DIN0_NUM_Pos = 0x0
	// Bit mask of DIN0_NUM field.
	SPI_DIN_NUM_DIN0_NUM_Msk = 0x3
	// Position of DIN1_NUM field.
	SPI_DIN_NUM_DIN1_NUM_Pos = 0x2
	// Bit mask of DIN1_NUM field.
	SPI_DIN_NUM_DIN1_NUM_Msk = 0xc
	// Position of DIN2_NUM field.
	SPI_DIN_NUM_DIN2_NUM_Pos = 0x4
	// Bit mask of DIN2_NUM field.
	SPI_DIN_NUM_DIN2_NUM_Msk = 0x30
	// Position of DIN3_NUM field.
	SPI_DIN_NUM_DIN3_NUM_Pos = 0x6
	// Bit mask of DIN3_NUM field.
	SPI_DIN_NUM_DIN3_NUM_Msk = 0xc0
	// Position of DIN4_NUM field.
	SPI_DIN_NUM_DIN4_NUM_Pos = 0x8
	// Bit mask of DIN4_NUM field.
	SPI_DIN_NUM_DIN4_NUM_Msk = 0x300
	// Position of DIN5_NUM field.
	SPI_DIN_NUM_DIN5_NUM_Pos = 0xa
	// Bit mask of DIN5_NUM field.
	SPI_DIN_NUM_DIN5_NUM_Msk = 0xc00
	// Position of DIN6_NUM field.
	SPI_DIN_NUM_DIN6_NUM_Pos = 0xc
	// Bit mask of DIN6_NUM field.
	SPI_DIN_NUM_DIN6_NUM_Msk = 0x3000
	// Position of DIN7_NUM field.
	SPI_DIN_NUM_DIN7_NUM_Pos = 0xe
	// Bit mask of DIN7_NUM field.
	SPI_DIN_NUM_DIN7_NUM_Msk = 0xc000

	// DOUT_MODE: SPI output delay mode configuration
	// Position of DOUT0_MODE field.
	SPI_DOUT_MODE_DOUT0_MODE_Pos = 0x0
	// Bit mask of DOUT0_MODE field.
	SPI_DOUT_MODE_DOUT0_MODE_Msk = 0x7
	// Position of DOUT1_MODE field.
	SPI_DOUT_MODE_DOUT1_MODE_Pos = 0x3
	// Bit mask of DOUT1_MODE field.
	SPI_DOUT_MODE_DOUT1_MODE_Msk = 0x38
	// Position of DOUT2_MODE field.
	SPI_DOUT_MODE_DOUT2_MODE_Pos = 0x6
	// Bit mask of DOUT2_MODE field.
	SPI_DOUT_MODE_DOUT2_MODE_Msk = 0x1c0
	// Position of DOUT3_MODE field.
	SPI_DOUT_MODE_DOUT3_MODE_Pos = 0x9
	// Bit mask of DOUT3_MODE field.
	SPI_DOUT_MODE_DOUT3_MODE_Msk = 0xe00
	// Position of DOUT4_MODE field.
	SPI_DOUT_MODE_DOUT4_MODE_Pos = 0xc
	// Bit mask of DOUT4_MODE field.
	SPI_DOUT_MODE_DOUT4_MODE_Msk = 0x7000
	// Position of DOUT5_MODE field.
	SPI_DOUT_MODE_DOUT5_MODE_Pos = 0xf
	// Bit mask of DOUT5_MODE field.
	SPI_DOUT_MODE_DOUT5_MODE_Msk = 0x38000
	// Position of DOUT6_MODE field.
	SPI_DOUT_MODE_DOUT6_MODE_Pos = 0x12
	// Bit mask of DOUT6_MODE field.
	SPI_DOUT_MODE_DOUT6_MODE_Msk = 0x1c0000
	// Position of DOUT7_MODE field.
	SPI_DOUT_MODE_DOUT7_MODE_Pos = 0x15
	// Bit mask of DOUT7_MODE field.
	SPI_DOUT_MODE_DOUT7_MODE_Msk = 0xe00000

	// DOUT_NUM: SPI output delay number configuration
	// Position of DOUT0_NUM field.
	SPI_DOUT_NUM_DOUT0_NUM_Pos = 0x0
	// Bit mask of DOUT0_NUM field.
	SPI_DOUT_NUM_DOUT0_NUM_Msk = 0x3
	// Position of DOUT1_NUM field.
	SPI_DOUT_NUM_DOUT1_NUM_Pos = 0x2
	// Bit mask of DOUT1_NUM field.
	SPI_DOUT_NUM_DOUT1_NUM_Msk = 0xc
	// Position of DOUT2_NUM field.
	SPI_DOUT_NUM_DOUT2_NUM_Pos = 0x4
	// Bit mask of DOUT2_NUM field.
	SPI_DOUT_NUM_DOUT2_NUM_Msk = 0x30
	// Position of DOUT3_NUM field.
	SPI_DOUT_NUM_DOUT3_NUM_Pos = 0x6
	// Bit mask of DOUT3_NUM field.
	SPI_DOUT_NUM_DOUT3_NUM_Msk = 0xc0
	// Position of DOUT4_NUM field.
	SPI_DOUT_NUM_DOUT4_NUM_Pos = 0x8
	// Bit mask of DOUT4_NUM field.
	SPI_DOUT_NUM_DOUT4_NUM_Msk = 0x300
	// Position of DOUT5_NUM field.
	SPI_DOUT_NUM_DOUT5_NUM_Pos = 0xa
	// Bit mask of DOUT5_NUM field.
	SPI_DOUT_NUM_DOUT5_NUM_Msk = 0xc00
	// Position of DOUT6_NUM field.
	SPI_DOUT_NUM_DOUT6_NUM_Pos = 0xc
	// Bit mask of DOUT6_NUM field.
	SPI_DOUT_NUM_DOUT6_NUM_Msk = 0x3000
	// Position of DOUT7_NUM field.
	SPI_DOUT_NUM_DOUT7_NUM_Pos = 0xe
	// Bit mask of DOUT7_NUM field.
	SPI_DOUT_NUM_DOUT7_NUM_Msk = 0xc000

	// LCD_CTRL: LCD frame control register
	// Position of LCD_HB_FRONT field.
	SPI_LCD_CTRL_LCD_HB_FRONT_Pos = 0x0
	// Bit mask of LCD_HB_FRONT field.
	SPI_LCD_CTRL_LCD_HB_FRONT_Msk = 0x7ff
	// Position of LCD_VA_HEIGHT field.
	SPI_LCD_CTRL_LCD_VA_HEIGHT_Pos = 0xb
	// Bit mask of LCD_VA_HEIGHT field.
	SPI_LCD_CTRL_LCD_VA_HEIGHT_Msk = 0x1ff800
	// Position of LCD_VT_HEIGHT field.
	SPI_LCD_CTRL_LCD_VT_HEIGHT_Pos = 0x15
	// Bit mask of LCD_VT_HEIGHT field.
	SPI_LCD_CTRL_LCD_VT_HEIGHT_Msk = 0x7fe00000
	// Position of LCD_MODE_EN field.
	SPI_LCD_CTRL_LCD_MODE_EN_Pos = 0x1f
	// Bit mask of LCD_MODE_EN field.
	SPI_LCD_CTRL_LCD_MODE_EN_Msk = 0x80000000
	// Bit LCD_MODE_EN.
	SPI_LCD_CTRL_LCD_MODE_EN = 0x80000000

	// LCD_CTRL1: LCD frame control1 register
	// Position of LCD_VB_FRONT field.
	SPI_LCD_CTRL1_LCD_VB_FRONT_Pos = 0x0
	// Bit mask of LCD_VB_FRONT field.
	SPI_LCD_CTRL1_LCD_VB_FRONT_Msk = 0xff
	// Position of LCD_HA_WIDTH field.
	SPI_LCD_CTRL1_LCD_HA_WIDTH_Pos = 0x8
	// Bit mask of LCD_HA_WIDTH field.
	SPI_LCD_CTRL1_LCD_HA_WIDTH_Msk = 0xfff00
	// Position of LCD_HT_WIDTH field.
	SPI_LCD_CTRL1_LCD_HT_WIDTH_Pos = 0x14
	// Bit mask of LCD_HT_WIDTH field.
	SPI_LCD_CTRL1_LCD_HT_WIDTH_Msk = 0xfff00000

	// LCD_CTRL2: LCD frame control2 register
	// Position of LCD_VSYNC_WIDTH field.
	SPI_LCD_CTRL2_LCD_VSYNC_WIDTH_Pos = 0x0
	// Bit mask of LCD_VSYNC_WIDTH field.
	SPI_LCD_CTRL2_LCD_VSYNC_WIDTH_Msk = 0x7f
	// Position of VSYNC_IDLE_POL field.
	SPI_LCD_CTRL2_VSYNC_IDLE_POL_Pos = 0x7
	// Bit mask of VSYNC_IDLE_POL field.
	SPI_LCD_CTRL2_VSYNC_IDLE_POL_Msk = 0x80
	// Bit VSYNC_IDLE_POL.
	SPI_LCD_CTRL2_VSYNC_IDLE_POL = 0x80
	// Position of LCD_HSYNC_WIDTH field.
	SPI_LCD_CTRL2_LCD_HSYNC_WIDTH_Pos = 0x10
	// Bit mask of LCD_HSYNC_WIDTH field.
	SPI_LCD_CTRL2_LCD_HSYNC_WIDTH_Msk = 0x7f0000
	// Position of HSYNC_IDLE_POL field.
	SPI_LCD_CTRL2_HSYNC_IDLE_POL_Pos = 0x17
	// Bit mask of HSYNC_IDLE_POL field.
	SPI_LCD_CTRL2_HSYNC_IDLE_POL_Msk = 0x800000
	// Bit HSYNC_IDLE_POL.
	SPI_LCD_CTRL2_HSYNC_IDLE_POL = 0x800000
	// Position of LCD_HSYNC_POSITION field.
	SPI_LCD_CTRL2_LCD_HSYNC_POSITION_Pos = 0x18
	// Bit mask of LCD_HSYNC_POSITION field.
	SPI_LCD_CTRL2_LCD_HSYNC_POSITION_Msk = 0xff000000

	// LCD_D_MODE: LCD delay number
	// Position of D_DQS_MODE field.
	SPI_LCD_D_MODE_D_DQS_MODE_Pos = 0x0
	// Bit mask of D_DQS_MODE field.
	SPI_LCD_D_MODE_D_DQS_MODE_Msk = 0x7
	// Position of D_CD_MODE field.
	SPI_LCD_D_MODE_D_CD_MODE_Pos = 0x3
	// Bit mask of D_CD_MODE field.
	SPI_LCD_D_MODE_D_CD_MODE_Msk = 0x38
	// Position of D_DE_MODE field.
	SPI_LCD_D_MODE_D_DE_MODE_Pos = 0x6
	// Bit mask of D_DE_MODE field.
	SPI_LCD_D_MODE_D_DE_MODE_Msk = 0x1c0
	// Position of D_HSYNC_MODE field.
	SPI_LCD_D_MODE_D_HSYNC_MODE_Pos = 0x9
	// Bit mask of D_HSYNC_MODE field.
	SPI_LCD_D_MODE_D_HSYNC_MODE_Msk = 0xe00
	// Position of D_VSYNC_MODE field.
	SPI_LCD_D_MODE_D_VSYNC_MODE_Pos = 0xc
	// Bit mask of D_VSYNC_MODE field.
	SPI_LCD_D_MODE_D_VSYNC_MODE_Msk = 0x7000
	// Position of DE_IDLE_POL field.
	SPI_LCD_D_MODE_DE_IDLE_POL_Pos = 0xf
	// Bit mask of DE_IDLE_POL field.
	SPI_LCD_D_MODE_DE_IDLE_POL_Msk = 0x8000
	// Bit DE_IDLE_POL.
	SPI_LCD_D_MODE_DE_IDLE_POL = 0x8000
	// Position of HS_BLANK_EN field.
	SPI_LCD_D_MODE_HS_BLANK_EN_Pos = 0x10
	// Bit mask of HS_BLANK_EN field.
	SPI_LCD_D_MODE_HS_BLANK_EN_Msk = 0x10000
	// Bit HS_BLANK_EN.
	SPI_LCD_D_MODE_HS_BLANK_EN = 0x10000

	// LCD_D_NUM: LCD delay mode
	// Position of D_DQS_NUM field.
	SPI_LCD_D_NUM_D_DQS_NUM_Pos = 0x0
	// Bit mask of D_DQS_NUM field.
	SPI_LCD_D_NUM_D_DQS_NUM_Msk = 0x3
	// Position of D_CD_NUM field.
	SPI_LCD_D_NUM_D_CD_NUM_Pos = 0x2
	// Bit mask of D_CD_NUM field.
	SPI_LCD_D_NUM_D_CD_NUM_Msk = 0xc
	// Position of D_DE_NUM field.
	SPI_LCD_D_NUM_D_DE_NUM_Pos = 0x4
	// Bit mask of D_DE_NUM field.
	SPI_LCD_D_NUM_D_DE_NUM_Msk = 0x30
	// Position of D_HSYNC_NUM field.
	SPI_LCD_D_NUM_D_HSYNC_NUM_Pos = 0x6
	// Bit mask of D_HSYNC_NUM field.
	SPI_LCD_D_NUM_D_HSYNC_NUM_Msk = 0xc0
	// Position of D_VSYNC_NUM field.
	SPI_LCD_D_NUM_D_VSYNC_NUM_Pos = 0x8
	// Bit mask of D_VSYNC_NUM field.
	SPI_LCD_D_NUM_D_VSYNC_NUM_Msk = 0x300

	// REG_DATE: SPI version control
	// Position of DATE field.
	SPI_REG_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SPI_REG_DATE_DATE_Msk = 0xfffffff
)

// Constants for SYSCON: SYSCON Peripheral
const (
	// SYSCLK_CONF
	// Position of CLK_320M_EN field.
	SYSCON_SYSCLK_CONF_CLK_320M_EN_Pos = 0xa
	// Bit mask of CLK_320M_EN field.
	SYSCON_SYSCLK_CONF_CLK_320M_EN_Msk = 0x400
	// Bit CLK_320M_EN.
	SYSCON_SYSCLK_CONF_CLK_320M_EN = 0x400
	// Position of CLK_EN field.
	SYSCON_SYSCLK_CONF_CLK_EN_Pos = 0xb
	// Bit mask of CLK_EN field.
	SYSCON_SYSCLK_CONF_CLK_EN_Msk = 0x800
	// Bit CLK_EN.
	SYSCON_SYSCLK_CONF_CLK_EN = 0x800
	// Position of RST_TICK_CNT field.
	SYSCON_SYSCLK_CONF_RST_TICK_CNT_Pos = 0xc
	// Bit mask of RST_TICK_CNT field.
	SYSCON_SYSCLK_CONF_RST_TICK_CNT_Msk = 0x1000
	// Bit RST_TICK_CNT.
	SYSCON_SYSCLK_CONF_RST_TICK_CNT = 0x1000

	// TICK_CONF
	// Position of XTAL_TICK_NUM field.
	SYSCON_TICK_CONF_XTAL_TICK_NUM_Pos = 0x0
	// Bit mask of XTAL_TICK_NUM field.
	SYSCON_TICK_CONF_XTAL_TICK_NUM_Msk = 0xff
	// Position of CK8M_TICK_NUM field.
	SYSCON_TICK_CONF_CK8M_TICK_NUM_Pos = 0x8
	// Bit mask of CK8M_TICK_NUM field.
	SYSCON_TICK_CONF_CK8M_TICK_NUM_Msk = 0xff00
	// Position of TICK_ENABLE field.
	SYSCON_TICK_CONF_TICK_ENABLE_Pos = 0x10
	// Bit mask of TICK_ENABLE field.
	SYSCON_TICK_CONF_TICK_ENABLE_Msk = 0x10000
	// Bit TICK_ENABLE.
	SYSCON_TICK_CONF_TICK_ENABLE = 0x10000

	// CLK_OUT_EN
	// Position of CLK20_OEN field.
	SYSCON_CLK_OUT_EN_CLK20_OEN_Pos = 0x0
	// Bit mask of CLK20_OEN field.
	SYSCON_CLK_OUT_EN_CLK20_OEN_Msk = 0x1
	// Bit CLK20_OEN.
	SYSCON_CLK_OUT_EN_CLK20_OEN = 0x1
	// Position of CLK22_OEN field.
	SYSCON_CLK_OUT_EN_CLK22_OEN_Pos = 0x1
	// Bit mask of CLK22_OEN field.
	SYSCON_CLK_OUT_EN_CLK22_OEN_Msk = 0x2
	// Bit CLK22_OEN.
	SYSCON_CLK_OUT_EN_CLK22_OEN = 0x2
	// Position of CLK44_OEN field.
	SYSCON_CLK_OUT_EN_CLK44_OEN_Pos = 0x2
	// Bit mask of CLK44_OEN field.
	SYSCON_CLK_OUT_EN_CLK44_OEN_Msk = 0x4
	// Bit CLK44_OEN.
	SYSCON_CLK_OUT_EN_CLK44_OEN = 0x4
	// Position of CLK_BB_OEN field.
	SYSCON_CLK_OUT_EN_CLK_BB_OEN_Pos = 0x3
	// Bit mask of CLK_BB_OEN field.
	SYSCON_CLK_OUT_EN_CLK_BB_OEN_Msk = 0x8
	// Bit CLK_BB_OEN.
	SYSCON_CLK_OUT_EN_CLK_BB_OEN = 0x8
	// Position of CLK80_OEN field.
	SYSCON_CLK_OUT_EN_CLK80_OEN_Pos = 0x4
	// Bit mask of CLK80_OEN field.
	SYSCON_CLK_OUT_EN_CLK80_OEN_Msk = 0x10
	// Bit CLK80_OEN.
	SYSCON_CLK_OUT_EN_CLK80_OEN = 0x10
	// Position of CLK160_OEN field.
	SYSCON_CLK_OUT_EN_CLK160_OEN_Pos = 0x5
	// Bit mask of CLK160_OEN field.
	SYSCON_CLK_OUT_EN_CLK160_OEN_Msk = 0x20
	// Bit CLK160_OEN.
	SYSCON_CLK_OUT_EN_CLK160_OEN = 0x20
	// Position of CLK_320M_OEN field.
	SYSCON_CLK_OUT_EN_CLK_320M_OEN_Pos = 0x6
	// Bit mask of CLK_320M_OEN field.
	SYSCON_CLK_OUT_EN_CLK_320M_OEN_Msk = 0x40
	// Bit CLK_320M_OEN.
	SYSCON_CLK_OUT_EN_CLK_320M_OEN = 0x40
	// Position of CLK_ADC_INF_OEN field.
	SYSCON_CLK_OUT_EN_CLK_ADC_INF_OEN_Pos = 0x7
	// Bit mask of CLK_ADC_INF_OEN field.
	SYSCON_CLK_OUT_EN_CLK_ADC_INF_OEN_Msk = 0x80
	// Bit CLK_ADC_INF_OEN.
	SYSCON_CLK_OUT_EN_CLK_ADC_INF_OEN = 0x80
	// Position of CLK_DAC_CPU_OEN field.
	SYSCON_CLK_OUT_EN_CLK_DAC_CPU_OEN_Pos = 0x8
	// Bit mask of CLK_DAC_CPU_OEN field.
	SYSCON_CLK_OUT_EN_CLK_DAC_CPU_OEN_Msk = 0x100
	// Bit CLK_DAC_CPU_OEN.
	SYSCON_CLK_OUT_EN_CLK_DAC_CPU_OEN = 0x100
	// Position of CLK40X_BB_OEN field.
	SYSCON_CLK_OUT_EN_CLK40X_BB_OEN_Pos = 0x9
	// Bit mask of CLK40X_BB_OEN field.
	SYSCON_CLK_OUT_EN_CLK40X_BB_OEN_Msk = 0x200
	// Bit CLK40X_BB_OEN.
	SYSCON_CLK_OUT_EN_CLK40X_BB_OEN = 0x200
	// Position of CLK_XTAL_OEN field.
	SYSCON_CLK_OUT_EN_CLK_XTAL_OEN_Pos = 0xa
	// Bit mask of CLK_XTAL_OEN field.
	SYSCON_CLK_OUT_EN_CLK_XTAL_OEN_Msk = 0x400
	// Bit CLK_XTAL_OEN.
	SYSCON_CLK_OUT_EN_CLK_XTAL_OEN = 0x400

	// HOST_INF_SEL
	// Position of PERI_IO_SWAP field.
	SYSCON_HOST_INF_SEL_PERI_IO_SWAP_Pos = 0x0
	// Bit mask of PERI_IO_SWAP field.
	SYSCON_HOST_INF_SEL_PERI_IO_SWAP_Msk = 0xff

	// EXT_MEM_PMS_LOCK
	// Position of EXT_MEM_PMS_LOCK field.
	SYSCON_EXT_MEM_PMS_LOCK_EXT_MEM_PMS_LOCK_Pos = 0x0
	// Bit mask of EXT_MEM_PMS_LOCK field.
	SYSCON_EXT_MEM_PMS_LOCK_EXT_MEM_PMS_LOCK_Msk = 0x1
	// Bit EXT_MEM_PMS_LOCK.
	SYSCON_EXT_MEM_PMS_LOCK_EXT_MEM_PMS_LOCK = 0x1

	// FLASH_ACE0_ATTR
	// Position of FLASH_ACE0_ATTR field.
	SYSCON_FLASH_ACE0_ATTR_FLASH_ACE0_ATTR_Pos = 0x0
	// Bit mask of FLASH_ACE0_ATTR field.
	SYSCON_FLASH_ACE0_ATTR_FLASH_ACE0_ATTR_Msk = 0x7

	// FLASH_ACE1_ATTR
	// Position of FLASH_ACE1_ATTR field.
	SYSCON_FLASH_ACE1_ATTR_FLASH_ACE1_ATTR_Pos = 0x0
	// Bit mask of FLASH_ACE1_ATTR field.
	SYSCON_FLASH_ACE1_ATTR_FLASH_ACE1_ATTR_Msk = 0x7

	// FLASH_ACE2_ATTR
	// Position of FLASH_ACE2_ATTR field.
	SYSCON_FLASH_ACE2_ATTR_FLASH_ACE2_ATTR_Pos = 0x0
	// Bit mask of FLASH_ACE2_ATTR field.
	SYSCON_FLASH_ACE2_ATTR_FLASH_ACE2_ATTR_Msk = 0x7

	// FLASH_ACE3_ATTR
	// Position of FLASH_ACE3_ATTR field.
	SYSCON_FLASH_ACE3_ATTR_FLASH_ACE3_ATTR_Pos = 0x0
	// Bit mask of FLASH_ACE3_ATTR field.
	SYSCON_FLASH_ACE3_ATTR_FLASH_ACE3_ATTR_Msk = 0x7

	// FLASH_ACE0_ADDR
	// Position of S field.
	SYSCON_FLASH_ACE0_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_FLASH_ACE0_ADDR_S_Msk = 0xffffffff

	// FLASH_ACE1_ADDR
	// Position of S field.
	SYSCON_FLASH_ACE1_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_FLASH_ACE1_ADDR_S_Msk = 0xffffffff

	// FLASH_ACE2_ADDR
	// Position of S field.
	SYSCON_FLASH_ACE2_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_FLASH_ACE2_ADDR_S_Msk = 0xffffffff

	// FLASH_ACE3_ADDR
	// Position of S field.
	SYSCON_FLASH_ACE3_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_FLASH_ACE3_ADDR_S_Msk = 0xffffffff

	// FLASH_ACE0_SIZE
	// Position of FLASH_ACE0_SIZE field.
	SYSCON_FLASH_ACE0_SIZE_FLASH_ACE0_SIZE_Pos = 0x0
	// Bit mask of FLASH_ACE0_SIZE field.
	SYSCON_FLASH_ACE0_SIZE_FLASH_ACE0_SIZE_Msk = 0xffff

	// FLASH_ACE1_SIZE
	// Position of FLASH_ACE1_SIZE field.
	SYSCON_FLASH_ACE1_SIZE_FLASH_ACE1_SIZE_Pos = 0x0
	// Bit mask of FLASH_ACE1_SIZE field.
	SYSCON_FLASH_ACE1_SIZE_FLASH_ACE1_SIZE_Msk = 0xffff

	// FLASH_ACE2_SIZE
	// Position of FLASH_ACE2_SIZE field.
	SYSCON_FLASH_ACE2_SIZE_FLASH_ACE2_SIZE_Pos = 0x0
	// Bit mask of FLASH_ACE2_SIZE field.
	SYSCON_FLASH_ACE2_SIZE_FLASH_ACE2_SIZE_Msk = 0xffff

	// FLASH_ACE3_SIZE
	// Position of FLASH_ACE3_SIZE field.
	SYSCON_FLASH_ACE3_SIZE_FLASH_ACE3_SIZE_Pos = 0x0
	// Bit mask of FLASH_ACE3_SIZE field.
	SYSCON_FLASH_ACE3_SIZE_FLASH_ACE3_SIZE_Msk = 0xffff

	// SRAM_ACE0_ATTR
	// Position of SRAM_ACE0_ATTR field.
	SYSCON_SRAM_ACE0_ATTR_SRAM_ACE0_ATTR_Pos = 0x0
	// Bit mask of SRAM_ACE0_ATTR field.
	SYSCON_SRAM_ACE0_ATTR_SRAM_ACE0_ATTR_Msk = 0x7

	// SRAM_ACE1_ATTR
	// Position of SRAM_ACE1_ATTR field.
	SYSCON_SRAM_ACE1_ATTR_SRAM_ACE1_ATTR_Pos = 0x0
	// Bit mask of SRAM_ACE1_ATTR field.
	SYSCON_SRAM_ACE1_ATTR_SRAM_ACE1_ATTR_Msk = 0x7

	// SRAM_ACE2_ATTR
	// Position of SRAM_ACE2_ATTR field.
	SYSCON_SRAM_ACE2_ATTR_SRAM_ACE2_ATTR_Pos = 0x0
	// Bit mask of SRAM_ACE2_ATTR field.
	SYSCON_SRAM_ACE2_ATTR_SRAM_ACE2_ATTR_Msk = 0x7

	// SRAM_ACE3_ATTR
	// Position of SRAM_ACE3_ATTR field.
	SYSCON_SRAM_ACE3_ATTR_SRAM_ACE3_ATTR_Pos = 0x0
	// Bit mask of SRAM_ACE3_ATTR field.
	SYSCON_SRAM_ACE3_ATTR_SRAM_ACE3_ATTR_Msk = 0x7

	// SRAM_ACE0_ADDR
	// Position of S field.
	SYSCON_SRAM_ACE0_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_SRAM_ACE0_ADDR_S_Msk = 0xffffffff

	// SRAM_ACE1_ADDR
	// Position of S field.
	SYSCON_SRAM_ACE1_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_SRAM_ACE1_ADDR_S_Msk = 0xffffffff

	// SRAM_ACE2_ADDR
	// Position of S field.
	SYSCON_SRAM_ACE2_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_SRAM_ACE2_ADDR_S_Msk = 0xffffffff

	// SRAM_ACE3_ADDR
	// Position of S field.
	SYSCON_SRAM_ACE3_ADDR_S_Pos = 0x0
	// Bit mask of S field.
	SYSCON_SRAM_ACE3_ADDR_S_Msk = 0xffffffff

	// SRAM_ACE0_SIZE
	// Position of SRAM_ACE0_SIZE field.
	SYSCON_SRAM_ACE0_SIZE_SRAM_ACE0_SIZE_Pos = 0x0
	// Bit mask of SRAM_ACE0_SIZE field.
	SYSCON_SRAM_ACE0_SIZE_SRAM_ACE0_SIZE_Msk = 0xffff

	// SRAM_ACE1_SIZE
	// Position of SRAM_ACE1_SIZE field.
	SYSCON_SRAM_ACE1_SIZE_SRAM_ACE1_SIZE_Pos = 0x0
	// Bit mask of SRAM_ACE1_SIZE field.
	SYSCON_SRAM_ACE1_SIZE_SRAM_ACE1_SIZE_Msk = 0xffff

	// SRAM_ACE2_SIZE
	// Position of SRAM_ACE2_SIZE field.
	SYSCON_SRAM_ACE2_SIZE_SRAM_ACE2_SIZE_Pos = 0x0
	// Bit mask of SRAM_ACE2_SIZE field.
	SYSCON_SRAM_ACE2_SIZE_SRAM_ACE2_SIZE_Msk = 0xffff

	// SRAM_ACE3_SIZE
	// Position of SRAM_ACE3_SIZE field.
	SYSCON_SRAM_ACE3_SIZE_SRAM_ACE3_SIZE_Pos = 0x0
	// Bit mask of SRAM_ACE3_SIZE field.
	SYSCON_SRAM_ACE3_SIZE_SRAM_ACE3_SIZE_Msk = 0xffff

	// SPI_MEM_PMS_CTRL
	// Position of SPI_MEM_REJECT_INT field.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_INT_Pos = 0x0
	// Bit mask of SPI_MEM_REJECT_INT field.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_INT_Msk = 0x1
	// Bit SPI_MEM_REJECT_INT.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_INT = 0x1
	// Position of SPI_MEM_REJECT_CLR field.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CLR_Pos = 0x1
	// Bit mask of SPI_MEM_REJECT_CLR field.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CLR_Msk = 0x2
	// Bit SPI_MEM_REJECT_CLR.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CLR = 0x2
	// Position of SPI_MEM_REJECT_CDE field.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CDE_Pos = 0x2
	// Bit mask of SPI_MEM_REJECT_CDE field.
	SYSCON_SPI_MEM_PMS_CTRL_SPI_MEM_REJECT_CDE_Msk = 0x7c

	// SPI_MEM_REJECT_ADDR
	// Position of SPI_MEM_REJECT_ADDR field.
	SYSCON_SPI_MEM_REJECT_ADDR_SPI_MEM_REJECT_ADDR_Pos = 0x0
	// Bit mask of SPI_MEM_REJECT_ADDR field.
	SYSCON_SPI_MEM_REJECT_ADDR_SPI_MEM_REJECT_ADDR_Msk = 0xffffffff

	// SDIO_CTRL
	// Position of SDIO_WIN_ACCESS_EN field.
	SYSCON_SDIO_CTRL_SDIO_WIN_ACCESS_EN_Pos = 0x0
	// Bit mask of SDIO_WIN_ACCESS_EN field.
	SYSCON_SDIO_CTRL_SDIO_WIN_ACCESS_EN_Msk = 0x1
	// Bit SDIO_WIN_ACCESS_EN.
	SYSCON_SDIO_CTRL_SDIO_WIN_ACCESS_EN = 0x1

	// REDCY_SIG0
	// Position of REDCY_SIG0 field.
	SYSCON_REDCY_SIG0_REDCY_SIG0_Pos = 0x0
	// Bit mask of REDCY_SIG0 field.
	SYSCON_REDCY_SIG0_REDCY_SIG0_Msk = 0x7fffffff
	// Position of REDCY_ANDOR field.
	SYSCON_REDCY_SIG0_REDCY_ANDOR_Pos = 0x1f
	// Bit mask of REDCY_ANDOR field.
	SYSCON_REDCY_SIG0_REDCY_ANDOR_Msk = 0x80000000
	// Bit REDCY_ANDOR.
	SYSCON_REDCY_SIG0_REDCY_ANDOR = 0x80000000

	// REDCY_SIG1
	// Position of REDCY_SIG1 field.
	SYSCON_REDCY_SIG1_REDCY_SIG1_Pos = 0x0
	// Bit mask of REDCY_SIG1 field.
	SYSCON_REDCY_SIG1_REDCY_SIG1_Msk = 0x7fffffff
	// Position of REDCY_NANDOR field.
	SYSCON_REDCY_SIG1_REDCY_NANDOR_Pos = 0x1f
	// Bit mask of REDCY_NANDOR field.
	SYSCON_REDCY_SIG1_REDCY_NANDOR_Msk = 0x80000000
	// Bit REDCY_NANDOR.
	SYSCON_REDCY_SIG1_REDCY_NANDOR = 0x80000000

	// WIFI_BB_CFG
	// Position of WIFI_BB_CFG field.
	SYSCON_WIFI_BB_CFG_WIFI_BB_CFG_Pos = 0x0
	// Bit mask of WIFI_BB_CFG field.
	SYSCON_WIFI_BB_CFG_WIFI_BB_CFG_Msk = 0xffffffff

	// WIFI_BB_CFG_2
	// Position of WIFI_BB_CFG_2 field.
	SYSCON_WIFI_BB_CFG_2_WIFI_BB_CFG_2_Pos = 0x0
	// Bit mask of WIFI_BB_CFG_2 field.
	SYSCON_WIFI_BB_CFG_2_WIFI_BB_CFG_2_Msk = 0xffffffff

	// WIFI_CLK_EN
	// Position of WIFI_CLK_EN field.
	SYSCON_WIFI_CLK_EN_WIFI_CLK_EN_Pos = 0x0
	// Bit mask of WIFI_CLK_EN field.
	SYSCON_WIFI_CLK_EN_WIFI_CLK_EN_Msk = 0xffffffff

	// WIFI_RST_EN
	// Position of WIFI_RST field.
	SYSCON_WIFI_RST_EN_WIFI_RST_Pos = 0x0
	// Bit mask of WIFI_RST field.
	SYSCON_WIFI_RST_EN_WIFI_RST_Msk = 0xffffffff

	// FRONT_END_MEM_PD
	// Position of AGC_MEM_FORCE_PU field.
	SYSCON_FRONT_END_MEM_PD_AGC_MEM_FORCE_PU_Pos = 0x0
	// Bit mask of AGC_MEM_FORCE_PU field.
	SYSCON_FRONT_END_MEM_PD_AGC_MEM_FORCE_PU_Msk = 0x1
	// Bit AGC_MEM_FORCE_PU.
	SYSCON_FRONT_END_MEM_PD_AGC_MEM_FORCE_PU = 0x1
	// Position of AGC_MEM_FORCE_PD field.
	SYSCON_FRONT_END_MEM_PD_AGC_MEM_FORCE_PD_Pos = 0x1
	// Bit mask of AGC_MEM_FORCE_PD field.
	SYSCON_FRONT_END_MEM_PD_AGC_MEM_FORCE_PD_Msk = 0x2
	// Bit AGC_MEM_FORCE_PD.
	SYSCON_FRONT_END_MEM_PD_AGC_MEM_FORCE_PD = 0x2
	// Position of PBUS_MEM_FORCE_PU field.
	SYSCON_FRONT_END_MEM_PD_PBUS_MEM_FORCE_PU_Pos = 0x2
	// Bit mask of PBUS_MEM_FORCE_PU field.
	SYSCON_FRONT_END_MEM_PD_PBUS_MEM_FORCE_PU_Msk = 0x4
	// Bit PBUS_MEM_FORCE_PU.
	SYSCON_FRONT_END_MEM_PD_PBUS_MEM_FORCE_PU = 0x4
	// Position of PBUS_MEM_FORCE_PD field.
	SYSCON_FRONT_END_MEM_PD_PBUS_MEM_FORCE_PD_Pos = 0x3
	// Bit mask of PBUS_MEM_FORCE_PD field.
	SYSCON_FRONT_END_MEM_PD_PBUS_MEM_FORCE_PD_Msk = 0x8
	// Bit PBUS_MEM_FORCE_PD.
	SYSCON_FRONT_END_MEM_PD_PBUS_MEM_FORCE_PD = 0x8
	// Position of DC_MEM_FORCE_PU field.
	SYSCON_FRONT_END_MEM_PD_DC_MEM_FORCE_PU_Pos = 0x4
	// Bit mask of DC_MEM_FORCE_PU field.
	SYSCON_FRONT_END_MEM_PD_DC_MEM_FORCE_PU_Msk = 0x10
	// Bit DC_MEM_FORCE_PU.
	SYSCON_FRONT_END_MEM_PD_DC_MEM_FORCE_PU = 0x10
	// Position of DC_MEM_FORCE_PD field.
	SYSCON_FRONT_END_MEM_PD_DC_MEM_FORCE_PD_Pos = 0x5
	// Bit mask of DC_MEM_FORCE_PD field.
	SYSCON_FRONT_END_MEM_PD_DC_MEM_FORCE_PD_Msk = 0x20
	// Bit DC_MEM_FORCE_PD.
	SYSCON_FRONT_END_MEM_PD_DC_MEM_FORCE_PD = 0x20

	// DATE
	// Position of DATE field.
	SYSCON_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SYSCON_DATE_DATE_Msk = 0xffffffff
)

// Constants for SYSTEM: System Configuration Registers
const (
	// ROM_CTRL_0: System ROM configuration register 0
	// Position of ROM_FO field.
	SYSTEM_ROM_CTRL_0_ROM_FO_Pos = 0x0
	// Bit mask of ROM_FO field.
	SYSTEM_ROM_CTRL_0_ROM_FO_Msk = 0x3

	// ROM_CTRL_1: System ROM configuration register 1
	// Position of ROM_FORCE_PD field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PD_Pos = 0x0
	// Bit mask of ROM_FORCE_PD field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PD_Msk = 0x3
	// Position of ROM_FORCE_PU field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PU_Pos = 0x2
	// Bit mask of ROM_FORCE_PU field.
	SYSTEM_ROM_CTRL_1_ROM_FORCE_PU_Msk = 0xc

	// SRAM_CTRL_0: System SRAM configuration register 0
	// Position of SRAM_FO field.
	SYSTEM_SRAM_CTRL_0_SRAM_FO_Pos = 0x0
	// Bit mask of SRAM_FO field.
	SYSTEM_SRAM_CTRL_0_SRAM_FO_Msk = 0x3fffff

	// SRAM_CTRL_1: System SRAM configuration register 1
	// Position of SRAM_FORCE_PD field.
	SYSTEM_SRAM_CTRL_1_SRAM_FORCE_PD_Pos = 0x0
	// Bit mask of SRAM_FORCE_PD field.
	SYSTEM_SRAM_CTRL_1_SRAM_FORCE_PD_Msk = 0x3fffff

	// CPU_PERI_CLK_EN: CPU peripheral clock enable register
	// Position of CLK_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO_Pos = 0x7
	// Bit mask of CLK_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO_Msk = 0x80
	// Bit CLK_EN_DEDICATED_GPIO.
	SYSTEM_CPU_PERI_CLK_EN_CLK_EN_DEDICATED_GPIO = 0x80

	// CPU_PERI_RST_EN: CPU peripheral reset register
	// Position of RST_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO_Pos = 0x7
	// Bit mask of RST_EN_DEDICATED_GPIO field.
	SYSTEM_CPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO_Msk = 0x80
	// Bit RST_EN_DEDICATED_GPIO.
	SYSTEM_CPU_PERI_RST_EN_RST_EN_DEDICATED_GPIO = 0x80

	// CPU_PER_CONF: CPU peripheral clock configuration register
	// Position of CPUPERIOD_SEL field.
	SYSTEM_CPU_PER_CONF_CPUPERIOD_SEL_Pos = 0x0
	// Bit mask of CPUPERIOD_SEL field.
	SYSTEM_CPU_PER_CONF_CPUPERIOD_SEL_Msk = 0x3
	// Position of PLL_FREQ_SEL field.
	SYSTEM_CPU_PER_CONF_PLL_FREQ_SEL_Pos = 0x2
	// Bit mask of PLL_FREQ_SEL field.
	SYSTEM_CPU_PER_CONF_PLL_FREQ_SEL_Msk = 0x4
	// Bit PLL_FREQ_SEL.
	SYSTEM_CPU_PER_CONF_PLL_FREQ_SEL = 0x4
	// Position of CPU_WAIT_MODE_FORCE_ON field.
	SYSTEM_CPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON_Pos = 0x3
	// Bit mask of CPU_WAIT_MODE_FORCE_ON field.
	SYSTEM_CPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON_Msk = 0x8
	// Bit CPU_WAIT_MODE_FORCE_ON.
	SYSTEM_CPU_PER_CONF_CPU_WAIT_MODE_FORCE_ON = 0x8
	// Position of CPU_WAITI_DELAY_NUM field.
	SYSTEM_CPU_PER_CONF_CPU_WAITI_DELAY_NUM_Pos = 0x4
	// Bit mask of CPU_WAITI_DELAY_NUM field.
	SYSTEM_CPU_PER_CONF_CPU_WAITI_DELAY_NUM_Msk = 0xf0

	// JTAG_CTRL_0: JTAG configuration register 0
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 field.
	SYSTEM_JTAG_CTRL_0_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 field.
	SYSTEM_JTAG_CTRL_0_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0_Msk = 0xffffffff

	// JTAG_CTRL_1: JTAG configuration register 1
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1 field.
	SYSTEM_JTAG_CTRL_1_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1 field.
	SYSTEM_JTAG_CTRL_1_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_1_Msk = 0xffffffff

	// JTAG_CTRL_2: JTAG configuration register 2
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2 field.
	SYSTEM_JTAG_CTRL_2_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2 field.
	SYSTEM_JTAG_CTRL_2_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_2_Msk = 0xffffffff

	// JTAG_CTRL_3: JTAG configuration register 3
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3 field.
	SYSTEM_JTAG_CTRL_3_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3 field.
	SYSTEM_JTAG_CTRL_3_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_3_Msk = 0xffffffff

	// JTAG_CTRL_4: JTAG configuration register 4
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4 field.
	SYSTEM_JTAG_CTRL_4_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4 field.
	SYSTEM_JTAG_CTRL_4_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_4_Msk = 0xffffffff

	// JTAG_CTRL_5: JTAG configuration register 5
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5 field.
	SYSTEM_JTAG_CTRL_5_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5 field.
	SYSTEM_JTAG_CTRL_5_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_5_Msk = 0xffffffff

	// JTAG_CTRL_6: JTAG configuration register 6
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6 field.
	SYSTEM_JTAG_CTRL_6_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6 field.
	SYSTEM_JTAG_CTRL_6_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_6_Msk = 0xffffffff

	// JTAG_CTRL_7: JTAG configuration register 7
	// Position of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7 field.
	SYSTEM_JTAG_CTRL_7_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7_Pos = 0x0
	// Bit mask of CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7 field.
	SYSTEM_JTAG_CTRL_7_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7_Msk = 0xffffffff

	// MEM_PD_MASK: Memory power-related controlling register (under low-sleep)
	// Position of LSLP_MEM_PD_MASK field.
	SYSTEM_MEM_PD_MASK_LSLP_MEM_PD_MASK_Pos = 0x0
	// Bit mask of LSLP_MEM_PD_MASK field.
	SYSTEM_MEM_PD_MASK_LSLP_MEM_PD_MASK_Msk = 0x1
	// Bit LSLP_MEM_PD_MASK.
	SYSTEM_MEM_PD_MASK_LSLP_MEM_PD_MASK = 0x1

	// PERIP_CLK_EN0: System peripheral clock (for hardware accelerators) enable register
	// Position of TIMERS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERS_CLK_EN_Pos = 0x0
	// Bit mask of TIMERS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERS_CLK_EN_Msk = 0x1
	// Bit TIMERS_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TIMERS_CLK_EN = 0x1
	// Position of SPI01_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI01_CLK_EN_Pos = 0x1
	// Bit mask of SPI01_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI01_CLK_EN_Msk = 0x2
	// Bit SPI01_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI01_CLK_EN = 0x2
	// Position of UART_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_CLK_EN_Pos = 0x2
	// Bit mask of UART_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_CLK_EN_Msk = 0x4
	// Bit UART_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UART_CLK_EN = 0x4
	// Position of WDG_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_WDG_CLK_EN_Pos = 0x3
	// Bit mask of WDG_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_WDG_CLK_EN_Msk = 0x8
	// Bit WDG_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_WDG_CLK_EN = 0x8
	// Position of I2S0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S0_CLK_EN_Pos = 0x4
	// Bit mask of I2S0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S0_CLK_EN_Msk = 0x10
	// Bit I2S0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2S0_CLK_EN = 0x10
	// Position of UART1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART1_CLK_EN_Pos = 0x5
	// Bit mask of UART1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART1_CLK_EN_Msk = 0x20
	// Bit UART1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UART1_CLK_EN = 0x20
	// Position of SPI2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_CLK_EN_Pos = 0x6
	// Bit mask of SPI2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_CLK_EN_Msk = 0x40
	// Bit SPI2_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI2_CLK_EN = 0x40
	// Position of I2C_EXT0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT0_CLK_EN_Pos = 0x7
	// Bit mask of I2C_EXT0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT0_CLK_EN_Msk = 0x80
	// Bit I2C_EXT0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT0_CLK_EN = 0x80
	// Position of UHCI0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI0_CLK_EN_Pos = 0x8
	// Bit mask of UHCI0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI0_CLK_EN_Msk = 0x100
	// Bit UHCI0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UHCI0_CLK_EN = 0x100
	// Position of RMT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_RMT_CLK_EN_Pos = 0x9
	// Bit mask of RMT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_RMT_CLK_EN_Msk = 0x200
	// Bit RMT_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_RMT_CLK_EN = 0x200
	// Position of PCNT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PCNT_CLK_EN_Pos = 0xa
	// Bit mask of PCNT_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PCNT_CLK_EN_Msk = 0x400
	// Bit PCNT_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PCNT_CLK_EN = 0x400
	// Position of LEDC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_LEDC_CLK_EN_Pos = 0xb
	// Bit mask of LEDC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_LEDC_CLK_EN_Msk = 0x800
	// Bit LEDC_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_LEDC_CLK_EN = 0x800
	// Position of UHCI1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI1_CLK_EN_Pos = 0xc
	// Bit mask of UHCI1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UHCI1_CLK_EN_Msk = 0x1000
	// Bit UHCI1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UHCI1_CLK_EN = 0x1000
	// Position of TIMERGROUP_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP_CLK_EN_Pos = 0xd
	// Bit mask of TIMERGROUP_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP_CLK_EN_Msk = 0x2000
	// Bit TIMERGROUP_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP_CLK_EN = 0x2000
	// Position of EFUSE_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_EFUSE_CLK_EN_Pos = 0xe
	// Bit mask of EFUSE_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_EFUSE_CLK_EN_Msk = 0x4000
	// Bit EFUSE_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_EFUSE_CLK_EN = 0x4000
	// Position of TIMERGROUP1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP1_CLK_EN_Pos = 0xf
	// Bit mask of TIMERGROUP1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP1_CLK_EN_Msk = 0x8000
	// Bit TIMERGROUP1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TIMERGROUP1_CLK_EN = 0x8000
	// Position of SPI3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_CLK_EN_Pos = 0x10
	// Bit mask of SPI3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_CLK_EN_Msk = 0x10000
	// Bit SPI3_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI3_CLK_EN = 0x10000
	// Position of PWM0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM0_CLK_EN_Pos = 0x11
	// Bit mask of PWM0_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM0_CLK_EN_Msk = 0x20000
	// Bit PWM0_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM0_CLK_EN = 0x20000
	// Position of I2C_EXT1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT1_CLK_EN_Pos = 0x12
	// Bit mask of I2C_EXT1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT1_CLK_EN_Msk = 0x40000
	// Bit I2C_EXT1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2C_EXT1_CLK_EN = 0x40000
	// Position of TWAI_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TWAI_CLK_EN_Pos = 0x13
	// Bit mask of TWAI_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_TWAI_CLK_EN_Msk = 0x80000
	// Bit TWAI_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_TWAI_CLK_EN = 0x80000
	// Position of PWM1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM1_CLK_EN_Pos = 0x14
	// Bit mask of PWM1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM1_CLK_EN_Msk = 0x100000
	// Bit PWM1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM1_CLK_EN = 0x100000
	// Position of I2S1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S1_CLK_EN_Pos = 0x15
	// Bit mask of I2S1_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_I2S1_CLK_EN_Msk = 0x200000
	// Bit I2S1_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_I2S1_CLK_EN = 0x200000
	// Position of SPI2_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_DMA_CLK_EN_Pos = 0x16
	// Bit mask of SPI2_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI2_DMA_CLK_EN_Msk = 0x400000
	// Bit SPI2_DMA_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI2_DMA_CLK_EN = 0x400000
	// Position of USB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_USB_CLK_EN_Pos = 0x17
	// Bit mask of USB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_USB_CLK_EN_Msk = 0x800000
	// Bit USB_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_USB_CLK_EN = 0x800000
	// Position of UART_MEM_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_MEM_CLK_EN_Pos = 0x18
	// Bit mask of UART_MEM_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_UART_MEM_CLK_EN_Msk = 0x1000000
	// Bit UART_MEM_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_UART_MEM_CLK_EN = 0x1000000
	// Position of PWM2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM2_CLK_EN_Pos = 0x19
	// Bit mask of PWM2_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM2_CLK_EN_Msk = 0x2000000
	// Bit PWM2_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM2_CLK_EN = 0x2000000
	// Position of PWM3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM3_CLK_EN_Pos = 0x1a
	// Bit mask of PWM3_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_PWM3_CLK_EN_Msk = 0x4000000
	// Bit PWM3_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_PWM3_CLK_EN = 0x4000000
	// Position of SPI3_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_DMA_CLK_EN_Pos = 0x1b
	// Bit mask of SPI3_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI3_DMA_CLK_EN_Msk = 0x8000000
	// Bit SPI3_DMA_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI3_DMA_CLK_EN = 0x8000000
	// Position of APB_SARADC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_APB_SARADC_CLK_EN_Pos = 0x1c
	// Bit mask of APB_SARADC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_APB_SARADC_CLK_EN_Msk = 0x10000000
	// Bit APB_SARADC_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_APB_SARADC_CLK_EN = 0x10000000
	// Position of SYSTIMER_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SYSTIMER_CLK_EN_Pos = 0x1d
	// Bit mask of SYSTIMER_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SYSTIMER_CLK_EN_Msk = 0x20000000
	// Bit SYSTIMER_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SYSTIMER_CLK_EN = 0x20000000
	// Position of ADC2_ARB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_ADC2_ARB_CLK_EN_Pos = 0x1e
	// Bit mask of ADC2_ARB_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_ADC2_ARB_CLK_EN_Msk = 0x40000000
	// Bit ADC2_ARB_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_ADC2_ARB_CLK_EN = 0x40000000
	// Position of SPI4_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI4_CLK_EN_Pos = 0x1f
	// Bit mask of SPI4_CLK_EN field.
	SYSTEM_PERIP_CLK_EN0_SPI4_CLK_EN_Msk = 0x80000000
	// Bit SPI4_CLK_EN.
	SYSTEM_PERIP_CLK_EN0_SPI4_CLK_EN = 0x80000000

	// PERIP_CLK_EN1: System peripheral clock (for hardware accelerators) enable register 1
	// Position of CRYPTO_AES_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_AES_CLK_EN_Pos = 0x1
	// Bit mask of CRYPTO_AES_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_AES_CLK_EN_Msk = 0x2
	// Bit CRYPTO_AES_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_AES_CLK_EN = 0x2
	// Position of CRYPTO_SHA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_SHA_CLK_EN_Pos = 0x2
	// Bit mask of CRYPTO_SHA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_SHA_CLK_EN_Msk = 0x4
	// Bit CRYPTO_SHA_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_SHA_CLK_EN = 0x4
	// Position of CRYPTO_RSA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_RSA_CLK_EN_Pos = 0x3
	// Bit mask of CRYPTO_RSA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_RSA_CLK_EN_Msk = 0x8
	// Bit CRYPTO_RSA_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_RSA_CLK_EN = 0x8
	// Position of CRYPTO_DS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DS_CLK_EN_Pos = 0x4
	// Bit mask of CRYPTO_DS_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DS_CLK_EN_Msk = 0x10
	// Bit CRYPTO_DS_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DS_CLK_EN = 0x10
	// Position of CRYPTO_HMAC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN_Pos = 0x5
	// Bit mask of CRYPTO_HMAC_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN_Msk = 0x20
	// Bit CRYPTO_HMAC_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_HMAC_CLK_EN = 0x20
	// Position of CRYPTO_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DMA_CLK_EN_Pos = 0x6
	// Bit mask of CRYPTO_DMA_CLK_EN field.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DMA_CLK_EN_Msk = 0x40
	// Bit CRYPTO_DMA_CLK_EN.
	SYSTEM_PERIP_CLK_EN1_CRYPTO_DMA_CLK_EN = 0x40

	// PERIP_RST_EN0: System peripheral (hardware accelerators) reset register 0
	// Position of TIMERS_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERS_RST_Pos = 0x0
	// Bit mask of TIMERS_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERS_RST_Msk = 0x1
	// Bit TIMERS_RST.
	SYSTEM_PERIP_RST_EN0_TIMERS_RST = 0x1
	// Position of SPI01_RST field.
	SYSTEM_PERIP_RST_EN0_SPI01_RST_Pos = 0x1
	// Bit mask of SPI01_RST field.
	SYSTEM_PERIP_RST_EN0_SPI01_RST_Msk = 0x2
	// Bit SPI01_RST.
	SYSTEM_PERIP_RST_EN0_SPI01_RST = 0x2
	// Position of UART_RST field.
	SYSTEM_PERIP_RST_EN0_UART_RST_Pos = 0x2
	// Bit mask of UART_RST field.
	SYSTEM_PERIP_RST_EN0_UART_RST_Msk = 0x4
	// Bit UART_RST.
	SYSTEM_PERIP_RST_EN0_UART_RST = 0x4
	// Position of WDG_RST field.
	SYSTEM_PERIP_RST_EN0_WDG_RST_Pos = 0x3
	// Bit mask of WDG_RST field.
	SYSTEM_PERIP_RST_EN0_WDG_RST_Msk = 0x8
	// Bit WDG_RST.
	SYSTEM_PERIP_RST_EN0_WDG_RST = 0x8
	// Position of I2S0_RST field.
	SYSTEM_PERIP_RST_EN0_I2S0_RST_Pos = 0x4
	// Bit mask of I2S0_RST field.
	SYSTEM_PERIP_RST_EN0_I2S0_RST_Msk = 0x10
	// Bit I2S0_RST.
	SYSTEM_PERIP_RST_EN0_I2S0_RST = 0x10
	// Position of UART1_RST field.
	SYSTEM_PERIP_RST_EN0_UART1_RST_Pos = 0x5
	// Bit mask of UART1_RST field.
	SYSTEM_PERIP_RST_EN0_UART1_RST_Msk = 0x20
	// Bit UART1_RST.
	SYSTEM_PERIP_RST_EN0_UART1_RST = 0x20
	// Position of SPI2_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_RST_Pos = 0x6
	// Bit mask of SPI2_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_RST_Msk = 0x40
	// Bit SPI2_RST.
	SYSTEM_PERIP_RST_EN0_SPI2_RST = 0x40
	// Position of I2C_EXT0_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT0_RST_Pos = 0x7
	// Bit mask of I2C_EXT0_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT0_RST_Msk = 0x80
	// Bit I2C_EXT0_RST.
	SYSTEM_PERIP_RST_EN0_I2C_EXT0_RST = 0x80
	// Position of UHCI0_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI0_RST_Pos = 0x8
	// Bit mask of UHCI0_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI0_RST_Msk = 0x100
	// Bit UHCI0_RST.
	SYSTEM_PERIP_RST_EN0_UHCI0_RST = 0x100
	// Position of RMT_RST field.
	SYSTEM_PERIP_RST_EN0_RMT_RST_Pos = 0x9
	// Bit mask of RMT_RST field.
	SYSTEM_PERIP_RST_EN0_RMT_RST_Msk = 0x200
	// Bit RMT_RST.
	SYSTEM_PERIP_RST_EN0_RMT_RST = 0x200
	// Position of PCNT_RST field.
	SYSTEM_PERIP_RST_EN0_PCNT_RST_Pos = 0xa
	// Bit mask of PCNT_RST field.
	SYSTEM_PERIP_RST_EN0_PCNT_RST_Msk = 0x400
	// Bit PCNT_RST.
	SYSTEM_PERIP_RST_EN0_PCNT_RST = 0x400
	// Position of LEDC_RST field.
	SYSTEM_PERIP_RST_EN0_LEDC_RST_Pos = 0xb
	// Bit mask of LEDC_RST field.
	SYSTEM_PERIP_RST_EN0_LEDC_RST_Msk = 0x800
	// Bit LEDC_RST.
	SYSTEM_PERIP_RST_EN0_LEDC_RST = 0x800
	// Position of UHCI1_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI1_RST_Pos = 0xc
	// Bit mask of UHCI1_RST field.
	SYSTEM_PERIP_RST_EN0_UHCI1_RST_Msk = 0x1000
	// Bit UHCI1_RST.
	SYSTEM_PERIP_RST_EN0_UHCI1_RST = 0x1000
	// Position of TIMERGROUP_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP_RST_Pos = 0xd
	// Bit mask of TIMERGROUP_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP_RST_Msk = 0x2000
	// Bit TIMERGROUP_RST.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP_RST = 0x2000
	// Position of EFUSE_RST field.
	SYSTEM_PERIP_RST_EN0_EFUSE_RST_Pos = 0xe
	// Bit mask of EFUSE_RST field.
	SYSTEM_PERIP_RST_EN0_EFUSE_RST_Msk = 0x4000
	// Bit EFUSE_RST.
	SYSTEM_PERIP_RST_EN0_EFUSE_RST = 0x4000
	// Position of TIMERGROUP1_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP1_RST_Pos = 0xf
	// Bit mask of TIMERGROUP1_RST field.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP1_RST_Msk = 0x8000
	// Bit TIMERGROUP1_RST.
	SYSTEM_PERIP_RST_EN0_TIMERGROUP1_RST = 0x8000
	// Position of SPI3_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_RST_Pos = 0x10
	// Bit mask of SPI3_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_RST_Msk = 0x10000
	// Bit SPI3_RST.
	SYSTEM_PERIP_RST_EN0_SPI3_RST = 0x10000
	// Position of PWM0_RST field.
	SYSTEM_PERIP_RST_EN0_PWM0_RST_Pos = 0x11
	// Bit mask of PWM0_RST field.
	SYSTEM_PERIP_RST_EN0_PWM0_RST_Msk = 0x20000
	// Bit PWM0_RST.
	SYSTEM_PERIP_RST_EN0_PWM0_RST = 0x20000
	// Position of I2C_EXT1_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT1_RST_Pos = 0x12
	// Bit mask of I2C_EXT1_RST field.
	SYSTEM_PERIP_RST_EN0_I2C_EXT1_RST_Msk = 0x40000
	// Bit I2C_EXT1_RST.
	SYSTEM_PERIP_RST_EN0_I2C_EXT1_RST = 0x40000
	// Position of TWAI_RST field.
	SYSTEM_PERIP_RST_EN0_TWAI_RST_Pos = 0x13
	// Bit mask of TWAI_RST field.
	SYSTEM_PERIP_RST_EN0_TWAI_RST_Msk = 0x80000
	// Bit TWAI_RST.
	SYSTEM_PERIP_RST_EN0_TWAI_RST = 0x80000
	// Position of PWM1_RST field.
	SYSTEM_PERIP_RST_EN0_PWM1_RST_Pos = 0x14
	// Bit mask of PWM1_RST field.
	SYSTEM_PERIP_RST_EN0_PWM1_RST_Msk = 0x100000
	// Bit PWM1_RST.
	SYSTEM_PERIP_RST_EN0_PWM1_RST = 0x100000
	// Position of I2S1_RST field.
	SYSTEM_PERIP_RST_EN0_I2S1_RST_Pos = 0x15
	// Bit mask of I2S1_RST field.
	SYSTEM_PERIP_RST_EN0_I2S1_RST_Msk = 0x200000
	// Bit I2S1_RST.
	SYSTEM_PERIP_RST_EN0_I2S1_RST = 0x200000
	// Position of SPI2_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_DMA_RST_Pos = 0x16
	// Bit mask of SPI2_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI2_DMA_RST_Msk = 0x400000
	// Bit SPI2_DMA_RST.
	SYSTEM_PERIP_RST_EN0_SPI2_DMA_RST = 0x400000
	// Position of USB_RST field.
	SYSTEM_PERIP_RST_EN0_USB_RST_Pos = 0x17
	// Bit mask of USB_RST field.
	SYSTEM_PERIP_RST_EN0_USB_RST_Msk = 0x800000
	// Bit USB_RST.
	SYSTEM_PERIP_RST_EN0_USB_RST = 0x800000
	// Position of UART_MEM_RST field.
	SYSTEM_PERIP_RST_EN0_UART_MEM_RST_Pos = 0x18
	// Bit mask of UART_MEM_RST field.
	SYSTEM_PERIP_RST_EN0_UART_MEM_RST_Msk = 0x1000000
	// Bit UART_MEM_RST.
	SYSTEM_PERIP_RST_EN0_UART_MEM_RST = 0x1000000
	// Position of PWM2_RST field.
	SYSTEM_PERIP_RST_EN0_PWM2_RST_Pos = 0x19
	// Bit mask of PWM2_RST field.
	SYSTEM_PERIP_RST_EN0_PWM2_RST_Msk = 0x2000000
	// Bit PWM2_RST.
	SYSTEM_PERIP_RST_EN0_PWM2_RST = 0x2000000
	// Position of PWM3_RST field.
	SYSTEM_PERIP_RST_EN0_PWM3_RST_Pos = 0x1a
	// Bit mask of PWM3_RST field.
	SYSTEM_PERIP_RST_EN0_PWM3_RST_Msk = 0x4000000
	// Bit PWM3_RST.
	SYSTEM_PERIP_RST_EN0_PWM3_RST = 0x4000000
	// Position of SPI3_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_DMA_RST_Pos = 0x1b
	// Bit mask of SPI3_DMA_RST field.
	SYSTEM_PERIP_RST_EN0_SPI3_DMA_RST_Msk = 0x8000000
	// Bit SPI3_DMA_RST.
	SYSTEM_PERIP_RST_EN0_SPI3_DMA_RST = 0x8000000
	// Position of APB_SARADC_RST field.
	SYSTEM_PERIP_RST_EN0_APB_SARADC_RST_Pos = 0x1c
	// Bit mask of APB_SARADC_RST field.
	SYSTEM_PERIP_RST_EN0_APB_SARADC_RST_Msk = 0x10000000
	// Bit APB_SARADC_RST.
	SYSTEM_PERIP_RST_EN0_APB_SARADC_RST = 0x10000000
	// Position of SYSTIMER_RST field.
	SYSTEM_PERIP_RST_EN0_SYSTIMER_RST_Pos = 0x1d
	// Bit mask of SYSTIMER_RST field.
	SYSTEM_PERIP_RST_EN0_SYSTIMER_RST_Msk = 0x20000000
	// Bit SYSTIMER_RST.
	SYSTEM_PERIP_RST_EN0_SYSTIMER_RST = 0x20000000
	// Position of ADC2_ARB_RST field.
	SYSTEM_PERIP_RST_EN0_ADC2_ARB_RST_Pos = 0x1e
	// Bit mask of ADC2_ARB_RST field.
	SYSTEM_PERIP_RST_EN0_ADC2_ARB_RST_Msk = 0x40000000
	// Bit ADC2_ARB_RST.
	SYSTEM_PERIP_RST_EN0_ADC2_ARB_RST = 0x40000000
	// Position of SPI4_RST field.
	SYSTEM_PERIP_RST_EN0_SPI4_RST_Pos = 0x1f
	// Bit mask of SPI4_RST field.
	SYSTEM_PERIP_RST_EN0_SPI4_RST_Msk = 0x80000000
	// Bit SPI4_RST.
	SYSTEM_PERIP_RST_EN0_SPI4_RST = 0x80000000

	// PERIP_RST_EN1: System peripheral (hardware accelerators) reset register 1
	// Position of CRYPTO_AES_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_AES_RST_Pos = 0x1
	// Bit mask of CRYPTO_AES_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_AES_RST_Msk = 0x2
	// Bit CRYPTO_AES_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_AES_RST = 0x2
	// Position of CRYPTO_SHA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_SHA_RST_Pos = 0x2
	// Bit mask of CRYPTO_SHA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_SHA_RST_Msk = 0x4
	// Bit CRYPTO_SHA_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_SHA_RST = 0x4
	// Position of CRYPTO_RSA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_RSA_RST_Pos = 0x3
	// Bit mask of CRYPTO_RSA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_RSA_RST_Msk = 0x8
	// Bit CRYPTO_RSA_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_RSA_RST = 0x8
	// Position of CRYPTO_DS_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DS_RST_Pos = 0x4
	// Bit mask of CRYPTO_DS_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DS_RST_Msk = 0x10
	// Bit CRYPTO_DS_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DS_RST = 0x10
	// Position of CRYPTO_HMAC_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_HMAC_RST_Pos = 0x5
	// Bit mask of CRYPTO_HMAC_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_HMAC_RST_Msk = 0x20
	// Bit CRYPTO_HMAC_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_HMAC_RST = 0x20
	// Position of CRYPTO_DMA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DMA_RST_Pos = 0x6
	// Bit mask of CRYPTO_DMA_RST field.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DMA_RST_Msk = 0x40
	// Bit CRYPTO_DMA_RST.
	SYSTEM_PERIP_RST_EN1_CRYPTO_DMA_RST = 0x40

	// LPCK_DIV_INT: Low power clock divider integer register
	// Position of LPCK_DIV_NUM field.
	SYSTEM_LPCK_DIV_INT_LPCK_DIV_NUM_Pos = 0x0
	// Bit mask of LPCK_DIV_NUM field.
	SYSTEM_LPCK_DIV_INT_LPCK_DIV_NUM_Msk = 0xfff

	// BT_LPCK_DIV_FRAC: Divider fraction configuration register for low-power clock
	// Position of LPCLK_SEL_RTC_SLOW field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW_Pos = 0x18
	// Bit mask of LPCLK_SEL_RTC_SLOW field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW_Msk = 0x1000000
	// Bit LPCLK_SEL_RTC_SLOW.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_RTC_SLOW = 0x1000000
	// Position of LPCLK_SEL_8M field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_8M_Pos = 0x19
	// Bit mask of LPCLK_SEL_8M field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_8M_Msk = 0x2000000
	// Bit LPCLK_SEL_8M.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_8M = 0x2000000
	// Position of LPCLK_SEL_XTAL field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL_Pos = 0x1a
	// Bit mask of LPCLK_SEL_XTAL field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL_Msk = 0x4000000
	// Bit LPCLK_SEL_XTAL.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL = 0x4000000
	// Position of LPCLK_SEL_XTAL32K field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K_Pos = 0x1b
	// Bit mask of LPCLK_SEL_XTAL32K field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K_Msk = 0x8000000
	// Bit LPCLK_SEL_XTAL32K.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_SEL_XTAL32K = 0x8000000
	// Position of LPCLK_RTC_EN field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_RTC_EN_Pos = 0x1c
	// Bit mask of LPCLK_RTC_EN field.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_RTC_EN_Msk = 0x10000000
	// Bit LPCLK_RTC_EN.
	SYSTEM_BT_LPCK_DIV_FRAC_LPCLK_RTC_EN = 0x10000000

	// CPU_INTR_FROM_CPU_0: CPU interrupt controlling register 0
	// Position of CPU_INTR_FROM_CPU_0 field.
	SYSTEM_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_0 field.
	SYSTEM_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_0.
	SYSTEM_CPU_INTR_FROM_CPU_0_CPU_INTR_FROM_CPU_0 = 0x1

	// CPU_INTR_FROM_CPU_1: CPU interrupt controlling register 1
	// Position of CPU_INTR_FROM_CPU_1 field.
	SYSTEM_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_1 field.
	SYSTEM_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_1.
	SYSTEM_CPU_INTR_FROM_CPU_1_CPU_INTR_FROM_CPU_1 = 0x1

	// CPU_INTR_FROM_CPU_2: CPU interrupt controlling register 2
	// Position of CPU_INTR_FROM_CPU_2 field.
	SYSTEM_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_2 field.
	SYSTEM_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_2.
	SYSTEM_CPU_INTR_FROM_CPU_2_CPU_INTR_FROM_CPU_2 = 0x1

	// CPU_INTR_FROM_CPU_3: CPU interrupt controlling register 3
	// Position of CPU_INTR_FROM_CPU_3 field.
	SYSTEM_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3_Pos = 0x0
	// Bit mask of CPU_INTR_FROM_CPU_3 field.
	SYSTEM_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3_Msk = 0x1
	// Bit CPU_INTR_FROM_CPU_3.
	SYSTEM_CPU_INTR_FROM_CPU_3_CPU_INTR_FROM_CPU_3 = 0x1

	// RSA_PD_CTRL: RSA memory remapping register
	// Position of RSA_MEM_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_PD_Pos = 0x0
	// Bit mask of RSA_MEM_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_PD_Msk = 0x1
	// Bit RSA_MEM_PD.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_PD = 0x1
	// Position of RSA_MEM_FORCE_PU field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PU_Pos = 0x1
	// Bit mask of RSA_MEM_FORCE_PU field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PU_Msk = 0x2
	// Bit RSA_MEM_FORCE_PU.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PU = 0x2
	// Position of RSA_MEM_FORCE_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PD_Pos = 0x2
	// Bit mask of RSA_MEM_FORCE_PD field.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PD_Msk = 0x4
	// Bit RSA_MEM_FORCE_PD.
	SYSTEM_RSA_PD_CTRL_RSA_MEM_FORCE_PD = 0x4

	// BUSTOEXTMEM_ENA: EDMA enable register
	// Position of BUSTOEXTMEM_ENA field.
	SYSTEM_BUSTOEXTMEM_ENA_BUSTOEXTMEM_ENA_Pos = 0x0
	// Bit mask of BUSTOEXTMEM_ENA field.
	SYSTEM_BUSTOEXTMEM_ENA_BUSTOEXTMEM_ENA_Msk = 0x1
	// Bit BUSTOEXTMEM_ENA.
	SYSTEM_BUSTOEXTMEM_ENA_BUSTOEXTMEM_ENA = 0x1

	// CACHE_CONTROL: Cache control register
	// Position of PRO_ICACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_ICACHE_CLK_ON_Pos = 0x0
	// Bit mask of PRO_ICACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_ICACHE_CLK_ON_Msk = 0x1
	// Bit PRO_ICACHE_CLK_ON.
	SYSTEM_CACHE_CONTROL_PRO_ICACHE_CLK_ON = 0x1
	// Position of PRO_DCACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_DCACHE_CLK_ON_Pos = 0x1
	// Bit mask of PRO_DCACHE_CLK_ON field.
	SYSTEM_CACHE_CONTROL_PRO_DCACHE_CLK_ON_Msk = 0x2
	// Bit PRO_DCACHE_CLK_ON.
	SYSTEM_CACHE_CONTROL_PRO_DCACHE_CLK_ON = 0x2
	// Position of PRO_CACHE_RESET field.
	SYSTEM_CACHE_CONTROL_PRO_CACHE_RESET_Pos = 0x2
	// Bit mask of PRO_CACHE_RESET field.
	SYSTEM_CACHE_CONTROL_PRO_CACHE_RESET_Msk = 0x4
	// Bit PRO_CACHE_RESET.
	SYSTEM_CACHE_CONTROL_PRO_CACHE_RESET = 0x4

	// EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL: External memory encrypt and decrypt controlling register
	// Position of ENABLE_SPI_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT_Pos = 0x0
	// Bit mask of ENABLE_SPI_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT_Msk = 0x1
	// Bit ENABLE_SPI_MANUAL_ENCRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_SPI_MANUAL_ENCRYPT = 0x1
	// Position of ENABLE_DOWNLOAD_DB_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT_Pos = 0x1
	// Bit mask of ENABLE_DOWNLOAD_DB_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT_Msk = 0x2
	// Bit ENABLE_DOWNLOAD_DB_ENCRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_DB_ENCRYPT = 0x2
	// Position of ENABLE_DOWNLOAD_G0CB_DECRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT_Pos = 0x2
	// Bit mask of ENABLE_DOWNLOAD_G0CB_DECRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT_Msk = 0x4
	// Bit ENABLE_DOWNLOAD_G0CB_DECRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_G0CB_DECRYPT = 0x4
	// Position of ENABLE_DOWNLOAD_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT_Pos = 0x3
	// Bit mask of ENABLE_DOWNLOAD_MANUAL_ENCRYPT field.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT_Msk = 0x8
	// Bit ENABLE_DOWNLOAD_MANUAL_ENCRYPT.
	SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_ENABLE_DOWNLOAD_MANUAL_ENCRYPT = 0x8

	// RTC_FASTMEM_CONFIG: RTC fast memory configuration register
	// Position of RTC_MEM_CRC_START field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_START_Pos = 0x8
	// Bit mask of RTC_MEM_CRC_START field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_START_Msk = 0x100
	// Bit RTC_MEM_CRC_START.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_START = 0x100
	// Position of RTC_MEM_CRC_ADDR field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR_Pos = 0x9
	// Bit mask of RTC_MEM_CRC_ADDR field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_ADDR_Msk = 0xffe00
	// Position of RTC_MEM_CRC_LEN field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN_Pos = 0x14
	// Bit mask of RTC_MEM_CRC_LEN field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_LEN_Msk = 0x7ff00000
	// Position of RTC_MEM_CRC_FINISH field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH_Pos = 0x1f
	// Bit mask of RTC_MEM_CRC_FINISH field.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH_Msk = 0x80000000
	// Bit RTC_MEM_CRC_FINISH.
	SYSTEM_RTC_FASTMEM_CONFIG_RTC_MEM_CRC_FINISH = 0x80000000

	// RTC_FASTMEM_CRC: RTC fast memory CRC controlling register
	// Position of RTC_MEM_CRC_RES field.
	SYSTEM_RTC_FASTMEM_CRC_RTC_MEM_CRC_RES_Pos = 0x0
	// Bit mask of RTC_MEM_CRC_RES field.
	SYSTEM_RTC_FASTMEM_CRC_RTC_MEM_CRC_RES_Msk = 0xffffffff

	// Redundant_ECO_Ctrl: Redundant ECO control register
	// Position of REDUNDANT_ECO_DRIVE field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE_Pos = 0x0
	// Bit mask of REDUNDANT_ECO_DRIVE field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE_Msk = 0x1
	// Bit REDUNDANT_ECO_DRIVE.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_DRIVE = 0x1
	// Position of REDUNDANT_ECO_RESULT field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_RESULT_Pos = 0x1
	// Bit mask of REDUNDANT_ECO_RESULT field.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_RESULT_Msk = 0x2
	// Bit REDUNDANT_ECO_RESULT.
	SYSTEM_Redundant_ECO_Ctrl_REDUNDANT_ECO_RESULT = 0x2

	// CLOCK_GATE: Clock gate control register
	// Position of CLK_EN field.
	SYSTEM_CLOCK_GATE_CLK_EN_Pos = 0x0
	// Bit mask of CLK_EN field.
	SYSTEM_CLOCK_GATE_CLK_EN_Msk = 0x1
	// Bit CLK_EN.
	SYSTEM_CLOCK_GATE_CLK_EN = 0x1

	// SRAM_CTRL_2: System SRAM configuration register 2
	// Position of SRAM_FORCE_PU field.
	SYSTEM_SRAM_CTRL_2_SRAM_FORCE_PU_Pos = 0x0
	// Bit mask of SRAM_FORCE_PU field.
	SYSTEM_SRAM_CTRL_2_SRAM_FORCE_PU_Msk = 0x3fffff

	// SYSCLK_CONF: SoC clock configuration register
	// Position of PRE_DIV_CNT field.
	SYSTEM_SYSCLK_CONF_PRE_DIV_CNT_Pos = 0x0
	// Bit mask of PRE_DIV_CNT field.
	SYSTEM_SYSCLK_CONF_PRE_DIV_CNT_Msk = 0x3ff
	// Position of SOC_CLK_SEL field.
	SYSTEM_SYSCLK_CONF_SOC_CLK_SEL_Pos = 0xa
	// Bit mask of SOC_CLK_SEL field.
	SYSTEM_SYSCLK_CONF_SOC_CLK_SEL_Msk = 0xc00
	// Position of CLK_XTAL_FREQ field.
	SYSTEM_SYSCLK_CONF_CLK_XTAL_FREQ_Pos = 0xc
	// Bit mask of CLK_XTAL_FREQ field.
	SYSTEM_SYSCLK_CONF_CLK_XTAL_FREQ_Msk = 0x7f000
	// Position of CLK_DIV_EN field.
	SYSTEM_SYSCLK_CONF_CLK_DIV_EN_Pos = 0x13
	// Bit mask of CLK_DIV_EN field.
	SYSTEM_SYSCLK_CONF_CLK_DIV_EN_Msk = 0x80000
	// Bit CLK_DIV_EN.
	SYSTEM_SYSCLK_CONF_CLK_DIV_EN = 0x80000

	// DATE: Version control register
	// Position of DATE field.
	SYSTEM_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SYSTEM_DATE_DATE_Msk = 0xfffffff
)

// Constants for SYSTIMER: System Timer
const (
	// CONF: Configure system timer clock
	// Position of CLK_FO field.
	SYSTIMER_CONF_CLK_FO_Pos = 0x0
	// Bit mask of CLK_FO field.
	SYSTIMER_CONF_CLK_FO_Msk = 0x1
	// Bit CLK_FO.
	SYSTIMER_CONF_CLK_FO = 0x1
	// Position of CLK_EN field.
	SYSTIMER_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	SYSTIMER_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	SYSTIMER_CONF_CLK_EN = 0x80000000

	// LOAD: Load value to system timer
	// Position of TIMER_LOAD field.
	SYSTIMER_LOAD_TIMER_LOAD_Pos = 0x1f
	// Bit mask of TIMER_LOAD field.
	SYSTIMER_LOAD_TIMER_LOAD_Msk = 0x80000000
	// Bit TIMER_LOAD.
	SYSTIMER_LOAD_TIMER_LOAD = 0x80000000

	// LOAD_HI: High 32 bits to be loaded to system timer
	// Position of TIMER_LOAD_HI field.
	SYSTIMER_LOAD_HI_TIMER_LOAD_HI_Pos = 0x0
	// Bit mask of TIMER_LOAD_HI field.
	SYSTIMER_LOAD_HI_TIMER_LOAD_HI_Msk = 0xffffffff

	// LOAD_LO: Low 32 bits to be loaded to system timer
	// Position of TIMER_LOAD_LO field.
	SYSTIMER_LOAD_LO_TIMER_LOAD_LO_Pos = 0x0
	// Bit mask of TIMER_LOAD_LO field.
	SYSTIMER_LOAD_LO_TIMER_LOAD_LO_Msk = 0xffffffff

	// STEP: System timer accumulation step
	// Position of TIMER_XTAL_STEP field.
	SYSTIMER_STEP_TIMER_XTAL_STEP_Pos = 0x0
	// Bit mask of TIMER_XTAL_STEP field.
	SYSTIMER_STEP_TIMER_XTAL_STEP_Msk = 0x3ff
	// Position of TIMER_PLL_STEP field.
	SYSTIMER_STEP_TIMER_PLL_STEP_Pos = 0xa
	// Bit mask of TIMER_PLL_STEP field.
	SYSTIMER_STEP_TIMER_PLL_STEP_Msk = 0xffc00

	// TARGET0_HI: System timer target 0, high 32 bits
	// Position of TIMER_TARGET0_HI field.
	SYSTIMER_TARGET0_HI_TIMER_TARGET0_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET0_HI field.
	SYSTIMER_TARGET0_HI_TIMER_TARGET0_HI_Msk = 0xffffffff

	// TARGET0_LO: System timer target 0, low 32 bits
	// Position of TIMER_TARGET0_LO field.
	SYSTIMER_TARGET0_LO_TIMER_TARGET0_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET0_LO field.
	SYSTIMER_TARGET0_LO_TIMER_TARGET0_LO_Msk = 0xffffffff

	// TARGET1_HI: System timer target 1, high 32 bits
	// Position of TIMER_TARGET1_HI field.
	SYSTIMER_TARGET1_HI_TIMER_TARGET1_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET1_HI field.
	SYSTIMER_TARGET1_HI_TIMER_TARGET1_HI_Msk = 0xffffffff

	// TARGET1_LO: System timer target 1, low 32 bits
	// Position of TIMER_TARGET1_LO field.
	SYSTIMER_TARGET1_LO_TIMER_TARGET1_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET1_LO field.
	SYSTIMER_TARGET1_LO_TIMER_TARGET1_LO_Msk = 0xffffffff

	// TARGET2_HI: System timer target 2, high 32 bits
	// Position of TIMER_TARGET2_HI field.
	SYSTIMER_TARGET2_HI_TIMER_TARGET2_HI_Pos = 0x0
	// Bit mask of TIMER_TARGET2_HI field.
	SYSTIMER_TARGET2_HI_TIMER_TARGET2_HI_Msk = 0xffffffff

	// TARGET2_LO: System timer target 2, low 32 bits
	// Position of TIMER_TARGET2_LO field.
	SYSTIMER_TARGET2_LO_TIMER_TARGET2_LO_Pos = 0x0
	// Bit mask of TIMER_TARGET2_LO field.
	SYSTIMER_TARGET2_LO_TIMER_TARGET2_LO_Msk = 0xffffffff

	// TARGET0_CONF: Configure work mode for system timer target 0
	// Position of TARGET0_PERIOD field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_Pos = 0x0
	// Bit mask of TARGET0_PERIOD field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_Msk = 0x3fffffff
	// Position of TARGET0_PERIOD_MODE field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET0_PERIOD_MODE field.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET0_PERIOD_MODE.
	SYSTIMER_TARGET0_CONF_TARGET0_PERIOD_MODE = 0x40000000
	// Position of TARGET0_WORK_EN field.
	SYSTIMER_TARGET0_CONF_TARGET0_WORK_EN_Pos = 0x1f
	// Bit mask of TARGET0_WORK_EN field.
	SYSTIMER_TARGET0_CONF_TARGET0_WORK_EN_Msk = 0x80000000
	// Bit TARGET0_WORK_EN.
	SYSTIMER_TARGET0_CONF_TARGET0_WORK_EN = 0x80000000

	// TARGET1_CONF: Configure work mode for system timer target 1
	// Position of TARGET1_PERIOD field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_Pos = 0x0
	// Bit mask of TARGET1_PERIOD field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_Msk = 0x3fffffff
	// Position of TARGET1_PERIOD_MODE field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET1_PERIOD_MODE field.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET1_PERIOD_MODE.
	SYSTIMER_TARGET1_CONF_TARGET1_PERIOD_MODE = 0x40000000
	// Position of TARGET1_WORK_EN field.
	SYSTIMER_TARGET1_CONF_TARGET1_WORK_EN_Pos = 0x1f
	// Bit mask of TARGET1_WORK_EN field.
	SYSTIMER_TARGET1_CONF_TARGET1_WORK_EN_Msk = 0x80000000
	// Bit TARGET1_WORK_EN.
	SYSTIMER_TARGET1_CONF_TARGET1_WORK_EN = 0x80000000

	// TARGET2_CONF: Configure work mode for system timer target 2
	// Position of TARGET2_PERIOD field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_Pos = 0x0
	// Bit mask of TARGET2_PERIOD field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_Msk = 0x3fffffff
	// Position of TARGET2_PERIOD_MODE field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE_Pos = 0x1e
	// Bit mask of TARGET2_PERIOD_MODE field.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE_Msk = 0x40000000
	// Bit TARGET2_PERIOD_MODE.
	SYSTIMER_TARGET2_CONF_TARGET2_PERIOD_MODE = 0x40000000
	// Position of TARGET2_WORK_EN field.
	SYSTIMER_TARGET2_CONF_TARGET2_WORK_EN_Pos = 0x1f
	// Bit mask of TARGET2_WORK_EN field.
	SYSTIMER_TARGET2_CONF_TARGET2_WORK_EN_Msk = 0x80000000
	// Bit TARGET2_WORK_EN.
	SYSTIMER_TARGET2_CONF_TARGET2_WORK_EN = 0x80000000

	// UNIT0_OP: Read out system timer value
	// Position of TIMER_UNIT0_VALUE_VALID field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_VALUE_VALID_Pos = 0x1e
	// Bit mask of TIMER_UNIT0_VALUE_VALID field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_VALUE_VALID_Msk = 0x40000000
	// Bit TIMER_UNIT0_VALUE_VALID.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_VALUE_VALID = 0x40000000
	// Position of TIMER_UNIT0_UPDATE field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_UPDATE_Pos = 0x1f
	// Bit mask of TIMER_UNIT0_UPDATE field.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_UPDATE_Msk = 0x80000000
	// Bit TIMER_UNIT0_UPDATE.
	SYSTIMER_UNIT0_OP_TIMER_UNIT0_UPDATE = 0x80000000

	// UNIT0_VALUE_HI: System timer value, high 32 bits
	// Position of TIMER_VALUE_HI field.
	SYSTIMER_UNIT0_VALUE_HI_TIMER_VALUE_HI_Pos = 0x0
	// Bit mask of TIMER_VALUE_HI field.
	SYSTIMER_UNIT0_VALUE_HI_TIMER_VALUE_HI_Msk = 0xffffffff

	// UNIT0_VALUE_LO: System timer value, low 32 bits
	// Position of TIMER_VALUE_LO field.
	SYSTIMER_UNIT0_VALUE_LO_TIMER_VALUE_LO_Pos = 0x0
	// Bit mask of TIMER_VALUE_LO field.
	SYSTIMER_UNIT0_VALUE_LO_TIMER_VALUE_LO_Msk = 0xffffffff

	// INT_ENA: System timer interrupt enable
	// Position of TARGET0_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET0_INT_ENA_Pos = 0x0
	// Bit mask of TARGET0_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET0_INT_ENA_Msk = 0x1
	// Bit TARGET0_INT_ENA.
	SYSTIMER_INT_ENA_TARGET0_INT_ENA = 0x1
	// Position of TARGET1_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET1_INT_ENA_Pos = 0x1
	// Bit mask of TARGET1_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET1_INT_ENA_Msk = 0x2
	// Bit TARGET1_INT_ENA.
	SYSTIMER_INT_ENA_TARGET1_INT_ENA = 0x2
	// Position of TARGET2_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET2_INT_ENA_Pos = 0x2
	// Bit mask of TARGET2_INT_ENA field.
	SYSTIMER_INT_ENA_TARGET2_INT_ENA_Msk = 0x4
	// Bit TARGET2_INT_ENA.
	SYSTIMER_INT_ENA_TARGET2_INT_ENA = 0x4

	// INT_RAW: System timer interrupt raw
	// Position of INT0_RAW field.
	SYSTIMER_INT_RAW_INT0_RAW_Pos = 0x0
	// Bit mask of INT0_RAW field.
	SYSTIMER_INT_RAW_INT0_RAW_Msk = 0x1
	// Bit INT0_RAW.
	SYSTIMER_INT_RAW_INT0_RAW = 0x1
	// Position of INT1_RAW field.
	SYSTIMER_INT_RAW_INT1_RAW_Pos = 0x1
	// Bit mask of INT1_RAW field.
	SYSTIMER_INT_RAW_INT1_RAW_Msk = 0x2
	// Bit INT1_RAW.
	SYSTIMER_INT_RAW_INT1_RAW = 0x2
	// Position of INT2_RAW field.
	SYSTIMER_INT_RAW_INT2_RAW_Pos = 0x2
	// Bit mask of INT2_RAW field.
	SYSTIMER_INT_RAW_INT2_RAW_Msk = 0x4
	// Bit INT2_RAW.
	SYSTIMER_INT_RAW_INT2_RAW = 0x4

	// INT_CLR: System timer interrupt clear
	// Position of TARGET0_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET0_INT_CLR_Pos = 0x0
	// Bit mask of TARGET0_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET0_INT_CLR_Msk = 0x1
	// Bit TARGET0_INT_CLR.
	SYSTIMER_INT_CLR_TARGET0_INT_CLR = 0x1
	// Position of TARGET1_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET1_INT_CLR_Pos = 0x1
	// Bit mask of TARGET1_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET1_INT_CLR_Msk = 0x2
	// Bit TARGET1_INT_CLR.
	SYSTIMER_INT_CLR_TARGET1_INT_CLR = 0x2
	// Position of TARGET2_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET2_INT_CLR_Pos = 0x2
	// Bit mask of TARGET2_INT_CLR field.
	SYSTIMER_INT_CLR_TARGET2_INT_CLR_Msk = 0x4
	// Bit TARGET2_INT_CLR.
	SYSTIMER_INT_CLR_TARGET2_INT_CLR = 0x4

	// DATE: Version control register
	// Position of DATE field.
	SYSTIMER_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	SYSTIMER_DATE_DATE_Msk = 0xffffffff
)

// Constants for TIMG0: Timer Group 0
const (
	// T0CONFIG: Timer %s configuration register
	// Position of USE_XTAL field.
	TIMG_TCONFIG_USE_XTAL_Pos = 0x9
	// Bit mask of USE_XTAL field.
	TIMG_TCONFIG_USE_XTAL_Msk = 0x200
	// Bit USE_XTAL.
	TIMG_TCONFIG_USE_XTAL = 0x200
	// Position of ALARM_EN field.
	TIMG_TCONFIG_ALARM_EN_Pos = 0xa
	// Bit mask of ALARM_EN field.
	TIMG_TCONFIG_ALARM_EN_Msk = 0x400
	// Bit ALARM_EN.
	TIMG_TCONFIG_ALARM_EN = 0x400
	// Position of LEVEL_INT_EN field.
	TIMG_TCONFIG_LEVEL_INT_EN_Pos = 0xb
	// Bit mask of LEVEL_INT_EN field.
	TIMG_TCONFIG_LEVEL_INT_EN_Msk = 0x800
	// Bit LEVEL_INT_EN.
	TIMG_TCONFIG_LEVEL_INT_EN = 0x800
	// Position of EDGE_INT_EN field.
	TIMG_TCONFIG_EDGE_INT_EN_Pos = 0xc
	// Bit mask of EDGE_INT_EN field.
	TIMG_TCONFIG_EDGE_INT_EN_Msk = 0x1000
	// Bit EDGE_INT_EN.
	TIMG_TCONFIG_EDGE_INT_EN = 0x1000
	// Position of DIVIDER field.
	TIMG_TCONFIG_DIVIDER_Pos = 0xd
	// Bit mask of DIVIDER field.
	TIMG_TCONFIG_DIVIDER_Msk = 0x1fffe000
	// Position of AUTORELOAD field.
	TIMG_TCONFIG_AUTORELOAD_Pos = 0x1d
	// Bit mask of AUTORELOAD field.
	TIMG_TCONFIG_AUTORELOAD_Msk = 0x20000000
	// Bit AUTORELOAD.
	TIMG_TCONFIG_AUTORELOAD = 0x20000000
	// Position of INCREASE field.
	TIMG_TCONFIG_INCREASE_Pos = 0x1e
	// Bit mask of INCREASE field.
	TIMG_TCONFIG_INCREASE_Msk = 0x40000000
	// Bit INCREASE.
	TIMG_TCONFIG_INCREASE = 0x40000000
	// Position of EN field.
	TIMG_TCONFIG_EN_Pos = 0x1f
	// Bit mask of EN field.
	TIMG_TCONFIG_EN_Msk = 0x80000000
	// Bit EN.
	TIMG_TCONFIG_EN = 0x80000000

	// T0LO: Timer %s current value, low 32 bits
	// Position of LO field.
	TIMG_TLO_LO_Pos = 0x0
	// Bit mask of LO field.
	TIMG_TLO_LO_Msk = 0xffffffff

	// T0HI: Timer %s current value, high 32 bits
	// Position of HI field.
	TIMG_THI_HI_Pos = 0x0
	// Bit mask of HI field.
	TIMG_THI_HI_Msk = 0xffffffff

	// T0UPDATE: Write to copy current timer value to TIMG_T%sLO_REG or TIMGn_T%sHI_REG
	// Position of UPDATE field.
	TIMG_TUPDATE_UPDATE_Pos = 0x1f
	// Bit mask of UPDATE field.
	TIMG_TUPDATE_UPDATE_Msk = 0x80000000
	// Bit UPDATE.
	TIMG_TUPDATE_UPDATE = 0x80000000

	// T0ALARMLO: Timer %s alarm value, low 32 bits
	// Position of ALARM_LO field.
	TIMG_TALARMLO_ALARM_LO_Pos = 0x0
	// Bit mask of ALARM_LO field.
	TIMG_TALARMLO_ALARM_LO_Msk = 0xffffffff

	// T0ALARMHI: Timer %s alarm value, high bits
	// Position of ALARM_HI field.
	TIMG_TALARMHI_ALARM_HI_Pos = 0x0
	// Bit mask of ALARM_HI field.
	TIMG_TALARMHI_ALARM_HI_Msk = 0xffffffff

	// T0LOADLO: Timer %s reload value, low 32 bits
	// Position of LOAD_LO field.
	TIMG_TLOADLO_LOAD_LO_Pos = 0x0
	// Bit mask of LOAD_LO field.
	TIMG_TLOADLO_LOAD_LO_Msk = 0xffffffff

	// T0LOADHI: Timer %s reload value, high 32 bits
	// Position of LOAD_HI field.
	TIMG_TLOADHI_LOAD_HI_Pos = 0x0
	// Bit mask of LOAD_HI field.
	TIMG_TLOADHI_LOAD_HI_Msk = 0xffffffff

	// T0LOAD: Write to reload timer from TIMG_T%sLOADLO_REG or TIMG_T%sLOADHI_REG
	// Position of LOAD field.
	TIMG_TLOAD_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	TIMG_TLOAD_LOAD_Msk = 0xffffffff

	// WDTCONFIG0: Watchdog timer configuration register
	// Position of WDT_APPCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_APPCPU_RESET_EN_Pos = 0xc
	// Bit mask of WDT_APPCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_APPCPU_RESET_EN_Msk = 0x1000
	// Bit WDT_APPCPU_RESET_EN.
	TIMG_WDTCONFIG0_WDT_APPCPU_RESET_EN = 0x1000
	// Position of WDT_PROCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_PROCPU_RESET_EN_Pos = 0xd
	// Bit mask of WDT_PROCPU_RESET_EN field.
	TIMG_WDTCONFIG0_WDT_PROCPU_RESET_EN_Msk = 0x2000
	// Bit WDT_PROCPU_RESET_EN.
	TIMG_WDTCONFIG0_WDT_PROCPU_RESET_EN = 0x2000
	// Position of WDT_FLASHBOOT_MOD_EN field.
	TIMG_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Pos = 0xe
	// Bit mask of WDT_FLASHBOOT_MOD_EN field.
	TIMG_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN_Msk = 0x4000
	// Bit WDT_FLASHBOOT_MOD_EN.
	TIMG_WDTCONFIG0_WDT_FLASHBOOT_MOD_EN = 0x4000
	// Position of WDT_SYS_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Pos = 0xf
	// Bit mask of WDT_SYS_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_SYS_RESET_LENGTH_Msk = 0x38000
	// Position of WDT_CPU_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Pos = 0x12
	// Bit mask of WDT_CPU_RESET_LENGTH field.
	TIMG_WDTCONFIG0_WDT_CPU_RESET_LENGTH_Msk = 0x1c0000
	// Position of WDT_LEVEL_INT_EN field.
	TIMG_WDTCONFIG0_WDT_LEVEL_INT_EN_Pos = 0x15
	// Bit mask of WDT_LEVEL_INT_EN field.
	TIMG_WDTCONFIG0_WDT_LEVEL_INT_EN_Msk = 0x200000
	// Bit WDT_LEVEL_INT_EN.
	TIMG_WDTCONFIG0_WDT_LEVEL_INT_EN = 0x200000
	// Position of WDT_EDGE_INT_EN field.
	TIMG_WDTCONFIG0_WDT_EDGE_INT_EN_Pos = 0x16
	// Bit mask of WDT_EDGE_INT_EN field.
	TIMG_WDTCONFIG0_WDT_EDGE_INT_EN_Msk = 0x400000
	// Bit WDT_EDGE_INT_EN.
	TIMG_WDTCONFIG0_WDT_EDGE_INT_EN = 0x400000
	// Position of WDT_STG3 field.
	TIMG_WDTCONFIG0_WDT_STG3_Pos = 0x17
	// Bit mask of WDT_STG3 field.
	TIMG_WDTCONFIG0_WDT_STG3_Msk = 0x1800000
	// Position of WDT_STG2 field.
	TIMG_WDTCONFIG0_WDT_STG2_Pos = 0x19
	// Bit mask of WDT_STG2 field.
	TIMG_WDTCONFIG0_WDT_STG2_Msk = 0x6000000
	// Position of WDT_STG1 field.
	TIMG_WDTCONFIG0_WDT_STG1_Pos = 0x1b
	// Bit mask of WDT_STG1 field.
	TIMG_WDTCONFIG0_WDT_STG1_Msk = 0x18000000
	// Position of WDT_STG0 field.
	TIMG_WDTCONFIG0_WDT_STG0_Pos = 0x1d
	// Bit mask of WDT_STG0 field.
	TIMG_WDTCONFIG0_WDT_STG0_Msk = 0x60000000
	// Position of WDT_EN field.
	TIMG_WDTCONFIG0_WDT_EN_Pos = 0x1f
	// Bit mask of WDT_EN field.
	TIMG_WDTCONFIG0_WDT_EN_Msk = 0x80000000
	// Bit WDT_EN.
	TIMG_WDTCONFIG0_WDT_EN = 0x80000000

	// WDTCONFIG1: Watchdog timer prescaler register
	// Position of WDT_CLK_PRESCALE field.
	TIMG_WDTCONFIG1_WDT_CLK_PRESCALE_Pos = 0x10
	// Bit mask of WDT_CLK_PRESCALE field.
	TIMG_WDTCONFIG1_WDT_CLK_PRESCALE_Msk = 0xffff0000

	// WDTCONFIG2: Watchdog timer stage 0 timeout value
	// Position of WDT_STG0_HOLD field.
	TIMG_WDTCONFIG2_WDT_STG0_HOLD_Pos = 0x0
	// Bit mask of WDT_STG0_HOLD field.
	TIMG_WDTCONFIG2_WDT_STG0_HOLD_Msk = 0xffffffff

	// WDTCONFIG3: Watchdog timer stage 1 timeout value
	// Position of WDT_STG1_HOLD field.
	TIMG_WDTCONFIG3_WDT_STG1_HOLD_Pos = 0x0
	// Bit mask of WDT_STG1_HOLD field.
	TIMG_WDTCONFIG3_WDT_STG1_HOLD_Msk = 0xffffffff

	// WDTCONFIG4: Watchdog timer stage 2 timeout value
	// Position of WDT_STG2_HOLD field.
	TIMG_WDTCONFIG4_WDT_STG2_HOLD_Pos = 0x0
	// Bit mask of WDT_STG2_HOLD field.
	TIMG_WDTCONFIG4_WDT_STG2_HOLD_Msk = 0xffffffff

	// WDTCONFIG5: Watchdog timer stage 3 timeout value
	// Position of WDT_STG3_HOLD field.
	TIMG_WDTCONFIG5_WDT_STG3_HOLD_Pos = 0x0
	// Bit mask of WDT_STG3_HOLD field.
	TIMG_WDTCONFIG5_WDT_STG3_HOLD_Msk = 0xffffffff

	// WDTFEED: Write to feed the watchdog timer
	// Position of WDT_FEED field.
	TIMG_WDTFEED_WDT_FEED_Pos = 0x0
	// Bit mask of WDT_FEED field.
	TIMG_WDTFEED_WDT_FEED_Msk = 0xffffffff

	// WDTWPROTECT: Watchdog write protect register
	// Position of WDT_WKEY field.
	TIMG_WDTWPROTECT_WDT_WKEY_Pos = 0x0
	// Bit mask of WDT_WKEY field.
	TIMG_WDTWPROTECT_WDT_WKEY_Msk = 0xffffffff

	// RTCCALICFG: RTC calibration configuration register
	// Position of RTC_CALI_START_CYCLING field.
	TIMG_RTCCALICFG_RTC_CALI_START_CYCLING_Pos = 0xc
	// Bit mask of RTC_CALI_START_CYCLING field.
	TIMG_RTCCALICFG_RTC_CALI_START_CYCLING_Msk = 0x1000
	// Bit RTC_CALI_START_CYCLING.
	TIMG_RTCCALICFG_RTC_CALI_START_CYCLING = 0x1000
	// Position of RTC_CALI_CLK_SEL field.
	TIMG_RTCCALICFG_RTC_CALI_CLK_SEL_Pos = 0xd
	// Bit mask of RTC_CALI_CLK_SEL field.
	TIMG_RTCCALICFG_RTC_CALI_CLK_SEL_Msk = 0x6000
	// Position of RTC_CALI_RDY field.
	TIMG_RTCCALICFG_RTC_CALI_RDY_Pos = 0xf
	// Bit mask of RTC_CALI_RDY field.
	TIMG_RTCCALICFG_RTC_CALI_RDY_Msk = 0x8000
	// Bit RTC_CALI_RDY.
	TIMG_RTCCALICFG_RTC_CALI_RDY = 0x8000
	// Position of RTC_CALI_MAX field.
	TIMG_RTCCALICFG_RTC_CALI_MAX_Pos = 0x10
	// Bit mask of RTC_CALI_MAX field.
	TIMG_RTCCALICFG_RTC_CALI_MAX_Msk = 0x7fff0000
	// Position of RTC_CALI_START field.
	TIMG_RTCCALICFG_RTC_CALI_START_Pos = 0x1f
	// Bit mask of RTC_CALI_START field.
	TIMG_RTCCALICFG_RTC_CALI_START_Msk = 0x80000000
	// Bit RTC_CALI_START.
	TIMG_RTCCALICFG_RTC_CALI_START = 0x80000000

	// RTCCALICFG1: RTC calibration configuration register 1
	// Position of RTC_CALI_CYCLING_DATA_VLD field.
	TIMG_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD_Pos = 0x0
	// Bit mask of RTC_CALI_CYCLING_DATA_VLD field.
	TIMG_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD_Msk = 0x1
	// Bit RTC_CALI_CYCLING_DATA_VLD.
	TIMG_RTCCALICFG1_RTC_CALI_CYCLING_DATA_VLD = 0x1
	// Position of RTC_CALI_VALUE field.
	TIMG_RTCCALICFG1_RTC_CALI_VALUE_Pos = 0x7
	// Bit mask of RTC_CALI_VALUE field.
	TIMG_RTCCALICFG1_RTC_CALI_VALUE_Msk = 0xffffff80

	// LACTCONFIG: LACT configuration register
	// Position of LACT_USE_REFTICK field.
	TIMG_LACTCONFIG_LACT_USE_REFTICK_Pos = 0x6
	// Bit mask of LACT_USE_REFTICK field.
	TIMG_LACTCONFIG_LACT_USE_REFTICK_Msk = 0x40
	// Bit LACT_USE_REFTICK.
	TIMG_LACTCONFIG_LACT_USE_REFTICK = 0x40
	// Position of LACT_RTC_ONLY field.
	TIMG_LACTCONFIG_LACT_RTC_ONLY_Pos = 0x7
	// Bit mask of LACT_RTC_ONLY field.
	TIMG_LACTCONFIG_LACT_RTC_ONLY_Msk = 0x80
	// Bit LACT_RTC_ONLY.
	TIMG_LACTCONFIG_LACT_RTC_ONLY = 0x80
	// Position of LACT_CPST_EN field.
	TIMG_LACTCONFIG_LACT_CPST_EN_Pos = 0x8
	// Bit mask of LACT_CPST_EN field.
	TIMG_LACTCONFIG_LACT_CPST_EN_Msk = 0x100
	// Bit LACT_CPST_EN.
	TIMG_LACTCONFIG_LACT_CPST_EN = 0x100
	// Position of LACT_LAC_EN field.
	TIMG_LACTCONFIG_LACT_LAC_EN_Pos = 0x9
	// Bit mask of LACT_LAC_EN field.
	TIMG_LACTCONFIG_LACT_LAC_EN_Msk = 0x200
	// Bit LACT_LAC_EN.
	TIMG_LACTCONFIG_LACT_LAC_EN = 0x200
	// Position of LACT_ALARM_EN field.
	TIMG_LACTCONFIG_LACT_ALARM_EN_Pos = 0xa
	// Bit mask of LACT_ALARM_EN field.
	TIMG_LACTCONFIG_LACT_ALARM_EN_Msk = 0x400
	// Bit LACT_ALARM_EN.
	TIMG_LACTCONFIG_LACT_ALARM_EN = 0x400
	// Position of LACT_LEVEL_INT_EN field.
	TIMG_LACTCONFIG_LACT_LEVEL_INT_EN_Pos = 0xb
	// Bit mask of LACT_LEVEL_INT_EN field.
	TIMG_LACTCONFIG_LACT_LEVEL_INT_EN_Msk = 0x800
	// Bit LACT_LEVEL_INT_EN.
	TIMG_LACTCONFIG_LACT_LEVEL_INT_EN = 0x800
	// Position of LACT_EDGE_INT_EN field.
	TIMG_LACTCONFIG_LACT_EDGE_INT_EN_Pos = 0xc
	// Bit mask of LACT_EDGE_INT_EN field.
	TIMG_LACTCONFIG_LACT_EDGE_INT_EN_Msk = 0x1000
	// Bit LACT_EDGE_INT_EN.
	TIMG_LACTCONFIG_LACT_EDGE_INT_EN = 0x1000
	// Position of LACT_DIVIDER field.
	TIMG_LACTCONFIG_LACT_DIVIDER_Pos = 0xd
	// Bit mask of LACT_DIVIDER field.
	TIMG_LACTCONFIG_LACT_DIVIDER_Msk = 0x1fffe000
	// Position of LACT_AUTORELOAD field.
	TIMG_LACTCONFIG_LACT_AUTORELOAD_Pos = 0x1d
	// Bit mask of LACT_AUTORELOAD field.
	TIMG_LACTCONFIG_LACT_AUTORELOAD_Msk = 0x20000000
	// Bit LACT_AUTORELOAD.
	TIMG_LACTCONFIG_LACT_AUTORELOAD = 0x20000000
	// Position of LACT_INCREASE field.
	TIMG_LACTCONFIG_LACT_INCREASE_Pos = 0x1e
	// Bit mask of LACT_INCREASE field.
	TIMG_LACTCONFIG_LACT_INCREASE_Msk = 0x40000000
	// Bit LACT_INCREASE.
	TIMG_LACTCONFIG_LACT_INCREASE = 0x40000000
	// Position of LACT_EN field.
	TIMG_LACTCONFIG_LACT_EN_Pos = 0x1f
	// Bit mask of LACT_EN field.
	TIMG_LACTCONFIG_LACT_EN_Msk = 0x80000000
	// Bit LACT_EN.
	TIMG_LACTCONFIG_LACT_EN = 0x80000000

	// LACTRTC: LACT RTC register
	// Position of LACT_RTC_STEP_LEN field.
	TIMG_LACTRTC_LACT_RTC_STEP_LEN_Pos = 0x6
	// Bit mask of LACT_RTC_STEP_LEN field.
	TIMG_LACTRTC_LACT_RTC_STEP_LEN_Msk = 0xffffffc0

	// LACTLO: LACT low register
	// Position of LACT_LO field.
	TIMG_LACTLO_LACT_LO_Pos = 0x0
	// Bit mask of LACT_LO field.
	TIMG_LACTLO_LACT_LO_Msk = 0xffffffff

	// LACTHI: LACT high register
	// Position of LACT_HI field.
	TIMG_LACTHI_LACT_HI_Pos = 0x0
	// Bit mask of LACT_HI field.
	TIMG_LACTHI_LACT_HI_Msk = 0xffffffff

	// LACTUPDATE: LACT update register
	// Position of LACT_UPDATE field.
	TIMG_LACTUPDATE_LACT_UPDATE_Pos = 0x0
	// Bit mask of LACT_UPDATE field.
	TIMG_LACTUPDATE_LACT_UPDATE_Msk = 0xffffffff

	// LACTALARMLO: LACT alarm low register
	// Position of LACT_ALARM_LO field.
	TIMG_LACTALARMLO_LACT_ALARM_LO_Pos = 0x0
	// Bit mask of LACT_ALARM_LO field.
	TIMG_LACTALARMLO_LACT_ALARM_LO_Msk = 0xffffffff

	// LACTALARMHI: LACT alarm high register
	// Position of LACT_ALARM_HI field.
	TIMG_LACTALARMHI_LACT_ALARM_HI_Pos = 0x0
	// Bit mask of LACT_ALARM_HI field.
	TIMG_LACTALARMHI_LACT_ALARM_HI_Msk = 0xffffffff

	// LACTLOADLO: LACT load low register
	// Position of LACT_LOAD_LO field.
	TIMG_LACTLOADLO_LACT_LOAD_LO_Pos = 0x0
	// Bit mask of LACT_LOAD_LO field.
	TIMG_LACTLOADLO_LACT_LOAD_LO_Msk = 0xffffffff

	// LACTLOADHI: Timer LACT load high register
	// Position of LACT_LOAD_HI field.
	TIMG_LACTLOADHI_LACT_LOAD_HI_Pos = 0x0
	// Bit mask of LACT_LOAD_HI field.
	TIMG_LACTLOADHI_LACT_LOAD_HI_Msk = 0xffffffff

	// LACTLOAD: Timer LACT load register
	// Position of LACT_LOAD field.
	TIMG_LACTLOAD_LACT_LOAD_Pos = 0x0
	// Bit mask of LACT_LOAD field.
	TIMG_LACTLOAD_LACT_LOAD_Msk = 0xffffffff

	// INT_ENA_TIMERS: Interrupt enable bits
	// Position of T0_INT_ENA field.
	TIMG_INT_ENA_TIMERS_T0_INT_ENA_Pos = 0x0
	// Bit mask of T0_INT_ENA field.
	TIMG_INT_ENA_TIMERS_T0_INT_ENA_Msk = 0x1
	// Bit T0_INT_ENA.
	TIMG_INT_ENA_TIMERS_T0_INT_ENA = 0x1
	// Position of T1_INT_ENA field.
	TIMG_INT_ENA_TIMERS_T1_INT_ENA_Pos = 0x1
	// Bit mask of T1_INT_ENA field.
	TIMG_INT_ENA_TIMERS_T1_INT_ENA_Msk = 0x2
	// Bit T1_INT_ENA.
	TIMG_INT_ENA_TIMERS_T1_INT_ENA = 0x2
	// Position of WDT_INT_ENA field.
	TIMG_INT_ENA_TIMERS_WDT_INT_ENA_Pos = 0x2
	// Bit mask of WDT_INT_ENA field.
	TIMG_INT_ENA_TIMERS_WDT_INT_ENA_Msk = 0x4
	// Bit WDT_INT_ENA.
	TIMG_INT_ENA_TIMERS_WDT_INT_ENA = 0x4
	// Position of LACT_INT_ENA field.
	TIMG_INT_ENA_TIMERS_LACT_INT_ENA_Pos = 0x3
	// Bit mask of LACT_INT_ENA field.
	TIMG_INT_ENA_TIMERS_LACT_INT_ENA_Msk = 0x8
	// Bit LACT_INT_ENA.
	TIMG_INT_ENA_TIMERS_LACT_INT_ENA = 0x8

	// INT_RAW_TIMERS: Raw interrupt status
	// Position of T0_INT_RAW field.
	TIMG_INT_RAW_TIMERS_T0_INT_RAW_Pos = 0x0
	// Bit mask of T0_INT_RAW field.
	TIMG_INT_RAW_TIMERS_T0_INT_RAW_Msk = 0x1
	// Bit T0_INT_RAW.
	TIMG_INT_RAW_TIMERS_T0_INT_RAW = 0x1
	// Position of T1_INT_RAW field.
	TIMG_INT_RAW_TIMERS_T1_INT_RAW_Pos = 0x1
	// Bit mask of T1_INT_RAW field.
	TIMG_INT_RAW_TIMERS_T1_INT_RAW_Msk = 0x2
	// Bit T1_INT_RAW.
	TIMG_INT_RAW_TIMERS_T1_INT_RAW = 0x2
	// Position of WDT_INT_RAW field.
	TIMG_INT_RAW_TIMERS_WDT_INT_RAW_Pos = 0x2
	// Bit mask of WDT_INT_RAW field.
	TIMG_INT_RAW_TIMERS_WDT_INT_RAW_Msk = 0x4
	// Bit WDT_INT_RAW.
	TIMG_INT_RAW_TIMERS_WDT_INT_RAW = 0x4
	// Position of LACT_INT_RAW field.
	TIMG_INT_RAW_TIMERS_LACT_INT_RAW_Pos = 0x3
	// Bit mask of LACT_INT_RAW field.
	TIMG_INT_RAW_TIMERS_LACT_INT_RAW_Msk = 0x8
	// Bit LACT_INT_RAW.
	TIMG_INT_RAW_TIMERS_LACT_INT_RAW = 0x8

	// INT_ST_TIMERS: Masked interrupt status
	// Position of T0_INT_ST field.
	TIMG_INT_ST_TIMERS_T0_INT_ST_Pos = 0x0
	// Bit mask of T0_INT_ST field.
	TIMG_INT_ST_TIMERS_T0_INT_ST_Msk = 0x1
	// Bit T0_INT_ST.
	TIMG_INT_ST_TIMERS_T0_INT_ST = 0x1
	// Position of T1_INT_ST field.
	TIMG_INT_ST_TIMERS_T1_INT_ST_Pos = 0x1
	// Bit mask of T1_INT_ST field.
	TIMG_INT_ST_TIMERS_T1_INT_ST_Msk = 0x2
	// Bit T1_INT_ST.
	TIMG_INT_ST_TIMERS_T1_INT_ST = 0x2
	// Position of WDT_INT_ST field.
	TIMG_INT_ST_TIMERS_WDT_INT_ST_Pos = 0x2
	// Bit mask of WDT_INT_ST field.
	TIMG_INT_ST_TIMERS_WDT_INT_ST_Msk = 0x4
	// Bit WDT_INT_ST.
	TIMG_INT_ST_TIMERS_WDT_INT_ST = 0x4
	// Position of LACT_INT_ST field.
	TIMG_INT_ST_TIMERS_LACT_INT_ST_Pos = 0x3
	// Bit mask of LACT_INT_ST field.
	TIMG_INT_ST_TIMERS_LACT_INT_ST_Msk = 0x8
	// Bit LACT_INT_ST.
	TIMG_INT_ST_TIMERS_LACT_INT_ST = 0x8

	// INT_CLR_TIMERS: Interrupt clear bits
	// Position of T0_INT_CLR field.
	TIMG_INT_CLR_TIMERS_T0_INT_CLR_Pos = 0x0
	// Bit mask of T0_INT_CLR field.
	TIMG_INT_CLR_TIMERS_T0_INT_CLR_Msk = 0x1
	// Bit T0_INT_CLR.
	TIMG_INT_CLR_TIMERS_T0_INT_CLR = 0x1
	// Position of T1_INT_CLR field.
	TIMG_INT_CLR_TIMERS_T1_INT_CLR_Pos = 0x1
	// Bit mask of T1_INT_CLR field.
	TIMG_INT_CLR_TIMERS_T1_INT_CLR_Msk = 0x2
	// Bit T1_INT_CLR.
	TIMG_INT_CLR_TIMERS_T1_INT_CLR = 0x2
	// Position of WDT_INT_CLR field.
	TIMG_INT_CLR_TIMERS_WDT_INT_CLR_Pos = 0x2
	// Bit mask of WDT_INT_CLR field.
	TIMG_INT_CLR_TIMERS_WDT_INT_CLR_Msk = 0x4
	// Bit WDT_INT_CLR.
	TIMG_INT_CLR_TIMERS_WDT_INT_CLR = 0x4
	// Position of LACT_INT_CLR field.
	TIMG_INT_CLR_TIMERS_LACT_INT_CLR_Pos = 0x3
	// Bit mask of LACT_INT_CLR field.
	TIMG_INT_CLR_TIMERS_LACT_INT_CLR_Msk = 0x8
	// Bit LACT_INT_CLR.
	TIMG_INT_CLR_TIMERS_LACT_INT_CLR = 0x8

	// RTCCALICFG2: Timer group calibration register
	// Position of RTC_CALI_TIMEOUT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_Pos = 0x0
	// Bit mask of RTC_CALI_TIMEOUT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_Msk = 0x1
	// Bit RTC_CALI_TIMEOUT.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT = 0x1
	// Position of RTC_CALI_TIMEOUT_RST_CNT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT_Pos = 0x3
	// Bit mask of RTC_CALI_TIMEOUT_RST_CNT field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_RST_CNT_Msk = 0x78
	// Position of RTC_CALI_TIMEOUT_THRES field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_THRES_Pos = 0x7
	// Bit mask of RTC_CALI_TIMEOUT_THRES field.
	TIMG_RTCCALICFG2_RTC_CALI_TIMEOUT_THRES_Msk = 0xffffff80

	// TIMERS_DATE: Version control register
	// Position of TIMERS_DATE field.
	TIMG_TIMERS_DATE_TIMERS_DATE_Pos = 0x0
	// Bit mask of TIMERS_DATE field.
	TIMG_TIMERS_DATE_TIMERS_DATE_Msk = 0xfffffff

	// REGCLK: Timer group clock gate register
	// Position of CLK_EN field.
	TIMG_REGCLK_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	TIMG_REGCLK_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	TIMG_REGCLK_CLK_EN = 0x80000000
)

// Constants for TWAI0: Two-Wire Automotive Interface
const (
	// MODE: Mode Register
	// Position of RESET_MODE field.
	TWAI_MODE_RESET_MODE_Pos = 0x0
	// Bit mask of RESET_MODE field.
	TWAI_MODE_RESET_MODE_Msk = 0x1
	// Bit RESET_MODE.
	TWAI_MODE_RESET_MODE = 0x1
	// Position of LISTEN_ONLY_MODE field.
	TWAI_MODE_LISTEN_ONLY_MODE_Pos = 0x1
	// Bit mask of LISTEN_ONLY_MODE field.
	TWAI_MODE_LISTEN_ONLY_MODE_Msk = 0x2
	// Bit LISTEN_ONLY_MODE.
	TWAI_MODE_LISTEN_ONLY_MODE = 0x2
	// Position of SELF_TEST_MODE field.
	TWAI_MODE_SELF_TEST_MODE_Pos = 0x2
	// Bit mask of SELF_TEST_MODE field.
	TWAI_MODE_SELF_TEST_MODE_Msk = 0x4
	// Bit SELF_TEST_MODE.
	TWAI_MODE_SELF_TEST_MODE = 0x4
	// Position of RX_FILTER_MODE field.
	TWAI_MODE_RX_FILTER_MODE_Pos = 0x3
	// Bit mask of RX_FILTER_MODE field.
	TWAI_MODE_RX_FILTER_MODE_Msk = 0x8
	// Bit RX_FILTER_MODE.
	TWAI_MODE_RX_FILTER_MODE = 0x8

	// CMD: Command Register
	// Position of TX_REQ field.
	TWAI_CMD_TX_REQ_Pos = 0x0
	// Bit mask of TX_REQ field.
	TWAI_CMD_TX_REQ_Msk = 0x1
	// Bit TX_REQ.
	TWAI_CMD_TX_REQ = 0x1
	// Position of ABORT_TX field.
	TWAI_CMD_ABORT_TX_Pos = 0x1
	// Bit mask of ABORT_TX field.
	TWAI_CMD_ABORT_TX_Msk = 0x2
	// Bit ABORT_TX.
	TWAI_CMD_ABORT_TX = 0x2
	// Position of RELEASE_BUF field.
	TWAI_CMD_RELEASE_BUF_Pos = 0x2
	// Bit mask of RELEASE_BUF field.
	TWAI_CMD_RELEASE_BUF_Msk = 0x4
	// Bit RELEASE_BUF.
	TWAI_CMD_RELEASE_BUF = 0x4
	// Position of CLR_OVERRUN field.
	TWAI_CMD_CLR_OVERRUN_Pos = 0x3
	// Bit mask of CLR_OVERRUN field.
	TWAI_CMD_CLR_OVERRUN_Msk = 0x8
	// Bit CLR_OVERRUN.
	TWAI_CMD_CLR_OVERRUN = 0x8
	// Position of SELF_RX_REQ field.
	TWAI_CMD_SELF_RX_REQ_Pos = 0x4
	// Bit mask of SELF_RX_REQ field.
	TWAI_CMD_SELF_RX_REQ_Msk = 0x10
	// Bit SELF_RX_REQ.
	TWAI_CMD_SELF_RX_REQ = 0x10

	// STATUS: Status register
	// Position of RX_BUF_ST field.
	TWAI_STATUS_RX_BUF_ST_Pos = 0x0
	// Bit mask of RX_BUF_ST field.
	TWAI_STATUS_RX_BUF_ST_Msk = 0x1
	// Bit RX_BUF_ST.
	TWAI_STATUS_RX_BUF_ST = 0x1
	// Position of OVERRUN_ST field.
	TWAI_STATUS_OVERRUN_ST_Pos = 0x1
	// Bit mask of OVERRUN_ST field.
	TWAI_STATUS_OVERRUN_ST_Msk = 0x2
	// Bit OVERRUN_ST.
	TWAI_STATUS_OVERRUN_ST = 0x2
	// Position of TX_BUF_ST field.
	TWAI_STATUS_TX_BUF_ST_Pos = 0x2
	// Bit mask of TX_BUF_ST field.
	TWAI_STATUS_TX_BUF_ST_Msk = 0x4
	// Bit TX_BUF_ST.
	TWAI_STATUS_TX_BUF_ST = 0x4
	// Position of TX_COMPLETE field.
	TWAI_STATUS_TX_COMPLETE_Pos = 0x3
	// Bit mask of TX_COMPLETE field.
	TWAI_STATUS_TX_COMPLETE_Msk = 0x8
	// Bit TX_COMPLETE.
	TWAI_STATUS_TX_COMPLETE = 0x8
	// Position of RX_ST field.
	TWAI_STATUS_RX_ST_Pos = 0x4
	// Bit mask of RX_ST field.
	TWAI_STATUS_RX_ST_Msk = 0x10
	// Bit RX_ST.
	TWAI_STATUS_RX_ST = 0x10
	// Position of TX_ST field.
	TWAI_STATUS_TX_ST_Pos = 0x5
	// Bit mask of TX_ST field.
	TWAI_STATUS_TX_ST_Msk = 0x20
	// Bit TX_ST.
	TWAI_STATUS_TX_ST = 0x20
	// Position of ERR_ST field.
	TWAI_STATUS_ERR_ST_Pos = 0x6
	// Bit mask of ERR_ST field.
	TWAI_STATUS_ERR_ST_Msk = 0x40
	// Bit ERR_ST.
	TWAI_STATUS_ERR_ST = 0x40
	// Position of BUS_OFF_ST field.
	TWAI_STATUS_BUS_OFF_ST_Pos = 0x7
	// Bit mask of BUS_OFF_ST field.
	TWAI_STATUS_BUS_OFF_ST_Msk = 0x80
	// Bit BUS_OFF_ST.
	TWAI_STATUS_BUS_OFF_ST = 0x80
	// Position of MISS_ST field.
	TWAI_STATUS_MISS_ST_Pos = 0x8
	// Bit mask of MISS_ST field.
	TWAI_STATUS_MISS_ST_Msk = 0x100
	// Bit MISS_ST.
	TWAI_STATUS_MISS_ST = 0x100

	// INT_RAW: Interrupt Register
	// Position of RX_INT_ST field.
	TWAI_INT_RAW_RX_INT_ST_Pos = 0x0
	// Bit mask of RX_INT_ST field.
	TWAI_INT_RAW_RX_INT_ST_Msk = 0x1
	// Bit RX_INT_ST.
	TWAI_INT_RAW_RX_INT_ST = 0x1
	// Position of TX_INT_ST field.
	TWAI_INT_RAW_TX_INT_ST_Pos = 0x1
	// Bit mask of TX_INT_ST field.
	TWAI_INT_RAW_TX_INT_ST_Msk = 0x2
	// Bit TX_INT_ST.
	TWAI_INT_RAW_TX_INT_ST = 0x2
	// Position of ERR_WARN_INT_ST field.
	TWAI_INT_RAW_ERR_WARN_INT_ST_Pos = 0x2
	// Bit mask of ERR_WARN_INT_ST field.
	TWAI_INT_RAW_ERR_WARN_INT_ST_Msk = 0x4
	// Bit ERR_WARN_INT_ST.
	TWAI_INT_RAW_ERR_WARN_INT_ST = 0x4
	// Position of OVERRUN_INT_ST field.
	TWAI_INT_RAW_OVERRUN_INT_ST_Pos = 0x3
	// Bit mask of OVERRUN_INT_ST field.
	TWAI_INT_RAW_OVERRUN_INT_ST_Msk = 0x8
	// Bit OVERRUN_INT_ST.
	TWAI_INT_RAW_OVERRUN_INT_ST = 0x8
	// Position of ERR_PASSIVE_INT_ST field.
	TWAI_INT_RAW_ERR_PASSIVE_INT_ST_Pos = 0x5
	// Bit mask of ERR_PASSIVE_INT_ST field.
	TWAI_INT_RAW_ERR_PASSIVE_INT_ST_Msk = 0x20
	// Bit ERR_PASSIVE_INT_ST.
	TWAI_INT_RAW_ERR_PASSIVE_INT_ST = 0x20
	// Position of ARB_LOST_INT_ST field.
	TWAI_INT_RAW_ARB_LOST_INT_ST_Pos = 0x6
	// Bit mask of ARB_LOST_INT_ST field.
	TWAI_INT_RAW_ARB_LOST_INT_ST_Msk = 0x40
	// Bit ARB_LOST_INT_ST.
	TWAI_INT_RAW_ARB_LOST_INT_ST = 0x40
	// Position of BUS_ERR_INT_ST field.
	TWAI_INT_RAW_BUS_ERR_INT_ST_Pos = 0x7
	// Bit mask of BUS_ERR_INT_ST field.
	TWAI_INT_RAW_BUS_ERR_INT_ST_Msk = 0x80
	// Bit BUS_ERR_INT_ST.
	TWAI_INT_RAW_BUS_ERR_INT_ST = 0x80

	// INT_ENA: Interrupt Enable Register
	// Position of RX_INT_ENA field.
	TWAI_INT_ENA_RX_INT_ENA_Pos = 0x0
	// Bit mask of RX_INT_ENA field.
	TWAI_INT_ENA_RX_INT_ENA_Msk = 0x1
	// Bit RX_INT_ENA.
	TWAI_INT_ENA_RX_INT_ENA = 0x1
	// Position of TX_INT_ENA field.
	TWAI_INT_ENA_TX_INT_ENA_Pos = 0x1
	// Bit mask of TX_INT_ENA field.
	TWAI_INT_ENA_TX_INT_ENA_Msk = 0x2
	// Bit TX_INT_ENA.
	TWAI_INT_ENA_TX_INT_ENA = 0x2
	// Position of ERR_WARN_INT_ENA field.
	TWAI_INT_ENA_ERR_WARN_INT_ENA_Pos = 0x2
	// Bit mask of ERR_WARN_INT_ENA field.
	TWAI_INT_ENA_ERR_WARN_INT_ENA_Msk = 0x4
	// Bit ERR_WARN_INT_ENA.
	TWAI_INT_ENA_ERR_WARN_INT_ENA = 0x4
	// Position of OVERRUN_INT_ENA field.
	TWAI_INT_ENA_OVERRUN_INT_ENA_Pos = 0x3
	// Bit mask of OVERRUN_INT_ENA field.
	TWAI_INT_ENA_OVERRUN_INT_ENA_Msk = 0x8
	// Bit OVERRUN_INT_ENA.
	TWAI_INT_ENA_OVERRUN_INT_ENA = 0x8
	// Position of ERR_PASSIVE_INT_ENA field.
	TWAI_INT_ENA_ERR_PASSIVE_INT_ENA_Pos = 0x5
	// Bit mask of ERR_PASSIVE_INT_ENA field.
	TWAI_INT_ENA_ERR_PASSIVE_INT_ENA_Msk = 0x20
	// Bit ERR_PASSIVE_INT_ENA.
	TWAI_INT_ENA_ERR_PASSIVE_INT_ENA = 0x20
	// Position of ARB_LOST_INT_ENA field.
	TWAI_INT_ENA_ARB_LOST_INT_ENA_Pos = 0x6
	// Bit mask of ARB_LOST_INT_ENA field.
	TWAI_INT_ENA_ARB_LOST_INT_ENA_Msk = 0x40
	// Bit ARB_LOST_INT_ENA.
	TWAI_INT_ENA_ARB_LOST_INT_ENA = 0x40
	// Position of BUS_ERR_INT_ENA field.
	TWAI_INT_ENA_BUS_ERR_INT_ENA_Pos = 0x7
	// Bit mask of BUS_ERR_INT_ENA field.
	TWAI_INT_ENA_BUS_ERR_INT_ENA_Msk = 0x80
	// Bit BUS_ERR_INT_ENA.
	TWAI_INT_ENA_BUS_ERR_INT_ENA = 0x80

	// BUS_TIMING_0: Bus Timing Register 0
	// Position of BAUD_PRESC field.
	TWAI_BUS_TIMING_0_BAUD_PRESC_Pos = 0x0
	// Bit mask of BAUD_PRESC field.
	TWAI_BUS_TIMING_0_BAUD_PRESC_Msk = 0x3fff
	// Position of SYNC_JUMP_WIDTH field.
	TWAI_BUS_TIMING_0_SYNC_JUMP_WIDTH_Pos = 0xe
	// Bit mask of SYNC_JUMP_WIDTH field.
	TWAI_BUS_TIMING_0_SYNC_JUMP_WIDTH_Msk = 0xc000

	// BUS_TIMING_1: Bus Timing Register 1
	// Position of TIME_SEG1 field.
	TWAI_BUS_TIMING_1_TIME_SEG1_Pos = 0x0
	// Bit mask of TIME_SEG1 field.
	TWAI_BUS_TIMING_1_TIME_SEG1_Msk = 0xf
	// Position of TIME_SEG2 field.
	TWAI_BUS_TIMING_1_TIME_SEG2_Pos = 0x4
	// Bit mask of TIME_SEG2 field.
	TWAI_BUS_TIMING_1_TIME_SEG2_Msk = 0x70
	// Position of TIME_SAMP field.
	TWAI_BUS_TIMING_1_TIME_SAMP_Pos = 0x7
	// Bit mask of TIME_SAMP field.
	TWAI_BUS_TIMING_1_TIME_SAMP_Msk = 0x80
	// Bit TIME_SAMP.
	TWAI_BUS_TIMING_1_TIME_SAMP = 0x80

	// ARB_LOST_CAP: Arbitration Lost Capture Register
	// Position of ARB_LOST_CAP field.
	TWAI_ARB_LOST_CAP_ARB_LOST_CAP_Pos = 0x0
	// Bit mask of ARB_LOST_CAP field.
	TWAI_ARB_LOST_CAP_ARB_LOST_CAP_Msk = 0x1f

	// ERR_CODE_CAP: Error Code Capture Register
	// Position of ECC_SEGMENT field.
	TWAI_ERR_CODE_CAP_ECC_SEGMENT_Pos = 0x0
	// Bit mask of ECC_SEGMENT field.
	TWAI_ERR_CODE_CAP_ECC_SEGMENT_Msk = 0x1f
	// Position of ECC_DIRECTION field.
	TWAI_ERR_CODE_CAP_ECC_DIRECTION_Pos = 0x5
	// Bit mask of ECC_DIRECTION field.
	TWAI_ERR_CODE_CAP_ECC_DIRECTION_Msk = 0x20
	// Bit ECC_DIRECTION.
	TWAI_ERR_CODE_CAP_ECC_DIRECTION = 0x20
	// Position of ECC_TYPE field.
	TWAI_ERR_CODE_CAP_ECC_TYPE_Pos = 0x6
	// Bit mask of ECC_TYPE field.
	TWAI_ERR_CODE_CAP_ECC_TYPE_Msk = 0xc0

	// ERR_WARNING_LIMIT: Error Warning Limit Register
	// Position of ERR_WARNING_LIMIT field.
	TWAI_ERR_WARNING_LIMIT_ERR_WARNING_LIMIT_Pos = 0x0
	// Bit mask of ERR_WARNING_LIMIT field.
	TWAI_ERR_WARNING_LIMIT_ERR_WARNING_LIMIT_Msk = 0xff

	// RX_ERR_CNT: Receive Error Counter Register
	// Position of RX_ERR_CNT field.
	TWAI_RX_ERR_CNT_RX_ERR_CNT_Pos = 0x0
	// Bit mask of RX_ERR_CNT field.
	TWAI_RX_ERR_CNT_RX_ERR_CNT_Msk = 0xff

	// TX_ERR_CNT: Transmit Error Counter Register
	// Position of TX_ERR_CNT field.
	TWAI_TX_ERR_CNT_TX_ERR_CNT_Pos = 0x0
	// Bit mask of TX_ERR_CNT field.
	TWAI_TX_ERR_CNT_TX_ERR_CNT_Msk = 0xff

	// DATA_0: Data register 0
	// Position of TX_BYTE_0 field.
	TWAI_DATA_0_TX_BYTE_0_Pos = 0x0
	// Bit mask of TX_BYTE_0 field.
	TWAI_DATA_0_TX_BYTE_0_Msk = 0xff

	// DATA_1: Data register 1
	// Position of TX_BYTE_1 field.
	TWAI_DATA_1_TX_BYTE_1_Pos = 0x0
	// Bit mask of TX_BYTE_1 field.
	TWAI_DATA_1_TX_BYTE_1_Msk = 0xff

	// DATA_2: Data register 2
	// Position of TX_BYTE_2 field.
	TWAI_DATA_2_TX_BYTE_2_Pos = 0x0
	// Bit mask of TX_BYTE_2 field.
	TWAI_DATA_2_TX_BYTE_2_Msk = 0xff

	// DATA_3: Data register 3
	// Position of TX_BYTE_3 field.
	TWAI_DATA_3_TX_BYTE_3_Pos = 0x0
	// Bit mask of TX_BYTE_3 field.
	TWAI_DATA_3_TX_BYTE_3_Msk = 0xff

	// DATA_4: Data register 4
	// Position of TX_BYTE_4 field.
	TWAI_DATA_4_TX_BYTE_4_Pos = 0x0
	// Bit mask of TX_BYTE_4 field.
	TWAI_DATA_4_TX_BYTE_4_Msk = 0xff

	// DATA_5: Data register 5
	// Position of TX_BYTE_5 field.
	TWAI_DATA_5_TX_BYTE_5_Pos = 0x0
	// Bit mask of TX_BYTE_5 field.
	TWAI_DATA_5_TX_BYTE_5_Msk = 0xff

	// DATA_6: Data register 6
	// Position of TX_BYTE_6 field.
	TWAI_DATA_6_TX_BYTE_6_Pos = 0x0
	// Bit mask of TX_BYTE_6 field.
	TWAI_DATA_6_TX_BYTE_6_Msk = 0xff

	// DATA_7: Data register 7
	// Position of TX_BYTE_7 field.
	TWAI_DATA_7_TX_BYTE_7_Pos = 0x0
	// Bit mask of TX_BYTE_7 field.
	TWAI_DATA_7_TX_BYTE_7_Msk = 0xff

	// DATA_8: Data register 8
	// Position of TX_BYTE_8 field.
	TWAI_DATA_8_TX_BYTE_8_Pos = 0x0
	// Bit mask of TX_BYTE_8 field.
	TWAI_DATA_8_TX_BYTE_8_Msk = 0xff

	// DATA_9: Data register 9
	// Position of TX_BYTE_9 field.
	TWAI_DATA_9_TX_BYTE_9_Pos = 0x0
	// Bit mask of TX_BYTE_9 field.
	TWAI_DATA_9_TX_BYTE_9_Msk = 0xff

	// DATA_10: Data register 10
	// Position of TX_BYTE_10 field.
	TWAI_DATA_10_TX_BYTE_10_Pos = 0x0
	// Bit mask of TX_BYTE_10 field.
	TWAI_DATA_10_TX_BYTE_10_Msk = 0xff

	// DATA_11: Data register 11
	// Position of TX_BYTE_11 field.
	TWAI_DATA_11_TX_BYTE_11_Pos = 0x0
	// Bit mask of TX_BYTE_11 field.
	TWAI_DATA_11_TX_BYTE_11_Msk = 0xff

	// DATA_12: Data register 12
	// Position of TX_BYTE_12 field.
	TWAI_DATA_12_TX_BYTE_12_Pos = 0x0
	// Bit mask of TX_BYTE_12 field.
	TWAI_DATA_12_TX_BYTE_12_Msk = 0xff

	// RX_MESSAGE_CNT: Receive Message Counter Register
	// Position of RX_MESSAGE_COUNTER field.
	TWAI_RX_MESSAGE_CNT_RX_MESSAGE_COUNTER_Pos = 0x0
	// Bit mask of RX_MESSAGE_COUNTER field.
	TWAI_RX_MESSAGE_CNT_RX_MESSAGE_COUNTER_Msk = 0x7f

	// CLOCK_DIVIDER: Clock Divider register
	// Position of CD field.
	TWAI_CLOCK_DIVIDER_CD_Pos = 0x0
	// Bit mask of CD field.
	TWAI_CLOCK_DIVIDER_CD_Msk = 0xff
	// Position of CLOCK_OFF field.
	TWAI_CLOCK_DIVIDER_CLOCK_OFF_Pos = 0x8
	// Bit mask of CLOCK_OFF field.
	TWAI_CLOCK_DIVIDER_CLOCK_OFF_Msk = 0x100
	// Bit CLOCK_OFF.
	TWAI_CLOCK_DIVIDER_CLOCK_OFF = 0x100
)

// Constants for UART0: UART (Universal Asynchronous Receiver-Transmitter) Controller 0
const (
	// FIFO: FIFO data register
	// Position of RXFIFO_RD_BYTE field.
	UART_FIFO_RXFIFO_RD_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_RD_BYTE field.
	UART_FIFO_RXFIFO_RD_BYTE_Msk = 0xff

	// INT_RAW: Raw interrupt status
	// Position of RXFIFO_FULL_INT_RAW field.
	UART_INT_RAW_RXFIFO_FULL_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_RAW field.
	UART_INT_RAW_RXFIFO_FULL_INT_RAW_Msk = 0x1
	// Bit RXFIFO_FULL_INT_RAW.
	UART_INT_RAW_RXFIFO_FULL_INT_RAW = 0x1
	// Position of TXFIFO_EMPTY_INT_RAW field.
	UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_RAW field.
	UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_RAW.
	UART_INT_RAW_TXFIFO_EMPTY_INT_RAW = 0x2
	// Position of PARITY_ERR_INT_RAW field.
	UART_INT_RAW_PARITY_ERR_INT_RAW_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_RAW field.
	UART_INT_RAW_PARITY_ERR_INT_RAW_Msk = 0x4
	// Bit PARITY_ERR_INT_RAW.
	UART_INT_RAW_PARITY_ERR_INT_RAW = 0x4
	// Position of FRM_ERR_INT_RAW field.
	UART_INT_RAW_FRM_ERR_INT_RAW_Pos = 0x3
	// Bit mask of FRM_ERR_INT_RAW field.
	UART_INT_RAW_FRM_ERR_INT_RAW_Msk = 0x8
	// Bit FRM_ERR_INT_RAW.
	UART_INT_RAW_FRM_ERR_INT_RAW = 0x8
	// Position of RXFIFO_OVF_INT_RAW field.
	UART_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	UART_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x10
	// Bit RXFIFO_OVF_INT_RAW.
	UART_INT_RAW_RXFIFO_OVF_INT_RAW = 0x10
	// Position of DSR_CHG_INT_RAW field.
	UART_INT_RAW_DSR_CHG_INT_RAW_Pos = 0x5
	// Bit mask of DSR_CHG_INT_RAW field.
	UART_INT_RAW_DSR_CHG_INT_RAW_Msk = 0x20
	// Bit DSR_CHG_INT_RAW.
	UART_INT_RAW_DSR_CHG_INT_RAW = 0x20
	// Position of CTS_CHG_INT_RAW field.
	UART_INT_RAW_CTS_CHG_INT_RAW_Pos = 0x6
	// Bit mask of CTS_CHG_INT_RAW field.
	UART_INT_RAW_CTS_CHG_INT_RAW_Msk = 0x40
	// Bit CTS_CHG_INT_RAW.
	UART_INT_RAW_CTS_CHG_INT_RAW = 0x40
	// Position of BRK_DET_INT_RAW field.
	UART_INT_RAW_BRK_DET_INT_RAW_Pos = 0x7
	// Bit mask of BRK_DET_INT_RAW field.
	UART_INT_RAW_BRK_DET_INT_RAW_Msk = 0x80
	// Bit BRK_DET_INT_RAW.
	UART_INT_RAW_BRK_DET_INT_RAW = 0x80
	// Position of RXFIFO_TOUT_INT_RAW field.
	UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_RAW field.
	UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_RAW.
	UART_INT_RAW_RXFIFO_TOUT_INT_RAW = 0x100
	// Position of SW_XON_INT_RAW field.
	UART_INT_RAW_SW_XON_INT_RAW_Pos = 0x9
	// Bit mask of SW_XON_INT_RAW field.
	UART_INT_RAW_SW_XON_INT_RAW_Msk = 0x200
	// Bit SW_XON_INT_RAW.
	UART_INT_RAW_SW_XON_INT_RAW = 0x200
	// Position of SW_XOFF_INT_RAW field.
	UART_INT_RAW_SW_XOFF_INT_RAW_Pos = 0xa
	// Bit mask of SW_XOFF_INT_RAW field.
	UART_INT_RAW_SW_XOFF_INT_RAW_Msk = 0x400
	// Bit SW_XOFF_INT_RAW.
	UART_INT_RAW_SW_XOFF_INT_RAW = 0x400
	// Position of GLITCH_DET_INT_RAW field.
	UART_INT_RAW_GLITCH_DET_INT_RAW_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_RAW field.
	UART_INT_RAW_GLITCH_DET_INT_RAW_Msk = 0x800
	// Bit GLITCH_DET_INT_RAW.
	UART_INT_RAW_GLITCH_DET_INT_RAW = 0x800
	// Position of TX_BRK_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_DONE_INT_RAW_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_DONE_INT_RAW_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_RAW.
	UART_INT_RAW_TX_BRK_DONE_INT_RAW = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_RAW field.
	UART_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_RAW.
	UART_INT_RAW_TX_BRK_IDLE_DONE_INT_RAW = 0x2000
	// Position of TX_DONE_INT_RAW field.
	UART_INT_RAW_TX_DONE_INT_RAW_Pos = 0xe
	// Bit mask of TX_DONE_INT_RAW field.
	UART_INT_RAW_TX_DONE_INT_RAW_Msk = 0x4000
	// Bit TX_DONE_INT_RAW.
	UART_INT_RAW_TX_DONE_INT_RAW = 0x4000
	// Position of RS485_PARITY_ERR_INT_RAW field.
	UART_INT_RAW_RS485_PARITY_ERR_INT_RAW_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_RAW field.
	UART_INT_RAW_RS485_PARITY_ERR_INT_RAW_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_RAW.
	UART_INT_RAW_RS485_PARITY_ERR_INT_RAW = 0x8000
	// Position of RS485_FRM_ERR_INT_RAW field.
	UART_INT_RAW_RS485_FRM_ERR_INT_RAW_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_RAW field.
	UART_INT_RAW_RS485_FRM_ERR_INT_RAW_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_RAW.
	UART_INT_RAW_RS485_FRM_ERR_INT_RAW = 0x10000
	// Position of RS485_CLASH_INT_RAW field.
	UART_INT_RAW_RS485_CLASH_INT_RAW_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_RAW field.
	UART_INT_RAW_RS485_CLASH_INT_RAW_Msk = 0x20000
	// Bit RS485_CLASH_INT_RAW.
	UART_INT_RAW_RS485_CLASH_INT_RAW = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_RAW field.
	UART_INT_RAW_AT_CMD_CHAR_DET_INT_RAW_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_RAW field.
	UART_INT_RAW_AT_CMD_CHAR_DET_INT_RAW_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_RAW.
	UART_INT_RAW_AT_CMD_CHAR_DET_INT_RAW = 0x40000
	// Position of WAKEUP_INT_RAW field.
	UART_INT_RAW_WAKEUP_INT_RAW_Pos = 0x13
	// Bit mask of WAKEUP_INT_RAW field.
	UART_INT_RAW_WAKEUP_INT_RAW_Msk = 0x80000
	// Bit WAKEUP_INT_RAW.
	UART_INT_RAW_WAKEUP_INT_RAW = 0x80000

	// INT_ST: Masked interrupt status
	// Position of RXFIFO_FULL_INT_ST field.
	UART_INT_ST_RXFIFO_FULL_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ST field.
	UART_INT_ST_RXFIFO_FULL_INT_ST_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ST.
	UART_INT_ST_RXFIFO_FULL_INT_ST = 0x1
	// Position of TXFIFO_EMPTY_INT_ST field.
	UART_INT_ST_TXFIFO_EMPTY_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ST field.
	UART_INT_ST_TXFIFO_EMPTY_INT_ST_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ST.
	UART_INT_ST_TXFIFO_EMPTY_INT_ST = 0x2
	// Position of PARITY_ERR_INT_ST field.
	UART_INT_ST_PARITY_ERR_INT_ST_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ST field.
	UART_INT_ST_PARITY_ERR_INT_ST_Msk = 0x4
	// Bit PARITY_ERR_INT_ST.
	UART_INT_ST_PARITY_ERR_INT_ST = 0x4
	// Position of FRM_ERR_INT_ST field.
	UART_INT_ST_FRM_ERR_INT_ST_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ST field.
	UART_INT_ST_FRM_ERR_INT_ST_Msk = 0x8
	// Bit FRM_ERR_INT_ST.
	UART_INT_ST_FRM_ERR_INT_ST = 0x8
	// Position of RXFIFO_OVF_INT_ST field.
	UART_INT_ST_RXFIFO_OVF_INT_ST_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ST field.
	UART_INT_ST_RXFIFO_OVF_INT_ST_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ST.
	UART_INT_ST_RXFIFO_OVF_INT_ST = 0x10
	// Position of DSR_CHG_INT_ST field.
	UART_INT_ST_DSR_CHG_INT_ST_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ST field.
	UART_INT_ST_DSR_CHG_INT_ST_Msk = 0x20
	// Bit DSR_CHG_INT_ST.
	UART_INT_ST_DSR_CHG_INT_ST = 0x20
	// Position of CTS_CHG_INT_ST field.
	UART_INT_ST_CTS_CHG_INT_ST_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ST field.
	UART_INT_ST_CTS_CHG_INT_ST_Msk = 0x40
	// Bit CTS_CHG_INT_ST.
	UART_INT_ST_CTS_CHG_INT_ST = 0x40
	// Position of BRK_DET_INT_ST field.
	UART_INT_ST_BRK_DET_INT_ST_Pos = 0x7
	// Bit mask of BRK_DET_INT_ST field.
	UART_INT_ST_BRK_DET_INT_ST_Msk = 0x80
	// Bit BRK_DET_INT_ST.
	UART_INT_ST_BRK_DET_INT_ST = 0x80
	// Position of RXFIFO_TOUT_INT_ST field.
	UART_INT_ST_RXFIFO_TOUT_INT_ST_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ST field.
	UART_INT_ST_RXFIFO_TOUT_INT_ST_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ST.
	UART_INT_ST_RXFIFO_TOUT_INT_ST = 0x100
	// Position of SW_XON_INT_ST field.
	UART_INT_ST_SW_XON_INT_ST_Pos = 0x9
	// Bit mask of SW_XON_INT_ST field.
	UART_INT_ST_SW_XON_INT_ST_Msk = 0x200
	// Bit SW_XON_INT_ST.
	UART_INT_ST_SW_XON_INT_ST = 0x200
	// Position of SW_XOFF_INT_ST field.
	UART_INT_ST_SW_XOFF_INT_ST_Pos = 0xa
	// Bit mask of SW_XOFF_INT_ST field.
	UART_INT_ST_SW_XOFF_INT_ST_Msk = 0x400
	// Bit SW_XOFF_INT_ST.
	UART_INT_ST_SW_XOFF_INT_ST = 0x400
	// Position of GLITCH_DET_INT_ST field.
	UART_INT_ST_GLITCH_DET_INT_ST_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_ST field.
	UART_INT_ST_GLITCH_DET_INT_ST_Msk = 0x800
	// Bit GLITCH_DET_INT_ST.
	UART_INT_ST_GLITCH_DET_INT_ST = 0x800
	// Position of TX_BRK_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_DONE_INT_ST_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_DONE_INT_ST_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_ST.
	UART_INT_ST_TX_BRK_DONE_INT_ST = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_IDLE_DONE_INT_ST_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_ST field.
	UART_INT_ST_TX_BRK_IDLE_DONE_INT_ST_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_ST.
	UART_INT_ST_TX_BRK_IDLE_DONE_INT_ST = 0x2000
	// Position of TX_DONE_INT_ST field.
	UART_INT_ST_TX_DONE_INT_ST_Pos = 0xe
	// Bit mask of TX_DONE_INT_ST field.
	UART_INT_ST_TX_DONE_INT_ST_Msk = 0x4000
	// Bit TX_DONE_INT_ST.
	UART_INT_ST_TX_DONE_INT_ST = 0x4000
	// Position of RS485_PARITY_ERR_INT_ST field.
	UART_INT_ST_RS485_PARITY_ERR_INT_ST_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_ST field.
	UART_INT_ST_RS485_PARITY_ERR_INT_ST_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_ST.
	UART_INT_ST_RS485_PARITY_ERR_INT_ST = 0x8000
	// Position of RS485_FRM_ERR_INT_ST field.
	UART_INT_ST_RS485_FRM_ERR_INT_ST_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_ST field.
	UART_INT_ST_RS485_FRM_ERR_INT_ST_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_ST.
	UART_INT_ST_RS485_FRM_ERR_INT_ST = 0x10000
	// Position of RS485_CLASH_INT_ST field.
	UART_INT_ST_RS485_CLASH_INT_ST_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_ST field.
	UART_INT_ST_RS485_CLASH_INT_ST_Msk = 0x20000
	// Bit RS485_CLASH_INT_ST.
	UART_INT_ST_RS485_CLASH_INT_ST = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_ST field.
	UART_INT_ST_AT_CMD_CHAR_DET_INT_ST_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_ST field.
	UART_INT_ST_AT_CMD_CHAR_DET_INT_ST_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_ST.
	UART_INT_ST_AT_CMD_CHAR_DET_INT_ST = 0x40000
	// Position of WAKEUP_INT_ST field.
	UART_INT_ST_WAKEUP_INT_ST_Pos = 0x13
	// Bit mask of WAKEUP_INT_ST field.
	UART_INT_ST_WAKEUP_INT_ST_Msk = 0x80000
	// Bit WAKEUP_INT_ST.
	UART_INT_ST_WAKEUP_INT_ST = 0x80000

	// INT_ENA: Interrupt enable bits
	// Position of RXFIFO_FULL_INT_ENA field.
	UART_INT_ENA_RXFIFO_FULL_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ENA field.
	UART_INT_ENA_RXFIFO_FULL_INT_ENA_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ENA.
	UART_INT_ENA_RXFIFO_FULL_INT_ENA = 0x1
	// Position of TXFIFO_EMPTY_INT_ENA field.
	UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ENA field.
	UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ENA.
	UART_INT_ENA_TXFIFO_EMPTY_INT_ENA = 0x2
	// Position of PARITY_ERR_INT_ENA field.
	UART_INT_ENA_PARITY_ERR_INT_ENA_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ENA field.
	UART_INT_ENA_PARITY_ERR_INT_ENA_Msk = 0x4
	// Bit PARITY_ERR_INT_ENA.
	UART_INT_ENA_PARITY_ERR_INT_ENA = 0x4
	// Position of FRM_ERR_INT_ENA field.
	UART_INT_ENA_FRM_ERR_INT_ENA_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ENA field.
	UART_INT_ENA_FRM_ERR_INT_ENA_Msk = 0x8
	// Bit FRM_ERR_INT_ENA.
	UART_INT_ENA_FRM_ERR_INT_ENA = 0x8
	// Position of RXFIFO_OVF_INT_ENA field.
	UART_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	UART_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ENA.
	UART_INT_ENA_RXFIFO_OVF_INT_ENA = 0x10
	// Position of DSR_CHG_INT_ENA field.
	UART_INT_ENA_DSR_CHG_INT_ENA_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ENA field.
	UART_INT_ENA_DSR_CHG_INT_ENA_Msk = 0x20
	// Bit DSR_CHG_INT_ENA.
	UART_INT_ENA_DSR_CHG_INT_ENA = 0x20
	// Position of CTS_CHG_INT_ENA field.
	UART_INT_ENA_CTS_CHG_INT_ENA_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ENA field.
	UART_INT_ENA_CTS_CHG_INT_ENA_Msk = 0x40
	// Bit CTS_CHG_INT_ENA.
	UART_INT_ENA_CTS_CHG_INT_ENA = 0x40
	// Position of BRK_DET_INT_ENA field.
	UART_INT_ENA_BRK_DET_INT_ENA_Pos = 0x7
	// Bit mask of BRK_DET_INT_ENA field.
	UART_INT_ENA_BRK_DET_INT_ENA_Msk = 0x80
	// Bit BRK_DET_INT_ENA.
	UART_INT_ENA_BRK_DET_INT_ENA = 0x80
	// Position of RXFIFO_TOUT_INT_ENA field.
	UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ENA field.
	UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ENA.
	UART_INT_ENA_RXFIFO_TOUT_INT_ENA = 0x100
	// Position of SW_XON_INT_ENA field.
	UART_INT_ENA_SW_XON_INT_ENA_Pos = 0x9
	// Bit mask of SW_XON_INT_ENA field.
	UART_INT_ENA_SW_XON_INT_ENA_Msk = 0x200
	// Bit SW_XON_INT_ENA.
	UART_INT_ENA_SW_XON_INT_ENA = 0x200
	// Position of SW_XOFF_INT_ENA field.
	UART_INT_ENA_SW_XOFF_INT_ENA_Pos = 0xa
	// Bit mask of SW_XOFF_INT_ENA field.
	UART_INT_ENA_SW_XOFF_INT_ENA_Msk = 0x400
	// Bit SW_XOFF_INT_ENA.
	UART_INT_ENA_SW_XOFF_INT_ENA = 0x400
	// Position of GLITCH_DET_INT_ENA field.
	UART_INT_ENA_GLITCH_DET_INT_ENA_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_ENA field.
	UART_INT_ENA_GLITCH_DET_INT_ENA_Msk = 0x800
	// Bit GLITCH_DET_INT_ENA.
	UART_INT_ENA_GLITCH_DET_INT_ENA = 0x800
	// Position of TX_BRK_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_DONE_INT_ENA_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_DONE_INT_ENA_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_ENA.
	UART_INT_ENA_TX_BRK_DONE_INT_ENA = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_ENA field.
	UART_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_ENA.
	UART_INT_ENA_TX_BRK_IDLE_DONE_INT_ENA = 0x2000
	// Position of TX_DONE_INT_ENA field.
	UART_INT_ENA_TX_DONE_INT_ENA_Pos = 0xe
	// Bit mask of TX_DONE_INT_ENA field.
	UART_INT_ENA_TX_DONE_INT_ENA_Msk = 0x4000
	// Bit TX_DONE_INT_ENA.
	UART_INT_ENA_TX_DONE_INT_ENA = 0x4000
	// Position of RS485_PARITY_ERR_INT_ENA field.
	UART_INT_ENA_RS485_PARITY_ERR_INT_ENA_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_ENA field.
	UART_INT_ENA_RS485_PARITY_ERR_INT_ENA_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_ENA.
	UART_INT_ENA_RS485_PARITY_ERR_INT_ENA = 0x8000
	// Position of RS485_FRM_ERR_INT_ENA field.
	UART_INT_ENA_RS485_FRM_ERR_INT_ENA_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_ENA field.
	UART_INT_ENA_RS485_FRM_ERR_INT_ENA_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_ENA.
	UART_INT_ENA_RS485_FRM_ERR_INT_ENA = 0x10000
	// Position of RS485_CLASH_INT_ENA field.
	UART_INT_ENA_RS485_CLASH_INT_ENA_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_ENA field.
	UART_INT_ENA_RS485_CLASH_INT_ENA_Msk = 0x20000
	// Bit RS485_CLASH_INT_ENA.
	UART_INT_ENA_RS485_CLASH_INT_ENA = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_ENA field.
	UART_INT_ENA_AT_CMD_CHAR_DET_INT_ENA_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_ENA field.
	UART_INT_ENA_AT_CMD_CHAR_DET_INT_ENA_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_ENA.
	UART_INT_ENA_AT_CMD_CHAR_DET_INT_ENA = 0x40000
	// Position of WAKEUP_INT_ENA field.
	UART_INT_ENA_WAKEUP_INT_ENA_Pos = 0x13
	// Bit mask of WAKEUP_INT_ENA field.
	UART_INT_ENA_WAKEUP_INT_ENA_Msk = 0x80000
	// Bit WAKEUP_INT_ENA.
	UART_INT_ENA_WAKEUP_INT_ENA = 0x80000

	// INT_CLR: Interrupt clear bits
	// Position of RXFIFO_FULL_INT_CLR field.
	UART_INT_CLR_RXFIFO_FULL_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_CLR field.
	UART_INT_CLR_RXFIFO_FULL_INT_CLR_Msk = 0x1
	// Bit RXFIFO_FULL_INT_CLR.
	UART_INT_CLR_RXFIFO_FULL_INT_CLR = 0x1
	// Position of TXFIFO_EMPTY_INT_CLR field.
	UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_CLR field.
	UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_CLR.
	UART_INT_CLR_TXFIFO_EMPTY_INT_CLR = 0x2
	// Position of PARITY_ERR_INT_CLR field.
	UART_INT_CLR_PARITY_ERR_INT_CLR_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_CLR field.
	UART_INT_CLR_PARITY_ERR_INT_CLR_Msk = 0x4
	// Bit PARITY_ERR_INT_CLR.
	UART_INT_CLR_PARITY_ERR_INT_CLR = 0x4
	// Position of FRM_ERR_INT_CLR field.
	UART_INT_CLR_FRM_ERR_INT_CLR_Pos = 0x3
	// Bit mask of FRM_ERR_INT_CLR field.
	UART_INT_CLR_FRM_ERR_INT_CLR_Msk = 0x8
	// Bit FRM_ERR_INT_CLR.
	UART_INT_CLR_FRM_ERR_INT_CLR = 0x8
	// Position of RXFIFO_OVF_INT_CLR field.
	UART_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	UART_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x10
	// Bit RXFIFO_OVF_INT_CLR.
	UART_INT_CLR_RXFIFO_OVF_INT_CLR = 0x10
	// Position of DSR_CHG_INT_CLR field.
	UART_INT_CLR_DSR_CHG_INT_CLR_Pos = 0x5
	// Bit mask of DSR_CHG_INT_CLR field.
	UART_INT_CLR_DSR_CHG_INT_CLR_Msk = 0x20
	// Bit DSR_CHG_INT_CLR.
	UART_INT_CLR_DSR_CHG_INT_CLR = 0x20
	// Position of CTS_CHG_INT_CLR field.
	UART_INT_CLR_CTS_CHG_INT_CLR_Pos = 0x6
	// Bit mask of CTS_CHG_INT_CLR field.
	UART_INT_CLR_CTS_CHG_INT_CLR_Msk = 0x40
	// Bit CTS_CHG_INT_CLR.
	UART_INT_CLR_CTS_CHG_INT_CLR = 0x40
	// Position of BRK_DET_INT_CLR field.
	UART_INT_CLR_BRK_DET_INT_CLR_Pos = 0x7
	// Bit mask of BRK_DET_INT_CLR field.
	UART_INT_CLR_BRK_DET_INT_CLR_Msk = 0x80
	// Bit BRK_DET_INT_CLR.
	UART_INT_CLR_BRK_DET_INT_CLR = 0x80
	// Position of RXFIFO_TOUT_INT_CLR field.
	UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_CLR field.
	UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_CLR.
	UART_INT_CLR_RXFIFO_TOUT_INT_CLR = 0x100
	// Position of SW_XON_INT_CLR field.
	UART_INT_CLR_SW_XON_INT_CLR_Pos = 0x9
	// Bit mask of SW_XON_INT_CLR field.
	UART_INT_CLR_SW_XON_INT_CLR_Msk = 0x200
	// Bit SW_XON_INT_CLR.
	UART_INT_CLR_SW_XON_INT_CLR = 0x200
	// Position of SW_XOFF_INT_CLR field.
	UART_INT_CLR_SW_XOFF_INT_CLR_Pos = 0xa
	// Bit mask of SW_XOFF_INT_CLR field.
	UART_INT_CLR_SW_XOFF_INT_CLR_Msk = 0x400
	// Bit SW_XOFF_INT_CLR.
	UART_INT_CLR_SW_XOFF_INT_CLR = 0x400
	// Position of GLITCH_DET_INT_CLR field.
	UART_INT_CLR_GLITCH_DET_INT_CLR_Pos = 0xb
	// Bit mask of GLITCH_DET_INT_CLR field.
	UART_INT_CLR_GLITCH_DET_INT_CLR_Msk = 0x800
	// Bit GLITCH_DET_INT_CLR.
	UART_INT_CLR_GLITCH_DET_INT_CLR = 0x800
	// Position of TX_BRK_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_DONE_INT_CLR_Pos = 0xc
	// Bit mask of TX_BRK_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_DONE_INT_CLR_Msk = 0x1000
	// Bit TX_BRK_DONE_INT_CLR.
	UART_INT_CLR_TX_BRK_DONE_INT_CLR = 0x1000
	// Position of TX_BRK_IDLE_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR_Pos = 0xd
	// Bit mask of TX_BRK_IDLE_DONE_INT_CLR field.
	UART_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR_Msk = 0x2000
	// Bit TX_BRK_IDLE_DONE_INT_CLR.
	UART_INT_CLR_TX_BRK_IDLE_DONE_INT_CLR = 0x2000
	// Position of TX_DONE_INT_CLR field.
	UART_INT_CLR_TX_DONE_INT_CLR_Pos = 0xe
	// Bit mask of TX_DONE_INT_CLR field.
	UART_INT_CLR_TX_DONE_INT_CLR_Msk = 0x4000
	// Bit TX_DONE_INT_CLR.
	UART_INT_CLR_TX_DONE_INT_CLR = 0x4000
	// Position of RS485_PARITY_ERR_INT_CLR field.
	UART_INT_CLR_RS485_PARITY_ERR_INT_CLR_Pos = 0xf
	// Bit mask of RS485_PARITY_ERR_INT_CLR field.
	UART_INT_CLR_RS485_PARITY_ERR_INT_CLR_Msk = 0x8000
	// Bit RS485_PARITY_ERR_INT_CLR.
	UART_INT_CLR_RS485_PARITY_ERR_INT_CLR = 0x8000
	// Position of RS485_FRM_ERR_INT_CLR field.
	UART_INT_CLR_RS485_FRM_ERR_INT_CLR_Pos = 0x10
	// Bit mask of RS485_FRM_ERR_INT_CLR field.
	UART_INT_CLR_RS485_FRM_ERR_INT_CLR_Msk = 0x10000
	// Bit RS485_FRM_ERR_INT_CLR.
	UART_INT_CLR_RS485_FRM_ERR_INT_CLR = 0x10000
	// Position of RS485_CLASH_INT_CLR field.
	UART_INT_CLR_RS485_CLASH_INT_CLR_Pos = 0x11
	// Bit mask of RS485_CLASH_INT_CLR field.
	UART_INT_CLR_RS485_CLASH_INT_CLR_Msk = 0x20000
	// Bit RS485_CLASH_INT_CLR.
	UART_INT_CLR_RS485_CLASH_INT_CLR = 0x20000
	// Position of AT_CMD_CHAR_DET_INT_CLR field.
	UART_INT_CLR_AT_CMD_CHAR_DET_INT_CLR_Pos = 0x12
	// Bit mask of AT_CMD_CHAR_DET_INT_CLR field.
	UART_INT_CLR_AT_CMD_CHAR_DET_INT_CLR_Msk = 0x40000
	// Bit AT_CMD_CHAR_DET_INT_CLR.
	UART_INT_CLR_AT_CMD_CHAR_DET_INT_CLR = 0x40000
	// Position of WAKEUP_INT_CLR field.
	UART_INT_CLR_WAKEUP_INT_CLR_Pos = 0x13
	// Bit mask of WAKEUP_INT_CLR field.
	UART_INT_CLR_WAKEUP_INT_CLR_Msk = 0x80000
	// Bit WAKEUP_INT_CLR.
	UART_INT_CLR_WAKEUP_INT_CLR = 0x80000

	// CLKDIV: Clock divider configuration
	// Position of CLKDIV field.
	UART_CLKDIV_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	UART_CLKDIV_CLKDIV_Msk = 0xfffff
	// Position of FRAG field.
	UART_CLKDIV_FRAG_Pos = 0x14
	// Bit mask of FRAG field.
	UART_CLKDIV_FRAG_Msk = 0xf00000

	// AUTOBAUD: Autobaud configuration register
	// Position of EN field.
	UART_AUTOBAUD_EN_Pos = 0x0
	// Bit mask of EN field.
	UART_AUTOBAUD_EN_Msk = 0x1
	// Bit EN.
	UART_AUTOBAUD_EN = 0x1
	// Position of GLITCH_FILT field.
	UART_AUTOBAUD_GLITCH_FILT_Pos = 0x8
	// Bit mask of GLITCH_FILT field.
	UART_AUTOBAUD_GLITCH_FILT_Msk = 0xff00

	// STATUS: UART status register
	// Position of RXFIFO_CNT field.
	UART_STATUS_RXFIFO_CNT_Pos = 0x0
	// Bit mask of RXFIFO_CNT field.
	UART_STATUS_RXFIFO_CNT_Msk = 0x3ff
	// Position of DSRN field.
	UART_STATUS_DSRN_Pos = 0xd
	// Bit mask of DSRN field.
	UART_STATUS_DSRN_Msk = 0x2000
	// Bit DSRN.
	UART_STATUS_DSRN = 0x2000
	// Position of CTSN field.
	UART_STATUS_CTSN_Pos = 0xe
	// Bit mask of CTSN field.
	UART_STATUS_CTSN_Msk = 0x4000
	// Bit CTSN.
	UART_STATUS_CTSN = 0x4000
	// Position of RXD field.
	UART_STATUS_RXD_Pos = 0xf
	// Bit mask of RXD field.
	UART_STATUS_RXD_Msk = 0x8000
	// Bit RXD.
	UART_STATUS_RXD = 0x8000
	// Position of TXFIFO_CNT field.
	UART_STATUS_TXFIFO_CNT_Pos = 0x10
	// Bit mask of TXFIFO_CNT field.
	UART_STATUS_TXFIFO_CNT_Msk = 0x3ff0000
	// Position of DTRN field.
	UART_STATUS_DTRN_Pos = 0x1d
	// Bit mask of DTRN field.
	UART_STATUS_DTRN_Msk = 0x20000000
	// Bit DTRN.
	UART_STATUS_DTRN = 0x20000000
	// Position of RTSN field.
	UART_STATUS_RTSN_Pos = 0x1e
	// Bit mask of RTSN field.
	UART_STATUS_RTSN_Msk = 0x40000000
	// Bit RTSN.
	UART_STATUS_RTSN = 0x40000000
	// Position of TXD field.
	UART_STATUS_TXD_Pos = 0x1f
	// Bit mask of TXD field.
	UART_STATUS_TXD_Msk = 0x80000000
	// Bit TXD.
	UART_STATUS_TXD = 0x80000000

	// CONF0: Configuration register 0
	// Position of PARITY field.
	UART_CONF0_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	UART_CONF0_PARITY_Msk = 0x1
	// Bit PARITY.
	UART_CONF0_PARITY = 0x1
	// Position of PARITY_EN field.
	UART_CONF0_PARITY_EN_Pos = 0x1
	// Bit mask of PARITY_EN field.
	UART_CONF0_PARITY_EN_Msk = 0x2
	// Bit PARITY_EN.
	UART_CONF0_PARITY_EN = 0x2
	// Position of BIT_NUM field.
	UART_CONF0_BIT_NUM_Pos = 0x2
	// Bit mask of BIT_NUM field.
	UART_CONF0_BIT_NUM_Msk = 0xc
	// Position of STOP_BIT_NUM field.
	UART_CONF0_STOP_BIT_NUM_Pos = 0x4
	// Bit mask of STOP_BIT_NUM field.
	UART_CONF0_STOP_BIT_NUM_Msk = 0x30
	// Position of SW_RTS field.
	UART_CONF0_SW_RTS_Pos = 0x6
	// Bit mask of SW_RTS field.
	UART_CONF0_SW_RTS_Msk = 0x40
	// Bit SW_RTS.
	UART_CONF0_SW_RTS = 0x40
	// Position of SW_DTR field.
	UART_CONF0_SW_DTR_Pos = 0x7
	// Bit mask of SW_DTR field.
	UART_CONF0_SW_DTR_Msk = 0x80
	// Bit SW_DTR.
	UART_CONF0_SW_DTR = 0x80
	// Position of TXD_BRK field.
	UART_CONF0_TXD_BRK_Pos = 0x8
	// Bit mask of TXD_BRK field.
	UART_CONF0_TXD_BRK_Msk = 0x100
	// Bit TXD_BRK.
	UART_CONF0_TXD_BRK = 0x100
	// Position of IRDA_DPLX field.
	UART_CONF0_IRDA_DPLX_Pos = 0x9
	// Bit mask of IRDA_DPLX field.
	UART_CONF0_IRDA_DPLX_Msk = 0x200
	// Bit IRDA_DPLX.
	UART_CONF0_IRDA_DPLX = 0x200
	// Position of IRDA_TX_EN field.
	UART_CONF0_IRDA_TX_EN_Pos = 0xa
	// Bit mask of IRDA_TX_EN field.
	UART_CONF0_IRDA_TX_EN_Msk = 0x400
	// Bit IRDA_TX_EN.
	UART_CONF0_IRDA_TX_EN = 0x400
	// Position of IRDA_WCTL field.
	UART_CONF0_IRDA_WCTL_Pos = 0xb
	// Bit mask of IRDA_WCTL field.
	UART_CONF0_IRDA_WCTL_Msk = 0x800
	// Bit IRDA_WCTL.
	UART_CONF0_IRDA_WCTL = 0x800
	// Position of IRDA_TX_INV field.
	UART_CONF0_IRDA_TX_INV_Pos = 0xc
	// Bit mask of IRDA_TX_INV field.
	UART_CONF0_IRDA_TX_INV_Msk = 0x1000
	// Bit IRDA_TX_INV.
	UART_CONF0_IRDA_TX_INV = 0x1000
	// Position of IRDA_RX_INV field.
	UART_CONF0_IRDA_RX_INV_Pos = 0xd
	// Bit mask of IRDA_RX_INV field.
	UART_CONF0_IRDA_RX_INV_Msk = 0x2000
	// Bit IRDA_RX_INV.
	UART_CONF0_IRDA_RX_INV = 0x2000
	// Position of LOOPBACK field.
	UART_CONF0_LOOPBACK_Pos = 0xe
	// Bit mask of LOOPBACK field.
	UART_CONF0_LOOPBACK_Msk = 0x4000
	// Bit LOOPBACK.
	UART_CONF0_LOOPBACK = 0x4000
	// Position of TX_FLOW_EN field.
	UART_CONF0_TX_FLOW_EN_Pos = 0xf
	// Bit mask of TX_FLOW_EN field.
	UART_CONF0_TX_FLOW_EN_Msk = 0x8000
	// Bit TX_FLOW_EN.
	UART_CONF0_TX_FLOW_EN = 0x8000
	// Position of IRDA_EN field.
	UART_CONF0_IRDA_EN_Pos = 0x10
	// Bit mask of IRDA_EN field.
	UART_CONF0_IRDA_EN_Msk = 0x10000
	// Bit IRDA_EN.
	UART_CONF0_IRDA_EN = 0x10000
	// Position of RXFIFO_RST field.
	UART_CONF0_RXFIFO_RST_Pos = 0x11
	// Bit mask of RXFIFO_RST field.
	UART_CONF0_RXFIFO_RST_Msk = 0x20000
	// Bit RXFIFO_RST.
	UART_CONF0_RXFIFO_RST = 0x20000
	// Position of TXFIFO_RST field.
	UART_CONF0_TXFIFO_RST_Pos = 0x12
	// Bit mask of TXFIFO_RST field.
	UART_CONF0_TXFIFO_RST_Msk = 0x40000
	// Bit TXFIFO_RST.
	UART_CONF0_TXFIFO_RST = 0x40000
	// Position of RXD_INV field.
	UART_CONF0_RXD_INV_Pos = 0x13
	// Bit mask of RXD_INV field.
	UART_CONF0_RXD_INV_Msk = 0x80000
	// Bit RXD_INV.
	UART_CONF0_RXD_INV = 0x80000
	// Position of CTS_INV field.
	UART_CONF0_CTS_INV_Pos = 0x14
	// Bit mask of CTS_INV field.
	UART_CONF0_CTS_INV_Msk = 0x100000
	// Bit CTS_INV.
	UART_CONF0_CTS_INV = 0x100000
	// Position of DSR_INV field.
	UART_CONF0_DSR_INV_Pos = 0x15
	// Bit mask of DSR_INV field.
	UART_CONF0_DSR_INV_Msk = 0x200000
	// Bit DSR_INV.
	UART_CONF0_DSR_INV = 0x200000
	// Position of TXD_INV field.
	UART_CONF0_TXD_INV_Pos = 0x16
	// Bit mask of TXD_INV field.
	UART_CONF0_TXD_INV_Msk = 0x400000
	// Bit TXD_INV.
	UART_CONF0_TXD_INV = 0x400000
	// Position of RTS_INV field.
	UART_CONF0_RTS_INV_Pos = 0x17
	// Bit mask of RTS_INV field.
	UART_CONF0_RTS_INV_Msk = 0x800000
	// Bit RTS_INV.
	UART_CONF0_RTS_INV = 0x800000
	// Position of DTR_INV field.
	UART_CONF0_DTR_INV_Pos = 0x18
	// Bit mask of DTR_INV field.
	UART_CONF0_DTR_INV_Msk = 0x1000000
	// Bit DTR_INV.
	UART_CONF0_DTR_INV = 0x1000000
	// Position of CLK_EN field.
	UART_CONF0_CLK_EN_Pos = 0x19
	// Bit mask of CLK_EN field.
	UART_CONF0_CLK_EN_Msk = 0x2000000
	// Bit CLK_EN.
	UART_CONF0_CLK_EN = 0x2000000
	// Position of ERR_WR_MASK field.
	UART_CONF0_ERR_WR_MASK_Pos = 0x1a
	// Bit mask of ERR_WR_MASK field.
	UART_CONF0_ERR_WR_MASK_Msk = 0x4000000
	// Bit ERR_WR_MASK.
	UART_CONF0_ERR_WR_MASK = 0x4000000
	// Position of TICK_REF_ALWAYS_ON field.
	UART_CONF0_TICK_REF_ALWAYS_ON_Pos = 0x1b
	// Bit mask of TICK_REF_ALWAYS_ON field.
	UART_CONF0_TICK_REF_ALWAYS_ON_Msk = 0x8000000
	// Bit TICK_REF_ALWAYS_ON.
	UART_CONF0_TICK_REF_ALWAYS_ON = 0x8000000
	// Position of MEM_CLK_EN field.
	UART_CONF0_MEM_CLK_EN_Pos = 0x1c
	// Bit mask of MEM_CLK_EN field.
	UART_CONF0_MEM_CLK_EN_Msk = 0x10000000
	// Bit MEM_CLK_EN.
	UART_CONF0_MEM_CLK_EN = 0x10000000

	// CONF1: Configuration register 1
	// Position of RXFIFO_FULL_THRHD field.
	UART_CONF1_RXFIFO_FULL_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_FULL_THRHD field.
	UART_CONF1_RXFIFO_FULL_THRHD_Msk = 0x1ff
	// Position of TXFIFO_EMPTY_THRHD field.
	UART_CONF1_TXFIFO_EMPTY_THRHD_Pos = 0x9
	// Bit mask of TXFIFO_EMPTY_THRHD field.
	UART_CONF1_TXFIFO_EMPTY_THRHD_Msk = 0x3fe00
	// Position of RX_TOUT_FLOW_DIS field.
	UART_CONF1_RX_TOUT_FLOW_DIS_Pos = 0x1d
	// Bit mask of RX_TOUT_FLOW_DIS field.
	UART_CONF1_RX_TOUT_FLOW_DIS_Msk = 0x20000000
	// Bit RX_TOUT_FLOW_DIS.
	UART_CONF1_RX_TOUT_FLOW_DIS = 0x20000000
	// Position of RX_FLOW_EN field.
	UART_CONF1_RX_FLOW_EN_Pos = 0x1e
	// Bit mask of RX_FLOW_EN field.
	UART_CONF1_RX_FLOW_EN_Msk = 0x40000000
	// Bit RX_FLOW_EN.
	UART_CONF1_RX_FLOW_EN = 0x40000000
	// Position of RX_TOUT_EN field.
	UART_CONF1_RX_TOUT_EN_Pos = 0x1f
	// Bit mask of RX_TOUT_EN field.
	UART_CONF1_RX_TOUT_EN_Msk = 0x80000000
	// Bit RX_TOUT_EN.
	UART_CONF1_RX_TOUT_EN = 0x80000000

	// LOWPULSE: Autobaud minimum low pulse duration register
	// Position of MIN_CNT field.
	UART_LOWPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of MIN_CNT field.
	UART_LOWPULSE_MIN_CNT_Msk = 0xfffff

	// HIGHPULSE: Autobaud minimum high pulse duration register
	// Position of MIN_CNT field.
	UART_HIGHPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of MIN_CNT field.
	UART_HIGHPULSE_MIN_CNT_Msk = 0xfffff

	// RXD_CNT: Autobaud edge change count register
	// Position of RXD_EDGE_CNT field.
	UART_RXD_CNT_RXD_EDGE_CNT_Pos = 0x0
	// Bit mask of RXD_EDGE_CNT field.
	UART_RXD_CNT_RXD_EDGE_CNT_Msk = 0x3ff

	// FLOW_CONF: Software flow control configuration
	// Position of SW_FLOW_CON_EN field.
	UART_FLOW_CONF_SW_FLOW_CON_EN_Pos = 0x0
	// Bit mask of SW_FLOW_CON_EN field.
	UART_FLOW_CONF_SW_FLOW_CON_EN_Msk = 0x1
	// Bit SW_FLOW_CON_EN.
	UART_FLOW_CONF_SW_FLOW_CON_EN = 0x1
	// Position of XONOFF_DEL field.
	UART_FLOW_CONF_XONOFF_DEL_Pos = 0x1
	// Bit mask of XONOFF_DEL field.
	UART_FLOW_CONF_XONOFF_DEL_Msk = 0x2
	// Bit XONOFF_DEL.
	UART_FLOW_CONF_XONOFF_DEL = 0x2
	// Position of FORCE_XON field.
	UART_FLOW_CONF_FORCE_XON_Pos = 0x2
	// Bit mask of FORCE_XON field.
	UART_FLOW_CONF_FORCE_XON_Msk = 0x4
	// Bit FORCE_XON.
	UART_FLOW_CONF_FORCE_XON = 0x4
	// Position of FORCE_XOFF field.
	UART_FLOW_CONF_FORCE_XOFF_Pos = 0x3
	// Bit mask of FORCE_XOFF field.
	UART_FLOW_CONF_FORCE_XOFF_Msk = 0x8
	// Bit FORCE_XOFF.
	UART_FLOW_CONF_FORCE_XOFF = 0x8
	// Position of SEND_XON field.
	UART_FLOW_CONF_SEND_XON_Pos = 0x4
	// Bit mask of SEND_XON field.
	UART_FLOW_CONF_SEND_XON_Msk = 0x10
	// Bit SEND_XON.
	UART_FLOW_CONF_SEND_XON = 0x10
	// Position of SEND_XOFF field.
	UART_FLOW_CONF_SEND_XOFF_Pos = 0x5
	// Bit mask of SEND_XOFF field.
	UART_FLOW_CONF_SEND_XOFF_Msk = 0x20
	// Bit SEND_XOFF.
	UART_FLOW_CONF_SEND_XOFF = 0x20

	// SLEEP_CONF: Sleep mode configuration
	// Position of ACTIVE_THRESHOLD field.
	UART_SLEEP_CONF_ACTIVE_THRESHOLD_Pos = 0x0
	// Bit mask of ACTIVE_THRESHOLD field.
	UART_SLEEP_CONF_ACTIVE_THRESHOLD_Msk = 0x3ff

	// SWFC_CONF0: Software flow control character configuration
	// Position of XOFF_THRESHOLD field.
	UART_SWFC_CONF0_XOFF_THRESHOLD_Pos = 0x0
	// Bit mask of XOFF_THRESHOLD field.
	UART_SWFC_CONF0_XOFF_THRESHOLD_Msk = 0x1ff
	// Position of XOFF_CHAR field.
	UART_SWFC_CONF0_XOFF_CHAR_Pos = 0x9
	// Bit mask of XOFF_CHAR field.
	UART_SWFC_CONF0_XOFF_CHAR_Msk = 0x1fe00

	// SWFC_CONF1: Software flow-control character configuration
	// Position of XON_THRESHOLD field.
	UART_SWFC_CONF1_XON_THRESHOLD_Pos = 0x0
	// Bit mask of XON_THRESHOLD field.
	UART_SWFC_CONF1_XON_THRESHOLD_Msk = 0x1ff
	// Position of XON_CHAR field.
	UART_SWFC_CONF1_XON_CHAR_Pos = 0x9
	// Bit mask of XON_CHAR field.
	UART_SWFC_CONF1_XON_CHAR_Msk = 0x1fe00

	// IDLE_CONF: Frame end idle time configuration
	// Position of RX_IDLE_THRHD field.
	UART_IDLE_CONF_RX_IDLE_THRHD_Pos = 0x0
	// Bit mask of RX_IDLE_THRHD field.
	UART_IDLE_CONF_RX_IDLE_THRHD_Msk = 0x3ff
	// Position of TX_IDLE_NUM field.
	UART_IDLE_CONF_TX_IDLE_NUM_Pos = 0xa
	// Bit mask of TX_IDLE_NUM field.
	UART_IDLE_CONF_TX_IDLE_NUM_Msk = 0xffc00
	// Position of TX_BRK_NUM field.
	UART_IDLE_CONF_TX_BRK_NUM_Pos = 0x14
	// Bit mask of TX_BRK_NUM field.
	UART_IDLE_CONF_TX_BRK_NUM_Msk = 0xff00000

	// RS485_CONF: RS485 mode configuration
	// Position of RS485_EN field.
	UART_RS485_CONF_RS485_EN_Pos = 0x0
	// Bit mask of RS485_EN field.
	UART_RS485_CONF_RS485_EN_Msk = 0x1
	// Bit RS485_EN.
	UART_RS485_CONF_RS485_EN = 0x1
	// Position of DL0_EN field.
	UART_RS485_CONF_DL0_EN_Pos = 0x1
	// Bit mask of DL0_EN field.
	UART_RS485_CONF_DL0_EN_Msk = 0x2
	// Bit DL0_EN.
	UART_RS485_CONF_DL0_EN = 0x2
	// Position of DL1_EN field.
	UART_RS485_CONF_DL1_EN_Pos = 0x2
	// Bit mask of DL1_EN field.
	UART_RS485_CONF_DL1_EN_Msk = 0x4
	// Bit DL1_EN.
	UART_RS485_CONF_DL1_EN = 0x4
	// Position of RS485TX_RX_EN field.
	UART_RS485_CONF_RS485TX_RX_EN_Pos = 0x3
	// Bit mask of RS485TX_RX_EN field.
	UART_RS485_CONF_RS485TX_RX_EN_Msk = 0x8
	// Bit RS485TX_RX_EN.
	UART_RS485_CONF_RS485TX_RX_EN = 0x8
	// Position of RS485RXBY_TX_EN field.
	UART_RS485_CONF_RS485RXBY_TX_EN_Pos = 0x4
	// Bit mask of RS485RXBY_TX_EN field.
	UART_RS485_CONF_RS485RXBY_TX_EN_Msk = 0x10
	// Bit RS485RXBY_TX_EN.
	UART_RS485_CONF_RS485RXBY_TX_EN = 0x10
	// Position of RS485_RX_DLY_NUM field.
	UART_RS485_CONF_RS485_RX_DLY_NUM_Pos = 0x5
	// Bit mask of RS485_RX_DLY_NUM field.
	UART_RS485_CONF_RS485_RX_DLY_NUM_Msk = 0x20
	// Bit RS485_RX_DLY_NUM.
	UART_RS485_CONF_RS485_RX_DLY_NUM = 0x20
	// Position of RS485_TX_DLY_NUM field.
	UART_RS485_CONF_RS485_TX_DLY_NUM_Pos = 0x6
	// Bit mask of RS485_TX_DLY_NUM field.
	UART_RS485_CONF_RS485_TX_DLY_NUM_Msk = 0x3c0

	// AT_CMD_PRECNT: Pre-sequence timing configuration
	// Position of PRE_IDLE_NUM field.
	UART_AT_CMD_PRECNT_PRE_IDLE_NUM_Pos = 0x0
	// Bit mask of PRE_IDLE_NUM field.
	UART_AT_CMD_PRECNT_PRE_IDLE_NUM_Msk = 0xffff

	// AT_CMD_POSTCNT: Post-sequence timing configuration
	// Position of POST_IDLE_NUM field.
	UART_AT_CMD_POSTCNT_POST_IDLE_NUM_Pos = 0x0
	// Bit mask of POST_IDLE_NUM field.
	UART_AT_CMD_POSTCNT_POST_IDLE_NUM_Msk = 0xffff

	// AT_CMD_GAPTOUT: Timeout configuration
	// Position of RX_GAP_TOUT field.
	UART_AT_CMD_GAPTOUT_RX_GAP_TOUT_Pos = 0x0
	// Bit mask of RX_GAP_TOUT field.
	UART_AT_CMD_GAPTOUT_RX_GAP_TOUT_Msk = 0xffff

	// AT_CMD_CHAR: AT escape sequence selection configuration
	// Position of AT_CMD_CHAR field.
	UART_AT_CMD_CHAR_AT_CMD_CHAR_Pos = 0x0
	// Bit mask of AT_CMD_CHAR field.
	UART_AT_CMD_CHAR_AT_CMD_CHAR_Msk = 0xff
	// Position of CHAR_NUM field.
	UART_AT_CMD_CHAR_CHAR_NUM_Pos = 0x8
	// Bit mask of CHAR_NUM field.
	UART_AT_CMD_CHAR_CHAR_NUM_Msk = 0xff00

	// MEM_CONF: UART threshold and allocation configuration
	// Position of RX_SIZE field.
	UART_MEM_CONF_RX_SIZE_Pos = 0x1
	// Bit mask of RX_SIZE field.
	UART_MEM_CONF_RX_SIZE_Msk = 0xe
	// Position of TX_SIZE field.
	UART_MEM_CONF_TX_SIZE_Pos = 0x4
	// Bit mask of TX_SIZE field.
	UART_MEM_CONF_TX_SIZE_Msk = 0x70
	// Position of RX_FLOW_THRHD field.
	UART_MEM_CONF_RX_FLOW_THRHD_Pos = 0x7
	// Bit mask of RX_FLOW_THRHD field.
	UART_MEM_CONF_RX_FLOW_THRHD_Msk = 0xff80
	// Position of RX_TOUT_THRHD field.
	UART_MEM_CONF_RX_TOUT_THRHD_Pos = 0x10
	// Bit mask of RX_TOUT_THRHD field.
	UART_MEM_CONF_RX_TOUT_THRHD_Msk = 0x3ff0000
	// Position of MEM_FORCE_PD field.
	UART_MEM_CONF_MEM_FORCE_PD_Pos = 0x1a
	// Bit mask of MEM_FORCE_PD field.
	UART_MEM_CONF_MEM_FORCE_PD_Msk = 0x4000000
	// Bit MEM_FORCE_PD.
	UART_MEM_CONF_MEM_FORCE_PD = 0x4000000
	// Position of MEM_FORCE_PU field.
	UART_MEM_CONF_MEM_FORCE_PU_Pos = 0x1b
	// Bit mask of MEM_FORCE_PU field.
	UART_MEM_CONF_MEM_FORCE_PU_Msk = 0x8000000
	// Bit MEM_FORCE_PU.
	UART_MEM_CONF_MEM_FORCE_PU = 0x8000000

	// MEM_TX_STATUS: TX FIFO write and read offset address
	// Position of APB_TX_WADDR field.
	UART_MEM_TX_STATUS_APB_TX_WADDR_Pos = 0x0
	// Bit mask of APB_TX_WADDR field.
	UART_MEM_TX_STATUS_APB_TX_WADDR_Msk = 0x3ff
	// Position of TX_RADDR field.
	UART_MEM_TX_STATUS_TX_RADDR_Pos = 0xb
	// Bit mask of TX_RADDR field.
	UART_MEM_TX_STATUS_TX_RADDR_Msk = 0x1ff800

	// MEM_RX_STATUS: RX FIFO write and read offset address
	// Position of APB_RX_RADDR field.
	UART_MEM_RX_STATUS_APB_RX_RADDR_Pos = 0x0
	// Bit mask of APB_RX_RADDR field.
	UART_MEM_RX_STATUS_APB_RX_RADDR_Msk = 0x3ff
	// Position of RX_WADDR field.
	UART_MEM_RX_STATUS_RX_WADDR_Pos = 0xb
	// Bit mask of RX_WADDR field.
	UART_MEM_RX_STATUS_RX_WADDR_Msk = 0x1ff800

	// FSM_STATUS: UART transmitter and receiver status
	// Position of ST_URX_OUT field.
	UART_FSM_STATUS_ST_URX_OUT_Pos = 0x0
	// Bit mask of ST_URX_OUT field.
	UART_FSM_STATUS_ST_URX_OUT_Msk = 0xf
	// Position of ST_UTX_OUT field.
	UART_FSM_STATUS_ST_UTX_OUT_Pos = 0x4
	// Bit mask of ST_UTX_OUT field.
	UART_FSM_STATUS_ST_UTX_OUT_Msk = 0xf0

	// POSPULSE: Autobaud high pulse register
	// Position of POSEDGE_MIN_CNT field.
	UART_POSPULSE_POSEDGE_MIN_CNT_Pos = 0x0
	// Bit mask of POSEDGE_MIN_CNT field.
	UART_POSPULSE_POSEDGE_MIN_CNT_Msk = 0xfffff

	// NEGPULSE: Autobaud low pulse register
	// Position of NEGEDGE_MIN_CNT field.
	UART_NEGPULSE_NEGEDGE_MIN_CNT_Pos = 0x0
	// Bit mask of NEGEDGE_MIN_CNT field.
	UART_NEGPULSE_NEGEDGE_MIN_CNT_Msk = 0xfffff

	// DATE: UART version control register
	// Position of DATE field.
	UART_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	UART_DATE_DATE_Msk = 0xffffffff

	// ID: UART ID register
	// Position of ID field.
	UART_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	UART_ID_ID_Msk = 0xffffffff
)

// Constants for UHCI0: Universal Host Controller Interface 0
const (
	// CONF0: UHCI configuration register
	// Position of IN_RST field.
	UHCI_CONF0_IN_RST_Pos = 0x0
	// Bit mask of IN_RST field.
	UHCI_CONF0_IN_RST_Msk = 0x1
	// Bit IN_RST.
	UHCI_CONF0_IN_RST = 0x1
	// Position of OUT_RST field.
	UHCI_CONF0_OUT_RST_Pos = 0x1
	// Bit mask of OUT_RST field.
	UHCI_CONF0_OUT_RST_Msk = 0x2
	// Bit OUT_RST.
	UHCI_CONF0_OUT_RST = 0x2
	// Position of AHBM_FIFO_RST field.
	UHCI_CONF0_AHBM_FIFO_RST_Pos = 0x2
	// Bit mask of AHBM_FIFO_RST field.
	UHCI_CONF0_AHBM_FIFO_RST_Msk = 0x4
	// Bit AHBM_FIFO_RST.
	UHCI_CONF0_AHBM_FIFO_RST = 0x4
	// Position of AHBM_RST field.
	UHCI_CONF0_AHBM_RST_Pos = 0x3
	// Bit mask of AHBM_RST field.
	UHCI_CONF0_AHBM_RST_Msk = 0x8
	// Bit AHBM_RST.
	UHCI_CONF0_AHBM_RST = 0x8
	// Position of IN_LOOP_TEST field.
	UHCI_CONF0_IN_LOOP_TEST_Pos = 0x4
	// Bit mask of IN_LOOP_TEST field.
	UHCI_CONF0_IN_LOOP_TEST_Msk = 0x10
	// Bit IN_LOOP_TEST.
	UHCI_CONF0_IN_LOOP_TEST = 0x10
	// Position of OUT_LOOP_TEST field.
	UHCI_CONF0_OUT_LOOP_TEST_Pos = 0x5
	// Bit mask of OUT_LOOP_TEST field.
	UHCI_CONF0_OUT_LOOP_TEST_Msk = 0x20
	// Bit OUT_LOOP_TEST.
	UHCI_CONF0_OUT_LOOP_TEST = 0x20
	// Position of OUT_AUTO_WRBACK field.
	UHCI_CONF0_OUT_AUTO_WRBACK_Pos = 0x6
	// Bit mask of OUT_AUTO_WRBACK field.
	UHCI_CONF0_OUT_AUTO_WRBACK_Msk = 0x40
	// Bit OUT_AUTO_WRBACK.
	UHCI_CONF0_OUT_AUTO_WRBACK = 0x40
	// Position of OUT_NO_RESTART_CLR field.
	UHCI_CONF0_OUT_NO_RESTART_CLR_Pos = 0x7
	// Bit mask of OUT_NO_RESTART_CLR field.
	UHCI_CONF0_OUT_NO_RESTART_CLR_Msk = 0x80
	// Bit OUT_NO_RESTART_CLR.
	UHCI_CONF0_OUT_NO_RESTART_CLR = 0x80
	// Position of OUT_EOF_MODE field.
	UHCI_CONF0_OUT_EOF_MODE_Pos = 0x8
	// Bit mask of OUT_EOF_MODE field.
	UHCI_CONF0_OUT_EOF_MODE_Msk = 0x100
	// Bit OUT_EOF_MODE.
	UHCI_CONF0_OUT_EOF_MODE = 0x100
	// Position of UART0_CE field.
	UHCI_CONF0_UART0_CE_Pos = 0x9
	// Bit mask of UART0_CE field.
	UHCI_CONF0_UART0_CE_Msk = 0x200
	// Bit UART0_CE.
	UHCI_CONF0_UART0_CE = 0x200
	// Position of UART1_CE field.
	UHCI_CONF0_UART1_CE_Pos = 0xa
	// Bit mask of UART1_CE field.
	UHCI_CONF0_UART1_CE_Msk = 0x400
	// Bit UART1_CE.
	UHCI_CONF0_UART1_CE = 0x400
	// Position of OUTDSCR_BURST_EN field.
	UHCI_CONF0_OUTDSCR_BURST_EN_Pos = 0xc
	// Bit mask of OUTDSCR_BURST_EN field.
	UHCI_CONF0_OUTDSCR_BURST_EN_Msk = 0x1000
	// Bit OUTDSCR_BURST_EN.
	UHCI_CONF0_OUTDSCR_BURST_EN = 0x1000
	// Position of INDSCR_BURST_EN field.
	UHCI_CONF0_INDSCR_BURST_EN_Pos = 0xd
	// Bit mask of INDSCR_BURST_EN field.
	UHCI_CONF0_INDSCR_BURST_EN_Msk = 0x2000
	// Bit INDSCR_BURST_EN.
	UHCI_CONF0_INDSCR_BURST_EN = 0x2000
	// Position of MEM_TRANS_EN field.
	UHCI_CONF0_MEM_TRANS_EN_Pos = 0xf
	// Bit mask of MEM_TRANS_EN field.
	UHCI_CONF0_MEM_TRANS_EN_Msk = 0x8000
	// Bit MEM_TRANS_EN.
	UHCI_CONF0_MEM_TRANS_EN = 0x8000
	// Position of SEPER_EN field.
	UHCI_CONF0_SEPER_EN_Pos = 0x10
	// Bit mask of SEPER_EN field.
	UHCI_CONF0_SEPER_EN_Msk = 0x10000
	// Bit SEPER_EN.
	UHCI_CONF0_SEPER_EN = 0x10000
	// Position of HEAD_EN field.
	UHCI_CONF0_HEAD_EN_Pos = 0x11
	// Bit mask of HEAD_EN field.
	UHCI_CONF0_HEAD_EN_Msk = 0x20000
	// Bit HEAD_EN.
	UHCI_CONF0_HEAD_EN = 0x20000
	// Position of CRC_REC_EN field.
	UHCI_CONF0_CRC_REC_EN_Pos = 0x12
	// Bit mask of CRC_REC_EN field.
	UHCI_CONF0_CRC_REC_EN_Msk = 0x40000
	// Bit CRC_REC_EN.
	UHCI_CONF0_CRC_REC_EN = 0x40000
	// Position of UART_IDLE_EOF_EN field.
	UHCI_CONF0_UART_IDLE_EOF_EN_Pos = 0x13
	// Bit mask of UART_IDLE_EOF_EN field.
	UHCI_CONF0_UART_IDLE_EOF_EN_Msk = 0x80000
	// Bit UART_IDLE_EOF_EN.
	UHCI_CONF0_UART_IDLE_EOF_EN = 0x80000
	// Position of LEN_EOF_EN field.
	UHCI_CONF0_LEN_EOF_EN_Pos = 0x14
	// Bit mask of LEN_EOF_EN field.
	UHCI_CONF0_LEN_EOF_EN_Msk = 0x100000
	// Bit LEN_EOF_EN.
	UHCI_CONF0_LEN_EOF_EN = 0x100000
	// Position of ENCODE_CRC_EN field.
	UHCI_CONF0_ENCODE_CRC_EN_Pos = 0x15
	// Bit mask of ENCODE_CRC_EN field.
	UHCI_CONF0_ENCODE_CRC_EN_Msk = 0x200000
	// Bit ENCODE_CRC_EN.
	UHCI_CONF0_ENCODE_CRC_EN = 0x200000
	// Position of CLK_EN field.
	UHCI_CONF0_CLK_EN_Pos = 0x16
	// Bit mask of CLK_EN field.
	UHCI_CONF0_CLK_EN_Msk = 0x400000
	// Bit CLK_EN.
	UHCI_CONF0_CLK_EN = 0x400000
	// Position of UART_RX_BRK_EOF_EN field.
	UHCI_CONF0_UART_RX_BRK_EOF_EN_Pos = 0x17
	// Bit mask of UART_RX_BRK_EOF_EN field.
	UHCI_CONF0_UART_RX_BRK_EOF_EN_Msk = 0x800000
	// Bit UART_RX_BRK_EOF_EN.
	UHCI_CONF0_UART_RX_BRK_EOF_EN = 0x800000

	// INT_RAW: Raw interrupt status
	// Position of RX_START_INT_RAW field.
	UHCI_INT_RAW_RX_START_INT_RAW_Pos = 0x0
	// Bit mask of RX_START_INT_RAW field.
	UHCI_INT_RAW_RX_START_INT_RAW_Msk = 0x1
	// Bit RX_START_INT_RAW.
	UHCI_INT_RAW_RX_START_INT_RAW = 0x1
	// Position of TX_START_INT_RAW field.
	UHCI_INT_RAW_TX_START_INT_RAW_Pos = 0x1
	// Bit mask of TX_START_INT_RAW field.
	UHCI_INT_RAW_TX_START_INT_RAW_Msk = 0x2
	// Bit TX_START_INT_RAW.
	UHCI_INT_RAW_TX_START_INT_RAW = 0x2
	// Position of RX_HUNG_INT_RAW field.
	UHCI_INT_RAW_RX_HUNG_INT_RAW_Pos = 0x2
	// Bit mask of RX_HUNG_INT_RAW field.
	UHCI_INT_RAW_RX_HUNG_INT_RAW_Msk = 0x4
	// Bit RX_HUNG_INT_RAW.
	UHCI_INT_RAW_RX_HUNG_INT_RAW = 0x4
	// Position of TX_HUNG_INT_RAW field.
	UHCI_INT_RAW_TX_HUNG_INT_RAW_Pos = 0x3
	// Bit mask of TX_HUNG_INT_RAW field.
	UHCI_INT_RAW_TX_HUNG_INT_RAW_Msk = 0x8
	// Bit TX_HUNG_INT_RAW.
	UHCI_INT_RAW_TX_HUNG_INT_RAW = 0x8
	// Position of IN_DONE_INT_RAW field.
	UHCI_INT_RAW_IN_DONE_INT_RAW_Pos = 0x4
	// Bit mask of IN_DONE_INT_RAW field.
	UHCI_INT_RAW_IN_DONE_INT_RAW_Msk = 0x10
	// Bit IN_DONE_INT_RAW.
	UHCI_INT_RAW_IN_DONE_INT_RAW = 0x10
	// Position of IN_SUC_EOF_INT_RAW field.
	UHCI_INT_RAW_IN_SUC_EOF_INT_RAW_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_RAW field.
	UHCI_INT_RAW_IN_SUC_EOF_INT_RAW_Msk = 0x20
	// Bit IN_SUC_EOF_INT_RAW.
	UHCI_INT_RAW_IN_SUC_EOF_INT_RAW = 0x20
	// Position of IN_ERR_EOF_INT_RAW field.
	UHCI_INT_RAW_IN_ERR_EOF_INT_RAW_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_RAW field.
	UHCI_INT_RAW_IN_ERR_EOF_INT_RAW_Msk = 0x40
	// Bit IN_ERR_EOF_INT_RAW.
	UHCI_INT_RAW_IN_ERR_EOF_INT_RAW = 0x40
	// Position of OUT_DONE_INT_RAW field.
	UHCI_INT_RAW_OUT_DONE_INT_RAW_Pos = 0x7
	// Bit mask of OUT_DONE_INT_RAW field.
	UHCI_INT_RAW_OUT_DONE_INT_RAW_Msk = 0x80
	// Bit OUT_DONE_INT_RAW.
	UHCI_INT_RAW_OUT_DONE_INT_RAW = 0x80
	// Position of OUT_EOF_INT_RAW field.
	UHCI_INT_RAW_OUT_EOF_INT_RAW_Pos = 0x8
	// Bit mask of OUT_EOF_INT_RAW field.
	UHCI_INT_RAW_OUT_EOF_INT_RAW_Msk = 0x100
	// Bit OUT_EOF_INT_RAW.
	UHCI_INT_RAW_OUT_EOF_INT_RAW = 0x100
	// Position of IN_DSCR_ERR_INT_RAW field.
	UHCI_INT_RAW_IN_DSCR_ERR_INT_RAW_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_RAW field.
	UHCI_INT_RAW_IN_DSCR_ERR_INT_RAW_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_RAW.
	UHCI_INT_RAW_IN_DSCR_ERR_INT_RAW = 0x200
	// Position of OUT_DSCR_ERR_INT_RAW field.
	UHCI_INT_RAW_OUT_DSCR_ERR_INT_RAW_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_RAW field.
	UHCI_INT_RAW_OUT_DSCR_ERR_INT_RAW_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_RAW.
	UHCI_INT_RAW_OUT_DSCR_ERR_INT_RAW = 0x400
	// Position of IN_DSCR_EMPTY_INT_RAW field.
	UHCI_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_RAW field.
	UHCI_INT_RAW_IN_DSCR_EMPTY_INT_RAW_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_RAW.
	UHCI_INT_RAW_IN_DSCR_EMPTY_INT_RAW = 0x800
	// Position of OUTLINK_EOF_ERR_INT_RAW field.
	UHCI_INT_RAW_OUTLINK_EOF_ERR_INT_RAW_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_RAW field.
	UHCI_INT_RAW_OUTLINK_EOF_ERR_INT_RAW_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_RAW.
	UHCI_INT_RAW_OUTLINK_EOF_ERR_INT_RAW = 0x1000
	// Position of OUT_TOTAL_EOF_INT_RAW field.
	UHCI_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_RAW field.
	UHCI_INT_RAW_OUT_TOTAL_EOF_INT_RAW_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_RAW.
	UHCI_INT_RAW_OUT_TOTAL_EOF_INT_RAW = 0x2000
	// Position of SEND_S_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_S_REG_Q_INT_RAW_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_S_REG_Q_INT_RAW_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_RAW.
	UHCI_INT_RAW_SEND_S_REG_Q_INT_RAW = 0x4000
	// Position of SEND_A_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_A_REG_Q_INT_RAW_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_RAW field.
	UHCI_INT_RAW_SEND_A_REG_Q_INT_RAW_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_RAW.
	UHCI_INT_RAW_SEND_A_REG_Q_INT_RAW = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_RAW field.
	UHCI_INT_RAW_DMA_INFIFO_FULL_WM_INT_RAW_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_RAW field.
	UHCI_INT_RAW_DMA_INFIFO_FULL_WM_INT_RAW_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_RAW.
	UHCI_INT_RAW_DMA_INFIFO_FULL_WM_INT_RAW = 0x10000

	// INT_ST: Masked interrupt status
	// Position of RX_START_INT_ST field.
	UHCI_INT_ST_RX_START_INT_ST_Pos = 0x0
	// Bit mask of RX_START_INT_ST field.
	UHCI_INT_ST_RX_START_INT_ST_Msk = 0x1
	// Bit RX_START_INT_ST.
	UHCI_INT_ST_RX_START_INT_ST = 0x1
	// Position of TX_START_INT_ST field.
	UHCI_INT_ST_TX_START_INT_ST_Pos = 0x1
	// Bit mask of TX_START_INT_ST field.
	UHCI_INT_ST_TX_START_INT_ST_Msk = 0x2
	// Bit TX_START_INT_ST.
	UHCI_INT_ST_TX_START_INT_ST = 0x2
	// Position of RX_HUNG_INT_ST field.
	UHCI_INT_ST_RX_HUNG_INT_ST_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ST field.
	UHCI_INT_ST_RX_HUNG_INT_ST_Msk = 0x4
	// Bit RX_HUNG_INT_ST.
	UHCI_INT_ST_RX_HUNG_INT_ST = 0x4
	// Position of TX_HUNG_INT_ST field.
	UHCI_INT_ST_TX_HUNG_INT_ST_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ST field.
	UHCI_INT_ST_TX_HUNG_INT_ST_Msk = 0x8
	// Bit TX_HUNG_INT_ST.
	UHCI_INT_ST_TX_HUNG_INT_ST = 0x8
	// Position of IN_DONE_INT_ST field.
	UHCI_INT_ST_IN_DONE_INT_ST_Pos = 0x4
	// Bit mask of IN_DONE_INT_ST field.
	UHCI_INT_ST_IN_DONE_INT_ST_Msk = 0x10
	// Bit IN_DONE_INT_ST.
	UHCI_INT_ST_IN_DONE_INT_ST = 0x10
	// Position of IN_SUC_EOF_INT_ST field.
	UHCI_INT_ST_IN_SUC_EOF_INT_ST_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_ST field.
	UHCI_INT_ST_IN_SUC_EOF_INT_ST_Msk = 0x20
	// Bit IN_SUC_EOF_INT_ST.
	UHCI_INT_ST_IN_SUC_EOF_INT_ST = 0x20
	// Position of IN_ERR_EOF_INT_ST field.
	UHCI_INT_ST_IN_ERR_EOF_INT_ST_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_ST field.
	UHCI_INT_ST_IN_ERR_EOF_INT_ST_Msk = 0x40
	// Bit IN_ERR_EOF_INT_ST.
	UHCI_INT_ST_IN_ERR_EOF_INT_ST = 0x40
	// Position of OUT_DONE_INT_ST field.
	UHCI_INT_ST_OUT_DONE_INT_ST_Pos = 0x7
	// Bit mask of OUT_DONE_INT_ST field.
	UHCI_INT_ST_OUT_DONE_INT_ST_Msk = 0x80
	// Bit OUT_DONE_INT_ST.
	UHCI_INT_ST_OUT_DONE_INT_ST = 0x80
	// Position of OUT_EOF_INT_ST field.
	UHCI_INT_ST_OUT_EOF_INT_ST_Pos = 0x8
	// Bit mask of OUT_EOF_INT_ST field.
	UHCI_INT_ST_OUT_EOF_INT_ST_Msk = 0x100
	// Bit OUT_EOF_INT_ST.
	UHCI_INT_ST_OUT_EOF_INT_ST = 0x100
	// Position of IN_DSCR_ERR_INT_ST field.
	UHCI_INT_ST_IN_DSCR_ERR_INT_ST_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_ST field.
	UHCI_INT_ST_IN_DSCR_ERR_INT_ST_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_ST.
	UHCI_INT_ST_IN_DSCR_ERR_INT_ST = 0x200
	// Position of OUT_DSCR_ERR_INT_ST field.
	UHCI_INT_ST_OUT_DSCR_ERR_INT_ST_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_ST field.
	UHCI_INT_ST_OUT_DSCR_ERR_INT_ST_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_ST.
	UHCI_INT_ST_OUT_DSCR_ERR_INT_ST = 0x400
	// Position of IN_DSCR_EMPTY_INT_ST field.
	UHCI_INT_ST_IN_DSCR_EMPTY_INT_ST_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_ST field.
	UHCI_INT_ST_IN_DSCR_EMPTY_INT_ST_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_ST.
	UHCI_INT_ST_IN_DSCR_EMPTY_INT_ST = 0x800
	// Position of OUTLINK_EOF_ERR_INT_ST field.
	UHCI_INT_ST_OUTLINK_EOF_ERR_INT_ST_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_ST field.
	UHCI_INT_ST_OUTLINK_EOF_ERR_INT_ST_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_ST.
	UHCI_INT_ST_OUTLINK_EOF_ERR_INT_ST = 0x1000
	// Position of OUT_TOTAL_EOF_INT_ST field.
	UHCI_INT_ST_OUT_TOTAL_EOF_INT_ST_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_ST field.
	UHCI_INT_ST_OUT_TOTAL_EOF_INT_ST_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_ST.
	UHCI_INT_ST_OUT_TOTAL_EOF_INT_ST = 0x2000
	// Position of SEND_S_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_S_REG_Q_INT_ST_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_S_REG_Q_INT_ST_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_ST.
	UHCI_INT_ST_SEND_S_REG_Q_INT_ST = 0x4000
	// Position of SEND_A_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_A_REG_Q_INT_ST_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_ST field.
	UHCI_INT_ST_SEND_A_REG_Q_INT_ST_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_ST.
	UHCI_INT_ST_SEND_A_REG_Q_INT_ST = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_ST field.
	UHCI_INT_ST_DMA_INFIFO_FULL_WM_INT_ST_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_ST field.
	UHCI_INT_ST_DMA_INFIFO_FULL_WM_INT_ST_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_ST.
	UHCI_INT_ST_DMA_INFIFO_FULL_WM_INT_ST = 0x10000

	// INT_ENA: Interrupt enable bits
	// Position of RX_START_INT_ENA field.
	UHCI_INT_ENA_RX_START_INT_ENA_Pos = 0x0
	// Bit mask of RX_START_INT_ENA field.
	UHCI_INT_ENA_RX_START_INT_ENA_Msk = 0x1
	// Bit RX_START_INT_ENA.
	UHCI_INT_ENA_RX_START_INT_ENA = 0x1
	// Position of TX_START_INT_ENA field.
	UHCI_INT_ENA_TX_START_INT_ENA_Pos = 0x1
	// Bit mask of TX_START_INT_ENA field.
	UHCI_INT_ENA_TX_START_INT_ENA_Msk = 0x2
	// Bit TX_START_INT_ENA.
	UHCI_INT_ENA_TX_START_INT_ENA = 0x2
	// Position of RX_HUNG_INT_ENA field.
	UHCI_INT_ENA_RX_HUNG_INT_ENA_Pos = 0x2
	// Bit mask of RX_HUNG_INT_ENA field.
	UHCI_INT_ENA_RX_HUNG_INT_ENA_Msk = 0x4
	// Bit RX_HUNG_INT_ENA.
	UHCI_INT_ENA_RX_HUNG_INT_ENA = 0x4
	// Position of TX_HUNG_INT_ENA field.
	UHCI_INT_ENA_TX_HUNG_INT_ENA_Pos = 0x3
	// Bit mask of TX_HUNG_INT_ENA field.
	UHCI_INT_ENA_TX_HUNG_INT_ENA_Msk = 0x8
	// Bit TX_HUNG_INT_ENA.
	UHCI_INT_ENA_TX_HUNG_INT_ENA = 0x8
	// Position of IN_DONE_INT_ENA field.
	UHCI_INT_ENA_IN_DONE_INT_ENA_Pos = 0x4
	// Bit mask of IN_DONE_INT_ENA field.
	UHCI_INT_ENA_IN_DONE_INT_ENA_Msk = 0x10
	// Bit IN_DONE_INT_ENA.
	UHCI_INT_ENA_IN_DONE_INT_ENA = 0x10
	// Position of IN_SUC_EOF_INT_ENA field.
	UHCI_INT_ENA_IN_SUC_EOF_INT_ENA_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_ENA field.
	UHCI_INT_ENA_IN_SUC_EOF_INT_ENA_Msk = 0x20
	// Bit IN_SUC_EOF_INT_ENA.
	UHCI_INT_ENA_IN_SUC_EOF_INT_ENA = 0x20
	// Position of IN_ERR_EOF_INT_ENA field.
	UHCI_INT_ENA_IN_ERR_EOF_INT_ENA_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_ENA field.
	UHCI_INT_ENA_IN_ERR_EOF_INT_ENA_Msk = 0x40
	// Bit IN_ERR_EOF_INT_ENA.
	UHCI_INT_ENA_IN_ERR_EOF_INT_ENA = 0x40
	// Position of OUT_DONE_INT_ENA field.
	UHCI_INT_ENA_OUT_DONE_INT_ENA_Pos = 0x7
	// Bit mask of OUT_DONE_INT_ENA field.
	UHCI_INT_ENA_OUT_DONE_INT_ENA_Msk = 0x80
	// Bit OUT_DONE_INT_ENA.
	UHCI_INT_ENA_OUT_DONE_INT_ENA = 0x80
	// Position of OUT_EOF_INT_ENA field.
	UHCI_INT_ENA_OUT_EOF_INT_ENA_Pos = 0x8
	// Bit mask of OUT_EOF_INT_ENA field.
	UHCI_INT_ENA_OUT_EOF_INT_ENA_Msk = 0x100
	// Bit OUT_EOF_INT_ENA.
	UHCI_INT_ENA_OUT_EOF_INT_ENA = 0x100
	// Position of IN_DSCR_ERR_INT_ENA field.
	UHCI_INT_ENA_IN_DSCR_ERR_INT_ENA_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_ENA field.
	UHCI_INT_ENA_IN_DSCR_ERR_INT_ENA_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_ENA.
	UHCI_INT_ENA_IN_DSCR_ERR_INT_ENA = 0x200
	// Position of OUT_DSCR_ERR_INT_ENA field.
	UHCI_INT_ENA_OUT_DSCR_ERR_INT_ENA_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_ENA field.
	UHCI_INT_ENA_OUT_DSCR_ERR_INT_ENA_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_ENA.
	UHCI_INT_ENA_OUT_DSCR_ERR_INT_ENA = 0x400
	// Position of IN_DSCR_EMPTY_INT_ENA field.
	UHCI_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_ENA field.
	UHCI_INT_ENA_IN_DSCR_EMPTY_INT_ENA_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_ENA.
	UHCI_INT_ENA_IN_DSCR_EMPTY_INT_ENA = 0x800
	// Position of OUTLINK_EOF_ERR_INT_ENA field.
	UHCI_INT_ENA_OUTLINK_EOF_ERR_INT_ENA_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_ENA field.
	UHCI_INT_ENA_OUTLINK_EOF_ERR_INT_ENA_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_ENA.
	UHCI_INT_ENA_OUTLINK_EOF_ERR_INT_ENA = 0x1000
	// Position of OUT_TOTAL_EOF_INT_ENA field.
	UHCI_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_ENA field.
	UHCI_INT_ENA_OUT_TOTAL_EOF_INT_ENA_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_ENA.
	UHCI_INT_ENA_OUT_TOTAL_EOF_INT_ENA = 0x2000
	// Position of SEND_S_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_S_REG_Q_INT_ENA_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_S_REG_Q_INT_ENA_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_ENA.
	UHCI_INT_ENA_SEND_S_REG_Q_INT_ENA = 0x4000
	// Position of SEND_A_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_A_REG_Q_INT_ENA_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_ENA field.
	UHCI_INT_ENA_SEND_A_REG_Q_INT_ENA_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_ENA.
	UHCI_INT_ENA_SEND_A_REG_Q_INT_ENA = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_ENA field.
	UHCI_INT_ENA_DMA_INFIFO_FULL_WM_INT_ENA_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_ENA field.
	UHCI_INT_ENA_DMA_INFIFO_FULL_WM_INT_ENA_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_ENA.
	UHCI_INT_ENA_DMA_INFIFO_FULL_WM_INT_ENA = 0x10000

	// INT_CLR: Interrupt clear bits
	// Position of RX_START_INT_CLR field.
	UHCI_INT_CLR_RX_START_INT_CLR_Pos = 0x0
	// Bit mask of RX_START_INT_CLR field.
	UHCI_INT_CLR_RX_START_INT_CLR_Msk = 0x1
	// Bit RX_START_INT_CLR.
	UHCI_INT_CLR_RX_START_INT_CLR = 0x1
	// Position of TX_START_INT_CLR field.
	UHCI_INT_CLR_TX_START_INT_CLR_Pos = 0x1
	// Bit mask of TX_START_INT_CLR field.
	UHCI_INT_CLR_TX_START_INT_CLR_Msk = 0x2
	// Bit TX_START_INT_CLR.
	UHCI_INT_CLR_TX_START_INT_CLR = 0x2
	// Position of RX_HUNG_INT_CLR field.
	UHCI_INT_CLR_RX_HUNG_INT_CLR_Pos = 0x2
	// Bit mask of RX_HUNG_INT_CLR field.
	UHCI_INT_CLR_RX_HUNG_INT_CLR_Msk = 0x4
	// Bit RX_HUNG_INT_CLR.
	UHCI_INT_CLR_RX_HUNG_INT_CLR = 0x4
	// Position of TX_HUNG_INT_CLR field.
	UHCI_INT_CLR_TX_HUNG_INT_CLR_Pos = 0x3
	// Bit mask of TX_HUNG_INT_CLR field.
	UHCI_INT_CLR_TX_HUNG_INT_CLR_Msk = 0x8
	// Bit TX_HUNG_INT_CLR.
	UHCI_INT_CLR_TX_HUNG_INT_CLR = 0x8
	// Position of IN_DONE_INT_CLR field.
	UHCI_INT_CLR_IN_DONE_INT_CLR_Pos = 0x4
	// Bit mask of IN_DONE_INT_CLR field.
	UHCI_INT_CLR_IN_DONE_INT_CLR_Msk = 0x10
	// Bit IN_DONE_INT_CLR.
	UHCI_INT_CLR_IN_DONE_INT_CLR = 0x10
	// Position of IN_SUC_EOF_INT_CLR field.
	UHCI_INT_CLR_IN_SUC_EOF_INT_CLR_Pos = 0x5
	// Bit mask of IN_SUC_EOF_INT_CLR field.
	UHCI_INT_CLR_IN_SUC_EOF_INT_CLR_Msk = 0x20
	// Bit IN_SUC_EOF_INT_CLR.
	UHCI_INT_CLR_IN_SUC_EOF_INT_CLR = 0x20
	// Position of IN_ERR_EOF_INT_CLR field.
	UHCI_INT_CLR_IN_ERR_EOF_INT_CLR_Pos = 0x6
	// Bit mask of IN_ERR_EOF_INT_CLR field.
	UHCI_INT_CLR_IN_ERR_EOF_INT_CLR_Msk = 0x40
	// Bit IN_ERR_EOF_INT_CLR.
	UHCI_INT_CLR_IN_ERR_EOF_INT_CLR = 0x40
	// Position of OUT_DONE_INT_CLR field.
	UHCI_INT_CLR_OUT_DONE_INT_CLR_Pos = 0x7
	// Bit mask of OUT_DONE_INT_CLR field.
	UHCI_INT_CLR_OUT_DONE_INT_CLR_Msk = 0x80
	// Bit OUT_DONE_INT_CLR.
	UHCI_INT_CLR_OUT_DONE_INT_CLR = 0x80
	// Position of OUT_EOF_INT_CLR field.
	UHCI_INT_CLR_OUT_EOF_INT_CLR_Pos = 0x8
	// Bit mask of OUT_EOF_INT_CLR field.
	UHCI_INT_CLR_OUT_EOF_INT_CLR_Msk = 0x100
	// Bit OUT_EOF_INT_CLR.
	UHCI_INT_CLR_OUT_EOF_INT_CLR = 0x100
	// Position of IN_DSCR_ERR_INT_CLR field.
	UHCI_INT_CLR_IN_DSCR_ERR_INT_CLR_Pos = 0x9
	// Bit mask of IN_DSCR_ERR_INT_CLR field.
	UHCI_INT_CLR_IN_DSCR_ERR_INT_CLR_Msk = 0x200
	// Bit IN_DSCR_ERR_INT_CLR.
	UHCI_INT_CLR_IN_DSCR_ERR_INT_CLR = 0x200
	// Position of OUT_DSCR_ERR_INT_CLR field.
	UHCI_INT_CLR_OUT_DSCR_ERR_INT_CLR_Pos = 0xa
	// Bit mask of OUT_DSCR_ERR_INT_CLR field.
	UHCI_INT_CLR_OUT_DSCR_ERR_INT_CLR_Msk = 0x400
	// Bit OUT_DSCR_ERR_INT_CLR.
	UHCI_INT_CLR_OUT_DSCR_ERR_INT_CLR = 0x400
	// Position of IN_DSCR_EMPTY_INT_CLR field.
	UHCI_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Pos = 0xb
	// Bit mask of IN_DSCR_EMPTY_INT_CLR field.
	UHCI_INT_CLR_IN_DSCR_EMPTY_INT_CLR_Msk = 0x800
	// Bit IN_DSCR_EMPTY_INT_CLR.
	UHCI_INT_CLR_IN_DSCR_EMPTY_INT_CLR = 0x800
	// Position of OUTLINK_EOF_ERR_INT_CLR field.
	UHCI_INT_CLR_OUTLINK_EOF_ERR_INT_CLR_Pos = 0xc
	// Bit mask of OUTLINK_EOF_ERR_INT_CLR field.
	UHCI_INT_CLR_OUTLINK_EOF_ERR_INT_CLR_Msk = 0x1000
	// Bit OUTLINK_EOF_ERR_INT_CLR.
	UHCI_INT_CLR_OUTLINK_EOF_ERR_INT_CLR = 0x1000
	// Position of OUT_TOTAL_EOF_INT_CLR field.
	UHCI_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Pos = 0xd
	// Bit mask of OUT_TOTAL_EOF_INT_CLR field.
	UHCI_INT_CLR_OUT_TOTAL_EOF_INT_CLR_Msk = 0x2000
	// Bit OUT_TOTAL_EOF_INT_CLR.
	UHCI_INT_CLR_OUT_TOTAL_EOF_INT_CLR = 0x2000
	// Position of SEND_S_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_S_REG_Q_INT_CLR_Pos = 0xe
	// Bit mask of SEND_S_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_S_REG_Q_INT_CLR_Msk = 0x4000
	// Bit SEND_S_REG_Q_INT_CLR.
	UHCI_INT_CLR_SEND_S_REG_Q_INT_CLR = 0x4000
	// Position of SEND_A_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_A_REG_Q_INT_CLR_Pos = 0xf
	// Bit mask of SEND_A_REG_Q_INT_CLR field.
	UHCI_INT_CLR_SEND_A_REG_Q_INT_CLR_Msk = 0x8000
	// Bit SEND_A_REG_Q_INT_CLR.
	UHCI_INT_CLR_SEND_A_REG_Q_INT_CLR = 0x8000
	// Position of DMA_INFIFO_FULL_WM_INT_CLR field.
	UHCI_INT_CLR_DMA_INFIFO_FULL_WM_INT_CLR_Pos = 0x10
	// Bit mask of DMA_INFIFO_FULL_WM_INT_CLR field.
	UHCI_INT_CLR_DMA_INFIFO_FULL_WM_INT_CLR_Msk = 0x10000
	// Bit DMA_INFIFO_FULL_WM_INT_CLR.
	UHCI_INT_CLR_DMA_INFIFO_FULL_WM_INT_CLR = 0x10000

	// DMA_OUT_STATUS: DMA data-output status register
	// Position of OUT_FULL field.
	UHCI_DMA_OUT_STATUS_OUT_FULL_Pos = 0x0
	// Bit mask of OUT_FULL field.
	UHCI_DMA_OUT_STATUS_OUT_FULL_Msk = 0x1
	// Bit OUT_FULL.
	UHCI_DMA_OUT_STATUS_OUT_FULL = 0x1
	// Position of OUT_EMPTY field.
	UHCI_DMA_OUT_STATUS_OUT_EMPTY_Pos = 0x1
	// Bit mask of OUT_EMPTY field.
	UHCI_DMA_OUT_STATUS_OUT_EMPTY_Msk = 0x2
	// Bit OUT_EMPTY.
	UHCI_DMA_OUT_STATUS_OUT_EMPTY = 0x2

	// DMA_OUT_PUSH: Push control register of TX FIFO
	// Position of OUTFIFO_WDATA field.
	UHCI_DMA_OUT_PUSH_OUTFIFO_WDATA_Pos = 0x0
	// Bit mask of OUTFIFO_WDATA field.
	UHCI_DMA_OUT_PUSH_OUTFIFO_WDATA_Msk = 0x1ff
	// Position of OUTFIFO_PUSH field.
	UHCI_DMA_OUT_PUSH_OUTFIFO_PUSH_Pos = 0x10
	// Bit mask of OUTFIFO_PUSH field.
	UHCI_DMA_OUT_PUSH_OUTFIFO_PUSH_Msk = 0x10000
	// Bit OUTFIFO_PUSH.
	UHCI_DMA_OUT_PUSH_OUTFIFO_PUSH = 0x10000

	// DMA_IN_STATUS: UHCI data-input status register
	// Position of IN_FULL field.
	UHCI_DMA_IN_STATUS_IN_FULL_Pos = 0x0
	// Bit mask of IN_FULL field.
	UHCI_DMA_IN_STATUS_IN_FULL_Msk = 0x1
	// Bit IN_FULL.
	UHCI_DMA_IN_STATUS_IN_FULL = 0x1
	// Position of IN_EMPTY field.
	UHCI_DMA_IN_STATUS_IN_EMPTY_Pos = 0x1
	// Bit mask of IN_EMPTY field.
	UHCI_DMA_IN_STATUS_IN_EMPTY_Msk = 0x2
	// Bit IN_EMPTY.
	UHCI_DMA_IN_STATUS_IN_EMPTY = 0x2
	// Position of RX_ERR_CAUSE field.
	UHCI_DMA_IN_STATUS_RX_ERR_CAUSE_Pos = 0x4
	// Bit mask of RX_ERR_CAUSE field.
	UHCI_DMA_IN_STATUS_RX_ERR_CAUSE_Msk = 0x70

	// DMA_IN_POP: Pop control register of RX FIFO
	// Position of INFIFO_RDATA field.
	UHCI_DMA_IN_POP_INFIFO_RDATA_Pos = 0x0
	// Bit mask of INFIFO_RDATA field.
	UHCI_DMA_IN_POP_INFIFO_RDATA_Msk = 0xfff
	// Position of INFIFO_POP field.
	UHCI_DMA_IN_POP_INFIFO_POP_Pos = 0x10
	// Bit mask of INFIFO_POP field.
	UHCI_DMA_IN_POP_INFIFO_POP_Msk = 0x10000
	// Bit INFIFO_POP.
	UHCI_DMA_IN_POP_INFIFO_POP = 0x10000

	// DMA_OUT_LINK: Link descriptor address and control
	// Position of OUTLINK_ADDR field.
	UHCI_DMA_OUT_LINK_OUTLINK_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_ADDR field.
	UHCI_DMA_OUT_LINK_OUTLINK_ADDR_Msk = 0xfffff
	// Position of OUTLINK_STOP field.
	UHCI_DMA_OUT_LINK_OUTLINK_STOP_Pos = 0x1c
	// Bit mask of OUTLINK_STOP field.
	UHCI_DMA_OUT_LINK_OUTLINK_STOP_Msk = 0x10000000
	// Bit OUTLINK_STOP.
	UHCI_DMA_OUT_LINK_OUTLINK_STOP = 0x10000000
	// Position of OUTLINK_START field.
	UHCI_DMA_OUT_LINK_OUTLINK_START_Pos = 0x1d
	// Bit mask of OUTLINK_START field.
	UHCI_DMA_OUT_LINK_OUTLINK_START_Msk = 0x20000000
	// Bit OUTLINK_START.
	UHCI_DMA_OUT_LINK_OUTLINK_START = 0x20000000
	// Position of OUTLINK_RESTART field.
	UHCI_DMA_OUT_LINK_OUTLINK_RESTART_Pos = 0x1e
	// Bit mask of OUTLINK_RESTART field.
	UHCI_DMA_OUT_LINK_OUTLINK_RESTART_Msk = 0x40000000
	// Bit OUTLINK_RESTART.
	UHCI_DMA_OUT_LINK_OUTLINK_RESTART = 0x40000000
	// Position of OUTLINK_PARK field.
	UHCI_DMA_OUT_LINK_OUTLINK_PARK_Pos = 0x1f
	// Bit mask of OUTLINK_PARK field.
	UHCI_DMA_OUT_LINK_OUTLINK_PARK_Msk = 0x80000000
	// Bit OUTLINK_PARK.
	UHCI_DMA_OUT_LINK_OUTLINK_PARK = 0x80000000

	// DMA_IN_LINK: Link descriptor address and control
	// Position of INLINK_ADDR field.
	UHCI_DMA_IN_LINK_INLINK_ADDR_Pos = 0x0
	// Bit mask of INLINK_ADDR field.
	UHCI_DMA_IN_LINK_INLINK_ADDR_Msk = 0xfffff
	// Position of INLINK_AUTO_RET field.
	UHCI_DMA_IN_LINK_INLINK_AUTO_RET_Pos = 0x14
	// Bit mask of INLINK_AUTO_RET field.
	UHCI_DMA_IN_LINK_INLINK_AUTO_RET_Msk = 0x100000
	// Bit INLINK_AUTO_RET.
	UHCI_DMA_IN_LINK_INLINK_AUTO_RET = 0x100000
	// Position of INLINK_STOP field.
	UHCI_DMA_IN_LINK_INLINK_STOP_Pos = 0x1c
	// Bit mask of INLINK_STOP field.
	UHCI_DMA_IN_LINK_INLINK_STOP_Msk = 0x10000000
	// Bit INLINK_STOP.
	UHCI_DMA_IN_LINK_INLINK_STOP = 0x10000000
	// Position of INLINK_START field.
	UHCI_DMA_IN_LINK_INLINK_START_Pos = 0x1d
	// Bit mask of INLINK_START field.
	UHCI_DMA_IN_LINK_INLINK_START_Msk = 0x20000000
	// Bit INLINK_START.
	UHCI_DMA_IN_LINK_INLINK_START = 0x20000000
	// Position of INLINK_RESTART field.
	UHCI_DMA_IN_LINK_INLINK_RESTART_Pos = 0x1e
	// Bit mask of INLINK_RESTART field.
	UHCI_DMA_IN_LINK_INLINK_RESTART_Msk = 0x40000000
	// Bit INLINK_RESTART.
	UHCI_DMA_IN_LINK_INLINK_RESTART = 0x40000000
	// Position of INLINK_PARK field.
	UHCI_DMA_IN_LINK_INLINK_PARK_Pos = 0x1f
	// Bit mask of INLINK_PARK field.
	UHCI_DMA_IN_LINK_INLINK_PARK_Msk = 0x80000000
	// Bit INLINK_PARK.
	UHCI_DMA_IN_LINK_INLINK_PARK = 0x80000000

	// CONF1: UHCI configuration register
	// Position of CHECK_SUM_EN field.
	UHCI_CONF1_CHECK_SUM_EN_Pos = 0x0
	// Bit mask of CHECK_SUM_EN field.
	UHCI_CONF1_CHECK_SUM_EN_Msk = 0x1
	// Bit CHECK_SUM_EN.
	UHCI_CONF1_CHECK_SUM_EN = 0x1
	// Position of CHECK_SEQ_EN field.
	UHCI_CONF1_CHECK_SEQ_EN_Pos = 0x1
	// Bit mask of CHECK_SEQ_EN field.
	UHCI_CONF1_CHECK_SEQ_EN_Msk = 0x2
	// Bit CHECK_SEQ_EN.
	UHCI_CONF1_CHECK_SEQ_EN = 0x2
	// Position of CRC_DISABLE field.
	UHCI_CONF1_CRC_DISABLE_Pos = 0x2
	// Bit mask of CRC_DISABLE field.
	UHCI_CONF1_CRC_DISABLE_Msk = 0x4
	// Bit CRC_DISABLE.
	UHCI_CONF1_CRC_DISABLE = 0x4
	// Position of SAVE_HEAD field.
	UHCI_CONF1_SAVE_HEAD_Pos = 0x3
	// Bit mask of SAVE_HEAD field.
	UHCI_CONF1_SAVE_HEAD_Msk = 0x8
	// Bit SAVE_HEAD.
	UHCI_CONF1_SAVE_HEAD = 0x8
	// Position of TX_CHECK_SUM_RE field.
	UHCI_CONF1_TX_CHECK_SUM_RE_Pos = 0x4
	// Bit mask of TX_CHECK_SUM_RE field.
	UHCI_CONF1_TX_CHECK_SUM_RE_Msk = 0x10
	// Bit TX_CHECK_SUM_RE.
	UHCI_CONF1_TX_CHECK_SUM_RE = 0x10
	// Position of TX_ACK_NUM_RE field.
	UHCI_CONF1_TX_ACK_NUM_RE_Pos = 0x5
	// Bit mask of TX_ACK_NUM_RE field.
	UHCI_CONF1_TX_ACK_NUM_RE_Msk = 0x20
	// Bit TX_ACK_NUM_RE.
	UHCI_CONF1_TX_ACK_NUM_RE = 0x20
	// Position of CHECK_OWNER field.
	UHCI_CONF1_CHECK_OWNER_Pos = 0x6
	// Bit mask of CHECK_OWNER field.
	UHCI_CONF1_CHECK_OWNER_Msk = 0x40
	// Bit CHECK_OWNER.
	UHCI_CONF1_CHECK_OWNER = 0x40
	// Position of WAIT_SW_START field.
	UHCI_CONF1_WAIT_SW_START_Pos = 0x7
	// Bit mask of WAIT_SW_START field.
	UHCI_CONF1_WAIT_SW_START_Msk = 0x80
	// Bit WAIT_SW_START.
	UHCI_CONF1_WAIT_SW_START = 0x80
	// Position of SW_START field.
	UHCI_CONF1_SW_START_Pos = 0x8
	// Bit mask of SW_START field.
	UHCI_CONF1_SW_START_Msk = 0x100
	// Bit SW_START.
	UHCI_CONF1_SW_START = 0x100
	// Position of DMA_INFIFO_FULL_THRS field.
	UHCI_CONF1_DMA_INFIFO_FULL_THRS_Pos = 0x9
	// Bit mask of DMA_INFIFO_FULL_THRS field.
	UHCI_CONF1_DMA_INFIFO_FULL_THRS_Msk = 0x1ffe00

	// STATE0: UHCI decoder status register
	// Position of INLINK_DSCR_ADDR field.
	UHCI_STATE0_INLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of INLINK_DSCR_ADDR field.
	UHCI_STATE0_INLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of IN_DSCR_STATE field.
	UHCI_STATE0_IN_DSCR_STATE_Pos = 0x12
	// Bit mask of IN_DSCR_STATE field.
	UHCI_STATE0_IN_DSCR_STATE_Msk = 0xc0000
	// Position of IN_STATE field.
	UHCI_STATE0_IN_STATE_Pos = 0x14
	// Bit mask of IN_STATE field.
	UHCI_STATE0_IN_STATE_Msk = 0x700000
	// Position of INFIFO_CNT_DEBUG field.
	UHCI_STATE0_INFIFO_CNT_DEBUG_Pos = 0x17
	// Bit mask of INFIFO_CNT_DEBUG field.
	UHCI_STATE0_INFIFO_CNT_DEBUG_Msk = 0xf800000
	// Position of DECODE_STATE field.
	UHCI_STATE0_DECODE_STATE_Pos = 0x1c
	// Bit mask of DECODE_STATE field.
	UHCI_STATE0_DECODE_STATE_Msk = 0x70000000

	// STATE1: UHCI encoder status register
	// Position of OUTLINK_DSCR_ADDR field.
	UHCI_STATE1_OUTLINK_DSCR_ADDR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_ADDR field.
	UHCI_STATE1_OUTLINK_DSCR_ADDR_Msk = 0x3ffff
	// Position of OUT_DSCR_STATE field.
	UHCI_STATE1_OUT_DSCR_STATE_Pos = 0x12
	// Bit mask of OUT_DSCR_STATE field.
	UHCI_STATE1_OUT_DSCR_STATE_Msk = 0xc0000
	// Position of OUT_STATE field.
	UHCI_STATE1_OUT_STATE_Pos = 0x14
	// Bit mask of OUT_STATE field.
	UHCI_STATE1_OUT_STATE_Msk = 0x700000
	// Position of OUTFIFO_CNT field.
	UHCI_STATE1_OUTFIFO_CNT_Pos = 0x17
	// Bit mask of OUTFIFO_CNT field.
	UHCI_STATE1_OUTFIFO_CNT_Msk = 0xf800000
	// Position of ENCODE_STATE field.
	UHCI_STATE1_ENCODE_STATE_Pos = 0x1c
	// Bit mask of ENCODE_STATE field.
	UHCI_STATE1_ENCODE_STATE_Msk = 0x70000000

	// DMA_OUT_EOF_DES_ADDR: Outlink descriptor address when EOF occurs
	// Position of OUT_EOF_DES_ADDR field.
	UHCI_DMA_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_DES_ADDR field.
	UHCI_DMA_OUT_EOF_DES_ADDR_OUT_EOF_DES_ADDR_Msk = 0xffffffff

	// DMA_IN_SUC_EOF_DES_ADDR: Inlink descriptor address when EOF occurs
	// Position of IN_SUC_EOF_DES_ADDR field.
	UHCI_DMA_IN_SUC_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_SUC_EOF_DES_ADDR field.
	UHCI_DMA_IN_SUC_EOF_DES_ADDR_IN_SUC_EOF_DES_ADDR_Msk = 0xffffffff

	// DMA_IN_ERR_EOF_DES_ADDR: Inlink descriptor address when errors occur
	// Position of IN_ERR_EOF_DES_ADDR field.
	UHCI_DMA_IN_ERR_EOF_DES_ADDR_IN_ERR_EOF_DES_ADDR_Pos = 0x0
	// Bit mask of IN_ERR_EOF_DES_ADDR field.
	UHCI_DMA_IN_ERR_EOF_DES_ADDR_IN_ERR_EOF_DES_ADDR_Msk = 0xffffffff

	// DMA_OUT_EOF_BFR_DES_ADDR: Outlink descriptor address before the last transmit descriptor
	// Position of OUT_EOF_BFR_DES_ADDR field.
	UHCI_DMA_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Pos = 0x0
	// Bit mask of OUT_EOF_BFR_DES_ADDR field.
	UHCI_DMA_OUT_EOF_BFR_DES_ADDR_OUT_EOF_BFR_DES_ADDR_Msk = 0xffffffff

	// AHB_TEST: AHB test register
	// Position of AHB_TESTMODE field.
	UHCI_AHB_TEST_AHB_TESTMODE_Pos = 0x0
	// Bit mask of AHB_TESTMODE field.
	UHCI_AHB_TEST_AHB_TESTMODE_Msk = 0x7
	// Position of AHB_TESTADDR field.
	UHCI_AHB_TEST_AHB_TESTADDR_Pos = 0x4
	// Bit mask of AHB_TESTADDR field.
	UHCI_AHB_TEST_AHB_TESTADDR_Msk = 0x30

	// DMA_IN_DSCR: The third word of the next receive descriptor
	// Position of INLINK_DSCR field.
	UHCI_DMA_IN_DSCR_INLINK_DSCR_Pos = 0x0
	// Bit mask of INLINK_DSCR field.
	UHCI_DMA_IN_DSCR_INLINK_DSCR_Msk = 0xffffffff

	// DMA_IN_DSCR_BF0: The third word of current receive descriptor
	// Position of INLINK_DSCR_BF0 field.
	UHCI_DMA_IN_DSCR_BF0_INLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of INLINK_DSCR_BF0 field.
	UHCI_DMA_IN_DSCR_BF0_INLINK_DSCR_BF0_Msk = 0xffffffff

	// DMA_OUT_DSCR: The third word of the next transmit descriptor
	// Position of OUTLINK_DSCR field.
	UHCI_DMA_OUT_DSCR_OUTLINK_DSCR_Pos = 0x0
	// Bit mask of OUTLINK_DSCR field.
	UHCI_DMA_OUT_DSCR_OUTLINK_DSCR_Msk = 0xffffffff

	// DMA_OUT_DSCR_BF0: The third word of current transmit descriptor
	// Position of OUTLINK_DSCR_BF0 field.
	UHCI_DMA_OUT_DSCR_BF0_OUTLINK_DSCR_BF0_Pos = 0x0
	// Bit mask of OUTLINK_DSCR_BF0 field.
	UHCI_DMA_OUT_DSCR_BF0_OUTLINK_DSCR_BF0_Msk = 0xffffffff

	// ESCAPE_CONF: Escape character configuration
	// Position of TX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_C0_ESC_EN_Pos = 0x0
	// Bit mask of TX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_C0_ESC_EN_Msk = 0x1
	// Bit TX_C0_ESC_EN.
	UHCI_ESCAPE_CONF_TX_C0_ESC_EN = 0x1
	// Position of TX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_DB_ESC_EN_Pos = 0x1
	// Bit mask of TX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_DB_ESC_EN_Msk = 0x2
	// Bit TX_DB_ESC_EN.
	UHCI_ESCAPE_CONF_TX_DB_ESC_EN = 0x2
	// Position of TX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_11_ESC_EN_Pos = 0x2
	// Bit mask of TX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_11_ESC_EN_Msk = 0x4
	// Bit TX_11_ESC_EN.
	UHCI_ESCAPE_CONF_TX_11_ESC_EN = 0x4
	// Position of TX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_13_ESC_EN_Pos = 0x3
	// Bit mask of TX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_TX_13_ESC_EN_Msk = 0x8
	// Bit TX_13_ESC_EN.
	UHCI_ESCAPE_CONF_TX_13_ESC_EN = 0x8
	// Position of RX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_C0_ESC_EN_Pos = 0x4
	// Bit mask of RX_C0_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_C0_ESC_EN_Msk = 0x10
	// Bit RX_C0_ESC_EN.
	UHCI_ESCAPE_CONF_RX_C0_ESC_EN = 0x10
	// Position of RX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_DB_ESC_EN_Pos = 0x5
	// Bit mask of RX_DB_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_DB_ESC_EN_Msk = 0x20
	// Bit RX_DB_ESC_EN.
	UHCI_ESCAPE_CONF_RX_DB_ESC_EN = 0x20
	// Position of RX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_11_ESC_EN_Pos = 0x6
	// Bit mask of RX_11_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_11_ESC_EN_Msk = 0x40
	// Bit RX_11_ESC_EN.
	UHCI_ESCAPE_CONF_RX_11_ESC_EN = 0x40
	// Position of RX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_13_ESC_EN_Pos = 0x7
	// Bit mask of RX_13_ESC_EN field.
	UHCI_ESCAPE_CONF_RX_13_ESC_EN_Msk = 0x80
	// Bit RX_13_ESC_EN.
	UHCI_ESCAPE_CONF_RX_13_ESC_EN = 0x80

	// HUNG_CONF: Timeout configuration
	// Position of TXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_Pos = 0x0
	// Bit mask of TXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_Msk = 0xff
	// Position of TXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_SHIFT_Pos = 0x8
	// Bit mask of TXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_SHIFT_Msk = 0x700
	// Position of TXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_ENA_Pos = 0xb
	// Bit mask of TXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_ENA_Msk = 0x800
	// Bit TXFIFO_TIMEOUT_ENA.
	UHCI_HUNG_CONF_TXFIFO_TIMEOUT_ENA = 0x800
	// Position of RXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_Pos = 0xc
	// Bit mask of RXFIFO_TIMEOUT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_Msk = 0xff000
	// Position of RXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_SHIFT_Pos = 0x14
	// Bit mask of RXFIFO_TIMEOUT_SHIFT field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_SHIFT_Msk = 0x700000
	// Position of RXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_ENA_Pos = 0x17
	// Bit mask of RXFIFO_TIMEOUT_ENA field.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_ENA_Msk = 0x800000
	// Bit RXFIFO_TIMEOUT_ENA.
	UHCI_HUNG_CONF_RXFIFO_TIMEOUT_ENA = 0x800000

	// RX_HEAD: UHCI packet header register
	// Position of RX_HEAD field.
	UHCI_RX_HEAD_RX_HEAD_Pos = 0x0
	// Bit mask of RX_HEAD field.
	UHCI_RX_HEAD_RX_HEAD_Msk = 0xffffffff

	// QUICK_SENT: UHCI quick_sent configuration register
	// Position of SINGLE_SEND_NUM field.
	UHCI_QUICK_SENT_SINGLE_SEND_NUM_Pos = 0x0
	// Bit mask of SINGLE_SEND_NUM field.
	UHCI_QUICK_SENT_SINGLE_SEND_NUM_Msk = 0x7
	// Position of SINGLE_SEND_EN field.
	UHCI_QUICK_SENT_SINGLE_SEND_EN_Pos = 0x3
	// Bit mask of SINGLE_SEND_EN field.
	UHCI_QUICK_SENT_SINGLE_SEND_EN_Msk = 0x8
	// Bit SINGLE_SEND_EN.
	UHCI_QUICK_SENT_SINGLE_SEND_EN = 0x8
	// Position of ALWAYS_SEND_NUM field.
	UHCI_QUICK_SENT_ALWAYS_SEND_NUM_Pos = 0x4
	// Bit mask of ALWAYS_SEND_NUM field.
	UHCI_QUICK_SENT_ALWAYS_SEND_NUM_Msk = 0x70
	// Position of ALWAYS_SEND_EN field.
	UHCI_QUICK_SENT_ALWAYS_SEND_EN_Pos = 0x7
	// Bit mask of ALWAYS_SEND_EN field.
	UHCI_QUICK_SENT_ALWAYS_SEND_EN_Msk = 0x80
	// Bit ALWAYS_SEND_EN.
	UHCI_QUICK_SENT_ALWAYS_SEND_EN = 0x80

	// Q0_WORD0: Q0_WORD0 quick_sent register
	// Position of SEND_Q0_WORD0 field.
	UHCI_Q0_WORD0_SEND_Q0_WORD0_Pos = 0x0
	// Bit mask of SEND_Q0_WORD0 field.
	UHCI_Q0_WORD0_SEND_Q0_WORD0_Msk = 0xffffffff

	// Q0_WORD1: Q0_WORD1 quick_sent register
	// Position of SEND_Q0_WORD1 field.
	UHCI_Q0_WORD1_SEND_Q0_WORD1_Pos = 0x0
	// Bit mask of SEND_Q0_WORD1 field.
	UHCI_Q0_WORD1_SEND_Q0_WORD1_Msk = 0xffffffff

	// Q1_WORD0: Q1_WORD0 quick_sent register
	// Position of SEND_Q1_WORD0 field.
	UHCI_Q1_WORD0_SEND_Q1_WORD0_Pos = 0x0
	// Bit mask of SEND_Q1_WORD0 field.
	UHCI_Q1_WORD0_SEND_Q1_WORD0_Msk = 0xffffffff

	// Q1_WORD1: Q1_WORD1 quick_sent register
	// Position of SEND_Q1_WORD1 field.
	UHCI_Q1_WORD1_SEND_Q1_WORD1_Pos = 0x0
	// Bit mask of SEND_Q1_WORD1 field.
	UHCI_Q1_WORD1_SEND_Q1_WORD1_Msk = 0xffffffff

	// Q2_WORD0: Q2_WORD0 quick_sent register
	// Position of SEND_Q2_WORD0 field.
	UHCI_Q2_WORD0_SEND_Q2_WORD0_Pos = 0x0
	// Bit mask of SEND_Q2_WORD0 field.
	UHCI_Q2_WORD0_SEND_Q2_WORD0_Msk = 0xffffffff

	// Q2_WORD1: Q2_WORD1 quick_sent register
	// Position of SEND_Q2_WORD1 field.
	UHCI_Q2_WORD1_SEND_Q2_WORD1_Pos = 0x0
	// Bit mask of SEND_Q2_WORD1 field.
	UHCI_Q2_WORD1_SEND_Q2_WORD1_Msk = 0xffffffff

	// Q3_WORD0: Q3_WORD0 quick_sent register
	// Position of SEND_Q3_WORD0 field.
	UHCI_Q3_WORD0_SEND_Q3_WORD0_Pos = 0x0
	// Bit mask of SEND_Q3_WORD0 field.
	UHCI_Q3_WORD0_SEND_Q3_WORD0_Msk = 0xffffffff

	// Q3_WORD1: Q3_WORD1 quick_sent register
	// Position of SEND_Q3_WORD1 field.
	UHCI_Q3_WORD1_SEND_Q3_WORD1_Pos = 0x0
	// Bit mask of SEND_Q3_WORD1 field.
	UHCI_Q3_WORD1_SEND_Q3_WORD1_Msk = 0xffffffff

	// Q4_WORD0: Q4_WORD0 quick_sent register
	// Position of SEND_Q4_WORD0 field.
	UHCI_Q4_WORD0_SEND_Q4_WORD0_Pos = 0x0
	// Bit mask of SEND_Q4_WORD0 field.
	UHCI_Q4_WORD0_SEND_Q4_WORD0_Msk = 0xffffffff

	// Q4_WORD1: Q4_WORD1 quick_sent register
	// Position of SEND_Q4_WORD1 field.
	UHCI_Q4_WORD1_SEND_Q4_WORD1_Pos = 0x0
	// Bit mask of SEND_Q4_WORD1 field.
	UHCI_Q4_WORD1_SEND_Q4_WORD1_Msk = 0xffffffff

	// Q5_WORD0: Q5_WORD0 quick_sent register
	// Position of SEND_Q5_WORD0 field.
	UHCI_Q5_WORD0_SEND_Q5_WORD0_Pos = 0x0
	// Bit mask of SEND_Q5_WORD0 field.
	UHCI_Q5_WORD0_SEND_Q5_WORD0_Msk = 0xffffffff

	// Q5_WORD1: Q5_WORD1 quick_sent register
	// Position of SEND_Q5_WORD1 field.
	UHCI_Q5_WORD1_SEND_Q5_WORD1_Pos = 0x0
	// Bit mask of SEND_Q5_WORD1 field.
	UHCI_Q5_WORD1_SEND_Q5_WORD1_Msk = 0xffffffff

	// Q6_WORD0: Q6_WORD0 quick_sent register
	// Position of SEND_Q6_WORD0 field.
	UHCI_Q6_WORD0_SEND_Q6_WORD0_Pos = 0x0
	// Bit mask of SEND_Q6_WORD0 field.
	UHCI_Q6_WORD0_SEND_Q6_WORD0_Msk = 0xffffffff

	// Q6_WORD1: Q6_WORD1 quick_sent register
	// Position of SEND_Q6_WORD1 field.
	UHCI_Q6_WORD1_SEND_Q6_WORD1_Pos = 0x0
	// Bit mask of SEND_Q6_WORD1 field.
	UHCI_Q6_WORD1_SEND_Q6_WORD1_Msk = 0xffffffff

	// ESC_CONF0: Escape sequence configuration register 0
	// Position of SEPER_CHAR field.
	UHCI_ESC_CONF0_SEPER_CHAR_Pos = 0x0
	// Bit mask of SEPER_CHAR field.
	UHCI_ESC_CONF0_SEPER_CHAR_Msk = 0xff
	// Position of SEPER_ESC_CHAR0 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR0_Pos = 0x8
	// Bit mask of SEPER_ESC_CHAR0 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR0_Msk = 0xff00
	// Position of SEPER_ESC_CHAR1 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR1_Pos = 0x10
	// Bit mask of SEPER_ESC_CHAR1 field.
	UHCI_ESC_CONF0_SEPER_ESC_CHAR1_Msk = 0xff0000

	// ESC_CONF1: Escape sequence configuration register 1
	// Position of ESC_SEQ0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_Pos = 0x0
	// Bit mask of ESC_SEQ0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_Msk = 0xff
	// Position of ESC_SEQ0_CHAR0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ0_CHAR0 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ0_CHAR1 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ0_CHAR1 field.
	UHCI_ESC_CONF1_ESC_SEQ0_CHAR1_Msk = 0xff0000

	// ESC_CONF2: Escape sequence configuration register 2
	// Position of ESC_SEQ1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_Pos = 0x0
	// Bit mask of ESC_SEQ1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_Msk = 0xff
	// Position of ESC_SEQ1_CHAR0 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ1_CHAR0 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ1_CHAR1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ1_CHAR1 field.
	UHCI_ESC_CONF2_ESC_SEQ1_CHAR1_Msk = 0xff0000

	// ESC_CONF3: Escape sequence configuration register 3
	// Position of ESC_SEQ2 field.
	UHCI_ESC_CONF3_ESC_SEQ2_Pos = 0x0
	// Bit mask of ESC_SEQ2 field.
	UHCI_ESC_CONF3_ESC_SEQ2_Msk = 0xff
	// Position of ESC_SEQ2_CHAR0 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR0_Pos = 0x8
	// Bit mask of ESC_SEQ2_CHAR0 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR0_Msk = 0xff00
	// Position of ESC_SEQ2_CHAR1 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR1_Pos = 0x10
	// Bit mask of ESC_SEQ2_CHAR1 field.
	UHCI_ESC_CONF3_ESC_SEQ2_CHAR1_Msk = 0xff0000

	// PKT_THRES: Configure register for packet length
	// Position of PKT_THRS field.
	UHCI_PKT_THRES_PKT_THRS_Pos = 0x0
	// Bit mask of PKT_THRS field.
	UHCI_PKT_THRES_PKT_THRS_Msk = 0x1fff

	// DATE: UHCI version control register
	// Position of DATE field.
	UHCI_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	UHCI_DATE_DATE_Msk = 0xffffffff
)

// Constants for USB0: USB OTG (On-The-Go)
const (
	// GOTGCTL
	// Position of SESREQSCS field.
	USB_GOTGCTL_SESREQSCS_Pos = 0x0
	// Bit mask of SESREQSCS field.
	USB_GOTGCTL_SESREQSCS_Msk = 0x1
	// Bit SESREQSCS.
	USB_GOTGCTL_SESREQSCS = 0x1
	// Position of SESREQ field.
	USB_GOTGCTL_SESREQ_Pos = 0x1
	// Bit mask of SESREQ field.
	USB_GOTGCTL_SESREQ_Msk = 0x2
	// Bit SESREQ.
	USB_GOTGCTL_SESREQ = 0x2
	// Position of VBVALIDOVEN field.
	USB_GOTGCTL_VBVALIDOVEN_Pos = 0x2
	// Bit mask of VBVALIDOVEN field.
	USB_GOTGCTL_VBVALIDOVEN_Msk = 0x4
	// Bit VBVALIDOVEN.
	USB_GOTGCTL_VBVALIDOVEN = 0x4
	// Position of VBVALIDOVVAL field.
	USB_GOTGCTL_VBVALIDOVVAL_Pos = 0x3
	// Bit mask of VBVALIDOVVAL field.
	USB_GOTGCTL_VBVALIDOVVAL_Msk = 0x8
	// Bit VBVALIDOVVAL.
	USB_GOTGCTL_VBVALIDOVVAL = 0x8
	// Position of AVALIDOVEN field.
	USB_GOTGCTL_AVALIDOVEN_Pos = 0x4
	// Bit mask of AVALIDOVEN field.
	USB_GOTGCTL_AVALIDOVEN_Msk = 0x10
	// Bit AVALIDOVEN.
	USB_GOTGCTL_AVALIDOVEN = 0x10
	// Position of AVALIDOVVAL field.
	USB_GOTGCTL_AVALIDOVVAL_Pos = 0x5
	// Bit mask of AVALIDOVVAL field.
	USB_GOTGCTL_AVALIDOVVAL_Msk = 0x20
	// Bit AVALIDOVVAL.
	USB_GOTGCTL_AVALIDOVVAL = 0x20
	// Position of BVALIDOVEN field.
	USB_GOTGCTL_BVALIDOVEN_Pos = 0x6
	// Bit mask of BVALIDOVEN field.
	USB_GOTGCTL_BVALIDOVEN_Msk = 0x40
	// Bit BVALIDOVEN.
	USB_GOTGCTL_BVALIDOVEN = 0x40
	// Position of BVALIDOVVAL field.
	USB_GOTGCTL_BVALIDOVVAL_Pos = 0x7
	// Bit mask of BVALIDOVVAL field.
	USB_GOTGCTL_BVALIDOVVAL_Msk = 0x80
	// Bit BVALIDOVVAL.
	USB_GOTGCTL_BVALIDOVVAL = 0x80
	// Position of HSTNEGSCS field.
	USB_GOTGCTL_HSTNEGSCS_Pos = 0x8
	// Bit mask of HSTNEGSCS field.
	USB_GOTGCTL_HSTNEGSCS_Msk = 0x100
	// Bit HSTNEGSCS.
	USB_GOTGCTL_HSTNEGSCS = 0x100
	// Position of HNPREQ field.
	USB_GOTGCTL_HNPREQ_Pos = 0x9
	// Bit mask of HNPREQ field.
	USB_GOTGCTL_HNPREQ_Msk = 0x200
	// Bit HNPREQ.
	USB_GOTGCTL_HNPREQ = 0x200
	// Position of HSTSETHNPEN field.
	USB_GOTGCTL_HSTSETHNPEN_Pos = 0xa
	// Bit mask of HSTSETHNPEN field.
	USB_GOTGCTL_HSTSETHNPEN_Msk = 0x400
	// Bit HSTSETHNPEN.
	USB_GOTGCTL_HSTSETHNPEN = 0x400
	// Position of DEVHNPEN field.
	USB_GOTGCTL_DEVHNPEN_Pos = 0xb
	// Bit mask of DEVHNPEN field.
	USB_GOTGCTL_DEVHNPEN_Msk = 0x800
	// Bit DEVHNPEN.
	USB_GOTGCTL_DEVHNPEN = 0x800
	// Position of EHEN field.
	USB_GOTGCTL_EHEN_Pos = 0xc
	// Bit mask of EHEN field.
	USB_GOTGCTL_EHEN_Msk = 0x1000
	// Bit EHEN.
	USB_GOTGCTL_EHEN = 0x1000
	// Position of DBNCEFLTRBYPASS field.
	USB_GOTGCTL_DBNCEFLTRBYPASS_Pos = 0xf
	// Bit mask of DBNCEFLTRBYPASS field.
	USB_GOTGCTL_DBNCEFLTRBYPASS_Msk = 0x8000
	// Bit DBNCEFLTRBYPASS.
	USB_GOTGCTL_DBNCEFLTRBYPASS = 0x8000
	// Position of CONIDSTS field.
	USB_GOTGCTL_CONIDSTS_Pos = 0x10
	// Bit mask of CONIDSTS field.
	USB_GOTGCTL_CONIDSTS_Msk = 0x10000
	// Bit CONIDSTS.
	USB_GOTGCTL_CONIDSTS = 0x10000
	// Position of DBNCTIME field.
	USB_GOTGCTL_DBNCTIME_Pos = 0x11
	// Bit mask of DBNCTIME field.
	USB_GOTGCTL_DBNCTIME_Msk = 0x20000
	// Bit DBNCTIME.
	USB_GOTGCTL_DBNCTIME = 0x20000
	// Position of ASESVLD field.
	USB_GOTGCTL_ASESVLD_Pos = 0x12
	// Bit mask of ASESVLD field.
	USB_GOTGCTL_ASESVLD_Msk = 0x40000
	// Bit ASESVLD.
	USB_GOTGCTL_ASESVLD = 0x40000
	// Position of BSESVLD field.
	USB_GOTGCTL_BSESVLD_Pos = 0x13
	// Bit mask of BSESVLD field.
	USB_GOTGCTL_BSESVLD_Msk = 0x80000
	// Bit BSESVLD.
	USB_GOTGCTL_BSESVLD = 0x80000
	// Position of OTGVER field.
	USB_GOTGCTL_OTGVER_Pos = 0x14
	// Bit mask of OTGVER field.
	USB_GOTGCTL_OTGVER_Msk = 0x100000
	// Bit OTGVER.
	USB_GOTGCTL_OTGVER = 0x100000
	// Position of CURMOD field.
	USB_GOTGCTL_CURMOD_Pos = 0x15
	// Bit mask of CURMOD field.
	USB_GOTGCTL_CURMOD_Msk = 0x200000
	// Bit CURMOD.
	USB_GOTGCTL_CURMOD = 0x200000

	// GOTGINT
	// Position of SESENDDET field.
	USB_GOTGINT_SESENDDET_Pos = 0x2
	// Bit mask of SESENDDET field.
	USB_GOTGINT_SESENDDET_Msk = 0x4
	// Bit SESENDDET.
	USB_GOTGINT_SESENDDET = 0x4
	// Position of SESREQSUCSTSCHNG field.
	USB_GOTGINT_SESREQSUCSTSCHNG_Pos = 0x8
	// Bit mask of SESREQSUCSTSCHNG field.
	USB_GOTGINT_SESREQSUCSTSCHNG_Msk = 0x100
	// Bit SESREQSUCSTSCHNG.
	USB_GOTGINT_SESREQSUCSTSCHNG = 0x100
	// Position of HSTNEGSUCSTSCHNG field.
	USB_GOTGINT_HSTNEGSUCSTSCHNG_Pos = 0x9
	// Bit mask of HSTNEGSUCSTSCHNG field.
	USB_GOTGINT_HSTNEGSUCSTSCHNG_Msk = 0x200
	// Bit HSTNEGSUCSTSCHNG.
	USB_GOTGINT_HSTNEGSUCSTSCHNG = 0x200
	// Position of HSTNEGDET field.
	USB_GOTGINT_HSTNEGDET_Pos = 0x11
	// Bit mask of HSTNEGDET field.
	USB_GOTGINT_HSTNEGDET_Msk = 0x20000
	// Bit HSTNEGDET.
	USB_GOTGINT_HSTNEGDET = 0x20000
	// Position of ADEVTOUTCHG field.
	USB_GOTGINT_ADEVTOUTCHG_Pos = 0x12
	// Bit mask of ADEVTOUTCHG field.
	USB_GOTGINT_ADEVTOUTCHG_Msk = 0x40000
	// Bit ADEVTOUTCHG.
	USB_GOTGINT_ADEVTOUTCHG = 0x40000
	// Position of DBNCEDONE field.
	USB_GOTGINT_DBNCEDONE_Pos = 0x13
	// Bit mask of DBNCEDONE field.
	USB_GOTGINT_DBNCEDONE_Msk = 0x80000
	// Bit DBNCEDONE.
	USB_GOTGINT_DBNCEDONE = 0x80000

	// GAHBCFG
	// Position of GLBLLNTRMSK field.
	USB_GAHBCFG_GLBLLNTRMSK_Pos = 0x0
	// Bit mask of GLBLLNTRMSK field.
	USB_GAHBCFG_GLBLLNTRMSK_Msk = 0x1
	// Bit GLBLLNTRMSK.
	USB_GAHBCFG_GLBLLNTRMSK = 0x1
	// Position of HBSTLEN field.
	USB_GAHBCFG_HBSTLEN_Pos = 0x1
	// Bit mask of HBSTLEN field.
	USB_GAHBCFG_HBSTLEN_Msk = 0x1e
	// Position of DMAEN field.
	USB_GAHBCFG_DMAEN_Pos = 0x5
	// Bit mask of DMAEN field.
	USB_GAHBCFG_DMAEN_Msk = 0x20
	// Bit DMAEN.
	USB_GAHBCFG_DMAEN = 0x20
	// Position of NPTXFEMPLVL field.
	USB_GAHBCFG_NPTXFEMPLVL_Pos = 0x7
	// Bit mask of NPTXFEMPLVL field.
	USB_GAHBCFG_NPTXFEMPLVL_Msk = 0x80
	// Bit NPTXFEMPLVL.
	USB_GAHBCFG_NPTXFEMPLVL = 0x80
	// Position of PTXFEMPLVL field.
	USB_GAHBCFG_PTXFEMPLVL_Pos = 0x8
	// Bit mask of PTXFEMPLVL field.
	USB_GAHBCFG_PTXFEMPLVL_Msk = 0x100
	// Bit PTXFEMPLVL.
	USB_GAHBCFG_PTXFEMPLVL = 0x100
	// Position of REMMEMSUPP field.
	USB_GAHBCFG_REMMEMSUPP_Pos = 0x15
	// Bit mask of REMMEMSUPP field.
	USB_GAHBCFG_REMMEMSUPP_Msk = 0x200000
	// Bit REMMEMSUPP.
	USB_GAHBCFG_REMMEMSUPP = 0x200000
	// Position of NOTIALLDMAWRIT field.
	USB_GAHBCFG_NOTIALLDMAWRIT_Pos = 0x16
	// Bit mask of NOTIALLDMAWRIT field.
	USB_GAHBCFG_NOTIALLDMAWRIT_Msk = 0x400000
	// Bit NOTIALLDMAWRIT.
	USB_GAHBCFG_NOTIALLDMAWRIT = 0x400000
	// Position of AHBSINGLE field.
	USB_GAHBCFG_AHBSINGLE_Pos = 0x17
	// Bit mask of AHBSINGLE field.
	USB_GAHBCFG_AHBSINGLE_Msk = 0x800000
	// Bit AHBSINGLE.
	USB_GAHBCFG_AHBSINGLE = 0x800000
	// Position of INVDESCENDIANESS field.
	USB_GAHBCFG_INVDESCENDIANESS_Pos = 0x18
	// Bit mask of INVDESCENDIANESS field.
	USB_GAHBCFG_INVDESCENDIANESS_Msk = 0x1000000
	// Bit INVDESCENDIANESS.
	USB_GAHBCFG_INVDESCENDIANESS = 0x1000000

	// GUSBCFG
	// Position of TOUTCAL field.
	USB_GUSBCFG_TOUTCAL_Pos = 0x0
	// Bit mask of TOUTCAL field.
	USB_GUSBCFG_TOUTCAL_Msk = 0x7
	// Position of PHYIF field.
	USB_GUSBCFG_PHYIF_Pos = 0x3
	// Bit mask of PHYIF field.
	USB_GUSBCFG_PHYIF_Msk = 0x8
	// Bit PHYIF.
	USB_GUSBCFG_PHYIF = 0x8
	// Position of ULPI_UTMI_SEL field.
	USB_GUSBCFG_ULPI_UTMI_SEL_Pos = 0x4
	// Bit mask of ULPI_UTMI_SEL field.
	USB_GUSBCFG_ULPI_UTMI_SEL_Msk = 0x10
	// Bit ULPI_UTMI_SEL.
	USB_GUSBCFG_ULPI_UTMI_SEL = 0x10
	// Position of FSINTF field.
	USB_GUSBCFG_FSINTF_Pos = 0x5
	// Bit mask of FSINTF field.
	USB_GUSBCFG_FSINTF_Msk = 0x20
	// Bit FSINTF.
	USB_GUSBCFG_FSINTF = 0x20
	// Position of PHYSEL field.
	USB_GUSBCFG_PHYSEL_Pos = 0x6
	// Bit mask of PHYSEL field.
	USB_GUSBCFG_PHYSEL_Msk = 0x40
	// Bit PHYSEL.
	USB_GUSBCFG_PHYSEL = 0x40
	// Position of SRPCAP field.
	USB_GUSBCFG_SRPCAP_Pos = 0x8
	// Bit mask of SRPCAP field.
	USB_GUSBCFG_SRPCAP_Msk = 0x100
	// Bit SRPCAP.
	USB_GUSBCFG_SRPCAP = 0x100
	// Position of HNPCAP field.
	USB_GUSBCFG_HNPCAP_Pos = 0x9
	// Bit mask of HNPCAP field.
	USB_GUSBCFG_HNPCAP_Msk = 0x200
	// Bit HNPCAP.
	USB_GUSBCFG_HNPCAP = 0x200
	// Position of USBTRDTIM field.
	USB_GUSBCFG_USBTRDTIM_Pos = 0xa
	// Bit mask of USBTRDTIM field.
	USB_GUSBCFG_USBTRDTIM_Msk = 0x3c00
	// Position of TERMSELDLPULSE field.
	USB_GUSBCFG_TERMSELDLPULSE_Pos = 0x16
	// Bit mask of TERMSELDLPULSE field.
	USB_GUSBCFG_TERMSELDLPULSE_Msk = 0x400000
	// Bit TERMSELDLPULSE.
	USB_GUSBCFG_TERMSELDLPULSE = 0x400000
	// Position of TXENDDELAY field.
	USB_GUSBCFG_TXENDDELAY_Pos = 0x1c
	// Bit mask of TXENDDELAY field.
	USB_GUSBCFG_TXENDDELAY_Msk = 0x10000000
	// Bit TXENDDELAY.
	USB_GUSBCFG_TXENDDELAY = 0x10000000
	// Position of FORCEHSTMODE field.
	USB_GUSBCFG_FORCEHSTMODE_Pos = 0x1d
	// Bit mask of FORCEHSTMODE field.
	USB_GUSBCFG_FORCEHSTMODE_Msk = 0x20000000
	// Bit FORCEHSTMODE.
	USB_GUSBCFG_FORCEHSTMODE = 0x20000000
	// Position of FORCEDEVMODE field.
	USB_GUSBCFG_FORCEDEVMODE_Pos = 0x1e
	// Bit mask of FORCEDEVMODE field.
	USB_GUSBCFG_FORCEDEVMODE_Msk = 0x40000000
	// Bit FORCEDEVMODE.
	USB_GUSBCFG_FORCEDEVMODE = 0x40000000
	// Position of CORRUPTTXPKT field.
	USB_GUSBCFG_CORRUPTTXPKT_Pos = 0x1f
	// Bit mask of CORRUPTTXPKT field.
	USB_GUSBCFG_CORRUPTTXPKT_Msk = 0x80000000
	// Bit CORRUPTTXPKT.
	USB_GUSBCFG_CORRUPTTXPKT = 0x80000000

	// GRSTCTL
	// Position of CSFTRST field.
	USB_GRSTCTL_CSFTRST_Pos = 0x0
	// Bit mask of CSFTRST field.
	USB_GRSTCTL_CSFTRST_Msk = 0x1
	// Bit CSFTRST.
	USB_GRSTCTL_CSFTRST = 0x1
	// Position of PIUFSSFTRST field.
	USB_GRSTCTL_PIUFSSFTRST_Pos = 0x1
	// Bit mask of PIUFSSFTRST field.
	USB_GRSTCTL_PIUFSSFTRST_Msk = 0x2
	// Bit PIUFSSFTRST.
	USB_GRSTCTL_PIUFSSFTRST = 0x2
	// Position of FRMCNTRRST field.
	USB_GRSTCTL_FRMCNTRRST_Pos = 0x2
	// Bit mask of FRMCNTRRST field.
	USB_GRSTCTL_FRMCNTRRST_Msk = 0x4
	// Bit FRMCNTRRST.
	USB_GRSTCTL_FRMCNTRRST = 0x4
	// Position of RXFFLSH field.
	USB_GRSTCTL_RXFFLSH_Pos = 0x4
	// Bit mask of RXFFLSH field.
	USB_GRSTCTL_RXFFLSH_Msk = 0x10
	// Bit RXFFLSH.
	USB_GRSTCTL_RXFFLSH = 0x10
	// Position of TXFFLSH field.
	USB_GRSTCTL_TXFFLSH_Pos = 0x5
	// Bit mask of TXFFLSH field.
	USB_GRSTCTL_TXFFLSH_Msk = 0x20
	// Bit TXFFLSH.
	USB_GRSTCTL_TXFFLSH = 0x20
	// Position of TXFNUM field.
	USB_GRSTCTL_TXFNUM_Pos = 0x6
	// Bit mask of TXFNUM field.
	USB_GRSTCTL_TXFNUM_Msk = 0x7c0
	// Position of DMAREQ field.
	USB_GRSTCTL_DMAREQ_Pos = 0x1e
	// Bit mask of DMAREQ field.
	USB_GRSTCTL_DMAREQ_Msk = 0x40000000
	// Bit DMAREQ.
	USB_GRSTCTL_DMAREQ = 0x40000000
	// Position of AHBIDLE field.
	USB_GRSTCTL_AHBIDLE_Pos = 0x1f
	// Bit mask of AHBIDLE field.
	USB_GRSTCTL_AHBIDLE_Msk = 0x80000000
	// Bit AHBIDLE.
	USB_GRSTCTL_AHBIDLE = 0x80000000

	// GINTSTS
	// Position of CURMOD_INT field.
	USB_GINTSTS_CURMOD_INT_Pos = 0x0
	// Bit mask of CURMOD_INT field.
	USB_GINTSTS_CURMOD_INT_Msk = 0x1
	// Bit CURMOD_INT.
	USB_GINTSTS_CURMOD_INT = 0x1
	// Position of MODEMIS field.
	USB_GINTSTS_MODEMIS_Pos = 0x1
	// Bit mask of MODEMIS field.
	USB_GINTSTS_MODEMIS_Msk = 0x2
	// Bit MODEMIS.
	USB_GINTSTS_MODEMIS = 0x2
	// Position of OTGINT field.
	USB_GINTSTS_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_GINTSTS_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_GINTSTS_OTGINT = 0x4
	// Position of SOF field.
	USB_GINTSTS_SOF_Pos = 0x3
	// Bit mask of SOF field.
	USB_GINTSTS_SOF_Msk = 0x8
	// Bit SOF.
	USB_GINTSTS_SOF = 0x8
	// Position of RXFLVI field.
	USB_GINTSTS_RXFLVI_Pos = 0x4
	// Bit mask of RXFLVI field.
	USB_GINTSTS_RXFLVI_Msk = 0x10
	// Bit RXFLVI.
	USB_GINTSTS_RXFLVI = 0x10
	// Position of NPTXFEMP field.
	USB_GINTSTS_NPTXFEMP_Pos = 0x5
	// Bit mask of NPTXFEMP field.
	USB_GINTSTS_NPTXFEMP_Msk = 0x20
	// Bit NPTXFEMP.
	USB_GINTSTS_NPTXFEMP = 0x20
	// Position of GINNAKEFF field.
	USB_GINTSTS_GINNAKEFF_Pos = 0x6
	// Bit mask of GINNAKEFF field.
	USB_GINTSTS_GINNAKEFF_Msk = 0x40
	// Bit GINNAKEFF.
	USB_GINTSTS_GINNAKEFF = 0x40
	// Position of GOUTNAKEFF field.
	USB_GINTSTS_GOUTNAKEFF_Pos = 0x7
	// Bit mask of GOUTNAKEFF field.
	USB_GINTSTS_GOUTNAKEFF_Msk = 0x80
	// Bit GOUTNAKEFF.
	USB_GINTSTS_GOUTNAKEFF = 0x80
	// Position of ERLYSUSP field.
	USB_GINTSTS_ERLYSUSP_Pos = 0xa
	// Bit mask of ERLYSUSP field.
	USB_GINTSTS_ERLYSUSP_Msk = 0x400
	// Bit ERLYSUSP.
	USB_GINTSTS_ERLYSUSP = 0x400
	// Position of USBSUSP field.
	USB_GINTSTS_USBSUSP_Pos = 0xb
	// Bit mask of USBSUSP field.
	USB_GINTSTS_USBSUSP_Msk = 0x800
	// Bit USBSUSP.
	USB_GINTSTS_USBSUSP = 0x800
	// Position of USBRST field.
	USB_GINTSTS_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_GINTSTS_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_GINTSTS_USBRST = 0x1000
	// Position of ENUMDONE field.
	USB_GINTSTS_ENUMDONE_Pos = 0xd
	// Bit mask of ENUMDONE field.
	USB_GINTSTS_ENUMDONE_Msk = 0x2000
	// Bit ENUMDONE.
	USB_GINTSTS_ENUMDONE = 0x2000
	// Position of ISOOUTDROP field.
	USB_GINTSTS_ISOOUTDROP_Pos = 0xe
	// Bit mask of ISOOUTDROP field.
	USB_GINTSTS_ISOOUTDROP_Msk = 0x4000
	// Bit ISOOUTDROP.
	USB_GINTSTS_ISOOUTDROP = 0x4000
	// Position of EOPF field.
	USB_GINTSTS_EOPF_Pos = 0xf
	// Bit mask of EOPF field.
	USB_GINTSTS_EOPF_Msk = 0x8000
	// Bit EOPF.
	USB_GINTSTS_EOPF = 0x8000
	// Position of EPMIS field.
	USB_GINTSTS_EPMIS_Pos = 0x11
	// Bit mask of EPMIS field.
	USB_GINTSTS_EPMIS_Msk = 0x20000
	// Bit EPMIS.
	USB_GINTSTS_EPMIS = 0x20000
	// Position of IEPINT field.
	USB_GINTSTS_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_GINTSTS_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_GINTSTS_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_GINTSTS_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_GINTSTS_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_GINTSTS_OEPINT = 0x80000
	// Position of INCOMPISOIN field.
	USB_GINTSTS_INCOMPISOIN_Pos = 0x14
	// Bit mask of INCOMPISOIN field.
	USB_GINTSTS_INCOMPISOIN_Msk = 0x100000
	// Bit INCOMPISOIN.
	USB_GINTSTS_INCOMPISOIN = 0x100000
	// Position of INCOMPIP field.
	USB_GINTSTS_INCOMPIP_Pos = 0x15
	// Bit mask of INCOMPIP field.
	USB_GINTSTS_INCOMPIP_Msk = 0x200000
	// Bit INCOMPIP.
	USB_GINTSTS_INCOMPIP = 0x200000
	// Position of FETSUSP field.
	USB_GINTSTS_FETSUSP_Pos = 0x16
	// Bit mask of FETSUSP field.
	USB_GINTSTS_FETSUSP_Msk = 0x400000
	// Bit FETSUSP.
	USB_GINTSTS_FETSUSP = 0x400000
	// Position of RESETDET field.
	USB_GINTSTS_RESETDET_Pos = 0x17
	// Bit mask of RESETDET field.
	USB_GINTSTS_RESETDET_Msk = 0x800000
	// Bit RESETDET.
	USB_GINTSTS_RESETDET = 0x800000
	// Position of PRTLNT field.
	USB_GINTSTS_PRTLNT_Pos = 0x18
	// Bit mask of PRTLNT field.
	USB_GINTSTS_PRTLNT_Msk = 0x1000000
	// Bit PRTLNT.
	USB_GINTSTS_PRTLNT = 0x1000000
	// Position of HCHLNT field.
	USB_GINTSTS_HCHLNT_Pos = 0x19
	// Bit mask of HCHLNT field.
	USB_GINTSTS_HCHLNT_Msk = 0x2000000
	// Bit HCHLNT.
	USB_GINTSTS_HCHLNT = 0x2000000
	// Position of PTXFEMP field.
	USB_GINTSTS_PTXFEMP_Pos = 0x1a
	// Bit mask of PTXFEMP field.
	USB_GINTSTS_PTXFEMP_Msk = 0x4000000
	// Bit PTXFEMP.
	USB_GINTSTS_PTXFEMP = 0x4000000
	// Position of CONIDSTSCHNG field.
	USB_GINTSTS_CONIDSTSCHNG_Pos = 0x1c
	// Bit mask of CONIDSTSCHNG field.
	USB_GINTSTS_CONIDSTSCHNG_Msk = 0x10000000
	// Bit CONIDSTSCHNG.
	USB_GINTSTS_CONIDSTSCHNG = 0x10000000
	// Position of DISCONNINT field.
	USB_GINTSTS_DISCONNINT_Pos = 0x1d
	// Bit mask of DISCONNINT field.
	USB_GINTSTS_DISCONNINT_Msk = 0x20000000
	// Bit DISCONNINT.
	USB_GINTSTS_DISCONNINT = 0x20000000
	// Position of SESSREQINT field.
	USB_GINTSTS_SESSREQINT_Pos = 0x1e
	// Bit mask of SESSREQINT field.
	USB_GINTSTS_SESSREQINT_Msk = 0x40000000
	// Bit SESSREQINT.
	USB_GINTSTS_SESSREQINT = 0x40000000
	// Position of WKUPINT field.
	USB_GINTSTS_WKUPINT_Pos = 0x1f
	// Bit mask of WKUPINT field.
	USB_GINTSTS_WKUPINT_Msk = 0x80000000
	// Bit WKUPINT.
	USB_GINTSTS_WKUPINT = 0x80000000

	// GINTMSK
	// Position of MODEMISMSK field.
	USB_GINTMSK_MODEMISMSK_Pos = 0x1
	// Bit mask of MODEMISMSK field.
	USB_GINTMSK_MODEMISMSK_Msk = 0x2
	// Bit MODEMISMSK.
	USB_GINTMSK_MODEMISMSK = 0x2
	// Position of OTGINTMSK field.
	USB_GINTMSK_OTGINTMSK_Pos = 0x2
	// Bit mask of OTGINTMSK field.
	USB_GINTMSK_OTGINTMSK_Msk = 0x4
	// Bit OTGINTMSK.
	USB_GINTMSK_OTGINTMSK = 0x4
	// Position of SOFMSK field.
	USB_GINTMSK_SOFMSK_Pos = 0x3
	// Bit mask of SOFMSK field.
	USB_GINTMSK_SOFMSK_Msk = 0x8
	// Bit SOFMSK.
	USB_GINTMSK_SOFMSK = 0x8
	// Position of RXFLVIMSK field.
	USB_GINTMSK_RXFLVIMSK_Pos = 0x4
	// Bit mask of RXFLVIMSK field.
	USB_GINTMSK_RXFLVIMSK_Msk = 0x10
	// Bit RXFLVIMSK.
	USB_GINTMSK_RXFLVIMSK = 0x10
	// Position of NPTXFEMPMSK field.
	USB_GINTMSK_NPTXFEMPMSK_Pos = 0x5
	// Bit mask of NPTXFEMPMSK field.
	USB_GINTMSK_NPTXFEMPMSK_Msk = 0x20
	// Bit NPTXFEMPMSK.
	USB_GINTMSK_NPTXFEMPMSK = 0x20
	// Position of GINNAKEFFMSK field.
	USB_GINTMSK_GINNAKEFFMSK_Pos = 0x6
	// Bit mask of GINNAKEFFMSK field.
	USB_GINTMSK_GINNAKEFFMSK_Msk = 0x40
	// Bit GINNAKEFFMSK.
	USB_GINTMSK_GINNAKEFFMSK = 0x40
	// Position of GOUTNACKEFFMSK field.
	USB_GINTMSK_GOUTNACKEFFMSK_Pos = 0x7
	// Bit mask of GOUTNACKEFFMSK field.
	USB_GINTMSK_GOUTNACKEFFMSK_Msk = 0x80
	// Bit GOUTNACKEFFMSK.
	USB_GINTMSK_GOUTNACKEFFMSK = 0x80
	// Position of ERLYSUSPMSK field.
	USB_GINTMSK_ERLYSUSPMSK_Pos = 0xa
	// Bit mask of ERLYSUSPMSK field.
	USB_GINTMSK_ERLYSUSPMSK_Msk = 0x400
	// Bit ERLYSUSPMSK.
	USB_GINTMSK_ERLYSUSPMSK = 0x400
	// Position of USBSUSPMSK field.
	USB_GINTMSK_USBSUSPMSK_Pos = 0xb
	// Bit mask of USBSUSPMSK field.
	USB_GINTMSK_USBSUSPMSK_Msk = 0x800
	// Bit USBSUSPMSK.
	USB_GINTMSK_USBSUSPMSK = 0x800
	// Position of USBRSTMSK field.
	USB_GINTMSK_USBRSTMSK_Pos = 0xc
	// Bit mask of USBRSTMSK field.
	USB_GINTMSK_USBRSTMSK_Msk = 0x1000
	// Bit USBRSTMSK.
	USB_GINTMSK_USBRSTMSK = 0x1000
	// Position of ENUMDONEMSK field.
	USB_GINTMSK_ENUMDONEMSK_Pos = 0xd
	// Bit mask of ENUMDONEMSK field.
	USB_GINTMSK_ENUMDONEMSK_Msk = 0x2000
	// Bit ENUMDONEMSK.
	USB_GINTMSK_ENUMDONEMSK = 0x2000
	// Position of ISOOUTDROPMSK field.
	USB_GINTMSK_ISOOUTDROPMSK_Pos = 0xe
	// Bit mask of ISOOUTDROPMSK field.
	USB_GINTMSK_ISOOUTDROPMSK_Msk = 0x4000
	// Bit ISOOUTDROPMSK.
	USB_GINTMSK_ISOOUTDROPMSK = 0x4000
	// Position of EOPFMSK field.
	USB_GINTMSK_EOPFMSK_Pos = 0xf
	// Bit mask of EOPFMSK field.
	USB_GINTMSK_EOPFMSK_Msk = 0x8000
	// Bit EOPFMSK.
	USB_GINTMSK_EOPFMSK = 0x8000
	// Position of EPMISMSK field.
	USB_GINTMSK_EPMISMSK_Pos = 0x11
	// Bit mask of EPMISMSK field.
	USB_GINTMSK_EPMISMSK_Msk = 0x20000
	// Bit EPMISMSK.
	USB_GINTMSK_EPMISMSK = 0x20000
	// Position of IEPINTMSK field.
	USB_GINTMSK_IEPINTMSK_Pos = 0x12
	// Bit mask of IEPINTMSK field.
	USB_GINTMSK_IEPINTMSK_Msk = 0x40000
	// Bit IEPINTMSK.
	USB_GINTMSK_IEPINTMSK = 0x40000
	// Position of OEPINTMSK field.
	USB_GINTMSK_OEPINTMSK_Pos = 0x13
	// Bit mask of OEPINTMSK field.
	USB_GINTMSK_OEPINTMSK_Msk = 0x80000
	// Bit OEPINTMSK.
	USB_GINTMSK_OEPINTMSK = 0x80000
	// Position of INCOMPISOINMSK field.
	USB_GINTMSK_INCOMPISOINMSK_Pos = 0x14
	// Bit mask of INCOMPISOINMSK field.
	USB_GINTMSK_INCOMPISOINMSK_Msk = 0x100000
	// Bit INCOMPISOINMSK.
	USB_GINTMSK_INCOMPISOINMSK = 0x100000
	// Position of INCOMPIPMSK field.
	USB_GINTMSK_INCOMPIPMSK_Pos = 0x15
	// Bit mask of INCOMPIPMSK field.
	USB_GINTMSK_INCOMPIPMSK_Msk = 0x200000
	// Bit INCOMPIPMSK.
	USB_GINTMSK_INCOMPIPMSK = 0x200000
	// Position of FETSUSPMSK field.
	USB_GINTMSK_FETSUSPMSK_Pos = 0x16
	// Bit mask of FETSUSPMSK field.
	USB_GINTMSK_FETSUSPMSK_Msk = 0x400000
	// Bit FETSUSPMSK.
	USB_GINTMSK_FETSUSPMSK = 0x400000
	// Position of RESETDETMSK field.
	USB_GINTMSK_RESETDETMSK_Pos = 0x17
	// Bit mask of RESETDETMSK field.
	USB_GINTMSK_RESETDETMSK_Msk = 0x800000
	// Bit RESETDETMSK.
	USB_GINTMSK_RESETDETMSK = 0x800000
	// Position of PRTLNTMSK field.
	USB_GINTMSK_PRTLNTMSK_Pos = 0x18
	// Bit mask of PRTLNTMSK field.
	USB_GINTMSK_PRTLNTMSK_Msk = 0x1000000
	// Bit PRTLNTMSK.
	USB_GINTMSK_PRTLNTMSK = 0x1000000
	// Position of HCHINTMSK field.
	USB_GINTMSK_HCHINTMSK_Pos = 0x19
	// Bit mask of HCHINTMSK field.
	USB_GINTMSK_HCHINTMSK_Msk = 0x2000000
	// Bit HCHINTMSK.
	USB_GINTMSK_HCHINTMSK = 0x2000000
	// Position of PTXFEMPMSK field.
	USB_GINTMSK_PTXFEMPMSK_Pos = 0x1a
	// Bit mask of PTXFEMPMSK field.
	USB_GINTMSK_PTXFEMPMSK_Msk = 0x4000000
	// Bit PTXFEMPMSK.
	USB_GINTMSK_PTXFEMPMSK = 0x4000000
	// Position of CONIDSTSCHNGMSK field.
	USB_GINTMSK_CONIDSTSCHNGMSK_Pos = 0x1c
	// Bit mask of CONIDSTSCHNGMSK field.
	USB_GINTMSK_CONIDSTSCHNGMSK_Msk = 0x10000000
	// Bit CONIDSTSCHNGMSK.
	USB_GINTMSK_CONIDSTSCHNGMSK = 0x10000000
	// Position of DISCONNINTMSK field.
	USB_GINTMSK_DISCONNINTMSK_Pos = 0x1d
	// Bit mask of DISCONNINTMSK field.
	USB_GINTMSK_DISCONNINTMSK_Msk = 0x20000000
	// Bit DISCONNINTMSK.
	USB_GINTMSK_DISCONNINTMSK = 0x20000000
	// Position of SESSREQINTMSK field.
	USB_GINTMSK_SESSREQINTMSK_Pos = 0x1e
	// Bit mask of SESSREQINTMSK field.
	USB_GINTMSK_SESSREQINTMSK_Msk = 0x40000000
	// Bit SESSREQINTMSK.
	USB_GINTMSK_SESSREQINTMSK = 0x40000000
	// Position of WKUPINTMSK field.
	USB_GINTMSK_WKUPINTMSK_Pos = 0x1f
	// Bit mask of WKUPINTMSK field.
	USB_GINTMSK_WKUPINTMSK_Msk = 0x80000000
	// Bit WKUPINTMSK.
	USB_GINTMSK_WKUPINTMSK = 0x80000000

	// GRXSTSR
	// Position of G_CHNUM field.
	USB_GRXSTSR_G_CHNUM_Pos = 0x0
	// Bit mask of G_CHNUM field.
	USB_GRXSTSR_G_CHNUM_Msk = 0xf
	// Position of G_BCNT field.
	USB_GRXSTSR_G_BCNT_Pos = 0x4
	// Bit mask of G_BCNT field.
	USB_GRXSTSR_G_BCNT_Msk = 0x7ff0
	// Position of G_DPID field.
	USB_GRXSTSR_G_DPID_Pos = 0xf
	// Bit mask of G_DPID field.
	USB_GRXSTSR_G_DPID_Msk = 0x18000
	// Position of G_PKTSTS field.
	USB_GRXSTSR_G_PKTSTS_Pos = 0x11
	// Bit mask of G_PKTSTS field.
	USB_GRXSTSR_G_PKTSTS_Msk = 0x1e0000
	// Position of G_FN field.
	USB_GRXSTSR_G_FN_Pos = 0x15
	// Bit mask of G_FN field.
	USB_GRXSTSR_G_FN_Msk = 0x1e00000

	// GRXSTSP
	// Position of CHNUM field.
	USB_GRXSTSP_CHNUM_Pos = 0x0
	// Bit mask of CHNUM field.
	USB_GRXSTSP_CHNUM_Msk = 0xf
	// Position of BCNT field.
	USB_GRXSTSP_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_GRXSTSP_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_GRXSTSP_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_GRXSTSP_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_GRXSTSP_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_GRXSTSP_PKTSTS_Msk = 0x1e0000
	// Position of FN field.
	USB_GRXSTSP_FN_Pos = 0x15
	// Bit mask of FN field.
	USB_GRXSTSP_FN_Msk = 0x1e00000

	// GRXFSIZ
	// Position of RXFDEP field.
	USB_GRXFSIZ_RXFDEP_Pos = 0x0
	// Bit mask of RXFDEP field.
	USB_GRXFSIZ_RXFDEP_Msk = 0xffff

	// GNPTXFSIZ
	// Position of NPTXFSTADDR field.
	USB_GNPTXFSIZ_NPTXFSTADDR_Pos = 0x0
	// Bit mask of NPTXFSTADDR field.
	USB_GNPTXFSIZ_NPTXFSTADDR_Msk = 0xffff
	// Position of NPTXFDEP field.
	USB_GNPTXFSIZ_NPTXFDEP_Pos = 0x10
	// Bit mask of NPTXFDEP field.
	USB_GNPTXFSIZ_NPTXFDEP_Msk = 0xffff0000

	// GNPTXSTS
	// Position of NPTXFSPCAVAIL field.
	USB_GNPTXSTS_NPTXFSPCAVAIL_Pos = 0x0
	// Bit mask of NPTXFSPCAVAIL field.
	USB_GNPTXSTS_NPTXFSPCAVAIL_Msk = 0xffff
	// Position of NPTXQSPCAVAIL field.
	USB_GNPTXSTS_NPTXQSPCAVAIL_Pos = 0x10
	// Bit mask of NPTXQSPCAVAIL field.
	USB_GNPTXSTS_NPTXQSPCAVAIL_Msk = 0xf0000
	// Position of NPTXQTOP field.
	USB_GNPTXSTS_NPTXQTOP_Pos = 0x18
	// Bit mask of NPTXQTOP field.
	USB_GNPTXSTS_NPTXQTOP_Msk = 0x7f000000

	// GSNPSID
	// Position of SYNOPSYSID field.
	USB_GSNPSID_SYNOPSYSID_Pos = 0x0
	// Bit mask of SYNOPSYSID field.
	USB_GSNPSID_SYNOPSYSID_Msk = 0xffffffff

	// GHWCFG1
	// Position of EPDIR field.
	USB_GHWCFG1_EPDIR_Pos = 0x0
	// Bit mask of EPDIR field.
	USB_GHWCFG1_EPDIR_Msk = 0xffffffff

	// GHWCFG2
	// Position of OTGMODE field.
	USB_GHWCFG2_OTGMODE_Pos = 0x0
	// Bit mask of OTGMODE field.
	USB_GHWCFG2_OTGMODE_Msk = 0x7
	// Position of OTGARCH field.
	USB_GHWCFG2_OTGARCH_Pos = 0x3
	// Bit mask of OTGARCH field.
	USB_GHWCFG2_OTGARCH_Msk = 0x18
	// Position of SINGPNT field.
	USB_GHWCFG2_SINGPNT_Pos = 0x5
	// Bit mask of SINGPNT field.
	USB_GHWCFG2_SINGPNT_Msk = 0x20
	// Bit SINGPNT.
	USB_GHWCFG2_SINGPNT = 0x20
	// Position of HSPHYTYPE field.
	USB_GHWCFG2_HSPHYTYPE_Pos = 0x6
	// Bit mask of HSPHYTYPE field.
	USB_GHWCFG2_HSPHYTYPE_Msk = 0xc0
	// Position of FSPHYTYPE field.
	USB_GHWCFG2_FSPHYTYPE_Pos = 0x8
	// Bit mask of FSPHYTYPE field.
	USB_GHWCFG2_FSPHYTYPE_Msk = 0x300
	// Position of NUMDEVEPS field.
	USB_GHWCFG2_NUMDEVEPS_Pos = 0xa
	// Bit mask of NUMDEVEPS field.
	USB_GHWCFG2_NUMDEVEPS_Msk = 0x3c00
	// Position of NUMHSTCHNL field.
	USB_GHWCFG2_NUMHSTCHNL_Pos = 0xe
	// Bit mask of NUMHSTCHNL field.
	USB_GHWCFG2_NUMHSTCHNL_Msk = 0x3c000
	// Position of PERIOSUPPORT field.
	USB_GHWCFG2_PERIOSUPPORT_Pos = 0x12
	// Bit mask of PERIOSUPPORT field.
	USB_GHWCFG2_PERIOSUPPORT_Msk = 0x40000
	// Bit PERIOSUPPORT.
	USB_GHWCFG2_PERIOSUPPORT = 0x40000
	// Position of DYNFIFOSIZING field.
	USB_GHWCFG2_DYNFIFOSIZING_Pos = 0x13
	// Bit mask of DYNFIFOSIZING field.
	USB_GHWCFG2_DYNFIFOSIZING_Msk = 0x80000
	// Bit DYNFIFOSIZING.
	USB_GHWCFG2_DYNFIFOSIZING = 0x80000
	// Position of MULTIPROCINTRPT field.
	USB_GHWCFG2_MULTIPROCINTRPT_Pos = 0x14
	// Bit mask of MULTIPROCINTRPT field.
	USB_GHWCFG2_MULTIPROCINTRPT_Msk = 0x100000
	// Bit MULTIPROCINTRPT.
	USB_GHWCFG2_MULTIPROCINTRPT = 0x100000
	// Position of NPTXQDEPTH field.
	USB_GHWCFG2_NPTXQDEPTH_Pos = 0x16
	// Bit mask of NPTXQDEPTH field.
	USB_GHWCFG2_NPTXQDEPTH_Msk = 0xc00000
	// Position of PTXQDEPTH field.
	USB_GHWCFG2_PTXQDEPTH_Pos = 0x18
	// Bit mask of PTXQDEPTH field.
	USB_GHWCFG2_PTXQDEPTH_Msk = 0x3000000
	// Position of TKNQDEPTH field.
	USB_GHWCFG2_TKNQDEPTH_Pos = 0x1a
	// Bit mask of TKNQDEPTH field.
	USB_GHWCFG2_TKNQDEPTH_Msk = 0x7c000000
	// Position of OTG_ENABLE_IC_USB field.
	USB_GHWCFG2_OTG_ENABLE_IC_USB_Pos = 0x1f
	// Bit mask of OTG_ENABLE_IC_USB field.
	USB_GHWCFG2_OTG_ENABLE_IC_USB_Msk = 0x80000000
	// Bit OTG_ENABLE_IC_USB.
	USB_GHWCFG2_OTG_ENABLE_IC_USB = 0x80000000

	// GHWCFG3
	// Position of XFERSIZEWIDTH field.
	USB_GHWCFG3_XFERSIZEWIDTH_Pos = 0x0
	// Bit mask of XFERSIZEWIDTH field.
	USB_GHWCFG3_XFERSIZEWIDTH_Msk = 0xf
	// Position of PKTSIZEWIDTH field.
	USB_GHWCFG3_PKTSIZEWIDTH_Pos = 0x4
	// Bit mask of PKTSIZEWIDTH field.
	USB_GHWCFG3_PKTSIZEWIDTH_Msk = 0x70
	// Position of OTGEN field.
	USB_GHWCFG3_OTGEN_Pos = 0x7
	// Bit mask of OTGEN field.
	USB_GHWCFG3_OTGEN_Msk = 0x80
	// Bit OTGEN.
	USB_GHWCFG3_OTGEN = 0x80
	// Position of I2CINTSEL field.
	USB_GHWCFG3_I2CINTSEL_Pos = 0x8
	// Bit mask of I2CINTSEL field.
	USB_GHWCFG3_I2CINTSEL_Msk = 0x100
	// Bit I2CINTSEL.
	USB_GHWCFG3_I2CINTSEL = 0x100
	// Position of VNDCTLSUPT field.
	USB_GHWCFG3_VNDCTLSUPT_Pos = 0x9
	// Bit mask of VNDCTLSUPT field.
	USB_GHWCFG3_VNDCTLSUPT_Msk = 0x200
	// Bit VNDCTLSUPT.
	USB_GHWCFG3_VNDCTLSUPT = 0x200
	// Position of OPTFEATURE field.
	USB_GHWCFG3_OPTFEATURE_Pos = 0xa
	// Bit mask of OPTFEATURE field.
	USB_GHWCFG3_OPTFEATURE_Msk = 0x400
	// Bit OPTFEATURE.
	USB_GHWCFG3_OPTFEATURE = 0x400
	// Position of RSTTYPE field.
	USB_GHWCFG3_RSTTYPE_Pos = 0xb
	// Bit mask of RSTTYPE field.
	USB_GHWCFG3_RSTTYPE_Msk = 0x800
	// Bit RSTTYPE.
	USB_GHWCFG3_RSTTYPE = 0x800
	// Position of ADPSUPPORT field.
	USB_GHWCFG3_ADPSUPPORT_Pos = 0xc
	// Bit mask of ADPSUPPORT field.
	USB_GHWCFG3_ADPSUPPORT_Msk = 0x1000
	// Bit ADPSUPPORT.
	USB_GHWCFG3_ADPSUPPORT = 0x1000
	// Position of HSICMODE field.
	USB_GHWCFG3_HSICMODE_Pos = 0xd
	// Bit mask of HSICMODE field.
	USB_GHWCFG3_HSICMODE_Msk = 0x2000
	// Bit HSICMODE.
	USB_GHWCFG3_HSICMODE = 0x2000
	// Position of BCSUPPORT field.
	USB_GHWCFG3_BCSUPPORT_Pos = 0xe
	// Bit mask of BCSUPPORT field.
	USB_GHWCFG3_BCSUPPORT_Msk = 0x4000
	// Bit BCSUPPORT.
	USB_GHWCFG3_BCSUPPORT = 0x4000
	// Position of LPMMODE field.
	USB_GHWCFG3_LPMMODE_Pos = 0xf
	// Bit mask of LPMMODE field.
	USB_GHWCFG3_LPMMODE_Msk = 0x8000
	// Bit LPMMODE.
	USB_GHWCFG3_LPMMODE = 0x8000
	// Position of DFIFODEPTH field.
	USB_GHWCFG3_DFIFODEPTH_Pos = 0x10
	// Bit mask of DFIFODEPTH field.
	USB_GHWCFG3_DFIFODEPTH_Msk = 0xffff0000

	// GHWCFG4
	// Position of G_NUMDEVPERIOEPS field.
	USB_GHWCFG4_G_NUMDEVPERIOEPS_Pos = 0x0
	// Bit mask of G_NUMDEVPERIOEPS field.
	USB_GHWCFG4_G_NUMDEVPERIOEPS_Msk = 0xf
	// Position of G_PARTIALPWRDN field.
	USB_GHWCFG4_G_PARTIALPWRDN_Pos = 0x4
	// Bit mask of G_PARTIALPWRDN field.
	USB_GHWCFG4_G_PARTIALPWRDN_Msk = 0x10
	// Bit G_PARTIALPWRDN.
	USB_GHWCFG4_G_PARTIALPWRDN = 0x10
	// Position of G_AHBFREQ field.
	USB_GHWCFG4_G_AHBFREQ_Pos = 0x5
	// Bit mask of G_AHBFREQ field.
	USB_GHWCFG4_G_AHBFREQ_Msk = 0x20
	// Bit G_AHBFREQ.
	USB_GHWCFG4_G_AHBFREQ = 0x20
	// Position of G_HIBERNATION field.
	USB_GHWCFG4_G_HIBERNATION_Pos = 0x6
	// Bit mask of G_HIBERNATION field.
	USB_GHWCFG4_G_HIBERNATION_Msk = 0x40
	// Bit G_HIBERNATION.
	USB_GHWCFG4_G_HIBERNATION = 0x40
	// Position of G_EXTENDEDHIBERNATION field.
	USB_GHWCFG4_G_EXTENDEDHIBERNATION_Pos = 0x7
	// Bit mask of G_EXTENDEDHIBERNATION field.
	USB_GHWCFG4_G_EXTENDEDHIBERNATION_Msk = 0x80
	// Bit G_EXTENDEDHIBERNATION.
	USB_GHWCFG4_G_EXTENDEDHIBERNATION = 0x80
	// Position of G_ACGSUPT field.
	USB_GHWCFG4_G_ACGSUPT_Pos = 0xc
	// Bit mask of G_ACGSUPT field.
	USB_GHWCFG4_G_ACGSUPT_Msk = 0x1000
	// Bit G_ACGSUPT.
	USB_GHWCFG4_G_ACGSUPT = 0x1000
	// Position of G_ENHANCEDLPMSUPT field.
	USB_GHWCFG4_G_ENHANCEDLPMSUPT_Pos = 0xd
	// Bit mask of G_ENHANCEDLPMSUPT field.
	USB_GHWCFG4_G_ENHANCEDLPMSUPT_Msk = 0x2000
	// Bit G_ENHANCEDLPMSUPT.
	USB_GHWCFG4_G_ENHANCEDLPMSUPT = 0x2000
	// Position of G_PHYDATAWIDTH field.
	USB_GHWCFG4_G_PHYDATAWIDTH_Pos = 0xe
	// Bit mask of G_PHYDATAWIDTH field.
	USB_GHWCFG4_G_PHYDATAWIDTH_Msk = 0xc000
	// Position of G_NUMCTLEPS field.
	USB_GHWCFG4_G_NUMCTLEPS_Pos = 0x10
	// Bit mask of G_NUMCTLEPS field.
	USB_GHWCFG4_G_NUMCTLEPS_Msk = 0xf0000
	// Position of G_IDDQFLTR field.
	USB_GHWCFG4_G_IDDQFLTR_Pos = 0x14
	// Bit mask of G_IDDQFLTR field.
	USB_GHWCFG4_G_IDDQFLTR_Msk = 0x100000
	// Bit G_IDDQFLTR.
	USB_GHWCFG4_G_IDDQFLTR = 0x100000
	// Position of G_VBUSVALIDFLTR field.
	USB_GHWCFG4_G_VBUSVALIDFLTR_Pos = 0x15
	// Bit mask of G_VBUSVALIDFLTR field.
	USB_GHWCFG4_G_VBUSVALIDFLTR_Msk = 0x200000
	// Bit G_VBUSVALIDFLTR.
	USB_GHWCFG4_G_VBUSVALIDFLTR = 0x200000
	// Position of G_AVALIDFLTR field.
	USB_GHWCFG4_G_AVALIDFLTR_Pos = 0x16
	// Bit mask of G_AVALIDFLTR field.
	USB_GHWCFG4_G_AVALIDFLTR_Msk = 0x400000
	// Bit G_AVALIDFLTR.
	USB_GHWCFG4_G_AVALIDFLTR = 0x400000
	// Position of G_BVALIDFLTR field.
	USB_GHWCFG4_G_BVALIDFLTR_Pos = 0x17
	// Bit mask of G_BVALIDFLTR field.
	USB_GHWCFG4_G_BVALIDFLTR_Msk = 0x800000
	// Bit G_BVALIDFLTR.
	USB_GHWCFG4_G_BVALIDFLTR = 0x800000
	// Position of G_SESSENDFLTR field.
	USB_GHWCFG4_G_SESSENDFLTR_Pos = 0x18
	// Bit mask of G_SESSENDFLTR field.
	USB_GHWCFG4_G_SESSENDFLTR_Msk = 0x1000000
	// Bit G_SESSENDFLTR.
	USB_GHWCFG4_G_SESSENDFLTR = 0x1000000
	// Position of G_DEDFIFOMODE field.
	USB_GHWCFG4_G_DEDFIFOMODE_Pos = 0x19
	// Bit mask of G_DEDFIFOMODE field.
	USB_GHWCFG4_G_DEDFIFOMODE_Msk = 0x2000000
	// Bit G_DEDFIFOMODE.
	USB_GHWCFG4_G_DEDFIFOMODE = 0x2000000
	// Position of G_INEPS field.
	USB_GHWCFG4_G_INEPS_Pos = 0x1a
	// Bit mask of G_INEPS field.
	USB_GHWCFG4_G_INEPS_Msk = 0x3c000000
	// Position of G_DESCDMAENABLED field.
	USB_GHWCFG4_G_DESCDMAENABLED_Pos = 0x1e
	// Bit mask of G_DESCDMAENABLED field.
	USB_GHWCFG4_G_DESCDMAENABLED_Msk = 0x40000000
	// Bit G_DESCDMAENABLED.
	USB_GHWCFG4_G_DESCDMAENABLED = 0x40000000
	// Position of G_DESCDMA field.
	USB_GHWCFG4_G_DESCDMA_Pos = 0x1f
	// Bit mask of G_DESCDMA field.
	USB_GHWCFG4_G_DESCDMA_Msk = 0x80000000
	// Bit G_DESCDMA.
	USB_GHWCFG4_G_DESCDMA = 0x80000000

	// GDFIFOCFG
	// Position of GDFIFOCFG field.
	USB_GDFIFOCFG_GDFIFOCFG_Pos = 0x0
	// Bit mask of GDFIFOCFG field.
	USB_GDFIFOCFG_GDFIFOCFG_Msk = 0xffff
	// Position of EPINFOBASEADDR field.
	USB_GDFIFOCFG_EPINFOBASEADDR_Pos = 0x10
	// Bit mask of EPINFOBASEADDR field.
	USB_GDFIFOCFG_EPINFOBASEADDR_Msk = 0xffff0000

	// HPTXFSIZ
	// Position of PTXFSTADDR field.
	USB_HPTXFSIZ_PTXFSTADDR_Pos = 0x0
	// Bit mask of PTXFSTADDR field.
	USB_HPTXFSIZ_PTXFSTADDR_Msk = 0xffff
	// Position of PTXFSIZE field.
	USB_HPTXFSIZ_PTXFSIZE_Pos = 0x10
	// Bit mask of PTXFSIZE field.
	USB_HPTXFSIZ_PTXFSIZE_Msk = 0xffff0000

	// DIEPTXF1
	// Position of INEP1TXFSTADDR field.
	USB_DIEPTXF1_INEP1TXFSTADDR_Pos = 0x0
	// Bit mask of INEP1TXFSTADDR field.
	USB_DIEPTXF1_INEP1TXFSTADDR_Msk = 0xffff
	// Position of INEP1TXFDEP field.
	USB_DIEPTXF1_INEP1TXFDEP_Pos = 0x10
	// Bit mask of INEP1TXFDEP field.
	USB_DIEPTXF1_INEP1TXFDEP_Msk = 0xffff0000

	// DIEPTXF2
	// Position of INEP2TXFSTADDR field.
	USB_DIEPTXF2_INEP2TXFSTADDR_Pos = 0x0
	// Bit mask of INEP2TXFSTADDR field.
	USB_DIEPTXF2_INEP2TXFSTADDR_Msk = 0xffff
	// Position of INEP2TXFDEP field.
	USB_DIEPTXF2_INEP2TXFDEP_Pos = 0x10
	// Bit mask of INEP2TXFDEP field.
	USB_DIEPTXF2_INEP2TXFDEP_Msk = 0xffff0000

	// DIEPTXF3
	// Position of INEP3TXFSTADDR field.
	USB_DIEPTXF3_INEP3TXFSTADDR_Pos = 0x0
	// Bit mask of INEP3TXFSTADDR field.
	USB_DIEPTXF3_INEP3TXFSTADDR_Msk = 0xffff
	// Position of INEP3TXFDEP field.
	USB_DIEPTXF3_INEP3TXFDEP_Pos = 0x10
	// Bit mask of INEP3TXFDEP field.
	USB_DIEPTXF3_INEP3TXFDEP_Msk = 0xffff0000

	// DIEPTXF4
	// Position of INEP4TXFSTADDR field.
	USB_DIEPTXF4_INEP4TXFSTADDR_Pos = 0x0
	// Bit mask of INEP4TXFSTADDR field.
	USB_DIEPTXF4_INEP4TXFSTADDR_Msk = 0xffff
	// Position of INEP4TXFDEP field.
	USB_DIEPTXF4_INEP4TXFDEP_Pos = 0x10
	// Bit mask of INEP4TXFDEP field.
	USB_DIEPTXF4_INEP4TXFDEP_Msk = 0xffff0000

	// HCFG
	// Position of H_FSLSPCLKSEL field.
	USB_HCFG_H_FSLSPCLKSEL_Pos = 0x0
	// Bit mask of H_FSLSPCLKSEL field.
	USB_HCFG_H_FSLSPCLKSEL_Msk = 0x3
	// Position of H_FSLSSUPP field.
	USB_HCFG_H_FSLSSUPP_Pos = 0x2
	// Bit mask of H_FSLSSUPP field.
	USB_HCFG_H_FSLSSUPP_Msk = 0x4
	// Bit H_FSLSSUPP.
	USB_HCFG_H_FSLSSUPP = 0x4
	// Position of H_ENA32KHZS field.
	USB_HCFG_H_ENA32KHZS_Pos = 0x7
	// Bit mask of H_ENA32KHZS field.
	USB_HCFG_H_ENA32KHZS_Msk = 0x80
	// Bit H_ENA32KHZS.
	USB_HCFG_H_ENA32KHZS = 0x80
	// Position of H_DESCDMA field.
	USB_HCFG_H_DESCDMA_Pos = 0x17
	// Bit mask of H_DESCDMA field.
	USB_HCFG_H_DESCDMA_Msk = 0x800000
	// Bit H_DESCDMA.
	USB_HCFG_H_DESCDMA = 0x800000
	// Position of H_FRLISTEN field.
	USB_HCFG_H_FRLISTEN_Pos = 0x18
	// Bit mask of H_FRLISTEN field.
	USB_HCFG_H_FRLISTEN_Msk = 0x3000000
	// Position of H_PERSCHEDENA field.
	USB_HCFG_H_PERSCHEDENA_Pos = 0x1a
	// Bit mask of H_PERSCHEDENA field.
	USB_HCFG_H_PERSCHEDENA_Msk = 0x4000000
	// Bit H_PERSCHEDENA.
	USB_HCFG_H_PERSCHEDENA = 0x4000000
	// Position of H_MODECHTIMEN field.
	USB_HCFG_H_MODECHTIMEN_Pos = 0x1f
	// Bit mask of H_MODECHTIMEN field.
	USB_HCFG_H_MODECHTIMEN_Msk = 0x80000000
	// Bit H_MODECHTIMEN.
	USB_HCFG_H_MODECHTIMEN = 0x80000000

	// HFIR
	// Position of FRINT field.
	USB_HFIR_FRINT_Pos = 0x0
	// Bit mask of FRINT field.
	USB_HFIR_FRINT_Msk = 0xffff
	// Position of HFIRRLDCTRL field.
	USB_HFIR_HFIRRLDCTRL_Pos = 0x10
	// Bit mask of HFIRRLDCTRL field.
	USB_HFIR_HFIRRLDCTRL_Msk = 0x10000
	// Bit HFIRRLDCTRL.
	USB_HFIR_HFIRRLDCTRL = 0x10000

	// HFNUM
	// Position of FRNUM field.
	USB_HFNUM_FRNUM_Pos = 0x0
	// Bit mask of FRNUM field.
	USB_HFNUM_FRNUM_Msk = 0x3fff
	// Position of FRREM field.
	USB_HFNUM_FRREM_Pos = 0x10
	// Bit mask of FRREM field.
	USB_HFNUM_FRREM_Msk = 0xffff0000

	// HPTXSTS
	// Position of PTXFSPCAVAIL field.
	USB_HPTXSTS_PTXFSPCAVAIL_Pos = 0x0
	// Bit mask of PTXFSPCAVAIL field.
	USB_HPTXSTS_PTXFSPCAVAIL_Msk = 0xffff
	// Position of PTXQSPCAVAIL field.
	USB_HPTXSTS_PTXQSPCAVAIL_Pos = 0x10
	// Bit mask of PTXQSPCAVAIL field.
	USB_HPTXSTS_PTXQSPCAVAIL_Msk = 0x1f0000
	// Position of PTXQTOP field.
	USB_HPTXSTS_PTXQTOP_Pos = 0x18
	// Bit mask of PTXQTOP field.
	USB_HPTXSTS_PTXQTOP_Msk = 0xff000000

	// HAINT
	// Position of HAINT field.
	USB_HAINT_HAINT_Pos = 0x0
	// Bit mask of HAINT field.
	USB_HAINT_HAINT_Msk = 0xff

	// HAINTMSK
	// Position of HAINTMSK field.
	USB_HAINTMSK_HAINTMSK_Pos = 0x0
	// Bit mask of HAINTMSK field.
	USB_HAINTMSK_HAINTMSK_Msk = 0xff

	// HFLBADDR
	// Position of HFLBADDR field.
	USB_HFLBADDR_HFLBADDR_Pos = 0x0
	// Bit mask of HFLBADDR field.
	USB_HFLBADDR_HFLBADDR_Msk = 0xffffffff

	// HPRT
	// Position of PRTCONNSTS field.
	USB_HPRT_PRTCONNSTS_Pos = 0x0
	// Bit mask of PRTCONNSTS field.
	USB_HPRT_PRTCONNSTS_Msk = 0x1
	// Bit PRTCONNSTS.
	USB_HPRT_PRTCONNSTS = 0x1
	// Position of PRTCONNDET field.
	USB_HPRT_PRTCONNDET_Pos = 0x1
	// Bit mask of PRTCONNDET field.
	USB_HPRT_PRTCONNDET_Msk = 0x2
	// Bit PRTCONNDET.
	USB_HPRT_PRTCONNDET = 0x2
	// Position of PRTENA field.
	USB_HPRT_PRTENA_Pos = 0x2
	// Bit mask of PRTENA field.
	USB_HPRT_PRTENA_Msk = 0x4
	// Bit PRTENA.
	USB_HPRT_PRTENA = 0x4
	// Position of PRTENCHNG field.
	USB_HPRT_PRTENCHNG_Pos = 0x3
	// Bit mask of PRTENCHNG field.
	USB_HPRT_PRTENCHNG_Msk = 0x8
	// Bit PRTENCHNG.
	USB_HPRT_PRTENCHNG = 0x8
	// Position of PRTOVRCURRACT field.
	USB_HPRT_PRTOVRCURRACT_Pos = 0x4
	// Bit mask of PRTOVRCURRACT field.
	USB_HPRT_PRTOVRCURRACT_Msk = 0x10
	// Bit PRTOVRCURRACT.
	USB_HPRT_PRTOVRCURRACT = 0x10
	// Position of PRTOVRCURRCHNG field.
	USB_HPRT_PRTOVRCURRCHNG_Pos = 0x5
	// Bit mask of PRTOVRCURRCHNG field.
	USB_HPRT_PRTOVRCURRCHNG_Msk = 0x20
	// Bit PRTOVRCURRCHNG.
	USB_HPRT_PRTOVRCURRCHNG = 0x20
	// Position of PRTRES field.
	USB_HPRT_PRTRES_Pos = 0x6
	// Bit mask of PRTRES field.
	USB_HPRT_PRTRES_Msk = 0x40
	// Bit PRTRES.
	USB_HPRT_PRTRES = 0x40
	// Position of PRTSUSP field.
	USB_HPRT_PRTSUSP_Pos = 0x7
	// Bit mask of PRTSUSP field.
	USB_HPRT_PRTSUSP_Msk = 0x80
	// Bit PRTSUSP.
	USB_HPRT_PRTSUSP = 0x80
	// Position of PRTRST field.
	USB_HPRT_PRTRST_Pos = 0x8
	// Bit mask of PRTRST field.
	USB_HPRT_PRTRST_Msk = 0x100
	// Bit PRTRST.
	USB_HPRT_PRTRST = 0x100
	// Position of PRTLNSTS field.
	USB_HPRT_PRTLNSTS_Pos = 0xa
	// Bit mask of PRTLNSTS field.
	USB_HPRT_PRTLNSTS_Msk = 0xc00
	// Position of PRTPWR field.
	USB_HPRT_PRTPWR_Pos = 0xc
	// Bit mask of PRTPWR field.
	USB_HPRT_PRTPWR_Msk = 0x1000
	// Bit PRTPWR.
	USB_HPRT_PRTPWR = 0x1000
	// Position of PRTTSTCTL field.
	USB_HPRT_PRTTSTCTL_Pos = 0xd
	// Bit mask of PRTTSTCTL field.
	USB_HPRT_PRTTSTCTL_Msk = 0x1e000
	// Position of PRTSPD field.
	USB_HPRT_PRTSPD_Pos = 0x11
	// Bit mask of PRTSPD field.
	USB_HPRT_PRTSPD_Msk = 0x60000

	// HCCHAR0
	// Position of H_MPS0 field.
	USB_HCCHAR0_H_MPS0_Pos = 0x0
	// Bit mask of H_MPS0 field.
	USB_HCCHAR0_H_MPS0_Msk = 0x7ff
	// Position of H_EPNUM0 field.
	USB_HCCHAR0_H_EPNUM0_Pos = 0xb
	// Bit mask of H_EPNUM0 field.
	USB_HCCHAR0_H_EPNUM0_Msk = 0x7800
	// Position of H_EPDIR0 field.
	USB_HCCHAR0_H_EPDIR0_Pos = 0xf
	// Bit mask of H_EPDIR0 field.
	USB_HCCHAR0_H_EPDIR0_Msk = 0x8000
	// Bit H_EPDIR0.
	USB_HCCHAR0_H_EPDIR0 = 0x8000
	// Position of H_LSPDDEV0 field.
	USB_HCCHAR0_H_LSPDDEV0_Pos = 0x11
	// Bit mask of H_LSPDDEV0 field.
	USB_HCCHAR0_H_LSPDDEV0_Msk = 0x20000
	// Bit H_LSPDDEV0.
	USB_HCCHAR0_H_LSPDDEV0 = 0x20000
	// Position of H_EPTYPE0 field.
	USB_HCCHAR0_H_EPTYPE0_Pos = 0x12
	// Bit mask of H_EPTYPE0 field.
	USB_HCCHAR0_H_EPTYPE0_Msk = 0xc0000
	// Position of H_EC0 field.
	USB_HCCHAR0_H_EC0_Pos = 0x15
	// Bit mask of H_EC0 field.
	USB_HCCHAR0_H_EC0_Msk = 0x200000
	// Bit H_EC0.
	USB_HCCHAR0_H_EC0 = 0x200000
	// Position of H_DEVADDR0 field.
	USB_HCCHAR0_H_DEVADDR0_Pos = 0x16
	// Bit mask of H_DEVADDR0 field.
	USB_HCCHAR0_H_DEVADDR0_Msk = 0x1fc00000
	// Position of H_ODDFRM0 field.
	USB_HCCHAR0_H_ODDFRM0_Pos = 0x1d
	// Bit mask of H_ODDFRM0 field.
	USB_HCCHAR0_H_ODDFRM0_Msk = 0x20000000
	// Bit H_ODDFRM0.
	USB_HCCHAR0_H_ODDFRM0 = 0x20000000
	// Position of H_CHDIS0 field.
	USB_HCCHAR0_H_CHDIS0_Pos = 0x1e
	// Bit mask of H_CHDIS0 field.
	USB_HCCHAR0_H_CHDIS0_Msk = 0x40000000
	// Bit H_CHDIS0.
	USB_HCCHAR0_H_CHDIS0 = 0x40000000
	// Position of H_CHENA0 field.
	USB_HCCHAR0_H_CHENA0_Pos = 0x1f
	// Bit mask of H_CHENA0 field.
	USB_HCCHAR0_H_CHENA0_Msk = 0x80000000
	// Bit H_CHENA0.
	USB_HCCHAR0_H_CHENA0 = 0x80000000

	// HCINT0
	// Position of H_XFERCOMPL0 field.
	USB_HCINT0_H_XFERCOMPL0_Pos = 0x0
	// Bit mask of H_XFERCOMPL0 field.
	USB_HCINT0_H_XFERCOMPL0_Msk = 0x1
	// Bit H_XFERCOMPL0.
	USB_HCINT0_H_XFERCOMPL0 = 0x1
	// Position of H_CHHLTD0 field.
	USB_HCINT0_H_CHHLTD0_Pos = 0x1
	// Bit mask of H_CHHLTD0 field.
	USB_HCINT0_H_CHHLTD0_Msk = 0x2
	// Bit H_CHHLTD0.
	USB_HCINT0_H_CHHLTD0 = 0x2
	// Position of H_AHBERR0 field.
	USB_HCINT0_H_AHBERR0_Pos = 0x2
	// Bit mask of H_AHBERR0 field.
	USB_HCINT0_H_AHBERR0_Msk = 0x4
	// Bit H_AHBERR0.
	USB_HCINT0_H_AHBERR0 = 0x4
	// Position of H_STALL0 field.
	USB_HCINT0_H_STALL0_Pos = 0x3
	// Bit mask of H_STALL0 field.
	USB_HCINT0_H_STALL0_Msk = 0x8
	// Bit H_STALL0.
	USB_HCINT0_H_STALL0 = 0x8
	// Position of H_NACK0 field.
	USB_HCINT0_H_NACK0_Pos = 0x4
	// Bit mask of H_NACK0 field.
	USB_HCINT0_H_NACK0_Msk = 0x10
	// Bit H_NACK0.
	USB_HCINT0_H_NACK0 = 0x10
	// Position of H_ACK0 field.
	USB_HCINT0_H_ACK0_Pos = 0x5
	// Bit mask of H_ACK0 field.
	USB_HCINT0_H_ACK0_Msk = 0x20
	// Bit H_ACK0.
	USB_HCINT0_H_ACK0 = 0x20
	// Position of H_NYET0 field.
	USB_HCINT0_H_NYET0_Pos = 0x6
	// Bit mask of H_NYET0 field.
	USB_HCINT0_H_NYET0_Msk = 0x40
	// Bit H_NYET0.
	USB_HCINT0_H_NYET0 = 0x40
	// Position of H_XACTERR0 field.
	USB_HCINT0_H_XACTERR0_Pos = 0x7
	// Bit mask of H_XACTERR0 field.
	USB_HCINT0_H_XACTERR0_Msk = 0x80
	// Bit H_XACTERR0.
	USB_HCINT0_H_XACTERR0 = 0x80
	// Position of H_BBLERR0 field.
	USB_HCINT0_H_BBLERR0_Pos = 0x8
	// Bit mask of H_BBLERR0 field.
	USB_HCINT0_H_BBLERR0_Msk = 0x100
	// Bit H_BBLERR0.
	USB_HCINT0_H_BBLERR0 = 0x100
	// Position of H_FRMOVRUN0 field.
	USB_HCINT0_H_FRMOVRUN0_Pos = 0x9
	// Bit mask of H_FRMOVRUN0 field.
	USB_HCINT0_H_FRMOVRUN0_Msk = 0x200
	// Bit H_FRMOVRUN0.
	USB_HCINT0_H_FRMOVRUN0 = 0x200
	// Position of H_DATATGLERR0 field.
	USB_HCINT0_H_DATATGLERR0_Pos = 0xa
	// Bit mask of H_DATATGLERR0 field.
	USB_HCINT0_H_DATATGLERR0_Msk = 0x400
	// Bit H_DATATGLERR0.
	USB_HCINT0_H_DATATGLERR0 = 0x400
	// Position of H_BNAINTR0 field.
	USB_HCINT0_H_BNAINTR0_Pos = 0xb
	// Bit mask of H_BNAINTR0 field.
	USB_HCINT0_H_BNAINTR0_Msk = 0x800
	// Bit H_BNAINTR0.
	USB_HCINT0_H_BNAINTR0 = 0x800
	// Position of H_XCS_XACT_ERR0 field.
	USB_HCINT0_H_XCS_XACT_ERR0_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR0 field.
	USB_HCINT0_H_XCS_XACT_ERR0_Msk = 0x1000
	// Bit H_XCS_XACT_ERR0.
	USB_HCINT0_H_XCS_XACT_ERR0 = 0x1000
	// Position of H_DESC_LST_ROLLINTR0 field.
	USB_HCINT0_H_DESC_LST_ROLLINTR0_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR0 field.
	USB_HCINT0_H_DESC_LST_ROLLINTR0_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR0.
	USB_HCINT0_H_DESC_LST_ROLLINTR0 = 0x2000

	// HCINTMSK0
	// Position of H_XFERCOMPLMSK0 field.
	USB_HCINTMSK0_H_XFERCOMPLMSK0_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK0 field.
	USB_HCINTMSK0_H_XFERCOMPLMSK0_Msk = 0x1
	// Bit H_XFERCOMPLMSK0.
	USB_HCINTMSK0_H_XFERCOMPLMSK0 = 0x1
	// Position of H_CHHLTDMSK0 field.
	USB_HCINTMSK0_H_CHHLTDMSK0_Pos = 0x1
	// Bit mask of H_CHHLTDMSK0 field.
	USB_HCINTMSK0_H_CHHLTDMSK0_Msk = 0x2
	// Bit H_CHHLTDMSK0.
	USB_HCINTMSK0_H_CHHLTDMSK0 = 0x2
	// Position of H_AHBERRMSK0 field.
	USB_HCINTMSK0_H_AHBERRMSK0_Pos = 0x2
	// Bit mask of H_AHBERRMSK0 field.
	USB_HCINTMSK0_H_AHBERRMSK0_Msk = 0x4
	// Bit H_AHBERRMSK0.
	USB_HCINTMSK0_H_AHBERRMSK0 = 0x4
	// Position of H_STALLMSK0 field.
	USB_HCINTMSK0_H_STALLMSK0_Pos = 0x3
	// Bit mask of H_STALLMSK0 field.
	USB_HCINTMSK0_H_STALLMSK0_Msk = 0x8
	// Bit H_STALLMSK0.
	USB_HCINTMSK0_H_STALLMSK0 = 0x8
	// Position of H_NAKMSK0 field.
	USB_HCINTMSK0_H_NAKMSK0_Pos = 0x4
	// Bit mask of H_NAKMSK0 field.
	USB_HCINTMSK0_H_NAKMSK0_Msk = 0x10
	// Bit H_NAKMSK0.
	USB_HCINTMSK0_H_NAKMSK0 = 0x10
	// Position of H_ACKMSK0 field.
	USB_HCINTMSK0_H_ACKMSK0_Pos = 0x5
	// Bit mask of H_ACKMSK0 field.
	USB_HCINTMSK0_H_ACKMSK0_Msk = 0x20
	// Bit H_ACKMSK0.
	USB_HCINTMSK0_H_ACKMSK0 = 0x20
	// Position of H_NYETMSK0 field.
	USB_HCINTMSK0_H_NYETMSK0_Pos = 0x6
	// Bit mask of H_NYETMSK0 field.
	USB_HCINTMSK0_H_NYETMSK0_Msk = 0x40
	// Bit H_NYETMSK0.
	USB_HCINTMSK0_H_NYETMSK0 = 0x40
	// Position of H_XACTERRMSK0 field.
	USB_HCINTMSK0_H_XACTERRMSK0_Pos = 0x7
	// Bit mask of H_XACTERRMSK0 field.
	USB_HCINTMSK0_H_XACTERRMSK0_Msk = 0x80
	// Bit H_XACTERRMSK0.
	USB_HCINTMSK0_H_XACTERRMSK0 = 0x80
	// Position of H_BBLERRMSK0 field.
	USB_HCINTMSK0_H_BBLERRMSK0_Pos = 0x8
	// Bit mask of H_BBLERRMSK0 field.
	USB_HCINTMSK0_H_BBLERRMSK0_Msk = 0x100
	// Bit H_BBLERRMSK0.
	USB_HCINTMSK0_H_BBLERRMSK0 = 0x100
	// Position of H_FRMOVRUNMSK0 field.
	USB_HCINTMSK0_H_FRMOVRUNMSK0_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK0 field.
	USB_HCINTMSK0_H_FRMOVRUNMSK0_Msk = 0x200
	// Bit H_FRMOVRUNMSK0.
	USB_HCINTMSK0_H_FRMOVRUNMSK0 = 0x200
	// Position of H_DATATGLERRMSK0 field.
	USB_HCINTMSK0_H_DATATGLERRMSK0_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK0 field.
	USB_HCINTMSK0_H_DATATGLERRMSK0_Msk = 0x400
	// Bit H_DATATGLERRMSK0.
	USB_HCINTMSK0_H_DATATGLERRMSK0 = 0x400
	// Position of H_BNAINTRMSK0 field.
	USB_HCINTMSK0_H_BNAINTRMSK0_Pos = 0xb
	// Bit mask of H_BNAINTRMSK0 field.
	USB_HCINTMSK0_H_BNAINTRMSK0_Msk = 0x800
	// Bit H_BNAINTRMSK0.
	USB_HCINTMSK0_H_BNAINTRMSK0 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK0 field.
	USB_HCINTMSK0_H_DESC_LST_ROLLINTRMSK0_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK0 field.
	USB_HCINTMSK0_H_DESC_LST_ROLLINTRMSK0_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK0.
	USB_HCINTMSK0_H_DESC_LST_ROLLINTRMSK0 = 0x2000

	// HCTSIZ0
	// Position of H_XFERSIZE0 field.
	USB_HCTSIZ0_H_XFERSIZE0_Pos = 0x0
	// Bit mask of H_XFERSIZE0 field.
	USB_HCTSIZ0_H_XFERSIZE0_Msk = 0x7ffff
	// Position of H_PKTCNT0 field.
	USB_HCTSIZ0_H_PKTCNT0_Pos = 0x13
	// Bit mask of H_PKTCNT0 field.
	USB_HCTSIZ0_H_PKTCNT0_Msk = 0x1ff80000
	// Position of H_PID0 field.
	USB_HCTSIZ0_H_PID0_Pos = 0x1d
	// Bit mask of H_PID0 field.
	USB_HCTSIZ0_H_PID0_Msk = 0x60000000
	// Position of H_DOPNG0 field.
	USB_HCTSIZ0_H_DOPNG0_Pos = 0x1f
	// Bit mask of H_DOPNG0 field.
	USB_HCTSIZ0_H_DOPNG0_Msk = 0x80000000
	// Bit H_DOPNG0.
	USB_HCTSIZ0_H_DOPNG0 = 0x80000000

	// HCDMA0
	// Position of H_DMAADDR0 field.
	USB_HCDMA0_H_DMAADDR0_Pos = 0x0
	// Bit mask of H_DMAADDR0 field.
	USB_HCDMA0_H_DMAADDR0_Msk = 0xffffffff

	// HCDMAB0
	// Position of H_HCDMAB0 field.
	USB_HCDMAB0_H_HCDMAB0_Pos = 0x0
	// Bit mask of H_HCDMAB0 field.
	USB_HCDMAB0_H_HCDMAB0_Msk = 0xffffffff

	// HCCHAR1
	// Position of H_MPS1 field.
	USB_HCCHAR1_H_MPS1_Pos = 0x0
	// Bit mask of H_MPS1 field.
	USB_HCCHAR1_H_MPS1_Msk = 0x7ff
	// Position of H_EPNUM1 field.
	USB_HCCHAR1_H_EPNUM1_Pos = 0xb
	// Bit mask of H_EPNUM1 field.
	USB_HCCHAR1_H_EPNUM1_Msk = 0x7800
	// Position of H_EPDIR1 field.
	USB_HCCHAR1_H_EPDIR1_Pos = 0xf
	// Bit mask of H_EPDIR1 field.
	USB_HCCHAR1_H_EPDIR1_Msk = 0x8000
	// Bit H_EPDIR1.
	USB_HCCHAR1_H_EPDIR1 = 0x8000
	// Position of H_LSPDDEV1 field.
	USB_HCCHAR1_H_LSPDDEV1_Pos = 0x11
	// Bit mask of H_LSPDDEV1 field.
	USB_HCCHAR1_H_LSPDDEV1_Msk = 0x20000
	// Bit H_LSPDDEV1.
	USB_HCCHAR1_H_LSPDDEV1 = 0x20000
	// Position of H_EPTYPE1 field.
	USB_HCCHAR1_H_EPTYPE1_Pos = 0x12
	// Bit mask of H_EPTYPE1 field.
	USB_HCCHAR1_H_EPTYPE1_Msk = 0xc0000
	// Position of H_EC1 field.
	USB_HCCHAR1_H_EC1_Pos = 0x15
	// Bit mask of H_EC1 field.
	USB_HCCHAR1_H_EC1_Msk = 0x200000
	// Bit H_EC1.
	USB_HCCHAR1_H_EC1 = 0x200000
	// Position of H_DEVADDR1 field.
	USB_HCCHAR1_H_DEVADDR1_Pos = 0x16
	// Bit mask of H_DEVADDR1 field.
	USB_HCCHAR1_H_DEVADDR1_Msk = 0x1fc00000
	// Position of H_ODDFRM1 field.
	USB_HCCHAR1_H_ODDFRM1_Pos = 0x1d
	// Bit mask of H_ODDFRM1 field.
	USB_HCCHAR1_H_ODDFRM1_Msk = 0x20000000
	// Bit H_ODDFRM1.
	USB_HCCHAR1_H_ODDFRM1 = 0x20000000
	// Position of H_CHDIS1 field.
	USB_HCCHAR1_H_CHDIS1_Pos = 0x1e
	// Bit mask of H_CHDIS1 field.
	USB_HCCHAR1_H_CHDIS1_Msk = 0x40000000
	// Bit H_CHDIS1.
	USB_HCCHAR1_H_CHDIS1 = 0x40000000
	// Position of H_CHENA1 field.
	USB_HCCHAR1_H_CHENA1_Pos = 0x1f
	// Bit mask of H_CHENA1 field.
	USB_HCCHAR1_H_CHENA1_Msk = 0x80000000
	// Bit H_CHENA1.
	USB_HCCHAR1_H_CHENA1 = 0x80000000

	// HCINT1
	// Position of H_XFERCOMPL1 field.
	USB_HCINT1_H_XFERCOMPL1_Pos = 0x0
	// Bit mask of H_XFERCOMPL1 field.
	USB_HCINT1_H_XFERCOMPL1_Msk = 0x1
	// Bit H_XFERCOMPL1.
	USB_HCINT1_H_XFERCOMPL1 = 0x1
	// Position of H_CHHLTD1 field.
	USB_HCINT1_H_CHHLTD1_Pos = 0x1
	// Bit mask of H_CHHLTD1 field.
	USB_HCINT1_H_CHHLTD1_Msk = 0x2
	// Bit H_CHHLTD1.
	USB_HCINT1_H_CHHLTD1 = 0x2
	// Position of H_AHBERR1 field.
	USB_HCINT1_H_AHBERR1_Pos = 0x2
	// Bit mask of H_AHBERR1 field.
	USB_HCINT1_H_AHBERR1_Msk = 0x4
	// Bit H_AHBERR1.
	USB_HCINT1_H_AHBERR1 = 0x4
	// Position of H_STALL1 field.
	USB_HCINT1_H_STALL1_Pos = 0x3
	// Bit mask of H_STALL1 field.
	USB_HCINT1_H_STALL1_Msk = 0x8
	// Bit H_STALL1.
	USB_HCINT1_H_STALL1 = 0x8
	// Position of H_NACK1 field.
	USB_HCINT1_H_NACK1_Pos = 0x4
	// Bit mask of H_NACK1 field.
	USB_HCINT1_H_NACK1_Msk = 0x10
	// Bit H_NACK1.
	USB_HCINT1_H_NACK1 = 0x10
	// Position of H_ACK1 field.
	USB_HCINT1_H_ACK1_Pos = 0x5
	// Bit mask of H_ACK1 field.
	USB_HCINT1_H_ACK1_Msk = 0x20
	// Bit H_ACK1.
	USB_HCINT1_H_ACK1 = 0x20
	// Position of H_NYET1 field.
	USB_HCINT1_H_NYET1_Pos = 0x6
	// Bit mask of H_NYET1 field.
	USB_HCINT1_H_NYET1_Msk = 0x40
	// Bit H_NYET1.
	USB_HCINT1_H_NYET1 = 0x40
	// Position of H_XACTERR1 field.
	USB_HCINT1_H_XACTERR1_Pos = 0x7
	// Bit mask of H_XACTERR1 field.
	USB_HCINT1_H_XACTERR1_Msk = 0x80
	// Bit H_XACTERR1.
	USB_HCINT1_H_XACTERR1 = 0x80
	// Position of H_BBLERR1 field.
	USB_HCINT1_H_BBLERR1_Pos = 0x8
	// Bit mask of H_BBLERR1 field.
	USB_HCINT1_H_BBLERR1_Msk = 0x100
	// Bit H_BBLERR1.
	USB_HCINT1_H_BBLERR1 = 0x100
	// Position of H_FRMOVRUN1 field.
	USB_HCINT1_H_FRMOVRUN1_Pos = 0x9
	// Bit mask of H_FRMOVRUN1 field.
	USB_HCINT1_H_FRMOVRUN1_Msk = 0x200
	// Bit H_FRMOVRUN1.
	USB_HCINT1_H_FRMOVRUN1 = 0x200
	// Position of H_DATATGLERR1 field.
	USB_HCINT1_H_DATATGLERR1_Pos = 0xa
	// Bit mask of H_DATATGLERR1 field.
	USB_HCINT1_H_DATATGLERR1_Msk = 0x400
	// Bit H_DATATGLERR1.
	USB_HCINT1_H_DATATGLERR1 = 0x400
	// Position of H_BNAINTR1 field.
	USB_HCINT1_H_BNAINTR1_Pos = 0xb
	// Bit mask of H_BNAINTR1 field.
	USB_HCINT1_H_BNAINTR1_Msk = 0x800
	// Bit H_BNAINTR1.
	USB_HCINT1_H_BNAINTR1 = 0x800
	// Position of H_XCS_XACT_ERR1 field.
	USB_HCINT1_H_XCS_XACT_ERR1_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR1 field.
	USB_HCINT1_H_XCS_XACT_ERR1_Msk = 0x1000
	// Bit H_XCS_XACT_ERR1.
	USB_HCINT1_H_XCS_XACT_ERR1 = 0x1000
	// Position of H_DESC_LST_ROLLINTR1 field.
	USB_HCINT1_H_DESC_LST_ROLLINTR1_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR1 field.
	USB_HCINT1_H_DESC_LST_ROLLINTR1_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR1.
	USB_HCINT1_H_DESC_LST_ROLLINTR1 = 0x2000

	// HCINTMSK1
	// Position of H_XFERCOMPLMSK1 field.
	USB_HCINTMSK1_H_XFERCOMPLMSK1_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK1 field.
	USB_HCINTMSK1_H_XFERCOMPLMSK1_Msk = 0x1
	// Bit H_XFERCOMPLMSK1.
	USB_HCINTMSK1_H_XFERCOMPLMSK1 = 0x1
	// Position of H_CHHLTDMSK1 field.
	USB_HCINTMSK1_H_CHHLTDMSK1_Pos = 0x1
	// Bit mask of H_CHHLTDMSK1 field.
	USB_HCINTMSK1_H_CHHLTDMSK1_Msk = 0x2
	// Bit H_CHHLTDMSK1.
	USB_HCINTMSK1_H_CHHLTDMSK1 = 0x2
	// Position of H_AHBERRMSK1 field.
	USB_HCINTMSK1_H_AHBERRMSK1_Pos = 0x2
	// Bit mask of H_AHBERRMSK1 field.
	USB_HCINTMSK1_H_AHBERRMSK1_Msk = 0x4
	// Bit H_AHBERRMSK1.
	USB_HCINTMSK1_H_AHBERRMSK1 = 0x4
	// Position of H_STALLMSK1 field.
	USB_HCINTMSK1_H_STALLMSK1_Pos = 0x3
	// Bit mask of H_STALLMSK1 field.
	USB_HCINTMSK1_H_STALLMSK1_Msk = 0x8
	// Bit H_STALLMSK1.
	USB_HCINTMSK1_H_STALLMSK1 = 0x8
	// Position of H_NAKMSK1 field.
	USB_HCINTMSK1_H_NAKMSK1_Pos = 0x4
	// Bit mask of H_NAKMSK1 field.
	USB_HCINTMSK1_H_NAKMSK1_Msk = 0x10
	// Bit H_NAKMSK1.
	USB_HCINTMSK1_H_NAKMSK1 = 0x10
	// Position of H_ACKMSK1 field.
	USB_HCINTMSK1_H_ACKMSK1_Pos = 0x5
	// Bit mask of H_ACKMSK1 field.
	USB_HCINTMSK1_H_ACKMSK1_Msk = 0x20
	// Bit H_ACKMSK1.
	USB_HCINTMSK1_H_ACKMSK1 = 0x20
	// Position of H_NYETMSK1 field.
	USB_HCINTMSK1_H_NYETMSK1_Pos = 0x6
	// Bit mask of H_NYETMSK1 field.
	USB_HCINTMSK1_H_NYETMSK1_Msk = 0x40
	// Bit H_NYETMSK1.
	USB_HCINTMSK1_H_NYETMSK1 = 0x40
	// Position of H_XACTERRMSK1 field.
	USB_HCINTMSK1_H_XACTERRMSK1_Pos = 0x7
	// Bit mask of H_XACTERRMSK1 field.
	USB_HCINTMSK1_H_XACTERRMSK1_Msk = 0x80
	// Bit H_XACTERRMSK1.
	USB_HCINTMSK1_H_XACTERRMSK1 = 0x80
	// Position of H_BBLERRMSK1 field.
	USB_HCINTMSK1_H_BBLERRMSK1_Pos = 0x8
	// Bit mask of H_BBLERRMSK1 field.
	USB_HCINTMSK1_H_BBLERRMSK1_Msk = 0x100
	// Bit H_BBLERRMSK1.
	USB_HCINTMSK1_H_BBLERRMSK1 = 0x100
	// Position of H_FRMOVRUNMSK1 field.
	USB_HCINTMSK1_H_FRMOVRUNMSK1_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK1 field.
	USB_HCINTMSK1_H_FRMOVRUNMSK1_Msk = 0x200
	// Bit H_FRMOVRUNMSK1.
	USB_HCINTMSK1_H_FRMOVRUNMSK1 = 0x200
	// Position of H_DATATGLERRMSK1 field.
	USB_HCINTMSK1_H_DATATGLERRMSK1_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK1 field.
	USB_HCINTMSK1_H_DATATGLERRMSK1_Msk = 0x400
	// Bit H_DATATGLERRMSK1.
	USB_HCINTMSK1_H_DATATGLERRMSK1 = 0x400
	// Position of H_BNAINTRMSK1 field.
	USB_HCINTMSK1_H_BNAINTRMSK1_Pos = 0xb
	// Bit mask of H_BNAINTRMSK1 field.
	USB_HCINTMSK1_H_BNAINTRMSK1_Msk = 0x800
	// Bit H_BNAINTRMSK1.
	USB_HCINTMSK1_H_BNAINTRMSK1 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK1 field.
	USB_HCINTMSK1_H_DESC_LST_ROLLINTRMSK1_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK1 field.
	USB_HCINTMSK1_H_DESC_LST_ROLLINTRMSK1_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK1.
	USB_HCINTMSK1_H_DESC_LST_ROLLINTRMSK1 = 0x2000

	// HCTSIZ1
	// Position of H_XFERSIZE1 field.
	USB_HCTSIZ1_H_XFERSIZE1_Pos = 0x0
	// Bit mask of H_XFERSIZE1 field.
	USB_HCTSIZ1_H_XFERSIZE1_Msk = 0x7ffff
	// Position of H_PKTCNT1 field.
	USB_HCTSIZ1_H_PKTCNT1_Pos = 0x13
	// Bit mask of H_PKTCNT1 field.
	USB_HCTSIZ1_H_PKTCNT1_Msk = 0x1ff80000
	// Position of H_PID1 field.
	USB_HCTSIZ1_H_PID1_Pos = 0x1d
	// Bit mask of H_PID1 field.
	USB_HCTSIZ1_H_PID1_Msk = 0x60000000
	// Position of H_DOPNG1 field.
	USB_HCTSIZ1_H_DOPNG1_Pos = 0x1f
	// Bit mask of H_DOPNG1 field.
	USB_HCTSIZ1_H_DOPNG1_Msk = 0x80000000
	// Bit H_DOPNG1.
	USB_HCTSIZ1_H_DOPNG1 = 0x80000000

	// HCDMA1
	// Position of H_DMAADDR1 field.
	USB_HCDMA1_H_DMAADDR1_Pos = 0x0
	// Bit mask of H_DMAADDR1 field.
	USB_HCDMA1_H_DMAADDR1_Msk = 0xffffffff

	// HCDMAB1
	// Position of H_HCDMAB1 field.
	USB_HCDMAB1_H_HCDMAB1_Pos = 0x0
	// Bit mask of H_HCDMAB1 field.
	USB_HCDMAB1_H_HCDMAB1_Msk = 0xffffffff

	// HCCHAR2
	// Position of H_MPS2 field.
	USB_HCCHAR2_H_MPS2_Pos = 0x0
	// Bit mask of H_MPS2 field.
	USB_HCCHAR2_H_MPS2_Msk = 0x7ff
	// Position of H_EPNUM2 field.
	USB_HCCHAR2_H_EPNUM2_Pos = 0xb
	// Bit mask of H_EPNUM2 field.
	USB_HCCHAR2_H_EPNUM2_Msk = 0x7800
	// Position of H_EPDIR2 field.
	USB_HCCHAR2_H_EPDIR2_Pos = 0xf
	// Bit mask of H_EPDIR2 field.
	USB_HCCHAR2_H_EPDIR2_Msk = 0x8000
	// Bit H_EPDIR2.
	USB_HCCHAR2_H_EPDIR2 = 0x8000
	// Position of H_LSPDDEV2 field.
	USB_HCCHAR2_H_LSPDDEV2_Pos = 0x11
	// Bit mask of H_LSPDDEV2 field.
	USB_HCCHAR2_H_LSPDDEV2_Msk = 0x20000
	// Bit H_LSPDDEV2.
	USB_HCCHAR2_H_LSPDDEV2 = 0x20000
	// Position of H_EPTYPE2 field.
	USB_HCCHAR2_H_EPTYPE2_Pos = 0x12
	// Bit mask of H_EPTYPE2 field.
	USB_HCCHAR2_H_EPTYPE2_Msk = 0xc0000
	// Position of H_EC2 field.
	USB_HCCHAR2_H_EC2_Pos = 0x15
	// Bit mask of H_EC2 field.
	USB_HCCHAR2_H_EC2_Msk = 0x200000
	// Bit H_EC2.
	USB_HCCHAR2_H_EC2 = 0x200000
	// Position of H_DEVADDR2 field.
	USB_HCCHAR2_H_DEVADDR2_Pos = 0x16
	// Bit mask of H_DEVADDR2 field.
	USB_HCCHAR2_H_DEVADDR2_Msk = 0x1fc00000
	// Position of H_ODDFRM2 field.
	USB_HCCHAR2_H_ODDFRM2_Pos = 0x1d
	// Bit mask of H_ODDFRM2 field.
	USB_HCCHAR2_H_ODDFRM2_Msk = 0x20000000
	// Bit H_ODDFRM2.
	USB_HCCHAR2_H_ODDFRM2 = 0x20000000
	// Position of H_CHDIS2 field.
	USB_HCCHAR2_H_CHDIS2_Pos = 0x1e
	// Bit mask of H_CHDIS2 field.
	USB_HCCHAR2_H_CHDIS2_Msk = 0x40000000
	// Bit H_CHDIS2.
	USB_HCCHAR2_H_CHDIS2 = 0x40000000
	// Position of H_CHENA2 field.
	USB_HCCHAR2_H_CHENA2_Pos = 0x1f
	// Bit mask of H_CHENA2 field.
	USB_HCCHAR2_H_CHENA2_Msk = 0x80000000
	// Bit H_CHENA2.
	USB_HCCHAR2_H_CHENA2 = 0x80000000

	// HCINT2
	// Position of H_XFERCOMPL2 field.
	USB_HCINT2_H_XFERCOMPL2_Pos = 0x0
	// Bit mask of H_XFERCOMPL2 field.
	USB_HCINT2_H_XFERCOMPL2_Msk = 0x1
	// Bit H_XFERCOMPL2.
	USB_HCINT2_H_XFERCOMPL2 = 0x1
	// Position of H_CHHLTD2 field.
	USB_HCINT2_H_CHHLTD2_Pos = 0x1
	// Bit mask of H_CHHLTD2 field.
	USB_HCINT2_H_CHHLTD2_Msk = 0x2
	// Bit H_CHHLTD2.
	USB_HCINT2_H_CHHLTD2 = 0x2
	// Position of H_AHBERR2 field.
	USB_HCINT2_H_AHBERR2_Pos = 0x2
	// Bit mask of H_AHBERR2 field.
	USB_HCINT2_H_AHBERR2_Msk = 0x4
	// Bit H_AHBERR2.
	USB_HCINT2_H_AHBERR2 = 0x4
	// Position of H_STALL2 field.
	USB_HCINT2_H_STALL2_Pos = 0x3
	// Bit mask of H_STALL2 field.
	USB_HCINT2_H_STALL2_Msk = 0x8
	// Bit H_STALL2.
	USB_HCINT2_H_STALL2 = 0x8
	// Position of H_NACK2 field.
	USB_HCINT2_H_NACK2_Pos = 0x4
	// Bit mask of H_NACK2 field.
	USB_HCINT2_H_NACK2_Msk = 0x10
	// Bit H_NACK2.
	USB_HCINT2_H_NACK2 = 0x10
	// Position of H_ACK2 field.
	USB_HCINT2_H_ACK2_Pos = 0x5
	// Bit mask of H_ACK2 field.
	USB_HCINT2_H_ACK2_Msk = 0x20
	// Bit H_ACK2.
	USB_HCINT2_H_ACK2 = 0x20
	// Position of H_NYET2 field.
	USB_HCINT2_H_NYET2_Pos = 0x6
	// Bit mask of H_NYET2 field.
	USB_HCINT2_H_NYET2_Msk = 0x40
	// Bit H_NYET2.
	USB_HCINT2_H_NYET2 = 0x40
	// Position of H_XACTERR2 field.
	USB_HCINT2_H_XACTERR2_Pos = 0x7
	// Bit mask of H_XACTERR2 field.
	USB_HCINT2_H_XACTERR2_Msk = 0x80
	// Bit H_XACTERR2.
	USB_HCINT2_H_XACTERR2 = 0x80
	// Position of H_BBLERR2 field.
	USB_HCINT2_H_BBLERR2_Pos = 0x8
	// Bit mask of H_BBLERR2 field.
	USB_HCINT2_H_BBLERR2_Msk = 0x100
	// Bit H_BBLERR2.
	USB_HCINT2_H_BBLERR2 = 0x100
	// Position of H_FRMOVRUN2 field.
	USB_HCINT2_H_FRMOVRUN2_Pos = 0x9
	// Bit mask of H_FRMOVRUN2 field.
	USB_HCINT2_H_FRMOVRUN2_Msk = 0x200
	// Bit H_FRMOVRUN2.
	USB_HCINT2_H_FRMOVRUN2 = 0x200
	// Position of H_DATATGLERR2 field.
	USB_HCINT2_H_DATATGLERR2_Pos = 0xa
	// Bit mask of H_DATATGLERR2 field.
	USB_HCINT2_H_DATATGLERR2_Msk = 0x400
	// Bit H_DATATGLERR2.
	USB_HCINT2_H_DATATGLERR2 = 0x400
	// Position of H_BNAINTR2 field.
	USB_HCINT2_H_BNAINTR2_Pos = 0xb
	// Bit mask of H_BNAINTR2 field.
	USB_HCINT2_H_BNAINTR2_Msk = 0x800
	// Bit H_BNAINTR2.
	USB_HCINT2_H_BNAINTR2 = 0x800
	// Position of H_XCS_XACT_ERR2 field.
	USB_HCINT2_H_XCS_XACT_ERR2_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR2 field.
	USB_HCINT2_H_XCS_XACT_ERR2_Msk = 0x1000
	// Bit H_XCS_XACT_ERR2.
	USB_HCINT2_H_XCS_XACT_ERR2 = 0x1000
	// Position of H_DESC_LST_ROLLINTR2 field.
	USB_HCINT2_H_DESC_LST_ROLLINTR2_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR2 field.
	USB_HCINT2_H_DESC_LST_ROLLINTR2_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR2.
	USB_HCINT2_H_DESC_LST_ROLLINTR2 = 0x2000

	// HCINTMSK2
	// Position of H_XFERCOMPLMSK2 field.
	USB_HCINTMSK2_H_XFERCOMPLMSK2_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK2 field.
	USB_HCINTMSK2_H_XFERCOMPLMSK2_Msk = 0x1
	// Bit H_XFERCOMPLMSK2.
	USB_HCINTMSK2_H_XFERCOMPLMSK2 = 0x1
	// Position of H_CHHLTDMSK2 field.
	USB_HCINTMSK2_H_CHHLTDMSK2_Pos = 0x1
	// Bit mask of H_CHHLTDMSK2 field.
	USB_HCINTMSK2_H_CHHLTDMSK2_Msk = 0x2
	// Bit H_CHHLTDMSK2.
	USB_HCINTMSK2_H_CHHLTDMSK2 = 0x2
	// Position of H_AHBERRMSK2 field.
	USB_HCINTMSK2_H_AHBERRMSK2_Pos = 0x2
	// Bit mask of H_AHBERRMSK2 field.
	USB_HCINTMSK2_H_AHBERRMSK2_Msk = 0x4
	// Bit H_AHBERRMSK2.
	USB_HCINTMSK2_H_AHBERRMSK2 = 0x4
	// Position of H_STALLMSK2 field.
	USB_HCINTMSK2_H_STALLMSK2_Pos = 0x3
	// Bit mask of H_STALLMSK2 field.
	USB_HCINTMSK2_H_STALLMSK2_Msk = 0x8
	// Bit H_STALLMSK2.
	USB_HCINTMSK2_H_STALLMSK2 = 0x8
	// Position of H_NAKMSK2 field.
	USB_HCINTMSK2_H_NAKMSK2_Pos = 0x4
	// Bit mask of H_NAKMSK2 field.
	USB_HCINTMSK2_H_NAKMSK2_Msk = 0x10
	// Bit H_NAKMSK2.
	USB_HCINTMSK2_H_NAKMSK2 = 0x10
	// Position of H_ACKMSK2 field.
	USB_HCINTMSK2_H_ACKMSK2_Pos = 0x5
	// Bit mask of H_ACKMSK2 field.
	USB_HCINTMSK2_H_ACKMSK2_Msk = 0x20
	// Bit H_ACKMSK2.
	USB_HCINTMSK2_H_ACKMSK2 = 0x20
	// Position of H_NYETMSK2 field.
	USB_HCINTMSK2_H_NYETMSK2_Pos = 0x6
	// Bit mask of H_NYETMSK2 field.
	USB_HCINTMSK2_H_NYETMSK2_Msk = 0x40
	// Bit H_NYETMSK2.
	USB_HCINTMSK2_H_NYETMSK2 = 0x40
	// Position of H_XACTERRMSK2 field.
	USB_HCINTMSK2_H_XACTERRMSK2_Pos = 0x7
	// Bit mask of H_XACTERRMSK2 field.
	USB_HCINTMSK2_H_XACTERRMSK2_Msk = 0x80
	// Bit H_XACTERRMSK2.
	USB_HCINTMSK2_H_XACTERRMSK2 = 0x80
	// Position of H_BBLERRMSK2 field.
	USB_HCINTMSK2_H_BBLERRMSK2_Pos = 0x8
	// Bit mask of H_BBLERRMSK2 field.
	USB_HCINTMSK2_H_BBLERRMSK2_Msk = 0x100
	// Bit H_BBLERRMSK2.
	USB_HCINTMSK2_H_BBLERRMSK2 = 0x100
	// Position of H_FRMOVRUNMSK2 field.
	USB_HCINTMSK2_H_FRMOVRUNMSK2_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK2 field.
	USB_HCINTMSK2_H_FRMOVRUNMSK2_Msk = 0x200
	// Bit H_FRMOVRUNMSK2.
	USB_HCINTMSK2_H_FRMOVRUNMSK2 = 0x200
	// Position of H_DATATGLERRMSK2 field.
	USB_HCINTMSK2_H_DATATGLERRMSK2_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK2 field.
	USB_HCINTMSK2_H_DATATGLERRMSK2_Msk = 0x400
	// Bit H_DATATGLERRMSK2.
	USB_HCINTMSK2_H_DATATGLERRMSK2 = 0x400
	// Position of H_BNAINTRMSK2 field.
	USB_HCINTMSK2_H_BNAINTRMSK2_Pos = 0xb
	// Bit mask of H_BNAINTRMSK2 field.
	USB_HCINTMSK2_H_BNAINTRMSK2_Msk = 0x800
	// Bit H_BNAINTRMSK2.
	USB_HCINTMSK2_H_BNAINTRMSK2 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK2 field.
	USB_HCINTMSK2_H_DESC_LST_ROLLINTRMSK2_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK2 field.
	USB_HCINTMSK2_H_DESC_LST_ROLLINTRMSK2_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK2.
	USB_HCINTMSK2_H_DESC_LST_ROLLINTRMSK2 = 0x2000

	// HCTSIZ2
	// Position of H_XFERSIZE2 field.
	USB_HCTSIZ2_H_XFERSIZE2_Pos = 0x0
	// Bit mask of H_XFERSIZE2 field.
	USB_HCTSIZ2_H_XFERSIZE2_Msk = 0x7ffff
	// Position of H_PKTCNT2 field.
	USB_HCTSIZ2_H_PKTCNT2_Pos = 0x13
	// Bit mask of H_PKTCNT2 field.
	USB_HCTSIZ2_H_PKTCNT2_Msk = 0x1ff80000
	// Position of H_PID2 field.
	USB_HCTSIZ2_H_PID2_Pos = 0x1d
	// Bit mask of H_PID2 field.
	USB_HCTSIZ2_H_PID2_Msk = 0x60000000
	// Position of H_DOPNG2 field.
	USB_HCTSIZ2_H_DOPNG2_Pos = 0x1f
	// Bit mask of H_DOPNG2 field.
	USB_HCTSIZ2_H_DOPNG2_Msk = 0x80000000
	// Bit H_DOPNG2.
	USB_HCTSIZ2_H_DOPNG2 = 0x80000000

	// HCDMA2
	// Position of H_DMAADDR2 field.
	USB_HCDMA2_H_DMAADDR2_Pos = 0x0
	// Bit mask of H_DMAADDR2 field.
	USB_HCDMA2_H_DMAADDR2_Msk = 0xffffffff

	// HCDMAB2
	// Position of H_HCDMAB2 field.
	USB_HCDMAB2_H_HCDMAB2_Pos = 0x0
	// Bit mask of H_HCDMAB2 field.
	USB_HCDMAB2_H_HCDMAB2_Msk = 0xffffffff

	// HCCHAR3
	// Position of H_MPS3 field.
	USB_HCCHAR3_H_MPS3_Pos = 0x0
	// Bit mask of H_MPS3 field.
	USB_HCCHAR3_H_MPS3_Msk = 0x7ff
	// Position of H_EPNUM3 field.
	USB_HCCHAR3_H_EPNUM3_Pos = 0xb
	// Bit mask of H_EPNUM3 field.
	USB_HCCHAR3_H_EPNUM3_Msk = 0x7800
	// Position of H_EPDIR3 field.
	USB_HCCHAR3_H_EPDIR3_Pos = 0xf
	// Bit mask of H_EPDIR3 field.
	USB_HCCHAR3_H_EPDIR3_Msk = 0x8000
	// Bit H_EPDIR3.
	USB_HCCHAR3_H_EPDIR3 = 0x8000
	// Position of H_LSPDDEV3 field.
	USB_HCCHAR3_H_LSPDDEV3_Pos = 0x11
	// Bit mask of H_LSPDDEV3 field.
	USB_HCCHAR3_H_LSPDDEV3_Msk = 0x20000
	// Bit H_LSPDDEV3.
	USB_HCCHAR3_H_LSPDDEV3 = 0x20000
	// Position of H_EPTYPE3 field.
	USB_HCCHAR3_H_EPTYPE3_Pos = 0x12
	// Bit mask of H_EPTYPE3 field.
	USB_HCCHAR3_H_EPTYPE3_Msk = 0xc0000
	// Position of H_EC3 field.
	USB_HCCHAR3_H_EC3_Pos = 0x15
	// Bit mask of H_EC3 field.
	USB_HCCHAR3_H_EC3_Msk = 0x200000
	// Bit H_EC3.
	USB_HCCHAR3_H_EC3 = 0x200000
	// Position of H_DEVADDR3 field.
	USB_HCCHAR3_H_DEVADDR3_Pos = 0x16
	// Bit mask of H_DEVADDR3 field.
	USB_HCCHAR3_H_DEVADDR3_Msk = 0x1fc00000
	// Position of H_ODDFRM3 field.
	USB_HCCHAR3_H_ODDFRM3_Pos = 0x1d
	// Bit mask of H_ODDFRM3 field.
	USB_HCCHAR3_H_ODDFRM3_Msk = 0x20000000
	// Bit H_ODDFRM3.
	USB_HCCHAR3_H_ODDFRM3 = 0x20000000
	// Position of H_CHDIS3 field.
	USB_HCCHAR3_H_CHDIS3_Pos = 0x1e
	// Bit mask of H_CHDIS3 field.
	USB_HCCHAR3_H_CHDIS3_Msk = 0x40000000
	// Bit H_CHDIS3.
	USB_HCCHAR3_H_CHDIS3 = 0x40000000
	// Position of H_CHENA3 field.
	USB_HCCHAR3_H_CHENA3_Pos = 0x1f
	// Bit mask of H_CHENA3 field.
	USB_HCCHAR3_H_CHENA3_Msk = 0x80000000
	// Bit H_CHENA3.
	USB_HCCHAR3_H_CHENA3 = 0x80000000

	// HCINT3
	// Position of H_XFERCOMPL3 field.
	USB_HCINT3_H_XFERCOMPL3_Pos = 0x0
	// Bit mask of H_XFERCOMPL3 field.
	USB_HCINT3_H_XFERCOMPL3_Msk = 0x1
	// Bit H_XFERCOMPL3.
	USB_HCINT3_H_XFERCOMPL3 = 0x1
	// Position of H_CHHLTD3 field.
	USB_HCINT3_H_CHHLTD3_Pos = 0x1
	// Bit mask of H_CHHLTD3 field.
	USB_HCINT3_H_CHHLTD3_Msk = 0x2
	// Bit H_CHHLTD3.
	USB_HCINT3_H_CHHLTD3 = 0x2
	// Position of H_AHBERR3 field.
	USB_HCINT3_H_AHBERR3_Pos = 0x2
	// Bit mask of H_AHBERR3 field.
	USB_HCINT3_H_AHBERR3_Msk = 0x4
	// Bit H_AHBERR3.
	USB_HCINT3_H_AHBERR3 = 0x4
	// Position of H_STALL3 field.
	USB_HCINT3_H_STALL3_Pos = 0x3
	// Bit mask of H_STALL3 field.
	USB_HCINT3_H_STALL3_Msk = 0x8
	// Bit H_STALL3.
	USB_HCINT3_H_STALL3 = 0x8
	// Position of H_NACK3 field.
	USB_HCINT3_H_NACK3_Pos = 0x4
	// Bit mask of H_NACK3 field.
	USB_HCINT3_H_NACK3_Msk = 0x10
	// Bit H_NACK3.
	USB_HCINT3_H_NACK3 = 0x10
	// Position of H_ACK3 field.
	USB_HCINT3_H_ACK3_Pos = 0x5
	// Bit mask of H_ACK3 field.
	USB_HCINT3_H_ACK3_Msk = 0x20
	// Bit H_ACK3.
	USB_HCINT3_H_ACK3 = 0x20
	// Position of H_NYET3 field.
	USB_HCINT3_H_NYET3_Pos = 0x6
	// Bit mask of H_NYET3 field.
	USB_HCINT3_H_NYET3_Msk = 0x40
	// Bit H_NYET3.
	USB_HCINT3_H_NYET3 = 0x40
	// Position of H_XACTERR3 field.
	USB_HCINT3_H_XACTERR3_Pos = 0x7
	// Bit mask of H_XACTERR3 field.
	USB_HCINT3_H_XACTERR3_Msk = 0x80
	// Bit H_XACTERR3.
	USB_HCINT3_H_XACTERR3 = 0x80
	// Position of H_BBLERR3 field.
	USB_HCINT3_H_BBLERR3_Pos = 0x8
	// Bit mask of H_BBLERR3 field.
	USB_HCINT3_H_BBLERR3_Msk = 0x100
	// Bit H_BBLERR3.
	USB_HCINT3_H_BBLERR3 = 0x100
	// Position of H_FRMOVRUN3 field.
	USB_HCINT3_H_FRMOVRUN3_Pos = 0x9
	// Bit mask of H_FRMOVRUN3 field.
	USB_HCINT3_H_FRMOVRUN3_Msk = 0x200
	// Bit H_FRMOVRUN3.
	USB_HCINT3_H_FRMOVRUN3 = 0x200
	// Position of H_DATATGLERR3 field.
	USB_HCINT3_H_DATATGLERR3_Pos = 0xa
	// Bit mask of H_DATATGLERR3 field.
	USB_HCINT3_H_DATATGLERR3_Msk = 0x400
	// Bit H_DATATGLERR3.
	USB_HCINT3_H_DATATGLERR3 = 0x400
	// Position of H_BNAINTR3 field.
	USB_HCINT3_H_BNAINTR3_Pos = 0xb
	// Bit mask of H_BNAINTR3 field.
	USB_HCINT3_H_BNAINTR3_Msk = 0x800
	// Bit H_BNAINTR3.
	USB_HCINT3_H_BNAINTR3 = 0x800
	// Position of H_XCS_XACT_ERR3 field.
	USB_HCINT3_H_XCS_XACT_ERR3_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR3 field.
	USB_HCINT3_H_XCS_XACT_ERR3_Msk = 0x1000
	// Bit H_XCS_XACT_ERR3.
	USB_HCINT3_H_XCS_XACT_ERR3 = 0x1000
	// Position of H_DESC_LST_ROLLINTR3 field.
	USB_HCINT3_H_DESC_LST_ROLLINTR3_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR3 field.
	USB_HCINT3_H_DESC_LST_ROLLINTR3_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR3.
	USB_HCINT3_H_DESC_LST_ROLLINTR3 = 0x2000

	// HCINTMSK3
	// Position of H_XFERCOMPLMSK3 field.
	USB_HCINTMSK3_H_XFERCOMPLMSK3_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK3 field.
	USB_HCINTMSK3_H_XFERCOMPLMSK3_Msk = 0x1
	// Bit H_XFERCOMPLMSK3.
	USB_HCINTMSK3_H_XFERCOMPLMSK3 = 0x1
	// Position of H_CHHLTDMSK3 field.
	USB_HCINTMSK3_H_CHHLTDMSK3_Pos = 0x1
	// Bit mask of H_CHHLTDMSK3 field.
	USB_HCINTMSK3_H_CHHLTDMSK3_Msk = 0x2
	// Bit H_CHHLTDMSK3.
	USB_HCINTMSK3_H_CHHLTDMSK3 = 0x2
	// Position of H_AHBERRMSK3 field.
	USB_HCINTMSK3_H_AHBERRMSK3_Pos = 0x2
	// Bit mask of H_AHBERRMSK3 field.
	USB_HCINTMSK3_H_AHBERRMSK3_Msk = 0x4
	// Bit H_AHBERRMSK3.
	USB_HCINTMSK3_H_AHBERRMSK3 = 0x4
	// Position of H_STALLMSK3 field.
	USB_HCINTMSK3_H_STALLMSK3_Pos = 0x3
	// Bit mask of H_STALLMSK3 field.
	USB_HCINTMSK3_H_STALLMSK3_Msk = 0x8
	// Bit H_STALLMSK3.
	USB_HCINTMSK3_H_STALLMSK3 = 0x8
	// Position of H_NAKMSK3 field.
	USB_HCINTMSK3_H_NAKMSK3_Pos = 0x4
	// Bit mask of H_NAKMSK3 field.
	USB_HCINTMSK3_H_NAKMSK3_Msk = 0x10
	// Bit H_NAKMSK3.
	USB_HCINTMSK3_H_NAKMSK3 = 0x10
	// Position of H_ACKMSK3 field.
	USB_HCINTMSK3_H_ACKMSK3_Pos = 0x5
	// Bit mask of H_ACKMSK3 field.
	USB_HCINTMSK3_H_ACKMSK3_Msk = 0x20
	// Bit H_ACKMSK3.
	USB_HCINTMSK3_H_ACKMSK3 = 0x20
	// Position of H_NYETMSK3 field.
	USB_HCINTMSK3_H_NYETMSK3_Pos = 0x6
	// Bit mask of H_NYETMSK3 field.
	USB_HCINTMSK3_H_NYETMSK3_Msk = 0x40
	// Bit H_NYETMSK3.
	USB_HCINTMSK3_H_NYETMSK3 = 0x40
	// Position of H_XACTERRMSK3 field.
	USB_HCINTMSK3_H_XACTERRMSK3_Pos = 0x7
	// Bit mask of H_XACTERRMSK3 field.
	USB_HCINTMSK3_H_XACTERRMSK3_Msk = 0x80
	// Bit H_XACTERRMSK3.
	USB_HCINTMSK3_H_XACTERRMSK3 = 0x80
	// Position of H_BBLERRMSK3 field.
	USB_HCINTMSK3_H_BBLERRMSK3_Pos = 0x8
	// Bit mask of H_BBLERRMSK3 field.
	USB_HCINTMSK3_H_BBLERRMSK3_Msk = 0x100
	// Bit H_BBLERRMSK3.
	USB_HCINTMSK3_H_BBLERRMSK3 = 0x100
	// Position of H_FRMOVRUNMSK3 field.
	USB_HCINTMSK3_H_FRMOVRUNMSK3_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK3 field.
	USB_HCINTMSK3_H_FRMOVRUNMSK3_Msk = 0x200
	// Bit H_FRMOVRUNMSK3.
	USB_HCINTMSK3_H_FRMOVRUNMSK3 = 0x200
	// Position of H_DATATGLERRMSK3 field.
	USB_HCINTMSK3_H_DATATGLERRMSK3_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK3 field.
	USB_HCINTMSK3_H_DATATGLERRMSK3_Msk = 0x400
	// Bit H_DATATGLERRMSK3.
	USB_HCINTMSK3_H_DATATGLERRMSK3 = 0x400
	// Position of H_BNAINTRMSK3 field.
	USB_HCINTMSK3_H_BNAINTRMSK3_Pos = 0xb
	// Bit mask of H_BNAINTRMSK3 field.
	USB_HCINTMSK3_H_BNAINTRMSK3_Msk = 0x800
	// Bit H_BNAINTRMSK3.
	USB_HCINTMSK3_H_BNAINTRMSK3 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK3 field.
	USB_HCINTMSK3_H_DESC_LST_ROLLINTRMSK3_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK3 field.
	USB_HCINTMSK3_H_DESC_LST_ROLLINTRMSK3_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK3.
	USB_HCINTMSK3_H_DESC_LST_ROLLINTRMSK3 = 0x2000

	// HCTSIZ3
	// Position of H_XFERSIZE3 field.
	USB_HCTSIZ3_H_XFERSIZE3_Pos = 0x0
	// Bit mask of H_XFERSIZE3 field.
	USB_HCTSIZ3_H_XFERSIZE3_Msk = 0x7ffff
	// Position of H_PKTCNT3 field.
	USB_HCTSIZ3_H_PKTCNT3_Pos = 0x13
	// Bit mask of H_PKTCNT3 field.
	USB_HCTSIZ3_H_PKTCNT3_Msk = 0x1ff80000
	// Position of H_PID3 field.
	USB_HCTSIZ3_H_PID3_Pos = 0x1d
	// Bit mask of H_PID3 field.
	USB_HCTSIZ3_H_PID3_Msk = 0x60000000
	// Position of H_DOPNG3 field.
	USB_HCTSIZ3_H_DOPNG3_Pos = 0x1f
	// Bit mask of H_DOPNG3 field.
	USB_HCTSIZ3_H_DOPNG3_Msk = 0x80000000
	// Bit H_DOPNG3.
	USB_HCTSIZ3_H_DOPNG3 = 0x80000000

	// HCDMA3
	// Position of H_DMAADDR3 field.
	USB_HCDMA3_H_DMAADDR3_Pos = 0x0
	// Bit mask of H_DMAADDR3 field.
	USB_HCDMA3_H_DMAADDR3_Msk = 0xffffffff

	// HCDMAB3
	// Position of H_HCDMAB3 field.
	USB_HCDMAB3_H_HCDMAB3_Pos = 0x0
	// Bit mask of H_HCDMAB3 field.
	USB_HCDMAB3_H_HCDMAB3_Msk = 0xffffffff

	// HCCHAR4
	// Position of H_MPS4 field.
	USB_HCCHAR4_H_MPS4_Pos = 0x0
	// Bit mask of H_MPS4 field.
	USB_HCCHAR4_H_MPS4_Msk = 0x7ff
	// Position of H_EPNUM4 field.
	USB_HCCHAR4_H_EPNUM4_Pos = 0xb
	// Bit mask of H_EPNUM4 field.
	USB_HCCHAR4_H_EPNUM4_Msk = 0x7800
	// Position of H_EPDIR4 field.
	USB_HCCHAR4_H_EPDIR4_Pos = 0xf
	// Bit mask of H_EPDIR4 field.
	USB_HCCHAR4_H_EPDIR4_Msk = 0x8000
	// Bit H_EPDIR4.
	USB_HCCHAR4_H_EPDIR4 = 0x8000
	// Position of H_LSPDDEV4 field.
	USB_HCCHAR4_H_LSPDDEV4_Pos = 0x11
	// Bit mask of H_LSPDDEV4 field.
	USB_HCCHAR4_H_LSPDDEV4_Msk = 0x20000
	// Bit H_LSPDDEV4.
	USB_HCCHAR4_H_LSPDDEV4 = 0x20000
	// Position of H_EPTYPE4 field.
	USB_HCCHAR4_H_EPTYPE4_Pos = 0x12
	// Bit mask of H_EPTYPE4 field.
	USB_HCCHAR4_H_EPTYPE4_Msk = 0xc0000
	// Position of H_EC4 field.
	USB_HCCHAR4_H_EC4_Pos = 0x15
	// Bit mask of H_EC4 field.
	USB_HCCHAR4_H_EC4_Msk = 0x200000
	// Bit H_EC4.
	USB_HCCHAR4_H_EC4 = 0x200000
	// Position of H_DEVADDR4 field.
	USB_HCCHAR4_H_DEVADDR4_Pos = 0x16
	// Bit mask of H_DEVADDR4 field.
	USB_HCCHAR4_H_DEVADDR4_Msk = 0x1fc00000
	// Position of H_ODDFRM4 field.
	USB_HCCHAR4_H_ODDFRM4_Pos = 0x1d
	// Bit mask of H_ODDFRM4 field.
	USB_HCCHAR4_H_ODDFRM4_Msk = 0x20000000
	// Bit H_ODDFRM4.
	USB_HCCHAR4_H_ODDFRM4 = 0x20000000
	// Position of H_CHDIS4 field.
	USB_HCCHAR4_H_CHDIS4_Pos = 0x1e
	// Bit mask of H_CHDIS4 field.
	USB_HCCHAR4_H_CHDIS4_Msk = 0x40000000
	// Bit H_CHDIS4.
	USB_HCCHAR4_H_CHDIS4 = 0x40000000
	// Position of H_CHENA4 field.
	USB_HCCHAR4_H_CHENA4_Pos = 0x1f
	// Bit mask of H_CHENA4 field.
	USB_HCCHAR4_H_CHENA4_Msk = 0x80000000
	// Bit H_CHENA4.
	USB_HCCHAR4_H_CHENA4 = 0x80000000

	// HCINT4
	// Position of H_XFERCOMPL4 field.
	USB_HCINT4_H_XFERCOMPL4_Pos = 0x0
	// Bit mask of H_XFERCOMPL4 field.
	USB_HCINT4_H_XFERCOMPL4_Msk = 0x1
	// Bit H_XFERCOMPL4.
	USB_HCINT4_H_XFERCOMPL4 = 0x1
	// Position of H_CHHLTD4 field.
	USB_HCINT4_H_CHHLTD4_Pos = 0x1
	// Bit mask of H_CHHLTD4 field.
	USB_HCINT4_H_CHHLTD4_Msk = 0x2
	// Bit H_CHHLTD4.
	USB_HCINT4_H_CHHLTD4 = 0x2
	// Position of H_AHBERR4 field.
	USB_HCINT4_H_AHBERR4_Pos = 0x2
	// Bit mask of H_AHBERR4 field.
	USB_HCINT4_H_AHBERR4_Msk = 0x4
	// Bit H_AHBERR4.
	USB_HCINT4_H_AHBERR4 = 0x4
	// Position of H_STALL4 field.
	USB_HCINT4_H_STALL4_Pos = 0x3
	// Bit mask of H_STALL4 field.
	USB_HCINT4_H_STALL4_Msk = 0x8
	// Bit H_STALL4.
	USB_HCINT4_H_STALL4 = 0x8
	// Position of H_NACK4 field.
	USB_HCINT4_H_NACK4_Pos = 0x4
	// Bit mask of H_NACK4 field.
	USB_HCINT4_H_NACK4_Msk = 0x10
	// Bit H_NACK4.
	USB_HCINT4_H_NACK4 = 0x10
	// Position of H_ACK4 field.
	USB_HCINT4_H_ACK4_Pos = 0x5
	// Bit mask of H_ACK4 field.
	USB_HCINT4_H_ACK4_Msk = 0x20
	// Bit H_ACK4.
	USB_HCINT4_H_ACK4 = 0x20
	// Position of H_NYET4 field.
	USB_HCINT4_H_NYET4_Pos = 0x6
	// Bit mask of H_NYET4 field.
	USB_HCINT4_H_NYET4_Msk = 0x40
	// Bit H_NYET4.
	USB_HCINT4_H_NYET4 = 0x40
	// Position of H_XACTERR4 field.
	USB_HCINT4_H_XACTERR4_Pos = 0x7
	// Bit mask of H_XACTERR4 field.
	USB_HCINT4_H_XACTERR4_Msk = 0x80
	// Bit H_XACTERR4.
	USB_HCINT4_H_XACTERR4 = 0x80
	// Position of H_BBLERR4 field.
	USB_HCINT4_H_BBLERR4_Pos = 0x8
	// Bit mask of H_BBLERR4 field.
	USB_HCINT4_H_BBLERR4_Msk = 0x100
	// Bit H_BBLERR4.
	USB_HCINT4_H_BBLERR4 = 0x100
	// Position of H_FRMOVRUN4 field.
	USB_HCINT4_H_FRMOVRUN4_Pos = 0x9
	// Bit mask of H_FRMOVRUN4 field.
	USB_HCINT4_H_FRMOVRUN4_Msk = 0x200
	// Bit H_FRMOVRUN4.
	USB_HCINT4_H_FRMOVRUN4 = 0x200
	// Position of H_DATATGLERR4 field.
	USB_HCINT4_H_DATATGLERR4_Pos = 0xa
	// Bit mask of H_DATATGLERR4 field.
	USB_HCINT4_H_DATATGLERR4_Msk = 0x400
	// Bit H_DATATGLERR4.
	USB_HCINT4_H_DATATGLERR4 = 0x400
	// Position of H_BNAINTR4 field.
	USB_HCINT4_H_BNAINTR4_Pos = 0xb
	// Bit mask of H_BNAINTR4 field.
	USB_HCINT4_H_BNAINTR4_Msk = 0x800
	// Bit H_BNAINTR4.
	USB_HCINT4_H_BNAINTR4 = 0x800
	// Position of H_XCS_XACT_ERR4 field.
	USB_HCINT4_H_XCS_XACT_ERR4_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR4 field.
	USB_HCINT4_H_XCS_XACT_ERR4_Msk = 0x1000
	// Bit H_XCS_XACT_ERR4.
	USB_HCINT4_H_XCS_XACT_ERR4 = 0x1000
	// Position of H_DESC_LST_ROLLINTR4 field.
	USB_HCINT4_H_DESC_LST_ROLLINTR4_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR4 field.
	USB_HCINT4_H_DESC_LST_ROLLINTR4_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR4.
	USB_HCINT4_H_DESC_LST_ROLLINTR4 = 0x2000

	// HCINTMSK4
	// Position of H_XFERCOMPLMSK4 field.
	USB_HCINTMSK4_H_XFERCOMPLMSK4_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK4 field.
	USB_HCINTMSK4_H_XFERCOMPLMSK4_Msk = 0x1
	// Bit H_XFERCOMPLMSK4.
	USB_HCINTMSK4_H_XFERCOMPLMSK4 = 0x1
	// Position of H_CHHLTDMSK4 field.
	USB_HCINTMSK4_H_CHHLTDMSK4_Pos = 0x1
	// Bit mask of H_CHHLTDMSK4 field.
	USB_HCINTMSK4_H_CHHLTDMSK4_Msk = 0x2
	// Bit H_CHHLTDMSK4.
	USB_HCINTMSK4_H_CHHLTDMSK4 = 0x2
	// Position of H_AHBERRMSK4 field.
	USB_HCINTMSK4_H_AHBERRMSK4_Pos = 0x2
	// Bit mask of H_AHBERRMSK4 field.
	USB_HCINTMSK4_H_AHBERRMSK4_Msk = 0x4
	// Bit H_AHBERRMSK4.
	USB_HCINTMSK4_H_AHBERRMSK4 = 0x4
	// Position of H_STALLMSK4 field.
	USB_HCINTMSK4_H_STALLMSK4_Pos = 0x3
	// Bit mask of H_STALLMSK4 field.
	USB_HCINTMSK4_H_STALLMSK4_Msk = 0x8
	// Bit H_STALLMSK4.
	USB_HCINTMSK4_H_STALLMSK4 = 0x8
	// Position of H_NAKMSK4 field.
	USB_HCINTMSK4_H_NAKMSK4_Pos = 0x4
	// Bit mask of H_NAKMSK4 field.
	USB_HCINTMSK4_H_NAKMSK4_Msk = 0x10
	// Bit H_NAKMSK4.
	USB_HCINTMSK4_H_NAKMSK4 = 0x10
	// Position of H_ACKMSK4 field.
	USB_HCINTMSK4_H_ACKMSK4_Pos = 0x5
	// Bit mask of H_ACKMSK4 field.
	USB_HCINTMSK4_H_ACKMSK4_Msk = 0x20
	// Bit H_ACKMSK4.
	USB_HCINTMSK4_H_ACKMSK4 = 0x20
	// Position of H_NYETMSK4 field.
	USB_HCINTMSK4_H_NYETMSK4_Pos = 0x6
	// Bit mask of H_NYETMSK4 field.
	USB_HCINTMSK4_H_NYETMSK4_Msk = 0x40
	// Bit H_NYETMSK4.
	USB_HCINTMSK4_H_NYETMSK4 = 0x40
	// Position of H_XACTERRMSK4 field.
	USB_HCINTMSK4_H_XACTERRMSK4_Pos = 0x7
	// Bit mask of H_XACTERRMSK4 field.
	USB_HCINTMSK4_H_XACTERRMSK4_Msk = 0x80
	// Bit H_XACTERRMSK4.
	USB_HCINTMSK4_H_XACTERRMSK4 = 0x80
	// Position of H_BBLERRMSK4 field.
	USB_HCINTMSK4_H_BBLERRMSK4_Pos = 0x8
	// Bit mask of H_BBLERRMSK4 field.
	USB_HCINTMSK4_H_BBLERRMSK4_Msk = 0x100
	// Bit H_BBLERRMSK4.
	USB_HCINTMSK4_H_BBLERRMSK4 = 0x100
	// Position of H_FRMOVRUNMSK4 field.
	USB_HCINTMSK4_H_FRMOVRUNMSK4_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK4 field.
	USB_HCINTMSK4_H_FRMOVRUNMSK4_Msk = 0x200
	// Bit H_FRMOVRUNMSK4.
	USB_HCINTMSK4_H_FRMOVRUNMSK4 = 0x200
	// Position of H_DATATGLERRMSK4 field.
	USB_HCINTMSK4_H_DATATGLERRMSK4_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK4 field.
	USB_HCINTMSK4_H_DATATGLERRMSK4_Msk = 0x400
	// Bit H_DATATGLERRMSK4.
	USB_HCINTMSK4_H_DATATGLERRMSK4 = 0x400
	// Position of H_BNAINTRMSK4 field.
	USB_HCINTMSK4_H_BNAINTRMSK4_Pos = 0xb
	// Bit mask of H_BNAINTRMSK4 field.
	USB_HCINTMSK4_H_BNAINTRMSK4_Msk = 0x800
	// Bit H_BNAINTRMSK4.
	USB_HCINTMSK4_H_BNAINTRMSK4 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK4 field.
	USB_HCINTMSK4_H_DESC_LST_ROLLINTRMSK4_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK4 field.
	USB_HCINTMSK4_H_DESC_LST_ROLLINTRMSK4_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK4.
	USB_HCINTMSK4_H_DESC_LST_ROLLINTRMSK4 = 0x2000

	// HCTSIZ4
	// Position of H_XFERSIZE4 field.
	USB_HCTSIZ4_H_XFERSIZE4_Pos = 0x0
	// Bit mask of H_XFERSIZE4 field.
	USB_HCTSIZ4_H_XFERSIZE4_Msk = 0x7ffff
	// Position of H_PKTCNT4 field.
	USB_HCTSIZ4_H_PKTCNT4_Pos = 0x13
	// Bit mask of H_PKTCNT4 field.
	USB_HCTSIZ4_H_PKTCNT4_Msk = 0x1ff80000
	// Position of H_PID4 field.
	USB_HCTSIZ4_H_PID4_Pos = 0x1d
	// Bit mask of H_PID4 field.
	USB_HCTSIZ4_H_PID4_Msk = 0x60000000
	// Position of H_DOPNG4 field.
	USB_HCTSIZ4_H_DOPNG4_Pos = 0x1f
	// Bit mask of H_DOPNG4 field.
	USB_HCTSIZ4_H_DOPNG4_Msk = 0x80000000
	// Bit H_DOPNG4.
	USB_HCTSIZ4_H_DOPNG4 = 0x80000000

	// HCDMA4
	// Position of H_DMAADDR4 field.
	USB_HCDMA4_H_DMAADDR4_Pos = 0x0
	// Bit mask of H_DMAADDR4 field.
	USB_HCDMA4_H_DMAADDR4_Msk = 0xffffffff

	// HCDMAB4
	// Position of H_HCDMAB4 field.
	USB_HCDMAB4_H_HCDMAB4_Pos = 0x0
	// Bit mask of H_HCDMAB4 field.
	USB_HCDMAB4_H_HCDMAB4_Msk = 0xffffffff

	// HCCHAR5
	// Position of H_MPS5 field.
	USB_HCCHAR5_H_MPS5_Pos = 0x0
	// Bit mask of H_MPS5 field.
	USB_HCCHAR5_H_MPS5_Msk = 0x7ff
	// Position of H_EPNUM5 field.
	USB_HCCHAR5_H_EPNUM5_Pos = 0xb
	// Bit mask of H_EPNUM5 field.
	USB_HCCHAR5_H_EPNUM5_Msk = 0x7800
	// Position of H_EPDIR5 field.
	USB_HCCHAR5_H_EPDIR5_Pos = 0xf
	// Bit mask of H_EPDIR5 field.
	USB_HCCHAR5_H_EPDIR5_Msk = 0x8000
	// Bit H_EPDIR5.
	USB_HCCHAR5_H_EPDIR5 = 0x8000
	// Position of H_LSPDDEV5 field.
	USB_HCCHAR5_H_LSPDDEV5_Pos = 0x11
	// Bit mask of H_LSPDDEV5 field.
	USB_HCCHAR5_H_LSPDDEV5_Msk = 0x20000
	// Bit H_LSPDDEV5.
	USB_HCCHAR5_H_LSPDDEV5 = 0x20000
	// Position of H_EPTYPE5 field.
	USB_HCCHAR5_H_EPTYPE5_Pos = 0x12
	// Bit mask of H_EPTYPE5 field.
	USB_HCCHAR5_H_EPTYPE5_Msk = 0xc0000
	// Position of H_EC5 field.
	USB_HCCHAR5_H_EC5_Pos = 0x15
	// Bit mask of H_EC5 field.
	USB_HCCHAR5_H_EC5_Msk = 0x200000
	// Bit H_EC5.
	USB_HCCHAR5_H_EC5 = 0x200000
	// Position of H_DEVADDR5 field.
	USB_HCCHAR5_H_DEVADDR5_Pos = 0x16
	// Bit mask of H_DEVADDR5 field.
	USB_HCCHAR5_H_DEVADDR5_Msk = 0x1fc00000
	// Position of H_ODDFRM5 field.
	USB_HCCHAR5_H_ODDFRM5_Pos = 0x1d
	// Bit mask of H_ODDFRM5 field.
	USB_HCCHAR5_H_ODDFRM5_Msk = 0x20000000
	// Bit H_ODDFRM5.
	USB_HCCHAR5_H_ODDFRM5 = 0x20000000
	// Position of H_CHDIS5 field.
	USB_HCCHAR5_H_CHDIS5_Pos = 0x1e
	// Bit mask of H_CHDIS5 field.
	USB_HCCHAR5_H_CHDIS5_Msk = 0x40000000
	// Bit H_CHDIS5.
	USB_HCCHAR5_H_CHDIS5 = 0x40000000
	// Position of H_CHENA5 field.
	USB_HCCHAR5_H_CHENA5_Pos = 0x1f
	// Bit mask of H_CHENA5 field.
	USB_HCCHAR5_H_CHENA5_Msk = 0x80000000
	// Bit H_CHENA5.
	USB_HCCHAR5_H_CHENA5 = 0x80000000

	// HCINT5
	// Position of H_XFERCOMPL5 field.
	USB_HCINT5_H_XFERCOMPL5_Pos = 0x0
	// Bit mask of H_XFERCOMPL5 field.
	USB_HCINT5_H_XFERCOMPL5_Msk = 0x1
	// Bit H_XFERCOMPL5.
	USB_HCINT5_H_XFERCOMPL5 = 0x1
	// Position of H_CHHLTD5 field.
	USB_HCINT5_H_CHHLTD5_Pos = 0x1
	// Bit mask of H_CHHLTD5 field.
	USB_HCINT5_H_CHHLTD5_Msk = 0x2
	// Bit H_CHHLTD5.
	USB_HCINT5_H_CHHLTD5 = 0x2
	// Position of H_AHBERR5 field.
	USB_HCINT5_H_AHBERR5_Pos = 0x2
	// Bit mask of H_AHBERR5 field.
	USB_HCINT5_H_AHBERR5_Msk = 0x4
	// Bit H_AHBERR5.
	USB_HCINT5_H_AHBERR5 = 0x4
	// Position of H_STALL5 field.
	USB_HCINT5_H_STALL5_Pos = 0x3
	// Bit mask of H_STALL5 field.
	USB_HCINT5_H_STALL5_Msk = 0x8
	// Bit H_STALL5.
	USB_HCINT5_H_STALL5 = 0x8
	// Position of H_NACK5 field.
	USB_HCINT5_H_NACK5_Pos = 0x4
	// Bit mask of H_NACK5 field.
	USB_HCINT5_H_NACK5_Msk = 0x10
	// Bit H_NACK5.
	USB_HCINT5_H_NACK5 = 0x10
	// Position of H_ACK5 field.
	USB_HCINT5_H_ACK5_Pos = 0x5
	// Bit mask of H_ACK5 field.
	USB_HCINT5_H_ACK5_Msk = 0x20
	// Bit H_ACK5.
	USB_HCINT5_H_ACK5 = 0x20
	// Position of H_NYET5 field.
	USB_HCINT5_H_NYET5_Pos = 0x6
	// Bit mask of H_NYET5 field.
	USB_HCINT5_H_NYET5_Msk = 0x40
	// Bit H_NYET5.
	USB_HCINT5_H_NYET5 = 0x40
	// Position of H_XACTERR5 field.
	USB_HCINT5_H_XACTERR5_Pos = 0x7
	// Bit mask of H_XACTERR5 field.
	USB_HCINT5_H_XACTERR5_Msk = 0x80
	// Bit H_XACTERR5.
	USB_HCINT5_H_XACTERR5 = 0x80
	// Position of H_BBLERR5 field.
	USB_HCINT5_H_BBLERR5_Pos = 0x8
	// Bit mask of H_BBLERR5 field.
	USB_HCINT5_H_BBLERR5_Msk = 0x100
	// Bit H_BBLERR5.
	USB_HCINT5_H_BBLERR5 = 0x100
	// Position of H_FRMOVRUN5 field.
	USB_HCINT5_H_FRMOVRUN5_Pos = 0x9
	// Bit mask of H_FRMOVRUN5 field.
	USB_HCINT5_H_FRMOVRUN5_Msk = 0x200
	// Bit H_FRMOVRUN5.
	USB_HCINT5_H_FRMOVRUN5 = 0x200
	// Position of H_DATATGLERR5 field.
	USB_HCINT5_H_DATATGLERR5_Pos = 0xa
	// Bit mask of H_DATATGLERR5 field.
	USB_HCINT5_H_DATATGLERR5_Msk = 0x400
	// Bit H_DATATGLERR5.
	USB_HCINT5_H_DATATGLERR5 = 0x400
	// Position of H_BNAINTR5 field.
	USB_HCINT5_H_BNAINTR5_Pos = 0xb
	// Bit mask of H_BNAINTR5 field.
	USB_HCINT5_H_BNAINTR5_Msk = 0x800
	// Bit H_BNAINTR5.
	USB_HCINT5_H_BNAINTR5 = 0x800
	// Position of H_XCS_XACT_ERR5 field.
	USB_HCINT5_H_XCS_XACT_ERR5_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR5 field.
	USB_HCINT5_H_XCS_XACT_ERR5_Msk = 0x1000
	// Bit H_XCS_XACT_ERR5.
	USB_HCINT5_H_XCS_XACT_ERR5 = 0x1000
	// Position of H_DESC_LST_ROLLINTR5 field.
	USB_HCINT5_H_DESC_LST_ROLLINTR5_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR5 field.
	USB_HCINT5_H_DESC_LST_ROLLINTR5_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR5.
	USB_HCINT5_H_DESC_LST_ROLLINTR5 = 0x2000

	// HCINTMSK5
	// Position of H_XFERCOMPLMSK5 field.
	USB_HCINTMSK5_H_XFERCOMPLMSK5_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK5 field.
	USB_HCINTMSK5_H_XFERCOMPLMSK5_Msk = 0x1
	// Bit H_XFERCOMPLMSK5.
	USB_HCINTMSK5_H_XFERCOMPLMSK5 = 0x1
	// Position of H_CHHLTDMSK5 field.
	USB_HCINTMSK5_H_CHHLTDMSK5_Pos = 0x1
	// Bit mask of H_CHHLTDMSK5 field.
	USB_HCINTMSK5_H_CHHLTDMSK5_Msk = 0x2
	// Bit H_CHHLTDMSK5.
	USB_HCINTMSK5_H_CHHLTDMSK5 = 0x2
	// Position of H_AHBERRMSK5 field.
	USB_HCINTMSK5_H_AHBERRMSK5_Pos = 0x2
	// Bit mask of H_AHBERRMSK5 field.
	USB_HCINTMSK5_H_AHBERRMSK5_Msk = 0x4
	// Bit H_AHBERRMSK5.
	USB_HCINTMSK5_H_AHBERRMSK5 = 0x4
	// Position of H_STALLMSK5 field.
	USB_HCINTMSK5_H_STALLMSK5_Pos = 0x3
	// Bit mask of H_STALLMSK5 field.
	USB_HCINTMSK5_H_STALLMSK5_Msk = 0x8
	// Bit H_STALLMSK5.
	USB_HCINTMSK5_H_STALLMSK5 = 0x8
	// Position of H_NAKMSK5 field.
	USB_HCINTMSK5_H_NAKMSK5_Pos = 0x4
	// Bit mask of H_NAKMSK5 field.
	USB_HCINTMSK5_H_NAKMSK5_Msk = 0x10
	// Bit H_NAKMSK5.
	USB_HCINTMSK5_H_NAKMSK5 = 0x10
	// Position of H_ACKMSK5 field.
	USB_HCINTMSK5_H_ACKMSK5_Pos = 0x5
	// Bit mask of H_ACKMSK5 field.
	USB_HCINTMSK5_H_ACKMSK5_Msk = 0x20
	// Bit H_ACKMSK5.
	USB_HCINTMSK5_H_ACKMSK5 = 0x20
	// Position of H_NYETMSK5 field.
	USB_HCINTMSK5_H_NYETMSK5_Pos = 0x6
	// Bit mask of H_NYETMSK5 field.
	USB_HCINTMSK5_H_NYETMSK5_Msk = 0x40
	// Bit H_NYETMSK5.
	USB_HCINTMSK5_H_NYETMSK5 = 0x40
	// Position of H_XACTERRMSK5 field.
	USB_HCINTMSK5_H_XACTERRMSK5_Pos = 0x7
	// Bit mask of H_XACTERRMSK5 field.
	USB_HCINTMSK5_H_XACTERRMSK5_Msk = 0x80
	// Bit H_XACTERRMSK5.
	USB_HCINTMSK5_H_XACTERRMSK5 = 0x80
	// Position of H_BBLERRMSK5 field.
	USB_HCINTMSK5_H_BBLERRMSK5_Pos = 0x8
	// Bit mask of H_BBLERRMSK5 field.
	USB_HCINTMSK5_H_BBLERRMSK5_Msk = 0x100
	// Bit H_BBLERRMSK5.
	USB_HCINTMSK5_H_BBLERRMSK5 = 0x100
	// Position of H_FRMOVRUNMSK5 field.
	USB_HCINTMSK5_H_FRMOVRUNMSK5_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK5 field.
	USB_HCINTMSK5_H_FRMOVRUNMSK5_Msk = 0x200
	// Bit H_FRMOVRUNMSK5.
	USB_HCINTMSK5_H_FRMOVRUNMSK5 = 0x200
	// Position of H_DATATGLERRMSK5 field.
	USB_HCINTMSK5_H_DATATGLERRMSK5_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK5 field.
	USB_HCINTMSK5_H_DATATGLERRMSK5_Msk = 0x400
	// Bit H_DATATGLERRMSK5.
	USB_HCINTMSK5_H_DATATGLERRMSK5 = 0x400
	// Position of H_BNAINTRMSK5 field.
	USB_HCINTMSK5_H_BNAINTRMSK5_Pos = 0xb
	// Bit mask of H_BNAINTRMSK5 field.
	USB_HCINTMSK5_H_BNAINTRMSK5_Msk = 0x800
	// Bit H_BNAINTRMSK5.
	USB_HCINTMSK5_H_BNAINTRMSK5 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK5 field.
	USB_HCINTMSK5_H_DESC_LST_ROLLINTRMSK5_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK5 field.
	USB_HCINTMSK5_H_DESC_LST_ROLLINTRMSK5_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK5.
	USB_HCINTMSK5_H_DESC_LST_ROLLINTRMSK5 = 0x2000

	// HCTSIZ5
	// Position of H_XFERSIZE5 field.
	USB_HCTSIZ5_H_XFERSIZE5_Pos = 0x0
	// Bit mask of H_XFERSIZE5 field.
	USB_HCTSIZ5_H_XFERSIZE5_Msk = 0x7ffff
	// Position of H_PKTCNT5 field.
	USB_HCTSIZ5_H_PKTCNT5_Pos = 0x13
	// Bit mask of H_PKTCNT5 field.
	USB_HCTSIZ5_H_PKTCNT5_Msk = 0x1ff80000
	// Position of H_PID5 field.
	USB_HCTSIZ5_H_PID5_Pos = 0x1d
	// Bit mask of H_PID5 field.
	USB_HCTSIZ5_H_PID5_Msk = 0x60000000
	// Position of H_DOPNG5 field.
	USB_HCTSIZ5_H_DOPNG5_Pos = 0x1f
	// Bit mask of H_DOPNG5 field.
	USB_HCTSIZ5_H_DOPNG5_Msk = 0x80000000
	// Bit H_DOPNG5.
	USB_HCTSIZ5_H_DOPNG5 = 0x80000000

	// HCDMA5
	// Position of H_DMAADDR5 field.
	USB_HCDMA5_H_DMAADDR5_Pos = 0x0
	// Bit mask of H_DMAADDR5 field.
	USB_HCDMA5_H_DMAADDR5_Msk = 0xffffffff

	// HCDMAB5
	// Position of H_HCDMAB5 field.
	USB_HCDMAB5_H_HCDMAB5_Pos = 0x0
	// Bit mask of H_HCDMAB5 field.
	USB_HCDMAB5_H_HCDMAB5_Msk = 0xffffffff

	// HCCHAR6
	// Position of H_MPS6 field.
	USB_HCCHAR6_H_MPS6_Pos = 0x0
	// Bit mask of H_MPS6 field.
	USB_HCCHAR6_H_MPS6_Msk = 0x7ff
	// Position of H_EPNUM6 field.
	USB_HCCHAR6_H_EPNUM6_Pos = 0xb
	// Bit mask of H_EPNUM6 field.
	USB_HCCHAR6_H_EPNUM6_Msk = 0x7800
	// Position of H_EPDIR6 field.
	USB_HCCHAR6_H_EPDIR6_Pos = 0xf
	// Bit mask of H_EPDIR6 field.
	USB_HCCHAR6_H_EPDIR6_Msk = 0x8000
	// Bit H_EPDIR6.
	USB_HCCHAR6_H_EPDIR6 = 0x8000
	// Position of H_LSPDDEV6 field.
	USB_HCCHAR6_H_LSPDDEV6_Pos = 0x11
	// Bit mask of H_LSPDDEV6 field.
	USB_HCCHAR6_H_LSPDDEV6_Msk = 0x20000
	// Bit H_LSPDDEV6.
	USB_HCCHAR6_H_LSPDDEV6 = 0x20000
	// Position of H_EPTYPE6 field.
	USB_HCCHAR6_H_EPTYPE6_Pos = 0x12
	// Bit mask of H_EPTYPE6 field.
	USB_HCCHAR6_H_EPTYPE6_Msk = 0xc0000
	// Position of H_EC6 field.
	USB_HCCHAR6_H_EC6_Pos = 0x15
	// Bit mask of H_EC6 field.
	USB_HCCHAR6_H_EC6_Msk = 0x200000
	// Bit H_EC6.
	USB_HCCHAR6_H_EC6 = 0x200000
	// Position of H_DEVADDR6 field.
	USB_HCCHAR6_H_DEVADDR6_Pos = 0x16
	// Bit mask of H_DEVADDR6 field.
	USB_HCCHAR6_H_DEVADDR6_Msk = 0x1fc00000
	// Position of H_ODDFRM6 field.
	USB_HCCHAR6_H_ODDFRM6_Pos = 0x1d
	// Bit mask of H_ODDFRM6 field.
	USB_HCCHAR6_H_ODDFRM6_Msk = 0x20000000
	// Bit H_ODDFRM6.
	USB_HCCHAR6_H_ODDFRM6 = 0x20000000
	// Position of H_CHDIS6 field.
	USB_HCCHAR6_H_CHDIS6_Pos = 0x1e
	// Bit mask of H_CHDIS6 field.
	USB_HCCHAR6_H_CHDIS6_Msk = 0x40000000
	// Bit H_CHDIS6.
	USB_HCCHAR6_H_CHDIS6 = 0x40000000
	// Position of H_CHENA6 field.
	USB_HCCHAR6_H_CHENA6_Pos = 0x1f
	// Bit mask of H_CHENA6 field.
	USB_HCCHAR6_H_CHENA6_Msk = 0x80000000
	// Bit H_CHENA6.
	USB_HCCHAR6_H_CHENA6 = 0x80000000

	// HCINT6
	// Position of H_XFERCOMPL6 field.
	USB_HCINT6_H_XFERCOMPL6_Pos = 0x0
	// Bit mask of H_XFERCOMPL6 field.
	USB_HCINT6_H_XFERCOMPL6_Msk = 0x1
	// Bit H_XFERCOMPL6.
	USB_HCINT6_H_XFERCOMPL6 = 0x1
	// Position of H_CHHLTD6 field.
	USB_HCINT6_H_CHHLTD6_Pos = 0x1
	// Bit mask of H_CHHLTD6 field.
	USB_HCINT6_H_CHHLTD6_Msk = 0x2
	// Bit H_CHHLTD6.
	USB_HCINT6_H_CHHLTD6 = 0x2
	// Position of H_AHBERR6 field.
	USB_HCINT6_H_AHBERR6_Pos = 0x2
	// Bit mask of H_AHBERR6 field.
	USB_HCINT6_H_AHBERR6_Msk = 0x4
	// Bit H_AHBERR6.
	USB_HCINT6_H_AHBERR6 = 0x4
	// Position of H_STALL6 field.
	USB_HCINT6_H_STALL6_Pos = 0x3
	// Bit mask of H_STALL6 field.
	USB_HCINT6_H_STALL6_Msk = 0x8
	// Bit H_STALL6.
	USB_HCINT6_H_STALL6 = 0x8
	// Position of H_NACK6 field.
	USB_HCINT6_H_NACK6_Pos = 0x4
	// Bit mask of H_NACK6 field.
	USB_HCINT6_H_NACK6_Msk = 0x10
	// Bit H_NACK6.
	USB_HCINT6_H_NACK6 = 0x10
	// Position of H_ACK6 field.
	USB_HCINT6_H_ACK6_Pos = 0x5
	// Bit mask of H_ACK6 field.
	USB_HCINT6_H_ACK6_Msk = 0x20
	// Bit H_ACK6.
	USB_HCINT6_H_ACK6 = 0x20
	// Position of H_NYET6 field.
	USB_HCINT6_H_NYET6_Pos = 0x6
	// Bit mask of H_NYET6 field.
	USB_HCINT6_H_NYET6_Msk = 0x40
	// Bit H_NYET6.
	USB_HCINT6_H_NYET6 = 0x40
	// Position of H_XACTERR6 field.
	USB_HCINT6_H_XACTERR6_Pos = 0x7
	// Bit mask of H_XACTERR6 field.
	USB_HCINT6_H_XACTERR6_Msk = 0x80
	// Bit H_XACTERR6.
	USB_HCINT6_H_XACTERR6 = 0x80
	// Position of H_BBLERR6 field.
	USB_HCINT6_H_BBLERR6_Pos = 0x8
	// Bit mask of H_BBLERR6 field.
	USB_HCINT6_H_BBLERR6_Msk = 0x100
	// Bit H_BBLERR6.
	USB_HCINT6_H_BBLERR6 = 0x100
	// Position of H_FRMOVRUN6 field.
	USB_HCINT6_H_FRMOVRUN6_Pos = 0x9
	// Bit mask of H_FRMOVRUN6 field.
	USB_HCINT6_H_FRMOVRUN6_Msk = 0x200
	// Bit H_FRMOVRUN6.
	USB_HCINT6_H_FRMOVRUN6 = 0x200
	// Position of H_DATATGLERR6 field.
	USB_HCINT6_H_DATATGLERR6_Pos = 0xa
	// Bit mask of H_DATATGLERR6 field.
	USB_HCINT6_H_DATATGLERR6_Msk = 0x400
	// Bit H_DATATGLERR6.
	USB_HCINT6_H_DATATGLERR6 = 0x400
	// Position of H_BNAINTR6 field.
	USB_HCINT6_H_BNAINTR6_Pos = 0xb
	// Bit mask of H_BNAINTR6 field.
	USB_HCINT6_H_BNAINTR6_Msk = 0x800
	// Bit H_BNAINTR6.
	USB_HCINT6_H_BNAINTR6 = 0x800
	// Position of H_XCS_XACT_ERR6 field.
	USB_HCINT6_H_XCS_XACT_ERR6_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR6 field.
	USB_HCINT6_H_XCS_XACT_ERR6_Msk = 0x1000
	// Bit H_XCS_XACT_ERR6.
	USB_HCINT6_H_XCS_XACT_ERR6 = 0x1000
	// Position of H_DESC_LST_ROLLINTR6 field.
	USB_HCINT6_H_DESC_LST_ROLLINTR6_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR6 field.
	USB_HCINT6_H_DESC_LST_ROLLINTR6_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR6.
	USB_HCINT6_H_DESC_LST_ROLLINTR6 = 0x2000

	// HCINTMSK6
	// Position of H_XFERCOMPLMSK6 field.
	USB_HCINTMSK6_H_XFERCOMPLMSK6_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK6 field.
	USB_HCINTMSK6_H_XFERCOMPLMSK6_Msk = 0x1
	// Bit H_XFERCOMPLMSK6.
	USB_HCINTMSK6_H_XFERCOMPLMSK6 = 0x1
	// Position of H_CHHLTDMSK6 field.
	USB_HCINTMSK6_H_CHHLTDMSK6_Pos = 0x1
	// Bit mask of H_CHHLTDMSK6 field.
	USB_HCINTMSK6_H_CHHLTDMSK6_Msk = 0x2
	// Bit H_CHHLTDMSK6.
	USB_HCINTMSK6_H_CHHLTDMSK6 = 0x2
	// Position of H_AHBERRMSK6 field.
	USB_HCINTMSK6_H_AHBERRMSK6_Pos = 0x2
	// Bit mask of H_AHBERRMSK6 field.
	USB_HCINTMSK6_H_AHBERRMSK6_Msk = 0x4
	// Bit H_AHBERRMSK6.
	USB_HCINTMSK6_H_AHBERRMSK6 = 0x4
	// Position of H_STALLMSK6 field.
	USB_HCINTMSK6_H_STALLMSK6_Pos = 0x3
	// Bit mask of H_STALLMSK6 field.
	USB_HCINTMSK6_H_STALLMSK6_Msk = 0x8
	// Bit H_STALLMSK6.
	USB_HCINTMSK6_H_STALLMSK6 = 0x8
	// Position of H_NAKMSK6 field.
	USB_HCINTMSK6_H_NAKMSK6_Pos = 0x4
	// Bit mask of H_NAKMSK6 field.
	USB_HCINTMSK6_H_NAKMSK6_Msk = 0x10
	// Bit H_NAKMSK6.
	USB_HCINTMSK6_H_NAKMSK6 = 0x10
	// Position of H_ACKMSK6 field.
	USB_HCINTMSK6_H_ACKMSK6_Pos = 0x5
	// Bit mask of H_ACKMSK6 field.
	USB_HCINTMSK6_H_ACKMSK6_Msk = 0x20
	// Bit H_ACKMSK6.
	USB_HCINTMSK6_H_ACKMSK6 = 0x20
	// Position of H_NYETMSK6 field.
	USB_HCINTMSK6_H_NYETMSK6_Pos = 0x6
	// Bit mask of H_NYETMSK6 field.
	USB_HCINTMSK6_H_NYETMSK6_Msk = 0x40
	// Bit H_NYETMSK6.
	USB_HCINTMSK6_H_NYETMSK6 = 0x40
	// Position of H_XACTERRMSK6 field.
	USB_HCINTMSK6_H_XACTERRMSK6_Pos = 0x7
	// Bit mask of H_XACTERRMSK6 field.
	USB_HCINTMSK6_H_XACTERRMSK6_Msk = 0x80
	// Bit H_XACTERRMSK6.
	USB_HCINTMSK6_H_XACTERRMSK6 = 0x80
	// Position of H_BBLERRMSK6 field.
	USB_HCINTMSK6_H_BBLERRMSK6_Pos = 0x8
	// Bit mask of H_BBLERRMSK6 field.
	USB_HCINTMSK6_H_BBLERRMSK6_Msk = 0x100
	// Bit H_BBLERRMSK6.
	USB_HCINTMSK6_H_BBLERRMSK6 = 0x100
	// Position of H_FRMOVRUNMSK6 field.
	USB_HCINTMSK6_H_FRMOVRUNMSK6_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK6 field.
	USB_HCINTMSK6_H_FRMOVRUNMSK6_Msk = 0x200
	// Bit H_FRMOVRUNMSK6.
	USB_HCINTMSK6_H_FRMOVRUNMSK6 = 0x200
	// Position of H_DATATGLERRMSK6 field.
	USB_HCINTMSK6_H_DATATGLERRMSK6_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK6 field.
	USB_HCINTMSK6_H_DATATGLERRMSK6_Msk = 0x400
	// Bit H_DATATGLERRMSK6.
	USB_HCINTMSK6_H_DATATGLERRMSK6 = 0x400
	// Position of H_BNAINTRMSK6 field.
	USB_HCINTMSK6_H_BNAINTRMSK6_Pos = 0xb
	// Bit mask of H_BNAINTRMSK6 field.
	USB_HCINTMSK6_H_BNAINTRMSK6_Msk = 0x800
	// Bit H_BNAINTRMSK6.
	USB_HCINTMSK6_H_BNAINTRMSK6 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK6 field.
	USB_HCINTMSK6_H_DESC_LST_ROLLINTRMSK6_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK6 field.
	USB_HCINTMSK6_H_DESC_LST_ROLLINTRMSK6_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK6.
	USB_HCINTMSK6_H_DESC_LST_ROLLINTRMSK6 = 0x2000

	// HCTSIZ6
	// Position of H_XFERSIZE6 field.
	USB_HCTSIZ6_H_XFERSIZE6_Pos = 0x0
	// Bit mask of H_XFERSIZE6 field.
	USB_HCTSIZ6_H_XFERSIZE6_Msk = 0x7ffff
	// Position of H_PKTCNT6 field.
	USB_HCTSIZ6_H_PKTCNT6_Pos = 0x13
	// Bit mask of H_PKTCNT6 field.
	USB_HCTSIZ6_H_PKTCNT6_Msk = 0x1ff80000
	// Position of H_PID6 field.
	USB_HCTSIZ6_H_PID6_Pos = 0x1d
	// Bit mask of H_PID6 field.
	USB_HCTSIZ6_H_PID6_Msk = 0x60000000
	// Position of H_DOPNG6 field.
	USB_HCTSIZ6_H_DOPNG6_Pos = 0x1f
	// Bit mask of H_DOPNG6 field.
	USB_HCTSIZ6_H_DOPNG6_Msk = 0x80000000
	// Bit H_DOPNG6.
	USB_HCTSIZ6_H_DOPNG6 = 0x80000000

	// HCDMA6
	// Position of H_DMAADDR6 field.
	USB_HCDMA6_H_DMAADDR6_Pos = 0x0
	// Bit mask of H_DMAADDR6 field.
	USB_HCDMA6_H_DMAADDR6_Msk = 0xffffffff

	// HCDMAB6
	// Position of H_HCDMAB6 field.
	USB_HCDMAB6_H_HCDMAB6_Pos = 0x0
	// Bit mask of H_HCDMAB6 field.
	USB_HCDMAB6_H_HCDMAB6_Msk = 0xffffffff

	// HCCHAR7
	// Position of H_MPS7 field.
	USB_HCCHAR7_H_MPS7_Pos = 0x0
	// Bit mask of H_MPS7 field.
	USB_HCCHAR7_H_MPS7_Msk = 0x7ff
	// Position of H_EPNUM7 field.
	USB_HCCHAR7_H_EPNUM7_Pos = 0xb
	// Bit mask of H_EPNUM7 field.
	USB_HCCHAR7_H_EPNUM7_Msk = 0x7800
	// Position of H_EPDIR7 field.
	USB_HCCHAR7_H_EPDIR7_Pos = 0xf
	// Bit mask of H_EPDIR7 field.
	USB_HCCHAR7_H_EPDIR7_Msk = 0x8000
	// Bit H_EPDIR7.
	USB_HCCHAR7_H_EPDIR7 = 0x8000
	// Position of H_LSPDDEV7 field.
	USB_HCCHAR7_H_LSPDDEV7_Pos = 0x11
	// Bit mask of H_LSPDDEV7 field.
	USB_HCCHAR7_H_LSPDDEV7_Msk = 0x20000
	// Bit H_LSPDDEV7.
	USB_HCCHAR7_H_LSPDDEV7 = 0x20000
	// Position of H_EPTYPE7 field.
	USB_HCCHAR7_H_EPTYPE7_Pos = 0x12
	// Bit mask of H_EPTYPE7 field.
	USB_HCCHAR7_H_EPTYPE7_Msk = 0xc0000
	// Position of H_EC7 field.
	USB_HCCHAR7_H_EC7_Pos = 0x15
	// Bit mask of H_EC7 field.
	USB_HCCHAR7_H_EC7_Msk = 0x200000
	// Bit H_EC7.
	USB_HCCHAR7_H_EC7 = 0x200000
	// Position of H_DEVADDR7 field.
	USB_HCCHAR7_H_DEVADDR7_Pos = 0x16
	// Bit mask of H_DEVADDR7 field.
	USB_HCCHAR7_H_DEVADDR7_Msk = 0x1fc00000
	// Position of H_ODDFRM7 field.
	USB_HCCHAR7_H_ODDFRM7_Pos = 0x1d
	// Bit mask of H_ODDFRM7 field.
	USB_HCCHAR7_H_ODDFRM7_Msk = 0x20000000
	// Bit H_ODDFRM7.
	USB_HCCHAR7_H_ODDFRM7 = 0x20000000
	// Position of H_CHDIS7 field.
	USB_HCCHAR7_H_CHDIS7_Pos = 0x1e
	// Bit mask of H_CHDIS7 field.
	USB_HCCHAR7_H_CHDIS7_Msk = 0x40000000
	// Bit H_CHDIS7.
	USB_HCCHAR7_H_CHDIS7 = 0x40000000
	// Position of H_CHENA7 field.
	USB_HCCHAR7_H_CHENA7_Pos = 0x1f
	// Bit mask of H_CHENA7 field.
	USB_HCCHAR7_H_CHENA7_Msk = 0x80000000
	// Bit H_CHENA7.
	USB_HCCHAR7_H_CHENA7 = 0x80000000

	// HCINT7
	// Position of H_XFERCOMPL7 field.
	USB_HCINT7_H_XFERCOMPL7_Pos = 0x0
	// Bit mask of H_XFERCOMPL7 field.
	USB_HCINT7_H_XFERCOMPL7_Msk = 0x1
	// Bit H_XFERCOMPL7.
	USB_HCINT7_H_XFERCOMPL7 = 0x1
	// Position of H_CHHLTD7 field.
	USB_HCINT7_H_CHHLTD7_Pos = 0x1
	// Bit mask of H_CHHLTD7 field.
	USB_HCINT7_H_CHHLTD7_Msk = 0x2
	// Bit H_CHHLTD7.
	USB_HCINT7_H_CHHLTD7 = 0x2
	// Position of H_AHBERR7 field.
	USB_HCINT7_H_AHBERR7_Pos = 0x2
	// Bit mask of H_AHBERR7 field.
	USB_HCINT7_H_AHBERR7_Msk = 0x4
	// Bit H_AHBERR7.
	USB_HCINT7_H_AHBERR7 = 0x4
	// Position of H_STALL7 field.
	USB_HCINT7_H_STALL7_Pos = 0x3
	// Bit mask of H_STALL7 field.
	USB_HCINT7_H_STALL7_Msk = 0x8
	// Bit H_STALL7.
	USB_HCINT7_H_STALL7 = 0x8
	// Position of H_NACK7 field.
	USB_HCINT7_H_NACK7_Pos = 0x4
	// Bit mask of H_NACK7 field.
	USB_HCINT7_H_NACK7_Msk = 0x10
	// Bit H_NACK7.
	USB_HCINT7_H_NACK7 = 0x10
	// Position of H_ACK7 field.
	USB_HCINT7_H_ACK7_Pos = 0x5
	// Bit mask of H_ACK7 field.
	USB_HCINT7_H_ACK7_Msk = 0x20
	// Bit H_ACK7.
	USB_HCINT7_H_ACK7 = 0x20
	// Position of H_NYET7 field.
	USB_HCINT7_H_NYET7_Pos = 0x6
	// Bit mask of H_NYET7 field.
	USB_HCINT7_H_NYET7_Msk = 0x40
	// Bit H_NYET7.
	USB_HCINT7_H_NYET7 = 0x40
	// Position of H_XACTERR7 field.
	USB_HCINT7_H_XACTERR7_Pos = 0x7
	// Bit mask of H_XACTERR7 field.
	USB_HCINT7_H_XACTERR7_Msk = 0x80
	// Bit H_XACTERR7.
	USB_HCINT7_H_XACTERR7 = 0x80
	// Position of H_BBLERR7 field.
	USB_HCINT7_H_BBLERR7_Pos = 0x8
	// Bit mask of H_BBLERR7 field.
	USB_HCINT7_H_BBLERR7_Msk = 0x100
	// Bit H_BBLERR7.
	USB_HCINT7_H_BBLERR7 = 0x100
	// Position of H_FRMOVRUN7 field.
	USB_HCINT7_H_FRMOVRUN7_Pos = 0x9
	// Bit mask of H_FRMOVRUN7 field.
	USB_HCINT7_H_FRMOVRUN7_Msk = 0x200
	// Bit H_FRMOVRUN7.
	USB_HCINT7_H_FRMOVRUN7 = 0x200
	// Position of H_DATATGLERR7 field.
	USB_HCINT7_H_DATATGLERR7_Pos = 0xa
	// Bit mask of H_DATATGLERR7 field.
	USB_HCINT7_H_DATATGLERR7_Msk = 0x400
	// Bit H_DATATGLERR7.
	USB_HCINT7_H_DATATGLERR7 = 0x400
	// Position of H_BNAINTR7 field.
	USB_HCINT7_H_BNAINTR7_Pos = 0xb
	// Bit mask of H_BNAINTR7 field.
	USB_HCINT7_H_BNAINTR7_Msk = 0x800
	// Bit H_BNAINTR7.
	USB_HCINT7_H_BNAINTR7 = 0x800
	// Position of H_XCS_XACT_ERR7 field.
	USB_HCINT7_H_XCS_XACT_ERR7_Pos = 0xc
	// Bit mask of H_XCS_XACT_ERR7 field.
	USB_HCINT7_H_XCS_XACT_ERR7_Msk = 0x1000
	// Bit H_XCS_XACT_ERR7.
	USB_HCINT7_H_XCS_XACT_ERR7 = 0x1000
	// Position of H_DESC_LST_ROLLINTR7 field.
	USB_HCINT7_H_DESC_LST_ROLLINTR7_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTR7 field.
	USB_HCINT7_H_DESC_LST_ROLLINTR7_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTR7.
	USB_HCINT7_H_DESC_LST_ROLLINTR7 = 0x2000

	// HCINTMSK7
	// Position of H_XFERCOMPLMSK7 field.
	USB_HCINTMSK7_H_XFERCOMPLMSK7_Pos = 0x0
	// Bit mask of H_XFERCOMPLMSK7 field.
	USB_HCINTMSK7_H_XFERCOMPLMSK7_Msk = 0x1
	// Bit H_XFERCOMPLMSK7.
	USB_HCINTMSK7_H_XFERCOMPLMSK7 = 0x1
	// Position of H_CHHLTDMSK7 field.
	USB_HCINTMSK7_H_CHHLTDMSK7_Pos = 0x1
	// Bit mask of H_CHHLTDMSK7 field.
	USB_HCINTMSK7_H_CHHLTDMSK7_Msk = 0x2
	// Bit H_CHHLTDMSK7.
	USB_HCINTMSK7_H_CHHLTDMSK7 = 0x2
	// Position of H_AHBERRMSK7 field.
	USB_HCINTMSK7_H_AHBERRMSK7_Pos = 0x2
	// Bit mask of H_AHBERRMSK7 field.
	USB_HCINTMSK7_H_AHBERRMSK7_Msk = 0x4
	// Bit H_AHBERRMSK7.
	USB_HCINTMSK7_H_AHBERRMSK7 = 0x4
	// Position of H_STALLMSK7 field.
	USB_HCINTMSK7_H_STALLMSK7_Pos = 0x3
	// Bit mask of H_STALLMSK7 field.
	USB_HCINTMSK7_H_STALLMSK7_Msk = 0x8
	// Bit H_STALLMSK7.
	USB_HCINTMSK7_H_STALLMSK7 = 0x8
	// Position of H_NAKMSK7 field.
	USB_HCINTMSK7_H_NAKMSK7_Pos = 0x4
	// Bit mask of H_NAKMSK7 field.
	USB_HCINTMSK7_H_NAKMSK7_Msk = 0x10
	// Bit H_NAKMSK7.
	USB_HCINTMSK7_H_NAKMSK7 = 0x10
	// Position of H_ACKMSK7 field.
	USB_HCINTMSK7_H_ACKMSK7_Pos = 0x5
	// Bit mask of H_ACKMSK7 field.
	USB_HCINTMSK7_H_ACKMSK7_Msk = 0x20
	// Bit H_ACKMSK7.
	USB_HCINTMSK7_H_ACKMSK7 = 0x20
	// Position of H_NYETMSK7 field.
	USB_HCINTMSK7_H_NYETMSK7_Pos = 0x6
	// Bit mask of H_NYETMSK7 field.
	USB_HCINTMSK7_H_NYETMSK7_Msk = 0x40
	// Bit H_NYETMSK7.
	USB_HCINTMSK7_H_NYETMSK7 = 0x40
	// Position of H_XACTERRMSK7 field.
	USB_HCINTMSK7_H_XACTERRMSK7_Pos = 0x7
	// Bit mask of H_XACTERRMSK7 field.
	USB_HCINTMSK7_H_XACTERRMSK7_Msk = 0x80
	// Bit H_XACTERRMSK7.
	USB_HCINTMSK7_H_XACTERRMSK7 = 0x80
	// Position of H_BBLERRMSK7 field.
	USB_HCINTMSK7_H_BBLERRMSK7_Pos = 0x8
	// Bit mask of H_BBLERRMSK7 field.
	USB_HCINTMSK7_H_BBLERRMSK7_Msk = 0x100
	// Bit H_BBLERRMSK7.
	USB_HCINTMSK7_H_BBLERRMSK7 = 0x100
	// Position of H_FRMOVRUNMSK7 field.
	USB_HCINTMSK7_H_FRMOVRUNMSK7_Pos = 0x9
	// Bit mask of H_FRMOVRUNMSK7 field.
	USB_HCINTMSK7_H_FRMOVRUNMSK7_Msk = 0x200
	// Bit H_FRMOVRUNMSK7.
	USB_HCINTMSK7_H_FRMOVRUNMSK7 = 0x200
	// Position of H_DATATGLERRMSK7 field.
	USB_HCINTMSK7_H_DATATGLERRMSK7_Pos = 0xa
	// Bit mask of H_DATATGLERRMSK7 field.
	USB_HCINTMSK7_H_DATATGLERRMSK7_Msk = 0x400
	// Bit H_DATATGLERRMSK7.
	USB_HCINTMSK7_H_DATATGLERRMSK7 = 0x400
	// Position of H_BNAINTRMSK7 field.
	USB_HCINTMSK7_H_BNAINTRMSK7_Pos = 0xb
	// Bit mask of H_BNAINTRMSK7 field.
	USB_HCINTMSK7_H_BNAINTRMSK7_Msk = 0x800
	// Bit H_BNAINTRMSK7.
	USB_HCINTMSK7_H_BNAINTRMSK7 = 0x800
	// Position of H_DESC_LST_ROLLINTRMSK7 field.
	USB_HCINTMSK7_H_DESC_LST_ROLLINTRMSK7_Pos = 0xd
	// Bit mask of H_DESC_LST_ROLLINTRMSK7 field.
	USB_HCINTMSK7_H_DESC_LST_ROLLINTRMSK7_Msk = 0x2000
	// Bit H_DESC_LST_ROLLINTRMSK7.
	USB_HCINTMSK7_H_DESC_LST_ROLLINTRMSK7 = 0x2000

	// HCTSIZ7
	// Position of H_XFERSIZE7 field.
	USB_HCTSIZ7_H_XFERSIZE7_Pos = 0x0
	// Bit mask of H_XFERSIZE7 field.
	USB_HCTSIZ7_H_XFERSIZE7_Msk = 0x7ffff
	// Position of H_PKTCNT7 field.
	USB_HCTSIZ7_H_PKTCNT7_Pos = 0x13
	// Bit mask of H_PKTCNT7 field.
	USB_HCTSIZ7_H_PKTCNT7_Msk = 0x1ff80000
	// Position of H_PID7 field.
	USB_HCTSIZ7_H_PID7_Pos = 0x1d
	// Bit mask of H_PID7 field.
	USB_HCTSIZ7_H_PID7_Msk = 0x60000000
	// Position of H_DOPNG7 field.
	USB_HCTSIZ7_H_DOPNG7_Pos = 0x1f
	// Bit mask of H_DOPNG7 field.
	USB_HCTSIZ7_H_DOPNG7_Msk = 0x80000000
	// Bit H_DOPNG7.
	USB_HCTSIZ7_H_DOPNG7 = 0x80000000

	// HCDMA7
	// Position of H_DMAADDR7 field.
	USB_HCDMA7_H_DMAADDR7_Pos = 0x0
	// Bit mask of H_DMAADDR7 field.
	USB_HCDMA7_H_DMAADDR7_Msk = 0xffffffff

	// HCDMAB7
	// Position of H_HCDMAB7 field.
	USB_HCDMAB7_H_HCDMAB7_Pos = 0x0
	// Bit mask of H_HCDMAB7 field.
	USB_HCDMAB7_H_HCDMAB7_Msk = 0xffffffff

	// DCFG
	// Position of NZSTSOUTHSHK field.
	USB_DCFG_NZSTSOUTHSHK_Pos = 0x2
	// Bit mask of NZSTSOUTHSHK field.
	USB_DCFG_NZSTSOUTHSHK_Msk = 0x4
	// Bit NZSTSOUTHSHK.
	USB_DCFG_NZSTSOUTHSHK = 0x4
	// Position of ENA32KHZSUSP field.
	USB_DCFG_ENA32KHZSUSP_Pos = 0x3
	// Bit mask of ENA32KHZSUSP field.
	USB_DCFG_ENA32KHZSUSP_Msk = 0x8
	// Bit ENA32KHZSUSP.
	USB_DCFG_ENA32KHZSUSP = 0x8
	// Position of DEVADDR field.
	USB_DCFG_DEVADDR_Pos = 0x4
	// Bit mask of DEVADDR field.
	USB_DCFG_DEVADDR_Msk = 0x7f0
	// Position of PERFRLINT field.
	USB_DCFG_PERFRLINT_Pos = 0xb
	// Bit mask of PERFRLINT field.
	USB_DCFG_PERFRLINT_Msk = 0x1800
	// Position of ENDEVOUTNAK field.
	USB_DCFG_ENDEVOUTNAK_Pos = 0xd
	// Bit mask of ENDEVOUTNAK field.
	USB_DCFG_ENDEVOUTNAK_Msk = 0x2000
	// Bit ENDEVOUTNAK.
	USB_DCFG_ENDEVOUTNAK = 0x2000
	// Position of XCVRDLY field.
	USB_DCFG_XCVRDLY_Pos = 0xe
	// Bit mask of XCVRDLY field.
	USB_DCFG_XCVRDLY_Msk = 0x4000
	// Bit XCVRDLY.
	USB_DCFG_XCVRDLY = 0x4000
	// Position of ERRATICINTMSK field.
	USB_DCFG_ERRATICINTMSK_Pos = 0xf
	// Bit mask of ERRATICINTMSK field.
	USB_DCFG_ERRATICINTMSK_Msk = 0x8000
	// Bit ERRATICINTMSK.
	USB_DCFG_ERRATICINTMSK = 0x8000
	// Position of EPMISCNT field.
	USB_DCFG_EPMISCNT_Pos = 0x12
	// Bit mask of EPMISCNT field.
	USB_DCFG_EPMISCNT_Msk = 0x7c0000
	// Position of DESCDMA field.
	USB_DCFG_DESCDMA_Pos = 0x17
	// Bit mask of DESCDMA field.
	USB_DCFG_DESCDMA_Msk = 0x800000
	// Bit DESCDMA.
	USB_DCFG_DESCDMA = 0x800000
	// Position of PERSCHINTVL field.
	USB_DCFG_PERSCHINTVL_Pos = 0x18
	// Bit mask of PERSCHINTVL field.
	USB_DCFG_PERSCHINTVL_Msk = 0x3000000
	// Position of RESVALID field.
	USB_DCFG_RESVALID_Pos = 0x1a
	// Bit mask of RESVALID field.
	USB_DCFG_RESVALID_Msk = 0xfc000000

	// DCTL
	// Position of RMTWKUPSIG field.
	USB_DCTL_RMTWKUPSIG_Pos = 0x0
	// Bit mask of RMTWKUPSIG field.
	USB_DCTL_RMTWKUPSIG_Msk = 0x1
	// Bit RMTWKUPSIG.
	USB_DCTL_RMTWKUPSIG = 0x1
	// Position of SFTDISCON field.
	USB_DCTL_SFTDISCON_Pos = 0x1
	// Bit mask of SFTDISCON field.
	USB_DCTL_SFTDISCON_Msk = 0x2
	// Bit SFTDISCON.
	USB_DCTL_SFTDISCON = 0x2
	// Position of GNPINNAKSTS field.
	USB_DCTL_GNPINNAKSTS_Pos = 0x2
	// Bit mask of GNPINNAKSTS field.
	USB_DCTL_GNPINNAKSTS_Msk = 0x4
	// Bit GNPINNAKSTS.
	USB_DCTL_GNPINNAKSTS = 0x4
	// Position of GOUTNAKSTS field.
	USB_DCTL_GOUTNAKSTS_Pos = 0x3
	// Bit mask of GOUTNAKSTS field.
	USB_DCTL_GOUTNAKSTS_Msk = 0x8
	// Bit GOUTNAKSTS.
	USB_DCTL_GOUTNAKSTS = 0x8
	// Position of TSTCTL field.
	USB_DCTL_TSTCTL_Pos = 0x4
	// Bit mask of TSTCTL field.
	USB_DCTL_TSTCTL_Msk = 0x70
	// Position of SGNPINNAK field.
	USB_DCTL_SGNPINNAK_Pos = 0x7
	// Bit mask of SGNPINNAK field.
	USB_DCTL_SGNPINNAK_Msk = 0x80
	// Bit SGNPINNAK.
	USB_DCTL_SGNPINNAK = 0x80
	// Position of CGNPINNAK field.
	USB_DCTL_CGNPINNAK_Pos = 0x8
	// Bit mask of CGNPINNAK field.
	USB_DCTL_CGNPINNAK_Msk = 0x100
	// Bit CGNPINNAK.
	USB_DCTL_CGNPINNAK = 0x100
	// Position of SGOUTNAK field.
	USB_DCTL_SGOUTNAK_Pos = 0x9
	// Bit mask of SGOUTNAK field.
	USB_DCTL_SGOUTNAK_Msk = 0x200
	// Bit SGOUTNAK.
	USB_DCTL_SGOUTNAK = 0x200
	// Position of CGOUTNAK field.
	USB_DCTL_CGOUTNAK_Pos = 0xa
	// Bit mask of CGOUTNAK field.
	USB_DCTL_CGOUTNAK_Msk = 0x400
	// Bit CGOUTNAK.
	USB_DCTL_CGOUTNAK = 0x400
	// Position of PWRONPRGDONE field.
	USB_DCTL_PWRONPRGDONE_Pos = 0xb
	// Bit mask of PWRONPRGDONE field.
	USB_DCTL_PWRONPRGDONE_Msk = 0x800
	// Bit PWRONPRGDONE.
	USB_DCTL_PWRONPRGDONE = 0x800
	// Position of GMC field.
	USB_DCTL_GMC_Pos = 0xd
	// Bit mask of GMC field.
	USB_DCTL_GMC_Msk = 0x6000
	// Position of IGNRFRMNUM field.
	USB_DCTL_IGNRFRMNUM_Pos = 0xf
	// Bit mask of IGNRFRMNUM field.
	USB_DCTL_IGNRFRMNUM_Msk = 0x8000
	// Bit IGNRFRMNUM.
	USB_DCTL_IGNRFRMNUM = 0x8000
	// Position of NAKONBBLE field.
	USB_DCTL_NAKONBBLE_Pos = 0x10
	// Bit mask of NAKONBBLE field.
	USB_DCTL_NAKONBBLE_Msk = 0x10000
	// Bit NAKONBBLE.
	USB_DCTL_NAKONBBLE = 0x10000
	// Position of ENCOUNTONBNA field.
	USB_DCTL_ENCOUNTONBNA_Pos = 0x11
	// Bit mask of ENCOUNTONBNA field.
	USB_DCTL_ENCOUNTONBNA_Msk = 0x20000
	// Bit ENCOUNTONBNA.
	USB_DCTL_ENCOUNTONBNA = 0x20000
	// Position of DEEPSLEEPBESLREJECT field.
	USB_DCTL_DEEPSLEEPBESLREJECT_Pos = 0x12
	// Bit mask of DEEPSLEEPBESLREJECT field.
	USB_DCTL_DEEPSLEEPBESLREJECT_Msk = 0x40000
	// Bit DEEPSLEEPBESLREJECT.
	USB_DCTL_DEEPSLEEPBESLREJECT = 0x40000

	// DSTS
	// Position of SUSPSTS field.
	USB_DSTS_SUSPSTS_Pos = 0x0
	// Bit mask of SUSPSTS field.
	USB_DSTS_SUSPSTS_Msk = 0x1
	// Bit SUSPSTS.
	USB_DSTS_SUSPSTS = 0x1
	// Position of ENUMSPD field.
	USB_DSTS_ENUMSPD_Pos = 0x1
	// Bit mask of ENUMSPD field.
	USB_DSTS_ENUMSPD_Msk = 0x6
	// Position of ERRTICERR field.
	USB_DSTS_ERRTICERR_Pos = 0x3
	// Bit mask of ERRTICERR field.
	USB_DSTS_ERRTICERR_Msk = 0x8
	// Bit ERRTICERR.
	USB_DSTS_ERRTICERR = 0x8
	// Position of SOFFN field.
	USB_DSTS_SOFFN_Pos = 0x8
	// Bit mask of SOFFN field.
	USB_DSTS_SOFFN_Msk = 0x3fff00
	// Position of DEVLNSTS field.
	USB_DSTS_DEVLNSTS_Pos = 0x16
	// Bit mask of DEVLNSTS field.
	USB_DSTS_DEVLNSTS_Msk = 0xc00000

	// DIEPMSK
	// Position of DI_XFERCOMPLMSK field.
	USB_DIEPMSK_DI_XFERCOMPLMSK_Pos = 0x0
	// Bit mask of DI_XFERCOMPLMSK field.
	USB_DIEPMSK_DI_XFERCOMPLMSK_Msk = 0x1
	// Bit DI_XFERCOMPLMSK.
	USB_DIEPMSK_DI_XFERCOMPLMSK = 0x1
	// Position of DI_EPDISBLDMSK field.
	USB_DIEPMSK_DI_EPDISBLDMSK_Pos = 0x1
	// Bit mask of DI_EPDISBLDMSK field.
	USB_DIEPMSK_DI_EPDISBLDMSK_Msk = 0x2
	// Bit DI_EPDISBLDMSK.
	USB_DIEPMSK_DI_EPDISBLDMSK = 0x2
	// Position of DI_AHBERMSK field.
	USB_DIEPMSK_DI_AHBERMSK_Pos = 0x2
	// Bit mask of DI_AHBERMSK field.
	USB_DIEPMSK_DI_AHBERMSK_Msk = 0x4
	// Bit DI_AHBERMSK.
	USB_DIEPMSK_DI_AHBERMSK = 0x4
	// Position of TIMEOUTMSK field.
	USB_DIEPMSK_TIMEOUTMSK_Pos = 0x3
	// Bit mask of TIMEOUTMSK field.
	USB_DIEPMSK_TIMEOUTMSK_Msk = 0x8
	// Bit TIMEOUTMSK.
	USB_DIEPMSK_TIMEOUTMSK = 0x8
	// Position of INTKNTXFEMPMSK field.
	USB_DIEPMSK_INTKNTXFEMPMSK_Pos = 0x4
	// Bit mask of INTKNTXFEMPMSK field.
	USB_DIEPMSK_INTKNTXFEMPMSK_Msk = 0x10
	// Bit INTKNTXFEMPMSK.
	USB_DIEPMSK_INTKNTXFEMPMSK = 0x10
	// Position of INTKNEPMISMSK field.
	USB_DIEPMSK_INTKNEPMISMSK_Pos = 0x5
	// Bit mask of INTKNEPMISMSK field.
	USB_DIEPMSK_INTKNEPMISMSK_Msk = 0x20
	// Bit INTKNEPMISMSK.
	USB_DIEPMSK_INTKNEPMISMSK = 0x20
	// Position of INEPNAKEFFMSK field.
	USB_DIEPMSK_INEPNAKEFFMSK_Pos = 0x6
	// Bit mask of INEPNAKEFFMSK field.
	USB_DIEPMSK_INEPNAKEFFMSK_Msk = 0x40
	// Bit INEPNAKEFFMSK.
	USB_DIEPMSK_INEPNAKEFFMSK = 0x40
	// Position of TXFIFOUNDRNMSK field.
	USB_DIEPMSK_TXFIFOUNDRNMSK_Pos = 0x8
	// Bit mask of TXFIFOUNDRNMSK field.
	USB_DIEPMSK_TXFIFOUNDRNMSK_Msk = 0x100
	// Bit TXFIFOUNDRNMSK.
	USB_DIEPMSK_TXFIFOUNDRNMSK = 0x100
	// Position of BNAININTRMSK field.
	USB_DIEPMSK_BNAININTRMSK_Pos = 0x9
	// Bit mask of BNAININTRMSK field.
	USB_DIEPMSK_BNAININTRMSK_Msk = 0x200
	// Bit BNAININTRMSK.
	USB_DIEPMSK_BNAININTRMSK = 0x200
	// Position of DI_NAKMSK field.
	USB_DIEPMSK_DI_NAKMSK_Pos = 0xd
	// Bit mask of DI_NAKMSK field.
	USB_DIEPMSK_DI_NAKMSK_Msk = 0x2000
	// Bit DI_NAKMSK.
	USB_DIEPMSK_DI_NAKMSK = 0x2000

	// DOEPMSK
	// Position of XFERCOMPLMSK field.
	USB_DOEPMSK_XFERCOMPLMSK_Pos = 0x0
	// Bit mask of XFERCOMPLMSK field.
	USB_DOEPMSK_XFERCOMPLMSK_Msk = 0x1
	// Bit XFERCOMPLMSK.
	USB_DOEPMSK_XFERCOMPLMSK = 0x1
	// Position of EPDISBLDMSK field.
	USB_DOEPMSK_EPDISBLDMSK_Pos = 0x1
	// Bit mask of EPDISBLDMSK field.
	USB_DOEPMSK_EPDISBLDMSK_Msk = 0x2
	// Bit EPDISBLDMSK.
	USB_DOEPMSK_EPDISBLDMSK = 0x2
	// Position of AHBERMSK field.
	USB_DOEPMSK_AHBERMSK_Pos = 0x2
	// Bit mask of AHBERMSK field.
	USB_DOEPMSK_AHBERMSK_Msk = 0x4
	// Bit AHBERMSK.
	USB_DOEPMSK_AHBERMSK = 0x4
	// Position of SETUPMSK field.
	USB_DOEPMSK_SETUPMSK_Pos = 0x3
	// Bit mask of SETUPMSK field.
	USB_DOEPMSK_SETUPMSK_Msk = 0x8
	// Bit SETUPMSK.
	USB_DOEPMSK_SETUPMSK = 0x8
	// Position of OUTTKNEPDISMSK field.
	USB_DOEPMSK_OUTTKNEPDISMSK_Pos = 0x4
	// Bit mask of OUTTKNEPDISMSK field.
	USB_DOEPMSK_OUTTKNEPDISMSK_Msk = 0x10
	// Bit OUTTKNEPDISMSK.
	USB_DOEPMSK_OUTTKNEPDISMSK = 0x10
	// Position of STSPHSERCVDMSK field.
	USB_DOEPMSK_STSPHSERCVDMSK_Pos = 0x5
	// Bit mask of STSPHSERCVDMSK field.
	USB_DOEPMSK_STSPHSERCVDMSK_Msk = 0x20
	// Bit STSPHSERCVDMSK.
	USB_DOEPMSK_STSPHSERCVDMSK = 0x20
	// Position of BACK2BACKSETUP field.
	USB_DOEPMSK_BACK2BACKSETUP_Pos = 0x6
	// Bit mask of BACK2BACKSETUP field.
	USB_DOEPMSK_BACK2BACKSETUP_Msk = 0x40
	// Bit BACK2BACKSETUP.
	USB_DOEPMSK_BACK2BACKSETUP = 0x40
	// Position of OUTPKTERRMSK field.
	USB_DOEPMSK_OUTPKTERRMSK_Pos = 0x8
	// Bit mask of OUTPKTERRMSK field.
	USB_DOEPMSK_OUTPKTERRMSK_Msk = 0x100
	// Bit OUTPKTERRMSK.
	USB_DOEPMSK_OUTPKTERRMSK = 0x100
	// Position of BNAOUTINTRMSK field.
	USB_DOEPMSK_BNAOUTINTRMSK_Pos = 0x9
	// Bit mask of BNAOUTINTRMSK field.
	USB_DOEPMSK_BNAOUTINTRMSK_Msk = 0x200
	// Bit BNAOUTINTRMSK.
	USB_DOEPMSK_BNAOUTINTRMSK = 0x200
	// Position of BBLEERRMSK field.
	USB_DOEPMSK_BBLEERRMSK_Pos = 0xc
	// Bit mask of BBLEERRMSK field.
	USB_DOEPMSK_BBLEERRMSK_Msk = 0x1000
	// Bit BBLEERRMSK.
	USB_DOEPMSK_BBLEERRMSK = 0x1000
	// Position of NAKMSK field.
	USB_DOEPMSK_NAKMSK_Pos = 0xd
	// Bit mask of NAKMSK field.
	USB_DOEPMSK_NAKMSK_Msk = 0x2000
	// Bit NAKMSK.
	USB_DOEPMSK_NAKMSK = 0x2000
	// Position of NYETMSK field.
	USB_DOEPMSK_NYETMSK_Pos = 0xe
	// Bit mask of NYETMSK field.
	USB_DOEPMSK_NYETMSK_Msk = 0x4000
	// Bit NYETMSK.
	USB_DOEPMSK_NYETMSK = 0x4000

	// DAINT
	// Position of INEPINT0 field.
	USB_DAINT_INEPINT0_Pos = 0x0
	// Bit mask of INEPINT0 field.
	USB_DAINT_INEPINT0_Msk = 0x1
	// Bit INEPINT0.
	USB_DAINT_INEPINT0 = 0x1
	// Position of INEPINT1 field.
	USB_DAINT_INEPINT1_Pos = 0x1
	// Bit mask of INEPINT1 field.
	USB_DAINT_INEPINT1_Msk = 0x2
	// Bit INEPINT1.
	USB_DAINT_INEPINT1 = 0x2
	// Position of INEPINT2 field.
	USB_DAINT_INEPINT2_Pos = 0x2
	// Bit mask of INEPINT2 field.
	USB_DAINT_INEPINT2_Msk = 0x4
	// Bit INEPINT2.
	USB_DAINT_INEPINT2 = 0x4
	// Position of INEPINT3 field.
	USB_DAINT_INEPINT3_Pos = 0x3
	// Bit mask of INEPINT3 field.
	USB_DAINT_INEPINT3_Msk = 0x8
	// Bit INEPINT3.
	USB_DAINT_INEPINT3 = 0x8
	// Position of INEPINT4 field.
	USB_DAINT_INEPINT4_Pos = 0x4
	// Bit mask of INEPINT4 field.
	USB_DAINT_INEPINT4_Msk = 0x10
	// Bit INEPINT4.
	USB_DAINT_INEPINT4 = 0x10
	// Position of INEPINT5 field.
	USB_DAINT_INEPINT5_Pos = 0x5
	// Bit mask of INEPINT5 field.
	USB_DAINT_INEPINT5_Msk = 0x20
	// Bit INEPINT5.
	USB_DAINT_INEPINT5 = 0x20
	// Position of INEPINT6 field.
	USB_DAINT_INEPINT6_Pos = 0x6
	// Bit mask of INEPINT6 field.
	USB_DAINT_INEPINT6_Msk = 0x40
	// Bit INEPINT6.
	USB_DAINT_INEPINT6 = 0x40
	// Position of OUTEPINT0 field.
	USB_DAINT_OUTEPINT0_Pos = 0x10
	// Bit mask of OUTEPINT0 field.
	USB_DAINT_OUTEPINT0_Msk = 0x10000
	// Bit OUTEPINT0.
	USB_DAINT_OUTEPINT0 = 0x10000
	// Position of OUTEPINT1 field.
	USB_DAINT_OUTEPINT1_Pos = 0x11
	// Bit mask of OUTEPINT1 field.
	USB_DAINT_OUTEPINT1_Msk = 0x20000
	// Bit OUTEPINT1.
	USB_DAINT_OUTEPINT1 = 0x20000
	// Position of OUTEPINT2 field.
	USB_DAINT_OUTEPINT2_Pos = 0x12
	// Bit mask of OUTEPINT2 field.
	USB_DAINT_OUTEPINT2_Msk = 0x40000
	// Bit OUTEPINT2.
	USB_DAINT_OUTEPINT2 = 0x40000
	// Position of OUTEPINT3 field.
	USB_DAINT_OUTEPINT3_Pos = 0x13
	// Bit mask of OUTEPINT3 field.
	USB_DAINT_OUTEPINT3_Msk = 0x80000
	// Bit OUTEPINT3.
	USB_DAINT_OUTEPINT3 = 0x80000
	// Position of OUTEPINT4 field.
	USB_DAINT_OUTEPINT4_Pos = 0x14
	// Bit mask of OUTEPINT4 field.
	USB_DAINT_OUTEPINT4_Msk = 0x100000
	// Bit OUTEPINT4.
	USB_DAINT_OUTEPINT4 = 0x100000
	// Position of OUTEPINT5 field.
	USB_DAINT_OUTEPINT5_Pos = 0x15
	// Bit mask of OUTEPINT5 field.
	USB_DAINT_OUTEPINT5_Msk = 0x200000
	// Bit OUTEPINT5.
	USB_DAINT_OUTEPINT5 = 0x200000
	// Position of OUTEPINT6 field.
	USB_DAINT_OUTEPINT6_Pos = 0x16
	// Bit mask of OUTEPINT6 field.
	USB_DAINT_OUTEPINT6_Msk = 0x400000
	// Bit OUTEPINT6.
	USB_DAINT_OUTEPINT6 = 0x400000

	// DAINTMSK
	// Position of INEPMSK0 field.
	USB_DAINTMSK_INEPMSK0_Pos = 0x0
	// Bit mask of INEPMSK0 field.
	USB_DAINTMSK_INEPMSK0_Msk = 0x1
	// Bit INEPMSK0.
	USB_DAINTMSK_INEPMSK0 = 0x1
	// Position of INEPMSK1 field.
	USB_DAINTMSK_INEPMSK1_Pos = 0x1
	// Bit mask of INEPMSK1 field.
	USB_DAINTMSK_INEPMSK1_Msk = 0x2
	// Bit INEPMSK1.
	USB_DAINTMSK_INEPMSK1 = 0x2
	// Position of INEPMSK2 field.
	USB_DAINTMSK_INEPMSK2_Pos = 0x2
	// Bit mask of INEPMSK2 field.
	USB_DAINTMSK_INEPMSK2_Msk = 0x4
	// Bit INEPMSK2.
	USB_DAINTMSK_INEPMSK2 = 0x4
	// Position of INEPMSK3 field.
	USB_DAINTMSK_INEPMSK3_Pos = 0x3
	// Bit mask of INEPMSK3 field.
	USB_DAINTMSK_INEPMSK3_Msk = 0x8
	// Bit INEPMSK3.
	USB_DAINTMSK_INEPMSK3 = 0x8
	// Position of INEPMSK4 field.
	USB_DAINTMSK_INEPMSK4_Pos = 0x4
	// Bit mask of INEPMSK4 field.
	USB_DAINTMSK_INEPMSK4_Msk = 0x10
	// Bit INEPMSK4.
	USB_DAINTMSK_INEPMSK4 = 0x10
	// Position of INEPMSK5 field.
	USB_DAINTMSK_INEPMSK5_Pos = 0x5
	// Bit mask of INEPMSK5 field.
	USB_DAINTMSK_INEPMSK5_Msk = 0x20
	// Bit INEPMSK5.
	USB_DAINTMSK_INEPMSK5 = 0x20
	// Position of INEPMSK6 field.
	USB_DAINTMSK_INEPMSK6_Pos = 0x6
	// Bit mask of INEPMSK6 field.
	USB_DAINTMSK_INEPMSK6_Msk = 0x40
	// Bit INEPMSK6.
	USB_DAINTMSK_INEPMSK6 = 0x40
	// Position of OUTEPMSK0 field.
	USB_DAINTMSK_OUTEPMSK0_Pos = 0x10
	// Bit mask of OUTEPMSK0 field.
	USB_DAINTMSK_OUTEPMSK0_Msk = 0x10000
	// Bit OUTEPMSK0.
	USB_DAINTMSK_OUTEPMSK0 = 0x10000
	// Position of OUTEPMSK1 field.
	USB_DAINTMSK_OUTEPMSK1_Pos = 0x11
	// Bit mask of OUTEPMSK1 field.
	USB_DAINTMSK_OUTEPMSK1_Msk = 0x20000
	// Bit OUTEPMSK1.
	USB_DAINTMSK_OUTEPMSK1 = 0x20000
	// Position of OUTEPMSK2 field.
	USB_DAINTMSK_OUTEPMSK2_Pos = 0x12
	// Bit mask of OUTEPMSK2 field.
	USB_DAINTMSK_OUTEPMSK2_Msk = 0x40000
	// Bit OUTEPMSK2.
	USB_DAINTMSK_OUTEPMSK2 = 0x40000
	// Position of OUTEPMSK3 field.
	USB_DAINTMSK_OUTEPMSK3_Pos = 0x13
	// Bit mask of OUTEPMSK3 field.
	USB_DAINTMSK_OUTEPMSK3_Msk = 0x80000
	// Bit OUTEPMSK3.
	USB_DAINTMSK_OUTEPMSK3 = 0x80000
	// Position of OUTEPMSK4 field.
	USB_DAINTMSK_OUTEPMSK4_Pos = 0x14
	// Bit mask of OUTEPMSK4 field.
	USB_DAINTMSK_OUTEPMSK4_Msk = 0x100000
	// Bit OUTEPMSK4.
	USB_DAINTMSK_OUTEPMSK4 = 0x100000
	// Position of OUTEPMSK5 field.
	USB_DAINTMSK_OUTEPMSK5_Pos = 0x15
	// Bit mask of OUTEPMSK5 field.
	USB_DAINTMSK_OUTEPMSK5_Msk = 0x200000
	// Bit OUTEPMSK5.
	USB_DAINTMSK_OUTEPMSK5 = 0x200000
	// Position of OUTEPMSK6 field.
	USB_DAINTMSK_OUTEPMSK6_Pos = 0x16
	// Bit mask of OUTEPMSK6 field.
	USB_DAINTMSK_OUTEPMSK6_Msk = 0x400000
	// Bit OUTEPMSK6.
	USB_DAINTMSK_OUTEPMSK6 = 0x400000

	// DVBUSDIS
	// Position of DVBUSDIS field.
	USB_DVBUSDIS_DVBUSDIS_Pos = 0x0
	// Bit mask of DVBUSDIS field.
	USB_DVBUSDIS_DVBUSDIS_Msk = 0xffff

	// DVBUSPULSE
	// Position of DVBUSPULSE field.
	USB_DVBUSPULSE_DVBUSPULSE_Pos = 0x0
	// Bit mask of DVBUSPULSE field.
	USB_DVBUSPULSE_DVBUSPULSE_Msk = 0xfff

	// DTHRCTL
	// Position of NONISOTHREN field.
	USB_DTHRCTL_NONISOTHREN_Pos = 0x0
	// Bit mask of NONISOTHREN field.
	USB_DTHRCTL_NONISOTHREN_Msk = 0x1
	// Bit NONISOTHREN.
	USB_DTHRCTL_NONISOTHREN = 0x1
	// Position of ISOTHREN field.
	USB_DTHRCTL_ISOTHREN_Pos = 0x1
	// Bit mask of ISOTHREN field.
	USB_DTHRCTL_ISOTHREN_Msk = 0x2
	// Bit ISOTHREN.
	USB_DTHRCTL_ISOTHREN = 0x2
	// Position of TXTHRLEN field.
	USB_DTHRCTL_TXTHRLEN_Pos = 0x2
	// Bit mask of TXTHRLEN field.
	USB_DTHRCTL_TXTHRLEN_Msk = 0x7fc
	// Position of AHBTHRRATIO field.
	USB_DTHRCTL_AHBTHRRATIO_Pos = 0xb
	// Bit mask of AHBTHRRATIO field.
	USB_DTHRCTL_AHBTHRRATIO_Msk = 0x1800
	// Position of RXTHREN field.
	USB_DTHRCTL_RXTHREN_Pos = 0x10
	// Bit mask of RXTHREN field.
	USB_DTHRCTL_RXTHREN_Msk = 0x10000
	// Bit RXTHREN.
	USB_DTHRCTL_RXTHREN = 0x10000
	// Position of RXTHRLEN field.
	USB_DTHRCTL_RXTHRLEN_Pos = 0x11
	// Bit mask of RXTHRLEN field.
	USB_DTHRCTL_RXTHRLEN_Msk = 0x3fe0000
	// Position of ARBPRKEN field.
	USB_DTHRCTL_ARBPRKEN_Pos = 0x1b
	// Bit mask of ARBPRKEN field.
	USB_DTHRCTL_ARBPRKEN_Msk = 0x8000000
	// Bit ARBPRKEN.
	USB_DTHRCTL_ARBPRKEN = 0x8000000

	// DIEPEMPMSK
	// Position of D_INEPTXFEMPMSK field.
	USB_DIEPEMPMSK_D_INEPTXFEMPMSK_Pos = 0x0
	// Bit mask of D_INEPTXFEMPMSK field.
	USB_DIEPEMPMSK_D_INEPTXFEMPMSK_Msk = 0xffff

	// DIEPCTL0
	// Position of D_MPS0 field.
	USB_DIEPCTL0_D_MPS0_Pos = 0x0
	// Bit mask of D_MPS0 field.
	USB_DIEPCTL0_D_MPS0_Msk = 0x3
	// Position of D_USBACTEP0 field.
	USB_DIEPCTL0_D_USBACTEP0_Pos = 0xf
	// Bit mask of D_USBACTEP0 field.
	USB_DIEPCTL0_D_USBACTEP0_Msk = 0x8000
	// Bit D_USBACTEP0.
	USB_DIEPCTL0_D_USBACTEP0 = 0x8000
	// Position of D_NAKSTS0 field.
	USB_DIEPCTL0_D_NAKSTS0_Pos = 0x11
	// Bit mask of D_NAKSTS0 field.
	USB_DIEPCTL0_D_NAKSTS0_Msk = 0x20000
	// Bit D_NAKSTS0.
	USB_DIEPCTL0_D_NAKSTS0 = 0x20000
	// Position of D_EPTYPE0 field.
	USB_DIEPCTL0_D_EPTYPE0_Pos = 0x12
	// Bit mask of D_EPTYPE0 field.
	USB_DIEPCTL0_D_EPTYPE0_Msk = 0xc0000
	// Position of D_STALL0 field.
	USB_DIEPCTL0_D_STALL0_Pos = 0x15
	// Bit mask of D_STALL0 field.
	USB_DIEPCTL0_D_STALL0_Msk = 0x200000
	// Bit D_STALL0.
	USB_DIEPCTL0_D_STALL0 = 0x200000
	// Position of D_TXFNUM0 field.
	USB_DIEPCTL0_D_TXFNUM0_Pos = 0x16
	// Bit mask of D_TXFNUM0 field.
	USB_DIEPCTL0_D_TXFNUM0_Msk = 0x3c00000
	// Position of D_CNAK0 field.
	USB_DIEPCTL0_D_CNAK0_Pos = 0x1a
	// Bit mask of D_CNAK0 field.
	USB_DIEPCTL0_D_CNAK0_Msk = 0x4000000
	// Bit D_CNAK0.
	USB_DIEPCTL0_D_CNAK0 = 0x4000000
	// Position of DI_SNAK0 field.
	USB_DIEPCTL0_DI_SNAK0_Pos = 0x1b
	// Bit mask of DI_SNAK0 field.
	USB_DIEPCTL0_DI_SNAK0_Msk = 0x8000000
	// Bit DI_SNAK0.
	USB_DIEPCTL0_DI_SNAK0 = 0x8000000
	// Position of D_EPDIS0 field.
	USB_DIEPCTL0_D_EPDIS0_Pos = 0x1e
	// Bit mask of D_EPDIS0 field.
	USB_DIEPCTL0_D_EPDIS0_Msk = 0x40000000
	// Bit D_EPDIS0.
	USB_DIEPCTL0_D_EPDIS0 = 0x40000000
	// Position of D_EPENA0 field.
	USB_DIEPCTL0_D_EPENA0_Pos = 0x1f
	// Bit mask of D_EPENA0 field.
	USB_DIEPCTL0_D_EPENA0_Msk = 0x80000000
	// Bit D_EPENA0.
	USB_DIEPCTL0_D_EPENA0 = 0x80000000

	// DIEPINT0
	// Position of D_XFERCOMPL0 field.
	USB_DIEPINT0_D_XFERCOMPL0_Pos = 0x0
	// Bit mask of D_XFERCOMPL0 field.
	USB_DIEPINT0_D_XFERCOMPL0_Msk = 0x1
	// Bit D_XFERCOMPL0.
	USB_DIEPINT0_D_XFERCOMPL0 = 0x1
	// Position of D_EPDISBLD0 field.
	USB_DIEPINT0_D_EPDISBLD0_Pos = 0x1
	// Bit mask of D_EPDISBLD0 field.
	USB_DIEPINT0_D_EPDISBLD0_Msk = 0x2
	// Bit D_EPDISBLD0.
	USB_DIEPINT0_D_EPDISBLD0 = 0x2
	// Position of D_AHBERR0 field.
	USB_DIEPINT0_D_AHBERR0_Pos = 0x2
	// Bit mask of D_AHBERR0 field.
	USB_DIEPINT0_D_AHBERR0_Msk = 0x4
	// Bit D_AHBERR0.
	USB_DIEPINT0_D_AHBERR0 = 0x4
	// Position of D_TIMEOUT0 field.
	USB_DIEPINT0_D_TIMEOUT0_Pos = 0x3
	// Bit mask of D_TIMEOUT0 field.
	USB_DIEPINT0_D_TIMEOUT0_Msk = 0x8
	// Bit D_TIMEOUT0.
	USB_DIEPINT0_D_TIMEOUT0 = 0x8
	// Position of D_INTKNTXFEMP0 field.
	USB_DIEPINT0_D_INTKNTXFEMP0_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP0 field.
	USB_DIEPINT0_D_INTKNTXFEMP0_Msk = 0x10
	// Bit D_INTKNTXFEMP0.
	USB_DIEPINT0_D_INTKNTXFEMP0 = 0x10
	// Position of D_INTKNEPMIS0 field.
	USB_DIEPINT0_D_INTKNEPMIS0_Pos = 0x5
	// Bit mask of D_INTKNEPMIS0 field.
	USB_DIEPINT0_D_INTKNEPMIS0_Msk = 0x20
	// Bit D_INTKNEPMIS0.
	USB_DIEPINT0_D_INTKNEPMIS0 = 0x20
	// Position of D_INEPNAKEFF0 field.
	USB_DIEPINT0_D_INEPNAKEFF0_Pos = 0x6
	// Bit mask of D_INEPNAKEFF0 field.
	USB_DIEPINT0_D_INEPNAKEFF0_Msk = 0x40
	// Bit D_INEPNAKEFF0.
	USB_DIEPINT0_D_INEPNAKEFF0 = 0x40
	// Position of D_TXFEMP0 field.
	USB_DIEPINT0_D_TXFEMP0_Pos = 0x7
	// Bit mask of D_TXFEMP0 field.
	USB_DIEPINT0_D_TXFEMP0_Msk = 0x80
	// Bit D_TXFEMP0.
	USB_DIEPINT0_D_TXFEMP0 = 0x80
	// Position of D_TXFIFOUNDRN0 field.
	USB_DIEPINT0_D_TXFIFOUNDRN0_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN0 field.
	USB_DIEPINT0_D_TXFIFOUNDRN0_Msk = 0x100
	// Bit D_TXFIFOUNDRN0.
	USB_DIEPINT0_D_TXFIFOUNDRN0 = 0x100
	// Position of D_BNAINTR0 field.
	USB_DIEPINT0_D_BNAINTR0_Pos = 0x9
	// Bit mask of D_BNAINTR0 field.
	USB_DIEPINT0_D_BNAINTR0_Msk = 0x200
	// Bit D_BNAINTR0.
	USB_DIEPINT0_D_BNAINTR0 = 0x200
	// Position of D_PKTDRPSTS0 field.
	USB_DIEPINT0_D_PKTDRPSTS0_Pos = 0xb
	// Bit mask of D_PKTDRPSTS0 field.
	USB_DIEPINT0_D_PKTDRPSTS0_Msk = 0x800
	// Bit D_PKTDRPSTS0.
	USB_DIEPINT0_D_PKTDRPSTS0 = 0x800
	// Position of D_BBLEERR0 field.
	USB_DIEPINT0_D_BBLEERR0_Pos = 0xc
	// Bit mask of D_BBLEERR0 field.
	USB_DIEPINT0_D_BBLEERR0_Msk = 0x1000
	// Bit D_BBLEERR0.
	USB_DIEPINT0_D_BBLEERR0 = 0x1000
	// Position of D_NAKINTRPT0 field.
	USB_DIEPINT0_D_NAKINTRPT0_Pos = 0xd
	// Bit mask of D_NAKINTRPT0 field.
	USB_DIEPINT0_D_NAKINTRPT0_Msk = 0x2000
	// Bit D_NAKINTRPT0.
	USB_DIEPINT0_D_NAKINTRPT0 = 0x2000
	// Position of D_NYETINTRPT0 field.
	USB_DIEPINT0_D_NYETINTRPT0_Pos = 0xe
	// Bit mask of D_NYETINTRPT0 field.
	USB_DIEPINT0_D_NYETINTRPT0_Msk = 0x4000
	// Bit D_NYETINTRPT0.
	USB_DIEPINT0_D_NYETINTRPT0 = 0x4000

	// DIEPTSIZ0
	// Position of D_XFERSIZE0 field.
	USB_DIEPTSIZ0_D_XFERSIZE0_Pos = 0x0
	// Bit mask of D_XFERSIZE0 field.
	USB_DIEPTSIZ0_D_XFERSIZE0_Msk = 0x7f
	// Position of D_PKTCNT0 field.
	USB_DIEPTSIZ0_D_PKTCNT0_Pos = 0x13
	// Bit mask of D_PKTCNT0 field.
	USB_DIEPTSIZ0_D_PKTCNT0_Msk = 0x180000

	// DIEPDMA0
	// Position of D_DMAADDR0 field.
	USB_DIEPDMA0_D_DMAADDR0_Pos = 0x0
	// Bit mask of D_DMAADDR0 field.
	USB_DIEPDMA0_D_DMAADDR0_Msk = 0xffffffff

	// DTXFSTS0
	// Position of D_INEPTXFSPCAVAIL0 field.
	USB_DTXFSTS0_D_INEPTXFSPCAVAIL0_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL0 field.
	USB_DTXFSTS0_D_INEPTXFSPCAVAIL0_Msk = 0xffff

	// DIEPDMAB0
	// Position of D_DMABUFFERADDR0 field.
	USB_DIEPDMAB0_D_DMABUFFERADDR0_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR0 field.
	USB_DIEPDMAB0_D_DMABUFFERADDR0_Msk = 0xffffffff

	// DIEPCTL1
	// Position of D_MPS1 field.
	USB_DIEPCTL1_D_MPS1_Pos = 0x0
	// Bit mask of D_MPS1 field.
	USB_DIEPCTL1_D_MPS1_Msk = 0x3
	// Position of D_USBACTEP1 field.
	USB_DIEPCTL1_D_USBACTEP1_Pos = 0xf
	// Bit mask of D_USBACTEP1 field.
	USB_DIEPCTL1_D_USBACTEP1_Msk = 0x8000
	// Bit D_USBACTEP1.
	USB_DIEPCTL1_D_USBACTEP1 = 0x8000
	// Position of D_NAKSTS1 field.
	USB_DIEPCTL1_D_NAKSTS1_Pos = 0x11
	// Bit mask of D_NAKSTS1 field.
	USB_DIEPCTL1_D_NAKSTS1_Msk = 0x20000
	// Bit D_NAKSTS1.
	USB_DIEPCTL1_D_NAKSTS1 = 0x20000
	// Position of D_EPTYPE1 field.
	USB_DIEPCTL1_D_EPTYPE1_Pos = 0x12
	// Bit mask of D_EPTYPE1 field.
	USB_DIEPCTL1_D_EPTYPE1_Msk = 0xc0000
	// Position of D_STALL1 field.
	USB_DIEPCTL1_D_STALL1_Pos = 0x15
	// Bit mask of D_STALL1 field.
	USB_DIEPCTL1_D_STALL1_Msk = 0x200000
	// Bit D_STALL1.
	USB_DIEPCTL1_D_STALL1 = 0x200000
	// Position of D_TXFNUM1 field.
	USB_DIEPCTL1_D_TXFNUM1_Pos = 0x16
	// Bit mask of D_TXFNUM1 field.
	USB_DIEPCTL1_D_TXFNUM1_Msk = 0x3c00000
	// Position of D_CNAK1 field.
	USB_DIEPCTL1_D_CNAK1_Pos = 0x1a
	// Bit mask of D_CNAK1 field.
	USB_DIEPCTL1_D_CNAK1_Msk = 0x4000000
	// Bit D_CNAK1.
	USB_DIEPCTL1_D_CNAK1 = 0x4000000
	// Position of DI_SNAK1 field.
	USB_DIEPCTL1_DI_SNAK1_Pos = 0x1b
	// Bit mask of DI_SNAK1 field.
	USB_DIEPCTL1_DI_SNAK1_Msk = 0x8000000
	// Bit DI_SNAK1.
	USB_DIEPCTL1_DI_SNAK1 = 0x8000000
	// Position of DI_SETD0PID1 field.
	USB_DIEPCTL1_DI_SETD0PID1_Pos = 0x1c
	// Bit mask of DI_SETD0PID1 field.
	USB_DIEPCTL1_DI_SETD0PID1_Msk = 0x10000000
	// Bit DI_SETD0PID1.
	USB_DIEPCTL1_DI_SETD0PID1 = 0x10000000
	// Position of DI_SETD1PID1 field.
	USB_DIEPCTL1_DI_SETD1PID1_Pos = 0x1d
	// Bit mask of DI_SETD1PID1 field.
	USB_DIEPCTL1_DI_SETD1PID1_Msk = 0x20000000
	// Bit DI_SETD1PID1.
	USB_DIEPCTL1_DI_SETD1PID1 = 0x20000000
	// Position of D_EPDIS1 field.
	USB_DIEPCTL1_D_EPDIS1_Pos = 0x1e
	// Bit mask of D_EPDIS1 field.
	USB_DIEPCTL1_D_EPDIS1_Msk = 0x40000000
	// Bit D_EPDIS1.
	USB_DIEPCTL1_D_EPDIS1 = 0x40000000
	// Position of D_EPENA1 field.
	USB_DIEPCTL1_D_EPENA1_Pos = 0x1f
	// Bit mask of D_EPENA1 field.
	USB_DIEPCTL1_D_EPENA1_Msk = 0x80000000
	// Bit D_EPENA1.
	USB_DIEPCTL1_D_EPENA1 = 0x80000000

	// DIEPINT1
	// Position of D_XFERCOMPL1 field.
	USB_DIEPINT1_D_XFERCOMPL1_Pos = 0x0
	// Bit mask of D_XFERCOMPL1 field.
	USB_DIEPINT1_D_XFERCOMPL1_Msk = 0x1
	// Bit D_XFERCOMPL1.
	USB_DIEPINT1_D_XFERCOMPL1 = 0x1
	// Position of D_EPDISBLD1 field.
	USB_DIEPINT1_D_EPDISBLD1_Pos = 0x1
	// Bit mask of D_EPDISBLD1 field.
	USB_DIEPINT1_D_EPDISBLD1_Msk = 0x2
	// Bit D_EPDISBLD1.
	USB_DIEPINT1_D_EPDISBLD1 = 0x2
	// Position of D_AHBERR1 field.
	USB_DIEPINT1_D_AHBERR1_Pos = 0x2
	// Bit mask of D_AHBERR1 field.
	USB_DIEPINT1_D_AHBERR1_Msk = 0x4
	// Bit D_AHBERR1.
	USB_DIEPINT1_D_AHBERR1 = 0x4
	// Position of D_TIMEOUT1 field.
	USB_DIEPINT1_D_TIMEOUT1_Pos = 0x3
	// Bit mask of D_TIMEOUT1 field.
	USB_DIEPINT1_D_TIMEOUT1_Msk = 0x8
	// Bit D_TIMEOUT1.
	USB_DIEPINT1_D_TIMEOUT1 = 0x8
	// Position of D_INTKNTXFEMP1 field.
	USB_DIEPINT1_D_INTKNTXFEMP1_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP1 field.
	USB_DIEPINT1_D_INTKNTXFEMP1_Msk = 0x10
	// Bit D_INTKNTXFEMP1.
	USB_DIEPINT1_D_INTKNTXFEMP1 = 0x10
	// Position of D_INTKNEPMIS1 field.
	USB_DIEPINT1_D_INTKNEPMIS1_Pos = 0x5
	// Bit mask of D_INTKNEPMIS1 field.
	USB_DIEPINT1_D_INTKNEPMIS1_Msk = 0x20
	// Bit D_INTKNEPMIS1.
	USB_DIEPINT1_D_INTKNEPMIS1 = 0x20
	// Position of D_INEPNAKEFF1 field.
	USB_DIEPINT1_D_INEPNAKEFF1_Pos = 0x6
	// Bit mask of D_INEPNAKEFF1 field.
	USB_DIEPINT1_D_INEPNAKEFF1_Msk = 0x40
	// Bit D_INEPNAKEFF1.
	USB_DIEPINT1_D_INEPNAKEFF1 = 0x40
	// Position of D_TXFEMP1 field.
	USB_DIEPINT1_D_TXFEMP1_Pos = 0x7
	// Bit mask of D_TXFEMP1 field.
	USB_DIEPINT1_D_TXFEMP1_Msk = 0x80
	// Bit D_TXFEMP1.
	USB_DIEPINT1_D_TXFEMP1 = 0x80
	// Position of D_TXFIFOUNDRN1 field.
	USB_DIEPINT1_D_TXFIFOUNDRN1_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN1 field.
	USB_DIEPINT1_D_TXFIFOUNDRN1_Msk = 0x100
	// Bit D_TXFIFOUNDRN1.
	USB_DIEPINT1_D_TXFIFOUNDRN1 = 0x100
	// Position of D_BNAINTR1 field.
	USB_DIEPINT1_D_BNAINTR1_Pos = 0x9
	// Bit mask of D_BNAINTR1 field.
	USB_DIEPINT1_D_BNAINTR1_Msk = 0x200
	// Bit D_BNAINTR1.
	USB_DIEPINT1_D_BNAINTR1 = 0x200
	// Position of D_PKTDRPSTS1 field.
	USB_DIEPINT1_D_PKTDRPSTS1_Pos = 0xb
	// Bit mask of D_PKTDRPSTS1 field.
	USB_DIEPINT1_D_PKTDRPSTS1_Msk = 0x800
	// Bit D_PKTDRPSTS1.
	USB_DIEPINT1_D_PKTDRPSTS1 = 0x800
	// Position of D_BBLEERR1 field.
	USB_DIEPINT1_D_BBLEERR1_Pos = 0xc
	// Bit mask of D_BBLEERR1 field.
	USB_DIEPINT1_D_BBLEERR1_Msk = 0x1000
	// Bit D_BBLEERR1.
	USB_DIEPINT1_D_BBLEERR1 = 0x1000
	// Position of D_NAKINTRPT1 field.
	USB_DIEPINT1_D_NAKINTRPT1_Pos = 0xd
	// Bit mask of D_NAKINTRPT1 field.
	USB_DIEPINT1_D_NAKINTRPT1_Msk = 0x2000
	// Bit D_NAKINTRPT1.
	USB_DIEPINT1_D_NAKINTRPT1 = 0x2000
	// Position of D_NYETINTRPT1 field.
	USB_DIEPINT1_D_NYETINTRPT1_Pos = 0xe
	// Bit mask of D_NYETINTRPT1 field.
	USB_DIEPINT1_D_NYETINTRPT1_Msk = 0x4000
	// Bit D_NYETINTRPT1.
	USB_DIEPINT1_D_NYETINTRPT1 = 0x4000

	// DIEPTSIZ1
	// Position of D_XFERSIZE1 field.
	USB_DIEPTSIZ1_D_XFERSIZE1_Pos = 0x0
	// Bit mask of D_XFERSIZE1 field.
	USB_DIEPTSIZ1_D_XFERSIZE1_Msk = 0x7f
	// Position of D_PKTCNT1 field.
	USB_DIEPTSIZ1_D_PKTCNT1_Pos = 0x13
	// Bit mask of D_PKTCNT1 field.
	USB_DIEPTSIZ1_D_PKTCNT1_Msk = 0x180000

	// DIEPDMA1
	// Position of D_DMAADDR1 field.
	USB_DIEPDMA1_D_DMAADDR1_Pos = 0x0
	// Bit mask of D_DMAADDR1 field.
	USB_DIEPDMA1_D_DMAADDR1_Msk = 0xffffffff

	// DTXFSTS1
	// Position of D_INEPTXFSPCAVAIL1 field.
	USB_DTXFSTS1_D_INEPTXFSPCAVAIL1_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL1 field.
	USB_DTXFSTS1_D_INEPTXFSPCAVAIL1_Msk = 0xffff

	// DIEPDMAB1
	// Position of D_DMABUFFERADDR1 field.
	USB_DIEPDMAB1_D_DMABUFFERADDR1_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR1 field.
	USB_DIEPDMAB1_D_DMABUFFERADDR1_Msk = 0xffffffff

	// DIEPCTL2
	// Position of D_MPS2 field.
	USB_DIEPCTL2_D_MPS2_Pos = 0x0
	// Bit mask of D_MPS2 field.
	USB_DIEPCTL2_D_MPS2_Msk = 0x3
	// Position of D_USBACTEP2 field.
	USB_DIEPCTL2_D_USBACTEP2_Pos = 0xf
	// Bit mask of D_USBACTEP2 field.
	USB_DIEPCTL2_D_USBACTEP2_Msk = 0x8000
	// Bit D_USBACTEP2.
	USB_DIEPCTL2_D_USBACTEP2 = 0x8000
	// Position of D_NAKSTS2 field.
	USB_DIEPCTL2_D_NAKSTS2_Pos = 0x11
	// Bit mask of D_NAKSTS2 field.
	USB_DIEPCTL2_D_NAKSTS2_Msk = 0x20000
	// Bit D_NAKSTS2.
	USB_DIEPCTL2_D_NAKSTS2 = 0x20000
	// Position of D_EPTYPE2 field.
	USB_DIEPCTL2_D_EPTYPE2_Pos = 0x12
	// Bit mask of D_EPTYPE2 field.
	USB_DIEPCTL2_D_EPTYPE2_Msk = 0xc0000
	// Position of D_STALL2 field.
	USB_DIEPCTL2_D_STALL2_Pos = 0x15
	// Bit mask of D_STALL2 field.
	USB_DIEPCTL2_D_STALL2_Msk = 0x200000
	// Bit D_STALL2.
	USB_DIEPCTL2_D_STALL2 = 0x200000
	// Position of D_TXFNUM2 field.
	USB_DIEPCTL2_D_TXFNUM2_Pos = 0x16
	// Bit mask of D_TXFNUM2 field.
	USB_DIEPCTL2_D_TXFNUM2_Msk = 0x3c00000
	// Position of D_CNAK2 field.
	USB_DIEPCTL2_D_CNAK2_Pos = 0x1a
	// Bit mask of D_CNAK2 field.
	USB_DIEPCTL2_D_CNAK2_Msk = 0x4000000
	// Bit D_CNAK2.
	USB_DIEPCTL2_D_CNAK2 = 0x4000000
	// Position of DI_SNAK2 field.
	USB_DIEPCTL2_DI_SNAK2_Pos = 0x1b
	// Bit mask of DI_SNAK2 field.
	USB_DIEPCTL2_DI_SNAK2_Msk = 0x8000000
	// Bit DI_SNAK2.
	USB_DIEPCTL2_DI_SNAK2 = 0x8000000
	// Position of DI_SETD0PID2 field.
	USB_DIEPCTL2_DI_SETD0PID2_Pos = 0x1c
	// Bit mask of DI_SETD0PID2 field.
	USB_DIEPCTL2_DI_SETD0PID2_Msk = 0x10000000
	// Bit DI_SETD0PID2.
	USB_DIEPCTL2_DI_SETD0PID2 = 0x10000000
	// Position of DI_SETD1PID2 field.
	USB_DIEPCTL2_DI_SETD1PID2_Pos = 0x1d
	// Bit mask of DI_SETD1PID2 field.
	USB_DIEPCTL2_DI_SETD1PID2_Msk = 0x20000000
	// Bit DI_SETD1PID2.
	USB_DIEPCTL2_DI_SETD1PID2 = 0x20000000
	// Position of D_EPDIS2 field.
	USB_DIEPCTL2_D_EPDIS2_Pos = 0x1e
	// Bit mask of D_EPDIS2 field.
	USB_DIEPCTL2_D_EPDIS2_Msk = 0x40000000
	// Bit D_EPDIS2.
	USB_DIEPCTL2_D_EPDIS2 = 0x40000000
	// Position of D_EPENA2 field.
	USB_DIEPCTL2_D_EPENA2_Pos = 0x1f
	// Bit mask of D_EPENA2 field.
	USB_DIEPCTL2_D_EPENA2_Msk = 0x80000000
	// Bit D_EPENA2.
	USB_DIEPCTL2_D_EPENA2 = 0x80000000

	// DIEPINT2
	// Position of D_XFERCOMPL2 field.
	USB_DIEPINT2_D_XFERCOMPL2_Pos = 0x0
	// Bit mask of D_XFERCOMPL2 field.
	USB_DIEPINT2_D_XFERCOMPL2_Msk = 0x1
	// Bit D_XFERCOMPL2.
	USB_DIEPINT2_D_XFERCOMPL2 = 0x1
	// Position of D_EPDISBLD2 field.
	USB_DIEPINT2_D_EPDISBLD2_Pos = 0x1
	// Bit mask of D_EPDISBLD2 field.
	USB_DIEPINT2_D_EPDISBLD2_Msk = 0x2
	// Bit D_EPDISBLD2.
	USB_DIEPINT2_D_EPDISBLD2 = 0x2
	// Position of D_AHBERR2 field.
	USB_DIEPINT2_D_AHBERR2_Pos = 0x2
	// Bit mask of D_AHBERR2 field.
	USB_DIEPINT2_D_AHBERR2_Msk = 0x4
	// Bit D_AHBERR2.
	USB_DIEPINT2_D_AHBERR2 = 0x4
	// Position of D_TIMEOUT2 field.
	USB_DIEPINT2_D_TIMEOUT2_Pos = 0x3
	// Bit mask of D_TIMEOUT2 field.
	USB_DIEPINT2_D_TIMEOUT2_Msk = 0x8
	// Bit D_TIMEOUT2.
	USB_DIEPINT2_D_TIMEOUT2 = 0x8
	// Position of D_INTKNTXFEMP2 field.
	USB_DIEPINT2_D_INTKNTXFEMP2_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP2 field.
	USB_DIEPINT2_D_INTKNTXFEMP2_Msk = 0x10
	// Bit D_INTKNTXFEMP2.
	USB_DIEPINT2_D_INTKNTXFEMP2 = 0x10
	// Position of D_INTKNEPMIS2 field.
	USB_DIEPINT2_D_INTKNEPMIS2_Pos = 0x5
	// Bit mask of D_INTKNEPMIS2 field.
	USB_DIEPINT2_D_INTKNEPMIS2_Msk = 0x20
	// Bit D_INTKNEPMIS2.
	USB_DIEPINT2_D_INTKNEPMIS2 = 0x20
	// Position of D_INEPNAKEFF2 field.
	USB_DIEPINT2_D_INEPNAKEFF2_Pos = 0x6
	// Bit mask of D_INEPNAKEFF2 field.
	USB_DIEPINT2_D_INEPNAKEFF2_Msk = 0x40
	// Bit D_INEPNAKEFF2.
	USB_DIEPINT2_D_INEPNAKEFF2 = 0x40
	// Position of D_TXFEMP2 field.
	USB_DIEPINT2_D_TXFEMP2_Pos = 0x7
	// Bit mask of D_TXFEMP2 field.
	USB_DIEPINT2_D_TXFEMP2_Msk = 0x80
	// Bit D_TXFEMP2.
	USB_DIEPINT2_D_TXFEMP2 = 0x80
	// Position of D_TXFIFOUNDRN2 field.
	USB_DIEPINT2_D_TXFIFOUNDRN2_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN2 field.
	USB_DIEPINT2_D_TXFIFOUNDRN2_Msk = 0x100
	// Bit D_TXFIFOUNDRN2.
	USB_DIEPINT2_D_TXFIFOUNDRN2 = 0x100
	// Position of D_BNAINTR2 field.
	USB_DIEPINT2_D_BNAINTR2_Pos = 0x9
	// Bit mask of D_BNAINTR2 field.
	USB_DIEPINT2_D_BNAINTR2_Msk = 0x200
	// Bit D_BNAINTR2.
	USB_DIEPINT2_D_BNAINTR2 = 0x200
	// Position of D_PKTDRPSTS2 field.
	USB_DIEPINT2_D_PKTDRPSTS2_Pos = 0xb
	// Bit mask of D_PKTDRPSTS2 field.
	USB_DIEPINT2_D_PKTDRPSTS2_Msk = 0x800
	// Bit D_PKTDRPSTS2.
	USB_DIEPINT2_D_PKTDRPSTS2 = 0x800
	// Position of D_BBLEERR2 field.
	USB_DIEPINT2_D_BBLEERR2_Pos = 0xc
	// Bit mask of D_BBLEERR2 field.
	USB_DIEPINT2_D_BBLEERR2_Msk = 0x1000
	// Bit D_BBLEERR2.
	USB_DIEPINT2_D_BBLEERR2 = 0x1000
	// Position of D_NAKINTRPT2 field.
	USB_DIEPINT2_D_NAKINTRPT2_Pos = 0xd
	// Bit mask of D_NAKINTRPT2 field.
	USB_DIEPINT2_D_NAKINTRPT2_Msk = 0x2000
	// Bit D_NAKINTRPT2.
	USB_DIEPINT2_D_NAKINTRPT2 = 0x2000
	// Position of D_NYETINTRPT2 field.
	USB_DIEPINT2_D_NYETINTRPT2_Pos = 0xe
	// Bit mask of D_NYETINTRPT2 field.
	USB_DIEPINT2_D_NYETINTRPT2_Msk = 0x4000
	// Bit D_NYETINTRPT2.
	USB_DIEPINT2_D_NYETINTRPT2 = 0x4000

	// DIEPTSIZ2
	// Position of D_XFERSIZE2 field.
	USB_DIEPTSIZ2_D_XFERSIZE2_Pos = 0x0
	// Bit mask of D_XFERSIZE2 field.
	USB_DIEPTSIZ2_D_XFERSIZE2_Msk = 0x7f
	// Position of D_PKTCNT2 field.
	USB_DIEPTSIZ2_D_PKTCNT2_Pos = 0x13
	// Bit mask of D_PKTCNT2 field.
	USB_DIEPTSIZ2_D_PKTCNT2_Msk = 0x180000

	// DIEPDMA2
	// Position of D_DMAADDR2 field.
	USB_DIEPDMA2_D_DMAADDR2_Pos = 0x0
	// Bit mask of D_DMAADDR2 field.
	USB_DIEPDMA2_D_DMAADDR2_Msk = 0xffffffff

	// DTXFSTS2
	// Position of D_INEPTXFSPCAVAIL2 field.
	USB_DTXFSTS2_D_INEPTXFSPCAVAIL2_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL2 field.
	USB_DTXFSTS2_D_INEPTXFSPCAVAIL2_Msk = 0xffff

	// DIEPDMAB2
	// Position of D_DMABUFFERADDR2 field.
	USB_DIEPDMAB2_D_DMABUFFERADDR2_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR2 field.
	USB_DIEPDMAB2_D_DMABUFFERADDR2_Msk = 0xffffffff

	// DIEPCTL3
	// Position of DI_MPS3 field.
	USB_DIEPCTL3_DI_MPS3_Pos = 0x0
	// Bit mask of DI_MPS3 field.
	USB_DIEPCTL3_DI_MPS3_Msk = 0x3
	// Position of DI_USBACTEP3 field.
	USB_DIEPCTL3_DI_USBACTEP3_Pos = 0xf
	// Bit mask of DI_USBACTEP3 field.
	USB_DIEPCTL3_DI_USBACTEP3_Msk = 0x8000
	// Bit DI_USBACTEP3.
	USB_DIEPCTL3_DI_USBACTEP3 = 0x8000
	// Position of DI_NAKSTS3 field.
	USB_DIEPCTL3_DI_NAKSTS3_Pos = 0x11
	// Bit mask of DI_NAKSTS3 field.
	USB_DIEPCTL3_DI_NAKSTS3_Msk = 0x20000
	// Bit DI_NAKSTS3.
	USB_DIEPCTL3_DI_NAKSTS3 = 0x20000
	// Position of DI_EPTYPE3 field.
	USB_DIEPCTL3_DI_EPTYPE3_Pos = 0x12
	// Bit mask of DI_EPTYPE3 field.
	USB_DIEPCTL3_DI_EPTYPE3_Msk = 0xc0000
	// Position of DI_STALL3 field.
	USB_DIEPCTL3_DI_STALL3_Pos = 0x15
	// Bit mask of DI_STALL3 field.
	USB_DIEPCTL3_DI_STALL3_Msk = 0x200000
	// Bit DI_STALL3.
	USB_DIEPCTL3_DI_STALL3 = 0x200000
	// Position of DI_TXFNUM3 field.
	USB_DIEPCTL3_DI_TXFNUM3_Pos = 0x16
	// Bit mask of DI_TXFNUM3 field.
	USB_DIEPCTL3_DI_TXFNUM3_Msk = 0x3c00000
	// Position of DI_CNAK3 field.
	USB_DIEPCTL3_DI_CNAK3_Pos = 0x1a
	// Bit mask of DI_CNAK3 field.
	USB_DIEPCTL3_DI_CNAK3_Msk = 0x4000000
	// Bit DI_CNAK3.
	USB_DIEPCTL3_DI_CNAK3 = 0x4000000
	// Position of DI_SNAK3 field.
	USB_DIEPCTL3_DI_SNAK3_Pos = 0x1b
	// Bit mask of DI_SNAK3 field.
	USB_DIEPCTL3_DI_SNAK3_Msk = 0x8000000
	// Bit DI_SNAK3.
	USB_DIEPCTL3_DI_SNAK3 = 0x8000000
	// Position of DI_SETD0PID3 field.
	USB_DIEPCTL3_DI_SETD0PID3_Pos = 0x1c
	// Bit mask of DI_SETD0PID3 field.
	USB_DIEPCTL3_DI_SETD0PID3_Msk = 0x10000000
	// Bit DI_SETD0PID3.
	USB_DIEPCTL3_DI_SETD0PID3 = 0x10000000
	// Position of DI_SETD1PID3 field.
	USB_DIEPCTL3_DI_SETD1PID3_Pos = 0x1d
	// Bit mask of DI_SETD1PID3 field.
	USB_DIEPCTL3_DI_SETD1PID3_Msk = 0x20000000
	// Bit DI_SETD1PID3.
	USB_DIEPCTL3_DI_SETD1PID3 = 0x20000000
	// Position of DI_EPDIS3 field.
	USB_DIEPCTL3_DI_EPDIS3_Pos = 0x1e
	// Bit mask of DI_EPDIS3 field.
	USB_DIEPCTL3_DI_EPDIS3_Msk = 0x40000000
	// Bit DI_EPDIS3.
	USB_DIEPCTL3_DI_EPDIS3 = 0x40000000
	// Position of DI_EPENA3 field.
	USB_DIEPCTL3_DI_EPENA3_Pos = 0x1f
	// Bit mask of DI_EPENA3 field.
	USB_DIEPCTL3_DI_EPENA3_Msk = 0x80000000
	// Bit DI_EPENA3.
	USB_DIEPCTL3_DI_EPENA3 = 0x80000000

	// DIEPINT3
	// Position of D_XFERCOMPL3 field.
	USB_DIEPINT3_D_XFERCOMPL3_Pos = 0x0
	// Bit mask of D_XFERCOMPL3 field.
	USB_DIEPINT3_D_XFERCOMPL3_Msk = 0x1
	// Bit D_XFERCOMPL3.
	USB_DIEPINT3_D_XFERCOMPL3 = 0x1
	// Position of D_EPDISBLD3 field.
	USB_DIEPINT3_D_EPDISBLD3_Pos = 0x1
	// Bit mask of D_EPDISBLD3 field.
	USB_DIEPINT3_D_EPDISBLD3_Msk = 0x2
	// Bit D_EPDISBLD3.
	USB_DIEPINT3_D_EPDISBLD3 = 0x2
	// Position of D_AHBERR3 field.
	USB_DIEPINT3_D_AHBERR3_Pos = 0x2
	// Bit mask of D_AHBERR3 field.
	USB_DIEPINT3_D_AHBERR3_Msk = 0x4
	// Bit D_AHBERR3.
	USB_DIEPINT3_D_AHBERR3 = 0x4
	// Position of D_TIMEOUT3 field.
	USB_DIEPINT3_D_TIMEOUT3_Pos = 0x3
	// Bit mask of D_TIMEOUT3 field.
	USB_DIEPINT3_D_TIMEOUT3_Msk = 0x8
	// Bit D_TIMEOUT3.
	USB_DIEPINT3_D_TIMEOUT3 = 0x8
	// Position of D_INTKNTXFEMP3 field.
	USB_DIEPINT3_D_INTKNTXFEMP3_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP3 field.
	USB_DIEPINT3_D_INTKNTXFEMP3_Msk = 0x10
	// Bit D_INTKNTXFEMP3.
	USB_DIEPINT3_D_INTKNTXFEMP3 = 0x10
	// Position of D_INTKNEPMIS3 field.
	USB_DIEPINT3_D_INTKNEPMIS3_Pos = 0x5
	// Bit mask of D_INTKNEPMIS3 field.
	USB_DIEPINT3_D_INTKNEPMIS3_Msk = 0x20
	// Bit D_INTKNEPMIS3.
	USB_DIEPINT3_D_INTKNEPMIS3 = 0x20
	// Position of D_INEPNAKEFF3 field.
	USB_DIEPINT3_D_INEPNAKEFF3_Pos = 0x6
	// Bit mask of D_INEPNAKEFF3 field.
	USB_DIEPINT3_D_INEPNAKEFF3_Msk = 0x40
	// Bit D_INEPNAKEFF3.
	USB_DIEPINT3_D_INEPNAKEFF3 = 0x40
	// Position of D_TXFEMP3 field.
	USB_DIEPINT3_D_TXFEMP3_Pos = 0x7
	// Bit mask of D_TXFEMP3 field.
	USB_DIEPINT3_D_TXFEMP3_Msk = 0x80
	// Bit D_TXFEMP3.
	USB_DIEPINT3_D_TXFEMP3 = 0x80
	// Position of D_TXFIFOUNDRN3 field.
	USB_DIEPINT3_D_TXFIFOUNDRN3_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN3 field.
	USB_DIEPINT3_D_TXFIFOUNDRN3_Msk = 0x100
	// Bit D_TXFIFOUNDRN3.
	USB_DIEPINT3_D_TXFIFOUNDRN3 = 0x100
	// Position of D_BNAINTR3 field.
	USB_DIEPINT3_D_BNAINTR3_Pos = 0x9
	// Bit mask of D_BNAINTR3 field.
	USB_DIEPINT3_D_BNAINTR3_Msk = 0x200
	// Bit D_BNAINTR3.
	USB_DIEPINT3_D_BNAINTR3 = 0x200
	// Position of D_PKTDRPSTS3 field.
	USB_DIEPINT3_D_PKTDRPSTS3_Pos = 0xb
	// Bit mask of D_PKTDRPSTS3 field.
	USB_DIEPINT3_D_PKTDRPSTS3_Msk = 0x800
	// Bit D_PKTDRPSTS3.
	USB_DIEPINT3_D_PKTDRPSTS3 = 0x800
	// Position of D_BBLEERR3 field.
	USB_DIEPINT3_D_BBLEERR3_Pos = 0xc
	// Bit mask of D_BBLEERR3 field.
	USB_DIEPINT3_D_BBLEERR3_Msk = 0x1000
	// Bit D_BBLEERR3.
	USB_DIEPINT3_D_BBLEERR3 = 0x1000
	// Position of D_NAKINTRPT3 field.
	USB_DIEPINT3_D_NAKINTRPT3_Pos = 0xd
	// Bit mask of D_NAKINTRPT3 field.
	USB_DIEPINT3_D_NAKINTRPT3_Msk = 0x2000
	// Bit D_NAKINTRPT3.
	USB_DIEPINT3_D_NAKINTRPT3 = 0x2000
	// Position of D_NYETINTRPT3 field.
	USB_DIEPINT3_D_NYETINTRPT3_Pos = 0xe
	// Bit mask of D_NYETINTRPT3 field.
	USB_DIEPINT3_D_NYETINTRPT3_Msk = 0x4000
	// Bit D_NYETINTRPT3.
	USB_DIEPINT3_D_NYETINTRPT3 = 0x4000

	// DIEPTSIZ3
	// Position of D_XFERSIZE3 field.
	USB_DIEPTSIZ3_D_XFERSIZE3_Pos = 0x0
	// Bit mask of D_XFERSIZE3 field.
	USB_DIEPTSIZ3_D_XFERSIZE3_Msk = 0x7f
	// Position of D_PKTCNT3 field.
	USB_DIEPTSIZ3_D_PKTCNT3_Pos = 0x13
	// Bit mask of D_PKTCNT3 field.
	USB_DIEPTSIZ3_D_PKTCNT3_Msk = 0x180000

	// DIEPDMA3
	// Position of D_DMAADDR3 field.
	USB_DIEPDMA3_D_DMAADDR3_Pos = 0x0
	// Bit mask of D_DMAADDR3 field.
	USB_DIEPDMA3_D_DMAADDR3_Msk = 0xffffffff

	// DTXFSTS3
	// Position of D_INEPTXFSPCAVAIL3 field.
	USB_DTXFSTS3_D_INEPTXFSPCAVAIL3_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL3 field.
	USB_DTXFSTS3_D_INEPTXFSPCAVAIL3_Msk = 0xffff

	// DIEPDMAB3
	// Position of D_DMABUFFERADDR3 field.
	USB_DIEPDMAB3_D_DMABUFFERADDR3_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR3 field.
	USB_DIEPDMAB3_D_DMABUFFERADDR3_Msk = 0xffffffff

	// DIEPCTL4
	// Position of D_MPS4 field.
	USB_DIEPCTL4_D_MPS4_Pos = 0x0
	// Bit mask of D_MPS4 field.
	USB_DIEPCTL4_D_MPS4_Msk = 0x3
	// Position of D_USBACTEP4 field.
	USB_DIEPCTL4_D_USBACTEP4_Pos = 0xf
	// Bit mask of D_USBACTEP4 field.
	USB_DIEPCTL4_D_USBACTEP4_Msk = 0x8000
	// Bit D_USBACTEP4.
	USB_DIEPCTL4_D_USBACTEP4 = 0x8000
	// Position of D_NAKSTS4 field.
	USB_DIEPCTL4_D_NAKSTS4_Pos = 0x11
	// Bit mask of D_NAKSTS4 field.
	USB_DIEPCTL4_D_NAKSTS4_Msk = 0x20000
	// Bit D_NAKSTS4.
	USB_DIEPCTL4_D_NAKSTS4 = 0x20000
	// Position of D_EPTYPE4 field.
	USB_DIEPCTL4_D_EPTYPE4_Pos = 0x12
	// Bit mask of D_EPTYPE4 field.
	USB_DIEPCTL4_D_EPTYPE4_Msk = 0xc0000
	// Position of D_STALL4 field.
	USB_DIEPCTL4_D_STALL4_Pos = 0x15
	// Bit mask of D_STALL4 field.
	USB_DIEPCTL4_D_STALL4_Msk = 0x200000
	// Bit D_STALL4.
	USB_DIEPCTL4_D_STALL4 = 0x200000
	// Position of D_TXFNUM4 field.
	USB_DIEPCTL4_D_TXFNUM4_Pos = 0x16
	// Bit mask of D_TXFNUM4 field.
	USB_DIEPCTL4_D_TXFNUM4_Msk = 0x3c00000
	// Position of D_CNAK4 field.
	USB_DIEPCTL4_D_CNAK4_Pos = 0x1a
	// Bit mask of D_CNAK4 field.
	USB_DIEPCTL4_D_CNAK4_Msk = 0x4000000
	// Bit D_CNAK4.
	USB_DIEPCTL4_D_CNAK4 = 0x4000000
	// Position of DI_SNAK4 field.
	USB_DIEPCTL4_DI_SNAK4_Pos = 0x1b
	// Bit mask of DI_SNAK4 field.
	USB_DIEPCTL4_DI_SNAK4_Msk = 0x8000000
	// Bit DI_SNAK4.
	USB_DIEPCTL4_DI_SNAK4 = 0x8000000
	// Position of DI_SETD0PID4 field.
	USB_DIEPCTL4_DI_SETD0PID4_Pos = 0x1c
	// Bit mask of DI_SETD0PID4 field.
	USB_DIEPCTL4_DI_SETD0PID4_Msk = 0x10000000
	// Bit DI_SETD0PID4.
	USB_DIEPCTL4_DI_SETD0PID4 = 0x10000000
	// Position of DI_SETD1PID4 field.
	USB_DIEPCTL4_DI_SETD1PID4_Pos = 0x1d
	// Bit mask of DI_SETD1PID4 field.
	USB_DIEPCTL4_DI_SETD1PID4_Msk = 0x20000000
	// Bit DI_SETD1PID4.
	USB_DIEPCTL4_DI_SETD1PID4 = 0x20000000
	// Position of D_EPDIS4 field.
	USB_DIEPCTL4_D_EPDIS4_Pos = 0x1e
	// Bit mask of D_EPDIS4 field.
	USB_DIEPCTL4_D_EPDIS4_Msk = 0x40000000
	// Bit D_EPDIS4.
	USB_DIEPCTL4_D_EPDIS4 = 0x40000000
	// Position of D_EPENA4 field.
	USB_DIEPCTL4_D_EPENA4_Pos = 0x1f
	// Bit mask of D_EPENA4 field.
	USB_DIEPCTL4_D_EPENA4_Msk = 0x80000000
	// Bit D_EPENA4.
	USB_DIEPCTL4_D_EPENA4 = 0x80000000

	// DIEPINT4
	// Position of D_XFERCOMPL4 field.
	USB_DIEPINT4_D_XFERCOMPL4_Pos = 0x0
	// Bit mask of D_XFERCOMPL4 field.
	USB_DIEPINT4_D_XFERCOMPL4_Msk = 0x1
	// Bit D_XFERCOMPL4.
	USB_DIEPINT4_D_XFERCOMPL4 = 0x1
	// Position of D_EPDISBLD4 field.
	USB_DIEPINT4_D_EPDISBLD4_Pos = 0x1
	// Bit mask of D_EPDISBLD4 field.
	USB_DIEPINT4_D_EPDISBLD4_Msk = 0x2
	// Bit D_EPDISBLD4.
	USB_DIEPINT4_D_EPDISBLD4 = 0x2
	// Position of D_AHBERR4 field.
	USB_DIEPINT4_D_AHBERR4_Pos = 0x2
	// Bit mask of D_AHBERR4 field.
	USB_DIEPINT4_D_AHBERR4_Msk = 0x4
	// Bit D_AHBERR4.
	USB_DIEPINT4_D_AHBERR4 = 0x4
	// Position of D_TIMEOUT4 field.
	USB_DIEPINT4_D_TIMEOUT4_Pos = 0x3
	// Bit mask of D_TIMEOUT4 field.
	USB_DIEPINT4_D_TIMEOUT4_Msk = 0x8
	// Bit D_TIMEOUT4.
	USB_DIEPINT4_D_TIMEOUT4 = 0x8
	// Position of D_INTKNTXFEMP4 field.
	USB_DIEPINT4_D_INTKNTXFEMP4_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP4 field.
	USB_DIEPINT4_D_INTKNTXFEMP4_Msk = 0x10
	// Bit D_INTKNTXFEMP4.
	USB_DIEPINT4_D_INTKNTXFEMP4 = 0x10
	// Position of D_INTKNEPMIS4 field.
	USB_DIEPINT4_D_INTKNEPMIS4_Pos = 0x5
	// Bit mask of D_INTKNEPMIS4 field.
	USB_DIEPINT4_D_INTKNEPMIS4_Msk = 0x20
	// Bit D_INTKNEPMIS4.
	USB_DIEPINT4_D_INTKNEPMIS4 = 0x20
	// Position of D_INEPNAKEFF4 field.
	USB_DIEPINT4_D_INEPNAKEFF4_Pos = 0x6
	// Bit mask of D_INEPNAKEFF4 field.
	USB_DIEPINT4_D_INEPNAKEFF4_Msk = 0x40
	// Bit D_INEPNAKEFF4.
	USB_DIEPINT4_D_INEPNAKEFF4 = 0x40
	// Position of D_TXFEMP4 field.
	USB_DIEPINT4_D_TXFEMP4_Pos = 0x7
	// Bit mask of D_TXFEMP4 field.
	USB_DIEPINT4_D_TXFEMP4_Msk = 0x80
	// Bit D_TXFEMP4.
	USB_DIEPINT4_D_TXFEMP4 = 0x80
	// Position of D_TXFIFOUNDRN4 field.
	USB_DIEPINT4_D_TXFIFOUNDRN4_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN4 field.
	USB_DIEPINT4_D_TXFIFOUNDRN4_Msk = 0x100
	// Bit D_TXFIFOUNDRN4.
	USB_DIEPINT4_D_TXFIFOUNDRN4 = 0x100
	// Position of D_BNAINTR4 field.
	USB_DIEPINT4_D_BNAINTR4_Pos = 0x9
	// Bit mask of D_BNAINTR4 field.
	USB_DIEPINT4_D_BNAINTR4_Msk = 0x200
	// Bit D_BNAINTR4.
	USB_DIEPINT4_D_BNAINTR4 = 0x200
	// Position of D_PKTDRPSTS4 field.
	USB_DIEPINT4_D_PKTDRPSTS4_Pos = 0xb
	// Bit mask of D_PKTDRPSTS4 field.
	USB_DIEPINT4_D_PKTDRPSTS4_Msk = 0x800
	// Bit D_PKTDRPSTS4.
	USB_DIEPINT4_D_PKTDRPSTS4 = 0x800
	// Position of D_BBLEERR4 field.
	USB_DIEPINT4_D_BBLEERR4_Pos = 0xc
	// Bit mask of D_BBLEERR4 field.
	USB_DIEPINT4_D_BBLEERR4_Msk = 0x1000
	// Bit D_BBLEERR4.
	USB_DIEPINT4_D_BBLEERR4 = 0x1000
	// Position of D_NAKINTRPT4 field.
	USB_DIEPINT4_D_NAKINTRPT4_Pos = 0xd
	// Bit mask of D_NAKINTRPT4 field.
	USB_DIEPINT4_D_NAKINTRPT4_Msk = 0x2000
	// Bit D_NAKINTRPT4.
	USB_DIEPINT4_D_NAKINTRPT4 = 0x2000
	// Position of D_NYETINTRPT4 field.
	USB_DIEPINT4_D_NYETINTRPT4_Pos = 0xe
	// Bit mask of D_NYETINTRPT4 field.
	USB_DIEPINT4_D_NYETINTRPT4_Msk = 0x4000
	// Bit D_NYETINTRPT4.
	USB_DIEPINT4_D_NYETINTRPT4 = 0x4000

	// DIEPTSIZ4
	// Position of D_XFERSIZE4 field.
	USB_DIEPTSIZ4_D_XFERSIZE4_Pos = 0x0
	// Bit mask of D_XFERSIZE4 field.
	USB_DIEPTSIZ4_D_XFERSIZE4_Msk = 0x7f
	// Position of D_PKTCNT4 field.
	USB_DIEPTSIZ4_D_PKTCNT4_Pos = 0x13
	// Bit mask of D_PKTCNT4 field.
	USB_DIEPTSIZ4_D_PKTCNT4_Msk = 0x180000

	// DIEPDMA4
	// Position of D_DMAADDR4 field.
	USB_DIEPDMA4_D_DMAADDR4_Pos = 0x0
	// Bit mask of D_DMAADDR4 field.
	USB_DIEPDMA4_D_DMAADDR4_Msk = 0xffffffff

	// DTXFSTS4
	// Position of D_INEPTXFSPCAVAIL4 field.
	USB_DTXFSTS4_D_INEPTXFSPCAVAIL4_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL4 field.
	USB_DTXFSTS4_D_INEPTXFSPCAVAIL4_Msk = 0xffff

	// DIEPDMAB4
	// Position of D_DMABUFFERADDR4 field.
	USB_DIEPDMAB4_D_DMABUFFERADDR4_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR4 field.
	USB_DIEPDMAB4_D_DMABUFFERADDR4_Msk = 0xffffffff

	// DIEPCTL5
	// Position of DI_MPS5 field.
	USB_DIEPCTL5_DI_MPS5_Pos = 0x0
	// Bit mask of DI_MPS5 field.
	USB_DIEPCTL5_DI_MPS5_Msk = 0x3
	// Position of DI_USBACTEP5 field.
	USB_DIEPCTL5_DI_USBACTEP5_Pos = 0xf
	// Bit mask of DI_USBACTEP5 field.
	USB_DIEPCTL5_DI_USBACTEP5_Msk = 0x8000
	// Bit DI_USBACTEP5.
	USB_DIEPCTL5_DI_USBACTEP5 = 0x8000
	// Position of DI_NAKSTS5 field.
	USB_DIEPCTL5_DI_NAKSTS5_Pos = 0x11
	// Bit mask of DI_NAKSTS5 field.
	USB_DIEPCTL5_DI_NAKSTS5_Msk = 0x20000
	// Bit DI_NAKSTS5.
	USB_DIEPCTL5_DI_NAKSTS5 = 0x20000
	// Position of DI_EPTYPE5 field.
	USB_DIEPCTL5_DI_EPTYPE5_Pos = 0x12
	// Bit mask of DI_EPTYPE5 field.
	USB_DIEPCTL5_DI_EPTYPE5_Msk = 0xc0000
	// Position of DI_STALL5 field.
	USB_DIEPCTL5_DI_STALL5_Pos = 0x15
	// Bit mask of DI_STALL5 field.
	USB_DIEPCTL5_DI_STALL5_Msk = 0x200000
	// Bit DI_STALL5.
	USB_DIEPCTL5_DI_STALL5 = 0x200000
	// Position of DI_TXFNUM5 field.
	USB_DIEPCTL5_DI_TXFNUM5_Pos = 0x16
	// Bit mask of DI_TXFNUM5 field.
	USB_DIEPCTL5_DI_TXFNUM5_Msk = 0x3c00000
	// Position of DI_CNAK5 field.
	USB_DIEPCTL5_DI_CNAK5_Pos = 0x1a
	// Bit mask of DI_CNAK5 field.
	USB_DIEPCTL5_DI_CNAK5_Msk = 0x4000000
	// Bit DI_CNAK5.
	USB_DIEPCTL5_DI_CNAK5 = 0x4000000
	// Position of DI_SNAK5 field.
	USB_DIEPCTL5_DI_SNAK5_Pos = 0x1b
	// Bit mask of DI_SNAK5 field.
	USB_DIEPCTL5_DI_SNAK5_Msk = 0x8000000
	// Bit DI_SNAK5.
	USB_DIEPCTL5_DI_SNAK5 = 0x8000000
	// Position of DI_SETD0PID5 field.
	USB_DIEPCTL5_DI_SETD0PID5_Pos = 0x1c
	// Bit mask of DI_SETD0PID5 field.
	USB_DIEPCTL5_DI_SETD0PID5_Msk = 0x10000000
	// Bit DI_SETD0PID5.
	USB_DIEPCTL5_DI_SETD0PID5 = 0x10000000
	// Position of DI_SETD1PID5 field.
	USB_DIEPCTL5_DI_SETD1PID5_Pos = 0x1d
	// Bit mask of DI_SETD1PID5 field.
	USB_DIEPCTL5_DI_SETD1PID5_Msk = 0x20000000
	// Bit DI_SETD1PID5.
	USB_DIEPCTL5_DI_SETD1PID5 = 0x20000000
	// Position of DI_EPDIS5 field.
	USB_DIEPCTL5_DI_EPDIS5_Pos = 0x1e
	// Bit mask of DI_EPDIS5 field.
	USB_DIEPCTL5_DI_EPDIS5_Msk = 0x40000000
	// Bit DI_EPDIS5.
	USB_DIEPCTL5_DI_EPDIS5 = 0x40000000
	// Position of DI_EPENA5 field.
	USB_DIEPCTL5_DI_EPENA5_Pos = 0x1f
	// Bit mask of DI_EPENA5 field.
	USB_DIEPCTL5_DI_EPENA5_Msk = 0x80000000
	// Bit DI_EPENA5.
	USB_DIEPCTL5_DI_EPENA5 = 0x80000000

	// DIEPINT5
	// Position of D_XFERCOMPL5 field.
	USB_DIEPINT5_D_XFERCOMPL5_Pos = 0x0
	// Bit mask of D_XFERCOMPL5 field.
	USB_DIEPINT5_D_XFERCOMPL5_Msk = 0x1
	// Bit D_XFERCOMPL5.
	USB_DIEPINT5_D_XFERCOMPL5 = 0x1
	// Position of D_EPDISBLD5 field.
	USB_DIEPINT5_D_EPDISBLD5_Pos = 0x1
	// Bit mask of D_EPDISBLD5 field.
	USB_DIEPINT5_D_EPDISBLD5_Msk = 0x2
	// Bit D_EPDISBLD5.
	USB_DIEPINT5_D_EPDISBLD5 = 0x2
	// Position of D_AHBERR5 field.
	USB_DIEPINT5_D_AHBERR5_Pos = 0x2
	// Bit mask of D_AHBERR5 field.
	USB_DIEPINT5_D_AHBERR5_Msk = 0x4
	// Bit D_AHBERR5.
	USB_DIEPINT5_D_AHBERR5 = 0x4
	// Position of D_TIMEOUT5 field.
	USB_DIEPINT5_D_TIMEOUT5_Pos = 0x3
	// Bit mask of D_TIMEOUT5 field.
	USB_DIEPINT5_D_TIMEOUT5_Msk = 0x8
	// Bit D_TIMEOUT5.
	USB_DIEPINT5_D_TIMEOUT5 = 0x8
	// Position of D_INTKNTXFEMP5 field.
	USB_DIEPINT5_D_INTKNTXFEMP5_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP5 field.
	USB_DIEPINT5_D_INTKNTXFEMP5_Msk = 0x10
	// Bit D_INTKNTXFEMP5.
	USB_DIEPINT5_D_INTKNTXFEMP5 = 0x10
	// Position of D_INTKNEPMIS5 field.
	USB_DIEPINT5_D_INTKNEPMIS5_Pos = 0x5
	// Bit mask of D_INTKNEPMIS5 field.
	USB_DIEPINT5_D_INTKNEPMIS5_Msk = 0x20
	// Bit D_INTKNEPMIS5.
	USB_DIEPINT5_D_INTKNEPMIS5 = 0x20
	// Position of D_INEPNAKEFF5 field.
	USB_DIEPINT5_D_INEPNAKEFF5_Pos = 0x6
	// Bit mask of D_INEPNAKEFF5 field.
	USB_DIEPINT5_D_INEPNAKEFF5_Msk = 0x40
	// Bit D_INEPNAKEFF5.
	USB_DIEPINT5_D_INEPNAKEFF5 = 0x40
	// Position of D_TXFEMP5 field.
	USB_DIEPINT5_D_TXFEMP5_Pos = 0x7
	// Bit mask of D_TXFEMP5 field.
	USB_DIEPINT5_D_TXFEMP5_Msk = 0x80
	// Bit D_TXFEMP5.
	USB_DIEPINT5_D_TXFEMP5 = 0x80
	// Position of D_TXFIFOUNDRN5 field.
	USB_DIEPINT5_D_TXFIFOUNDRN5_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN5 field.
	USB_DIEPINT5_D_TXFIFOUNDRN5_Msk = 0x100
	// Bit D_TXFIFOUNDRN5.
	USB_DIEPINT5_D_TXFIFOUNDRN5 = 0x100
	// Position of D_BNAINTR5 field.
	USB_DIEPINT5_D_BNAINTR5_Pos = 0x9
	// Bit mask of D_BNAINTR5 field.
	USB_DIEPINT5_D_BNAINTR5_Msk = 0x200
	// Bit D_BNAINTR5.
	USB_DIEPINT5_D_BNAINTR5 = 0x200
	// Position of D_PKTDRPSTS5 field.
	USB_DIEPINT5_D_PKTDRPSTS5_Pos = 0xb
	// Bit mask of D_PKTDRPSTS5 field.
	USB_DIEPINT5_D_PKTDRPSTS5_Msk = 0x800
	// Bit D_PKTDRPSTS5.
	USB_DIEPINT5_D_PKTDRPSTS5 = 0x800
	// Position of D_BBLEERR5 field.
	USB_DIEPINT5_D_BBLEERR5_Pos = 0xc
	// Bit mask of D_BBLEERR5 field.
	USB_DIEPINT5_D_BBLEERR5_Msk = 0x1000
	// Bit D_BBLEERR5.
	USB_DIEPINT5_D_BBLEERR5 = 0x1000
	// Position of D_NAKINTRPT5 field.
	USB_DIEPINT5_D_NAKINTRPT5_Pos = 0xd
	// Bit mask of D_NAKINTRPT5 field.
	USB_DIEPINT5_D_NAKINTRPT5_Msk = 0x2000
	// Bit D_NAKINTRPT5.
	USB_DIEPINT5_D_NAKINTRPT5 = 0x2000
	// Position of D_NYETINTRPT5 field.
	USB_DIEPINT5_D_NYETINTRPT5_Pos = 0xe
	// Bit mask of D_NYETINTRPT5 field.
	USB_DIEPINT5_D_NYETINTRPT5_Msk = 0x4000
	// Bit D_NYETINTRPT5.
	USB_DIEPINT5_D_NYETINTRPT5 = 0x4000

	// DIEPTSIZ5
	// Position of D_XFERSIZE5 field.
	USB_DIEPTSIZ5_D_XFERSIZE5_Pos = 0x0
	// Bit mask of D_XFERSIZE5 field.
	USB_DIEPTSIZ5_D_XFERSIZE5_Msk = 0x7f
	// Position of D_PKTCNT5 field.
	USB_DIEPTSIZ5_D_PKTCNT5_Pos = 0x13
	// Bit mask of D_PKTCNT5 field.
	USB_DIEPTSIZ5_D_PKTCNT5_Msk = 0x180000

	// DIEPDMA5
	// Position of D_DMAADDR5 field.
	USB_DIEPDMA5_D_DMAADDR5_Pos = 0x0
	// Bit mask of D_DMAADDR5 field.
	USB_DIEPDMA5_D_DMAADDR5_Msk = 0xffffffff

	// DTXFSTS5
	// Position of D_INEPTXFSPCAVAIL5 field.
	USB_DTXFSTS5_D_INEPTXFSPCAVAIL5_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL5 field.
	USB_DTXFSTS5_D_INEPTXFSPCAVAIL5_Msk = 0xffff

	// DIEPDMAB5
	// Position of D_DMABUFFERADDR5 field.
	USB_DIEPDMAB5_D_DMABUFFERADDR5_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR5 field.
	USB_DIEPDMAB5_D_DMABUFFERADDR5_Msk = 0xffffffff

	// DIEPCTL6
	// Position of D_MPS6 field.
	USB_DIEPCTL6_D_MPS6_Pos = 0x0
	// Bit mask of D_MPS6 field.
	USB_DIEPCTL6_D_MPS6_Msk = 0x3
	// Position of D_USBACTEP6 field.
	USB_DIEPCTL6_D_USBACTEP6_Pos = 0xf
	// Bit mask of D_USBACTEP6 field.
	USB_DIEPCTL6_D_USBACTEP6_Msk = 0x8000
	// Bit D_USBACTEP6.
	USB_DIEPCTL6_D_USBACTEP6 = 0x8000
	// Position of D_NAKSTS6 field.
	USB_DIEPCTL6_D_NAKSTS6_Pos = 0x11
	// Bit mask of D_NAKSTS6 field.
	USB_DIEPCTL6_D_NAKSTS6_Msk = 0x20000
	// Bit D_NAKSTS6.
	USB_DIEPCTL6_D_NAKSTS6 = 0x20000
	// Position of D_EPTYPE6 field.
	USB_DIEPCTL6_D_EPTYPE6_Pos = 0x12
	// Bit mask of D_EPTYPE6 field.
	USB_DIEPCTL6_D_EPTYPE6_Msk = 0xc0000
	// Position of D_STALL6 field.
	USB_DIEPCTL6_D_STALL6_Pos = 0x15
	// Bit mask of D_STALL6 field.
	USB_DIEPCTL6_D_STALL6_Msk = 0x200000
	// Bit D_STALL6.
	USB_DIEPCTL6_D_STALL6 = 0x200000
	// Position of D_TXFNUM6 field.
	USB_DIEPCTL6_D_TXFNUM6_Pos = 0x16
	// Bit mask of D_TXFNUM6 field.
	USB_DIEPCTL6_D_TXFNUM6_Msk = 0x3c00000
	// Position of D_CNAK6 field.
	USB_DIEPCTL6_D_CNAK6_Pos = 0x1a
	// Bit mask of D_CNAK6 field.
	USB_DIEPCTL6_D_CNAK6_Msk = 0x4000000
	// Bit D_CNAK6.
	USB_DIEPCTL6_D_CNAK6 = 0x4000000
	// Position of DI_SNAK6 field.
	USB_DIEPCTL6_DI_SNAK6_Pos = 0x1b
	// Bit mask of DI_SNAK6 field.
	USB_DIEPCTL6_DI_SNAK6_Msk = 0x8000000
	// Bit DI_SNAK6.
	USB_DIEPCTL6_DI_SNAK6 = 0x8000000
	// Position of DI_SETD0PID6 field.
	USB_DIEPCTL6_DI_SETD0PID6_Pos = 0x1c
	// Bit mask of DI_SETD0PID6 field.
	USB_DIEPCTL6_DI_SETD0PID6_Msk = 0x10000000
	// Bit DI_SETD0PID6.
	USB_DIEPCTL6_DI_SETD0PID6 = 0x10000000
	// Position of DI_SETD1PID6 field.
	USB_DIEPCTL6_DI_SETD1PID6_Pos = 0x1d
	// Bit mask of DI_SETD1PID6 field.
	USB_DIEPCTL6_DI_SETD1PID6_Msk = 0x20000000
	// Bit DI_SETD1PID6.
	USB_DIEPCTL6_DI_SETD1PID6 = 0x20000000
	// Position of D_EPDIS6 field.
	USB_DIEPCTL6_D_EPDIS6_Pos = 0x1e
	// Bit mask of D_EPDIS6 field.
	USB_DIEPCTL6_D_EPDIS6_Msk = 0x40000000
	// Bit D_EPDIS6.
	USB_DIEPCTL6_D_EPDIS6 = 0x40000000
	// Position of D_EPENA6 field.
	USB_DIEPCTL6_D_EPENA6_Pos = 0x1f
	// Bit mask of D_EPENA6 field.
	USB_DIEPCTL6_D_EPENA6_Msk = 0x80000000
	// Bit D_EPENA6.
	USB_DIEPCTL6_D_EPENA6 = 0x80000000

	// DIEPINT6
	// Position of D_XFERCOMPL6 field.
	USB_DIEPINT6_D_XFERCOMPL6_Pos = 0x0
	// Bit mask of D_XFERCOMPL6 field.
	USB_DIEPINT6_D_XFERCOMPL6_Msk = 0x1
	// Bit D_XFERCOMPL6.
	USB_DIEPINT6_D_XFERCOMPL6 = 0x1
	// Position of D_EPDISBLD6 field.
	USB_DIEPINT6_D_EPDISBLD6_Pos = 0x1
	// Bit mask of D_EPDISBLD6 field.
	USB_DIEPINT6_D_EPDISBLD6_Msk = 0x2
	// Bit D_EPDISBLD6.
	USB_DIEPINT6_D_EPDISBLD6 = 0x2
	// Position of D_AHBERR6 field.
	USB_DIEPINT6_D_AHBERR6_Pos = 0x2
	// Bit mask of D_AHBERR6 field.
	USB_DIEPINT6_D_AHBERR6_Msk = 0x4
	// Bit D_AHBERR6.
	USB_DIEPINT6_D_AHBERR6 = 0x4
	// Position of D_TIMEOUT6 field.
	USB_DIEPINT6_D_TIMEOUT6_Pos = 0x3
	// Bit mask of D_TIMEOUT6 field.
	USB_DIEPINT6_D_TIMEOUT6_Msk = 0x8
	// Bit D_TIMEOUT6.
	USB_DIEPINT6_D_TIMEOUT6 = 0x8
	// Position of D_INTKNTXFEMP6 field.
	USB_DIEPINT6_D_INTKNTXFEMP6_Pos = 0x4
	// Bit mask of D_INTKNTXFEMP6 field.
	USB_DIEPINT6_D_INTKNTXFEMP6_Msk = 0x10
	// Bit D_INTKNTXFEMP6.
	USB_DIEPINT6_D_INTKNTXFEMP6 = 0x10
	// Position of D_INTKNEPMIS6 field.
	USB_DIEPINT6_D_INTKNEPMIS6_Pos = 0x5
	// Bit mask of D_INTKNEPMIS6 field.
	USB_DIEPINT6_D_INTKNEPMIS6_Msk = 0x20
	// Bit D_INTKNEPMIS6.
	USB_DIEPINT6_D_INTKNEPMIS6 = 0x20
	// Position of D_INEPNAKEFF6 field.
	USB_DIEPINT6_D_INEPNAKEFF6_Pos = 0x6
	// Bit mask of D_INEPNAKEFF6 field.
	USB_DIEPINT6_D_INEPNAKEFF6_Msk = 0x40
	// Bit D_INEPNAKEFF6.
	USB_DIEPINT6_D_INEPNAKEFF6 = 0x40
	// Position of D_TXFEMP6 field.
	USB_DIEPINT6_D_TXFEMP6_Pos = 0x7
	// Bit mask of D_TXFEMP6 field.
	USB_DIEPINT6_D_TXFEMP6_Msk = 0x80
	// Bit D_TXFEMP6.
	USB_DIEPINT6_D_TXFEMP6 = 0x80
	// Position of D_TXFIFOUNDRN6 field.
	USB_DIEPINT6_D_TXFIFOUNDRN6_Pos = 0x8
	// Bit mask of D_TXFIFOUNDRN6 field.
	USB_DIEPINT6_D_TXFIFOUNDRN6_Msk = 0x100
	// Bit D_TXFIFOUNDRN6.
	USB_DIEPINT6_D_TXFIFOUNDRN6 = 0x100
	// Position of D_BNAINTR6 field.
	USB_DIEPINT6_D_BNAINTR6_Pos = 0x9
	// Bit mask of D_BNAINTR6 field.
	USB_DIEPINT6_D_BNAINTR6_Msk = 0x200
	// Bit D_BNAINTR6.
	USB_DIEPINT6_D_BNAINTR6 = 0x200
	// Position of D_PKTDRPSTS6 field.
	USB_DIEPINT6_D_PKTDRPSTS6_Pos = 0xb
	// Bit mask of D_PKTDRPSTS6 field.
	USB_DIEPINT6_D_PKTDRPSTS6_Msk = 0x800
	// Bit D_PKTDRPSTS6.
	USB_DIEPINT6_D_PKTDRPSTS6 = 0x800
	// Position of D_BBLEERR6 field.
	USB_DIEPINT6_D_BBLEERR6_Pos = 0xc
	// Bit mask of D_BBLEERR6 field.
	USB_DIEPINT6_D_BBLEERR6_Msk = 0x1000
	// Bit D_BBLEERR6.
	USB_DIEPINT6_D_BBLEERR6 = 0x1000
	// Position of D_NAKINTRPT6 field.
	USB_DIEPINT6_D_NAKINTRPT6_Pos = 0xd
	// Bit mask of D_NAKINTRPT6 field.
	USB_DIEPINT6_D_NAKINTRPT6_Msk = 0x2000
	// Bit D_NAKINTRPT6.
	USB_DIEPINT6_D_NAKINTRPT6 = 0x2000
	// Position of D_NYETINTRPT6 field.
	USB_DIEPINT6_D_NYETINTRPT6_Pos = 0xe
	// Bit mask of D_NYETINTRPT6 field.
	USB_DIEPINT6_D_NYETINTRPT6_Msk = 0x4000
	// Bit D_NYETINTRPT6.
	USB_DIEPINT6_D_NYETINTRPT6 = 0x4000

	// DIEPTSIZ6
	// Position of D_XFERSIZE6 field.
	USB_DIEPTSIZ6_D_XFERSIZE6_Pos = 0x0
	// Bit mask of D_XFERSIZE6 field.
	USB_DIEPTSIZ6_D_XFERSIZE6_Msk = 0x7f
	// Position of D_PKTCNT6 field.
	USB_DIEPTSIZ6_D_PKTCNT6_Pos = 0x13
	// Bit mask of D_PKTCNT6 field.
	USB_DIEPTSIZ6_D_PKTCNT6_Msk = 0x180000

	// DIEPDMA6
	// Position of D_DMAADDR6 field.
	USB_DIEPDMA6_D_DMAADDR6_Pos = 0x0
	// Bit mask of D_DMAADDR6 field.
	USB_DIEPDMA6_D_DMAADDR6_Msk = 0xffffffff

	// DTXFSTS6
	// Position of D_INEPTXFSPCAVAIL6 field.
	USB_DTXFSTS6_D_INEPTXFSPCAVAIL6_Pos = 0x0
	// Bit mask of D_INEPTXFSPCAVAIL6 field.
	USB_DTXFSTS6_D_INEPTXFSPCAVAIL6_Msk = 0xffff

	// DIEPDMAB6
	// Position of D_DMABUFFERADDR6 field.
	USB_DIEPDMAB6_D_DMABUFFERADDR6_Pos = 0x0
	// Bit mask of D_DMABUFFERADDR6 field.
	USB_DIEPDMAB6_D_DMABUFFERADDR6_Msk = 0xffffffff

	// DOEPCTL0
	// Position of MPS0 field.
	USB_DOEPCTL0_MPS0_Pos = 0x0
	// Bit mask of MPS0 field.
	USB_DOEPCTL0_MPS0_Msk = 0x3
	// Position of USBACTEP0 field.
	USB_DOEPCTL0_USBACTEP0_Pos = 0xf
	// Bit mask of USBACTEP0 field.
	USB_DOEPCTL0_USBACTEP0_Msk = 0x8000
	// Bit USBACTEP0.
	USB_DOEPCTL0_USBACTEP0 = 0x8000
	// Position of NAKSTS0 field.
	USB_DOEPCTL0_NAKSTS0_Pos = 0x11
	// Bit mask of NAKSTS0 field.
	USB_DOEPCTL0_NAKSTS0_Msk = 0x20000
	// Bit NAKSTS0.
	USB_DOEPCTL0_NAKSTS0 = 0x20000
	// Position of EPTYPE0 field.
	USB_DOEPCTL0_EPTYPE0_Pos = 0x12
	// Bit mask of EPTYPE0 field.
	USB_DOEPCTL0_EPTYPE0_Msk = 0xc0000
	// Position of SNP0 field.
	USB_DOEPCTL0_SNP0_Pos = 0x14
	// Bit mask of SNP0 field.
	USB_DOEPCTL0_SNP0_Msk = 0x100000
	// Bit SNP0.
	USB_DOEPCTL0_SNP0 = 0x100000
	// Position of STALL0 field.
	USB_DOEPCTL0_STALL0_Pos = 0x15
	// Bit mask of STALL0 field.
	USB_DOEPCTL0_STALL0_Msk = 0x200000
	// Bit STALL0.
	USB_DOEPCTL0_STALL0 = 0x200000
	// Position of CNAK0 field.
	USB_DOEPCTL0_CNAK0_Pos = 0x1a
	// Bit mask of CNAK0 field.
	USB_DOEPCTL0_CNAK0_Msk = 0x4000000
	// Bit CNAK0.
	USB_DOEPCTL0_CNAK0 = 0x4000000
	// Position of DO_SNAK0 field.
	USB_DOEPCTL0_DO_SNAK0_Pos = 0x1b
	// Bit mask of DO_SNAK0 field.
	USB_DOEPCTL0_DO_SNAK0_Msk = 0x8000000
	// Bit DO_SNAK0.
	USB_DOEPCTL0_DO_SNAK0 = 0x8000000
	// Position of EPDIS0 field.
	USB_DOEPCTL0_EPDIS0_Pos = 0x1e
	// Bit mask of EPDIS0 field.
	USB_DOEPCTL0_EPDIS0_Msk = 0x40000000
	// Bit EPDIS0.
	USB_DOEPCTL0_EPDIS0 = 0x40000000
	// Position of EPENA0 field.
	USB_DOEPCTL0_EPENA0_Pos = 0x1f
	// Bit mask of EPENA0 field.
	USB_DOEPCTL0_EPENA0_Msk = 0x80000000
	// Bit EPENA0.
	USB_DOEPCTL0_EPENA0 = 0x80000000

	// DOEPINT0
	// Position of XFERCOMPL0 field.
	USB_DOEPINT0_XFERCOMPL0_Pos = 0x0
	// Bit mask of XFERCOMPL0 field.
	USB_DOEPINT0_XFERCOMPL0_Msk = 0x1
	// Bit XFERCOMPL0.
	USB_DOEPINT0_XFERCOMPL0 = 0x1
	// Position of EPDISBLD0 field.
	USB_DOEPINT0_EPDISBLD0_Pos = 0x1
	// Bit mask of EPDISBLD0 field.
	USB_DOEPINT0_EPDISBLD0_Msk = 0x2
	// Bit EPDISBLD0.
	USB_DOEPINT0_EPDISBLD0 = 0x2
	// Position of AHBERR0 field.
	USB_DOEPINT0_AHBERR0_Pos = 0x2
	// Bit mask of AHBERR0 field.
	USB_DOEPINT0_AHBERR0_Msk = 0x4
	// Bit AHBERR0.
	USB_DOEPINT0_AHBERR0 = 0x4
	// Position of SETUP0 field.
	USB_DOEPINT0_SETUP0_Pos = 0x3
	// Bit mask of SETUP0 field.
	USB_DOEPINT0_SETUP0_Msk = 0x8
	// Bit SETUP0.
	USB_DOEPINT0_SETUP0 = 0x8
	// Position of OUTTKNEPDIS0 field.
	USB_DOEPINT0_OUTTKNEPDIS0_Pos = 0x4
	// Bit mask of OUTTKNEPDIS0 field.
	USB_DOEPINT0_OUTTKNEPDIS0_Msk = 0x10
	// Bit OUTTKNEPDIS0.
	USB_DOEPINT0_OUTTKNEPDIS0 = 0x10
	// Position of STSPHSERCVD0 field.
	USB_DOEPINT0_STSPHSERCVD0_Pos = 0x5
	// Bit mask of STSPHSERCVD0 field.
	USB_DOEPINT0_STSPHSERCVD0_Msk = 0x20
	// Bit STSPHSERCVD0.
	USB_DOEPINT0_STSPHSERCVD0 = 0x20
	// Position of BACK2BACKSETUP0 field.
	USB_DOEPINT0_BACK2BACKSETUP0_Pos = 0x6
	// Bit mask of BACK2BACKSETUP0 field.
	USB_DOEPINT0_BACK2BACKSETUP0_Msk = 0x40
	// Bit BACK2BACKSETUP0.
	USB_DOEPINT0_BACK2BACKSETUP0 = 0x40
	// Position of OUTPKTERR0 field.
	USB_DOEPINT0_OUTPKTERR0_Pos = 0x8
	// Bit mask of OUTPKTERR0 field.
	USB_DOEPINT0_OUTPKTERR0_Msk = 0x100
	// Bit OUTPKTERR0.
	USB_DOEPINT0_OUTPKTERR0 = 0x100
	// Position of BNAINTR0 field.
	USB_DOEPINT0_BNAINTR0_Pos = 0x9
	// Bit mask of BNAINTR0 field.
	USB_DOEPINT0_BNAINTR0_Msk = 0x200
	// Bit BNAINTR0.
	USB_DOEPINT0_BNAINTR0 = 0x200
	// Position of PKTDRPSTS0 field.
	USB_DOEPINT0_PKTDRPSTS0_Pos = 0xb
	// Bit mask of PKTDRPSTS0 field.
	USB_DOEPINT0_PKTDRPSTS0_Msk = 0x800
	// Bit PKTDRPSTS0.
	USB_DOEPINT0_PKTDRPSTS0 = 0x800
	// Position of BBLEERR0 field.
	USB_DOEPINT0_BBLEERR0_Pos = 0xc
	// Bit mask of BBLEERR0 field.
	USB_DOEPINT0_BBLEERR0_Msk = 0x1000
	// Bit BBLEERR0.
	USB_DOEPINT0_BBLEERR0 = 0x1000
	// Position of NAKINTRPT0 field.
	USB_DOEPINT0_NAKINTRPT0_Pos = 0xd
	// Bit mask of NAKINTRPT0 field.
	USB_DOEPINT0_NAKINTRPT0_Msk = 0x2000
	// Bit NAKINTRPT0.
	USB_DOEPINT0_NAKINTRPT0 = 0x2000
	// Position of NYEPINTRPT0 field.
	USB_DOEPINT0_NYEPINTRPT0_Pos = 0xe
	// Bit mask of NYEPINTRPT0 field.
	USB_DOEPINT0_NYEPINTRPT0_Msk = 0x4000
	// Bit NYEPINTRPT0.
	USB_DOEPINT0_NYEPINTRPT0 = 0x4000
	// Position of STUPPKTRCVD0 field.
	USB_DOEPINT0_STUPPKTRCVD0_Pos = 0xf
	// Bit mask of STUPPKTRCVD0 field.
	USB_DOEPINT0_STUPPKTRCVD0_Msk = 0x8000
	// Bit STUPPKTRCVD0.
	USB_DOEPINT0_STUPPKTRCVD0 = 0x8000

	// DOEPTSIZ0
	// Position of XFERSIZE0 field.
	USB_DOEPTSIZ0_XFERSIZE0_Pos = 0x0
	// Bit mask of XFERSIZE0 field.
	USB_DOEPTSIZ0_XFERSIZE0_Msk = 0x7f
	// Position of PKTCNT0 field.
	USB_DOEPTSIZ0_PKTCNT0_Pos = 0x13
	// Bit mask of PKTCNT0 field.
	USB_DOEPTSIZ0_PKTCNT0_Msk = 0x80000
	// Bit PKTCNT0.
	USB_DOEPTSIZ0_PKTCNT0 = 0x80000
	// Position of SUPCNT0 field.
	USB_DOEPTSIZ0_SUPCNT0_Pos = 0x1d
	// Bit mask of SUPCNT0 field.
	USB_DOEPTSIZ0_SUPCNT0_Msk = 0x60000000

	// DOEPDMA0
	// Position of DMAADDR0 field.
	USB_DOEPDMA0_DMAADDR0_Pos = 0x0
	// Bit mask of DMAADDR0 field.
	USB_DOEPDMA0_DMAADDR0_Msk = 0xffffffff

	// DOEPDMAB0
	// Position of DMABUFFERADDR0 field.
	USB_DOEPDMAB0_DMABUFFERADDR0_Pos = 0x0
	// Bit mask of DMABUFFERADDR0 field.
	USB_DOEPDMAB0_DMABUFFERADDR0_Msk = 0xffffffff

	// DOEPCTL1
	// Position of MPS1 field.
	USB_DOEPCTL1_MPS1_Pos = 0x0
	// Bit mask of MPS1 field.
	USB_DOEPCTL1_MPS1_Msk = 0x7ff
	// Position of USBACTEP1 field.
	USB_DOEPCTL1_USBACTEP1_Pos = 0xf
	// Bit mask of USBACTEP1 field.
	USB_DOEPCTL1_USBACTEP1_Msk = 0x8000
	// Bit USBACTEP1.
	USB_DOEPCTL1_USBACTEP1 = 0x8000
	// Position of NAKSTS1 field.
	USB_DOEPCTL1_NAKSTS1_Pos = 0x11
	// Bit mask of NAKSTS1 field.
	USB_DOEPCTL1_NAKSTS1_Msk = 0x20000
	// Bit NAKSTS1.
	USB_DOEPCTL1_NAKSTS1 = 0x20000
	// Position of EPTYPE1 field.
	USB_DOEPCTL1_EPTYPE1_Pos = 0x12
	// Bit mask of EPTYPE1 field.
	USB_DOEPCTL1_EPTYPE1_Msk = 0xc0000
	// Position of SNP1 field.
	USB_DOEPCTL1_SNP1_Pos = 0x14
	// Bit mask of SNP1 field.
	USB_DOEPCTL1_SNP1_Msk = 0x100000
	// Bit SNP1.
	USB_DOEPCTL1_SNP1 = 0x100000
	// Position of STALL1 field.
	USB_DOEPCTL1_STALL1_Pos = 0x15
	// Bit mask of STALL1 field.
	USB_DOEPCTL1_STALL1_Msk = 0x200000
	// Bit STALL1.
	USB_DOEPCTL1_STALL1 = 0x200000
	// Position of CNAK1 field.
	USB_DOEPCTL1_CNAK1_Pos = 0x1a
	// Bit mask of CNAK1 field.
	USB_DOEPCTL1_CNAK1_Msk = 0x4000000
	// Bit CNAK1.
	USB_DOEPCTL1_CNAK1 = 0x4000000
	// Position of DO_SNAK1 field.
	USB_DOEPCTL1_DO_SNAK1_Pos = 0x1b
	// Bit mask of DO_SNAK1 field.
	USB_DOEPCTL1_DO_SNAK1_Msk = 0x8000000
	// Bit DO_SNAK1.
	USB_DOEPCTL1_DO_SNAK1 = 0x8000000
	// Position of DO_SETD0PID1 field.
	USB_DOEPCTL1_DO_SETD0PID1_Pos = 0x1c
	// Bit mask of DO_SETD0PID1 field.
	USB_DOEPCTL1_DO_SETD0PID1_Msk = 0x10000000
	// Bit DO_SETD0PID1.
	USB_DOEPCTL1_DO_SETD0PID1 = 0x10000000
	// Position of DO_SETD1PID1 field.
	USB_DOEPCTL1_DO_SETD1PID1_Pos = 0x1d
	// Bit mask of DO_SETD1PID1 field.
	USB_DOEPCTL1_DO_SETD1PID1_Msk = 0x20000000
	// Bit DO_SETD1PID1.
	USB_DOEPCTL1_DO_SETD1PID1 = 0x20000000
	// Position of EPDIS1 field.
	USB_DOEPCTL1_EPDIS1_Pos = 0x1e
	// Bit mask of EPDIS1 field.
	USB_DOEPCTL1_EPDIS1_Msk = 0x40000000
	// Bit EPDIS1.
	USB_DOEPCTL1_EPDIS1 = 0x40000000
	// Position of EPENA1 field.
	USB_DOEPCTL1_EPENA1_Pos = 0x1f
	// Bit mask of EPENA1 field.
	USB_DOEPCTL1_EPENA1_Msk = 0x80000000
	// Bit EPENA1.
	USB_DOEPCTL1_EPENA1 = 0x80000000

	// DOEPINT1
	// Position of XFERCOMPL1 field.
	USB_DOEPINT1_XFERCOMPL1_Pos = 0x0
	// Bit mask of XFERCOMPL1 field.
	USB_DOEPINT1_XFERCOMPL1_Msk = 0x1
	// Bit XFERCOMPL1.
	USB_DOEPINT1_XFERCOMPL1 = 0x1
	// Position of EPDISBLD1 field.
	USB_DOEPINT1_EPDISBLD1_Pos = 0x1
	// Bit mask of EPDISBLD1 field.
	USB_DOEPINT1_EPDISBLD1_Msk = 0x2
	// Bit EPDISBLD1.
	USB_DOEPINT1_EPDISBLD1 = 0x2
	// Position of AHBERR1 field.
	USB_DOEPINT1_AHBERR1_Pos = 0x2
	// Bit mask of AHBERR1 field.
	USB_DOEPINT1_AHBERR1_Msk = 0x4
	// Bit AHBERR1.
	USB_DOEPINT1_AHBERR1 = 0x4
	// Position of SETUP1 field.
	USB_DOEPINT1_SETUP1_Pos = 0x3
	// Bit mask of SETUP1 field.
	USB_DOEPINT1_SETUP1_Msk = 0x8
	// Bit SETUP1.
	USB_DOEPINT1_SETUP1 = 0x8
	// Position of OUTTKNEPDIS1 field.
	USB_DOEPINT1_OUTTKNEPDIS1_Pos = 0x4
	// Bit mask of OUTTKNEPDIS1 field.
	USB_DOEPINT1_OUTTKNEPDIS1_Msk = 0x10
	// Bit OUTTKNEPDIS1.
	USB_DOEPINT1_OUTTKNEPDIS1 = 0x10
	// Position of STSPHSERCVD1 field.
	USB_DOEPINT1_STSPHSERCVD1_Pos = 0x5
	// Bit mask of STSPHSERCVD1 field.
	USB_DOEPINT1_STSPHSERCVD1_Msk = 0x20
	// Bit STSPHSERCVD1.
	USB_DOEPINT1_STSPHSERCVD1 = 0x20
	// Position of BACK2BACKSETUP1 field.
	USB_DOEPINT1_BACK2BACKSETUP1_Pos = 0x6
	// Bit mask of BACK2BACKSETUP1 field.
	USB_DOEPINT1_BACK2BACKSETUP1_Msk = 0x40
	// Bit BACK2BACKSETUP1.
	USB_DOEPINT1_BACK2BACKSETUP1 = 0x40
	// Position of OUTPKTERR1 field.
	USB_DOEPINT1_OUTPKTERR1_Pos = 0x8
	// Bit mask of OUTPKTERR1 field.
	USB_DOEPINT1_OUTPKTERR1_Msk = 0x100
	// Bit OUTPKTERR1.
	USB_DOEPINT1_OUTPKTERR1 = 0x100
	// Position of BNAINTR1 field.
	USB_DOEPINT1_BNAINTR1_Pos = 0x9
	// Bit mask of BNAINTR1 field.
	USB_DOEPINT1_BNAINTR1_Msk = 0x200
	// Bit BNAINTR1.
	USB_DOEPINT1_BNAINTR1 = 0x200
	// Position of PKTDRPSTS1 field.
	USB_DOEPINT1_PKTDRPSTS1_Pos = 0xb
	// Bit mask of PKTDRPSTS1 field.
	USB_DOEPINT1_PKTDRPSTS1_Msk = 0x800
	// Bit PKTDRPSTS1.
	USB_DOEPINT1_PKTDRPSTS1 = 0x800
	// Position of BBLEERR1 field.
	USB_DOEPINT1_BBLEERR1_Pos = 0xc
	// Bit mask of BBLEERR1 field.
	USB_DOEPINT1_BBLEERR1_Msk = 0x1000
	// Bit BBLEERR1.
	USB_DOEPINT1_BBLEERR1 = 0x1000
	// Position of NAKINTRPT1 field.
	USB_DOEPINT1_NAKINTRPT1_Pos = 0xd
	// Bit mask of NAKINTRPT1 field.
	USB_DOEPINT1_NAKINTRPT1_Msk = 0x2000
	// Bit NAKINTRPT1.
	USB_DOEPINT1_NAKINTRPT1 = 0x2000
	// Position of NYEPINTRPT1 field.
	USB_DOEPINT1_NYEPINTRPT1_Pos = 0xe
	// Bit mask of NYEPINTRPT1 field.
	USB_DOEPINT1_NYEPINTRPT1_Msk = 0x4000
	// Bit NYEPINTRPT1.
	USB_DOEPINT1_NYEPINTRPT1 = 0x4000
	// Position of STUPPKTRCVD1 field.
	USB_DOEPINT1_STUPPKTRCVD1_Pos = 0xf
	// Bit mask of STUPPKTRCVD1 field.
	USB_DOEPINT1_STUPPKTRCVD1_Msk = 0x8000
	// Bit STUPPKTRCVD1.
	USB_DOEPINT1_STUPPKTRCVD1 = 0x8000

	// DOEPTSIZ1
	// Position of XFERSIZE1 field.
	USB_DOEPTSIZ1_XFERSIZE1_Pos = 0x0
	// Bit mask of XFERSIZE1 field.
	USB_DOEPTSIZ1_XFERSIZE1_Msk = 0x7f
	// Position of PKTCNT1 field.
	USB_DOEPTSIZ1_PKTCNT1_Pos = 0x13
	// Bit mask of PKTCNT1 field.
	USB_DOEPTSIZ1_PKTCNT1_Msk = 0x80000
	// Bit PKTCNT1.
	USB_DOEPTSIZ1_PKTCNT1 = 0x80000
	// Position of SUPCNT1 field.
	USB_DOEPTSIZ1_SUPCNT1_Pos = 0x1d
	// Bit mask of SUPCNT1 field.
	USB_DOEPTSIZ1_SUPCNT1_Msk = 0x60000000

	// DOEPDMA1
	// Position of DMAADDR1 field.
	USB_DOEPDMA1_DMAADDR1_Pos = 0x0
	// Bit mask of DMAADDR1 field.
	USB_DOEPDMA1_DMAADDR1_Msk = 0xffffffff

	// DOEPDMAB1
	// Position of DMABUFFERADDR1 field.
	USB_DOEPDMAB1_DMABUFFERADDR1_Pos = 0x0
	// Bit mask of DMABUFFERADDR1 field.
	USB_DOEPDMAB1_DMABUFFERADDR1_Msk = 0xffffffff

	// DOEPCTL2
	// Position of MPS2 field.
	USB_DOEPCTL2_MPS2_Pos = 0x0
	// Bit mask of MPS2 field.
	USB_DOEPCTL2_MPS2_Msk = 0x7ff
	// Position of USBACTEP2 field.
	USB_DOEPCTL2_USBACTEP2_Pos = 0xf
	// Bit mask of USBACTEP2 field.
	USB_DOEPCTL2_USBACTEP2_Msk = 0x8000
	// Bit USBACTEP2.
	USB_DOEPCTL2_USBACTEP2 = 0x8000
	// Position of NAKSTS2 field.
	USB_DOEPCTL2_NAKSTS2_Pos = 0x11
	// Bit mask of NAKSTS2 field.
	USB_DOEPCTL2_NAKSTS2_Msk = 0x20000
	// Bit NAKSTS2.
	USB_DOEPCTL2_NAKSTS2 = 0x20000
	// Position of EPTYPE2 field.
	USB_DOEPCTL2_EPTYPE2_Pos = 0x12
	// Bit mask of EPTYPE2 field.
	USB_DOEPCTL2_EPTYPE2_Msk = 0xc0000
	// Position of SNP2 field.
	USB_DOEPCTL2_SNP2_Pos = 0x14
	// Bit mask of SNP2 field.
	USB_DOEPCTL2_SNP2_Msk = 0x100000
	// Bit SNP2.
	USB_DOEPCTL2_SNP2 = 0x100000
	// Position of STALL2 field.
	USB_DOEPCTL2_STALL2_Pos = 0x15
	// Bit mask of STALL2 field.
	USB_DOEPCTL2_STALL2_Msk = 0x200000
	// Bit STALL2.
	USB_DOEPCTL2_STALL2 = 0x200000
	// Position of CNAK2 field.
	USB_DOEPCTL2_CNAK2_Pos = 0x1a
	// Bit mask of CNAK2 field.
	USB_DOEPCTL2_CNAK2_Msk = 0x4000000
	// Bit CNAK2.
	USB_DOEPCTL2_CNAK2 = 0x4000000
	// Position of DO_SNAK2 field.
	USB_DOEPCTL2_DO_SNAK2_Pos = 0x1b
	// Bit mask of DO_SNAK2 field.
	USB_DOEPCTL2_DO_SNAK2_Msk = 0x8000000
	// Bit DO_SNAK2.
	USB_DOEPCTL2_DO_SNAK2 = 0x8000000
	// Position of DO_SETD0PID2 field.
	USB_DOEPCTL2_DO_SETD0PID2_Pos = 0x1c
	// Bit mask of DO_SETD0PID2 field.
	USB_DOEPCTL2_DO_SETD0PID2_Msk = 0x10000000
	// Bit DO_SETD0PID2.
	USB_DOEPCTL2_DO_SETD0PID2 = 0x10000000
	// Position of DO_SETD1PID2 field.
	USB_DOEPCTL2_DO_SETD1PID2_Pos = 0x1d
	// Bit mask of DO_SETD1PID2 field.
	USB_DOEPCTL2_DO_SETD1PID2_Msk = 0x20000000
	// Bit DO_SETD1PID2.
	USB_DOEPCTL2_DO_SETD1PID2 = 0x20000000
	// Position of EPDIS2 field.
	USB_DOEPCTL2_EPDIS2_Pos = 0x1e
	// Bit mask of EPDIS2 field.
	USB_DOEPCTL2_EPDIS2_Msk = 0x40000000
	// Bit EPDIS2.
	USB_DOEPCTL2_EPDIS2 = 0x40000000
	// Position of EPENA2 field.
	USB_DOEPCTL2_EPENA2_Pos = 0x1f
	// Bit mask of EPENA2 field.
	USB_DOEPCTL2_EPENA2_Msk = 0x80000000
	// Bit EPENA2.
	USB_DOEPCTL2_EPENA2 = 0x80000000

	// DOEPINT2
	// Position of XFERCOMPL2 field.
	USB_DOEPINT2_XFERCOMPL2_Pos = 0x0
	// Bit mask of XFERCOMPL2 field.
	USB_DOEPINT2_XFERCOMPL2_Msk = 0x1
	// Bit XFERCOMPL2.
	USB_DOEPINT2_XFERCOMPL2 = 0x1
	// Position of EPDISBLD2 field.
	USB_DOEPINT2_EPDISBLD2_Pos = 0x1
	// Bit mask of EPDISBLD2 field.
	USB_DOEPINT2_EPDISBLD2_Msk = 0x2
	// Bit EPDISBLD2.
	USB_DOEPINT2_EPDISBLD2 = 0x2
	// Position of AHBERR2 field.
	USB_DOEPINT2_AHBERR2_Pos = 0x2
	// Bit mask of AHBERR2 field.
	USB_DOEPINT2_AHBERR2_Msk = 0x4
	// Bit AHBERR2.
	USB_DOEPINT2_AHBERR2 = 0x4
	// Position of SETUP2 field.
	USB_DOEPINT2_SETUP2_Pos = 0x3
	// Bit mask of SETUP2 field.
	USB_DOEPINT2_SETUP2_Msk = 0x8
	// Bit SETUP2.
	USB_DOEPINT2_SETUP2 = 0x8
	// Position of OUTTKNEPDIS2 field.
	USB_DOEPINT2_OUTTKNEPDIS2_Pos = 0x4
	// Bit mask of OUTTKNEPDIS2 field.
	USB_DOEPINT2_OUTTKNEPDIS2_Msk = 0x10
	// Bit OUTTKNEPDIS2.
	USB_DOEPINT2_OUTTKNEPDIS2 = 0x10
	// Position of STSPHSERCVD2 field.
	USB_DOEPINT2_STSPHSERCVD2_Pos = 0x5
	// Bit mask of STSPHSERCVD2 field.
	USB_DOEPINT2_STSPHSERCVD2_Msk = 0x20
	// Bit STSPHSERCVD2.
	USB_DOEPINT2_STSPHSERCVD2 = 0x20
	// Position of BACK2BACKSETUP2 field.
	USB_DOEPINT2_BACK2BACKSETUP2_Pos = 0x6
	// Bit mask of BACK2BACKSETUP2 field.
	USB_DOEPINT2_BACK2BACKSETUP2_Msk = 0x40
	// Bit BACK2BACKSETUP2.
	USB_DOEPINT2_BACK2BACKSETUP2 = 0x40
	// Position of OUTPKTERR2 field.
	USB_DOEPINT2_OUTPKTERR2_Pos = 0x8
	// Bit mask of OUTPKTERR2 field.
	USB_DOEPINT2_OUTPKTERR2_Msk = 0x100
	// Bit OUTPKTERR2.
	USB_DOEPINT2_OUTPKTERR2 = 0x100
	// Position of BNAINTR2 field.
	USB_DOEPINT2_BNAINTR2_Pos = 0x9
	// Bit mask of BNAINTR2 field.
	USB_DOEPINT2_BNAINTR2_Msk = 0x200
	// Bit BNAINTR2.
	USB_DOEPINT2_BNAINTR2 = 0x200
	// Position of PKTDRPSTS2 field.
	USB_DOEPINT2_PKTDRPSTS2_Pos = 0xb
	// Bit mask of PKTDRPSTS2 field.
	USB_DOEPINT2_PKTDRPSTS2_Msk = 0x800
	// Bit PKTDRPSTS2.
	USB_DOEPINT2_PKTDRPSTS2 = 0x800
	// Position of BBLEERR2 field.
	USB_DOEPINT2_BBLEERR2_Pos = 0xc
	// Bit mask of BBLEERR2 field.
	USB_DOEPINT2_BBLEERR2_Msk = 0x1000
	// Bit BBLEERR2.
	USB_DOEPINT2_BBLEERR2 = 0x1000
	// Position of NAKINTRPT2 field.
	USB_DOEPINT2_NAKINTRPT2_Pos = 0xd
	// Bit mask of NAKINTRPT2 field.
	USB_DOEPINT2_NAKINTRPT2_Msk = 0x2000
	// Bit NAKINTRPT2.
	USB_DOEPINT2_NAKINTRPT2 = 0x2000
	// Position of NYEPINTRPT2 field.
	USB_DOEPINT2_NYEPINTRPT2_Pos = 0xe
	// Bit mask of NYEPINTRPT2 field.
	USB_DOEPINT2_NYEPINTRPT2_Msk = 0x4000
	// Bit NYEPINTRPT2.
	USB_DOEPINT2_NYEPINTRPT2 = 0x4000
	// Position of STUPPKTRCVD2 field.
	USB_DOEPINT2_STUPPKTRCVD2_Pos = 0xf
	// Bit mask of STUPPKTRCVD2 field.
	USB_DOEPINT2_STUPPKTRCVD2_Msk = 0x8000
	// Bit STUPPKTRCVD2.
	USB_DOEPINT2_STUPPKTRCVD2 = 0x8000

	// DOEPTSIZ2
	// Position of XFERSIZE2 field.
	USB_DOEPTSIZ2_XFERSIZE2_Pos = 0x0
	// Bit mask of XFERSIZE2 field.
	USB_DOEPTSIZ2_XFERSIZE2_Msk = 0x7f
	// Position of PKTCNT2 field.
	USB_DOEPTSIZ2_PKTCNT2_Pos = 0x13
	// Bit mask of PKTCNT2 field.
	USB_DOEPTSIZ2_PKTCNT2_Msk = 0x80000
	// Bit PKTCNT2.
	USB_DOEPTSIZ2_PKTCNT2 = 0x80000
	// Position of SUPCNT2 field.
	USB_DOEPTSIZ2_SUPCNT2_Pos = 0x1d
	// Bit mask of SUPCNT2 field.
	USB_DOEPTSIZ2_SUPCNT2_Msk = 0x60000000

	// DOEPDMA2
	// Position of DMAADDR2 field.
	USB_DOEPDMA2_DMAADDR2_Pos = 0x0
	// Bit mask of DMAADDR2 field.
	USB_DOEPDMA2_DMAADDR2_Msk = 0xffffffff

	// DOEPDMAB2
	// Position of DMABUFFERADDR2 field.
	USB_DOEPDMAB2_DMABUFFERADDR2_Pos = 0x0
	// Bit mask of DMABUFFERADDR2 field.
	USB_DOEPDMAB2_DMABUFFERADDR2_Msk = 0xffffffff

	// DOEPCTL3
	// Position of MPS3 field.
	USB_DOEPCTL3_MPS3_Pos = 0x0
	// Bit mask of MPS3 field.
	USB_DOEPCTL3_MPS3_Msk = 0x7ff
	// Position of USBACTEP3 field.
	USB_DOEPCTL3_USBACTEP3_Pos = 0xf
	// Bit mask of USBACTEP3 field.
	USB_DOEPCTL3_USBACTEP3_Msk = 0x8000
	// Bit USBACTEP3.
	USB_DOEPCTL3_USBACTEP3 = 0x8000
	// Position of NAKSTS3 field.
	USB_DOEPCTL3_NAKSTS3_Pos = 0x11
	// Bit mask of NAKSTS3 field.
	USB_DOEPCTL3_NAKSTS3_Msk = 0x20000
	// Bit NAKSTS3.
	USB_DOEPCTL3_NAKSTS3 = 0x20000
	// Position of EPTYPE3 field.
	USB_DOEPCTL3_EPTYPE3_Pos = 0x12
	// Bit mask of EPTYPE3 field.
	USB_DOEPCTL3_EPTYPE3_Msk = 0xc0000
	// Position of SNP3 field.
	USB_DOEPCTL3_SNP3_Pos = 0x14
	// Bit mask of SNP3 field.
	USB_DOEPCTL3_SNP3_Msk = 0x100000
	// Bit SNP3.
	USB_DOEPCTL3_SNP3 = 0x100000
	// Position of STALL3 field.
	USB_DOEPCTL3_STALL3_Pos = 0x15
	// Bit mask of STALL3 field.
	USB_DOEPCTL3_STALL3_Msk = 0x200000
	// Bit STALL3.
	USB_DOEPCTL3_STALL3 = 0x200000
	// Position of CNAK3 field.
	USB_DOEPCTL3_CNAK3_Pos = 0x1a
	// Bit mask of CNAK3 field.
	USB_DOEPCTL3_CNAK3_Msk = 0x4000000
	// Bit CNAK3.
	USB_DOEPCTL3_CNAK3 = 0x4000000
	// Position of DO_SNAK3 field.
	USB_DOEPCTL3_DO_SNAK3_Pos = 0x1b
	// Bit mask of DO_SNAK3 field.
	USB_DOEPCTL3_DO_SNAK3_Msk = 0x8000000
	// Bit DO_SNAK3.
	USB_DOEPCTL3_DO_SNAK3 = 0x8000000
	// Position of DO_SETD0PID3 field.
	USB_DOEPCTL3_DO_SETD0PID3_Pos = 0x1c
	// Bit mask of DO_SETD0PID3 field.
	USB_DOEPCTL3_DO_SETD0PID3_Msk = 0x10000000
	// Bit DO_SETD0PID3.
	USB_DOEPCTL3_DO_SETD0PID3 = 0x10000000
	// Position of DO_SETD1PID3 field.
	USB_DOEPCTL3_DO_SETD1PID3_Pos = 0x1d
	// Bit mask of DO_SETD1PID3 field.
	USB_DOEPCTL3_DO_SETD1PID3_Msk = 0x20000000
	// Bit DO_SETD1PID3.
	USB_DOEPCTL3_DO_SETD1PID3 = 0x20000000
	// Position of EPDIS3 field.
	USB_DOEPCTL3_EPDIS3_Pos = 0x1e
	// Bit mask of EPDIS3 field.
	USB_DOEPCTL3_EPDIS3_Msk = 0x40000000
	// Bit EPDIS3.
	USB_DOEPCTL3_EPDIS3 = 0x40000000
	// Position of EPENA3 field.
	USB_DOEPCTL3_EPENA3_Pos = 0x1f
	// Bit mask of EPENA3 field.
	USB_DOEPCTL3_EPENA3_Msk = 0x80000000
	// Bit EPENA3.
	USB_DOEPCTL3_EPENA3 = 0x80000000

	// DOEPINT3
	// Position of XFERCOMPL3 field.
	USB_DOEPINT3_XFERCOMPL3_Pos = 0x0
	// Bit mask of XFERCOMPL3 field.
	USB_DOEPINT3_XFERCOMPL3_Msk = 0x1
	// Bit XFERCOMPL3.
	USB_DOEPINT3_XFERCOMPL3 = 0x1
	// Position of EPDISBLD3 field.
	USB_DOEPINT3_EPDISBLD3_Pos = 0x1
	// Bit mask of EPDISBLD3 field.
	USB_DOEPINT3_EPDISBLD3_Msk = 0x2
	// Bit EPDISBLD3.
	USB_DOEPINT3_EPDISBLD3 = 0x2
	// Position of AHBERR3 field.
	USB_DOEPINT3_AHBERR3_Pos = 0x2
	// Bit mask of AHBERR3 field.
	USB_DOEPINT3_AHBERR3_Msk = 0x4
	// Bit AHBERR3.
	USB_DOEPINT3_AHBERR3 = 0x4
	// Position of SETUP3 field.
	USB_DOEPINT3_SETUP3_Pos = 0x3
	// Bit mask of SETUP3 field.
	USB_DOEPINT3_SETUP3_Msk = 0x8
	// Bit SETUP3.
	USB_DOEPINT3_SETUP3 = 0x8
	// Position of OUTTKNEPDIS3 field.
	USB_DOEPINT3_OUTTKNEPDIS3_Pos = 0x4
	// Bit mask of OUTTKNEPDIS3 field.
	USB_DOEPINT3_OUTTKNEPDIS3_Msk = 0x10
	// Bit OUTTKNEPDIS3.
	USB_DOEPINT3_OUTTKNEPDIS3 = 0x10
	// Position of STSPHSERCVD3 field.
	USB_DOEPINT3_STSPHSERCVD3_Pos = 0x5
	// Bit mask of STSPHSERCVD3 field.
	USB_DOEPINT3_STSPHSERCVD3_Msk = 0x20
	// Bit STSPHSERCVD3.
	USB_DOEPINT3_STSPHSERCVD3 = 0x20
	// Position of BACK2BACKSETUP3 field.
	USB_DOEPINT3_BACK2BACKSETUP3_Pos = 0x6
	// Bit mask of BACK2BACKSETUP3 field.
	USB_DOEPINT3_BACK2BACKSETUP3_Msk = 0x40
	// Bit BACK2BACKSETUP3.
	USB_DOEPINT3_BACK2BACKSETUP3 = 0x40
	// Position of OUTPKTERR3 field.
	USB_DOEPINT3_OUTPKTERR3_Pos = 0x8
	// Bit mask of OUTPKTERR3 field.
	USB_DOEPINT3_OUTPKTERR3_Msk = 0x100
	// Bit OUTPKTERR3.
	USB_DOEPINT3_OUTPKTERR3 = 0x100
	// Position of BNAINTR3 field.
	USB_DOEPINT3_BNAINTR3_Pos = 0x9
	// Bit mask of BNAINTR3 field.
	USB_DOEPINT3_BNAINTR3_Msk = 0x200
	// Bit BNAINTR3.
	USB_DOEPINT3_BNAINTR3 = 0x200
	// Position of PKTDRPSTS3 field.
	USB_DOEPINT3_PKTDRPSTS3_Pos = 0xb
	// Bit mask of PKTDRPSTS3 field.
	USB_DOEPINT3_PKTDRPSTS3_Msk = 0x800
	// Bit PKTDRPSTS3.
	USB_DOEPINT3_PKTDRPSTS3 = 0x800
	// Position of BBLEERR3 field.
	USB_DOEPINT3_BBLEERR3_Pos = 0xc
	// Bit mask of BBLEERR3 field.
	USB_DOEPINT3_BBLEERR3_Msk = 0x1000
	// Bit BBLEERR3.
	USB_DOEPINT3_BBLEERR3 = 0x1000
	// Position of NAKINTRPT3 field.
	USB_DOEPINT3_NAKINTRPT3_Pos = 0xd
	// Bit mask of NAKINTRPT3 field.
	USB_DOEPINT3_NAKINTRPT3_Msk = 0x2000
	// Bit NAKINTRPT3.
	USB_DOEPINT3_NAKINTRPT3 = 0x2000
	// Position of NYEPINTRPT3 field.
	USB_DOEPINT3_NYEPINTRPT3_Pos = 0xe
	// Bit mask of NYEPINTRPT3 field.
	USB_DOEPINT3_NYEPINTRPT3_Msk = 0x4000
	// Bit NYEPINTRPT3.
	USB_DOEPINT3_NYEPINTRPT3 = 0x4000
	// Position of STUPPKTRCVD3 field.
	USB_DOEPINT3_STUPPKTRCVD3_Pos = 0xf
	// Bit mask of STUPPKTRCVD3 field.
	USB_DOEPINT3_STUPPKTRCVD3_Msk = 0x8000
	// Bit STUPPKTRCVD3.
	USB_DOEPINT3_STUPPKTRCVD3 = 0x8000

	// DOEPTSIZ3
	// Position of XFERSIZE3 field.
	USB_DOEPTSIZ3_XFERSIZE3_Pos = 0x0
	// Bit mask of XFERSIZE3 field.
	USB_DOEPTSIZ3_XFERSIZE3_Msk = 0x7f
	// Position of PKTCNT3 field.
	USB_DOEPTSIZ3_PKTCNT3_Pos = 0x13
	// Bit mask of PKTCNT3 field.
	USB_DOEPTSIZ3_PKTCNT3_Msk = 0x80000
	// Bit PKTCNT3.
	USB_DOEPTSIZ3_PKTCNT3 = 0x80000
	// Position of SUPCNT3 field.
	USB_DOEPTSIZ3_SUPCNT3_Pos = 0x1d
	// Bit mask of SUPCNT3 field.
	USB_DOEPTSIZ3_SUPCNT3_Msk = 0x60000000

	// DOEPDMA3
	// Position of DMAADDR3 field.
	USB_DOEPDMA3_DMAADDR3_Pos = 0x0
	// Bit mask of DMAADDR3 field.
	USB_DOEPDMA3_DMAADDR3_Msk = 0xffffffff

	// DOEPDMAB3
	// Position of DMABUFFERADDR3 field.
	USB_DOEPDMAB3_DMABUFFERADDR3_Pos = 0x0
	// Bit mask of DMABUFFERADDR3 field.
	USB_DOEPDMAB3_DMABUFFERADDR3_Msk = 0xffffffff

	// DOEPCTL4
	// Position of MPS4 field.
	USB_DOEPCTL4_MPS4_Pos = 0x0
	// Bit mask of MPS4 field.
	USB_DOEPCTL4_MPS4_Msk = 0x7ff
	// Position of USBACTEP4 field.
	USB_DOEPCTL4_USBACTEP4_Pos = 0xf
	// Bit mask of USBACTEP4 field.
	USB_DOEPCTL4_USBACTEP4_Msk = 0x8000
	// Bit USBACTEP4.
	USB_DOEPCTL4_USBACTEP4 = 0x8000
	// Position of NAKSTS4 field.
	USB_DOEPCTL4_NAKSTS4_Pos = 0x11
	// Bit mask of NAKSTS4 field.
	USB_DOEPCTL4_NAKSTS4_Msk = 0x20000
	// Bit NAKSTS4.
	USB_DOEPCTL4_NAKSTS4 = 0x20000
	// Position of EPTYPE4 field.
	USB_DOEPCTL4_EPTYPE4_Pos = 0x12
	// Bit mask of EPTYPE4 field.
	USB_DOEPCTL4_EPTYPE4_Msk = 0xc0000
	// Position of SNP4 field.
	USB_DOEPCTL4_SNP4_Pos = 0x14
	// Bit mask of SNP4 field.
	USB_DOEPCTL4_SNP4_Msk = 0x100000
	// Bit SNP4.
	USB_DOEPCTL4_SNP4 = 0x100000
	// Position of STALL4 field.
	USB_DOEPCTL4_STALL4_Pos = 0x15
	// Bit mask of STALL4 field.
	USB_DOEPCTL4_STALL4_Msk = 0x200000
	// Bit STALL4.
	USB_DOEPCTL4_STALL4 = 0x200000
	// Position of CNAK4 field.
	USB_DOEPCTL4_CNAK4_Pos = 0x1a
	// Bit mask of CNAK4 field.
	USB_DOEPCTL4_CNAK4_Msk = 0x4000000
	// Bit CNAK4.
	USB_DOEPCTL4_CNAK4 = 0x4000000
	// Position of DO_SNAK4 field.
	USB_DOEPCTL4_DO_SNAK4_Pos = 0x1b
	// Bit mask of DO_SNAK4 field.
	USB_DOEPCTL4_DO_SNAK4_Msk = 0x8000000
	// Bit DO_SNAK4.
	USB_DOEPCTL4_DO_SNAK4 = 0x8000000
	// Position of DO_SETD0PID4 field.
	USB_DOEPCTL4_DO_SETD0PID4_Pos = 0x1c
	// Bit mask of DO_SETD0PID4 field.
	USB_DOEPCTL4_DO_SETD0PID4_Msk = 0x10000000
	// Bit DO_SETD0PID4.
	USB_DOEPCTL4_DO_SETD0PID4 = 0x10000000
	// Position of DO_SETD1PID4 field.
	USB_DOEPCTL4_DO_SETD1PID4_Pos = 0x1d
	// Bit mask of DO_SETD1PID4 field.
	USB_DOEPCTL4_DO_SETD1PID4_Msk = 0x20000000
	// Bit DO_SETD1PID4.
	USB_DOEPCTL4_DO_SETD1PID4 = 0x20000000
	// Position of EPDIS4 field.
	USB_DOEPCTL4_EPDIS4_Pos = 0x1e
	// Bit mask of EPDIS4 field.
	USB_DOEPCTL4_EPDIS4_Msk = 0x40000000
	// Bit EPDIS4.
	USB_DOEPCTL4_EPDIS4 = 0x40000000
	// Position of EPENA4 field.
	USB_DOEPCTL4_EPENA4_Pos = 0x1f
	// Bit mask of EPENA4 field.
	USB_DOEPCTL4_EPENA4_Msk = 0x80000000
	// Bit EPENA4.
	USB_DOEPCTL4_EPENA4 = 0x80000000

	// DOEPINT4
	// Position of XFERCOMPL4 field.
	USB_DOEPINT4_XFERCOMPL4_Pos = 0x0
	// Bit mask of XFERCOMPL4 field.
	USB_DOEPINT4_XFERCOMPL4_Msk = 0x1
	// Bit XFERCOMPL4.
	USB_DOEPINT4_XFERCOMPL4 = 0x1
	// Position of EPDISBLD4 field.
	USB_DOEPINT4_EPDISBLD4_Pos = 0x1
	// Bit mask of EPDISBLD4 field.
	USB_DOEPINT4_EPDISBLD4_Msk = 0x2
	// Bit EPDISBLD4.
	USB_DOEPINT4_EPDISBLD4 = 0x2
	// Position of AHBERR4 field.
	USB_DOEPINT4_AHBERR4_Pos = 0x2
	// Bit mask of AHBERR4 field.
	USB_DOEPINT4_AHBERR4_Msk = 0x4
	// Bit AHBERR4.
	USB_DOEPINT4_AHBERR4 = 0x4
	// Position of SETUP4 field.
	USB_DOEPINT4_SETUP4_Pos = 0x3
	// Bit mask of SETUP4 field.
	USB_DOEPINT4_SETUP4_Msk = 0x8
	// Bit SETUP4.
	USB_DOEPINT4_SETUP4 = 0x8
	// Position of OUTTKNEPDIS4 field.
	USB_DOEPINT4_OUTTKNEPDIS4_Pos = 0x4
	// Bit mask of OUTTKNEPDIS4 field.
	USB_DOEPINT4_OUTTKNEPDIS4_Msk = 0x10
	// Bit OUTTKNEPDIS4.
	USB_DOEPINT4_OUTTKNEPDIS4 = 0x10
	// Position of STSPHSERCVD4 field.
	USB_DOEPINT4_STSPHSERCVD4_Pos = 0x5
	// Bit mask of STSPHSERCVD4 field.
	USB_DOEPINT4_STSPHSERCVD4_Msk = 0x20
	// Bit STSPHSERCVD4.
	USB_DOEPINT4_STSPHSERCVD4 = 0x20
	// Position of BACK2BACKSETUP4 field.
	USB_DOEPINT4_BACK2BACKSETUP4_Pos = 0x6
	// Bit mask of BACK2BACKSETUP4 field.
	USB_DOEPINT4_BACK2BACKSETUP4_Msk = 0x40
	// Bit BACK2BACKSETUP4.
	USB_DOEPINT4_BACK2BACKSETUP4 = 0x40
	// Position of OUTPKTERR4 field.
	USB_DOEPINT4_OUTPKTERR4_Pos = 0x8
	// Bit mask of OUTPKTERR4 field.
	USB_DOEPINT4_OUTPKTERR4_Msk = 0x100
	// Bit OUTPKTERR4.
	USB_DOEPINT4_OUTPKTERR4 = 0x100
	// Position of BNAINTR4 field.
	USB_DOEPINT4_BNAINTR4_Pos = 0x9
	// Bit mask of BNAINTR4 field.
	USB_DOEPINT4_BNAINTR4_Msk = 0x200
	// Bit BNAINTR4.
	USB_DOEPINT4_BNAINTR4 = 0x200
	// Position of PKTDRPSTS4 field.
	USB_DOEPINT4_PKTDRPSTS4_Pos = 0xb
	// Bit mask of PKTDRPSTS4 field.
	USB_DOEPINT4_PKTDRPSTS4_Msk = 0x800
	// Bit PKTDRPSTS4.
	USB_DOEPINT4_PKTDRPSTS4 = 0x800
	// Position of BBLEERR4 field.
	USB_DOEPINT4_BBLEERR4_Pos = 0xc
	// Bit mask of BBLEERR4 field.
	USB_DOEPINT4_BBLEERR4_Msk = 0x1000
	// Bit BBLEERR4.
	USB_DOEPINT4_BBLEERR4 = 0x1000
	// Position of NAKINTRPT4 field.
	USB_DOEPINT4_NAKINTRPT4_Pos = 0xd
	// Bit mask of NAKINTRPT4 field.
	USB_DOEPINT4_NAKINTRPT4_Msk = 0x2000
	// Bit NAKINTRPT4.
	USB_DOEPINT4_NAKINTRPT4 = 0x2000
	// Position of NYEPINTRPT4 field.
	USB_DOEPINT4_NYEPINTRPT4_Pos = 0xe
	// Bit mask of NYEPINTRPT4 field.
	USB_DOEPINT4_NYEPINTRPT4_Msk = 0x4000
	// Bit NYEPINTRPT4.
	USB_DOEPINT4_NYEPINTRPT4 = 0x4000
	// Position of STUPPKTRCVD4 field.
	USB_DOEPINT4_STUPPKTRCVD4_Pos = 0xf
	// Bit mask of STUPPKTRCVD4 field.
	USB_DOEPINT4_STUPPKTRCVD4_Msk = 0x8000
	// Bit STUPPKTRCVD4.
	USB_DOEPINT4_STUPPKTRCVD4 = 0x8000

	// DOEPTSIZ4
	// Position of XFERSIZE4 field.
	USB_DOEPTSIZ4_XFERSIZE4_Pos = 0x0
	// Bit mask of XFERSIZE4 field.
	USB_DOEPTSIZ4_XFERSIZE4_Msk = 0x7f
	// Position of PKTCNT4 field.
	USB_DOEPTSIZ4_PKTCNT4_Pos = 0x13
	// Bit mask of PKTCNT4 field.
	USB_DOEPTSIZ4_PKTCNT4_Msk = 0x80000
	// Bit PKTCNT4.
	USB_DOEPTSIZ4_PKTCNT4 = 0x80000
	// Position of SUPCNT4 field.
	USB_DOEPTSIZ4_SUPCNT4_Pos = 0x1d
	// Bit mask of SUPCNT4 field.
	USB_DOEPTSIZ4_SUPCNT4_Msk = 0x60000000

	// DOEPDMA4
	// Position of DMAADDR4 field.
	USB_DOEPDMA4_DMAADDR4_Pos = 0x0
	// Bit mask of DMAADDR4 field.
	USB_DOEPDMA4_DMAADDR4_Msk = 0xffffffff

	// DOEPDMAB4
	// Position of DMABUFFERADDR4 field.
	USB_DOEPDMAB4_DMABUFFERADDR4_Pos = 0x0
	// Bit mask of DMABUFFERADDR4 field.
	USB_DOEPDMAB4_DMABUFFERADDR4_Msk = 0xffffffff

	// DOEPCTL5
	// Position of MPS5 field.
	USB_DOEPCTL5_MPS5_Pos = 0x0
	// Bit mask of MPS5 field.
	USB_DOEPCTL5_MPS5_Msk = 0x7ff
	// Position of USBACTEP5 field.
	USB_DOEPCTL5_USBACTEP5_Pos = 0xf
	// Bit mask of USBACTEP5 field.
	USB_DOEPCTL5_USBACTEP5_Msk = 0x8000
	// Bit USBACTEP5.
	USB_DOEPCTL5_USBACTEP5 = 0x8000
	// Position of NAKSTS5 field.
	USB_DOEPCTL5_NAKSTS5_Pos = 0x11
	// Bit mask of NAKSTS5 field.
	USB_DOEPCTL5_NAKSTS5_Msk = 0x20000
	// Bit NAKSTS5.
	USB_DOEPCTL5_NAKSTS5 = 0x20000
	// Position of EPTYPE5 field.
	USB_DOEPCTL5_EPTYPE5_Pos = 0x12
	// Bit mask of EPTYPE5 field.
	USB_DOEPCTL5_EPTYPE5_Msk = 0xc0000
	// Position of SNP5 field.
	USB_DOEPCTL5_SNP5_Pos = 0x14
	// Bit mask of SNP5 field.
	USB_DOEPCTL5_SNP5_Msk = 0x100000
	// Bit SNP5.
	USB_DOEPCTL5_SNP5 = 0x100000
	// Position of STALL5 field.
	USB_DOEPCTL5_STALL5_Pos = 0x15
	// Bit mask of STALL5 field.
	USB_DOEPCTL5_STALL5_Msk = 0x200000
	// Bit STALL5.
	USB_DOEPCTL5_STALL5 = 0x200000
	// Position of CNAK5 field.
	USB_DOEPCTL5_CNAK5_Pos = 0x1a
	// Bit mask of CNAK5 field.
	USB_DOEPCTL5_CNAK5_Msk = 0x4000000
	// Bit CNAK5.
	USB_DOEPCTL5_CNAK5 = 0x4000000
	// Position of DO_SNAK5 field.
	USB_DOEPCTL5_DO_SNAK5_Pos = 0x1b
	// Bit mask of DO_SNAK5 field.
	USB_DOEPCTL5_DO_SNAK5_Msk = 0x8000000
	// Bit DO_SNAK5.
	USB_DOEPCTL5_DO_SNAK5 = 0x8000000
	// Position of DO_SETD0PID5 field.
	USB_DOEPCTL5_DO_SETD0PID5_Pos = 0x1c
	// Bit mask of DO_SETD0PID5 field.
	USB_DOEPCTL5_DO_SETD0PID5_Msk = 0x10000000
	// Bit DO_SETD0PID5.
	USB_DOEPCTL5_DO_SETD0PID5 = 0x10000000
	// Position of DO_SETD1PID5 field.
	USB_DOEPCTL5_DO_SETD1PID5_Pos = 0x1d
	// Bit mask of DO_SETD1PID5 field.
	USB_DOEPCTL5_DO_SETD1PID5_Msk = 0x20000000
	// Bit DO_SETD1PID5.
	USB_DOEPCTL5_DO_SETD1PID5 = 0x20000000
	// Position of EPDIS5 field.
	USB_DOEPCTL5_EPDIS5_Pos = 0x1e
	// Bit mask of EPDIS5 field.
	USB_DOEPCTL5_EPDIS5_Msk = 0x40000000
	// Bit EPDIS5.
	USB_DOEPCTL5_EPDIS5 = 0x40000000
	// Position of EPENA5 field.
	USB_DOEPCTL5_EPENA5_Pos = 0x1f
	// Bit mask of EPENA5 field.
	USB_DOEPCTL5_EPENA5_Msk = 0x80000000
	// Bit EPENA5.
	USB_DOEPCTL5_EPENA5 = 0x80000000

	// DOEPINT5
	// Position of XFERCOMPL5 field.
	USB_DOEPINT5_XFERCOMPL5_Pos = 0x0
	// Bit mask of XFERCOMPL5 field.
	USB_DOEPINT5_XFERCOMPL5_Msk = 0x1
	// Bit XFERCOMPL5.
	USB_DOEPINT5_XFERCOMPL5 = 0x1
	// Position of EPDISBLD5 field.
	USB_DOEPINT5_EPDISBLD5_Pos = 0x1
	// Bit mask of EPDISBLD5 field.
	USB_DOEPINT5_EPDISBLD5_Msk = 0x2
	// Bit EPDISBLD5.
	USB_DOEPINT5_EPDISBLD5 = 0x2
	// Position of AHBERR5 field.
	USB_DOEPINT5_AHBERR5_Pos = 0x2
	// Bit mask of AHBERR5 field.
	USB_DOEPINT5_AHBERR5_Msk = 0x4
	// Bit AHBERR5.
	USB_DOEPINT5_AHBERR5 = 0x4
	// Position of SETUP5 field.
	USB_DOEPINT5_SETUP5_Pos = 0x3
	// Bit mask of SETUP5 field.
	USB_DOEPINT5_SETUP5_Msk = 0x8
	// Bit SETUP5.
	USB_DOEPINT5_SETUP5 = 0x8
	// Position of OUTTKNEPDIS5 field.
	USB_DOEPINT5_OUTTKNEPDIS5_Pos = 0x4
	// Bit mask of OUTTKNEPDIS5 field.
	USB_DOEPINT5_OUTTKNEPDIS5_Msk = 0x10
	// Bit OUTTKNEPDIS5.
	USB_DOEPINT5_OUTTKNEPDIS5 = 0x10
	// Position of STSPHSERCVD5 field.
	USB_DOEPINT5_STSPHSERCVD5_Pos = 0x5
	// Bit mask of STSPHSERCVD5 field.
	USB_DOEPINT5_STSPHSERCVD5_Msk = 0x20
	// Bit STSPHSERCVD5.
	USB_DOEPINT5_STSPHSERCVD5 = 0x20
	// Position of BACK2BACKSETUP5 field.
	USB_DOEPINT5_BACK2BACKSETUP5_Pos = 0x6
	// Bit mask of BACK2BACKSETUP5 field.
	USB_DOEPINT5_BACK2BACKSETUP5_Msk = 0x40
	// Bit BACK2BACKSETUP5.
	USB_DOEPINT5_BACK2BACKSETUP5 = 0x40
	// Position of OUTPKTERR5 field.
	USB_DOEPINT5_OUTPKTERR5_Pos = 0x8
	// Bit mask of OUTPKTERR5 field.
	USB_DOEPINT5_OUTPKTERR5_Msk = 0x100
	// Bit OUTPKTERR5.
	USB_DOEPINT5_OUTPKTERR5 = 0x100
	// Position of BNAINTR5 field.
	USB_DOEPINT5_BNAINTR5_Pos = 0x9
	// Bit mask of BNAINTR5 field.
	USB_DOEPINT5_BNAINTR5_Msk = 0x200
	// Bit BNAINTR5.
	USB_DOEPINT5_BNAINTR5 = 0x200
	// Position of PKTDRPSTS5 field.
	USB_DOEPINT5_PKTDRPSTS5_Pos = 0xb
	// Bit mask of PKTDRPSTS5 field.
	USB_DOEPINT5_PKTDRPSTS5_Msk = 0x800
	// Bit PKTDRPSTS5.
	USB_DOEPINT5_PKTDRPSTS5 = 0x800
	// Position of BBLEERR5 field.
	USB_DOEPINT5_BBLEERR5_Pos = 0xc
	// Bit mask of BBLEERR5 field.
	USB_DOEPINT5_BBLEERR5_Msk = 0x1000
	// Bit BBLEERR5.
	USB_DOEPINT5_BBLEERR5 = 0x1000
	// Position of NAKINTRPT5 field.
	USB_DOEPINT5_NAKINTRPT5_Pos = 0xd
	// Bit mask of NAKINTRPT5 field.
	USB_DOEPINT5_NAKINTRPT5_Msk = 0x2000
	// Bit NAKINTRPT5.
	USB_DOEPINT5_NAKINTRPT5 = 0x2000
	// Position of NYEPINTRPT5 field.
	USB_DOEPINT5_NYEPINTRPT5_Pos = 0xe
	// Bit mask of NYEPINTRPT5 field.
	USB_DOEPINT5_NYEPINTRPT5_Msk = 0x4000
	// Bit NYEPINTRPT5.
	USB_DOEPINT5_NYEPINTRPT5 = 0x4000
	// Position of STUPPKTRCVD5 field.
	USB_DOEPINT5_STUPPKTRCVD5_Pos = 0xf
	// Bit mask of STUPPKTRCVD5 field.
	USB_DOEPINT5_STUPPKTRCVD5_Msk = 0x8000
	// Bit STUPPKTRCVD5.
	USB_DOEPINT5_STUPPKTRCVD5 = 0x8000

	// DOEPTSIZ5
	// Position of XFERSIZE5 field.
	USB_DOEPTSIZ5_XFERSIZE5_Pos = 0x0
	// Bit mask of XFERSIZE5 field.
	USB_DOEPTSIZ5_XFERSIZE5_Msk = 0x7f
	// Position of PKTCNT5 field.
	USB_DOEPTSIZ5_PKTCNT5_Pos = 0x13
	// Bit mask of PKTCNT5 field.
	USB_DOEPTSIZ5_PKTCNT5_Msk = 0x80000
	// Bit PKTCNT5.
	USB_DOEPTSIZ5_PKTCNT5 = 0x80000
	// Position of SUPCNT5 field.
	USB_DOEPTSIZ5_SUPCNT5_Pos = 0x1d
	// Bit mask of SUPCNT5 field.
	USB_DOEPTSIZ5_SUPCNT5_Msk = 0x60000000

	// DOEPDMA5
	// Position of DMAADDR5 field.
	USB_DOEPDMA5_DMAADDR5_Pos = 0x0
	// Bit mask of DMAADDR5 field.
	USB_DOEPDMA5_DMAADDR5_Msk = 0xffffffff

	// DOEPDMAB5
	// Position of DMABUFFERADDR5 field.
	USB_DOEPDMAB5_DMABUFFERADDR5_Pos = 0x0
	// Bit mask of DMABUFFERADDR5 field.
	USB_DOEPDMAB5_DMABUFFERADDR5_Msk = 0xffffffff

	// DOEPCTL6
	// Position of MPS6 field.
	USB_DOEPCTL6_MPS6_Pos = 0x0
	// Bit mask of MPS6 field.
	USB_DOEPCTL6_MPS6_Msk = 0x7ff
	// Position of USBACTEP6 field.
	USB_DOEPCTL6_USBACTEP6_Pos = 0xf
	// Bit mask of USBACTEP6 field.
	USB_DOEPCTL6_USBACTEP6_Msk = 0x8000
	// Bit USBACTEP6.
	USB_DOEPCTL6_USBACTEP6 = 0x8000
	// Position of NAKSTS6 field.
	USB_DOEPCTL6_NAKSTS6_Pos = 0x11
	// Bit mask of NAKSTS6 field.
	USB_DOEPCTL6_NAKSTS6_Msk = 0x20000
	// Bit NAKSTS6.
	USB_DOEPCTL6_NAKSTS6 = 0x20000
	// Position of EPTYPE6 field.
	USB_DOEPCTL6_EPTYPE6_Pos = 0x12
	// Bit mask of EPTYPE6 field.
	USB_DOEPCTL6_EPTYPE6_Msk = 0xc0000
	// Position of SNP6 field.
	USB_DOEPCTL6_SNP6_Pos = 0x14
	// Bit mask of SNP6 field.
	USB_DOEPCTL6_SNP6_Msk = 0x100000
	// Bit SNP6.
	USB_DOEPCTL6_SNP6 = 0x100000
	// Position of STALL6 field.
	USB_DOEPCTL6_STALL6_Pos = 0x15
	// Bit mask of STALL6 field.
	USB_DOEPCTL6_STALL6_Msk = 0x200000
	// Bit STALL6.
	USB_DOEPCTL6_STALL6 = 0x200000
	// Position of CNAK6 field.
	USB_DOEPCTL6_CNAK6_Pos = 0x1a
	// Bit mask of CNAK6 field.
	USB_DOEPCTL6_CNAK6_Msk = 0x4000000
	// Bit CNAK6.
	USB_DOEPCTL6_CNAK6 = 0x4000000
	// Position of DO_SNAK6 field.
	USB_DOEPCTL6_DO_SNAK6_Pos = 0x1b
	// Bit mask of DO_SNAK6 field.
	USB_DOEPCTL6_DO_SNAK6_Msk = 0x8000000
	// Bit DO_SNAK6.
	USB_DOEPCTL6_DO_SNAK6 = 0x8000000
	// Position of DO_SETD0PID6 field.
	USB_DOEPCTL6_DO_SETD0PID6_Pos = 0x1c
	// Bit mask of DO_SETD0PID6 field.
	USB_DOEPCTL6_DO_SETD0PID6_Msk = 0x10000000
	// Bit DO_SETD0PID6.
	USB_DOEPCTL6_DO_SETD0PID6 = 0x10000000
	// Position of DO_SETD1PID6 field.
	USB_DOEPCTL6_DO_SETD1PID6_Pos = 0x1d
	// Bit mask of DO_SETD1PID6 field.
	USB_DOEPCTL6_DO_SETD1PID6_Msk = 0x20000000
	// Bit DO_SETD1PID6.
	USB_DOEPCTL6_DO_SETD1PID6 = 0x20000000
	// Position of EPDIS6 field.
	USB_DOEPCTL6_EPDIS6_Pos = 0x1e
	// Bit mask of EPDIS6 field.
	USB_DOEPCTL6_EPDIS6_Msk = 0x40000000
	// Bit EPDIS6.
	USB_DOEPCTL6_EPDIS6 = 0x40000000
	// Position of EPENA6 field.
	USB_DOEPCTL6_EPENA6_Pos = 0x1f
	// Bit mask of EPENA6 field.
	USB_DOEPCTL6_EPENA6_Msk = 0x80000000
	// Bit EPENA6.
	USB_DOEPCTL6_EPENA6 = 0x80000000

	// DOEPINT6
	// Position of XFERCOMPL6 field.
	USB_DOEPINT6_XFERCOMPL6_Pos = 0x0
	// Bit mask of XFERCOMPL6 field.
	USB_DOEPINT6_XFERCOMPL6_Msk = 0x1
	// Bit XFERCOMPL6.
	USB_DOEPINT6_XFERCOMPL6 = 0x1
	// Position of EPDISBLD6 field.
	USB_DOEPINT6_EPDISBLD6_Pos = 0x1
	// Bit mask of EPDISBLD6 field.
	USB_DOEPINT6_EPDISBLD6_Msk = 0x2
	// Bit EPDISBLD6.
	USB_DOEPINT6_EPDISBLD6 = 0x2
	// Position of AHBERR6 field.
	USB_DOEPINT6_AHBERR6_Pos = 0x2
	// Bit mask of AHBERR6 field.
	USB_DOEPINT6_AHBERR6_Msk = 0x4
	// Bit AHBERR6.
	USB_DOEPINT6_AHBERR6 = 0x4
	// Position of SETUP6 field.
	USB_DOEPINT6_SETUP6_Pos = 0x3
	// Bit mask of SETUP6 field.
	USB_DOEPINT6_SETUP6_Msk = 0x8
	// Bit SETUP6.
	USB_DOEPINT6_SETUP6 = 0x8
	// Position of OUTTKNEPDIS6 field.
	USB_DOEPINT6_OUTTKNEPDIS6_Pos = 0x4
	// Bit mask of OUTTKNEPDIS6 field.
	USB_DOEPINT6_OUTTKNEPDIS6_Msk = 0x10
	// Bit OUTTKNEPDIS6.
	USB_DOEPINT6_OUTTKNEPDIS6 = 0x10
	// Position of STSPHSERCVD6 field.
	USB_DOEPINT6_STSPHSERCVD6_Pos = 0x5
	// Bit mask of STSPHSERCVD6 field.
	USB_DOEPINT6_STSPHSERCVD6_Msk = 0x20
	// Bit STSPHSERCVD6.
	USB_DOEPINT6_STSPHSERCVD6 = 0x20
	// Position of BACK2BACKSETUP6 field.
	USB_DOEPINT6_BACK2BACKSETUP6_Pos = 0x6
	// Bit mask of BACK2BACKSETUP6 field.
	USB_DOEPINT6_BACK2BACKSETUP6_Msk = 0x40
	// Bit BACK2BACKSETUP6.
	USB_DOEPINT6_BACK2BACKSETUP6 = 0x40
	// Position of OUTPKTERR6 field.
	USB_DOEPINT6_OUTPKTERR6_Pos = 0x8
	// Bit mask of OUTPKTERR6 field.
	USB_DOEPINT6_OUTPKTERR6_Msk = 0x100
	// Bit OUTPKTERR6.
	USB_DOEPINT6_OUTPKTERR6 = 0x100
	// Position of BNAINTR6 field.
	USB_DOEPINT6_BNAINTR6_Pos = 0x9
	// Bit mask of BNAINTR6 field.
	USB_DOEPINT6_BNAINTR6_Msk = 0x200
	// Bit BNAINTR6.
	USB_DOEPINT6_BNAINTR6 = 0x200
	// Position of PKTDRPSTS6 field.
	USB_DOEPINT6_PKTDRPSTS6_Pos = 0xb
	// Bit mask of PKTDRPSTS6 field.
	USB_DOEPINT6_PKTDRPSTS6_Msk = 0x800
	// Bit PKTDRPSTS6.
	USB_DOEPINT6_PKTDRPSTS6 = 0x800
	// Position of BBLEERR6 field.
	USB_DOEPINT6_BBLEERR6_Pos = 0xc
	// Bit mask of BBLEERR6 field.
	USB_DOEPINT6_BBLEERR6_Msk = 0x1000
	// Bit BBLEERR6.
	USB_DOEPINT6_BBLEERR6 = 0x1000
	// Position of NAKINTRPT6 field.
	USB_DOEPINT6_NAKINTRPT6_Pos = 0xd
	// Bit mask of NAKINTRPT6 field.
	USB_DOEPINT6_NAKINTRPT6_Msk = 0x2000
	// Bit NAKINTRPT6.
	USB_DOEPINT6_NAKINTRPT6 = 0x2000
	// Position of NYEPINTRPT6 field.
	USB_DOEPINT6_NYEPINTRPT6_Pos = 0xe
	// Bit mask of NYEPINTRPT6 field.
	USB_DOEPINT6_NYEPINTRPT6_Msk = 0x4000
	// Bit NYEPINTRPT6.
	USB_DOEPINT6_NYEPINTRPT6 = 0x4000
	// Position of STUPPKTRCVD6 field.
	USB_DOEPINT6_STUPPKTRCVD6_Pos = 0xf
	// Bit mask of STUPPKTRCVD6 field.
	USB_DOEPINT6_STUPPKTRCVD6_Msk = 0x8000
	// Bit STUPPKTRCVD6.
	USB_DOEPINT6_STUPPKTRCVD6 = 0x8000

	// DOEPTSIZ6
	// Position of XFERSIZE6 field.
	USB_DOEPTSIZ6_XFERSIZE6_Pos = 0x0
	// Bit mask of XFERSIZE6 field.
	USB_DOEPTSIZ6_XFERSIZE6_Msk = 0x7f
	// Position of PKTCNT6 field.
	USB_DOEPTSIZ6_PKTCNT6_Pos = 0x13
	// Bit mask of PKTCNT6 field.
	USB_DOEPTSIZ6_PKTCNT6_Msk = 0x80000
	// Bit PKTCNT6.
	USB_DOEPTSIZ6_PKTCNT6 = 0x80000
	// Position of SUPCNT6 field.
	USB_DOEPTSIZ6_SUPCNT6_Pos = 0x1d
	// Bit mask of SUPCNT6 field.
	USB_DOEPTSIZ6_SUPCNT6_Msk = 0x60000000

	// DOEPDMA6
	// Position of DMAADDR6 field.
	USB_DOEPDMA6_DMAADDR6_Pos = 0x0
	// Bit mask of DMAADDR6 field.
	USB_DOEPDMA6_DMAADDR6_Msk = 0xffffffff

	// DOEPDMAB6
	// Position of DMABUFFERADDR6 field.
	USB_DOEPDMAB6_DMABUFFERADDR6_Pos = 0x0
	// Bit mask of DMABUFFERADDR6 field.
	USB_DOEPDMAB6_DMABUFFERADDR6_Msk = 0xffffffff

	// PCGCCTL
	// Position of STOPPCLK field.
	USB_PCGCCTL_STOPPCLK_Pos = 0x0
	// Bit mask of STOPPCLK field.
	USB_PCGCCTL_STOPPCLK_Msk = 0x1
	// Bit STOPPCLK.
	USB_PCGCCTL_STOPPCLK = 0x1
	// Position of GATEHCLK field.
	USB_PCGCCTL_GATEHCLK_Pos = 0x1
	// Bit mask of GATEHCLK field.
	USB_PCGCCTL_GATEHCLK_Msk = 0x2
	// Bit GATEHCLK.
	USB_PCGCCTL_GATEHCLK = 0x2
	// Position of PWRCLMP field.
	USB_PCGCCTL_PWRCLMP_Pos = 0x2
	// Bit mask of PWRCLMP field.
	USB_PCGCCTL_PWRCLMP_Msk = 0x4
	// Bit PWRCLMP.
	USB_PCGCCTL_PWRCLMP = 0x4
	// Position of RSTPDWNMODULE field.
	USB_PCGCCTL_RSTPDWNMODULE_Pos = 0x3
	// Bit mask of RSTPDWNMODULE field.
	USB_PCGCCTL_RSTPDWNMODULE_Msk = 0x8
	// Bit RSTPDWNMODULE.
	USB_PCGCCTL_RSTPDWNMODULE = 0x8
	// Position of PHYSLEEP field.
	USB_PCGCCTL_PHYSLEEP_Pos = 0x6
	// Bit mask of PHYSLEEP field.
	USB_PCGCCTL_PHYSLEEP_Msk = 0x40
	// Bit PHYSLEEP.
	USB_PCGCCTL_PHYSLEEP = 0x40
	// Position of L1SUSPENDED field.
	USB_PCGCCTL_L1SUSPENDED_Pos = 0x7
	// Bit mask of L1SUSPENDED field.
	USB_PCGCCTL_L1SUSPENDED_Msk = 0x80
	// Bit L1SUSPENDED.
	USB_PCGCCTL_L1SUSPENDED = 0x80
	// Position of RESETAFTERSUSP field.
	USB_PCGCCTL_RESETAFTERSUSP_Pos = 0x8
	// Bit mask of RESETAFTERSUSP field.
	USB_PCGCCTL_RESETAFTERSUSP_Msk = 0x100
	// Bit RESETAFTERSUSP.
	USB_PCGCCTL_RESETAFTERSUSP = 0x100
)

// Constants for USB_WRAP: USB_WRAP Peripheral
const (
	// OTG_CONF: USB OTG Wrapper Configure Register
	// Position of SRP_SESSEND_OVERRIDE field.
	USB_WRAP_OTG_CONF_SRP_SESSEND_OVERRIDE_Pos = 0x0
	// Bit mask of SRP_SESSEND_OVERRIDE field.
	USB_WRAP_OTG_CONF_SRP_SESSEND_OVERRIDE_Msk = 0x1
	// Bit SRP_SESSEND_OVERRIDE.
	USB_WRAP_OTG_CONF_SRP_SESSEND_OVERRIDE = 0x1
	// Position of SRP_SESSEND_VALUE field.
	USB_WRAP_OTG_CONF_SRP_SESSEND_VALUE_Pos = 0x1
	// Bit mask of SRP_SESSEND_VALUE field.
	USB_WRAP_OTG_CONF_SRP_SESSEND_VALUE_Msk = 0x2
	// Bit SRP_SESSEND_VALUE.
	USB_WRAP_OTG_CONF_SRP_SESSEND_VALUE = 0x2
	// Position of PHY_SEL field.
	USB_WRAP_OTG_CONF_PHY_SEL_Pos = 0x2
	// Bit mask of PHY_SEL field.
	USB_WRAP_OTG_CONF_PHY_SEL_Msk = 0x4
	// Bit PHY_SEL.
	USB_WRAP_OTG_CONF_PHY_SEL = 0x4
	// Position of DFIFO_FORCE_PD field.
	USB_WRAP_OTG_CONF_DFIFO_FORCE_PD_Pos = 0x3
	// Bit mask of DFIFO_FORCE_PD field.
	USB_WRAP_OTG_CONF_DFIFO_FORCE_PD_Msk = 0x8
	// Bit DFIFO_FORCE_PD.
	USB_WRAP_OTG_CONF_DFIFO_FORCE_PD = 0x8
	// Position of DBNCE_FLTR_BYPASS field.
	USB_WRAP_OTG_CONF_DBNCE_FLTR_BYPASS_Pos = 0x4
	// Bit mask of DBNCE_FLTR_BYPASS field.
	USB_WRAP_OTG_CONF_DBNCE_FLTR_BYPASS_Msk = 0x10
	// Bit DBNCE_FLTR_BYPASS.
	USB_WRAP_OTG_CONF_DBNCE_FLTR_BYPASS = 0x10
	// Position of EXCHG_PINS_OVERRIDE field.
	USB_WRAP_OTG_CONF_EXCHG_PINS_OVERRIDE_Pos = 0x5
	// Bit mask of EXCHG_PINS_OVERRIDE field.
	USB_WRAP_OTG_CONF_EXCHG_PINS_OVERRIDE_Msk = 0x20
	// Bit EXCHG_PINS_OVERRIDE.
	USB_WRAP_OTG_CONF_EXCHG_PINS_OVERRIDE = 0x20
	// Position of EXCHG_PINS field.
	USB_WRAP_OTG_CONF_EXCHG_PINS_Pos = 0x6
	// Bit mask of EXCHG_PINS field.
	USB_WRAP_OTG_CONF_EXCHG_PINS_Msk = 0x40
	// Bit EXCHG_PINS.
	USB_WRAP_OTG_CONF_EXCHG_PINS = 0x40
	// Position of VREFH field.
	USB_WRAP_OTG_CONF_VREFH_Pos = 0x7
	// Bit mask of VREFH field.
	USB_WRAP_OTG_CONF_VREFH_Msk = 0x180
	// Position of VREFL field.
	USB_WRAP_OTG_CONF_VREFL_Pos = 0x9
	// Bit mask of VREFL field.
	USB_WRAP_OTG_CONF_VREFL_Msk = 0x600
	// Position of VREF_OVERRIDE field.
	USB_WRAP_OTG_CONF_VREF_OVERRIDE_Pos = 0xb
	// Bit mask of VREF_OVERRIDE field.
	USB_WRAP_OTG_CONF_VREF_OVERRIDE_Msk = 0x800
	// Bit VREF_OVERRIDE.
	USB_WRAP_OTG_CONF_VREF_OVERRIDE = 0x800
	// Position of PAD_PULL_OVERRIDE field.
	USB_WRAP_OTG_CONF_PAD_PULL_OVERRIDE_Pos = 0xc
	// Bit mask of PAD_PULL_OVERRIDE field.
	USB_WRAP_OTG_CONF_PAD_PULL_OVERRIDE_Msk = 0x1000
	// Bit PAD_PULL_OVERRIDE.
	USB_WRAP_OTG_CONF_PAD_PULL_OVERRIDE = 0x1000
	// Position of DP_PULLUP field.
	USB_WRAP_OTG_CONF_DP_PULLUP_Pos = 0xd
	// Bit mask of DP_PULLUP field.
	USB_WRAP_OTG_CONF_DP_PULLUP_Msk = 0x2000
	// Bit DP_PULLUP.
	USB_WRAP_OTG_CONF_DP_PULLUP = 0x2000
	// Position of DP_PULLDOWN field.
	USB_WRAP_OTG_CONF_DP_PULLDOWN_Pos = 0xe
	// Bit mask of DP_PULLDOWN field.
	USB_WRAP_OTG_CONF_DP_PULLDOWN_Msk = 0x4000
	// Bit DP_PULLDOWN.
	USB_WRAP_OTG_CONF_DP_PULLDOWN = 0x4000
	// Position of DM_PULLUP field.
	USB_WRAP_OTG_CONF_DM_PULLUP_Pos = 0xf
	// Bit mask of DM_PULLUP field.
	USB_WRAP_OTG_CONF_DM_PULLUP_Msk = 0x8000
	// Bit DM_PULLUP.
	USB_WRAP_OTG_CONF_DM_PULLUP = 0x8000
	// Position of DM_PULLDOWN field.
	USB_WRAP_OTG_CONF_DM_PULLDOWN_Pos = 0x10
	// Bit mask of DM_PULLDOWN field.
	USB_WRAP_OTG_CONF_DM_PULLDOWN_Msk = 0x10000
	// Bit DM_PULLDOWN.
	USB_WRAP_OTG_CONF_DM_PULLDOWN = 0x10000
	// Position of PULLUP_VALUE field.
	USB_WRAP_OTG_CONF_PULLUP_VALUE_Pos = 0x11
	// Bit mask of PULLUP_VALUE field.
	USB_WRAP_OTG_CONF_PULLUP_VALUE_Msk = 0x20000
	// Bit PULLUP_VALUE.
	USB_WRAP_OTG_CONF_PULLUP_VALUE = 0x20000
	// Position of USB_PAD_ENABLE field.
	USB_WRAP_OTG_CONF_USB_PAD_ENABLE_Pos = 0x12
	// Bit mask of USB_PAD_ENABLE field.
	USB_WRAP_OTG_CONF_USB_PAD_ENABLE_Msk = 0x40000
	// Bit USB_PAD_ENABLE.
	USB_WRAP_OTG_CONF_USB_PAD_ENABLE = 0x40000
	// Position of AHB_CLK_FORCE_ON field.
	USB_WRAP_OTG_CONF_AHB_CLK_FORCE_ON_Pos = 0x13
	// Bit mask of AHB_CLK_FORCE_ON field.
	USB_WRAP_OTG_CONF_AHB_CLK_FORCE_ON_Msk = 0x80000
	// Bit AHB_CLK_FORCE_ON.
	USB_WRAP_OTG_CONF_AHB_CLK_FORCE_ON = 0x80000
	// Position of PHY_CLK_FORCE_ON field.
	USB_WRAP_OTG_CONF_PHY_CLK_FORCE_ON_Pos = 0x14
	// Bit mask of PHY_CLK_FORCE_ON field.
	USB_WRAP_OTG_CONF_PHY_CLK_FORCE_ON_Msk = 0x100000
	// Bit PHY_CLK_FORCE_ON.
	USB_WRAP_OTG_CONF_PHY_CLK_FORCE_ON = 0x100000
	// Position of PHY_TX_EDGE_SEL field.
	USB_WRAP_OTG_CONF_PHY_TX_EDGE_SEL_Pos = 0x15
	// Bit mask of PHY_TX_EDGE_SEL field.
	USB_WRAP_OTG_CONF_PHY_TX_EDGE_SEL_Msk = 0x200000
	// Bit PHY_TX_EDGE_SEL.
	USB_WRAP_OTG_CONF_PHY_TX_EDGE_SEL = 0x200000
	// Position of DFIFO_FORCE_PU field.
	USB_WRAP_OTG_CONF_DFIFO_FORCE_PU_Pos = 0x16
	// Bit mask of DFIFO_FORCE_PU field.
	USB_WRAP_OTG_CONF_DFIFO_FORCE_PU_Msk = 0x400000
	// Bit DFIFO_FORCE_PU.
	USB_WRAP_OTG_CONF_DFIFO_FORCE_PU = 0x400000
	// Position of CLK_EN field.
	USB_WRAP_OTG_CONF_CLK_EN_Pos = 0x1f
	// Bit mask of CLK_EN field.
	USB_WRAP_OTG_CONF_CLK_EN_Msk = 0x80000000
	// Bit CLK_EN.
	USB_WRAP_OTG_CONF_CLK_EN = 0x80000000

	// TEST_CONF: USB Internal PHY Testing Register
	// Position of TEST_ENABLE field.
	USB_WRAP_TEST_CONF_TEST_ENABLE_Pos = 0x0
	// Bit mask of TEST_ENABLE field.
	USB_WRAP_TEST_CONF_TEST_ENABLE_Msk = 0x1
	// Bit TEST_ENABLE.
	USB_WRAP_TEST_CONF_TEST_ENABLE = 0x1
	// Position of TEST_USB_OE field.
	USB_WRAP_TEST_CONF_TEST_USB_OE_Pos = 0x1
	// Bit mask of TEST_USB_OE field.
	USB_WRAP_TEST_CONF_TEST_USB_OE_Msk = 0x2
	// Bit TEST_USB_OE.
	USB_WRAP_TEST_CONF_TEST_USB_OE = 0x2
	// Position of TEST_TX_DP field.
	USB_WRAP_TEST_CONF_TEST_TX_DP_Pos = 0x2
	// Bit mask of TEST_TX_DP field.
	USB_WRAP_TEST_CONF_TEST_TX_DP_Msk = 0x4
	// Bit TEST_TX_DP.
	USB_WRAP_TEST_CONF_TEST_TX_DP = 0x4
	// Position of TEST_TX_DM field.
	USB_WRAP_TEST_CONF_TEST_TX_DM_Pos = 0x3
	// Bit mask of TEST_TX_DM field.
	USB_WRAP_TEST_CONF_TEST_TX_DM_Msk = 0x8
	// Bit TEST_TX_DM.
	USB_WRAP_TEST_CONF_TEST_TX_DM = 0x8
	// Position of TEST_RX_RCV field.
	USB_WRAP_TEST_CONF_TEST_RX_RCV_Pos = 0x4
	// Bit mask of TEST_RX_RCV field.
	USB_WRAP_TEST_CONF_TEST_RX_RCV_Msk = 0x10
	// Bit TEST_RX_RCV.
	USB_WRAP_TEST_CONF_TEST_RX_RCV = 0x10
	// Position of TEST_RX_DP field.
	USB_WRAP_TEST_CONF_TEST_RX_DP_Pos = 0x5
	// Bit mask of TEST_RX_DP field.
	USB_WRAP_TEST_CONF_TEST_RX_DP_Msk = 0x20
	// Bit TEST_RX_DP.
	USB_WRAP_TEST_CONF_TEST_RX_DP = 0x20
	// Position of TEST_RX_DM field.
	USB_WRAP_TEST_CONF_TEST_RX_DM_Pos = 0x6
	// Bit mask of TEST_RX_DM field.
	USB_WRAP_TEST_CONF_TEST_RX_DM_Msk = 0x40
	// Bit TEST_RX_DM.
	USB_WRAP_TEST_CONF_TEST_RX_DM = 0x40

	// DATE: Version Control Register
	// Position of USB_WRAP_DATE field.
	USB_WRAP_DATE_USB_WRAP_DATE_Pos = 0x0
	// Bit mask of USB_WRAP_DATE field.
	USB_WRAP_DATE_USB_WRAP_DATE_Msk = 0xffffffff
)

// Constants for XTS_AES: XTS-AES-128 Flash Encryption
const (
	// PLAIN_0: Plaintext register %s
	// Position of PLAIN field.
	XTS_AES_PLAIN_PLAIN_Pos = 0x0
	// Bit mask of PLAIN field.
	XTS_AES_PLAIN_PLAIN_Msk = 0xffffffff

	// LINESIZE: Configures the size of target memory space
	// Position of LINESIZE field.
	XTS_AES_LINESIZE_LINESIZE_Pos = 0x0
	// Bit mask of LINESIZE field.
	XTS_AES_LINESIZE_LINESIZE_Msk = 0x3

	// DESTINATION: Configures the type of the external memory
	// Position of DESTINATION field.
	XTS_AES_DESTINATION_DESTINATION_Pos = 0x0
	// Bit mask of DESTINATION field.
	XTS_AES_DESTINATION_DESTINATION_Msk = 0x1
	// Bit DESTINATION.
	XTS_AES_DESTINATION_DESTINATION = 0x1

	// PHYSICAL_ADDRESS: Physical address
	// Position of PHYSICAL_ADDRESS field.
	XTS_AES_PHYSICAL_ADDRESS_PHYSICAL_ADDRESS_Pos = 0x0
	// Bit mask of PHYSICAL_ADDRESS field.
	XTS_AES_PHYSICAL_ADDRESS_PHYSICAL_ADDRESS_Msk = 0x3fffffff

	// TRIGGER: Activates AES algorithm
	// Position of TRIGGER field.
	XTS_AES_TRIGGER_TRIGGER_Pos = 0x0
	// Bit mask of TRIGGER field.
	XTS_AES_TRIGGER_TRIGGER_Msk = 0x1
	// Bit TRIGGER.
	XTS_AES_TRIGGER_TRIGGER = 0x1

	// RELEASE: Release control
	// Position of RELEASE field.
	XTS_AES_RELEASE_RELEASE_Pos = 0x0
	// Bit mask of RELEASE field.
	XTS_AES_RELEASE_RELEASE_Msk = 0x1
	// Bit RELEASE.
	XTS_AES_RELEASE_RELEASE = 0x1

	// DESTROY: Destroys control
	// Position of DESTROY field.
	XTS_AES_DESTROY_DESTROY_Pos = 0x0
	// Bit mask of DESTROY field.
	XTS_AES_DESTROY_DESTROY_Msk = 0x1
	// Bit DESTROY.
	XTS_AES_DESTROY_DESTROY = 0x1

	// STATE: Status register
	// Position of STATE field.
	XTS_AES_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	XTS_AES_STATE_STATE_Msk = 0x3

	// DATE: Version control register
	// Position of DATE field.
	XTS_AES_DATE_DATE_Pos = 0x0
	// Bit mask of DATE field.
	XTS_AES_DATE_DATE_Msk = 0x3fffffff
)
