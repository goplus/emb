// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from esp8266.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Espressif-Community

//go:build esp && esp8266

/*

 */

package esp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "esp8266"
	CPU          = "Xtensa LX106"
	FPUPresent   = true
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Highest interrupt number on this device.
	IRQ_max = 0
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)
func HandleInterrupt(num int) {
	switch num {
	}
}

// Peripherals.
var (
	DPORT = (*DPORT_Type)(unsafe.Pointer(uintptr(0x3ff00000)))

	EFUSE = (*EFUSE_Type)(unsafe.Pointer(uintptr(0x3ff00050)))

	GPIO = (*GPIO_Type)(unsafe.Pointer(uintptr(0x60000300)))

	I2S = (*I2S_Type)(unsafe.Pointer(uintptr(0x60000e00)))

	IO_MUX = (*IO_MUX_Type)(unsafe.Pointer(uintptr(0x60000800)))

	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x60000700)))

	SLC = (*SLC_Type)(unsafe.Pointer(uintptr(0x60000b00)))

	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x60000200)))

	SPI1 = (*SPI1_Type)(unsafe.Pointer(uintptr(0x60000100)))

	TIMER = (*TIMER_Type)(unsafe.Pointer(uintptr(0x60000600)))

	UART0 = (*UART0_Type)(unsafe.Pointer(uintptr(0x60000000)))

	UART1 = (*UART1_Type)(unsafe.Pointer(uintptr(0x60000f00)))

	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x60000900)))

	// RNG register
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x3ff20e44)))

	// Watchdog registers
	WATCHDOG = (*WATCHDOG_Type)(unsafe.Pointer(uintptr(0x60000900)))
)

type DPORT_Type struct {
	_               [4]byte
	EDGE_INT_ENABLE volatile.Register32 // 0x4
	_               [12]byte
	DPORT_CTL       volatile.Register32 // 0x14
}

// DPORT.EDGE_INT_ENABLE: EDGE_INT_ENABLE
func (o *DPORT_Type) SetEDGE_INT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.EDGE_INT_ENABLE.Reg, value)
}
func (o *DPORT_Type) GetEDGE_INT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.EDGE_INT_ENABLE.Reg)
}
func (o *DPORT_Type) SetEDGE_INT_ENABLE_WDT_EDGE_INT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.EDGE_INT_ENABLE.Reg, volatile.LoadUint32(&o.EDGE_INT_ENABLE.Reg)&^(0x1)|value)
}
func (o *DPORT_Type) GetEDGE_INT_ENABLE_WDT_EDGE_INT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.EDGE_INT_ENABLE.Reg) & 0x1
}
func (o *DPORT_Type) SetEDGE_INT_ENABLE_TIMER1_EDGE_INT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.EDGE_INT_ENABLE.Reg, volatile.LoadUint32(&o.EDGE_INT_ENABLE.Reg)&^(0x2)|value<<1)
}
func (o *DPORT_Type) GetEDGE_INT_ENABLE_TIMER1_EDGE_INT_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.EDGE_INT_ENABLE.Reg) & 0x2) >> 1
}

// DPORT.DPORT_CTL: DPORT_CTL
func (o *DPORT_Type) SetDPORT_CTL_DPORT_CTL_DOUBLE_CLK(value uint32) {
	volatile.StoreUint32(&o.DPORT_CTL.Reg, volatile.LoadUint32(&o.DPORT_CTL.Reg)&^(0x1)|value)
}
func (o *DPORT_Type) GetDPORT_CTL_DPORT_CTL_DOUBLE_CLK() uint32 {
	return volatile.LoadUint32(&o.DPORT_CTL.Reg) & 0x1
}

type EFUSE_Type struct {
	EFUSE_DATA0 volatile.Register32 // 0x0
	EFUSE_DATA1 volatile.Register32 // 0x4
	EFUSE_DATA2 volatile.Register32 // 0x8
	EFUSE_DATA3 volatile.Register32 // 0xC
}

// EFUSE.EFUSE_DATA0: EFUSE_DATA0
func (o *EFUSE_Type) SetEFUSE_DATA0(value uint32) {
	volatile.StoreUint32(&o.EFUSE_DATA0.Reg, value)
}
func (o *EFUSE_Type) GetEFUSE_DATA0() uint32 {
	return volatile.LoadUint32(&o.EFUSE_DATA0.Reg)
}

// EFUSE.EFUSE_DATA1: EFUSE_DATA1
func (o *EFUSE_Type) SetEFUSE_DATA1(value uint32) {
	volatile.StoreUint32(&o.EFUSE_DATA1.Reg, value)
}
func (o *EFUSE_Type) GetEFUSE_DATA1() uint32 {
	return volatile.LoadUint32(&o.EFUSE_DATA1.Reg)
}

// EFUSE.EFUSE_DATA2: EFUSE_DATA2
func (o *EFUSE_Type) SetEFUSE_DATA2(value uint32) {
	volatile.StoreUint32(&o.EFUSE_DATA2.Reg, value)
}
func (o *EFUSE_Type) GetEFUSE_DATA2() uint32 {
	return volatile.LoadUint32(&o.EFUSE_DATA2.Reg)
}

// EFUSE.EFUSE_DATA3: EFUSE_DATA3
func (o *EFUSE_Type) SetEFUSE_DATA3(value uint32) {
	volatile.StoreUint32(&o.EFUSE_DATA3.Reg, value)
}
func (o *EFUSE_Type) GetEFUSE_DATA3() uint32 {
	return volatile.LoadUint32(&o.EFUSE_DATA3.Reg)
}

type GPIO_Type struct {
	GPIO_OUT             volatile.Register32 // 0x0
	GPIO_OUT_W1TS        volatile.Register32 // 0x4
	GPIO_OUT_W1TC        volatile.Register32 // 0x8
	GPIO_ENABLE          volatile.Register32 // 0xC
	GPIO_ENABLE_W1TS     volatile.Register32 // 0x10
	GPIO_ENABLE_W1TC     volatile.Register32 // 0x14
	GPIO_IN              volatile.Register32 // 0x18
	GPIO_STATUS          volatile.Register32 // 0x1C
	GPIO_STATUS_W1TS     volatile.Register32 // 0x20
	GPIO_STATUS_W1TC     volatile.Register32 // 0x24
	GPIO_PIN0            volatile.Register32 // 0x28
	GPIO_PIN1            volatile.Register32 // 0x2C
	GPIO_PIN2            volatile.Register32 // 0x30
	GPIO_PIN3            volatile.Register32 // 0x34
	GPIO_PIN4            volatile.Register32 // 0x38
	GPIO_PIN5            volatile.Register32 // 0x3C
	GPIO_PIN6            volatile.Register32 // 0x40
	GPIO_PIN7            volatile.Register32 // 0x44
	GPIO_PIN8            volatile.Register32 // 0x48
	GPIO_PIN9            volatile.Register32 // 0x4C
	GPIO_PIN10           volatile.Register32 // 0x50
	GPIO_PIN11           volatile.Register32 // 0x54
	GPIO_PIN12           volatile.Register32 // 0x58
	GPIO_PIN13           volatile.Register32 // 0x5C
	GPIO_PIN14           volatile.Register32 // 0x60
	GPIO_PIN15           volatile.Register32 // 0x64
	GPIO_SIGMA_DELTA     volatile.Register32 // 0x68
	GPIO_RTC_CALIB_SYNC  volatile.Register32 // 0x6C
	GPIO_RTC_CALIB_VALUE volatile.Register32 // 0x70
}

// GPIO.GPIO_OUT: BT-Coexist Selection register
func (o *GPIO_Type) SetGPIO_OUT_GPIO_BT_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT.Reg, volatile.LoadUint32(&o.GPIO_OUT.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPIO_Type) GetGPIO_OUT_GPIO_BT_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_OUT.Reg) & 0xffff0000) >> 16
}
func (o *GPIO_Type) SetGPIO_OUT_GPIO_OUT_DATA(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT.Reg, volatile.LoadUint32(&o.GPIO_OUT.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_OUT_GPIO_OUT_DATA() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT.Reg) & 0xffff
}

// GPIO.GPIO_OUT_W1TS: GPIO_OUT_W1TS
func (o *GPIO_Type) SetGPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT_W1TS.Reg, volatile.LoadUint32(&o.GPIO_OUT_W1TS.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT_W1TS.Reg) & 0xffff
}

// GPIO.GPIO_OUT_W1TC: GPIO_OUT_W1TC
func (o *GPIO_Type) SetGPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT_W1TC.Reg, volatile.LoadUint32(&o.GPIO_OUT_W1TC.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT_W1TC.Reg) & 0xffff
}

// GPIO.GPIO_ENABLE: GPIO_ENABLE
func (o *GPIO_Type) SetGPIO_ENABLE_GPIO_SDIO_SEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_ENABLE.Reg, volatile.LoadUint32(&o.GPIO_ENABLE.Reg)&^(0x3f0000)|value<<16)
}
func (o *GPIO_Type) GetGPIO_ENABLE_GPIO_SDIO_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_ENABLE.Reg) & 0x3f0000) >> 16
}
func (o *GPIO_Type) SetGPIO_ENABLE_GPIO_ENABLE_DATA(value uint32) {
	volatile.StoreUint32(&o.GPIO_ENABLE.Reg, volatile.LoadUint32(&o.GPIO_ENABLE.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_ENABLE_GPIO_ENABLE_DATA() uint32 {
	return volatile.LoadUint32(&o.GPIO_ENABLE.Reg) & 0xffff
}

// GPIO.GPIO_ENABLE_W1TS: GPIO_ENABLE_W1TS
func (o *GPIO_Type) SetGPIO_ENABLE_W1TS_GPIO_ENABLE_DATA_W1TS(value uint32) {
	volatile.StoreUint32(&o.GPIO_ENABLE_W1TS.Reg, volatile.LoadUint32(&o.GPIO_ENABLE_W1TS.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_ENABLE_W1TS_GPIO_ENABLE_DATA_W1TS() uint32 {
	return volatile.LoadUint32(&o.GPIO_ENABLE_W1TS.Reg) & 0xffff
}

// GPIO.GPIO_ENABLE_W1TC: GPIO_ENABLE_W1TC
func (o *GPIO_Type) SetGPIO_ENABLE_W1TC_GPIO_ENABLE_DATA_W1TC(value uint32) {
	volatile.StoreUint32(&o.GPIO_ENABLE_W1TC.Reg, volatile.LoadUint32(&o.GPIO_ENABLE_W1TC.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_ENABLE_W1TC_GPIO_ENABLE_DATA_W1TC() uint32 {
	return volatile.LoadUint32(&o.GPIO_ENABLE_W1TC.Reg) & 0xffff
}

// GPIO.GPIO_IN: The values of the strapping pins.
func (o *GPIO_Type) SetGPIO_IN_GPIO_STRAPPING(value uint32) {
	volatile.StoreUint32(&o.GPIO_IN.Reg, volatile.LoadUint32(&o.GPIO_IN.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPIO_Type) GetGPIO_IN_GPIO_STRAPPING() uint32 {
	return (volatile.LoadUint32(&o.GPIO_IN.Reg) & 0xffff0000) >> 16
}
func (o *GPIO_Type) SetGPIO_IN_GPIO_IN_DATA(value uint32) {
	volatile.StoreUint32(&o.GPIO_IN.Reg, volatile.LoadUint32(&o.GPIO_IN.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_IN_GPIO_IN_DATA() uint32 {
	return volatile.LoadUint32(&o.GPIO_IN.Reg) & 0xffff
}

// GPIO.GPIO_STATUS: GPIO_STATUS
func (o *GPIO_Type) SetGPIO_STATUS_GPIO_STATUS_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.GPIO_STATUS.Reg, volatile.LoadUint32(&o.GPIO_STATUS.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_STATUS_GPIO_STATUS_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.GPIO_STATUS.Reg) & 0xffff
}

// GPIO.GPIO_STATUS_W1TS: GPIO_STATUS_W1TS
func (o *GPIO_Type) SetGPIO_STATUS_W1TS_GPIO_STATUS_INTERRUPT_W1TS(value uint32) {
	volatile.StoreUint32(&o.GPIO_STATUS_W1TS.Reg, volatile.LoadUint32(&o.GPIO_STATUS_W1TS.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_STATUS_W1TS_GPIO_STATUS_INTERRUPT_W1TS() uint32 {
	return volatile.LoadUint32(&o.GPIO_STATUS_W1TS.Reg) & 0xffff
}

// GPIO.GPIO_STATUS_W1TC: GPIO_STATUS_W1TC
func (o *GPIO_Type) SetGPIO_STATUS_W1TC_GPIO_STATUS_INTERRUPT_W1TC(value uint32) {
	volatile.StoreUint32(&o.GPIO_STATUS_W1TC.Reg, volatile.LoadUint32(&o.GPIO_STATUS_W1TC.Reg)&^(0xffff)|value)
}
func (o *GPIO_Type) GetGPIO_STATUS_W1TC_GPIO_STATUS_INTERRUPT_W1TC() uint32 {
	return volatile.LoadUint32(&o.GPIO_STATUS_W1TC.Reg) & 0xffff
}

// GPIO.GPIO_PIN0: GPIO_PIN0
func (o *GPIO_Type) SetGPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN0.Reg, volatile.LoadUint32(&o.GPIO_PIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN0_GPIO_PIN0_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN0.Reg, volatile.LoadUint32(&o.GPIO_PIN0.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN0_GPIO_PIN0_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN0.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN0_GPIO_PIN0_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN0.Reg, volatile.LoadUint32(&o.GPIO_PIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN0_GPIO_PIN0_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN0_GPIO_PIN0_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN0.Reg, volatile.LoadUint32(&o.GPIO_PIN0.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN0_GPIO_PIN0_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN0.Reg) & 0x1
}

// GPIO.GPIO_PIN1: GPIO_PIN1
func (o *GPIO_Type) SetGPIO_PIN1_GPIO_PIN1_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN1.Reg, volatile.LoadUint32(&o.GPIO_PIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN1_GPIO_PIN1_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN1_GPIO_PIN1_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN1.Reg, volatile.LoadUint32(&o.GPIO_PIN1.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN1_GPIO_PIN1_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN1.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN1_GPIO_PIN1_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN1.Reg, volatile.LoadUint32(&o.GPIO_PIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN1_GPIO_PIN1_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN1_GPIO_PIN1_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN1.Reg, volatile.LoadUint32(&o.GPIO_PIN1.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN1_GPIO_PIN1_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN1.Reg) & 0x1
}

// GPIO.GPIO_PIN2: GPIO_PIN2
func (o *GPIO_Type) SetGPIO_PIN2_GPIO_PIN2_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN2.Reg, volatile.LoadUint32(&o.GPIO_PIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN2_GPIO_PIN2_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN2_GPIO_PIN2_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN2.Reg, volatile.LoadUint32(&o.GPIO_PIN2.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN2_GPIO_PIN2_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN2.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN2_GPIO_PIN2_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN2.Reg, volatile.LoadUint32(&o.GPIO_PIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN2_GPIO_PIN2_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN2_GPIO_PIN2_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN2.Reg, volatile.LoadUint32(&o.GPIO_PIN2.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN2_GPIO_PIN2_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN2.Reg) & 0x1
}

// GPIO.GPIO_PIN3: GPIO_PIN3
func (o *GPIO_Type) SetGPIO_PIN3_GPIO_PIN3_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN3.Reg, volatile.LoadUint32(&o.GPIO_PIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN3_GPIO_PIN3_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN3_GPIO_PIN3_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN3.Reg, volatile.LoadUint32(&o.GPIO_PIN3.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN3_GPIO_PIN3_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN3.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN3_GPIO_PIN3_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN3.Reg, volatile.LoadUint32(&o.GPIO_PIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN3_GPIO_PIN3_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN3_GPIO_PIN3_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN3.Reg, volatile.LoadUint32(&o.GPIO_PIN3.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN3_GPIO_PIN3_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN3.Reg) & 0x1
}

// GPIO.GPIO_PIN4: GPIO_PIN4
func (o *GPIO_Type) SetGPIO_PIN4_GPIO_PIN4_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN4.Reg, volatile.LoadUint32(&o.GPIO_PIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN4_GPIO_PIN4_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN4_GPIO_PIN4_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN4.Reg, volatile.LoadUint32(&o.GPIO_PIN4.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN4_GPIO_PIN4_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN4.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN4_GPIO_PIN4_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN4.Reg, volatile.LoadUint32(&o.GPIO_PIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN4_GPIO_PIN4_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN4_GPIO_PIN4_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN4.Reg, volatile.LoadUint32(&o.GPIO_PIN4.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN4_GPIO_PIN4_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN4.Reg) & 0x1
}

// GPIO.GPIO_PIN5: GPIO_PIN5
func (o *GPIO_Type) SetGPIO_PIN5_GPIO_PIN5_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN5.Reg, volatile.LoadUint32(&o.GPIO_PIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN5_GPIO_PIN5_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN5_GPIO_PIN5_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN5.Reg, volatile.LoadUint32(&o.GPIO_PIN5.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN5_GPIO_PIN5_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN5.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN5_GPIO_PIN5_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN5.Reg, volatile.LoadUint32(&o.GPIO_PIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN5_GPIO_PIN5_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN5_GPIO_PIN5_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN5.Reg, volatile.LoadUint32(&o.GPIO_PIN5.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN5_GPIO_PIN5_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN5.Reg) & 0x1
}

// GPIO.GPIO_PIN6: GPIO_PIN6
func (o *GPIO_Type) SetGPIO_PIN6_GPIO_PIN6_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN6.Reg, volatile.LoadUint32(&o.GPIO_PIN6.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN6_GPIO_PIN6_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN6.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN6_GPIO_PIN6_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN6.Reg, volatile.LoadUint32(&o.GPIO_PIN6.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN6_GPIO_PIN6_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN6.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN6_GPIO_PIN6_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN6.Reg, volatile.LoadUint32(&o.GPIO_PIN6.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN6_GPIO_PIN6_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN6.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN6_GPIO_PIN6_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN6.Reg, volatile.LoadUint32(&o.GPIO_PIN6.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN6_GPIO_PIN6_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN6.Reg) & 0x1
}

// GPIO.GPIO_PIN7: GPIO_PIN7
func (o *GPIO_Type) SetGPIO_PIN7_GPIO_PIN7_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN7.Reg, volatile.LoadUint32(&o.GPIO_PIN7.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN7_GPIO_PIN7_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN7.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN7_GPIO_PIN7_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN7.Reg, volatile.LoadUint32(&o.GPIO_PIN7.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN7_GPIO_PIN7_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN7.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN7_GPIO_PIN7_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN7.Reg, volatile.LoadUint32(&o.GPIO_PIN7.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN7_GPIO_PIN7_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN7.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN7_GPIO_PIN7_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN7.Reg, volatile.LoadUint32(&o.GPIO_PIN7.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN7_GPIO_PIN7_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN7.Reg) & 0x1
}

// GPIO.GPIO_PIN8: GPIO_PIN8
func (o *GPIO_Type) SetGPIO_PIN8_GPIO_PIN8_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN8.Reg, volatile.LoadUint32(&o.GPIO_PIN8.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN8_GPIO_PIN8_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN8.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN8_GPIO_PIN8_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN8.Reg, volatile.LoadUint32(&o.GPIO_PIN8.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN8_GPIO_PIN8_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN8.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN8_GPIO_PIN8_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN8.Reg, volatile.LoadUint32(&o.GPIO_PIN8.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN8_GPIO_PIN8_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN8.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN8_GPIO_PIN8_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN8.Reg, volatile.LoadUint32(&o.GPIO_PIN8.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN8_GPIO_PIN8_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN8.Reg) & 0x1
}

// GPIO.GPIO_PIN9: GPIO_PIN9
func (o *GPIO_Type) SetGPIO_PIN9_GPIO_PIN9_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN9.Reg, volatile.LoadUint32(&o.GPIO_PIN9.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN9_GPIO_PIN9_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN9.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN9_GPIO_PIN9_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN9.Reg, volatile.LoadUint32(&o.GPIO_PIN9.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN9_GPIO_PIN9_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN9.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN9_GPIO_PIN9_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN9.Reg, volatile.LoadUint32(&o.GPIO_PIN9.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN9_GPIO_PIN9_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN9.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN9_GPIO_PIN9_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN9.Reg, volatile.LoadUint32(&o.GPIO_PIN9.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN9_GPIO_PIN9_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN9.Reg) & 0x1
}

// GPIO.GPIO_PIN10: GPIO_PIN10
func (o *GPIO_Type) SetGPIO_PIN10_GPIO_PIN10_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN10.Reg, volatile.LoadUint32(&o.GPIO_PIN10.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN10_GPIO_PIN10_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN10.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN10_GPIO_PIN10_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN10.Reg, volatile.LoadUint32(&o.GPIO_PIN10.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN10_GPIO_PIN10_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN10.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN10_GPIO_PIN10_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN10.Reg, volatile.LoadUint32(&o.GPIO_PIN10.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN10_GPIO_PIN10_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN10.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN10_GPIO_PIN10_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN10.Reg, volatile.LoadUint32(&o.GPIO_PIN10.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN10_GPIO_PIN10_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN10.Reg) & 0x1
}

// GPIO.GPIO_PIN11: GPIO_PIN11
func (o *GPIO_Type) SetGPIO_PIN11_GPIO_PIN11_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN11.Reg, volatile.LoadUint32(&o.GPIO_PIN11.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN11_GPIO_PIN11_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN11.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN11_GPIO_PIN11_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN11.Reg, volatile.LoadUint32(&o.GPIO_PIN11.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN11_GPIO_PIN11_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN11.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN11_GPIO_PIN11_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN11.Reg, volatile.LoadUint32(&o.GPIO_PIN11.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN11_GPIO_PIN11_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN11.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN11_GPIO_PIN11_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN11.Reg, volatile.LoadUint32(&o.GPIO_PIN11.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN11_GPIO_PIN11_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN11.Reg) & 0x1
}

// GPIO.GPIO_PIN12: GPIO_PIN12
func (o *GPIO_Type) SetGPIO_PIN12_GPIO_PIN12_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN12.Reg, volatile.LoadUint32(&o.GPIO_PIN12.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN12_GPIO_PIN12_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN12.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN12_GPIO_PIN12_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN12.Reg, volatile.LoadUint32(&o.GPIO_PIN12.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN12_GPIO_PIN12_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN12.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN12_GPIO_PIN12_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN12.Reg, volatile.LoadUint32(&o.GPIO_PIN12.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN12_GPIO_PIN12_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN12.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN12_GPIO_PIN12_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN12.Reg, volatile.LoadUint32(&o.GPIO_PIN12.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN12_GPIO_PIN12_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN12.Reg) & 0x1
}

// GPIO.GPIO_PIN13: GPIO_PIN13
func (o *GPIO_Type) SetGPIO_PIN13_GPIO_PIN13_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN13.Reg, volatile.LoadUint32(&o.GPIO_PIN13.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN13_GPIO_PIN13_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN13.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN13_GPIO_PIN13_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN13.Reg, volatile.LoadUint32(&o.GPIO_PIN13.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN13_GPIO_PIN13_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN13.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN13_GPIO_PIN13_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN13.Reg, volatile.LoadUint32(&o.GPIO_PIN13.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN13_GPIO_PIN13_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN13.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN13_GPIO_PIN13_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN13.Reg, volatile.LoadUint32(&o.GPIO_PIN13.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN13_GPIO_PIN13_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN13.Reg) & 0x1
}

// GPIO.GPIO_PIN14: GPIO_PIN14
func (o *GPIO_Type) SetGPIO_PIN14_GPIO_PIN14_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN14.Reg, volatile.LoadUint32(&o.GPIO_PIN14.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN14_GPIO_PIN14_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN14.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN14_GPIO_PIN14_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN14.Reg, volatile.LoadUint32(&o.GPIO_PIN14.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN14_GPIO_PIN14_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN14.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN14_GPIO_PIN14_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN14.Reg, volatile.LoadUint32(&o.GPIO_PIN14.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN14_GPIO_PIN14_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN14.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN14_GPIO_PIN14_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN14.Reg, volatile.LoadUint32(&o.GPIO_PIN14.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN14_GPIO_PIN14_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN14.Reg) & 0x1
}

// GPIO.GPIO_PIN15: GPIO_PIN15
func (o *GPIO_Type) SetGPIO_PIN15_GPIO_PIN15_WAKEUP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN15.Reg, volatile.LoadUint32(&o.GPIO_PIN15.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetGPIO_PIN15_GPIO_PIN15_WAKEUP_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN15.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetGPIO_PIN15_GPIO_PIN15_INT_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN15.Reg, volatile.LoadUint32(&o.GPIO_PIN15.Reg)&^(0x380)|value<<7)
}
func (o *GPIO_Type) GetGPIO_PIN15_GPIO_PIN15_INT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN15.Reg) & 0x380) >> 7
}
func (o *GPIO_Type) SetGPIO_PIN15_GPIO_PIN15_DRIVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN15.Reg, volatile.LoadUint32(&o.GPIO_PIN15.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetGPIO_PIN15_GPIO_PIN15_DRIVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_PIN15.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetGPIO_PIN15_GPIO_PIN15_SOURCE(value uint32) {
	volatile.StoreUint32(&o.GPIO_PIN15.Reg, volatile.LoadUint32(&o.GPIO_PIN15.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetGPIO_PIN15_GPIO_PIN15_SOURCE() uint32 {
	return volatile.LoadUint32(&o.GPIO_PIN15.Reg) & 0x1
}

// GPIO.GPIO_SIGMA_DELTA: GPIO_SIGMA_DELTA
func (o *GPIO_Type) SetGPIO_SIGMA_DELTA_SIGMA_DELTA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPIO_SIGMA_DELTA.Reg, volatile.LoadUint32(&o.GPIO_SIGMA_DELTA.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetGPIO_SIGMA_DELTA_SIGMA_DELTA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_SIGMA_DELTA.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetGPIO_SIGMA_DELTA_SIGMA_DELTA_PRESCALAR(value uint32) {
	volatile.StoreUint32(&o.GPIO_SIGMA_DELTA.Reg, volatile.LoadUint32(&o.GPIO_SIGMA_DELTA.Reg)&^(0xff00)|value<<8)
}
func (o *GPIO_Type) GetGPIO_SIGMA_DELTA_SIGMA_DELTA_PRESCALAR() uint32 {
	return (volatile.LoadUint32(&o.GPIO_SIGMA_DELTA.Reg) & 0xff00) >> 8
}
func (o *GPIO_Type) SetGPIO_SIGMA_DELTA_SIGMA_DELTA_TARGET(value uint32) {
	volatile.StoreUint32(&o.GPIO_SIGMA_DELTA.Reg, volatile.LoadUint32(&o.GPIO_SIGMA_DELTA.Reg)&^(0xff)|value)
}
func (o *GPIO_Type) GetGPIO_SIGMA_DELTA_SIGMA_DELTA_TARGET() uint32 {
	return volatile.LoadUint32(&o.GPIO_SIGMA_DELTA.Reg) & 0xff
}

// GPIO.GPIO_RTC_CALIB_SYNC: Positvie edge of this bit will trigger the RTC-clock-calibration process.
func (o *GPIO_Type) SetGPIO_RTC_CALIB_SYNC_RTC_CALIB_START(value uint32) {
	volatile.StoreUint32(&o.GPIO_RTC_CALIB_SYNC.Reg, volatile.LoadUint32(&o.GPIO_RTC_CALIB_SYNC.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetGPIO_RTC_CALIB_SYNC_RTC_CALIB_START() uint32 {
	return (volatile.LoadUint32(&o.GPIO_RTC_CALIB_SYNC.Reg) & 0x80000000) >> 31
}
func (o *GPIO_Type) SetGPIO_RTC_CALIB_SYNC_RTC_PERIOD_NUM(value uint32) {
	volatile.StoreUint32(&o.GPIO_RTC_CALIB_SYNC.Reg, volatile.LoadUint32(&o.GPIO_RTC_CALIB_SYNC.Reg)&^(0x3ff)|value)
}
func (o *GPIO_Type) GetGPIO_RTC_CALIB_SYNC_RTC_PERIOD_NUM() uint32 {
	return volatile.LoadUint32(&o.GPIO_RTC_CALIB_SYNC.Reg) & 0x3ff
}

// GPIO.GPIO_RTC_CALIB_VALUE: 0: during RTC-clock-calibration; 1: RTC-clock-calibration is done
func (o *GPIO_Type) SetGPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY(value uint32) {
	volatile.StoreUint32(&o.GPIO_RTC_CALIB_VALUE.Reg, volatile.LoadUint32(&o.GPIO_RTC_CALIB_VALUE.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetGPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY() uint32 {
	return (volatile.LoadUint32(&o.GPIO_RTC_CALIB_VALUE.Reg) & 0x80000000) >> 31
}
func (o *GPIO_Type) SetGPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_REAL(value uint32) {
	volatile.StoreUint32(&o.GPIO_RTC_CALIB_VALUE.Reg, volatile.LoadUint32(&o.GPIO_RTC_CALIB_VALUE.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetGPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_REAL() uint32 {
	return (volatile.LoadUint32(&o.GPIO_RTC_CALIB_VALUE.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetGPIO_RTC_CALIB_VALUE_RTC_CALIB_VALUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_RTC_CALIB_VALUE.Reg, volatile.LoadUint32(&o.GPIO_RTC_CALIB_VALUE.Reg)&^(0xfffff)|value)
}
func (o *GPIO_Type) GetGPIO_RTC_CALIB_VALUE_RTC_CALIB_VALUE() uint32 {
	return volatile.LoadUint32(&o.GPIO_RTC_CALIB_VALUE.Reg) & 0xfffff
}

type I2S_Type struct {
	I2STXFIFO          volatile.Register32 // 0x0
	I2SRXFIFO          volatile.Register32 // 0x4
	I2SCONF            volatile.Register32 // 0x8
	I2SINT_RAW         volatile.Register32 // 0xC
	I2SINT_ST          volatile.Register32 // 0x10
	I2SINT_ENA         volatile.Register32 // 0x14
	I2SINT_CLR         volatile.Register32 // 0x18
	I2STIMING          volatile.Register32 // 0x1C
	I2S_FIFO_CONF      volatile.Register32 // 0x20
	I2SRXEOF_NUM       volatile.Register32 // 0x24
	I2SCONF_SIGLE_DATA volatile.Register32 // 0x28
}

// I2S.I2STXFIFO: I2STXFIFO
func (o *I2S_Type) SetI2STXFIFO(value uint32) {
	volatile.StoreUint32(&o.I2STXFIFO.Reg, value)
}
func (o *I2S_Type) GetI2STXFIFO() uint32 {
	return volatile.LoadUint32(&o.I2STXFIFO.Reg)
}

// I2S.I2SRXFIFO: I2SRXFIFO
func (o *I2S_Type) SetI2SRXFIFO(value uint32) {
	volatile.StoreUint32(&o.I2SRXFIFO.Reg, value)
}
func (o *I2S_Type) GetI2SRXFIFO() uint32 {
	return volatile.LoadUint32(&o.I2SRXFIFO.Reg)
}

// I2S.I2SCONF: I2SCONF
func (o *I2S_Type) SetI2SCONF_I2S_BCK_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0xfc00000)|value<<22)
}
func (o *I2S_Type) GetI2SCONF_I2S_BCK_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0xfc00000) >> 22
}
func (o *I2S_Type) SetI2SCONF_I2S_CLKM_DIV_NUM(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x3f0000)|value<<16)
}
func (o *I2S_Type) GetI2SCONF_I2S_CLKM_DIV_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x3f0000) >> 16
}
func (o *I2S_Type) SetI2SCONF_I2S_BITS_MOD(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetI2SCONF_I2S_BITS_MOD() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetI2SCONF_I2S_RECE_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetI2SCONF_I2S_RECE_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetI2SCONF_I2S_TRANS_MSB_SHIFT(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetI2SCONF_I2S_TRANS_MSB_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetI2SCONF_I2S_I2S_RX_START(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetI2SCONF_I2S_I2S_RX_START() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetI2SCONF_I2S_I2S_TX_START(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetI2SCONF_I2S_I2S_TX_START() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetI2SCONF_I2S_MSB_RIGHT(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetI2SCONF_I2S_MSB_RIGHT() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetI2SCONF_I2S_RIGHT_FIRST(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x40)|value<<6)
}
func (o *I2S_Type) GetI2SCONF_I2S_RIGHT_FIRST() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x40) >> 6
}
func (o *I2S_Type) SetI2SCONF_I2S_RECE_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetI2SCONF_I2S_RECE_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetI2SCONF_I2S_TRANS_SLAVE_MOD(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetI2SCONF_I2S_TRANS_SLAVE_MOD() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetI2SCONF_I2S_I2S_RX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetI2SCONF_I2S_I2S_RX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetI2SCONF_I2S_I2S_TX_FIFO_RESET(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetI2SCONF_I2S_I2S_TX_FIFO_RESET() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetI2SCONF_I2S_I2S_RX_RESET(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetI2SCONF_I2S_I2S_RX_RESET() uint32 {
	return (volatile.LoadUint32(&o.I2SCONF.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetI2SCONF_I2S_I2S_TX_RESET(value uint32) {
	volatile.StoreUint32(&o.I2SCONF.Reg, volatile.LoadUint32(&o.I2SCONF.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetI2SCONF_I2S_I2S_TX_RESET() uint32 {
	return volatile.LoadUint32(&o.I2SCONF.Reg) & 0x1
}

// I2S.I2SINT_RAW: I2SINT_RAW
func (o *I2S_Type) SetI2SINT_RAW_I2S_I2S_TX_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.I2SINT_RAW.Reg, volatile.LoadUint32(&o.I2SINT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetI2SINT_RAW_I2S_I2S_TX_REMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_RAW.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetI2SINT_RAW_I2S_I2S_TX_WFULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.I2SINT_RAW.Reg, volatile.LoadUint32(&o.I2SINT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetI2SINT_RAW_I2S_I2S_TX_WFULL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_RAW.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetI2SINT_RAW_I2S_I2S_RX_REMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.I2SINT_RAW.Reg, volatile.LoadUint32(&o.I2SINT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetI2SINT_RAW_I2S_I2S_RX_REMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_RAW.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetI2SINT_RAW_I2S_I2S_RX_WFULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.I2SINT_RAW.Reg, volatile.LoadUint32(&o.I2SINT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetI2SINT_RAW_I2S_I2S_RX_WFULL_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_RAW.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetI2SINT_RAW_I2S_I2S_TX_PUT_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.I2SINT_RAW.Reg, volatile.LoadUint32(&o.I2SINT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetI2SINT_RAW_I2S_I2S_TX_PUT_DATA_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_RAW.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetI2SINT_RAW_I2S_I2S_RX_TAKE_DATA_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.I2SINT_RAW.Reg, volatile.LoadUint32(&o.I2SINT_RAW.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetI2SINT_RAW_I2S_I2S_RX_TAKE_DATA_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.I2SINT_RAW.Reg) & 0x1
}

// I2S.I2SINT_ST: I2SINT_ST
func (o *I2S_Type) SetI2SINT_ST_I2S_I2S_TX_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ST.Reg, volatile.LoadUint32(&o.I2SINT_ST.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetI2SINT_ST_I2S_I2S_TX_REMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ST.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetI2SINT_ST_I2S_I2S_TX_WFULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ST.Reg, volatile.LoadUint32(&o.I2SINT_ST.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetI2SINT_ST_I2S_I2S_TX_WFULL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ST.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetI2SINT_ST_I2S_I2S_RX_REMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ST.Reg, volatile.LoadUint32(&o.I2SINT_ST.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetI2SINT_ST_I2S_I2S_RX_REMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ST.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetI2SINT_ST_I2S_I2S_RX_WFULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ST.Reg, volatile.LoadUint32(&o.I2SINT_ST.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetI2SINT_ST_I2S_I2S_RX_WFULL_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ST.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetI2SINT_ST_I2S_I2S_TX_PUT_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ST.Reg, volatile.LoadUint32(&o.I2SINT_ST.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetI2SINT_ST_I2S_I2S_TX_PUT_DATA_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ST.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetI2SINT_ST_I2S_I2S_RX_TAKE_DATA_INT_ST(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ST.Reg, volatile.LoadUint32(&o.I2SINT_ST.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetI2SINT_ST_I2S_I2S_RX_TAKE_DATA_INT_ST() uint32 {
	return volatile.LoadUint32(&o.I2SINT_ST.Reg) & 0x1
}

// I2S.I2SINT_ENA: I2SINT_ENA
func (o *I2S_Type) SetI2SINT_ENA_I2S_I2S_TX_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ENA.Reg, volatile.LoadUint32(&o.I2SINT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetI2SINT_ENA_I2S_I2S_TX_REMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ENA.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetI2SINT_ENA_I2S_I2S_TX_WFULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ENA.Reg, volatile.LoadUint32(&o.I2SINT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetI2SINT_ENA_I2S_I2S_TX_WFULL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ENA.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetI2SINT_ENA_I2S_I2S_RX_REMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ENA.Reg, volatile.LoadUint32(&o.I2SINT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetI2SINT_ENA_I2S_I2S_RX_REMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ENA.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetI2SINT_ENA_I2S_I2S_RX_WFULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ENA.Reg, volatile.LoadUint32(&o.I2SINT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetI2SINT_ENA_I2S_I2S_RX_WFULL_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ENA.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetI2SINT_ENA_I2S_I2S_TX_PUT_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ENA.Reg, volatile.LoadUint32(&o.I2SINT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetI2SINT_ENA_I2S_I2S_TX_PUT_DATA_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_ENA.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetI2SINT_ENA_I2S_I2S_RX_TAKE_DATA_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.I2SINT_ENA.Reg, volatile.LoadUint32(&o.I2SINT_ENA.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetI2SINT_ENA_I2S_I2S_RX_TAKE_DATA_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.I2SINT_ENA.Reg) & 0x1
}

// I2S.I2SINT_CLR: I2SINT_CLR
func (o *I2S_Type) SetI2SINT_CLR_I2S_I2S_TX_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.I2SINT_CLR.Reg, volatile.LoadUint32(&o.I2SINT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetI2SINT_CLR_I2S_I2S_TX_REMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_CLR.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetI2SINT_CLR_I2S_I2S_TX_WFULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.I2SINT_CLR.Reg, volatile.LoadUint32(&o.I2SINT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetI2SINT_CLR_I2S_I2S_TX_WFULL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_CLR.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetI2SINT_CLR_I2S_I2S_RX_REMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.I2SINT_CLR.Reg, volatile.LoadUint32(&o.I2SINT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetI2SINT_CLR_I2S_I2S_RX_REMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_CLR.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetI2SINT_CLR_I2S_I2S_RX_WFULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.I2SINT_CLR.Reg, volatile.LoadUint32(&o.I2SINT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetI2SINT_CLR_I2S_I2S_RX_WFULL_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_CLR.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetI2SINT_CLR_I2S_I2S_PUT_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.I2SINT_CLR.Reg, volatile.LoadUint32(&o.I2SINT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetI2SINT_CLR_I2S_I2S_PUT_DATA_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.I2SINT_CLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetI2SINT_CLR_I2S_I2S_TAKE_DATA_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.I2SINT_CLR.Reg, volatile.LoadUint32(&o.I2SINT_CLR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetI2SINT_CLR_I2S_I2S_TAKE_DATA_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.I2SINT_CLR.Reg) & 0x1
}

// I2S.I2STIMING: I2STIMING
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_BCK_IN_INV(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_BCK_IN_INV() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetI2STIMING_I2S_RECE_DSYNC_SW(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetI2STIMING_I2S_RECE_DSYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_DSYNC_SW(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_DSYNC_SW() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetI2STIMING_I2S_RECE_BCK_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0xc0000)|value<<18)
}
func (o *I2S_Type) GetI2STIMING_I2S_RECE_BCK_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0xc0000) >> 18
}
func (o *I2S_Type) SetI2STIMING_I2S_RECE_WS_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetI2STIMING_I2S_RECE_WS_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_SD_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0xc000)|value<<14)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_SD_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0xc000) >> 14
}
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_WS_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x3000)|value<<12)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_WS_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x3000) >> 12
}
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_BCK_OUT_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0xc00)|value<<10)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_BCK_OUT_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0xc00) >> 10
}
func (o *I2S_Type) SetI2STIMING_I2S_RECE_SD_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x300)|value<<8)
}
func (o *I2S_Type) GetI2STIMING_I2S_RECE_SD_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x300) >> 8
}
func (o *I2S_Type) SetI2STIMING_I2S_RECE_WS_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0xc0)|value<<6)
}
func (o *I2S_Type) GetI2STIMING_I2S_RECE_WS_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0xc0) >> 6
}
func (o *I2S_Type) SetI2STIMING_I2S_RECE_BCK_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x30)|value<<4)
}
func (o *I2S_Type) GetI2STIMING_I2S_RECE_BCK_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0x30) >> 4
}
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_WS_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0xc)|value<<2)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_WS_IN_DELAY() uint32 {
	return (volatile.LoadUint32(&o.I2STIMING.Reg) & 0xc) >> 2
}
func (o *I2S_Type) SetI2STIMING_I2S_TRANS_BCK_IN_DELAY(value uint32) {
	volatile.StoreUint32(&o.I2STIMING.Reg, volatile.LoadUint32(&o.I2STIMING.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetI2STIMING_I2S_TRANS_BCK_IN_DELAY() uint32 {
	return volatile.LoadUint32(&o.I2STIMING.Reg) & 0x3
}

// I2S.I2S_FIFO_CONF: I2S_FIFO_CONF
func (o *I2S_Type) SetI2S_FIFO_CONF_I2S_I2S_RX_FIFO_MOD(value uint32) {
	volatile.StoreUint32(&o.I2S_FIFO_CONF.Reg, volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg)&^(0x70000)|value<<16)
}
func (o *I2S_Type) GetI2S_FIFO_CONF_I2S_I2S_RX_FIFO_MOD() uint32 {
	return (volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg) & 0x70000) >> 16
}
func (o *I2S_Type) SetI2S_FIFO_CONF_I2S_I2S_TX_FIFO_MOD(value uint32) {
	volatile.StoreUint32(&o.I2S_FIFO_CONF.Reg, volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg)&^(0xe000)|value<<13)
}
func (o *I2S_Type) GetI2S_FIFO_CONF_I2S_I2S_TX_FIFO_MOD() uint32 {
	return (volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg) & 0xe000) >> 13
}
func (o *I2S_Type) SetI2S_FIFO_CONF_I2S_I2S_DSCR_EN(value uint32) {
	volatile.StoreUint32(&o.I2S_FIFO_CONF.Reg, volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetI2S_FIFO_CONF_I2S_I2S_DSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetI2S_FIFO_CONF_I2S_I2S_TX_DATA_NUM(value uint32) {
	volatile.StoreUint32(&o.I2S_FIFO_CONF.Reg, volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg)&^(0xfc0)|value<<6)
}
func (o *I2S_Type) GetI2S_FIFO_CONF_I2S_I2S_TX_DATA_NUM() uint32 {
	return (volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg) & 0xfc0) >> 6
}
func (o *I2S_Type) SetI2S_FIFO_CONF_I2S_I2S_RX_DATA_NUM(value uint32) {
	volatile.StoreUint32(&o.I2S_FIFO_CONF.Reg, volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetI2S_FIFO_CONF_I2S_I2S_RX_DATA_NUM() uint32 {
	return volatile.LoadUint32(&o.I2S_FIFO_CONF.Reg) & 0x3f
}

// I2S.I2SRXEOF_NUM: I2SRXEOF_NUM
func (o *I2S_Type) SetI2SRXEOF_NUM(value uint32) {
	volatile.StoreUint32(&o.I2SRXEOF_NUM.Reg, value)
}
func (o *I2S_Type) GetI2SRXEOF_NUM() uint32 {
	return volatile.LoadUint32(&o.I2SRXEOF_NUM.Reg)
}

// I2S.I2SCONF_SIGLE_DATA: I2SCONF_SIGLE_DATA
func (o *I2S_Type) SetI2SCONF_SIGLE_DATA(value uint32) {
	volatile.StoreUint32(&o.I2SCONF_SIGLE_DATA.Reg, value)
}
func (o *I2S_Type) GetI2SCONF_SIGLE_DATA() uint32 {
	return volatile.LoadUint32(&o.I2SCONF_SIGLE_DATA.Reg)
}

type IO_MUX_Type struct {
	IO_MUX_CONF     volatile.Register32 // 0x0
	IO_MUX_MTDI     volatile.Register32 // 0x4
	IO_MUX_MTCK     volatile.Register32 // 0x8
	IO_MUX_MTMS     volatile.Register32 // 0xC
	IO_MUX_MTDO     volatile.Register32 // 0x10
	IO_MUX_U0RXD    volatile.Register32 // 0x14
	IO_MUX_U0TXD    volatile.Register32 // 0x18
	IO_MUX_SD_CLK   volatile.Register32 // 0x1C
	IO_MUX_SD_DATA0 volatile.Register32 // 0x20
	IO_MUX_SD_DATA1 volatile.Register32 // 0x24
	IO_MUX_SD_DATA2 volatile.Register32 // 0x28
	IO_MUX_SD_DATA3 volatile.Register32 // 0x2C
	IO_MUX_SD_CMD   volatile.Register32 // 0x30
	IO_MUX_GPIO0    volatile.Register32 // 0x34
	IO_MUX_GPIO2    volatile.Register32 // 0x38
	IO_MUX_GPIO4    volatile.Register32 // 0x3C
	IO_MUX_GPIO5    volatile.Register32 // 0x40
}

// IO_MUX.IO_MUX_CONF: IO_MUX_CONF
func (o *IO_MUX_Type) SetIO_MUX_CONF_SPI0_CLK_EQU_SYS_CLK(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_CONF.Reg, volatile.LoadUint32(&o.IO_MUX_CONF.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_CONF_SPI0_CLK_EQU_SYS_CLK() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_CONF.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_CONF_SPI1_CLK_EQU_SYS_CLK(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_CONF.Reg, volatile.LoadUint32(&o.IO_MUX_CONF.Reg)&^(0x200)|value<<9)
}
func (o *IO_MUX_Type) GetIO_MUX_CONF_SPI1_CLK_EQU_SYS_CLK() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_CONF.Reg) & 0x200) >> 9
}

// IO_MUX.IO_MUX_MTDI: IO_MUX_MTDI
func (o *IO_MUX_Type) SetIO_MUX_MTDI(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDI.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDI() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTDI.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_MTDI_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDI.Reg, volatile.LoadUint32(&o.IO_MUX_MTDI.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDI_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDI.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_MTDI_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDI.Reg, volatile.LoadUint32(&o.IO_MUX_MTDI.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDI_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDI.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_MTDI_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDI.Reg, volatile.LoadUint32(&o.IO_MUX_MTDI.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDI_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDI.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_MTDI_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDI.Reg, volatile.LoadUint32(&o.IO_MUX_MTDI.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDI_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDI.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_MTDI_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDI.Reg, volatile.LoadUint32(&o.IO_MUX_MTDI.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDI_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTDI.Reg) & 0x1
}

// IO_MUX.IO_MUX_MTCK: IO_MUX_MTCK
func (o *IO_MUX_Type) SetIO_MUX_MTCK(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTCK.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTCK() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTCK.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_MTCK_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTCK.Reg, volatile.LoadUint32(&o.IO_MUX_MTCK.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_MTCK_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTCK.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_MTCK_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTCK.Reg, volatile.LoadUint32(&o.IO_MUX_MTCK.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_MTCK_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTCK.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_MTCK_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTCK.Reg, volatile.LoadUint32(&o.IO_MUX_MTCK.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_MTCK_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTCK.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_MTCK_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTCK.Reg, volatile.LoadUint32(&o.IO_MUX_MTCK.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_MTCK_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTCK.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_MTCK_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTCK.Reg, volatile.LoadUint32(&o.IO_MUX_MTCK.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTCK_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTCK.Reg) & 0x1
}

// IO_MUX.IO_MUX_MTMS: IO_MUX_MTMS
func (o *IO_MUX_Type) SetIO_MUX_MTMS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTMS.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTMS() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTMS.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_MTMS_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTMS.Reg, volatile.LoadUint32(&o.IO_MUX_MTMS.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_MTMS_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTMS.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_MTMS_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTMS.Reg, volatile.LoadUint32(&o.IO_MUX_MTMS.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_MTMS_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTMS.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_MTMS_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTMS.Reg, volatile.LoadUint32(&o.IO_MUX_MTMS.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_MTMS_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTMS.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_MTMS_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTMS.Reg, volatile.LoadUint32(&o.IO_MUX_MTMS.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_MTMS_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTMS.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_MTMS_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTMS.Reg, volatile.LoadUint32(&o.IO_MUX_MTMS.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTMS_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTMS.Reg) & 0x1
}

// IO_MUX.IO_MUX_MTDO: IO_MUX_MTDO
func (o *IO_MUX_Type) SetIO_MUX_MTDO(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDO.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDO() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTDO.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_MTDO_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDO.Reg, volatile.LoadUint32(&o.IO_MUX_MTDO.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDO_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDO.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_MTDO_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDO.Reg, volatile.LoadUint32(&o.IO_MUX_MTDO.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDO_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDO.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_MTDO_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDO.Reg, volatile.LoadUint32(&o.IO_MUX_MTDO.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDO_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDO.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_MTDO_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDO.Reg, volatile.LoadUint32(&o.IO_MUX_MTDO.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDO_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_MTDO.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_MTDO_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_MTDO.Reg, volatile.LoadUint32(&o.IO_MUX_MTDO.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_MTDO_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_MTDO.Reg) & 0x1
}

// IO_MUX.IO_MUX_U0RXD: IO_MUX_U0RXD
func (o *IO_MUX_Type) SetIO_MUX_U0RXD(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0RXD.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_U0RXD() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_U0RXD_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0RXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_U0RXD_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_U0RXD_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0RXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_U0RXD_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_U0RXD_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0RXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_U0RXD_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_U0RXD_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0RXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_U0RXD_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_U0RXD_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0RXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_U0RXD_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_U0RXD.Reg) & 0x1
}

// IO_MUX.IO_MUX_U0TXD: IO_MUX_U0TXD
func (o *IO_MUX_Type) SetIO_MUX_U0TXD(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0TXD.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_U0TXD() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_U0TXD_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0TXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_U0TXD_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_U0TXD_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0TXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_U0TXD_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_U0TXD_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0TXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_U0TXD_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_U0TXD_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0TXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_U0TXD_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_U0TXD_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_U0TXD.Reg, volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_U0TXD_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_U0TXD.Reg) & 0x1
}

// IO_MUX.IO_MUX_SD_CLK: IO_MUX_SD_CLK
func (o *IO_MUX_Type) SetIO_MUX_SD_CLK(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CLK.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CLK() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CLK_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CLK.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CLK_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CLK_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CLK.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CLK_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CLK_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CLK.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CLK_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CLK_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CLK.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CLK_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CLK_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CLK.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CLK_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_CLK.Reg) & 0x1
}

// IO_MUX.IO_MUX_SD_DATA0: IO_MUX_SD_DATA0
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA0(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA0.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA0() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA0_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA0.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA0_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA0_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA0.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA0_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA0_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA0.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA0_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA0_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA0.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA0_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA0_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA0.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA0_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA0.Reg) & 0x1
}

// IO_MUX.IO_MUX_SD_DATA1: IO_MUX_SD_DATA1
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA1(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA1.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA1() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA1_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA1.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA1_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA1_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA1.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA1_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA1_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA1.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA1_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA1_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA1.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA1_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA1_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA1.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA1_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA1.Reg) & 0x1
}

// IO_MUX.IO_MUX_SD_DATA2: IO_MUX_SD_DATA2
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA2(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA2.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA2() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA2_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA2.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA2_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA2_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA2.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA2_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA2_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA2.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA2_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA2_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA2.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA2_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA2_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA2.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA2_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA2.Reg) & 0x1
}

// IO_MUX.IO_MUX_SD_DATA3: IO_MUX_SD_DATA3
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA3(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA3.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA3() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA3_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA3.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA3_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA3_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA3.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA3_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA3_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA3.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA3_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA3_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA3.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA3_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_SD_DATA3_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_DATA3.Reg, volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_DATA3_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_DATA3.Reg) & 0x1
}

// IO_MUX.IO_MUX_SD_CMD: IO_MUX_SD_CMD
func (o *IO_MUX_Type) SetIO_MUX_SD_CMD(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CMD.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CMD() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CMD_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CMD.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CMD_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CMD_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CMD.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CMD_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CMD_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CMD.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CMD_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CMD_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CMD.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CMD_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_SD_CMD_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_SD_CMD.Reg, volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_SD_CMD_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_SD_CMD.Reg) & 0x1
}

// IO_MUX.IO_MUX_GPIO0: IO_MUX_GPIO0
func (o *IO_MUX_Type) SetIO_MUX_GPIO0(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO0.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO0() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO0_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO0.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO0_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO0_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO0.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO0_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO0_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO0.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO0_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO0_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO0.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO0_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO0_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO0.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO0_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO0.Reg) & 0x1
}

// IO_MUX.IO_MUX_GPIO2: IO_MUX_GPIO2
func (o *IO_MUX_Type) SetIO_MUX_GPIO2(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO2.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO2() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO2_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO2.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO2_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO2_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO2.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO2_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO2_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO2.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO2_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO2_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO2.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO2_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO2_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO2.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO2_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO2.Reg) & 0x1
}

// IO_MUX.IO_MUX_GPIO4: IO_MUX_GPIO4
func (o *IO_MUX_Type) SetIO_MUX_GPIO4(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO4.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO4() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO4_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO4.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO4_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO4_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO4.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO4_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO4_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO4.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO4_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO4_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO4.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO4_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO4_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO4.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO4_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO4.Reg) & 0x1
}

// IO_MUX.IO_MUX_GPIO5: IO_MUX_GPIO5
func (o *IO_MUX_Type) SetIO_MUX_GPIO5(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO5.Reg, value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO5() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg)
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO5_FUNCTION_SELECT_LOW_BITS(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO5.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg)&^(0x30)|value<<4)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO5_FUNCTION_SELECT_LOW_BITS() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg) & 0x30) >> 4
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO5_FUNCTION_SELECT_HIGH_BIT(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO5.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg)&^(0x100)|value<<8)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO5_FUNCTION_SELECT_HIGH_BIT() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg) & 0x100) >> 8
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO5_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO5.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg)&^(0x80)|value<<7)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO5_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg) & 0x80) >> 7
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO5_SLEEP_PULLUP(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO5.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg)&^(0x8)|value<<3)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO5_SLEEP_PULLUP() uint32 {
	return (volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg) & 0x8) >> 3
}
func (o *IO_MUX_Type) SetIO_MUX_GPIO5_SLEEP_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IO_MUX_GPIO5.Reg, volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg)&^(0x1)|value)
}
func (o *IO_MUX_Type) GetIO_MUX_GPIO5_SLEEP_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IO_MUX_GPIO5.Reg) & 0x1
}

type RTC_Type struct {
	_          [20]byte
	RTC_STATE1 volatile.Register32 // 0x14
	_          [24]byte
	RTC_STORE0 volatile.Register32 // 0x30
}

// RTC.RTC_STATE1: RTC_STATE1
func (o *RTC_Type) SetRTC_STATE1(value uint32) {
	volatile.StoreUint32(&o.RTC_STATE1.Reg, value)
}
func (o *RTC_Type) GetRTC_STATE1() uint32 {
	return volatile.LoadUint32(&o.RTC_STATE1.Reg)
}

// RTC.RTC_STORE0: RTC_STORE0
func (o *RTC_Type) SetRTC_STORE0(value uint32) {
	volatile.StoreUint32(&o.RTC_STORE0.Reg, value)
}
func (o *RTC_Type) GetRTC_STORE0() uint32 {
	return volatile.LoadUint32(&o.RTC_STORE0.Reg)
}

type SLC_Type struct {
	SLC_CONF0               volatile.Register32 // 0x0
	SLC_INT_RAW             volatile.Register32 // 0x4
	SLC_INT_STATUS          volatile.Register32 // 0x8
	SLC_INT_ENA             volatile.Register32 // 0xC
	SLC_INT_CLR             volatile.Register32 // 0x10
	SLC_RX_STATUS           volatile.Register32 // 0x14
	SLC_RX_FIFO_PUSH        volatile.Register32 // 0x18
	SLC_TX_STATUS           volatile.Register32 // 0x1C
	SLC_TX_FIFO_POP         volatile.Register32 // 0x20
	SLC_RX_LINK             volatile.Register32 // 0x24
	SLC_TX_LINK             volatile.Register32 // 0x28
	SLC_INTVEC_TOHOST       volatile.Register32 // 0x2C
	SLC_TOKEN0              volatile.Register32 // 0x30
	SLC_TOKEN1              volatile.Register32 // 0x34
	SLC_CONF1               volatile.Register32 // 0x38
	SLC_STATE0              volatile.Register32 // 0x3C
	SLC_STATE1              volatile.Register32 // 0x40
	SLC_BRIDGE_CONF         volatile.Register32 // 0x44
	SLC_RX_EOF_DES_ADDR     volatile.Register32 // 0x48
	SLC_TX_EOF_DES_ADDR     volatile.Register32 // 0x4C
	SLC_RX_EOF_BFR_DES_ADDR volatile.Register32 // 0x50
	SLC_AHB_TEST            volatile.Register32 // 0x54
	SLC_SDIO_ST             volatile.Register32 // 0x58
	SLC_RX_DSCR_CONF        volatile.Register32 // 0x5C
	SLC_TXLINK_DSCR         volatile.Register32 // 0x60
	SLC_TXLINK_DSCR_BF0     volatile.Register32 // 0x64
	SLC_TXLINK_DSCR_BF1     volatile.Register32 // 0x68
	SLC_RXLINK_DSCR         volatile.Register32 // 0x6C
	SLC_RXLINK_DSCR_BF0     volatile.Register32 // 0x70
	SLC_RXLINK_DSCR_BF1     volatile.Register32 // 0x74
	SLC_DATE                volatile.Register32 // 0x78
	SLC_ID                  volatile.Register32 // 0x7C
}

// SLC.SLC_CONF0: SLC_CONF0
func (o *SLC_Type) SetSLC_CONF0_SLC_MODE(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x3000)|value<<12)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_MODE() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x3000) >> 12
}
func (o *SLC_Type) SetSLC_CONF0_SLC_DATA_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x200)|value<<9)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_DATA_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x200) >> 9
}
func (o *SLC_Type) SetSLC_CONF0_SLC_DSCR_BURST_EN(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_DSCR_BURST_EN() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x100) >> 8
}
func (o *SLC_Type) SetSLC_CONF0_SLC_RX_NO_RESTART_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x80)|value<<7)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_RX_NO_RESTART_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x80) >> 7
}
func (o *SLC_Type) SetSLC_CONF0_SLC_RX_AUTO_WRBACK(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x40)|value<<6)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_RX_AUTO_WRBACK() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x40) >> 6
}
func (o *SLC_Type) SetSLC_CONF0_SLC_RX_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x20)|value<<5)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_RX_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x20) >> 5
}
func (o *SLC_Type) SetSLC_CONF0_SLC_TX_LOOP_TEST(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x10)|value<<4)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_TX_LOOP_TEST() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x10) >> 4
}
func (o *SLC_Type) SetSLC_CONF0_SLC_AHBM_RST(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x8)|value<<3)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_AHBM_RST() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x8) >> 3
}
func (o *SLC_Type) SetSLC_CONF0_SLC_AHBM_FIFO_RST(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x4)|value<<2)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_AHBM_FIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x4) >> 2
}
func (o *SLC_Type) SetSLC_CONF0_SLC_RXLINK_RST(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_RXLINK_RST() uint32 {
	return (volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_CONF0_SLC_TXLINK_RST(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF0.Reg, volatile.LoadUint32(&o.SLC_CONF0.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_CONF0_SLC_TXLINK_RST() uint32 {
	return volatile.LoadUint32(&o.SLC_CONF0.Reg) & 0x1
}

// SLC.SLC_INT_RAW: SLC_INT_RAW
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TX_DSCR_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x200000)|value<<21)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TX_DSCR_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x200000) >> 21
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_RX_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x100000)|value<<20)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_RX_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x100000) >> 20
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TX_DSCR_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x80000)|value<<19)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TX_DSCR_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x80000) >> 19
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TOHOST_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x40000)|value<<18)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TOHOST_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x40000) >> 18
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_RX_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x20000)|value<<17)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_RX_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x20000) >> 17
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_RX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x10000)|value<<16)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_RX_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x10000) >> 16
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TX_EOF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x8000)|value<<15)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TX_EOF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x8000) >> 15
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TX_DONE_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x4000)|value<<14)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TX_DONE_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x4000) >> 14
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TOKEN1_1TO0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x2000)|value<<13)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TOKEN1_1TO0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x2000) >> 13
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TOKEN0_1TO0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TOKEN0_1TO0_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TX_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x800)|value<<11)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TX_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x800) >> 11
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_RX_UDF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x400)|value<<10)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_RX_UDF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x400) >> 10
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_TX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x200)|value<<9)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_TX_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x200) >> 9
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_RX_START_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_RX_START_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x100) >> 8
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT7_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT7_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x80) >> 7
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT6_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT6_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x40) >> 6
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT5_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT5_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x20) >> 5
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT4_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT4_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x10) >> 4
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT3_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT3_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x8) >> 3
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT2_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT2_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x4) >> 2
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT1_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT1_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_INT_RAW_SLC_FRHOST_BIT0_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_RAW.Reg, volatile.LoadUint32(&o.SLC_INT_RAW.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_INT_RAW_SLC_FRHOST_BIT0_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.SLC_INT_RAW.Reg) & 0x1
}

// SLC.SLC_INT_STATUS: SLC_INT_STATUS
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TX_DSCR_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TX_DSCR_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x200000) >> 21
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_RX_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_RX_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x100000) >> 20
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TX_DSCR_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TX_DSCR_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x80000) >> 19
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TOHOST_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TOHOST_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x40000) >> 18
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_RX_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_RX_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x20000) >> 17
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_RX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_RX_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x10000) >> 16
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TX_EOF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TX_EOF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x8000) >> 15
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TX_DONE_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TX_DONE_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x4000) >> 14
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TOKEN1_1TO0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TOKEN1_1TO0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x2000) >> 13
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TOKEN0_1TO0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TOKEN0_1TO0_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TX_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x800)|value<<11)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TX_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x800) >> 11
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_RX_UDF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x400)|value<<10)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_RX_UDF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x400) >> 10
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_TX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_TX_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x200) >> 9
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_RX_START_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_RX_START_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x100) >> 8
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT7_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT7_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x80) >> 7
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT6_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT6_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x40) >> 6
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT5_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT5_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x20) >> 5
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT4_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT4_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x10) >> 4
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT3_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT3_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x8) >> 3
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT2_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT2_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x4) >> 2
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT1_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT1_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_INT_STATUS_SLC_FRHOST_BIT0_INT_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_STATUS.Reg, volatile.LoadUint32(&o.SLC_INT_STATUS.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_INT_STATUS_SLC_FRHOST_BIT0_INT_ST() uint32 {
	return volatile.LoadUint32(&o.SLC_INT_STATUS.Reg) & 0x1
}

// SLC.SLC_INT_ENA: SLC_INT_ENA
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TX_DSCR_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x200000)|value<<21)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TX_DSCR_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x200000) >> 21
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_RX_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x100000)|value<<20)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_RX_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x100000) >> 20
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TX_DSCR_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x80000)|value<<19)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TX_DSCR_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x80000) >> 19
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TOHOST_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x40000)|value<<18)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TOHOST_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x40000) >> 18
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_RX_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x20000)|value<<17)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_RX_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x20000) >> 17
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_RX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x10000)|value<<16)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_RX_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x10000) >> 16
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TX_EOF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x8000)|value<<15)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TX_EOF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x8000) >> 15
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TX_DONE_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x4000)|value<<14)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TX_DONE_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x4000) >> 14
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TOKEN1_1TO0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x2000)|value<<13)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TOKEN1_1TO0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x2000) >> 13
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TOKEN0_1TO0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TOKEN0_1TO0_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TX_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x800)|value<<11)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TX_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x800) >> 11
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_RX_UDF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x400)|value<<10)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_RX_UDF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x400) >> 10
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_TX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x200)|value<<9)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_TX_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x200) >> 9
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_RX_START_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_RX_START_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x100) >> 8
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT7_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT7_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x80) >> 7
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT6_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT6_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x40) >> 6
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT5_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT5_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x20) >> 5
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT4_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT4_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x10) >> 4
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT3_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT3_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x8) >> 3
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT2_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT2_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x4) >> 2
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT1_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT1_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_INT_ENA_SLC_FRHOST_BIT0_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_ENA.Reg, volatile.LoadUint32(&o.SLC_INT_ENA.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_INT_ENA_SLC_FRHOST_BIT0_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.SLC_INT_ENA.Reg) & 0x1
}

// SLC.SLC_INT_CLR: SLC_INT_CLR
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TX_DSCR_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TX_DSCR_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x200000) >> 21
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_RX_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_RX_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x100000) >> 20
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TX_DSCR_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TX_DSCR_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x80000) >> 19
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TOHOST_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TOHOST_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x40000) >> 18
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_RX_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_RX_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x20000) >> 17
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_RX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_RX_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x10000) >> 16
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TX_EOF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TX_EOF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x8000) >> 15
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TX_DONE_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TX_DONE_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x4000) >> 14
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TOKEN1_1TO0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TOKEN1_1TO0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x2000) >> 13
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TOKEN0_1TO0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TOKEN0_1TO0_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TX_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x800)|value<<11)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TX_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x800) >> 11
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_RX_UDF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x400)|value<<10)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_RX_UDF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x400) >> 10
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_TX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x200)|value<<9)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_TX_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x200) >> 9
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_RX_START_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_RX_START_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x100) >> 8
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT7_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT7_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x80) >> 7
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT6_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT6_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x40) >> 6
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT5_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT5_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x20) >> 5
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT4_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT4_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x10) >> 4
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT3_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT3_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x8) >> 3
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT2_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT2_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x4) >> 2
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT1_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT1_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_INT_CLR_SLC_FRHOST_BIT0_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.SLC_INT_CLR.Reg, volatile.LoadUint32(&o.SLC_INT_CLR.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_INT_CLR_SLC_FRHOST_BIT0_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.SLC_INT_CLR.Reg) & 0x1
}

// SLC.SLC_RX_STATUS: SLC_RX_STATUS
func (o *SLC_Type) SetSLC_RX_STATUS_SLC_RX_EMPTY(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_STATUS.Reg, volatile.LoadUint32(&o.SLC_RX_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_RX_STATUS_SLC_RX_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_STATUS.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_RX_STATUS_SLC_RX_FULL(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_STATUS.Reg, volatile.LoadUint32(&o.SLC_RX_STATUS.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_RX_STATUS_SLC_RX_FULL() uint32 {
	return volatile.LoadUint32(&o.SLC_RX_STATUS.Reg) & 0x1
}

// SLC.SLC_RX_FIFO_PUSH: SLC_RX_FIFO_PUSH
func (o *SLC_Type) SetSLC_RX_FIFO_PUSH_SLC_RXFIFO_PUSH(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_FIFO_PUSH.Reg, volatile.LoadUint32(&o.SLC_RX_FIFO_PUSH.Reg)&^(0x10000)|value<<16)
}
func (o *SLC_Type) GetSLC_RX_FIFO_PUSH_SLC_RXFIFO_PUSH() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_FIFO_PUSH.Reg) & 0x10000) >> 16
}
func (o *SLC_Type) SetSLC_RX_FIFO_PUSH_SLC_RXFIFO_WDATA(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_FIFO_PUSH.Reg, volatile.LoadUint32(&o.SLC_RX_FIFO_PUSH.Reg)&^(0x1ff)|value)
}
func (o *SLC_Type) GetSLC_RX_FIFO_PUSH_SLC_RXFIFO_WDATA() uint32 {
	return volatile.LoadUint32(&o.SLC_RX_FIFO_PUSH.Reg) & 0x1ff
}

// SLC.SLC_TX_STATUS: SLC_TX_STATUS
func (o *SLC_Type) SetSLC_TX_STATUS_SLC_TX_EMPTY(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_STATUS.Reg, volatile.LoadUint32(&o.SLC_TX_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SLC_Type) GetSLC_TX_STATUS_SLC_TX_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.SLC_TX_STATUS.Reg) & 0x2) >> 1
}
func (o *SLC_Type) SetSLC_TX_STATUS_SLC_TX_FULL(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_STATUS.Reg, volatile.LoadUint32(&o.SLC_TX_STATUS.Reg)&^(0x1)|value)
}
func (o *SLC_Type) GetSLC_TX_STATUS_SLC_TX_FULL() uint32 {
	return volatile.LoadUint32(&o.SLC_TX_STATUS.Reg) & 0x1
}

// SLC.SLC_TX_FIFO_POP: SLC_TX_FIFO_POP
func (o *SLC_Type) SetSLC_TX_FIFO_POP_SLC_TXFIFO_POP(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_FIFO_POP.Reg, volatile.LoadUint32(&o.SLC_TX_FIFO_POP.Reg)&^(0x10000)|value<<16)
}
func (o *SLC_Type) GetSLC_TX_FIFO_POP_SLC_TXFIFO_POP() uint32 {
	return (volatile.LoadUint32(&o.SLC_TX_FIFO_POP.Reg) & 0x10000) >> 16
}
func (o *SLC_Type) SetSLC_TX_FIFO_POP_SLC_TXFIFO_RDATA(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_FIFO_POP.Reg, volatile.LoadUint32(&o.SLC_TX_FIFO_POP.Reg)&^(0x7ff)|value)
}
func (o *SLC_Type) GetSLC_TX_FIFO_POP_SLC_TXFIFO_RDATA() uint32 {
	return volatile.LoadUint32(&o.SLC_TX_FIFO_POP.Reg) & 0x7ff
}

// SLC.SLC_RX_LINK: SLC_RX_LINK
func (o *SLC_Type) SetSLC_RX_LINK_SLC_RXLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_LINK.Reg, volatile.LoadUint32(&o.SLC_RX_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *SLC_Type) GetSLC_RX_LINK_SLC_RXLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_LINK.Reg) & 0x80000000) >> 31
}
func (o *SLC_Type) SetSLC_RX_LINK_SLC_RXLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_LINK.Reg, volatile.LoadUint32(&o.SLC_RX_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *SLC_Type) GetSLC_RX_LINK_SLC_RXLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_LINK.Reg) & 0x40000000) >> 30
}
func (o *SLC_Type) SetSLC_RX_LINK_SLC_RXLINK_START(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_LINK.Reg, volatile.LoadUint32(&o.SLC_RX_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *SLC_Type) GetSLC_RX_LINK_SLC_RXLINK_START() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_LINK.Reg) & 0x20000000) >> 29
}
func (o *SLC_Type) SetSLC_RX_LINK_SLC_RXLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_LINK.Reg, volatile.LoadUint32(&o.SLC_RX_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *SLC_Type) GetSLC_RX_LINK_SLC_RXLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_LINK.Reg) & 0x10000000) >> 28
}
func (o *SLC_Type) SetSLC_RX_LINK_SLC_RXLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_LINK.Reg, volatile.LoadUint32(&o.SLC_RX_LINK.Reg)&^(0xfffff)|value)
}
func (o *SLC_Type) GetSLC_RX_LINK_SLC_RXLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLC_RX_LINK.Reg) & 0xfffff
}

// SLC.SLC_TX_LINK: SLC_TX_LINK
func (o *SLC_Type) SetSLC_TX_LINK_SLC_TXLINK_PARK(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_LINK.Reg, volatile.LoadUint32(&o.SLC_TX_LINK.Reg)&^(0x80000000)|value<<31)
}
func (o *SLC_Type) GetSLC_TX_LINK_SLC_TXLINK_PARK() uint32 {
	return (volatile.LoadUint32(&o.SLC_TX_LINK.Reg) & 0x80000000) >> 31
}
func (o *SLC_Type) SetSLC_TX_LINK_SLC_TXLINK_RESTART(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_LINK.Reg, volatile.LoadUint32(&o.SLC_TX_LINK.Reg)&^(0x40000000)|value<<30)
}
func (o *SLC_Type) GetSLC_TX_LINK_SLC_TXLINK_RESTART() uint32 {
	return (volatile.LoadUint32(&o.SLC_TX_LINK.Reg) & 0x40000000) >> 30
}
func (o *SLC_Type) SetSLC_TX_LINK_SLC_TXLINK_START(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_LINK.Reg, volatile.LoadUint32(&o.SLC_TX_LINK.Reg)&^(0x20000000)|value<<29)
}
func (o *SLC_Type) GetSLC_TX_LINK_SLC_TXLINK_START() uint32 {
	return (volatile.LoadUint32(&o.SLC_TX_LINK.Reg) & 0x20000000) >> 29
}
func (o *SLC_Type) SetSLC_TX_LINK_SLC_TXLINK_STOP(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_LINK.Reg, volatile.LoadUint32(&o.SLC_TX_LINK.Reg)&^(0x10000000)|value<<28)
}
func (o *SLC_Type) GetSLC_TX_LINK_SLC_TXLINK_STOP() uint32 {
	return (volatile.LoadUint32(&o.SLC_TX_LINK.Reg) & 0x10000000) >> 28
}
func (o *SLC_Type) SetSLC_TX_LINK_SLC_TXLINK_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_LINK.Reg, volatile.LoadUint32(&o.SLC_TX_LINK.Reg)&^(0xfffff)|value)
}
func (o *SLC_Type) GetSLC_TX_LINK_SLC_TXLINK_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLC_TX_LINK.Reg) & 0xfffff
}

// SLC.SLC_INTVEC_TOHOST: SLC_INTVEC_TOHOST
func (o *SLC_Type) SetSLC_INTVEC_TOHOST_SLC_TOHOST_INTVEC(value uint32) {
	volatile.StoreUint32(&o.SLC_INTVEC_TOHOST.Reg, volatile.LoadUint32(&o.SLC_INTVEC_TOHOST.Reg)&^(0xff)|value)
}
func (o *SLC_Type) GetSLC_INTVEC_TOHOST_SLC_TOHOST_INTVEC() uint32 {
	return volatile.LoadUint32(&o.SLC_INTVEC_TOHOST.Reg) & 0xff
}

// SLC.SLC_TOKEN0: SLC_TOKEN0
func (o *SLC_Type) SetSLC_TOKEN0(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN0.Reg, volatile.LoadUint32(&o.SLC_TOKEN0.Reg)&^(0xfff0000)|value<<16)
}
func (o *SLC_Type) GetSLC_TOKEN0() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN0.Reg) & 0xfff0000) >> 16
}
func (o *SLC_Type) SetSLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_MORE(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN0.Reg, volatile.LoadUint32(&o.SLC_TOKEN0.Reg)&^(0x4000)|value<<14)
}
func (o *SLC_Type) GetSLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_MORE() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN0.Reg) & 0x4000) >> 14
}
func (o *SLC_Type) SetSLC_TOKEN0_SLC_TOKEN0_LOCAL_INC(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN0.Reg, volatile.LoadUint32(&o.SLC_TOKEN0.Reg)&^(0x2000)|value<<13)
}
func (o *SLC_Type) GetSLC_TOKEN0_SLC_TOKEN0_LOCAL_INC() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN0.Reg) & 0x2000) >> 13
}
func (o *SLC_Type) SetSLC_TOKEN0_SLC_TOKEN0_LOCAL_WR(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN0.Reg, volatile.LoadUint32(&o.SLC_TOKEN0.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_TOKEN0_SLC_TOKEN0_LOCAL_WR() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN0.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_TOKEN0_SLC_TOKEN0_LOCAL_WDATA(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN0.Reg, volatile.LoadUint32(&o.SLC_TOKEN0.Reg)&^(0xfff)|value)
}
func (o *SLC_Type) GetSLC_TOKEN0_SLC_TOKEN0_LOCAL_WDATA() uint32 {
	return volatile.LoadUint32(&o.SLC_TOKEN0.Reg) & 0xfff
}

// SLC.SLC_TOKEN1: SLC_TOKEN1
func (o *SLC_Type) SetSLC_TOKEN1(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN1.Reg, volatile.LoadUint32(&o.SLC_TOKEN1.Reg)&^(0xfff0000)|value<<16)
}
func (o *SLC_Type) GetSLC_TOKEN1() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN1.Reg) & 0xfff0000) >> 16
}
func (o *SLC_Type) SetSLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_MORE(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN1.Reg, volatile.LoadUint32(&o.SLC_TOKEN1.Reg)&^(0x4000)|value<<14)
}
func (o *SLC_Type) GetSLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_MORE() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN1.Reg) & 0x4000) >> 14
}
func (o *SLC_Type) SetSLC_TOKEN1_SLC_TOKEN1_LOCAL_INC(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN1.Reg, volatile.LoadUint32(&o.SLC_TOKEN1.Reg)&^(0x2000)|value<<13)
}
func (o *SLC_Type) GetSLC_TOKEN1_SLC_TOKEN1_LOCAL_INC() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN1.Reg) & 0x2000) >> 13
}
func (o *SLC_Type) SetSLC_TOKEN1_SLC_TOKEN1_LOCAL_WR(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN1.Reg, volatile.LoadUint32(&o.SLC_TOKEN1.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_TOKEN1_SLC_TOKEN1_LOCAL_WR() uint32 {
	return (volatile.LoadUint32(&o.SLC_TOKEN1.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_TOKEN1_SLC_TOKEN1_LOCAL_WDATA(value uint32) {
	volatile.StoreUint32(&o.SLC_TOKEN1.Reg, volatile.LoadUint32(&o.SLC_TOKEN1.Reg)&^(0xfff)|value)
}
func (o *SLC_Type) GetSLC_TOKEN1_SLC_TOKEN1_LOCAL_WDATA() uint32 {
	return volatile.LoadUint32(&o.SLC_TOKEN1.Reg) & 0xfff
}

// SLC.SLC_CONF1: SLC_CONF1
func (o *SLC_Type) SetSLC_CONF1(value uint32) {
	volatile.StoreUint32(&o.SLC_CONF1.Reg, value)
}
func (o *SLC_Type) GetSLC_CONF1() uint32 {
	return volatile.LoadUint32(&o.SLC_CONF1.Reg)
}

// SLC.SLC_STATE0: SLC_STATE0
func (o *SLC_Type) SetSLC_STATE0(value uint32) {
	volatile.StoreUint32(&o.SLC_STATE0.Reg, value)
}
func (o *SLC_Type) GetSLC_STATE0() uint32 {
	return volatile.LoadUint32(&o.SLC_STATE0.Reg)
}

// SLC.SLC_STATE1: SLC_STATE1
func (o *SLC_Type) SetSLC_STATE1(value uint32) {
	volatile.StoreUint32(&o.SLC_STATE1.Reg, value)
}
func (o *SLC_Type) GetSLC_STATE1() uint32 {
	return volatile.LoadUint32(&o.SLC_STATE1.Reg)
}

// SLC.SLC_BRIDGE_CONF: SLC_BRIDGE_CONF
func (o *SLC_Type) SetSLC_BRIDGE_CONF_SLC_TX_PUSH_IDLE_NUM(value uint32) {
	volatile.StoreUint32(&o.SLC_BRIDGE_CONF.Reg, volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg)&^(0xffff0000)|value<<16)
}
func (o *SLC_Type) GetSLC_BRIDGE_CONF_SLC_TX_PUSH_IDLE_NUM() uint32 {
	return (volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg) & 0xffff0000) >> 16
}
func (o *SLC_Type) SetSLC_BRIDGE_CONF_SLC_TX_DUMMY_MODE(value uint32) {
	volatile.StoreUint32(&o.SLC_BRIDGE_CONF.Reg, volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg)&^(0x1000)|value<<12)
}
func (o *SLC_Type) GetSLC_BRIDGE_CONF_SLC_TX_DUMMY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg) & 0x1000) >> 12
}
func (o *SLC_Type) SetSLC_BRIDGE_CONF_SLC_FIFO_MAP_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_BRIDGE_CONF.Reg, volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg)&^(0xf00)|value<<8)
}
func (o *SLC_Type) GetSLC_BRIDGE_CONF_SLC_FIFO_MAP_ENA() uint32 {
	return (volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg) & 0xf00) >> 8
}
func (o *SLC_Type) SetSLC_BRIDGE_CONF_SLC_TXEOF_ENA(value uint32) {
	volatile.StoreUint32(&o.SLC_BRIDGE_CONF.Reg, volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg)&^(0x3f)|value)
}
func (o *SLC_Type) GetSLC_BRIDGE_CONF_SLC_TXEOF_ENA() uint32 {
	return volatile.LoadUint32(&o.SLC_BRIDGE_CONF.Reg) & 0x3f
}

// SLC.SLC_RX_EOF_DES_ADDR: SLC_RX_EOF_DES_ADDR
func (o *SLC_Type) SetSLC_RX_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_EOF_DES_ADDR.Reg, value)
}
func (o *SLC_Type) GetSLC_RX_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLC_RX_EOF_DES_ADDR.Reg)
}

// SLC.SLC_TX_EOF_DES_ADDR: SLC_TX_EOF_DES_ADDR
func (o *SLC_Type) SetSLC_TX_EOF_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLC_TX_EOF_DES_ADDR.Reg, value)
}
func (o *SLC_Type) GetSLC_TX_EOF_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLC_TX_EOF_DES_ADDR.Reg)
}

// SLC.SLC_RX_EOF_BFR_DES_ADDR: SLC_RX_EOF_BFR_DES_ADDR
func (o *SLC_Type) SetSLC_RX_EOF_BFR_DES_ADDR(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_EOF_BFR_DES_ADDR.Reg, value)
}
func (o *SLC_Type) GetSLC_RX_EOF_BFR_DES_ADDR() uint32 {
	return volatile.LoadUint32(&o.SLC_RX_EOF_BFR_DES_ADDR.Reg)
}

// SLC.SLC_AHB_TEST: SLC_AHB_TEST
func (o *SLC_Type) SetSLC_AHB_TEST_SLC_AHB_TESTADDR(value uint32) {
	volatile.StoreUint32(&o.SLC_AHB_TEST.Reg, volatile.LoadUint32(&o.SLC_AHB_TEST.Reg)&^(0x30)|value<<4)
}
func (o *SLC_Type) GetSLC_AHB_TEST_SLC_AHB_TESTADDR() uint32 {
	return (volatile.LoadUint32(&o.SLC_AHB_TEST.Reg) & 0x30) >> 4
}
func (o *SLC_Type) SetSLC_AHB_TEST_SLC_AHB_TESTMODE(value uint32) {
	volatile.StoreUint32(&o.SLC_AHB_TEST.Reg, volatile.LoadUint32(&o.SLC_AHB_TEST.Reg)&^(0x7)|value)
}
func (o *SLC_Type) GetSLC_AHB_TEST_SLC_AHB_TESTMODE() uint32 {
	return volatile.LoadUint32(&o.SLC_AHB_TEST.Reg) & 0x7
}

// SLC.SLC_SDIO_ST: SLC_SDIO_ST
func (o *SLC_Type) SetSLC_SDIO_ST_SLC_BUS_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_SDIO_ST.Reg, volatile.LoadUint32(&o.SLC_SDIO_ST.Reg)&^(0x7000)|value<<12)
}
func (o *SLC_Type) GetSLC_SDIO_ST_SLC_BUS_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_SDIO_ST.Reg) & 0x7000) >> 12
}
func (o *SLC_Type) SetSLC_SDIO_ST_SLC_SDIO_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.SLC_SDIO_ST.Reg, volatile.LoadUint32(&o.SLC_SDIO_ST.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_SDIO_ST_SLC_SDIO_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.SLC_SDIO_ST.Reg) & 0x100) >> 8
}
func (o *SLC_Type) SetSLC_SDIO_ST_SLC_FUNC_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_SDIO_ST.Reg, volatile.LoadUint32(&o.SLC_SDIO_ST.Reg)&^(0xf0)|value<<4)
}
func (o *SLC_Type) GetSLC_SDIO_ST_SLC_FUNC_ST() uint32 {
	return (volatile.LoadUint32(&o.SLC_SDIO_ST.Reg) & 0xf0) >> 4
}
func (o *SLC_Type) SetSLC_SDIO_ST_SLC_CMD_ST(value uint32) {
	volatile.StoreUint32(&o.SLC_SDIO_ST.Reg, volatile.LoadUint32(&o.SLC_SDIO_ST.Reg)&^(0x7)|value)
}
func (o *SLC_Type) GetSLC_SDIO_ST_SLC_CMD_ST() uint32 {
	return volatile.LoadUint32(&o.SLC_SDIO_ST.Reg) & 0x7
}

// SLC.SLC_RX_DSCR_CONF: SLC_RX_DSCR_CONF
func (o *SLC_Type) SetSLC_RX_DSCR_CONF_SLC_INFOR_NO_REPLACE(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_DSCR_CONF.Reg, volatile.LoadUint32(&o.SLC_RX_DSCR_CONF.Reg)&^(0x200)|value<<9)
}
func (o *SLC_Type) GetSLC_RX_DSCR_CONF_SLC_INFOR_NO_REPLACE() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_DSCR_CONF.Reg) & 0x200) >> 9
}
func (o *SLC_Type) SetSLC_RX_DSCR_CONF_SLC_TOKEN_NO_REPLACE(value uint32) {
	volatile.StoreUint32(&o.SLC_RX_DSCR_CONF.Reg, volatile.LoadUint32(&o.SLC_RX_DSCR_CONF.Reg)&^(0x100)|value<<8)
}
func (o *SLC_Type) GetSLC_RX_DSCR_CONF_SLC_TOKEN_NO_REPLACE() uint32 {
	return (volatile.LoadUint32(&o.SLC_RX_DSCR_CONF.Reg) & 0x100) >> 8
}

// SLC.SLC_TXLINK_DSCR: SLC_TXLINK_DSCR
func (o *SLC_Type) SetSLC_TXLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.SLC_TXLINK_DSCR.Reg, value)
}
func (o *SLC_Type) GetSLC_TXLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.SLC_TXLINK_DSCR.Reg)
}

// SLC.SLC_TXLINK_DSCR_BF0: SLC_TXLINK_DSCR_BF0
func (o *SLC_Type) SetSLC_TXLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.SLC_TXLINK_DSCR_BF0.Reg, value)
}
func (o *SLC_Type) GetSLC_TXLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.SLC_TXLINK_DSCR_BF0.Reg)
}

// SLC.SLC_TXLINK_DSCR_BF1: SLC_TXLINK_DSCR_BF1
func (o *SLC_Type) SetSLC_TXLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.SLC_TXLINK_DSCR_BF1.Reg, value)
}
func (o *SLC_Type) GetSLC_TXLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.SLC_TXLINK_DSCR_BF1.Reg)
}

// SLC.SLC_RXLINK_DSCR: SLC_RXLINK_DSCR
func (o *SLC_Type) SetSLC_RXLINK_DSCR(value uint32) {
	volatile.StoreUint32(&o.SLC_RXLINK_DSCR.Reg, value)
}
func (o *SLC_Type) GetSLC_RXLINK_DSCR() uint32 {
	return volatile.LoadUint32(&o.SLC_RXLINK_DSCR.Reg)
}

// SLC.SLC_RXLINK_DSCR_BF0: SLC_RXLINK_DSCR_BF0
func (o *SLC_Type) SetSLC_RXLINK_DSCR_BF0(value uint32) {
	volatile.StoreUint32(&o.SLC_RXLINK_DSCR_BF0.Reg, value)
}
func (o *SLC_Type) GetSLC_RXLINK_DSCR_BF0() uint32 {
	return volatile.LoadUint32(&o.SLC_RXLINK_DSCR_BF0.Reg)
}

// SLC.SLC_RXLINK_DSCR_BF1: SLC_RXLINK_DSCR_BF1
func (o *SLC_Type) SetSLC_RXLINK_DSCR_BF1(value uint32) {
	volatile.StoreUint32(&o.SLC_RXLINK_DSCR_BF1.Reg, value)
}
func (o *SLC_Type) GetSLC_RXLINK_DSCR_BF1() uint32 {
	return volatile.LoadUint32(&o.SLC_RXLINK_DSCR_BF1.Reg)
}

// SLC.SLC_DATE: SLC_DATE
func (o *SLC_Type) SetSLC_DATE(value uint32) {
	volatile.StoreUint32(&o.SLC_DATE.Reg, value)
}
func (o *SLC_Type) GetSLC_DATE() uint32 {
	return volatile.LoadUint32(&o.SLC_DATE.Reg)
}

// SLC.SLC_ID: SLC_ID
func (o *SLC_Type) SetSLC_ID(value uint32) {
	volatile.StoreUint32(&o.SLC_ID.Reg, value)
}
func (o *SLC_Type) GetSLC_ID() uint32 {
	return volatile.LoadUint32(&o.SLC_ID.Reg)
}

type SPI0_Type struct {
	SPI_CMD       volatile.Register32 // 0x0
	SPI_ADDR      volatile.Register32 // 0x4
	SPI_CTRL      volatile.Register32 // 0x8
	SPI_CTRL1     volatile.Register32 // 0xC
	SPI_RD_STATUS volatile.Register32 // 0x10
	SPI_CTRL2     volatile.Register32 // 0x14
	SPI_CLOCK     volatile.Register32 // 0x18
	SPI_USER      volatile.Register32 // 0x1C
	SPI_USER1     volatile.Register32 // 0x20
	SPI_USER2     volatile.Register32 // 0x24
	SPI_WR_STATUS volatile.Register32 // 0x28
	SPI_PIN       volatile.Register32 // 0x2C
	SPI_SLAVE     volatile.Register32 // 0x30
	SPI_SLAVE1    volatile.Register32 // 0x34
	SPI_SLAVE2    volatile.Register32 // 0x38
	SPI_SLAVE3    volatile.Register32 // 0x3C
	SPI_W0        volatile.Register32 // 0x40
	_             [28]byte
	SPI_W1        volatile.Register32 // 0x60
	_             [28]byte
	SPI_W2        volatile.Register32 // 0x80
	_             [28]byte
	SPI_W3        volatile.Register32 // 0xA0
	_             [28]byte
	SPI_W4        volatile.Register32 // 0xC0
	_             [28]byte
	SPI_W5        volatile.Register32 // 0xE0
	_             [24]byte
	SPI_EXT3      volatile.Register32 // 0xFC
	SPI_W6        volatile.Register32 // 0x100
	_             [28]byte
	SPI_W7        volatile.Register32 // 0x120
	_             [28]byte
	SPI_W8        volatile.Register32 // 0x140
	_             [28]byte
	SPI_W9        volatile.Register32 // 0x160
	_             [28]byte
	SPI_W10       volatile.Register32 // 0x180
	_             [28]byte
	SPI_W11       volatile.Register32 // 0x1A0
	_             [28]byte
	SPI_W12       volatile.Register32 // 0x1C0
	_             [28]byte
	SPI_W13       volatile.Register32 // 0x1E0
	_             [28]byte
	SPI_W14       volatile.Register32 // 0x200
	_             [28]byte
	SPI_W15       volatile.Register32 // 0x220
}

// SPI0.SPI_CMD: In the master mode, it is the start bit of a single operation. Self-clear by hardware
func (o *SPI0_Type) SetSPI_CMD_SPI_USR(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x40000)|value<<18)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_USR() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x40000) >> 18
}
func (o *SPI0_Type) SetSPI_CMD_SPI_READ(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_READ() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x80000000) >> 31
}
func (o *SPI0_Type) SetSPI_CMD_SPI_WRITE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_WRITE_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_CMD_SPI_WRITE_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_WRITE_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_CMD_SPI_READ_ID(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_READ_ID() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_CMD_SPI_READ_SR(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_READ_SR() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_CMD_SPI_WRITE_SR(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_WRITE_SR() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_CMD_SPI_PP(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_PP() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x2000000) >> 25
}
func (o *SPI0_Type) SetSPI_CMD_SPI_SE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_SE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_CMD_SPI_BE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_BE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x800000) >> 23
}
func (o *SPI0_Type) SetSPI_CMD_SPI_CE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x400000)|value<<22)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_CE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x400000) >> 22
}
func (o *SPI0_Type) SetSPI_CMD_SPI_DP(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x200000)|value<<21)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_DP() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x200000) >> 21
}
func (o *SPI0_Type) SetSPI_CMD_SPI_RES(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_RES() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x100000) >> 20
}
func (o *SPI0_Type) SetSPI_CMD_SPI_HPM(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x80000)|value<<19)
}
func (o *SPI0_Type) GetSPI_CMD_SPI_HPM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x80000) >> 19
}

// SPI0.SPI_ADDR: In the master mode, it is the value of address in "address" phase.
func (o *SPI0_Type) SetSPI_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_ADDR.Reg, value)
}
func (o *SPI0_Type) GetSPI_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_ADDR.Reg)
}
func (o *SPI0_Type) SetSPI_ADDR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.SPI_ADDR.Reg, volatile.LoadUint32(&o.SPI_ADDR.Reg)&^(0xffffff)|value)
}
func (o *SPI0_Type) GetSPI_ADDR_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.SPI_ADDR.Reg) & 0xffffff
}
func (o *SPI0_Type) SetSPI_ADDR_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_ADDR.Reg, volatile.LoadUint32(&o.SPI_ADDR.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_ADDR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SPI_ADDR.Reg) & 0xff000000) >> 24
}

// SPI0.SPI_CTRL: SPI_CTRL
func (o *SPI0_Type) SetSPI_CTRL_SPI_WR_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_WR_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x4000000) >> 26
}
func (o *SPI0_Type) SetSPI_CTRL_SPI_RD_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_RD_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x2000000) >> 25
}
func (o *SPI0_Type) SetSPI_CTRL_SPI_QIO_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_QIO_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_CTRL_SPI_DIO_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_DIO_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x800000) >> 23
}
func (o *SPI0_Type) SetSPI_CTRL_SPI_QOUT_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_QOUT_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x100000) >> 20
}
func (o *SPI0_Type) SetSPI_CTRL_SPI_DOUT_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_DOUT_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPI_CTRL_SPI_FASTRD_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPI_CTRL_SPI_FASTRD_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x2000) >> 13
}

// SPI0.SPI_CTRL1
func (o *SPI0_Type) SetSPI_CTRL1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL1.Reg, volatile.LoadUint32(&o.SPI_CTRL1.Reg)&^(0xffff)|value)
}
func (o *SPI0_Type) GetSPI_CTRL1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_CTRL1.Reg) & 0xffff
}
func (o *SPI0_Type) SetSPI_CTRL1_WB_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL1.Reg, volatile.LoadUint32(&o.SPI_CTRL1.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_CTRL1_WB_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL1.Reg) & 0xff0000) >> 16
}
func (o *SPI0_Type) SetSPI_CTRL1_STATUS_EXT(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL1.Reg, volatile.LoadUint32(&o.SPI_CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_CTRL1_STATUS_EXT() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL1.Reg) & 0xff000000) >> 24
}

// SPI0.SPI_RD_STATUS: In the slave mode, this register are the status register for the master to read out.
func (o *SPI0_Type) SetSPI_RD_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_RD_STATUS.Reg, value)
}
func (o *SPI0_Type) GetSPI_RD_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_RD_STATUS.Reg)
}

// SPI0.SPI_CTRL2: spi_cs signal is delayed by 80MHz clock cycles
func (o *SPI0_Type) SetSPI_CTRL2_SPI_CS_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_CTRL2_SPI_CS_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0xf0000000) >> 28
}
func (o *SPI0_Type) SetSPI_CTRL2_SPI_CS_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0xc000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_CTRL2_SPI_CS_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0xc000000) >> 26
}
func (o *SPI0_Type) SetSPI_CTRL2_SPI_MOSI_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x3800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_CTRL2_SPI_MOSI_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x3800000) >> 23
}
func (o *SPI0_Type) SetSPI_CTRL2_SPI_MOSI_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x600000)|value<<21)
}
func (o *SPI0_Type) GetSPI_CTRL2_SPI_MOSI_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x600000) >> 21
}
func (o *SPI0_Type) SetSPI_CTRL2_SPI_MISO_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SPI0_Type) GetSPI_CTRL2_SPI_MISO_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x1c0000) >> 18
}
func (o *SPI0_Type) SetSPI_CTRL2_SPI_MISO_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x30000)|value<<16)
}
func (o *SPI0_Type) GetSPI_CTRL2_SPI_MISO_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x30000) >> 16
}

// SPI0.SPI_CLOCK: In the master mode, 1: spi_clk is eqaul to 80MHz, 0: spi_clk is divided from 80 MHz clock.
func (o *SPI0_Type) SetSPI_CLOCK_SPI_CLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_CLOCK_SPI_CLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x80000000) >> 31
}
func (o *SPI0_Type) SetSPI_CLOCK_SPI_CLKDIV_PRE(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x7ffc0000)|value<<18)
}
func (o *SPI0_Type) GetSPI_CLOCK_SPI_CLKDIV_PRE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x7ffc0000) >> 18
}
func (o *SPI0_Type) SetSPI_CLOCK_SPI_CLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x3f000)|value<<12)
}
func (o *SPI0_Type) GetSPI_CLOCK_SPI_CLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x3f000) >> 12
}
func (o *SPI0_Type) SetSPI_CLOCK_SPI_CLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0xfc0)|value<<6)
}
func (o *SPI0_Type) GetSPI_CLOCK_SPI_CLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0xfc0) >> 6
}
func (o *SPI0_Type) SetSPI_CLOCK_SPI_CLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x3f)|value)
}
func (o *SPI0_Type) GetSPI_CLOCK_SPI_CLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x3f
}

// SPI0.SPI_USER: This bit enable the "command" phase of an operation.
func (o *SPI0_Type) SetSPI_USER_SPI_USR_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_USER_SPI_USR_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x80000000) >> 31
}
func (o *SPI0_Type) SetSPI_USER_SPI_USR_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_USER_SPI_USR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_USER_SPI_USR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_USER_SPI_USR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x20000000) >> 29
}
func (o *SPI0_Type) SetSPI_USER_SPI_USR_MISO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_USER_SPI_USR_MISO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x10000000) >> 28
}
func (o *SPI0_Type) SetSPI_USER_SPI_USR_MOSI(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_USER_SPI_USR_MOSI() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_USER_REG_USR_MOSI_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI0_Type) GetSPI_USER_REG_USR_MOSI_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x2000000) >> 25
}
func (o *SPI0_Type) SetSPI_USER_REG_USR_MISO_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_USER_REG_USR_MISO_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x1000000) >> 24
}
func (o *SPI0_Type) SetSPI_USER_SPI_SIO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x10000)|value<<16)
}
func (o *SPI0_Type) GetSPI_USER_SPI_SIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x10000) >> 16
}
func (o *SPI0_Type) SetSPI_USER_SPI_FWRITE_QIO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPI_USER_SPI_FWRITE_QIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPI_USER_SPI_FWRITE_DIO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPI_USER_SPI_FWRITE_DIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPI_USER_SPI_FWRITE_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPI_USER_SPI_FWRITE_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPI_USER_SPI_FWRITE_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPI_USER_SPI_FWRITE_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPI_USER_SPI_WR_BYTE_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x800)|value<<11)
}
func (o *SPI0_Type) GetSPI_USER_SPI_WR_BYTE_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x800) >> 11
}
func (o *SPI0_Type) SetSPI_USER_SPI_RD_BYTE_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x400)|value<<10)
}
func (o *SPI0_Type) GetSPI_USER_SPI_RD_BYTE_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x400) >> 10
}
func (o *SPI0_Type) SetSPI_USER_SPI_CK_I_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPI_USER_SPI_CK_I_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPI_USER_SPI_CK_O_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPI_USER_SPI_CK_O_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPI_USER_SPI_CS_SETUP(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPI_USER_SPI_CS_SETUP() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPI_USER_SPI_CS_HOLD(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_USER_SPI_CS_HOLD() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_USER_SPI_AHB_USER_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_USER_SPI_AHB_USER_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_USER_SPI_FLASH_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_USER_SPI_FLASH_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_USER_SPI_AHB_USER_COMMAND_4BYTE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_USER_SPI_AHB_USER_COMMAND_4BYTE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_USER_SPI_DUPLEX(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_USER_SPI_DUPLEX() uint32 {
	return volatile.LoadUint32(&o.SPI_USER.Reg) & 0x1
}

// SPI0.SPI_USER1: The length in bits of "address" phase. The register value shall be (bit_num-1)
func (o *SPI0_Type) SetSPI_USER1_REG_USR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0xfc000000)|value<<26)
}
func (o *SPI0_Type) GetSPI_USER1_REG_USR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER1.Reg) & 0xfc000000) >> 26
}
func (o *SPI0_Type) SetSPI_USER1_REG_USR_MOSI_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0x3fe0000)|value<<17)
}
func (o *SPI0_Type) GetSPI_USER1_REG_USR_MOSI_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER1.Reg) & 0x3fe0000) >> 17
}
func (o *SPI0_Type) SetSPI_USER1_REG_USR_MISO_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0x1ff00)|value<<8)
}
func (o *SPI0_Type) GetSPI_USER1_REG_USR_MISO_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER1.Reg) & 0x1ff00) >> 8
}
func (o *SPI0_Type) SetSPI_USER1_REG_USR_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSPI_USER1_REG_USR_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.SPI_USER1.Reg) & 0xff
}

// SPI0.SPI_USER2: The length in bits of "command" phase. The register value shall be (bit_num-1)
func (o *SPI0_Type) SetSPI_USER2_REG_USR_COMMAND_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER2.Reg, volatile.LoadUint32(&o.SPI_USER2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI0_Type) GetSPI_USER2_REG_USR_COMMAND_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER2.Reg) & 0xf0000000) >> 28
}
func (o *SPI0_Type) SetSPI_USER2_REG_USR_COMMAND_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER2.Reg, volatile.LoadUint32(&o.SPI_USER2.Reg)&^(0xffff)|value)
}
func (o *SPI0_Type) GetSPI_USER2_REG_USR_COMMAND_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_USER2.Reg) & 0xffff
}

// SPI0.SPI_WR_STATUS: In the slave mode, this register are the status register for the master to write into.
func (o *SPI0_Type) SetSPI_WR_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_WR_STATUS.Reg, value)
}
func (o *SPI0_Type) GetSPI_WR_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_WR_STATUS.Reg)
}

// SPI0.SPI_PIN: 1: disable CS2; 0: spi_cs signal is from/to CS2 pin
func (o *SPI0_Type) SetSPI_PIN_SPI_CS2_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_PIN_SPI_CS2_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_PIN_SPI_CS1_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_PIN_SPI_CS1_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_PIN_SPI_CS0_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_PIN_SPI_CS0_DIS() uint32 {
	return volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x1
}
func (o *SPI0_Type) SetSPI_PIN_SPI_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI0_Type) GetSPI_PIN_SPI_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x20000000) >> 29
}

// SPI0.SPI_SLAVE: It is the synchronous reset signal of the module. This bit is self-cleared by hardware.
func (o *SPI0_Type) SetSPI_SLAVE_SPI_SYNC_RESET(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI0_Type) GetSPI_SLAVE_SPI_SYNC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x80000000) >> 31
}
func (o *SPI0_Type) SetSPI_SLAVE_SPI_SLAVE_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI0_Type) GetSPI_SLAVE_SPI_SLAVE_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x40000000) >> 30
}
func (o *SPI0_Type) SetSPI_SLAVE_SLV_CMD_DEFINE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_SLAVE_SLV_CMD_DEFINE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x8000000) >> 27
}
func (o *SPI0_Type) SetSPI_SLAVE_SPI_TRANS_CNT(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x7800000)|value<<23)
}
func (o *SPI0_Type) GetSPI_SLAVE_SPI_TRANS_CNT() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x7800000) >> 23
}
func (o *SPI0_Type) SetSPI_SLAVE_SPI_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x3e0)|value<<5)
}
func (o *SPI0_Type) GetSPI_SLAVE_SPI_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x3e0) >> 5
}
func (o *SPI0_Type) SetSPI_SLAVE_SPI_TRANS_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPI_SLAVE_SPI_TRANS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPI_SLAVE_SLV_WR_STA_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_SLAVE_SLV_WR_STA_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_SLAVE_SLV_RD_STA_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SLAVE_SLV_RD_STA_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_SLAVE_SLV_WR_BUF_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SLAVE_SLV_WR_BUF_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SLAVE_SLV_RD_BUF_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SLAVE_SLV_RD_BUF_DONE() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x1
}

// SPI0.SPI_SLAVE1: In the slave mode, it is the length in bits for "write-status" and "read-status" operations. The register valueshall be (bit_num-1)
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_STATUS_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0xf8000000)|value<<27)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_STATUS_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0xf8000000) >> 27
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_BUF_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x1ff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_BUF_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x1ff0000) >> 16
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_RD_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0xfc00)|value<<10)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_RD_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0xfc00) >> 10
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_WR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x3f0)|value<<4)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_WR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x3f0) >> 4
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_WRSTA_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_WRSTA_DUMMY_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_RDSTA_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_RDSTA_DUMMY_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_WRBUF_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_WRBUF_DUMMY_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPI_SLAVE1_SLV_RDBUF_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPI_SLAVE1_SLV_RDBUF_DUMMY_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x1
}

// SPI0.SPI_SLAVE2: In the slave mode, it is the length in spi_clk cycles "dummy" phase for "write-buffer" operations. The registervalue shall be (cycle_num-1)
func (o *SPI0_Type) SetSPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff000000) >> 24
}
func (o *SPI0_Type) SetSPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff0000) >> 16
}
func (o *SPI0_Type) SetSPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff00)|value<<8)
}
func (o *SPI0_Type) GetSPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff00) >> 8
}
func (o *SPI0_Type) SetSPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff
}

// SPI0.SPI_SLAVE3: In slave mode, it is the value of "write-status" command
func (o *SPI0_Type) SetSPI_SLAVE3_SLV_WRSTA_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI0_Type) GetSPI_SLAVE3_SLV_WRSTA_CMD_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff000000) >> 24
}
func (o *SPI0_Type) SetSPI_SLAVE3_SLV_RDSTA_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI0_Type) GetSPI_SLAVE3_SLV_RDSTA_CMD_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff0000) >> 16
}
func (o *SPI0_Type) SetSPI_SLAVE3_SLV_WRBUF_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff00)|value<<8)
}
func (o *SPI0_Type) GetSPI_SLAVE3_SLV_WRBUF_CMD_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff00) >> 8
}
func (o *SPI0_Type) SetSPI_SLAVE3_SLV_RDBUF_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSPI_SLAVE3_SLV_RDBUF_CMD_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff
}

// SPI0.SPI_W0: the data inside the buffer of the SPI module, byte 0
func (o *SPI0_Type) SetSPI_W0(value uint32) {
	volatile.StoreUint32(&o.SPI_W0.Reg, value)
}
func (o *SPI0_Type) GetSPI_W0() uint32 {
	return volatile.LoadUint32(&o.SPI_W0.Reg)
}

// SPI0.SPI_W1: the data inside the buffer of the SPI module, byte 1
func (o *SPI0_Type) SetSPI_W1(value uint32) {
	volatile.StoreUint32(&o.SPI_W1.Reg, value)
}
func (o *SPI0_Type) GetSPI_W1() uint32 {
	return volatile.LoadUint32(&o.SPI_W1.Reg)
}

// SPI0.SPI_W2: the data inside the buffer of the SPI module, byte 2
func (o *SPI0_Type) SetSPI_W2(value uint32) {
	volatile.StoreUint32(&o.SPI_W2.Reg, value)
}
func (o *SPI0_Type) GetSPI_W2() uint32 {
	return volatile.LoadUint32(&o.SPI_W2.Reg)
}

// SPI0.SPI_W3: the data inside the buffer of the SPI module, byte 3
func (o *SPI0_Type) SetSPI_W3(value uint32) {
	volatile.StoreUint32(&o.SPI_W3.Reg, value)
}
func (o *SPI0_Type) GetSPI_W3() uint32 {
	return volatile.LoadUint32(&o.SPI_W3.Reg)
}

// SPI0.SPI_W4: the data inside the buffer of the SPI module, byte 4
func (o *SPI0_Type) SetSPI_W4(value uint32) {
	volatile.StoreUint32(&o.SPI_W4.Reg, value)
}
func (o *SPI0_Type) GetSPI_W4() uint32 {
	return volatile.LoadUint32(&o.SPI_W4.Reg)
}

// SPI0.SPI_W5: the data inside the buffer of the SPI module, byte 5
func (o *SPI0_Type) SetSPI_W5(value uint32) {
	volatile.StoreUint32(&o.SPI_W5.Reg, value)
}
func (o *SPI0_Type) GetSPI_W5() uint32 {
	return volatile.LoadUint32(&o.SPI_W5.Reg)
}

// SPI0.SPI_EXT3: This register is for two SPI masters to share the same cs, clock and data signals.
func (o *SPI0_Type) SetSPI_EXT3_REG_INT_HOLD_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_EXT3.Reg, volatile.LoadUint32(&o.SPI_EXT3.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPI_EXT3_REG_INT_HOLD_ENA() uint32 {
	return volatile.LoadUint32(&o.SPI_EXT3.Reg) & 0x3
}

// SPI0.SPI_W6: the data inside the buffer of the SPI module, byte 6
func (o *SPI0_Type) SetSPI_W6(value uint32) {
	volatile.StoreUint32(&o.SPI_W6.Reg, value)
}
func (o *SPI0_Type) GetSPI_W6() uint32 {
	return volatile.LoadUint32(&o.SPI_W6.Reg)
}

// SPI0.SPI_W7: the data inside the buffer of the SPI module, byte 7
func (o *SPI0_Type) SetSPI_W7(value uint32) {
	volatile.StoreUint32(&o.SPI_W7.Reg, value)
}
func (o *SPI0_Type) GetSPI_W7() uint32 {
	return volatile.LoadUint32(&o.SPI_W7.Reg)
}

// SPI0.SPI_W8: the data inside the buffer of the SPI module, byte 8
func (o *SPI0_Type) SetSPI_W8(value uint32) {
	volatile.StoreUint32(&o.SPI_W8.Reg, value)
}
func (o *SPI0_Type) GetSPI_W8() uint32 {
	return volatile.LoadUint32(&o.SPI_W8.Reg)
}

// SPI0.SPI_W9: the data inside the buffer of the SPI module, byte 9
func (o *SPI0_Type) SetSPI_W9(value uint32) {
	volatile.StoreUint32(&o.SPI_W9.Reg, value)
}
func (o *SPI0_Type) GetSPI_W9() uint32 {
	return volatile.LoadUint32(&o.SPI_W9.Reg)
}

// SPI0.SPI_W10: the data inside the buffer of the SPI module, byte 10
func (o *SPI0_Type) SetSPI_W10(value uint32) {
	volatile.StoreUint32(&o.SPI_W10.Reg, value)
}
func (o *SPI0_Type) GetSPI_W10() uint32 {
	return volatile.LoadUint32(&o.SPI_W10.Reg)
}

// SPI0.SPI_W11: the data inside the buffer of the SPI module, byte 11
func (o *SPI0_Type) SetSPI_W11(value uint32) {
	volatile.StoreUint32(&o.SPI_W11.Reg, value)
}
func (o *SPI0_Type) GetSPI_W11() uint32 {
	return volatile.LoadUint32(&o.SPI_W11.Reg)
}

// SPI0.SPI_W12: the data inside the buffer of the SPI module, byte 12
func (o *SPI0_Type) SetSPI_W12(value uint32) {
	volatile.StoreUint32(&o.SPI_W12.Reg, value)
}
func (o *SPI0_Type) GetSPI_W12() uint32 {
	return volatile.LoadUint32(&o.SPI_W12.Reg)
}

// SPI0.SPI_W13: the data inside the buffer of the SPI module, byte 13
func (o *SPI0_Type) SetSPI_W13(value uint32) {
	volatile.StoreUint32(&o.SPI_W13.Reg, value)
}
func (o *SPI0_Type) GetSPI_W13() uint32 {
	return volatile.LoadUint32(&o.SPI_W13.Reg)
}

// SPI0.SPI_W14: the data inside the buffer of the SPI module, byte 14
func (o *SPI0_Type) SetSPI_W14(value uint32) {
	volatile.StoreUint32(&o.SPI_W14.Reg, value)
}
func (o *SPI0_Type) GetSPI_W14() uint32 {
	return volatile.LoadUint32(&o.SPI_W14.Reg)
}

// SPI0.SPI_W15: the data inside the buffer of the SPI module, byte 15
func (o *SPI0_Type) SetSPI_W15(value uint32) {
	volatile.StoreUint32(&o.SPI_W15.Reg, value)
}
func (o *SPI0_Type) GetSPI_W15() uint32 {
	return volatile.LoadUint32(&o.SPI_W15.Reg)
}

type SPI1_Type struct {
	SPI_CMD       volatile.Register32 // 0x0
	SPI_ADDR      volatile.Register32 // 0x4
	SPI_CTRL      volatile.Register32 // 0x8
	SPI_CTRL1     volatile.Register32 // 0xC
	SPI_RD_STATUS volatile.Register32 // 0x10
	SPI_CTRL2     volatile.Register32 // 0x14
	SPI_CLOCK     volatile.Register32 // 0x18
	SPI_USER      volatile.Register32 // 0x1C
	SPI_USER1     volatile.Register32 // 0x20
	SPI_USER2     volatile.Register32 // 0x24
	SPI_WR_STATUS volatile.Register32 // 0x28
	SPI_PIN       volatile.Register32 // 0x2C
	SPI_SLAVE     volatile.Register32 // 0x30
	SPI_SLAVE1    volatile.Register32 // 0x34
	SPI_SLAVE2    volatile.Register32 // 0x38
	SPI_SLAVE3    volatile.Register32 // 0x3C
	SPI_W0        volatile.Register32 // 0x40
	_             [28]byte
	SPI_W1        volatile.Register32 // 0x60
	_             [28]byte
	SPI_W2        volatile.Register32 // 0x80
	_             [28]byte
	SPI_W3        volatile.Register32 // 0xA0
	_             [28]byte
	SPI_W4        volatile.Register32 // 0xC0
	_             [28]byte
	SPI_W5        volatile.Register32 // 0xE0
	_             [24]byte
	SPI_EXT3      volatile.Register32 // 0xFC
	SPI_W6        volatile.Register32 // 0x100
	_             [28]byte
	SPI_W7        volatile.Register32 // 0x120
	_             [28]byte
	SPI_W8        volatile.Register32 // 0x140
	_             [28]byte
	SPI_W9        volatile.Register32 // 0x160
	_             [28]byte
	SPI_W10       volatile.Register32 // 0x180
	_             [28]byte
	SPI_W11       volatile.Register32 // 0x1A0
	_             [28]byte
	SPI_W12       volatile.Register32 // 0x1C0
	_             [28]byte
	SPI_W13       volatile.Register32 // 0x1E0
	_             [28]byte
	SPI_W14       volatile.Register32 // 0x200
	_             [28]byte
	SPI_W15       volatile.Register32 // 0x220
}

// SPI1.SPI_CMD: In the master mode, it is the start bit of a single operation. Self-clear by hardware
func (o *SPI1_Type) SetSPI_CMD_SPI_USR(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x40000)|value<<18)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_USR() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x40000) >> 18
}
func (o *SPI1_Type) SetSPI_CMD_SPI_READ(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_READ() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x80000000) >> 31
}
func (o *SPI1_Type) SetSPI_CMD_SPI_WRITE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_WRITE_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x40000000) >> 30
}
func (o *SPI1_Type) SetSPI_CMD_SPI_WRITE_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_WRITE_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x20000000) >> 29
}
func (o *SPI1_Type) SetSPI_CMD_SPI_READ_ID(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_READ_ID() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x10000000) >> 28
}
func (o *SPI1_Type) SetSPI_CMD_SPI_READ_SR(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_READ_SR() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x8000000) >> 27
}
func (o *SPI1_Type) SetSPI_CMD_SPI_WRITE_SR(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_WRITE_SR() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x4000000) >> 26
}
func (o *SPI1_Type) SetSPI_CMD_SPI_PP(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_PP() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x2000000) >> 25
}
func (o *SPI1_Type) SetSPI_CMD_SPI_SE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_SE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_CMD_SPI_BE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_BE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x800000) >> 23
}
func (o *SPI1_Type) SetSPI_CMD_SPI_CE(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x400000)|value<<22)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_CE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x400000) >> 22
}
func (o *SPI1_Type) SetSPI_CMD_SPI_DP(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x200000)|value<<21)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_DP() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x200000) >> 21
}
func (o *SPI1_Type) SetSPI_CMD_SPI_RES(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x100000)|value<<20)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_RES() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x100000) >> 20
}
func (o *SPI1_Type) SetSPI_CMD_SPI_HPM(value uint32) {
	volatile.StoreUint32(&o.SPI_CMD.Reg, volatile.LoadUint32(&o.SPI_CMD.Reg)&^(0x80000)|value<<19)
}
func (o *SPI1_Type) GetSPI_CMD_SPI_HPM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CMD.Reg) & 0x80000) >> 19
}

// SPI1.SPI_ADDR: In the master mode, it is the value of address in "address" phase.
func (o *SPI1_Type) SetSPI_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_ADDR.Reg, value)
}
func (o *SPI1_Type) GetSPI_ADDR() uint32 {
	return volatile.LoadUint32(&o.SPI_ADDR.Reg)
}
func (o *SPI1_Type) SetSPI_ADDR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.SPI_ADDR.Reg, volatile.LoadUint32(&o.SPI_ADDR.Reg)&^(0xffffff)|value)
}
func (o *SPI1_Type) GetSPI_ADDR_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.SPI_ADDR.Reg) & 0xffffff
}
func (o *SPI1_Type) SetSPI_ADDR_SIZE(value uint32) {
	volatile.StoreUint32(&o.SPI_ADDR.Reg, volatile.LoadUint32(&o.SPI_ADDR.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_ADDR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.SPI_ADDR.Reg) & 0xff000000) >> 24
}

// SPI1.SPI_CTRL: SPI_CTRL
func (o *SPI1_Type) SetSPI_CTRL_SPI_WR_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_WR_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x4000000) >> 26
}
func (o *SPI1_Type) SetSPI_CTRL_SPI_RD_BIT_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_RD_BIT_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x2000000) >> 25
}
func (o *SPI1_Type) SetSPI_CTRL_SPI_QIO_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_QIO_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_CTRL_SPI_DIO_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_DIO_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x800000) >> 23
}
func (o *SPI1_Type) SetSPI_CTRL_SPI_QOUT_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_QOUT_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x100000) >> 20
}
func (o *SPI1_Type) SetSPI_CTRL_SPI_DOUT_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_DOUT_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x4000) >> 14
}
func (o *SPI1_Type) SetSPI_CTRL_SPI_FASTRD_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL.Reg, volatile.LoadUint32(&o.SPI_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SPI1_Type) GetSPI_CTRL_SPI_FASTRD_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL.Reg) & 0x2000) >> 13
}

// SPI1.SPI_CTRL1
func (o *SPI1_Type) SetSPI_CTRL1_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL1.Reg, volatile.LoadUint32(&o.SPI_CTRL1.Reg)&^(0xffff)|value)
}
func (o *SPI1_Type) GetSPI_CTRL1_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_CTRL1.Reg) & 0xffff
}
func (o *SPI1_Type) SetSPI_CTRL1_WB_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL1.Reg, volatile.LoadUint32(&o.SPI_CTRL1.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_CTRL1_WB_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL1.Reg) & 0xff0000) >> 16
}
func (o *SPI1_Type) SetSPI_CTRL1_STATUS_EXT(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL1.Reg, volatile.LoadUint32(&o.SPI_CTRL1.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_CTRL1_STATUS_EXT() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL1.Reg) & 0xff000000) >> 24
}

// SPI1.SPI_RD_STATUS: In the slave mode, this register are the status register for the master to read out.
func (o *SPI1_Type) SetSPI_RD_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_RD_STATUS.Reg, value)
}
func (o *SPI1_Type) GetSPI_RD_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_RD_STATUS.Reg)
}

// SPI1.SPI_CTRL2: spi_cs signal is delayed by 80MHz clock cycles
func (o *SPI1_Type) SetSPI_CTRL2_SPI_CS_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_CTRL2_SPI_CS_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0xf0000000) >> 28
}
func (o *SPI1_Type) SetSPI_CTRL2_SPI_CS_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0xc000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_CTRL2_SPI_CS_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0xc000000) >> 26
}
func (o *SPI1_Type) SetSPI_CTRL2_SPI_MOSI_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x3800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_CTRL2_SPI_MOSI_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x3800000) >> 23
}
func (o *SPI1_Type) SetSPI_CTRL2_SPI_MOSI_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x600000)|value<<21)
}
func (o *SPI1_Type) GetSPI_CTRL2_SPI_MOSI_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x600000) >> 21
}
func (o *SPI1_Type) SetSPI_CTRL2_SPI_MISO_DELAY_NUM(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x1c0000)|value<<18)
}
func (o *SPI1_Type) GetSPI_CTRL2_SPI_MISO_DELAY_NUM() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x1c0000) >> 18
}
func (o *SPI1_Type) SetSPI_CTRL2_SPI_MISO_DELAY_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRL2.Reg, volatile.LoadUint32(&o.SPI_CTRL2.Reg)&^(0x30000)|value<<16)
}
func (o *SPI1_Type) GetSPI_CTRL2_SPI_MISO_DELAY_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRL2.Reg) & 0x30000) >> 16
}

// SPI1.SPI_CLOCK: In the master mode, 1: spi_clk is eqaul to 80MHz, 0: spi_clk is divided from 80 MHz clock.
func (o *SPI1_Type) SetSPI_CLOCK_SPI_CLK_EQU_SYSCLK(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_CLOCK_SPI_CLK_EQU_SYSCLK() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x80000000) >> 31
}
func (o *SPI1_Type) SetSPI_CLOCK_SPI_CLKDIV_PRE(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x7ffc0000)|value<<18)
}
func (o *SPI1_Type) GetSPI_CLOCK_SPI_CLKDIV_PRE() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x7ffc0000) >> 18
}
func (o *SPI1_Type) SetSPI_CLOCK_SPI_CLKCNT_N(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x3f000)|value<<12)
}
func (o *SPI1_Type) GetSPI_CLOCK_SPI_CLKCNT_N() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x3f000) >> 12
}
func (o *SPI1_Type) SetSPI_CLOCK_SPI_CLKCNT_H(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0xfc0)|value<<6)
}
func (o *SPI1_Type) GetSPI_CLOCK_SPI_CLKCNT_H() uint32 {
	return (volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0xfc0) >> 6
}
func (o *SPI1_Type) SetSPI_CLOCK_SPI_CLKCNT_L(value uint32) {
	volatile.StoreUint32(&o.SPI_CLOCK.Reg, volatile.LoadUint32(&o.SPI_CLOCK.Reg)&^(0x3f)|value)
}
func (o *SPI1_Type) GetSPI_CLOCK_SPI_CLKCNT_L() uint32 {
	return volatile.LoadUint32(&o.SPI_CLOCK.Reg) & 0x3f
}

// SPI1.SPI_USER: This bit enable the "command" phase of an operation.
func (o *SPI1_Type) SetSPI_USER_SPI_USR_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_USER_SPI_USR_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x80000000) >> 31
}
func (o *SPI1_Type) SetSPI_USER_SPI_USR_ADDR(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI1_Type) GetSPI_USER_SPI_USR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x40000000) >> 30
}
func (o *SPI1_Type) SetSPI_USER_SPI_USR_DUMMY(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI1_Type) GetSPI_USER_SPI_USR_DUMMY() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x20000000) >> 29
}
func (o *SPI1_Type) SetSPI_USER_SPI_USR_MISO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x10000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_USER_SPI_USR_MISO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x10000000) >> 28
}
func (o *SPI1_Type) SetSPI_USER_SPI_USR_MOSI(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_USER_SPI_USR_MOSI() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x8000000) >> 27
}
func (o *SPI1_Type) SetSPI_USER_REG_USR_MOSI_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x2000000)|value<<25)
}
func (o *SPI1_Type) GetSPI_USER_REG_USR_MOSI_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x2000000) >> 25
}
func (o *SPI1_Type) SetSPI_USER_REG_USR_MISO_HIGHPART(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_USER_REG_USR_MISO_HIGHPART() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x1000000) >> 24
}
func (o *SPI1_Type) SetSPI_USER_SPI_SIO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x10000)|value<<16)
}
func (o *SPI1_Type) GetSPI_USER_SPI_SIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x10000) >> 16
}
func (o *SPI1_Type) SetSPI_USER_SPI_FWRITE_QIO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x8000)|value<<15)
}
func (o *SPI1_Type) GetSPI_USER_SPI_FWRITE_QIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x8000) >> 15
}
func (o *SPI1_Type) SetSPI_USER_SPI_FWRITE_DIO(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x4000)|value<<14)
}
func (o *SPI1_Type) GetSPI_USER_SPI_FWRITE_DIO() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x4000) >> 14
}
func (o *SPI1_Type) SetSPI_USER_SPI_FWRITE_QUAD(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x2000)|value<<13)
}
func (o *SPI1_Type) GetSPI_USER_SPI_FWRITE_QUAD() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x2000) >> 13
}
func (o *SPI1_Type) SetSPI_USER_SPI_FWRITE_DUAL(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x1000)|value<<12)
}
func (o *SPI1_Type) GetSPI_USER_SPI_FWRITE_DUAL() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x1000) >> 12
}
func (o *SPI1_Type) SetSPI_USER_SPI_WR_BYTE_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x800)|value<<11)
}
func (o *SPI1_Type) GetSPI_USER_SPI_WR_BYTE_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x800) >> 11
}
func (o *SPI1_Type) SetSPI_USER_SPI_RD_BYTE_ORDER(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x400)|value<<10)
}
func (o *SPI1_Type) GetSPI_USER_SPI_RD_BYTE_ORDER() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x400) >> 10
}
func (o *SPI1_Type) SetSPI_USER_SPI_CK_I_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x40)|value<<6)
}
func (o *SPI1_Type) GetSPI_USER_SPI_CK_I_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x40) >> 6
}
func (o *SPI1_Type) SetSPI_USER_SPI_CK_O_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x80)|value<<7)
}
func (o *SPI1_Type) GetSPI_USER_SPI_CK_O_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x80) >> 7
}
func (o *SPI1_Type) SetSPI_USER_SPI_CS_SETUP(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x20)|value<<5)
}
func (o *SPI1_Type) GetSPI_USER_SPI_CS_SETUP() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x20) >> 5
}
func (o *SPI1_Type) SetSPI_USER_SPI_CS_HOLD(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_USER_SPI_CS_HOLD() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_USER_SPI_AHB_USER_COMMAND(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_USER_SPI_AHB_USER_COMMAND() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_USER_SPI_FLASH_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_USER_SPI_FLASH_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_USER_SPI_AHB_USER_COMMAND_4BYTE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_USER_SPI_AHB_USER_COMMAND_4BYTE() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_USER_SPI_DUPLEX(value uint32) {
	volatile.StoreUint32(&o.SPI_USER.Reg, volatile.LoadUint32(&o.SPI_USER.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_USER_SPI_DUPLEX() uint32 {
	return volatile.LoadUint32(&o.SPI_USER.Reg) & 0x1
}

// SPI1.SPI_USER1: The length in bits of "address" phase. The register value shall be (bit_num-1)
func (o *SPI1_Type) SetSPI_USER1_REG_USR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0xfc000000)|value<<26)
}
func (o *SPI1_Type) GetSPI_USER1_REG_USR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER1.Reg) & 0xfc000000) >> 26
}
func (o *SPI1_Type) SetSPI_USER1_REG_USR_MOSI_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0x3fe0000)|value<<17)
}
func (o *SPI1_Type) GetSPI_USER1_REG_USR_MOSI_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER1.Reg) & 0x3fe0000) >> 17
}
func (o *SPI1_Type) SetSPI_USER1_REG_USR_MISO_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0x1ff00)|value<<8)
}
func (o *SPI1_Type) GetSPI_USER1_REG_USR_MISO_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER1.Reg) & 0x1ff00) >> 8
}
func (o *SPI1_Type) SetSPI_USER1_REG_USR_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER1.Reg, volatile.LoadUint32(&o.SPI_USER1.Reg)&^(0xff)|value)
}
func (o *SPI1_Type) GetSPI_USER1_REG_USR_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.SPI_USER1.Reg) & 0xff
}

// SPI1.SPI_USER2: The length in bits of "command" phase. The register value shall be (bit_num-1)
func (o *SPI1_Type) SetSPI_USER2_REG_USR_COMMAND_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_USER2.Reg, volatile.LoadUint32(&o.SPI_USER2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SPI1_Type) GetSPI_USER2_REG_USR_COMMAND_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_USER2.Reg) & 0xf0000000) >> 28
}
func (o *SPI1_Type) SetSPI_USER2_REG_USR_COMMAND_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_USER2.Reg, volatile.LoadUint32(&o.SPI_USER2.Reg)&^(0xffff)|value)
}
func (o *SPI1_Type) GetSPI_USER2_REG_USR_COMMAND_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_USER2.Reg) & 0xffff
}

// SPI1.SPI_WR_STATUS: In the slave mode, this register are the status register for the master to write into.
func (o *SPI1_Type) SetSPI_WR_STATUS(value uint32) {
	volatile.StoreUint32(&o.SPI_WR_STATUS.Reg, value)
}
func (o *SPI1_Type) GetSPI_WR_STATUS() uint32 {
	return volatile.LoadUint32(&o.SPI_WR_STATUS.Reg)
}

// SPI1.SPI_PIN: 1: disable CS2; 0: spi_cs signal is from/to CS2 pin
func (o *SPI1_Type) SetSPI_PIN_SPI_CS2_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_PIN_SPI_CS2_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_PIN_SPI_CS1_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_PIN_SPI_CS1_DIS() uint32 {
	return (volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_PIN_SPI_CS0_DIS(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_PIN_SPI_CS0_DIS() uint32 {
	return volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x1
}
func (o *SPI1_Type) SetSPI_PIN_SPI_IDLE_EDGE(value uint32) {
	volatile.StoreUint32(&o.SPI_PIN.Reg, volatile.LoadUint32(&o.SPI_PIN.Reg)&^(0x20000000)|value<<29)
}
func (o *SPI1_Type) GetSPI_PIN_SPI_IDLE_EDGE() uint32 {
	return (volatile.LoadUint32(&o.SPI_PIN.Reg) & 0x20000000) >> 29
}

// SPI1.SPI_SLAVE: It is the synchronous reset signal of the module. This bit is self-cleared by hardware.
func (o *SPI1_Type) SetSPI_SLAVE_SPI_SYNC_RESET(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI1_Type) GetSPI_SLAVE_SPI_SYNC_RESET() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x80000000) >> 31
}
func (o *SPI1_Type) SetSPI_SLAVE_SPI_SLAVE_MODE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x40000000)|value<<30)
}
func (o *SPI1_Type) GetSPI_SLAVE_SPI_SLAVE_MODE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x40000000) >> 30
}
func (o *SPI1_Type) SetSPI_SLAVE_SLV_CMD_DEFINE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_SLAVE_SLV_CMD_DEFINE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x8000000) >> 27
}
func (o *SPI1_Type) SetSPI_SLAVE_SPI_TRANS_CNT(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x7800000)|value<<23)
}
func (o *SPI1_Type) GetSPI_SLAVE_SPI_TRANS_CNT() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x7800000) >> 23
}
func (o *SPI1_Type) SetSPI_SLAVE_SPI_INT_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x3e0)|value<<5)
}
func (o *SPI1_Type) GetSPI_SLAVE_SPI_INT_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x3e0) >> 5
}
func (o *SPI1_Type) SetSPI_SLAVE_SPI_TRANS_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x10)|value<<4)
}
func (o *SPI1_Type) GetSPI_SLAVE_SPI_TRANS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x10) >> 4
}
func (o *SPI1_Type) SetSPI_SLAVE_SLV_WR_STA_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_SLAVE_SLV_WR_STA_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_SLAVE_SLV_RD_STA_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_SLAVE_SLV_RD_STA_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_SLAVE_SLV_WR_BUF_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_SLAVE_SLV_WR_BUF_DONE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_SLAVE_SLV_RD_BUF_DONE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE.Reg, volatile.LoadUint32(&o.SPI_SLAVE.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_SLAVE_SLV_RD_BUF_DONE() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE.Reg) & 0x1
}

// SPI1.SPI_SLAVE1: In the slave mode, it is the length in bits for "write-status" and "read-status" operations. The register valueshall be (bit_num-1)
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_STATUS_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0xf8000000)|value<<27)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_STATUS_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0xf8000000) >> 27
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_BUF_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x1ff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_BUF_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x1ff0000) >> 16
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_RD_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0xfc00)|value<<10)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_RD_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0xfc00) >> 10
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_WR_ADDR_BITLEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x3f0)|value<<4)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_WR_ADDR_BITLEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x3f0) >> 4
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_WRSTA_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x8)|value<<3)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_WRSTA_DUMMY_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x8) >> 3
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_RDSTA_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x4)|value<<2)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_RDSTA_DUMMY_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x4) >> 2
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_WRBUF_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x2)|value<<1)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_WRBUF_DUMMY_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x2) >> 1
}
func (o *SPI1_Type) SetSPI_SLAVE1_SLV_RDBUF_DUMMY_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE1.Reg, volatile.LoadUint32(&o.SPI_SLAVE1.Reg)&^(0x1)|value)
}
func (o *SPI1_Type) GetSPI_SLAVE1_SLV_RDBUF_DUMMY_EN() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE1.Reg) & 0x1
}

// SPI1.SPI_SLAVE2: In the slave mode, it is the length in spi_clk cycles "dummy" phase for "write-buffer" operations. The registervalue shall be (cycle_num-1)
func (o *SPI1_Type) SetSPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff000000) >> 24
}
func (o *SPI1_Type) SetSPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff0000) >> 16
}
func (o *SPI1_Type) SetSPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff00)|value<<8)
}
func (o *SPI1_Type) GetSPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff00) >> 8
}
func (o *SPI1_Type) SetSPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE2.Reg, volatile.LoadUint32(&o.SPI_SLAVE2.Reg)&^(0xff)|value)
}
func (o *SPI1_Type) GetSPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE2.Reg) & 0xff
}

// SPI1.SPI_SLAVE3: In slave mode, it is the value of "write-status" command
func (o *SPI1_Type) SetSPI_SLAVE3_SLV_WRSTA_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI1_Type) GetSPI_SLAVE3_SLV_WRSTA_CMD_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff000000) >> 24
}
func (o *SPI1_Type) SetSPI_SLAVE3_SLV_RDSTA_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff0000)|value<<16)
}
func (o *SPI1_Type) GetSPI_SLAVE3_SLV_RDSTA_CMD_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff0000) >> 16
}
func (o *SPI1_Type) SetSPI_SLAVE3_SLV_WRBUF_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff00)|value<<8)
}
func (o *SPI1_Type) GetSPI_SLAVE3_SLV_WRBUF_CMD_VALUE() uint32 {
	return (volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff00) >> 8
}
func (o *SPI1_Type) SetSPI_SLAVE3_SLV_RDBUF_CMD_VALUE(value uint32) {
	volatile.StoreUint32(&o.SPI_SLAVE3.Reg, volatile.LoadUint32(&o.SPI_SLAVE3.Reg)&^(0xff)|value)
}
func (o *SPI1_Type) GetSPI_SLAVE3_SLV_RDBUF_CMD_VALUE() uint32 {
	return volatile.LoadUint32(&o.SPI_SLAVE3.Reg) & 0xff
}

// SPI1.SPI_W0: the data inside the buffer of the SPI module, byte 0
func (o *SPI1_Type) SetSPI_W0(value uint32) {
	volatile.StoreUint32(&o.SPI_W0.Reg, value)
}
func (o *SPI1_Type) GetSPI_W0() uint32 {
	return volatile.LoadUint32(&o.SPI_W0.Reg)
}

// SPI1.SPI_W1: the data inside the buffer of the SPI module, byte 1
func (o *SPI1_Type) SetSPI_W1(value uint32) {
	volatile.StoreUint32(&o.SPI_W1.Reg, value)
}
func (o *SPI1_Type) GetSPI_W1() uint32 {
	return volatile.LoadUint32(&o.SPI_W1.Reg)
}

// SPI1.SPI_W2: the data inside the buffer of the SPI module, byte 2
func (o *SPI1_Type) SetSPI_W2(value uint32) {
	volatile.StoreUint32(&o.SPI_W2.Reg, value)
}
func (o *SPI1_Type) GetSPI_W2() uint32 {
	return volatile.LoadUint32(&o.SPI_W2.Reg)
}

// SPI1.SPI_W3: the data inside the buffer of the SPI module, byte 3
func (o *SPI1_Type) SetSPI_W3(value uint32) {
	volatile.StoreUint32(&o.SPI_W3.Reg, value)
}
func (o *SPI1_Type) GetSPI_W3() uint32 {
	return volatile.LoadUint32(&o.SPI_W3.Reg)
}

// SPI1.SPI_W4: the data inside the buffer of the SPI module, byte 4
func (o *SPI1_Type) SetSPI_W4(value uint32) {
	volatile.StoreUint32(&o.SPI_W4.Reg, value)
}
func (o *SPI1_Type) GetSPI_W4() uint32 {
	return volatile.LoadUint32(&o.SPI_W4.Reg)
}

// SPI1.SPI_W5: the data inside the buffer of the SPI module, byte 5
func (o *SPI1_Type) SetSPI_W5(value uint32) {
	volatile.StoreUint32(&o.SPI_W5.Reg, value)
}
func (o *SPI1_Type) GetSPI_W5() uint32 {
	return volatile.LoadUint32(&o.SPI_W5.Reg)
}

// SPI1.SPI_EXT3: This register is for two SPI masters to share the same cs, clock and data signals.
func (o *SPI1_Type) SetSPI_EXT3_REG_INT_HOLD_ENA(value uint32) {
	volatile.StoreUint32(&o.SPI_EXT3.Reg, volatile.LoadUint32(&o.SPI_EXT3.Reg)&^(0x3)|value)
}
func (o *SPI1_Type) GetSPI_EXT3_REG_INT_HOLD_ENA() uint32 {
	return volatile.LoadUint32(&o.SPI_EXT3.Reg) & 0x3
}

// SPI1.SPI_W6: the data inside the buffer of the SPI module, byte 6
func (o *SPI1_Type) SetSPI_W6(value uint32) {
	volatile.StoreUint32(&o.SPI_W6.Reg, value)
}
func (o *SPI1_Type) GetSPI_W6() uint32 {
	return volatile.LoadUint32(&o.SPI_W6.Reg)
}

// SPI1.SPI_W7: the data inside the buffer of the SPI module, byte 7
func (o *SPI1_Type) SetSPI_W7(value uint32) {
	volatile.StoreUint32(&o.SPI_W7.Reg, value)
}
func (o *SPI1_Type) GetSPI_W7() uint32 {
	return volatile.LoadUint32(&o.SPI_W7.Reg)
}

// SPI1.SPI_W8: the data inside the buffer of the SPI module, byte 8
func (o *SPI1_Type) SetSPI_W8(value uint32) {
	volatile.StoreUint32(&o.SPI_W8.Reg, value)
}
func (o *SPI1_Type) GetSPI_W8() uint32 {
	return volatile.LoadUint32(&o.SPI_W8.Reg)
}

// SPI1.SPI_W9: the data inside the buffer of the SPI module, byte 9
func (o *SPI1_Type) SetSPI_W9(value uint32) {
	volatile.StoreUint32(&o.SPI_W9.Reg, value)
}
func (o *SPI1_Type) GetSPI_W9() uint32 {
	return volatile.LoadUint32(&o.SPI_W9.Reg)
}

// SPI1.SPI_W10: the data inside the buffer of the SPI module, byte 10
func (o *SPI1_Type) SetSPI_W10(value uint32) {
	volatile.StoreUint32(&o.SPI_W10.Reg, value)
}
func (o *SPI1_Type) GetSPI_W10() uint32 {
	return volatile.LoadUint32(&o.SPI_W10.Reg)
}

// SPI1.SPI_W11: the data inside the buffer of the SPI module, byte 11
func (o *SPI1_Type) SetSPI_W11(value uint32) {
	volatile.StoreUint32(&o.SPI_W11.Reg, value)
}
func (o *SPI1_Type) GetSPI_W11() uint32 {
	return volatile.LoadUint32(&o.SPI_W11.Reg)
}

// SPI1.SPI_W12: the data inside the buffer of the SPI module, byte 12
func (o *SPI1_Type) SetSPI_W12(value uint32) {
	volatile.StoreUint32(&o.SPI_W12.Reg, value)
}
func (o *SPI1_Type) GetSPI_W12() uint32 {
	return volatile.LoadUint32(&o.SPI_W12.Reg)
}

// SPI1.SPI_W13: the data inside the buffer of the SPI module, byte 13
func (o *SPI1_Type) SetSPI_W13(value uint32) {
	volatile.StoreUint32(&o.SPI_W13.Reg, value)
}
func (o *SPI1_Type) GetSPI_W13() uint32 {
	return volatile.LoadUint32(&o.SPI_W13.Reg)
}

// SPI1.SPI_W14: the data inside the buffer of the SPI module, byte 14
func (o *SPI1_Type) SetSPI_W14(value uint32) {
	volatile.StoreUint32(&o.SPI_W14.Reg, value)
}
func (o *SPI1_Type) GetSPI_W14() uint32 {
	return volatile.LoadUint32(&o.SPI_W14.Reg)
}

// SPI1.SPI_W15: the data inside the buffer of the SPI module, byte 15
func (o *SPI1_Type) SetSPI_W15(value uint32) {
	volatile.StoreUint32(&o.SPI_W15.Reg, value)
}
func (o *SPI1_Type) GetSPI_W15() uint32 {
	return volatile.LoadUint32(&o.SPI_W15.Reg)
}

type TIMER_Type struct {
	FRC1_LOAD  volatile.Register32 // 0x0
	FRC1_COUNT volatile.Register32 // 0x4
	FRC1_CTRL  volatile.Register32 // 0x8
	FRC1_INT   volatile.Register32 // 0xC
	_          [16]byte
	FRC2_LOAD  volatile.Register32 // 0x20
	FRC2_COUNT volatile.Register32 // 0x24
	FRC2_CTRL  volatile.Register32 // 0x28
	FRC2_INT   volatile.Register32 // 0x2C
	FRC2_ALARM volatile.Register32 // 0x30
}

// TIMER.FRC1_LOAD: the load value into the counter
func (o *TIMER_Type) SetFRC1_LOAD_FRC1_LOAD_VALUE(value uint32) {
	volatile.StoreUint32(&o.FRC1_LOAD.Reg, volatile.LoadUint32(&o.FRC1_LOAD.Reg)&^(0x7fffff)|value)
}
func (o *TIMER_Type) GetFRC1_LOAD_FRC1_LOAD_VALUE() uint32 {
	return volatile.LoadUint32(&o.FRC1_LOAD.Reg) & 0x7fffff
}

// TIMER.FRC1_COUNT: the current value of the counter. It is a decreasingcounter.
func (o *TIMER_Type) SetFRC1_COUNT(value uint32) {
	volatile.StoreUint32(&o.FRC1_COUNT.Reg, volatile.LoadUint32(&o.FRC1_COUNT.Reg)&^(0x7fffff)|value)
}
func (o *TIMER_Type) GetFRC1_COUNT() uint32 {
	return volatile.LoadUint32(&o.FRC1_COUNT.Reg) & 0x7fffff
}

// TIMER.FRC1_CTRL: FRC1_CTRL
func (o *TIMER_Type) SetFRC1_CTRL_FRC1_INT(value uint32) {
	volatile.StoreUint32(&o.FRC1_CTRL.Reg, volatile.LoadUint32(&o.FRC1_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *TIMER_Type) GetFRC1_CTRL_FRC1_INT() uint32 {
	return (volatile.LoadUint32(&o.FRC1_CTRL.Reg) & 0x100) >> 8
}
func (o *TIMER_Type) SetFRC1_CTRL(value uint32) {
	volatile.StoreUint32(&o.FRC1_CTRL.Reg, volatile.LoadUint32(&o.FRC1_CTRL.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetFRC1_CTRL() uint32 {
	return volatile.LoadUint32(&o.FRC1_CTRL.Reg) & 0xff
}
func (o *TIMER_Type) SetFRC1_CTRL_TIMER_ENABLE(value uint32) {
	volatile.StoreUint32(&o.FRC1_CTRL.Reg, volatile.LoadUint32(&o.FRC1_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *TIMER_Type) GetFRC1_CTRL_TIMER_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.FRC1_CTRL.Reg) & 0x80) >> 7
}
func (o *TIMER_Type) SetFRC1_CTRL_ROLLOVER(value uint32) {
	volatile.StoreUint32(&o.FRC1_CTRL.Reg, volatile.LoadUint32(&o.FRC1_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *TIMER_Type) GetFRC1_CTRL_ROLLOVER() uint32 {
	return (volatile.LoadUint32(&o.FRC1_CTRL.Reg) & 0x40) >> 6
}
func (o *TIMER_Type) SetFRC1_CTRL_PRESCALE_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.FRC1_CTRL.Reg, volatile.LoadUint32(&o.FRC1_CTRL.Reg)&^(0xc)|value<<2)
}
func (o *TIMER_Type) GetFRC1_CTRL_PRESCALE_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.FRC1_CTRL.Reg) & 0xc) >> 2
}
func (o *TIMER_Type) SetFRC1_CTRL_INTERRUPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.FRC1_CTRL.Reg, volatile.LoadUint32(&o.FRC1_CTRL.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetFRC1_CTRL_INTERRUPT_TYPE() uint32 {
	return volatile.LoadUint32(&o.FRC1_CTRL.Reg) & 0x1
}

// TIMER.FRC1_INT: FRC1_INT
func (o *TIMER_Type) SetFRC1_INT_FRC1_INT_CLR_MASK(value uint32) {
	volatile.StoreUint32(&o.FRC1_INT.Reg, volatile.LoadUint32(&o.FRC1_INT.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetFRC1_INT_FRC1_INT_CLR_MASK() uint32 {
	return volatile.LoadUint32(&o.FRC1_INT.Reg) & 0x1
}

// TIMER.FRC2_LOAD: the load value into the counter
func (o *TIMER_Type) SetFRC2_LOAD(value uint32) {
	volatile.StoreUint32(&o.FRC2_LOAD.Reg, value)
}
func (o *TIMER_Type) GetFRC2_LOAD() uint32 {
	return volatile.LoadUint32(&o.FRC2_LOAD.Reg)
}

// TIMER.FRC2_COUNT: the current value of the counter. It is a increasingcounter.
func (o *TIMER_Type) SetFRC2_COUNT(value uint32) {
	volatile.StoreUint32(&o.FRC2_COUNT.Reg, value)
}
func (o *TIMER_Type) GetFRC2_COUNT() uint32 {
	return volatile.LoadUint32(&o.FRC2_COUNT.Reg)
}

// TIMER.FRC2_CTRL: FRC2_CTRL
func (o *TIMER_Type) SetFRC2_CTRL_FRC2_INT(value uint32) {
	volatile.StoreUint32(&o.FRC2_CTRL.Reg, volatile.LoadUint32(&o.FRC2_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *TIMER_Type) GetFRC2_CTRL_FRC2_INT() uint32 {
	return (volatile.LoadUint32(&o.FRC2_CTRL.Reg) & 0x100) >> 8
}
func (o *TIMER_Type) SetFRC2_CTRL(value uint32) {
	volatile.StoreUint32(&o.FRC2_CTRL.Reg, volatile.LoadUint32(&o.FRC2_CTRL.Reg)&^(0xff)|value)
}
func (o *TIMER_Type) GetFRC2_CTRL() uint32 {
	return volatile.LoadUint32(&o.FRC2_CTRL.Reg) & 0xff
}
func (o *TIMER_Type) SetFRC2_CTRL_TIMER_ENABLE(value uint32) {
	volatile.StoreUint32(&o.FRC2_CTRL.Reg, volatile.LoadUint32(&o.FRC2_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *TIMER_Type) GetFRC2_CTRL_TIMER_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.FRC2_CTRL.Reg) & 0x80) >> 7
}
func (o *TIMER_Type) SetFRC2_CTRL_ROLLOVER(value uint32) {
	volatile.StoreUint32(&o.FRC2_CTRL.Reg, volatile.LoadUint32(&o.FRC2_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *TIMER_Type) GetFRC2_CTRL_ROLLOVER() uint32 {
	return (volatile.LoadUint32(&o.FRC2_CTRL.Reg) & 0x40) >> 6
}
func (o *TIMER_Type) SetFRC2_CTRL_PRESCALE_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.FRC2_CTRL.Reg, volatile.LoadUint32(&o.FRC2_CTRL.Reg)&^(0xc)|value<<2)
}
func (o *TIMER_Type) GetFRC2_CTRL_PRESCALE_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.FRC2_CTRL.Reg) & 0xc) >> 2
}
func (o *TIMER_Type) SetFRC2_CTRL_INTERRUPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.FRC2_CTRL.Reg, volatile.LoadUint32(&o.FRC2_CTRL.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetFRC2_CTRL_INTERRUPT_TYPE() uint32 {
	return volatile.LoadUint32(&o.FRC2_CTRL.Reg) & 0x1
}

// TIMER.FRC2_INT: FRC2_INT
func (o *TIMER_Type) SetFRC2_INT_FRC2_INT_CLR_MASK(value uint32) {
	volatile.StoreUint32(&o.FRC2_INT.Reg, volatile.LoadUint32(&o.FRC2_INT.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetFRC2_INT_FRC2_INT_CLR_MASK() uint32 {
	return volatile.LoadUint32(&o.FRC2_INT.Reg) & 0x1
}

// TIMER.FRC2_ALARM: the alarm value for the counter
func (o *TIMER_Type) SetFRC2_ALARM(value uint32) {
	volatile.StoreUint32(&o.FRC2_ALARM.Reg, value)
}
func (o *TIMER_Type) GetFRC2_ALARM() uint32 {
	return volatile.LoadUint32(&o.FRC2_ALARM.Reg)
}

type UART0_Type struct {
	UART_FIFO      volatile.Register32 // 0x0
	UART_INT_RAW   volatile.Register32 // 0x4
	UART_INT_ST    volatile.Register32 // 0x8
	UART_INT_ENA   volatile.Register32 // 0xC
	UART_INT_CLR   volatile.Register32 // 0x10
	UART_CLKDIV    volatile.Register32 // 0x14
	UART_AUTOBAUD  volatile.Register32 // 0x18
	UART_STATUS    volatile.Register32 // 0x1C
	UART_CONF0     volatile.Register32 // 0x20
	UART_CONF1     volatile.Register32 // 0x24
	UART_LOWPULSE  volatile.Register32 // 0x28
	UART_HIGHPULSE volatile.Register32 // 0x2C
	UART_RXD_CNT   volatile.Register32 // 0x30
	_              [68]byte
	UART_DATE      volatile.Register32 // 0x78
	UART_ID        volatile.Register32 // 0x7C
}

// UART0.UART_FIFO: UART FIFO,length 128
func (o *UART0_Type) SetUART_FIFO_RXFIFO_RD_BYTE(value uint32) {
	volatile.StoreUint32(&o.UART_FIFO.Reg, volatile.LoadUint32(&o.UART_FIFO.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUART_FIFO_RXFIFO_RD_BYTE() uint32 {
	return volatile.LoadUint32(&o.UART_FIFO.Reg) & 0xff
}
func (o *UART0_Type) SetUART_FIFO_RXFIFO_WRITE_BYTE(value uint32) {
	volatile.StoreUint32(&o.UART_FIFO.Reg, volatile.LoadUint32(&o.UART_FIFO.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUART_FIFO_RXFIFO_WRITE_BYTE() uint32 {
	return volatile.LoadUint32(&o.UART_FIFO.Reg) & 0xff
}

// UART0.UART_INT_RAW: UART INTERRUPT RAW STATE
func (o *UART0_Type) SetUART_INT_RAW_RXFIFO_TOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUART_INT_RAW_RXFIFO_TOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUART_INT_RAW_BRK_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUART_INT_RAW_BRK_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUART_INT_RAW_CTS_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUART_INT_RAW_CTS_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUART_INT_RAW_DSR_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUART_INT_RAW_DSR_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUART_INT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUART_INT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUART_INT_RAW_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUART_INT_RAW_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUART_INT_RAW_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUART_INT_RAW_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUART_INT_RAW_TXFIFO_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUART_INT_RAW_TXFIFO_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUART_INT_RAW_RXFIFO_FULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUART_INT_RAW_RXFIFO_FULL_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x1
}

// UART0.UART_INT_ST: UART INTERRUPT STATEREGISTERUART_INT_RAW&UART_INT_ENA
func (o *UART0_Type) SetUART_INT_ST_RXFIFO_TOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUART_INT_ST_RXFIFO_TOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUART_INT_ST_BRK_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUART_INT_ST_BRK_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUART_INT_ST_CTS_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUART_INT_ST_CTS_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUART_INT_ST_DSR_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUART_INT_ST_DSR_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUART_INT_ST_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUART_INT_ST_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUART_INT_ST_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUART_INT_ST_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUART_INT_ST_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUART_INT_ST_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUART_INT_ST_TXFIFO_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUART_INT_ST_TXFIFO_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUART_INT_ST_RXFIFO_FULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUART_INT_ST_RXFIFO_FULL_INT_ST() uint32 {
	return volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x1
}

// UART0.UART_INT_ENA: UART INTERRUPT ENABLE REGISTER
func (o *UART0_Type) SetUART_INT_ENA_RXFIFO_TOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUART_INT_ENA_RXFIFO_TOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUART_INT_ENA_BRK_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUART_INT_ENA_BRK_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUART_INT_ENA_CTS_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUART_INT_ENA_CTS_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUART_INT_ENA_DSR_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUART_INT_ENA_DSR_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUART_INT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUART_INT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUART_INT_ENA_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUART_INT_ENA_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUART_INT_ENA_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUART_INT_ENA_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUART_INT_ENA_TXFIFO_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUART_INT_ENA_TXFIFO_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUART_INT_ENA_RXFIFO_FULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUART_INT_ENA_RXFIFO_FULL_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x1
}

// UART0.UART_INT_CLR: UART INTERRUPT CLEAR REGISTER
func (o *UART0_Type) SetUART_INT_CLR_RXFIFO_TOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUART_INT_CLR_RXFIFO_TOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUART_INT_CLR_BRK_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUART_INT_CLR_BRK_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUART_INT_CLR_CTS_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUART_INT_CLR_CTS_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUART_INT_CLR_DSR_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUART_INT_CLR_DSR_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUART_INT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUART_INT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUART_INT_CLR_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUART_INT_CLR_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUART_INT_CLR_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUART_INT_CLR_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUART_INT_CLR_TXFIFO_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUART_INT_CLR_TXFIFO_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUART_INT_CLR_RXFIFO_FULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUART_INT_CLR_RXFIFO_FULL_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x1
}

// UART0.UART_CLKDIV: UART CLK DIV REGISTER
func (o *UART0_Type) SetUART_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.UART_CLKDIV.Reg, volatile.LoadUint32(&o.UART_CLKDIV.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetUART_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.UART_CLKDIV.Reg) & 0xfffff
}

// UART0.UART_AUTOBAUD: UART BAUDRATE DETECT REGISTER
func (o *UART0_Type) SetUART_AUTOBAUD_GLITCH_FILT(value uint32) {
	volatile.StoreUint32(&o.UART_AUTOBAUD.Reg, volatile.LoadUint32(&o.UART_AUTOBAUD.Reg)&^(0xff00)|value<<8)
}
func (o *UART0_Type) GetUART_AUTOBAUD_GLITCH_FILT() uint32 {
	return (volatile.LoadUint32(&o.UART_AUTOBAUD.Reg) & 0xff00) >> 8
}
func (o *UART0_Type) SetUART_AUTOBAUD_AUTOBAUD_EN(value uint32) {
	volatile.StoreUint32(&o.UART_AUTOBAUD.Reg, volatile.LoadUint32(&o.UART_AUTOBAUD.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUART_AUTOBAUD_AUTOBAUD_EN() uint32 {
	return volatile.LoadUint32(&o.UART_AUTOBAUD.Reg) & 0x1
}

// UART0.UART_STATUS: UART STATUS REGISTER
func (o *UART0_Type) SetUART_STATUS_TXD(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART0_Type) GetUART_STATUS_TXD() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x80000000) >> 31
}
func (o *UART0_Type) SetUART_STATUS_RTSN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *UART0_Type) GetUART_STATUS_RTSN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x40000000) >> 30
}
func (o *UART0_Type) SetUART_STATUS_DTRN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *UART0_Type) GetUART_STATUS_DTRN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x20000000) >> 29
}
func (o *UART0_Type) SetUART_STATUS_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0xff0000)|value<<16)
}
func (o *UART0_Type) GetUART_STATUS_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0xff0000) >> 16
}
func (o *UART0_Type) SetUART_STATUS_RXD(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetUART_STATUS_RXD() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetUART_STATUS_CTSN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetUART_STATUS_CTSN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetUART_STATUS_DSRN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetUART_STATUS_DSRN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetUART_STATUS_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUART_STATUS_RXFIFO_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_STATUS.Reg) & 0xff
}

// UART0.UART_CONF0: UART CONFIG0(UART0 and UART1)
func (o *UART0_Type) SetUART_CONF0_UART_DTR_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x1000000)|value<<24)
}
func (o *UART0_Type) GetUART_CONF0_UART_DTR_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x1000000) >> 24
}
func (o *UART0_Type) SetUART_CONF0_UART_RTS_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UART0_Type) GetUART_CONF0_UART_RTS_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x800000) >> 23
}
func (o *UART0_Type) SetUART_CONF0_UART_TXD_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UART0_Type) GetUART_CONF0_UART_TXD_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x400000) >> 22
}
func (o *UART0_Type) SetUART_CONF0_UART_DSR_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UART0_Type) GetUART_CONF0_UART_DSR_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x200000) >> 21
}
func (o *UART0_Type) SetUART_CONF0_UART_CTS_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UART0_Type) GetUART_CONF0_UART_CTS_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x100000) >> 20
}
func (o *UART0_Type) SetUART_CONF0_UART_RXD_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UART0_Type) GetUART_CONF0_UART_RXD_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x80000) >> 19
}
func (o *UART0_Type) SetUART_CONF0_TXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UART0_Type) GetUART_CONF0_TXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x40000) >> 18
}
func (o *UART0_Type) SetUART_CONF0_RXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UART0_Type) GetUART_CONF0_RXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x20000) >> 17
}
func (o *UART0_Type) SetUART_CONF0_TX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetUART_CONF0_TX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetUART_CONF0_UART_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetUART_CONF0_UART_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetUART_CONF0_TXD_BRK(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUART_CONF0_TXD_BRK() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUART_CONF0_SW_DTR(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUART_CONF0_SW_DTR() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUART_CONF0_SW_RTS(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUART_CONF0_SW_RTS() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUART_CONF0_STOP_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x30)|value<<4)
}
func (o *UART0_Type) GetUART_CONF0_STOP_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x30) >> 4
}
func (o *UART0_Type) SetUART_CONF0_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0xc)|value<<2)
}
func (o *UART0_Type) GetUART_CONF0_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0xc) >> 2
}
func (o *UART0_Type) SetUART_CONF0_PARITY_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUART_CONF0_PARITY_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUART_CONF0_PARITY(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUART_CONF0_PARITY() uint32 {
	return volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x1
}

// UART0.UART_CONF1: Set this bit to enable rx time-out function
func (o *UART0_Type) SetUART_CONF1_RX_TOUT_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *UART0_Type) GetUART_CONF1_RX_TOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x80000000) >> 31
}
func (o *UART0_Type) SetUART_CONF1_RX_TOUT_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f000000)|value<<24)
}
func (o *UART0_Type) GetUART_CONF1_RX_TOUT_THRHD() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f000000) >> 24
}
func (o *UART0_Type) SetUART_CONF1_RX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x800000)|value<<23)
}
func (o *UART0_Type) GetUART_CONF1_RX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x800000) >> 23
}
func (o *UART0_Type) SetUART_CONF1_RX_FLOW_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f0000)|value<<16)
}
func (o *UART0_Type) GetUART_CONF1_RX_FLOW_THRHD() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f0000) >> 16
}
func (o *UART0_Type) SetUART_CONF1_TXFIFO_EMPTY_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f00)|value<<8)
}
func (o *UART0_Type) GetUART_CONF1_TXFIFO_EMPTY_THRHD() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f00) >> 8
}
func (o *UART0_Type) SetUART_CONF1_RXFIFO_FULL_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f)|value)
}
func (o *UART0_Type) GetUART_CONF1_RXFIFO_FULL_THRHD() uint32 {
	return volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f
}

// UART0.UART_LOWPULSE: UART_LOWPULSE
func (o *UART0_Type) SetUART_LOWPULSE_LOWPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_LOWPULSE.Reg, volatile.LoadUint32(&o.UART_LOWPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetUART_LOWPULSE_LOWPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_LOWPULSE.Reg) & 0xfffff
}

// UART0.UART_HIGHPULSE: UART_HIGHPULSE
func (o *UART0_Type) SetUART_HIGHPULSE_HIGHPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_HIGHPULSE.Reg, volatile.LoadUint32(&o.UART_HIGHPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART0_Type) GetUART_HIGHPULSE_HIGHPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_HIGHPULSE.Reg) & 0xfffff
}

// UART0.UART_RXD_CNT: UART_RXD_CNT
func (o *UART0_Type) SetUART_RXD_CNT_RXD_EDGE_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_RXD_CNT.Reg, volatile.LoadUint32(&o.UART_RXD_CNT.Reg)&^(0x3ff)|value)
}
func (o *UART0_Type) GetUART_RXD_CNT_RXD_EDGE_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_RXD_CNT.Reg) & 0x3ff
}

// UART0.UART_DATE: UART HW INFO
func (o *UART0_Type) SetUART_DATE(value uint32) {
	volatile.StoreUint32(&o.UART_DATE.Reg, value)
}
func (o *UART0_Type) GetUART_DATE() uint32 {
	return volatile.LoadUint32(&o.UART_DATE.Reg)
}

// UART0.UART_ID: UART_ID
func (o *UART0_Type) SetUART_ID(value uint32) {
	volatile.StoreUint32(&o.UART_ID.Reg, value)
}
func (o *UART0_Type) GetUART_ID() uint32 {
	return volatile.LoadUint32(&o.UART_ID.Reg)
}

type UART1_Type struct {
	UART_FIFO      volatile.Register32 // 0x0
	UART_INT_RAW   volatile.Register32 // 0x4
	UART_INT_ST    volatile.Register32 // 0x8
	UART_INT_ENA   volatile.Register32 // 0xC
	UART_INT_CLR   volatile.Register32 // 0x10
	UART_CLKDIV    volatile.Register32 // 0x14
	UART_AUTOBAUD  volatile.Register32 // 0x18
	UART_STATUS    volatile.Register32 // 0x1C
	UART_CONF0     volatile.Register32 // 0x20
	UART_CONF1     volatile.Register32 // 0x24
	UART_LOWPULSE  volatile.Register32 // 0x28
	UART_HIGHPULSE volatile.Register32 // 0x2C
	UART_RXD_CNT   volatile.Register32 // 0x30
	_              [68]byte
	UART_DATE      volatile.Register32 // 0x78
	UART_ID        volatile.Register32 // 0x7C
}

// UART1.UART_FIFO: UART FIFO,length 128
func (o *UART1_Type) SetUART_FIFO_RXFIFO_RD_BYTE(value uint32) {
	volatile.StoreUint32(&o.UART_FIFO.Reg, volatile.LoadUint32(&o.UART_FIFO.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetUART_FIFO_RXFIFO_RD_BYTE() uint32 {
	return volatile.LoadUint32(&o.UART_FIFO.Reg) & 0xff
}
func (o *UART1_Type) SetUART_FIFO_RXFIFO_WRITE_BYTE(value uint32) {
	volatile.StoreUint32(&o.UART_FIFO.Reg, volatile.LoadUint32(&o.UART_FIFO.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetUART_FIFO_RXFIFO_WRITE_BYTE() uint32 {
	return volatile.LoadUint32(&o.UART_FIFO.Reg) & 0xff
}

// UART1.UART_INT_RAW: UART INTERRUPT RAW STATE
func (o *UART1_Type) SetUART_INT_RAW_RXFIFO_TOUT_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetUART_INT_RAW_RXFIFO_TOUT_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetUART_INT_RAW_BRK_DET_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetUART_INT_RAW_BRK_DET_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetUART_INT_RAW_CTS_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetUART_INT_RAW_CTS_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetUART_INT_RAW_DSR_CHG_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetUART_INT_RAW_DSR_CHG_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetUART_INT_RAW_RXFIFO_OVF_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetUART_INT_RAW_RXFIFO_OVF_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetUART_INT_RAW_FRM_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetUART_INT_RAW_FRM_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetUART_INT_RAW_PARITY_ERR_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetUART_INT_RAW_PARITY_ERR_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetUART_INT_RAW_TXFIFO_EMPTY_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetUART_INT_RAW_TXFIFO_EMPTY_INT_RAW() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetUART_INT_RAW_RXFIFO_FULL_INT_RAW(value uint32) {
	volatile.StoreUint32(&o.UART_INT_RAW.Reg, volatile.LoadUint32(&o.UART_INT_RAW.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetUART_INT_RAW_RXFIFO_FULL_INT_RAW() uint32 {
	return volatile.LoadUint32(&o.UART_INT_RAW.Reg) & 0x1
}

// UART1.UART_INT_ST: UART INTERRUPT STATEREGISTERUART_INT_RAW&UART_INT_ENA
func (o *UART1_Type) SetUART_INT_ST_RXFIFO_TOUT_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetUART_INT_ST_RXFIFO_TOUT_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetUART_INT_ST_BRK_DET_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetUART_INT_ST_BRK_DET_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetUART_INT_ST_CTS_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetUART_INT_ST_CTS_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetUART_INT_ST_DSR_CHG_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetUART_INT_ST_DSR_CHG_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetUART_INT_ST_RXFIFO_OVF_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetUART_INT_ST_RXFIFO_OVF_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetUART_INT_ST_FRM_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetUART_INT_ST_FRM_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetUART_INT_ST_PARITY_ERR_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetUART_INT_ST_PARITY_ERR_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetUART_INT_ST_TXFIFO_EMPTY_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetUART_INT_ST_TXFIFO_EMPTY_INT_ST() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetUART_INT_ST_RXFIFO_FULL_INT_ST(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ST.Reg, volatile.LoadUint32(&o.UART_INT_ST.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetUART_INT_ST_RXFIFO_FULL_INT_ST() uint32 {
	return volatile.LoadUint32(&o.UART_INT_ST.Reg) & 0x1
}

// UART1.UART_INT_ENA: UART INTERRUPT ENABLE REGISTER
func (o *UART1_Type) SetUART_INT_ENA_RXFIFO_TOUT_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetUART_INT_ENA_RXFIFO_TOUT_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetUART_INT_ENA_BRK_DET_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetUART_INT_ENA_BRK_DET_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetUART_INT_ENA_CTS_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetUART_INT_ENA_CTS_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetUART_INT_ENA_DSR_CHG_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetUART_INT_ENA_DSR_CHG_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetUART_INT_ENA_RXFIFO_OVF_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetUART_INT_ENA_RXFIFO_OVF_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetUART_INT_ENA_FRM_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetUART_INT_ENA_FRM_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetUART_INT_ENA_PARITY_ERR_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetUART_INT_ENA_PARITY_ERR_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetUART_INT_ENA_TXFIFO_EMPTY_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetUART_INT_ENA_TXFIFO_EMPTY_INT_ENA() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetUART_INT_ENA_RXFIFO_FULL_INT_ENA(value uint32) {
	volatile.StoreUint32(&o.UART_INT_ENA.Reg, volatile.LoadUint32(&o.UART_INT_ENA.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetUART_INT_ENA_RXFIFO_FULL_INT_ENA() uint32 {
	return volatile.LoadUint32(&o.UART_INT_ENA.Reg) & 0x1
}

// UART1.UART_INT_CLR: UART INTERRUPT CLEAR REGISTER
func (o *UART1_Type) SetUART_INT_CLR_RXFIFO_TOUT_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetUART_INT_CLR_RXFIFO_TOUT_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetUART_INT_CLR_BRK_DET_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetUART_INT_CLR_BRK_DET_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetUART_INT_CLR_CTS_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetUART_INT_CLR_CTS_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetUART_INT_CLR_DSR_CHG_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetUART_INT_CLR_DSR_CHG_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetUART_INT_CLR_RXFIFO_OVF_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetUART_INT_CLR_RXFIFO_OVF_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetUART_INT_CLR_FRM_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetUART_INT_CLR_FRM_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetUART_INT_CLR_PARITY_ERR_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetUART_INT_CLR_PARITY_ERR_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetUART_INT_CLR_TXFIFO_EMPTY_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetUART_INT_CLR_TXFIFO_EMPTY_INT_CLR() uint32 {
	return (volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetUART_INT_CLR_RXFIFO_FULL_INT_CLR(value uint32) {
	volatile.StoreUint32(&o.UART_INT_CLR.Reg, volatile.LoadUint32(&o.UART_INT_CLR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetUART_INT_CLR_RXFIFO_FULL_INT_CLR() uint32 {
	return volatile.LoadUint32(&o.UART_INT_CLR.Reg) & 0x1
}

// UART1.UART_CLKDIV: UART CLK DIV REGISTER
func (o *UART1_Type) SetUART_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.UART_CLKDIV.Reg, volatile.LoadUint32(&o.UART_CLKDIV.Reg)&^(0xfffff)|value)
}
func (o *UART1_Type) GetUART_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.UART_CLKDIV.Reg) & 0xfffff
}

// UART1.UART_AUTOBAUD: UART BAUDRATE DETECT REGISTER
func (o *UART1_Type) SetUART_AUTOBAUD_GLITCH_FILT(value uint32) {
	volatile.StoreUint32(&o.UART_AUTOBAUD.Reg, volatile.LoadUint32(&o.UART_AUTOBAUD.Reg)&^(0xff00)|value<<8)
}
func (o *UART1_Type) GetUART_AUTOBAUD_GLITCH_FILT() uint32 {
	return (volatile.LoadUint32(&o.UART_AUTOBAUD.Reg) & 0xff00) >> 8
}
func (o *UART1_Type) SetUART_AUTOBAUD_AUTOBAUD_EN(value uint32) {
	volatile.StoreUint32(&o.UART_AUTOBAUD.Reg, volatile.LoadUint32(&o.UART_AUTOBAUD.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetUART_AUTOBAUD_AUTOBAUD_EN() uint32 {
	return volatile.LoadUint32(&o.UART_AUTOBAUD.Reg) & 0x1
}

// UART1.UART_STATUS: UART STATUS REGISTER
func (o *UART1_Type) SetUART_STATUS_TXD(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART1_Type) GetUART_STATUS_TXD() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x80000000) >> 31
}
func (o *UART1_Type) SetUART_STATUS_RTSN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *UART1_Type) GetUART_STATUS_RTSN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x40000000) >> 30
}
func (o *UART1_Type) SetUART_STATUS_DTRN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *UART1_Type) GetUART_STATUS_DTRN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x20000000) >> 29
}
func (o *UART1_Type) SetUART_STATUS_TXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0xff0000)|value<<16)
}
func (o *UART1_Type) GetUART_STATUS_TXFIFO_CNT() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0xff0000) >> 16
}
func (o *UART1_Type) SetUART_STATUS_RXD(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *UART1_Type) GetUART_STATUS_RXD() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x8000) >> 15
}
func (o *UART1_Type) SetUART_STATUS_CTSN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *UART1_Type) GetUART_STATUS_CTSN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x4000) >> 14
}
func (o *UART1_Type) SetUART_STATUS_DSRN(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *UART1_Type) GetUART_STATUS_DSRN() uint32 {
	return (volatile.LoadUint32(&o.UART_STATUS.Reg) & 0x2000) >> 13
}
func (o *UART1_Type) SetUART_STATUS_RXFIFO_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_STATUS.Reg, volatile.LoadUint32(&o.UART_STATUS.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetUART_STATUS_RXFIFO_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_STATUS.Reg) & 0xff
}

// UART1.UART_CONF0: UART CONFIG0(UART0 and UART1)
func (o *UART1_Type) SetUART_CONF0_UART_DTR_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x1000000)|value<<24)
}
func (o *UART1_Type) GetUART_CONF0_UART_DTR_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x1000000) >> 24
}
func (o *UART1_Type) SetUART_CONF0_UART_RTS_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x800000)|value<<23)
}
func (o *UART1_Type) GetUART_CONF0_UART_RTS_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x800000) >> 23
}
func (o *UART1_Type) SetUART_CONF0_UART_TXD_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x400000)|value<<22)
}
func (o *UART1_Type) GetUART_CONF0_UART_TXD_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x400000) >> 22
}
func (o *UART1_Type) SetUART_CONF0_UART_DSR_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x200000)|value<<21)
}
func (o *UART1_Type) GetUART_CONF0_UART_DSR_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x200000) >> 21
}
func (o *UART1_Type) SetUART_CONF0_UART_CTS_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x100000)|value<<20)
}
func (o *UART1_Type) GetUART_CONF0_UART_CTS_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x100000) >> 20
}
func (o *UART1_Type) SetUART_CONF0_UART_RXD_INV(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x80000)|value<<19)
}
func (o *UART1_Type) GetUART_CONF0_UART_RXD_INV() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x80000) >> 19
}
func (o *UART1_Type) SetUART_CONF0_TXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x40000)|value<<18)
}
func (o *UART1_Type) GetUART_CONF0_TXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x40000) >> 18
}
func (o *UART1_Type) SetUART_CONF0_RXFIFO_RST(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x20000)|value<<17)
}
func (o *UART1_Type) GetUART_CONF0_RXFIFO_RST() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x20000) >> 17
}
func (o *UART1_Type) SetUART_CONF0_TX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x8000)|value<<15)
}
func (o *UART1_Type) GetUART_CONF0_TX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x8000) >> 15
}
func (o *UART1_Type) SetUART_CONF0_UART_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x4000)|value<<14)
}
func (o *UART1_Type) GetUART_CONF0_UART_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x4000) >> 14
}
func (o *UART1_Type) SetUART_CONF0_TXD_BRK(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetUART_CONF0_TXD_BRK() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetUART_CONF0_SW_DTR(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetUART_CONF0_SW_DTR() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetUART_CONF0_SW_RTS(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetUART_CONF0_SW_RTS() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetUART_CONF0_STOP_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x30)|value<<4)
}
func (o *UART1_Type) GetUART_CONF0_STOP_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x30) >> 4
}
func (o *UART1_Type) SetUART_CONF0_BIT_NUM(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0xc)|value<<2)
}
func (o *UART1_Type) GetUART_CONF0_BIT_NUM() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0xc) >> 2
}
func (o *UART1_Type) SetUART_CONF0_PARITY_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetUART_CONF0_PARITY_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetUART_CONF0_PARITY(value uint32) {
	volatile.StoreUint32(&o.UART_CONF0.Reg, volatile.LoadUint32(&o.UART_CONF0.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetUART_CONF0_PARITY() uint32 {
	return volatile.LoadUint32(&o.UART_CONF0.Reg) & 0x1
}

// UART1.UART_CONF1: Set this bit to enable rx time-out function
func (o *UART1_Type) SetUART_CONF1_RX_TOUT_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x80000000)|value<<31)
}
func (o *UART1_Type) GetUART_CONF1_RX_TOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x80000000) >> 31
}
func (o *UART1_Type) SetUART_CONF1_RX_TOUT_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f000000)|value<<24)
}
func (o *UART1_Type) GetUART_CONF1_RX_TOUT_THRHD() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f000000) >> 24
}
func (o *UART1_Type) SetUART_CONF1_RX_FLOW_EN(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x800000)|value<<23)
}
func (o *UART1_Type) GetUART_CONF1_RX_FLOW_EN() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x800000) >> 23
}
func (o *UART1_Type) SetUART_CONF1_RX_FLOW_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f0000)|value<<16)
}
func (o *UART1_Type) GetUART_CONF1_RX_FLOW_THRHD() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f0000) >> 16
}
func (o *UART1_Type) SetUART_CONF1_TXFIFO_EMPTY_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f00)|value<<8)
}
func (o *UART1_Type) GetUART_CONF1_TXFIFO_EMPTY_THRHD() uint32 {
	return (volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f00) >> 8
}
func (o *UART1_Type) SetUART_CONF1_RXFIFO_FULL_THRHD(value uint32) {
	volatile.StoreUint32(&o.UART_CONF1.Reg, volatile.LoadUint32(&o.UART_CONF1.Reg)&^(0x7f)|value)
}
func (o *UART1_Type) GetUART_CONF1_RXFIFO_FULL_THRHD() uint32 {
	return volatile.LoadUint32(&o.UART_CONF1.Reg) & 0x7f
}

// UART1.UART_LOWPULSE: UART_LOWPULSE
func (o *UART1_Type) SetUART_LOWPULSE_LOWPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_LOWPULSE.Reg, volatile.LoadUint32(&o.UART_LOWPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART1_Type) GetUART_LOWPULSE_LOWPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_LOWPULSE.Reg) & 0xfffff
}

// UART1.UART_HIGHPULSE: UART_HIGHPULSE
func (o *UART1_Type) SetUART_HIGHPULSE_HIGHPULSE_MIN_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_HIGHPULSE.Reg, volatile.LoadUint32(&o.UART_HIGHPULSE.Reg)&^(0xfffff)|value)
}
func (o *UART1_Type) GetUART_HIGHPULSE_HIGHPULSE_MIN_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_HIGHPULSE.Reg) & 0xfffff
}

// UART1.UART_RXD_CNT: UART_RXD_CNT
func (o *UART1_Type) SetUART_RXD_CNT_RXD_EDGE_CNT(value uint32) {
	volatile.StoreUint32(&o.UART_RXD_CNT.Reg, volatile.LoadUint32(&o.UART_RXD_CNT.Reg)&^(0x3ff)|value)
}
func (o *UART1_Type) GetUART_RXD_CNT_RXD_EDGE_CNT() uint32 {
	return volatile.LoadUint32(&o.UART_RXD_CNT.Reg) & 0x3ff
}

// UART1.UART_DATE: UART HW INFO
func (o *UART1_Type) SetUART_DATE(value uint32) {
	volatile.StoreUint32(&o.UART_DATE.Reg, value)
}
func (o *UART1_Type) GetUART_DATE() uint32 {
	return volatile.LoadUint32(&o.UART_DATE.Reg)
}

// UART1.UART_ID: UART_ID
func (o *UART1_Type) SetUART_ID(value uint32) {
	volatile.StoreUint32(&o.UART_ID.Reg, value)
}
func (o *UART1_Type) GetUART_ID() uint32 {
	return volatile.LoadUint32(&o.UART_ID.Reg)
}

type WDT_Type struct {
	WDT_CTL   volatile.Register32 // 0x0
	WDT_OP    volatile.Register32 // 0x4
	WDT_OP_ND volatile.Register32 // 0x8
	_         [8]byte
	WDT_RST   volatile.Register32 // 0x14
}

// WDT.WDT_CTL: WDT_CTL
func (o *WDT_Type) SetWDT_CTL(value uint32) {
	volatile.StoreUint32(&o.WDT_CTL.Reg, value)
}
func (o *WDT_Type) GetWDT_CTL() uint32 {
	return volatile.LoadUint32(&o.WDT_CTL.Reg)
}

// WDT.WDT_OP: WDT_OP
func (o *WDT_Type) SetWDT_OP(value uint32) {
	volatile.StoreUint32(&o.WDT_OP.Reg, value)
}
func (o *WDT_Type) GetWDT_OP() uint32 {
	return volatile.LoadUint32(&o.WDT_OP.Reg)
}

// WDT.WDT_OP_ND: WDT_OP_ND
func (o *WDT_Type) SetWDT_OP_ND(value uint32) {
	volatile.StoreUint32(&o.WDT_OP_ND.Reg, value)
}
func (o *WDT_Type) GetWDT_OP_ND() uint32 {
	return volatile.LoadUint32(&o.WDT_OP_ND.Reg)
}

// WDT.WDT_RST: WDT_RST
func (o *WDT_Type) SetWDT_RST(value uint32) {
	volatile.StoreUint32(&o.WDT_RST.Reg, value)
}
func (o *WDT_Type) GetWDT_RST() uint32 {
	return volatile.LoadUint32(&o.WDT_RST.Reg)
}

// RNG register
type RNG_Type struct {
	RNG volatile.Register32 // 0x0
}

// Watchdog registers
type WATCHDOG_Type struct {
	CTL           volatile.Register32 // 0x0
	RELOAD_STAGE0 volatile.Register32 // 0x4
	RELOAD_STAGE1 volatile.Register32 // 0x8
	COUNT         volatile.Register32 // 0xC
	STAGE         volatile.Register32 // 0x10
	RESET         volatile.Register32 // 0x14
	RESET_STAGE   volatile.Register32 // 0x18
}

// WATCHDOG.CTL: Watchdog control
func (o *WATCHDOG_Type) SetCTL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x1)|value)
}
func (o *WATCHDOG_Type) GetCTL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTL.Reg) & 0x1
}
func (o *WATCHDOG_Type) SetCTL_STAGE_1_NO_RESET(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x2)|value<<1)
}
func (o *WATCHDOG_Type) GetCTL_STAGE_1_NO_RESET() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x2) >> 1
}
func (o *WATCHDOG_Type) SetCTL_STAGE_1_DISABLE(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x4)|value<<2)
}
func (o *WATCHDOG_Type) GetCTL_STAGE_1_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x4) >> 2
}
func (o *WATCHDOG_Type) SetCTL_UNKNOWN_3(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x8)|value<<3)
}
func (o *WATCHDOG_Type) GetCTL_UNKNOWN_3() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x8) >> 3
}
func (o *WATCHDOG_Type) SetCTL_UNKNOWN_4(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x10)|value<<4)
}
func (o *WATCHDOG_Type) GetCTL_UNKNOWN_4() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x10) >> 4
}
func (o *WATCHDOG_Type) SetCTL_UNKNOWN_5(value uint32) {
	volatile.StoreUint32(&o.CTL.Reg, volatile.LoadUint32(&o.CTL.Reg)&^(0x20)|value<<5)
}
func (o *WATCHDOG_Type) GetCTL_UNKNOWN_5() uint32 {
	return (volatile.LoadUint32(&o.CTL.Reg) & 0x20) >> 5
}

// Constants for DPORT
const (
	// EDGE_INT_ENABLE: EDGE_INT_ENABLE
	// Position of Register field.
	DPORT_EDGE_INT_ENABLE_Register_Pos = 0x0
	// Bit mask of Register field.
	DPORT_EDGE_INT_ENABLE_Register_Msk = 0xffffffff
	// Position of WDT_EDGE_INT_ENABLE field.
	DPORT_EDGE_INT_ENABLE_WDT_EDGE_INT_ENABLE_Pos = 0x0
	// Bit mask of WDT_EDGE_INT_ENABLE field.
	DPORT_EDGE_INT_ENABLE_WDT_EDGE_INT_ENABLE_Msk = 0x1
	// Bit WDT_EDGE_INT_ENABLE.
	DPORT_EDGE_INT_ENABLE_WDT_EDGE_INT_ENABLE = 0x1
	// Position of TIMER1_EDGE_INT_ENABLE field.
	DPORT_EDGE_INT_ENABLE_TIMER1_EDGE_INT_ENABLE_Pos = 0x1
	// Bit mask of TIMER1_EDGE_INT_ENABLE field.
	DPORT_EDGE_INT_ENABLE_TIMER1_EDGE_INT_ENABLE_Msk = 0x2
	// Bit TIMER1_EDGE_INT_ENABLE.
	DPORT_EDGE_INT_ENABLE_TIMER1_EDGE_INT_ENABLE = 0x2

	// DPORT_CTL: DPORT_CTL
	// Position of DPORT_CTL_DOUBLE_CLK field.
	DPORT_DPORT_CTL_DPORT_CTL_DOUBLE_CLK_Pos = 0x0
	// Bit mask of DPORT_CTL_DOUBLE_CLK field.
	DPORT_DPORT_CTL_DPORT_CTL_DOUBLE_CLK_Msk = 0x1
	// Bit DPORT_CTL_DOUBLE_CLK.
	DPORT_DPORT_CTL_DPORT_CTL_DOUBLE_CLK = 0x1
)

// Constants for EFUSE
const (
	// EFUSE_DATA0: EFUSE_DATA0
	// Position of Register field.
	EFUSE_EFUSE_DATA0_Register_Pos = 0x0
	// Bit mask of Register field.
	EFUSE_EFUSE_DATA0_Register_Msk = 0xffffffff

	// EFUSE_DATA1: EFUSE_DATA1
	// Position of Register field.
	EFUSE_EFUSE_DATA1_Register_Pos = 0x0
	// Bit mask of Register field.
	EFUSE_EFUSE_DATA1_Register_Msk = 0xffffffff

	// EFUSE_DATA2: EFUSE_DATA2
	// Position of Register field.
	EFUSE_EFUSE_DATA2_Register_Pos = 0x0
	// Bit mask of Register field.
	EFUSE_EFUSE_DATA2_Register_Msk = 0xffffffff

	// EFUSE_DATA3: EFUSE_DATA3
	// Position of Register field.
	EFUSE_EFUSE_DATA3_Register_Pos = 0x0
	// Bit mask of Register field.
	EFUSE_EFUSE_DATA3_Register_Msk = 0xffffffff
)

// Constants for GPIO
const (
	// GPIO_OUT: BT-Coexist Selection register
	// Position of GPIO_BT_SEL field.
	GPIO_GPIO_OUT_GPIO_BT_SEL_Pos = 0x10
	// Bit mask of GPIO_BT_SEL field.
	GPIO_GPIO_OUT_GPIO_BT_SEL_Msk = 0xffff0000
	// Position of GPIO_OUT_DATA field.
	GPIO_GPIO_OUT_GPIO_OUT_DATA_Pos = 0x0
	// Bit mask of GPIO_OUT_DATA field.
	GPIO_GPIO_OUT_GPIO_OUT_DATA_Msk = 0xffff

	// GPIO_OUT_W1TS: GPIO_OUT_W1TS
	// Position of GPIO_OUT_DATA_W1TS field.
	GPIO_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS_Pos = 0x0
	// Bit mask of GPIO_OUT_DATA_W1TS field.
	GPIO_GPIO_OUT_W1TS_GPIO_OUT_DATA_W1TS_Msk = 0xffff

	// GPIO_OUT_W1TC: GPIO_OUT_W1TC
	// Position of GPIO_OUT_DATA_W1TC field.
	GPIO_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC_Pos = 0x0
	// Bit mask of GPIO_OUT_DATA_W1TC field.
	GPIO_GPIO_OUT_W1TC_GPIO_OUT_DATA_W1TC_Msk = 0xffff

	// GPIO_ENABLE: GPIO_ENABLE
	// Position of GPIO_SDIO_SEL field.
	GPIO_GPIO_ENABLE_GPIO_SDIO_SEL_Pos = 0x10
	// Bit mask of GPIO_SDIO_SEL field.
	GPIO_GPIO_ENABLE_GPIO_SDIO_SEL_Msk = 0x3f0000
	// Position of GPIO_ENABLE_DATA field.
	GPIO_GPIO_ENABLE_GPIO_ENABLE_DATA_Pos = 0x0
	// Bit mask of GPIO_ENABLE_DATA field.
	GPIO_GPIO_ENABLE_GPIO_ENABLE_DATA_Msk = 0xffff

	// GPIO_ENABLE_W1TS: GPIO_ENABLE_W1TS
	// Position of GPIO_ENABLE_DATA_W1TS field.
	GPIO_GPIO_ENABLE_W1TS_GPIO_ENABLE_DATA_W1TS_Pos = 0x0
	// Bit mask of GPIO_ENABLE_DATA_W1TS field.
	GPIO_GPIO_ENABLE_W1TS_GPIO_ENABLE_DATA_W1TS_Msk = 0xffff

	// GPIO_ENABLE_W1TC: GPIO_ENABLE_W1TC
	// Position of GPIO_ENABLE_DATA_W1TC field.
	GPIO_GPIO_ENABLE_W1TC_GPIO_ENABLE_DATA_W1TC_Pos = 0x0
	// Bit mask of GPIO_ENABLE_DATA_W1TC field.
	GPIO_GPIO_ENABLE_W1TC_GPIO_ENABLE_DATA_W1TC_Msk = 0xffff

	// GPIO_IN: The values of the strapping pins.
	// Position of GPIO_STRAPPING field.
	GPIO_GPIO_IN_GPIO_STRAPPING_Pos = 0x10
	// Bit mask of GPIO_STRAPPING field.
	GPIO_GPIO_IN_GPIO_STRAPPING_Msk = 0xffff0000
	// Position of GPIO_IN_DATA field.
	GPIO_GPIO_IN_GPIO_IN_DATA_Pos = 0x0
	// Bit mask of GPIO_IN_DATA field.
	GPIO_GPIO_IN_GPIO_IN_DATA_Msk = 0xffff

	// GPIO_STATUS: GPIO_STATUS
	// Position of GPIO_STATUS_INTERRUPT field.
	GPIO_GPIO_STATUS_GPIO_STATUS_INTERRUPT_Pos = 0x0
	// Bit mask of GPIO_STATUS_INTERRUPT field.
	GPIO_GPIO_STATUS_GPIO_STATUS_INTERRUPT_Msk = 0xffff

	// GPIO_STATUS_W1TS: GPIO_STATUS_W1TS
	// Position of GPIO_STATUS_INTERRUPT_W1TS field.
	GPIO_GPIO_STATUS_W1TS_GPIO_STATUS_INTERRUPT_W1TS_Pos = 0x0
	// Bit mask of GPIO_STATUS_INTERRUPT_W1TS field.
	GPIO_GPIO_STATUS_W1TS_GPIO_STATUS_INTERRUPT_W1TS_Msk = 0xffff

	// GPIO_STATUS_W1TC: GPIO_STATUS_W1TC
	// Position of GPIO_STATUS_INTERRUPT_W1TC field.
	GPIO_GPIO_STATUS_W1TC_GPIO_STATUS_INTERRUPT_W1TC_Pos = 0x0
	// Bit mask of GPIO_STATUS_INTERRUPT_W1TC field.
	GPIO_GPIO_STATUS_W1TC_GPIO_STATUS_INTERRUPT_W1TC_Msk = 0xffff

	// GPIO_PIN0: GPIO_PIN0
	// Position of GPIO_PIN0_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN0_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN0_WAKEUP_ENABLE.
	GPIO_GPIO_PIN0_GPIO_PIN0_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN0_INT_TYPE field.
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN0_INT_TYPE field.
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN0_GPIO_PIN0_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN0_DRIVER field.
	GPIO_GPIO_PIN0_GPIO_PIN0_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN0_DRIVER field.
	GPIO_GPIO_PIN0_GPIO_PIN0_DRIVER_Msk = 0x4
	// Bit GPIO_PIN0_DRIVER.
	GPIO_GPIO_PIN0_GPIO_PIN0_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN0_GPIO_PIN0_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN0_GPIO_PIN0_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN0_SOURCE field.
	GPIO_GPIO_PIN0_GPIO_PIN0_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN0_SOURCE field.
	GPIO_GPIO_PIN0_GPIO_PIN0_SOURCE_Msk = 0x1
	// Bit GPIO_PIN0_SOURCE.
	GPIO_GPIO_PIN0_GPIO_PIN0_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN0_GPIO_PIN0_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN0_GPIO_PIN0_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN1: GPIO_PIN1
	// Position of GPIO_PIN1_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN1_GPIO_PIN1_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN1_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN1_GPIO_PIN1_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN1_WAKEUP_ENABLE.
	GPIO_GPIO_PIN1_GPIO_PIN1_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN1_INT_TYPE field.
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN1_INT_TYPE field.
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN1_GPIO_PIN1_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN1_DRIVER field.
	GPIO_GPIO_PIN1_GPIO_PIN1_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN1_DRIVER field.
	GPIO_GPIO_PIN1_GPIO_PIN1_DRIVER_Msk = 0x4
	// Bit GPIO_PIN1_DRIVER.
	GPIO_GPIO_PIN1_GPIO_PIN1_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN1_GPIO_PIN1_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN1_GPIO_PIN1_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN1_SOURCE field.
	GPIO_GPIO_PIN1_GPIO_PIN1_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN1_SOURCE field.
	GPIO_GPIO_PIN1_GPIO_PIN1_SOURCE_Msk = 0x1
	// Bit GPIO_PIN1_SOURCE.
	GPIO_GPIO_PIN1_GPIO_PIN1_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN1_GPIO_PIN1_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN1_GPIO_PIN1_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN2: GPIO_PIN2
	// Position of GPIO_PIN2_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN2_GPIO_PIN2_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN2_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN2_GPIO_PIN2_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN2_WAKEUP_ENABLE.
	GPIO_GPIO_PIN2_GPIO_PIN2_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN2_INT_TYPE field.
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN2_INT_TYPE field.
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN2_GPIO_PIN2_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN2_DRIVER field.
	GPIO_GPIO_PIN2_GPIO_PIN2_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN2_DRIVER field.
	GPIO_GPIO_PIN2_GPIO_PIN2_DRIVER_Msk = 0x4
	// Bit GPIO_PIN2_DRIVER.
	GPIO_GPIO_PIN2_GPIO_PIN2_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN2_GPIO_PIN2_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN2_GPIO_PIN2_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN2_SOURCE field.
	GPIO_GPIO_PIN2_GPIO_PIN2_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN2_SOURCE field.
	GPIO_GPIO_PIN2_GPIO_PIN2_SOURCE_Msk = 0x1
	// Bit GPIO_PIN2_SOURCE.
	GPIO_GPIO_PIN2_GPIO_PIN2_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN2_GPIO_PIN2_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN2_GPIO_PIN2_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN3: GPIO_PIN3
	// Position of GPIO_PIN3_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN3_GPIO_PIN3_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN3_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN3_GPIO_PIN3_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN3_WAKEUP_ENABLE.
	GPIO_GPIO_PIN3_GPIO_PIN3_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN3_INT_TYPE field.
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN3_INT_TYPE field.
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN3_GPIO_PIN3_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN3_DRIVER field.
	GPIO_GPIO_PIN3_GPIO_PIN3_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN3_DRIVER field.
	GPIO_GPIO_PIN3_GPIO_PIN3_DRIVER_Msk = 0x4
	// Bit GPIO_PIN3_DRIVER.
	GPIO_GPIO_PIN3_GPIO_PIN3_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN3_GPIO_PIN3_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN3_GPIO_PIN3_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN3_SOURCE field.
	GPIO_GPIO_PIN3_GPIO_PIN3_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN3_SOURCE field.
	GPIO_GPIO_PIN3_GPIO_PIN3_SOURCE_Msk = 0x1
	// Bit GPIO_PIN3_SOURCE.
	GPIO_GPIO_PIN3_GPIO_PIN3_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN3_GPIO_PIN3_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN3_GPIO_PIN3_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN4: GPIO_PIN4
	// Position of GPIO_PIN4_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN4_GPIO_PIN4_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN4_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN4_GPIO_PIN4_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN4_WAKEUP_ENABLE.
	GPIO_GPIO_PIN4_GPIO_PIN4_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN4_INT_TYPE field.
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN4_INT_TYPE field.
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN4_GPIO_PIN4_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN4_DRIVER field.
	GPIO_GPIO_PIN4_GPIO_PIN4_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN4_DRIVER field.
	GPIO_GPIO_PIN4_GPIO_PIN4_DRIVER_Msk = 0x4
	// Bit GPIO_PIN4_DRIVER.
	GPIO_GPIO_PIN4_GPIO_PIN4_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN4_GPIO_PIN4_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN4_GPIO_PIN4_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN4_SOURCE field.
	GPIO_GPIO_PIN4_GPIO_PIN4_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN4_SOURCE field.
	GPIO_GPIO_PIN4_GPIO_PIN4_SOURCE_Msk = 0x1
	// Bit GPIO_PIN4_SOURCE.
	GPIO_GPIO_PIN4_GPIO_PIN4_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN4_GPIO_PIN4_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN4_GPIO_PIN4_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN5: GPIO_PIN5
	// Position of GPIO_PIN5_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN5_GPIO_PIN5_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN5_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN5_GPIO_PIN5_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN5_WAKEUP_ENABLE.
	GPIO_GPIO_PIN5_GPIO_PIN5_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN5_INT_TYPE field.
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN5_INT_TYPE field.
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN5_GPIO_PIN5_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN5_DRIVER field.
	GPIO_GPIO_PIN5_GPIO_PIN5_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN5_DRIVER field.
	GPIO_GPIO_PIN5_GPIO_PIN5_DRIVER_Msk = 0x4
	// Bit GPIO_PIN5_DRIVER.
	GPIO_GPIO_PIN5_GPIO_PIN5_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN5_GPIO_PIN5_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN5_GPIO_PIN5_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN5_SOURCE field.
	GPIO_GPIO_PIN5_GPIO_PIN5_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN5_SOURCE field.
	GPIO_GPIO_PIN5_GPIO_PIN5_SOURCE_Msk = 0x1
	// Bit GPIO_PIN5_SOURCE.
	GPIO_GPIO_PIN5_GPIO_PIN5_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN5_GPIO_PIN5_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN5_GPIO_PIN5_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN6: GPIO_PIN6
	// Position of GPIO_PIN6_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN6_GPIO_PIN6_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN6_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN6_GPIO_PIN6_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN6_WAKEUP_ENABLE.
	GPIO_GPIO_PIN6_GPIO_PIN6_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN6_INT_TYPE field.
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN6_INT_TYPE field.
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN6_GPIO_PIN6_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN6_DRIVER field.
	GPIO_GPIO_PIN6_GPIO_PIN6_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN6_DRIVER field.
	GPIO_GPIO_PIN6_GPIO_PIN6_DRIVER_Msk = 0x4
	// Bit GPIO_PIN6_DRIVER.
	GPIO_GPIO_PIN6_GPIO_PIN6_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN6_GPIO_PIN6_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN6_GPIO_PIN6_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN6_SOURCE field.
	GPIO_GPIO_PIN6_GPIO_PIN6_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN6_SOURCE field.
	GPIO_GPIO_PIN6_GPIO_PIN6_SOURCE_Msk = 0x1
	// Bit GPIO_PIN6_SOURCE.
	GPIO_GPIO_PIN6_GPIO_PIN6_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN6_GPIO_PIN6_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN6_GPIO_PIN6_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN7: GPIO_PIN7
	// Position of GPIO_PIN7_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN7_GPIO_PIN7_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN7_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN7_GPIO_PIN7_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN7_WAKEUP_ENABLE.
	GPIO_GPIO_PIN7_GPIO_PIN7_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN7_INT_TYPE field.
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN7_INT_TYPE field.
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN7_GPIO_PIN7_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN7_DRIVER field.
	GPIO_GPIO_PIN7_GPIO_PIN7_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN7_DRIVER field.
	GPIO_GPIO_PIN7_GPIO_PIN7_DRIVER_Msk = 0x4
	// Bit GPIO_PIN7_DRIVER.
	GPIO_GPIO_PIN7_GPIO_PIN7_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN7_GPIO_PIN7_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN7_GPIO_PIN7_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN7_SOURCE field.
	GPIO_GPIO_PIN7_GPIO_PIN7_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN7_SOURCE field.
	GPIO_GPIO_PIN7_GPIO_PIN7_SOURCE_Msk = 0x1
	// Bit GPIO_PIN7_SOURCE.
	GPIO_GPIO_PIN7_GPIO_PIN7_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN7_GPIO_PIN7_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN7_GPIO_PIN7_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN8: GPIO_PIN8
	// Position of GPIO_PIN8_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN8_GPIO_PIN8_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN8_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN8_GPIO_PIN8_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN8_WAKEUP_ENABLE.
	GPIO_GPIO_PIN8_GPIO_PIN8_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN8_INT_TYPE field.
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN8_INT_TYPE field.
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN8_GPIO_PIN8_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN8_DRIVER field.
	GPIO_GPIO_PIN8_GPIO_PIN8_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN8_DRIVER field.
	GPIO_GPIO_PIN8_GPIO_PIN8_DRIVER_Msk = 0x4
	// Bit GPIO_PIN8_DRIVER.
	GPIO_GPIO_PIN8_GPIO_PIN8_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN8_GPIO_PIN8_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN8_GPIO_PIN8_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN8_SOURCE field.
	GPIO_GPIO_PIN8_GPIO_PIN8_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN8_SOURCE field.
	GPIO_GPIO_PIN8_GPIO_PIN8_SOURCE_Msk = 0x1
	// Bit GPIO_PIN8_SOURCE.
	GPIO_GPIO_PIN8_GPIO_PIN8_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN8_GPIO_PIN8_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN8_GPIO_PIN8_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN9: GPIO_PIN9
	// Position of GPIO_PIN9_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN9_GPIO_PIN9_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN9_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN9_GPIO_PIN9_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN9_WAKEUP_ENABLE.
	GPIO_GPIO_PIN9_GPIO_PIN9_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN9_INT_TYPE field.
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN9_INT_TYPE field.
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN9_GPIO_PIN9_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN9_DRIVER field.
	GPIO_GPIO_PIN9_GPIO_PIN9_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN9_DRIVER field.
	GPIO_GPIO_PIN9_GPIO_PIN9_DRIVER_Msk = 0x4
	// Bit GPIO_PIN9_DRIVER.
	GPIO_GPIO_PIN9_GPIO_PIN9_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN9_GPIO_PIN9_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN9_GPIO_PIN9_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN9_SOURCE field.
	GPIO_GPIO_PIN9_GPIO_PIN9_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN9_SOURCE field.
	GPIO_GPIO_PIN9_GPIO_PIN9_SOURCE_Msk = 0x1
	// Bit GPIO_PIN9_SOURCE.
	GPIO_GPIO_PIN9_GPIO_PIN9_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN9_GPIO_PIN9_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN9_GPIO_PIN9_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN10: GPIO_PIN10
	// Position of GPIO_PIN10_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN10_GPIO_PIN10_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN10_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN10_GPIO_PIN10_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN10_WAKEUP_ENABLE.
	GPIO_GPIO_PIN10_GPIO_PIN10_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN10_INT_TYPE field.
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN10_INT_TYPE field.
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN10_GPIO_PIN10_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN10_DRIVER field.
	GPIO_GPIO_PIN10_GPIO_PIN10_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN10_DRIVER field.
	GPIO_GPIO_PIN10_GPIO_PIN10_DRIVER_Msk = 0x4
	// Bit GPIO_PIN10_DRIVER.
	GPIO_GPIO_PIN10_GPIO_PIN10_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN10_GPIO_PIN10_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN10_GPIO_PIN10_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN10_SOURCE field.
	GPIO_GPIO_PIN10_GPIO_PIN10_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN10_SOURCE field.
	GPIO_GPIO_PIN10_GPIO_PIN10_SOURCE_Msk = 0x1
	// Bit GPIO_PIN10_SOURCE.
	GPIO_GPIO_PIN10_GPIO_PIN10_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN10_GPIO_PIN10_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN10_GPIO_PIN10_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN11: GPIO_PIN11
	// Position of GPIO_PIN11_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN11_GPIO_PIN11_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN11_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN11_GPIO_PIN11_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN11_WAKEUP_ENABLE.
	GPIO_GPIO_PIN11_GPIO_PIN11_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN11_INT_TYPE field.
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN11_INT_TYPE field.
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN11_GPIO_PIN11_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN11_DRIVER field.
	GPIO_GPIO_PIN11_GPIO_PIN11_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN11_DRIVER field.
	GPIO_GPIO_PIN11_GPIO_PIN11_DRIVER_Msk = 0x4
	// Bit GPIO_PIN11_DRIVER.
	GPIO_GPIO_PIN11_GPIO_PIN11_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN11_GPIO_PIN11_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN11_GPIO_PIN11_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN11_SOURCE field.
	GPIO_GPIO_PIN11_GPIO_PIN11_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN11_SOURCE field.
	GPIO_GPIO_PIN11_GPIO_PIN11_SOURCE_Msk = 0x1
	// Bit GPIO_PIN11_SOURCE.
	GPIO_GPIO_PIN11_GPIO_PIN11_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN11_GPIO_PIN11_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN11_GPIO_PIN11_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN12: GPIO_PIN12
	// Position of GPIO_PIN12_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN12_GPIO_PIN12_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN12_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN12_GPIO_PIN12_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN12_WAKEUP_ENABLE.
	GPIO_GPIO_PIN12_GPIO_PIN12_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN12_INT_TYPE field.
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN12_INT_TYPE field.
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN12_GPIO_PIN12_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN12_DRIVER field.
	GPIO_GPIO_PIN12_GPIO_PIN12_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN12_DRIVER field.
	GPIO_GPIO_PIN12_GPIO_PIN12_DRIVER_Msk = 0x4
	// Bit GPIO_PIN12_DRIVER.
	GPIO_GPIO_PIN12_GPIO_PIN12_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN12_GPIO_PIN12_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN12_GPIO_PIN12_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN12_SOURCE field.
	GPIO_GPIO_PIN12_GPIO_PIN12_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN12_SOURCE field.
	GPIO_GPIO_PIN12_GPIO_PIN12_SOURCE_Msk = 0x1
	// Bit GPIO_PIN12_SOURCE.
	GPIO_GPIO_PIN12_GPIO_PIN12_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN12_GPIO_PIN12_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN12_GPIO_PIN12_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN13: GPIO_PIN13
	// Position of GPIO_PIN13_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN13_GPIO_PIN13_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN13_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN13_GPIO_PIN13_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN13_WAKEUP_ENABLE.
	GPIO_GPIO_PIN13_GPIO_PIN13_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN13_INT_TYPE field.
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN13_INT_TYPE field.
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN13_GPIO_PIN13_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN13_DRIVER field.
	GPIO_GPIO_PIN13_GPIO_PIN13_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN13_DRIVER field.
	GPIO_GPIO_PIN13_GPIO_PIN13_DRIVER_Msk = 0x4
	// Bit GPIO_PIN13_DRIVER.
	GPIO_GPIO_PIN13_GPIO_PIN13_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN13_GPIO_PIN13_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN13_GPIO_PIN13_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN13_SOURCE field.
	GPIO_GPIO_PIN13_GPIO_PIN13_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN13_SOURCE field.
	GPIO_GPIO_PIN13_GPIO_PIN13_SOURCE_Msk = 0x1
	// Bit GPIO_PIN13_SOURCE.
	GPIO_GPIO_PIN13_GPIO_PIN13_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN13_GPIO_PIN13_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN13_GPIO_PIN13_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN14: GPIO_PIN14
	// Position of GPIO_PIN14_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN14_GPIO_PIN14_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN14_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN14_GPIO_PIN14_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN14_WAKEUP_ENABLE.
	GPIO_GPIO_PIN14_GPIO_PIN14_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN14_INT_TYPE field.
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN14_INT_TYPE field.
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN14_GPIO_PIN14_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN14_DRIVER field.
	GPIO_GPIO_PIN14_GPIO_PIN14_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN14_DRIVER field.
	GPIO_GPIO_PIN14_GPIO_PIN14_DRIVER_Msk = 0x4
	// Bit GPIO_PIN14_DRIVER.
	GPIO_GPIO_PIN14_GPIO_PIN14_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN14_GPIO_PIN14_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN14_GPIO_PIN14_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN14_SOURCE field.
	GPIO_GPIO_PIN14_GPIO_PIN14_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN14_SOURCE field.
	GPIO_GPIO_PIN14_GPIO_PIN14_SOURCE_Msk = 0x1
	// Bit GPIO_PIN14_SOURCE.
	GPIO_GPIO_PIN14_GPIO_PIN14_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN14_GPIO_PIN14_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN14_GPIO_PIN14_SOURCE_GPIO_DATA = 0x1

	// GPIO_PIN15: GPIO_PIN15
	// Position of GPIO_PIN15_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN15_GPIO_PIN15_WAKEUP_ENABLE_Pos = 0xa
	// Bit mask of GPIO_PIN15_WAKEUP_ENABLE field.
	GPIO_GPIO_PIN15_GPIO_PIN15_WAKEUP_ENABLE_Msk = 0x400
	// Bit GPIO_PIN15_WAKEUP_ENABLE.
	GPIO_GPIO_PIN15_GPIO_PIN15_WAKEUP_ENABLE = 0x400
	// Position of GPIO_PIN15_INT_TYPE field.
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_Pos = 0x7
	// Bit mask of GPIO_PIN15_INT_TYPE field.
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_Msk = 0x380
	// interrupt is disabled
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_DISABLED = 0x0
	// interrupt is triggered on the positive edge
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_POSITIVE_EDGE = 0x1
	// interrupt is triggered on the negative edge
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_NEGATIVE_EDGE = 0x2
	// interrupt is triggered on both edges
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_BOTH_EDGES = 0x3
	// interrupt is triggered on the low level
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_LOW_LEVEL = 0x4
	// interrupt is triggered on the high level
	GPIO_GPIO_PIN15_GPIO_PIN15_INT_TYPE_HIGH_LEVEL = 0x5
	// Position of GPIO_PIN15_DRIVER field.
	GPIO_GPIO_PIN15_GPIO_PIN15_DRIVER_Pos = 0x2
	// Bit mask of GPIO_PIN15_DRIVER field.
	GPIO_GPIO_PIN15_GPIO_PIN15_DRIVER_Msk = 0x4
	// Bit GPIO_PIN15_DRIVER.
	GPIO_GPIO_PIN15_GPIO_PIN15_DRIVER = 0x4
	// open drain
	GPIO_GPIO_PIN15_GPIO_PIN15_DRIVER_OPEN_DRAIN = 0x0
	// normal
	GPIO_GPIO_PIN15_GPIO_PIN15_DRIVER_NORMAL = 0x1
	// Position of GPIO_PIN15_SOURCE field.
	GPIO_GPIO_PIN15_GPIO_PIN15_SOURCE_Pos = 0x0
	// Bit mask of GPIO_PIN15_SOURCE field.
	GPIO_GPIO_PIN15_GPIO_PIN15_SOURCE_Msk = 0x1
	// Bit GPIO_PIN15_SOURCE.
	GPIO_GPIO_PIN15_GPIO_PIN15_SOURCE = 0x1
	// sigma-delta
	GPIO_GPIO_PIN15_GPIO_PIN15_SOURCE_SIGMA_DELTA = 0x0
	// gpio data
	GPIO_GPIO_PIN15_GPIO_PIN15_SOURCE_GPIO_DATA = 0x1

	// GPIO_SIGMA_DELTA: GPIO_SIGMA_DELTA
	// Position of SIGMA_DELTA_ENABLE field.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_ENABLE_Pos = 0x10
	// Bit mask of SIGMA_DELTA_ENABLE field.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_ENABLE_Msk = 0x10000
	// Bit SIGMA_DELTA_ENABLE.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_ENABLE = 0x10000
	// Position of SIGMA_DELTA_PRESCALAR field.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_PRESCALAR_Pos = 0x8
	// Bit mask of SIGMA_DELTA_PRESCALAR field.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_PRESCALAR_Msk = 0xff00
	// Position of SIGMA_DELTA_TARGET field.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_TARGET_Pos = 0x0
	// Bit mask of SIGMA_DELTA_TARGET field.
	GPIO_GPIO_SIGMA_DELTA_SIGMA_DELTA_TARGET_Msk = 0xff

	// GPIO_RTC_CALIB_SYNC: Positvie edge of this bit will trigger the RTC-clock-calibration process.
	// Position of RTC_CALIB_START field.
	GPIO_GPIO_RTC_CALIB_SYNC_RTC_CALIB_START_Pos = 0x1f
	// Bit mask of RTC_CALIB_START field.
	GPIO_GPIO_RTC_CALIB_SYNC_RTC_CALIB_START_Msk = 0x80000000
	// Bit RTC_CALIB_START.
	GPIO_GPIO_RTC_CALIB_SYNC_RTC_CALIB_START = 0x80000000
	// Position of RTC_PERIOD_NUM field.
	GPIO_GPIO_RTC_CALIB_SYNC_RTC_PERIOD_NUM_Pos = 0x0
	// Bit mask of RTC_PERIOD_NUM field.
	GPIO_GPIO_RTC_CALIB_SYNC_RTC_PERIOD_NUM_Msk = 0x3ff

	// GPIO_RTC_CALIB_VALUE: 0: during RTC-clock-calibration; 1: RTC-clock-calibration is done
	// Position of RTC_CALIB_RDY field.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_Pos = 0x1f
	// Bit mask of RTC_CALIB_RDY field.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_Msk = 0x80000000
	// Bit RTC_CALIB_RDY.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY = 0x80000000
	// Position of RTC_CALIB_RDY_REAL field.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_REAL_Pos = 0x1e
	// Bit mask of RTC_CALIB_RDY_REAL field.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_REAL_Msk = 0x40000000
	// Bit RTC_CALIB_RDY_REAL.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_RDY_REAL = 0x40000000
	// Position of RTC_CALIB_VALUE field.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_VALUE_Pos = 0x0
	// Bit mask of RTC_CALIB_VALUE field.
	GPIO_GPIO_RTC_CALIB_VALUE_RTC_CALIB_VALUE_Msk = 0xfffff
)

// Constants for I2S
const (
	// I2STXFIFO: I2STXFIFO
	// Position of Register field.
	I2S_I2STXFIFO_Register_Pos = 0x0
	// Bit mask of Register field.
	I2S_I2STXFIFO_Register_Msk = 0xffffffff

	// I2SRXFIFO: I2SRXFIFO
	// Position of Register field.
	I2S_I2SRXFIFO_Register_Pos = 0x0
	// Bit mask of Register field.
	I2S_I2SRXFIFO_Register_Msk = 0xffffffff

	// I2SCONF: I2SCONF
	// Position of I2S_BCK_DIV_NUM field.
	I2S_I2SCONF_I2S_BCK_DIV_NUM_Pos = 0x16
	// Bit mask of I2S_BCK_DIV_NUM field.
	I2S_I2SCONF_I2S_BCK_DIV_NUM_Msk = 0xfc00000
	// Position of I2S_CLKM_DIV_NUM field.
	I2S_I2SCONF_I2S_CLKM_DIV_NUM_Pos = 0x10
	// Bit mask of I2S_CLKM_DIV_NUM field.
	I2S_I2SCONF_I2S_CLKM_DIV_NUM_Msk = 0x3f0000
	// Position of I2S_BITS_MOD field.
	I2S_I2SCONF_I2S_BITS_MOD_Pos = 0xc
	// Bit mask of I2S_BITS_MOD field.
	I2S_I2SCONF_I2S_BITS_MOD_Msk = 0xf000
	// Position of I2S_RECE_MSB_SHIFT field.
	I2S_I2SCONF_I2S_RECE_MSB_SHIFT_Pos = 0xb
	// Bit mask of I2S_RECE_MSB_SHIFT field.
	I2S_I2SCONF_I2S_RECE_MSB_SHIFT_Msk = 0x800
	// Bit I2S_RECE_MSB_SHIFT.
	I2S_I2SCONF_I2S_RECE_MSB_SHIFT = 0x800
	// Position of I2S_TRANS_MSB_SHIFT field.
	I2S_I2SCONF_I2S_TRANS_MSB_SHIFT_Pos = 0xa
	// Bit mask of I2S_TRANS_MSB_SHIFT field.
	I2S_I2SCONF_I2S_TRANS_MSB_SHIFT_Msk = 0x400
	// Bit I2S_TRANS_MSB_SHIFT.
	I2S_I2SCONF_I2S_TRANS_MSB_SHIFT = 0x400
	// Position of I2S_I2S_RX_START field.
	I2S_I2SCONF_I2S_I2S_RX_START_Pos = 0x9
	// Bit mask of I2S_I2S_RX_START field.
	I2S_I2SCONF_I2S_I2S_RX_START_Msk = 0x200
	// Bit I2S_I2S_RX_START.
	I2S_I2SCONF_I2S_I2S_RX_START = 0x200
	// Position of I2S_I2S_TX_START field.
	I2S_I2SCONF_I2S_I2S_TX_START_Pos = 0x8
	// Bit mask of I2S_I2S_TX_START field.
	I2S_I2SCONF_I2S_I2S_TX_START_Msk = 0x100
	// Bit I2S_I2S_TX_START.
	I2S_I2SCONF_I2S_I2S_TX_START = 0x100
	// Position of I2S_MSB_RIGHT field.
	I2S_I2SCONF_I2S_MSB_RIGHT_Pos = 0x7
	// Bit mask of I2S_MSB_RIGHT field.
	I2S_I2SCONF_I2S_MSB_RIGHT_Msk = 0x80
	// Bit I2S_MSB_RIGHT.
	I2S_I2SCONF_I2S_MSB_RIGHT = 0x80
	// Position of I2S_RIGHT_FIRST field.
	I2S_I2SCONF_I2S_RIGHT_FIRST_Pos = 0x6
	// Bit mask of I2S_RIGHT_FIRST field.
	I2S_I2SCONF_I2S_RIGHT_FIRST_Msk = 0x40
	// Bit I2S_RIGHT_FIRST.
	I2S_I2SCONF_I2S_RIGHT_FIRST = 0x40
	// Position of I2S_RECE_SLAVE_MOD field.
	I2S_I2SCONF_I2S_RECE_SLAVE_MOD_Pos = 0x5
	// Bit mask of I2S_RECE_SLAVE_MOD field.
	I2S_I2SCONF_I2S_RECE_SLAVE_MOD_Msk = 0x20
	// Bit I2S_RECE_SLAVE_MOD.
	I2S_I2SCONF_I2S_RECE_SLAVE_MOD = 0x20
	// Position of I2S_TRANS_SLAVE_MOD field.
	I2S_I2SCONF_I2S_TRANS_SLAVE_MOD_Pos = 0x4
	// Bit mask of I2S_TRANS_SLAVE_MOD field.
	I2S_I2SCONF_I2S_TRANS_SLAVE_MOD_Msk = 0x10
	// Bit I2S_TRANS_SLAVE_MOD.
	I2S_I2SCONF_I2S_TRANS_SLAVE_MOD = 0x10
	// Position of I2S_I2S_RX_FIFO_RESET field.
	I2S_I2SCONF_I2S_I2S_RX_FIFO_RESET_Pos = 0x3
	// Bit mask of I2S_I2S_RX_FIFO_RESET field.
	I2S_I2SCONF_I2S_I2S_RX_FIFO_RESET_Msk = 0x8
	// Bit I2S_I2S_RX_FIFO_RESET.
	I2S_I2SCONF_I2S_I2S_RX_FIFO_RESET = 0x8
	// Position of I2S_I2S_TX_FIFO_RESET field.
	I2S_I2SCONF_I2S_I2S_TX_FIFO_RESET_Pos = 0x2
	// Bit mask of I2S_I2S_TX_FIFO_RESET field.
	I2S_I2SCONF_I2S_I2S_TX_FIFO_RESET_Msk = 0x4
	// Bit I2S_I2S_TX_FIFO_RESET.
	I2S_I2SCONF_I2S_I2S_TX_FIFO_RESET = 0x4
	// Position of I2S_I2S_RX_RESET field.
	I2S_I2SCONF_I2S_I2S_RX_RESET_Pos = 0x1
	// Bit mask of I2S_I2S_RX_RESET field.
	I2S_I2SCONF_I2S_I2S_RX_RESET_Msk = 0x2
	// Bit I2S_I2S_RX_RESET.
	I2S_I2SCONF_I2S_I2S_RX_RESET = 0x2
	// Position of I2S_I2S_TX_RESET field.
	I2S_I2SCONF_I2S_I2S_TX_RESET_Pos = 0x0
	// Bit mask of I2S_I2S_TX_RESET field.
	I2S_I2SCONF_I2S_I2S_TX_RESET_Msk = 0x1
	// Bit I2S_I2S_TX_RESET.
	I2S_I2SCONF_I2S_I2S_TX_RESET = 0x1

	// I2SINT_RAW: I2SINT_RAW
	// Position of I2S_I2S_TX_REMPTY_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_TX_REMPTY_INT_RAW_Pos = 0x5
	// Bit mask of I2S_I2S_TX_REMPTY_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_TX_REMPTY_INT_RAW_Msk = 0x20
	// Bit I2S_I2S_TX_REMPTY_INT_RAW.
	I2S_I2SINT_RAW_I2S_I2S_TX_REMPTY_INT_RAW = 0x20
	// Position of I2S_I2S_TX_WFULL_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_TX_WFULL_INT_RAW_Pos = 0x4
	// Bit mask of I2S_I2S_TX_WFULL_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_TX_WFULL_INT_RAW_Msk = 0x10
	// Bit I2S_I2S_TX_WFULL_INT_RAW.
	I2S_I2SINT_RAW_I2S_I2S_TX_WFULL_INT_RAW = 0x10
	// Position of I2S_I2S_RX_REMPTY_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_RX_REMPTY_INT_RAW_Pos = 0x3
	// Bit mask of I2S_I2S_RX_REMPTY_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_RX_REMPTY_INT_RAW_Msk = 0x8
	// Bit I2S_I2S_RX_REMPTY_INT_RAW.
	I2S_I2SINT_RAW_I2S_I2S_RX_REMPTY_INT_RAW = 0x8
	// Position of I2S_I2S_RX_WFULL_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_RX_WFULL_INT_RAW_Pos = 0x2
	// Bit mask of I2S_I2S_RX_WFULL_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_RX_WFULL_INT_RAW_Msk = 0x4
	// Bit I2S_I2S_RX_WFULL_INT_RAW.
	I2S_I2SINT_RAW_I2S_I2S_RX_WFULL_INT_RAW = 0x4
	// Position of I2S_I2S_TX_PUT_DATA_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_TX_PUT_DATA_INT_RAW_Pos = 0x1
	// Bit mask of I2S_I2S_TX_PUT_DATA_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_TX_PUT_DATA_INT_RAW_Msk = 0x2
	// Bit I2S_I2S_TX_PUT_DATA_INT_RAW.
	I2S_I2SINT_RAW_I2S_I2S_TX_PUT_DATA_INT_RAW = 0x2
	// Position of I2S_I2S_RX_TAKE_DATA_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_RX_TAKE_DATA_INT_RAW_Pos = 0x0
	// Bit mask of I2S_I2S_RX_TAKE_DATA_INT_RAW field.
	I2S_I2SINT_RAW_I2S_I2S_RX_TAKE_DATA_INT_RAW_Msk = 0x1
	// Bit I2S_I2S_RX_TAKE_DATA_INT_RAW.
	I2S_I2SINT_RAW_I2S_I2S_RX_TAKE_DATA_INT_RAW = 0x1

	// I2SINT_ST: I2SINT_ST
	// Position of I2S_I2S_TX_REMPTY_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_TX_REMPTY_INT_ST_Pos = 0x5
	// Bit mask of I2S_I2S_TX_REMPTY_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_TX_REMPTY_INT_ST_Msk = 0x20
	// Bit I2S_I2S_TX_REMPTY_INT_ST.
	I2S_I2SINT_ST_I2S_I2S_TX_REMPTY_INT_ST = 0x20
	// Position of I2S_I2S_TX_WFULL_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_TX_WFULL_INT_ST_Pos = 0x4
	// Bit mask of I2S_I2S_TX_WFULL_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_TX_WFULL_INT_ST_Msk = 0x10
	// Bit I2S_I2S_TX_WFULL_INT_ST.
	I2S_I2SINT_ST_I2S_I2S_TX_WFULL_INT_ST = 0x10
	// Position of I2S_I2S_RX_REMPTY_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_RX_REMPTY_INT_ST_Pos = 0x3
	// Bit mask of I2S_I2S_RX_REMPTY_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_RX_REMPTY_INT_ST_Msk = 0x8
	// Bit I2S_I2S_RX_REMPTY_INT_ST.
	I2S_I2SINT_ST_I2S_I2S_RX_REMPTY_INT_ST = 0x8
	// Position of I2S_I2S_RX_WFULL_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_RX_WFULL_INT_ST_Pos = 0x2
	// Bit mask of I2S_I2S_RX_WFULL_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_RX_WFULL_INT_ST_Msk = 0x4
	// Bit I2S_I2S_RX_WFULL_INT_ST.
	I2S_I2SINT_ST_I2S_I2S_RX_WFULL_INT_ST = 0x4
	// Position of I2S_I2S_TX_PUT_DATA_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_TX_PUT_DATA_INT_ST_Pos = 0x1
	// Bit mask of I2S_I2S_TX_PUT_DATA_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_TX_PUT_DATA_INT_ST_Msk = 0x2
	// Bit I2S_I2S_TX_PUT_DATA_INT_ST.
	I2S_I2SINT_ST_I2S_I2S_TX_PUT_DATA_INT_ST = 0x2
	// Position of I2S_I2S_RX_TAKE_DATA_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_RX_TAKE_DATA_INT_ST_Pos = 0x0
	// Bit mask of I2S_I2S_RX_TAKE_DATA_INT_ST field.
	I2S_I2SINT_ST_I2S_I2S_RX_TAKE_DATA_INT_ST_Msk = 0x1
	// Bit I2S_I2S_RX_TAKE_DATA_INT_ST.
	I2S_I2SINT_ST_I2S_I2S_RX_TAKE_DATA_INT_ST = 0x1

	// I2SINT_ENA: I2SINT_ENA
	// Position of I2S_I2S_TX_REMPTY_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_TX_REMPTY_INT_ENA_Pos = 0x5
	// Bit mask of I2S_I2S_TX_REMPTY_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_TX_REMPTY_INT_ENA_Msk = 0x20
	// Bit I2S_I2S_TX_REMPTY_INT_ENA.
	I2S_I2SINT_ENA_I2S_I2S_TX_REMPTY_INT_ENA = 0x20
	// Position of I2S_I2S_TX_WFULL_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_TX_WFULL_INT_ENA_Pos = 0x4
	// Bit mask of I2S_I2S_TX_WFULL_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_TX_WFULL_INT_ENA_Msk = 0x10
	// Bit I2S_I2S_TX_WFULL_INT_ENA.
	I2S_I2SINT_ENA_I2S_I2S_TX_WFULL_INT_ENA = 0x10
	// Position of I2S_I2S_RX_REMPTY_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_RX_REMPTY_INT_ENA_Pos = 0x3
	// Bit mask of I2S_I2S_RX_REMPTY_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_RX_REMPTY_INT_ENA_Msk = 0x8
	// Bit I2S_I2S_RX_REMPTY_INT_ENA.
	I2S_I2SINT_ENA_I2S_I2S_RX_REMPTY_INT_ENA = 0x8
	// Position of I2S_I2S_RX_WFULL_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_RX_WFULL_INT_ENA_Pos = 0x2
	// Bit mask of I2S_I2S_RX_WFULL_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_RX_WFULL_INT_ENA_Msk = 0x4
	// Bit I2S_I2S_RX_WFULL_INT_ENA.
	I2S_I2SINT_ENA_I2S_I2S_RX_WFULL_INT_ENA = 0x4
	// Position of I2S_I2S_TX_PUT_DATA_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_TX_PUT_DATA_INT_ENA_Pos = 0x1
	// Bit mask of I2S_I2S_TX_PUT_DATA_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_TX_PUT_DATA_INT_ENA_Msk = 0x2
	// Bit I2S_I2S_TX_PUT_DATA_INT_ENA.
	I2S_I2SINT_ENA_I2S_I2S_TX_PUT_DATA_INT_ENA = 0x2
	// Position of I2S_I2S_RX_TAKE_DATA_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_RX_TAKE_DATA_INT_ENA_Pos = 0x0
	// Bit mask of I2S_I2S_RX_TAKE_DATA_INT_ENA field.
	I2S_I2SINT_ENA_I2S_I2S_RX_TAKE_DATA_INT_ENA_Msk = 0x1
	// Bit I2S_I2S_RX_TAKE_DATA_INT_ENA.
	I2S_I2SINT_ENA_I2S_I2S_RX_TAKE_DATA_INT_ENA = 0x1

	// I2SINT_CLR: I2SINT_CLR
	// Position of I2S_I2S_TX_REMPTY_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_TX_REMPTY_INT_CLR_Pos = 0x5
	// Bit mask of I2S_I2S_TX_REMPTY_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_TX_REMPTY_INT_CLR_Msk = 0x20
	// Bit I2S_I2S_TX_REMPTY_INT_CLR.
	I2S_I2SINT_CLR_I2S_I2S_TX_REMPTY_INT_CLR = 0x20
	// Position of I2S_I2S_TX_WFULL_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_TX_WFULL_INT_CLR_Pos = 0x4
	// Bit mask of I2S_I2S_TX_WFULL_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_TX_WFULL_INT_CLR_Msk = 0x10
	// Bit I2S_I2S_TX_WFULL_INT_CLR.
	I2S_I2SINT_CLR_I2S_I2S_TX_WFULL_INT_CLR = 0x10
	// Position of I2S_I2S_RX_REMPTY_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_RX_REMPTY_INT_CLR_Pos = 0x3
	// Bit mask of I2S_I2S_RX_REMPTY_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_RX_REMPTY_INT_CLR_Msk = 0x8
	// Bit I2S_I2S_RX_REMPTY_INT_CLR.
	I2S_I2SINT_CLR_I2S_I2S_RX_REMPTY_INT_CLR = 0x8
	// Position of I2S_I2S_RX_WFULL_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_RX_WFULL_INT_CLR_Pos = 0x2
	// Bit mask of I2S_I2S_RX_WFULL_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_RX_WFULL_INT_CLR_Msk = 0x4
	// Bit I2S_I2S_RX_WFULL_INT_CLR.
	I2S_I2SINT_CLR_I2S_I2S_RX_WFULL_INT_CLR = 0x4
	// Position of I2S_I2S_PUT_DATA_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_PUT_DATA_INT_CLR_Pos = 0x1
	// Bit mask of I2S_I2S_PUT_DATA_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_PUT_DATA_INT_CLR_Msk = 0x2
	// Bit I2S_I2S_PUT_DATA_INT_CLR.
	I2S_I2SINT_CLR_I2S_I2S_PUT_DATA_INT_CLR = 0x2
	// Position of I2S_I2S_TAKE_DATA_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_TAKE_DATA_INT_CLR_Pos = 0x0
	// Bit mask of I2S_I2S_TAKE_DATA_INT_CLR field.
	I2S_I2SINT_CLR_I2S_I2S_TAKE_DATA_INT_CLR_Msk = 0x1
	// Bit I2S_I2S_TAKE_DATA_INT_CLR.
	I2S_I2SINT_CLR_I2S_I2S_TAKE_DATA_INT_CLR = 0x1

	// I2STIMING: I2STIMING
	// Position of I2S_TRANS_BCK_IN_INV field.
	I2S_I2STIMING_I2S_TRANS_BCK_IN_INV_Pos = 0x16
	// Bit mask of I2S_TRANS_BCK_IN_INV field.
	I2S_I2STIMING_I2S_TRANS_BCK_IN_INV_Msk = 0x400000
	// Bit I2S_TRANS_BCK_IN_INV.
	I2S_I2STIMING_I2S_TRANS_BCK_IN_INV = 0x400000
	// Position of I2S_RECE_DSYNC_SW field.
	I2S_I2STIMING_I2S_RECE_DSYNC_SW_Pos = 0x15
	// Bit mask of I2S_RECE_DSYNC_SW field.
	I2S_I2STIMING_I2S_RECE_DSYNC_SW_Msk = 0x200000
	// Bit I2S_RECE_DSYNC_SW.
	I2S_I2STIMING_I2S_RECE_DSYNC_SW = 0x200000
	// Position of I2S_TRANS_DSYNC_SW field.
	I2S_I2STIMING_I2S_TRANS_DSYNC_SW_Pos = 0x14
	// Bit mask of I2S_TRANS_DSYNC_SW field.
	I2S_I2STIMING_I2S_TRANS_DSYNC_SW_Msk = 0x100000
	// Bit I2S_TRANS_DSYNC_SW.
	I2S_I2STIMING_I2S_TRANS_DSYNC_SW = 0x100000
	// Position of I2S_RECE_BCK_OUT_DELAY field.
	I2S_I2STIMING_I2S_RECE_BCK_OUT_DELAY_Pos = 0x12
	// Bit mask of I2S_RECE_BCK_OUT_DELAY field.
	I2S_I2STIMING_I2S_RECE_BCK_OUT_DELAY_Msk = 0xc0000
	// Position of I2S_RECE_WS_OUT_DELAY field.
	I2S_I2STIMING_I2S_RECE_WS_OUT_DELAY_Pos = 0x10
	// Bit mask of I2S_RECE_WS_OUT_DELAY field.
	I2S_I2STIMING_I2S_RECE_WS_OUT_DELAY_Msk = 0x30000
	// Position of I2S_TRANS_SD_OUT_DELAY field.
	I2S_I2STIMING_I2S_TRANS_SD_OUT_DELAY_Pos = 0xe
	// Bit mask of I2S_TRANS_SD_OUT_DELAY field.
	I2S_I2STIMING_I2S_TRANS_SD_OUT_DELAY_Msk = 0xc000
	// Position of I2S_TRANS_WS_OUT_DELAY field.
	I2S_I2STIMING_I2S_TRANS_WS_OUT_DELAY_Pos = 0xc
	// Bit mask of I2S_TRANS_WS_OUT_DELAY field.
	I2S_I2STIMING_I2S_TRANS_WS_OUT_DELAY_Msk = 0x3000
	// Position of I2S_TRANS_BCK_OUT_DELAY field.
	I2S_I2STIMING_I2S_TRANS_BCK_OUT_DELAY_Pos = 0xa
	// Bit mask of I2S_TRANS_BCK_OUT_DELAY field.
	I2S_I2STIMING_I2S_TRANS_BCK_OUT_DELAY_Msk = 0xc00
	// Position of I2S_RECE_SD_IN_DELAY field.
	I2S_I2STIMING_I2S_RECE_SD_IN_DELAY_Pos = 0x8
	// Bit mask of I2S_RECE_SD_IN_DELAY field.
	I2S_I2STIMING_I2S_RECE_SD_IN_DELAY_Msk = 0x300
	// Position of I2S_RECE_WS_IN_DELAY field.
	I2S_I2STIMING_I2S_RECE_WS_IN_DELAY_Pos = 0x6
	// Bit mask of I2S_RECE_WS_IN_DELAY field.
	I2S_I2STIMING_I2S_RECE_WS_IN_DELAY_Msk = 0xc0
	// Position of I2S_RECE_BCK_IN_DELAY field.
	I2S_I2STIMING_I2S_RECE_BCK_IN_DELAY_Pos = 0x4
	// Bit mask of I2S_RECE_BCK_IN_DELAY field.
	I2S_I2STIMING_I2S_RECE_BCK_IN_DELAY_Msk = 0x30
	// Position of I2S_TRANS_WS_IN_DELAY field.
	I2S_I2STIMING_I2S_TRANS_WS_IN_DELAY_Pos = 0x2
	// Bit mask of I2S_TRANS_WS_IN_DELAY field.
	I2S_I2STIMING_I2S_TRANS_WS_IN_DELAY_Msk = 0xc
	// Position of I2S_TRANS_BCK_IN_DELAY field.
	I2S_I2STIMING_I2S_TRANS_BCK_IN_DELAY_Pos = 0x0
	// Bit mask of I2S_TRANS_BCK_IN_DELAY field.
	I2S_I2STIMING_I2S_TRANS_BCK_IN_DELAY_Msk = 0x3

	// I2S_FIFO_CONF: I2S_FIFO_CONF
	// Position of I2S_I2S_RX_FIFO_MOD field.
	I2S_I2S_FIFO_CONF_I2S_I2S_RX_FIFO_MOD_Pos = 0x10
	// Bit mask of I2S_I2S_RX_FIFO_MOD field.
	I2S_I2S_FIFO_CONF_I2S_I2S_RX_FIFO_MOD_Msk = 0x70000
	// Position of I2S_I2S_TX_FIFO_MOD field.
	I2S_I2S_FIFO_CONF_I2S_I2S_TX_FIFO_MOD_Pos = 0xd
	// Bit mask of I2S_I2S_TX_FIFO_MOD field.
	I2S_I2S_FIFO_CONF_I2S_I2S_TX_FIFO_MOD_Msk = 0xe000
	// Position of I2S_I2S_DSCR_EN field.
	I2S_I2S_FIFO_CONF_I2S_I2S_DSCR_EN_Pos = 0xc
	// Bit mask of I2S_I2S_DSCR_EN field.
	I2S_I2S_FIFO_CONF_I2S_I2S_DSCR_EN_Msk = 0x1000
	// Bit I2S_I2S_DSCR_EN.
	I2S_I2S_FIFO_CONF_I2S_I2S_DSCR_EN = 0x1000
	// Position of I2S_I2S_TX_DATA_NUM field.
	I2S_I2S_FIFO_CONF_I2S_I2S_TX_DATA_NUM_Pos = 0x6
	// Bit mask of I2S_I2S_TX_DATA_NUM field.
	I2S_I2S_FIFO_CONF_I2S_I2S_TX_DATA_NUM_Msk = 0xfc0
	// Position of I2S_I2S_RX_DATA_NUM field.
	I2S_I2S_FIFO_CONF_I2S_I2S_RX_DATA_NUM_Pos = 0x0
	// Bit mask of I2S_I2S_RX_DATA_NUM field.
	I2S_I2S_FIFO_CONF_I2S_I2S_RX_DATA_NUM_Msk = 0x3f

	// I2SRXEOF_NUM: I2SRXEOF_NUM
	// Position of I2S_I2S_RX_EOF_NUM field.
	I2S_I2SRXEOF_NUM_I2S_I2S_RX_EOF_NUM_Pos = 0x0
	// Bit mask of I2S_I2S_RX_EOF_NUM field.
	I2S_I2SRXEOF_NUM_I2S_I2S_RX_EOF_NUM_Msk = 0xffffffff

	// I2SCONF_SIGLE_DATA: I2SCONF_SIGLE_DATA
	// Position of I2S_I2S_SIGLE_DATA field.
	I2S_I2SCONF_SIGLE_DATA_I2S_I2S_SIGLE_DATA_Pos = 0x0
	// Bit mask of I2S_I2S_SIGLE_DATA field.
	I2S_I2SCONF_SIGLE_DATA_I2S_I2S_SIGLE_DATA_Msk = 0xffffffff
)

// Constants for IO_MUX
const (
	// IO_MUX_CONF: IO_MUX_CONF
	// Position of SPI0_CLK_EQU_SYS_CLK field.
	IO_MUX_IO_MUX_CONF_SPI0_CLK_EQU_SYS_CLK_Pos = 0x8
	// Bit mask of SPI0_CLK_EQU_SYS_CLK field.
	IO_MUX_IO_MUX_CONF_SPI0_CLK_EQU_SYS_CLK_Msk = 0x100
	// Bit SPI0_CLK_EQU_SYS_CLK.
	IO_MUX_IO_MUX_CONF_SPI0_CLK_EQU_SYS_CLK = 0x100
	// Position of SPI1_CLK_EQU_SYS_CLK field.
	IO_MUX_IO_MUX_CONF_SPI1_CLK_EQU_SYS_CLK_Pos = 0x9
	// Bit mask of SPI1_CLK_EQU_SYS_CLK field.
	IO_MUX_IO_MUX_CONF_SPI1_CLK_EQU_SYS_CLK_Msk = 0x200
	// Bit SPI1_CLK_EQU_SYS_CLK.
	IO_MUX_IO_MUX_CONF_SPI1_CLK_EQU_SYS_CLK = 0x200

	// IO_MUX_MTDI: IO_MUX_MTDI
	// Position of Register field.
	IO_MUX_IO_MUX_MTDI_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_MTDI_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTDI_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTDI_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTDI_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTDI_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_MTDI_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_MTDI_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_MTDI_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_MTDI_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTDI_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTDI_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_MTDI_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTDI_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTDI_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_MTDI_SLEEP_ENABLE = 0x1

	// IO_MUX_MTCK: IO_MUX_MTCK
	// Position of Register field.
	IO_MUX_IO_MUX_MTCK_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_MTCK_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTCK_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTCK_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTCK_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTCK_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_MTCK_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_MTCK_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_MTCK_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_MTCK_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTCK_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTCK_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_MTCK_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTCK_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTCK_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_MTCK_SLEEP_ENABLE = 0x1

	// IO_MUX_MTMS: IO_MUX_MTMS
	// Position of Register field.
	IO_MUX_IO_MUX_MTMS_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_MTMS_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTMS_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTMS_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTMS_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTMS_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_MTMS_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_MTMS_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_MTMS_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_MTMS_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTMS_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTMS_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_MTMS_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTMS_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTMS_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_MTMS_SLEEP_ENABLE = 0x1

	// IO_MUX_MTDO: IO_MUX_MTDO
	// Position of Register field.
	IO_MUX_IO_MUX_MTDO_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_MTDO_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTDO_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_MTDO_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTDO_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_MTDO_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_MTDO_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_MTDO_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_MTDO_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_MTDO_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTDO_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_MTDO_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_MTDO_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTDO_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_MTDO_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_MTDO_SLEEP_ENABLE = 0x1

	// IO_MUX_U0RXD: IO_MUX_U0RXD
	// Position of Register field.
	IO_MUX_IO_MUX_U0RXD_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_U0RXD_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_U0RXD_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_U0RXD_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_U0RXD_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_U0RXD_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_U0RXD_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_U0RXD_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_U0RXD_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_U0RXD_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_U0RXD_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_U0RXD_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_U0RXD_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_U0RXD_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_U0RXD_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_U0RXD_SLEEP_ENABLE = 0x1

	// IO_MUX_U0TXD: IO_MUX_U0TXD
	// Position of Register field.
	IO_MUX_IO_MUX_U0TXD_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_U0TXD_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_U0TXD_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_U0TXD_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_U0TXD_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_U0TXD_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_U0TXD_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_U0TXD_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_U0TXD_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_U0TXD_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_U0TXD_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_U0TXD_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_U0TXD_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_U0TXD_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_U0TXD_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_U0TXD_SLEEP_ENABLE = 0x1

	// IO_MUX_SD_CLK: IO_MUX_SD_CLK
	// Position of Register field.
	IO_MUX_IO_MUX_SD_CLK_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_SD_CLK_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_CLK_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_CLK_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_CLK_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_CLK_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_SD_CLK_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_SD_CLK_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_SD_CLK_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_SD_CLK_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_CLK_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_CLK_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_SD_CLK_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_CLK_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_CLK_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_SD_CLK_SLEEP_ENABLE = 0x1

	// IO_MUX_SD_DATA0: IO_MUX_SD_DATA0
	// Position of Register field.
	IO_MUX_IO_MUX_SD_DATA0_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_SD_DATA0_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA0_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA0_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA0_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA0_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_SD_DATA0_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA0_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA0_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_SD_DATA0_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA0_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA0_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_SD_DATA0_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA0_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA0_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_SD_DATA0_SLEEP_ENABLE = 0x1

	// IO_MUX_SD_DATA1: IO_MUX_SD_DATA1
	// Position of Register field.
	IO_MUX_IO_MUX_SD_DATA1_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_SD_DATA1_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA1_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA1_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA1_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA1_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_SD_DATA1_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA1_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA1_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_SD_DATA1_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA1_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA1_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_SD_DATA1_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA1_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA1_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_SD_DATA1_SLEEP_ENABLE = 0x1

	// IO_MUX_SD_DATA2: IO_MUX_SD_DATA2
	// Position of Register field.
	IO_MUX_IO_MUX_SD_DATA2_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_SD_DATA2_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA2_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA2_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA2_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA2_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_SD_DATA2_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA2_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA2_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_SD_DATA2_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA2_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA2_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_SD_DATA2_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA2_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA2_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_SD_DATA2_SLEEP_ENABLE = 0x1

	// IO_MUX_SD_DATA3: IO_MUX_SD_DATA3
	// Position of Register field.
	IO_MUX_IO_MUX_SD_DATA3_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_SD_DATA3_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA3_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_DATA3_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA3_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_DATA3_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_SD_DATA3_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA3_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_SD_DATA3_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_SD_DATA3_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA3_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_DATA3_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_SD_DATA3_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA3_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_DATA3_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_SD_DATA3_SLEEP_ENABLE = 0x1

	// IO_MUX_SD_CMD: IO_MUX_SD_CMD
	// Position of Register field.
	IO_MUX_IO_MUX_SD_CMD_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_SD_CMD_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_CMD_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_SD_CMD_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_CMD_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_SD_CMD_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_SD_CMD_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_SD_CMD_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_SD_CMD_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_SD_CMD_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_CMD_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_SD_CMD_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_SD_CMD_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_CMD_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_SD_CMD_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_SD_CMD_SLEEP_ENABLE = 0x1

	// IO_MUX_GPIO0: IO_MUX_GPIO0
	// Position of Register field.
	IO_MUX_IO_MUX_GPIO0_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_GPIO0_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO0_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO0_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO0_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO0_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_GPIO0_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_GPIO0_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_GPIO0_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_GPIO0_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO0_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO0_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_GPIO0_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO0_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO0_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_GPIO0_SLEEP_ENABLE = 0x1

	// IO_MUX_GPIO2: IO_MUX_GPIO2
	// Position of Register field.
	IO_MUX_IO_MUX_GPIO2_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_GPIO2_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO2_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO2_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO2_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO2_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_GPIO2_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_GPIO2_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_GPIO2_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_GPIO2_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO2_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO2_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_GPIO2_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO2_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO2_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_GPIO2_SLEEP_ENABLE = 0x1

	// IO_MUX_GPIO4: IO_MUX_GPIO4
	// Position of Register field.
	IO_MUX_IO_MUX_GPIO4_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_GPIO4_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO4_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO4_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO4_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO4_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_GPIO4_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_GPIO4_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_GPIO4_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_GPIO4_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO4_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO4_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_GPIO4_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO4_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO4_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_GPIO4_SLEEP_ENABLE = 0x1

	// IO_MUX_GPIO5: IO_MUX_GPIO5
	// Position of Register field.
	IO_MUX_IO_MUX_GPIO5_Register_Pos = 0x0
	// Bit mask of Register field.
	IO_MUX_IO_MUX_GPIO5_Register_Msk = 0xffffffff
	// Position of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO5_FUNCTION_SELECT_LOW_BITS_Pos = 0x4
	// Bit mask of FUNCTION_SELECT_LOW_BITS field.
	IO_MUX_IO_MUX_GPIO5_FUNCTION_SELECT_LOW_BITS_Msk = 0x30
	// Position of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO5_FUNCTION_SELECT_HIGH_BIT_Pos = 0x8
	// Bit mask of FUNCTION_SELECT_HIGH_BIT field.
	IO_MUX_IO_MUX_GPIO5_FUNCTION_SELECT_HIGH_BIT_Msk = 0x100
	// Bit FUNCTION_SELECT_HIGH_BIT.
	IO_MUX_IO_MUX_GPIO5_FUNCTION_SELECT_HIGH_BIT = 0x100
	// Position of PULLUP field.
	IO_MUX_IO_MUX_GPIO5_PULLUP_Pos = 0x7
	// Bit mask of PULLUP field.
	IO_MUX_IO_MUX_GPIO5_PULLUP_Msk = 0x80
	// Bit PULLUP.
	IO_MUX_IO_MUX_GPIO5_PULLUP = 0x80
	// Position of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO5_SLEEP_PULLUP_Pos = 0x3
	// Bit mask of SLEEP_PULLUP field.
	IO_MUX_IO_MUX_GPIO5_SLEEP_PULLUP_Msk = 0x8
	// Bit SLEEP_PULLUP.
	IO_MUX_IO_MUX_GPIO5_SLEEP_PULLUP = 0x8
	// Position of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO5_SLEEP_ENABLE_Pos = 0x0
	// Bit mask of SLEEP_ENABLE field.
	IO_MUX_IO_MUX_GPIO5_SLEEP_ENABLE_Msk = 0x1
	// Bit SLEEP_ENABLE.
	IO_MUX_IO_MUX_GPIO5_SLEEP_ENABLE = 0x1
)

// Constants for RTC
const (
	// RTC_STATE1: RTC_STATE1
	// Position of Register field.
	RTC_RTC_STATE1_Register_Pos = 0x0
	// Bit mask of Register field.
	RTC_RTC_STATE1_Register_Msk = 0xffffffff

	// RTC_STORE0: RTC_STORE0
	// Position of Register field.
	RTC_RTC_STORE0_Register_Pos = 0x0
	// Bit mask of Register field.
	RTC_RTC_STORE0_Register_Msk = 0xffffffff
)

// Constants for SLC
const (
	// SLC_CONF0: SLC_CONF0
	// Position of SLC_MODE field.
	SLC_SLC_CONF0_SLC_MODE_Pos = 0xc
	// Bit mask of SLC_MODE field.
	SLC_SLC_CONF0_SLC_MODE_Msk = 0x3000
	// Position of SLC_DATA_BURST_EN field.
	SLC_SLC_CONF0_SLC_DATA_BURST_EN_Pos = 0x9
	// Bit mask of SLC_DATA_BURST_EN field.
	SLC_SLC_CONF0_SLC_DATA_BURST_EN_Msk = 0x200
	// Bit SLC_DATA_BURST_EN.
	SLC_SLC_CONF0_SLC_DATA_BURST_EN = 0x200
	// Position of SLC_DSCR_BURST_EN field.
	SLC_SLC_CONF0_SLC_DSCR_BURST_EN_Pos = 0x8
	// Bit mask of SLC_DSCR_BURST_EN field.
	SLC_SLC_CONF0_SLC_DSCR_BURST_EN_Msk = 0x100
	// Bit SLC_DSCR_BURST_EN.
	SLC_SLC_CONF0_SLC_DSCR_BURST_EN = 0x100
	// Position of SLC_RX_NO_RESTART_CLR field.
	SLC_SLC_CONF0_SLC_RX_NO_RESTART_CLR_Pos = 0x7
	// Bit mask of SLC_RX_NO_RESTART_CLR field.
	SLC_SLC_CONF0_SLC_RX_NO_RESTART_CLR_Msk = 0x80
	// Bit SLC_RX_NO_RESTART_CLR.
	SLC_SLC_CONF0_SLC_RX_NO_RESTART_CLR = 0x80
	// Position of SLC_RX_AUTO_WRBACK field.
	SLC_SLC_CONF0_SLC_RX_AUTO_WRBACK_Pos = 0x6
	// Bit mask of SLC_RX_AUTO_WRBACK field.
	SLC_SLC_CONF0_SLC_RX_AUTO_WRBACK_Msk = 0x40
	// Bit SLC_RX_AUTO_WRBACK.
	SLC_SLC_CONF0_SLC_RX_AUTO_WRBACK = 0x40
	// Position of SLC_RX_LOOP_TEST field.
	SLC_SLC_CONF0_SLC_RX_LOOP_TEST_Pos = 0x5
	// Bit mask of SLC_RX_LOOP_TEST field.
	SLC_SLC_CONF0_SLC_RX_LOOP_TEST_Msk = 0x20
	// Bit SLC_RX_LOOP_TEST.
	SLC_SLC_CONF0_SLC_RX_LOOP_TEST = 0x20
	// Position of SLC_TX_LOOP_TEST field.
	SLC_SLC_CONF0_SLC_TX_LOOP_TEST_Pos = 0x4
	// Bit mask of SLC_TX_LOOP_TEST field.
	SLC_SLC_CONF0_SLC_TX_LOOP_TEST_Msk = 0x10
	// Bit SLC_TX_LOOP_TEST.
	SLC_SLC_CONF0_SLC_TX_LOOP_TEST = 0x10
	// Position of SLC_AHBM_RST field.
	SLC_SLC_CONF0_SLC_AHBM_RST_Pos = 0x3
	// Bit mask of SLC_AHBM_RST field.
	SLC_SLC_CONF0_SLC_AHBM_RST_Msk = 0x8
	// Bit SLC_AHBM_RST.
	SLC_SLC_CONF0_SLC_AHBM_RST = 0x8
	// Position of SLC_AHBM_FIFO_RST field.
	SLC_SLC_CONF0_SLC_AHBM_FIFO_RST_Pos = 0x2
	// Bit mask of SLC_AHBM_FIFO_RST field.
	SLC_SLC_CONF0_SLC_AHBM_FIFO_RST_Msk = 0x4
	// Bit SLC_AHBM_FIFO_RST.
	SLC_SLC_CONF0_SLC_AHBM_FIFO_RST = 0x4
	// Position of SLC_RXLINK_RST field.
	SLC_SLC_CONF0_SLC_RXLINK_RST_Pos = 0x1
	// Bit mask of SLC_RXLINK_RST field.
	SLC_SLC_CONF0_SLC_RXLINK_RST_Msk = 0x2
	// Bit SLC_RXLINK_RST.
	SLC_SLC_CONF0_SLC_RXLINK_RST = 0x2
	// Position of SLC_TXLINK_RST field.
	SLC_SLC_CONF0_SLC_TXLINK_RST_Pos = 0x0
	// Bit mask of SLC_TXLINK_RST field.
	SLC_SLC_CONF0_SLC_TXLINK_RST_Msk = 0x1
	// Bit SLC_TXLINK_RST.
	SLC_SLC_CONF0_SLC_TXLINK_RST = 0x1

	// SLC_INT_RAW: SLC_INT_RAW
	// Position of SLC_TX_DSCR_EMPTY_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_DSCR_EMPTY_INT_RAW_Pos = 0x15
	// Bit mask of SLC_TX_DSCR_EMPTY_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_DSCR_EMPTY_INT_RAW_Msk = 0x200000
	// Bit SLC_TX_DSCR_EMPTY_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TX_DSCR_EMPTY_INT_RAW = 0x200000
	// Position of SLC_RX_DSCR_ERR_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_DSCR_ERR_INT_RAW_Pos = 0x14
	// Bit mask of SLC_RX_DSCR_ERR_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_DSCR_ERR_INT_RAW_Msk = 0x100000
	// Bit SLC_RX_DSCR_ERR_INT_RAW.
	SLC_SLC_INT_RAW_SLC_RX_DSCR_ERR_INT_RAW = 0x100000
	// Position of SLC_TX_DSCR_ERR_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_DSCR_ERR_INT_RAW_Pos = 0x13
	// Bit mask of SLC_TX_DSCR_ERR_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_DSCR_ERR_INT_RAW_Msk = 0x80000
	// Bit SLC_TX_DSCR_ERR_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TX_DSCR_ERR_INT_RAW = 0x80000
	// Position of SLC_TOHOST_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TOHOST_INT_RAW_Pos = 0x12
	// Bit mask of SLC_TOHOST_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TOHOST_INT_RAW_Msk = 0x40000
	// Bit SLC_TOHOST_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TOHOST_INT_RAW = 0x40000
	// Position of SLC_RX_EOF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_EOF_INT_RAW_Pos = 0x11
	// Bit mask of SLC_RX_EOF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_EOF_INT_RAW_Msk = 0x20000
	// Bit SLC_RX_EOF_INT_RAW.
	SLC_SLC_INT_RAW_SLC_RX_EOF_INT_RAW = 0x20000
	// Position of SLC_RX_DONE_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_DONE_INT_RAW_Pos = 0x10
	// Bit mask of SLC_RX_DONE_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_DONE_INT_RAW_Msk = 0x10000
	// Bit SLC_RX_DONE_INT_RAW.
	SLC_SLC_INT_RAW_SLC_RX_DONE_INT_RAW = 0x10000
	// Position of SLC_TX_EOF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_EOF_INT_RAW_Pos = 0xf
	// Bit mask of SLC_TX_EOF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_EOF_INT_RAW_Msk = 0x8000
	// Bit SLC_TX_EOF_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TX_EOF_INT_RAW = 0x8000
	// Position of SLC_TX_DONE_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_DONE_INT_RAW_Pos = 0xe
	// Bit mask of SLC_TX_DONE_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_DONE_INT_RAW_Msk = 0x4000
	// Bit SLC_TX_DONE_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TX_DONE_INT_RAW = 0x4000
	// Position of SLC_TOKEN1_1TO0_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TOKEN1_1TO0_INT_RAW_Pos = 0xd
	// Bit mask of SLC_TOKEN1_1TO0_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TOKEN1_1TO0_INT_RAW_Msk = 0x2000
	// Bit SLC_TOKEN1_1TO0_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TOKEN1_1TO0_INT_RAW = 0x2000
	// Position of SLC_TOKEN0_1TO0_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TOKEN0_1TO0_INT_RAW_Pos = 0xc
	// Bit mask of SLC_TOKEN0_1TO0_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TOKEN0_1TO0_INT_RAW_Msk = 0x1000
	// Bit SLC_TOKEN0_1TO0_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TOKEN0_1TO0_INT_RAW = 0x1000
	// Position of SLC_TX_OVF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_OVF_INT_RAW_Pos = 0xb
	// Bit mask of SLC_TX_OVF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_OVF_INT_RAW_Msk = 0x800
	// Bit SLC_TX_OVF_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TX_OVF_INT_RAW = 0x800
	// Position of SLC_RX_UDF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_UDF_INT_RAW_Pos = 0xa
	// Bit mask of SLC_RX_UDF_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_UDF_INT_RAW_Msk = 0x400
	// Bit SLC_RX_UDF_INT_RAW.
	SLC_SLC_INT_RAW_SLC_RX_UDF_INT_RAW = 0x400
	// Position of SLC_TX_START_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_START_INT_RAW_Pos = 0x9
	// Bit mask of SLC_TX_START_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_TX_START_INT_RAW_Msk = 0x200
	// Bit SLC_TX_START_INT_RAW.
	SLC_SLC_INT_RAW_SLC_TX_START_INT_RAW = 0x200
	// Position of SLC_RX_START_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_START_INT_RAW_Pos = 0x8
	// Bit mask of SLC_RX_START_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_RX_START_INT_RAW_Msk = 0x100
	// Bit SLC_RX_START_INT_RAW.
	SLC_SLC_INT_RAW_SLC_RX_START_INT_RAW = 0x100
	// Position of SLC_FRHOST_BIT7_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT7_INT_RAW_Pos = 0x7
	// Bit mask of SLC_FRHOST_BIT7_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT7_INT_RAW_Msk = 0x80
	// Bit SLC_FRHOST_BIT7_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT7_INT_RAW = 0x80
	// Position of SLC_FRHOST_BIT6_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT6_INT_RAW_Pos = 0x6
	// Bit mask of SLC_FRHOST_BIT6_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT6_INT_RAW_Msk = 0x40
	// Bit SLC_FRHOST_BIT6_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT6_INT_RAW = 0x40
	// Position of SLC_FRHOST_BIT5_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT5_INT_RAW_Pos = 0x5
	// Bit mask of SLC_FRHOST_BIT5_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT5_INT_RAW_Msk = 0x20
	// Bit SLC_FRHOST_BIT5_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT5_INT_RAW = 0x20
	// Position of SLC_FRHOST_BIT4_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT4_INT_RAW_Pos = 0x4
	// Bit mask of SLC_FRHOST_BIT4_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT4_INT_RAW_Msk = 0x10
	// Bit SLC_FRHOST_BIT4_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT4_INT_RAW = 0x10
	// Position of SLC_FRHOST_BIT3_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT3_INT_RAW_Pos = 0x3
	// Bit mask of SLC_FRHOST_BIT3_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT3_INT_RAW_Msk = 0x8
	// Bit SLC_FRHOST_BIT3_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT3_INT_RAW = 0x8
	// Position of SLC_FRHOST_BIT2_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT2_INT_RAW_Pos = 0x2
	// Bit mask of SLC_FRHOST_BIT2_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT2_INT_RAW_Msk = 0x4
	// Bit SLC_FRHOST_BIT2_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT2_INT_RAW = 0x4
	// Position of SLC_FRHOST_BIT1_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT1_INT_RAW_Pos = 0x1
	// Bit mask of SLC_FRHOST_BIT1_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT1_INT_RAW_Msk = 0x2
	// Bit SLC_FRHOST_BIT1_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT1_INT_RAW = 0x2
	// Position of SLC_FRHOST_BIT0_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT0_INT_RAW_Pos = 0x0
	// Bit mask of SLC_FRHOST_BIT0_INT_RAW field.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT0_INT_RAW_Msk = 0x1
	// Bit SLC_FRHOST_BIT0_INT_RAW.
	SLC_SLC_INT_RAW_SLC_FRHOST_BIT0_INT_RAW = 0x1

	// SLC_INT_STATUS: SLC_INT_STATUS
	// Position of SLC_TX_DSCR_EMPTY_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_DSCR_EMPTY_INT_ST_Pos = 0x15
	// Bit mask of SLC_TX_DSCR_EMPTY_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_DSCR_EMPTY_INT_ST_Msk = 0x200000
	// Bit SLC_TX_DSCR_EMPTY_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TX_DSCR_EMPTY_INT_ST = 0x200000
	// Position of SLC_RX_DSCR_ERR_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_DSCR_ERR_INT_ST_Pos = 0x14
	// Bit mask of SLC_RX_DSCR_ERR_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_DSCR_ERR_INT_ST_Msk = 0x100000
	// Bit SLC_RX_DSCR_ERR_INT_ST.
	SLC_SLC_INT_STATUS_SLC_RX_DSCR_ERR_INT_ST = 0x100000
	// Position of SLC_TX_DSCR_ERR_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_DSCR_ERR_INT_ST_Pos = 0x13
	// Bit mask of SLC_TX_DSCR_ERR_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_DSCR_ERR_INT_ST_Msk = 0x80000
	// Bit SLC_TX_DSCR_ERR_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TX_DSCR_ERR_INT_ST = 0x80000
	// Position of SLC_TOHOST_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TOHOST_INT_ST_Pos = 0x12
	// Bit mask of SLC_TOHOST_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TOHOST_INT_ST_Msk = 0x40000
	// Bit SLC_TOHOST_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TOHOST_INT_ST = 0x40000
	// Position of SLC_RX_EOF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_EOF_INT_ST_Pos = 0x11
	// Bit mask of SLC_RX_EOF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_EOF_INT_ST_Msk = 0x20000
	// Bit SLC_RX_EOF_INT_ST.
	SLC_SLC_INT_STATUS_SLC_RX_EOF_INT_ST = 0x20000
	// Position of SLC_RX_DONE_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_DONE_INT_ST_Pos = 0x10
	// Bit mask of SLC_RX_DONE_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_DONE_INT_ST_Msk = 0x10000
	// Bit SLC_RX_DONE_INT_ST.
	SLC_SLC_INT_STATUS_SLC_RX_DONE_INT_ST = 0x10000
	// Position of SLC_TX_EOF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_EOF_INT_ST_Pos = 0xf
	// Bit mask of SLC_TX_EOF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_EOF_INT_ST_Msk = 0x8000
	// Bit SLC_TX_EOF_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TX_EOF_INT_ST = 0x8000
	// Position of SLC_TX_DONE_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_DONE_INT_ST_Pos = 0xe
	// Bit mask of SLC_TX_DONE_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_DONE_INT_ST_Msk = 0x4000
	// Bit SLC_TX_DONE_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TX_DONE_INT_ST = 0x4000
	// Position of SLC_TOKEN1_1TO0_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TOKEN1_1TO0_INT_ST_Pos = 0xd
	// Bit mask of SLC_TOKEN1_1TO0_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TOKEN1_1TO0_INT_ST_Msk = 0x2000
	// Bit SLC_TOKEN1_1TO0_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TOKEN1_1TO0_INT_ST = 0x2000
	// Position of SLC_TOKEN0_1TO0_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TOKEN0_1TO0_INT_ST_Pos = 0xc
	// Bit mask of SLC_TOKEN0_1TO0_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TOKEN0_1TO0_INT_ST_Msk = 0x1000
	// Bit SLC_TOKEN0_1TO0_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TOKEN0_1TO0_INT_ST = 0x1000
	// Position of SLC_TX_OVF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_OVF_INT_ST_Pos = 0xb
	// Bit mask of SLC_TX_OVF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_OVF_INT_ST_Msk = 0x800
	// Bit SLC_TX_OVF_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TX_OVF_INT_ST = 0x800
	// Position of SLC_RX_UDF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_UDF_INT_ST_Pos = 0xa
	// Bit mask of SLC_RX_UDF_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_UDF_INT_ST_Msk = 0x400
	// Bit SLC_RX_UDF_INT_ST.
	SLC_SLC_INT_STATUS_SLC_RX_UDF_INT_ST = 0x400
	// Position of SLC_TX_START_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_START_INT_ST_Pos = 0x9
	// Bit mask of SLC_TX_START_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_TX_START_INT_ST_Msk = 0x200
	// Bit SLC_TX_START_INT_ST.
	SLC_SLC_INT_STATUS_SLC_TX_START_INT_ST = 0x200
	// Position of SLC_RX_START_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_START_INT_ST_Pos = 0x8
	// Bit mask of SLC_RX_START_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_RX_START_INT_ST_Msk = 0x100
	// Bit SLC_RX_START_INT_ST.
	SLC_SLC_INT_STATUS_SLC_RX_START_INT_ST = 0x100
	// Position of SLC_FRHOST_BIT7_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT7_INT_ST_Pos = 0x7
	// Bit mask of SLC_FRHOST_BIT7_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT7_INT_ST_Msk = 0x80
	// Bit SLC_FRHOST_BIT7_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT7_INT_ST = 0x80
	// Position of SLC_FRHOST_BIT6_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT6_INT_ST_Pos = 0x6
	// Bit mask of SLC_FRHOST_BIT6_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT6_INT_ST_Msk = 0x40
	// Bit SLC_FRHOST_BIT6_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT6_INT_ST = 0x40
	// Position of SLC_FRHOST_BIT5_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT5_INT_ST_Pos = 0x5
	// Bit mask of SLC_FRHOST_BIT5_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT5_INT_ST_Msk = 0x20
	// Bit SLC_FRHOST_BIT5_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT5_INT_ST = 0x20
	// Position of SLC_FRHOST_BIT4_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT4_INT_ST_Pos = 0x4
	// Bit mask of SLC_FRHOST_BIT4_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT4_INT_ST_Msk = 0x10
	// Bit SLC_FRHOST_BIT4_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT4_INT_ST = 0x10
	// Position of SLC_FRHOST_BIT3_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT3_INT_ST_Pos = 0x3
	// Bit mask of SLC_FRHOST_BIT3_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT3_INT_ST_Msk = 0x8
	// Bit SLC_FRHOST_BIT3_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT3_INT_ST = 0x8
	// Position of SLC_FRHOST_BIT2_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT2_INT_ST_Pos = 0x2
	// Bit mask of SLC_FRHOST_BIT2_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT2_INT_ST_Msk = 0x4
	// Bit SLC_FRHOST_BIT2_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT2_INT_ST = 0x4
	// Position of SLC_FRHOST_BIT1_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT1_INT_ST_Pos = 0x1
	// Bit mask of SLC_FRHOST_BIT1_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT1_INT_ST_Msk = 0x2
	// Bit SLC_FRHOST_BIT1_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT1_INT_ST = 0x2
	// Position of SLC_FRHOST_BIT0_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT0_INT_ST_Pos = 0x0
	// Bit mask of SLC_FRHOST_BIT0_INT_ST field.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT0_INT_ST_Msk = 0x1
	// Bit SLC_FRHOST_BIT0_INT_ST.
	SLC_SLC_INT_STATUS_SLC_FRHOST_BIT0_INT_ST = 0x1

	// SLC_INT_ENA: SLC_INT_ENA
	// Position of SLC_TX_DSCR_EMPTY_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_DSCR_EMPTY_INT_ENA_Pos = 0x15
	// Bit mask of SLC_TX_DSCR_EMPTY_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_DSCR_EMPTY_INT_ENA_Msk = 0x200000
	// Bit SLC_TX_DSCR_EMPTY_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TX_DSCR_EMPTY_INT_ENA = 0x200000
	// Position of SLC_RX_DSCR_ERR_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_DSCR_ERR_INT_ENA_Pos = 0x14
	// Bit mask of SLC_RX_DSCR_ERR_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_DSCR_ERR_INT_ENA_Msk = 0x100000
	// Bit SLC_RX_DSCR_ERR_INT_ENA.
	SLC_SLC_INT_ENA_SLC_RX_DSCR_ERR_INT_ENA = 0x100000
	// Position of SLC_TX_DSCR_ERR_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_DSCR_ERR_INT_ENA_Pos = 0x13
	// Bit mask of SLC_TX_DSCR_ERR_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_DSCR_ERR_INT_ENA_Msk = 0x80000
	// Bit SLC_TX_DSCR_ERR_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TX_DSCR_ERR_INT_ENA = 0x80000
	// Position of SLC_TOHOST_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TOHOST_INT_ENA_Pos = 0x12
	// Bit mask of SLC_TOHOST_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TOHOST_INT_ENA_Msk = 0x40000
	// Bit SLC_TOHOST_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TOHOST_INT_ENA = 0x40000
	// Position of SLC_RX_EOF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_EOF_INT_ENA_Pos = 0x11
	// Bit mask of SLC_RX_EOF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_EOF_INT_ENA_Msk = 0x20000
	// Bit SLC_RX_EOF_INT_ENA.
	SLC_SLC_INT_ENA_SLC_RX_EOF_INT_ENA = 0x20000
	// Position of SLC_RX_DONE_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_DONE_INT_ENA_Pos = 0x10
	// Bit mask of SLC_RX_DONE_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_DONE_INT_ENA_Msk = 0x10000
	// Bit SLC_RX_DONE_INT_ENA.
	SLC_SLC_INT_ENA_SLC_RX_DONE_INT_ENA = 0x10000
	// Position of SLC_TX_EOF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_EOF_INT_ENA_Pos = 0xf
	// Bit mask of SLC_TX_EOF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_EOF_INT_ENA_Msk = 0x8000
	// Bit SLC_TX_EOF_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TX_EOF_INT_ENA = 0x8000
	// Position of SLC_TX_DONE_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_DONE_INT_ENA_Pos = 0xe
	// Bit mask of SLC_TX_DONE_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_DONE_INT_ENA_Msk = 0x4000
	// Bit SLC_TX_DONE_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TX_DONE_INT_ENA = 0x4000
	// Position of SLC_TOKEN1_1TO0_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TOKEN1_1TO0_INT_ENA_Pos = 0xd
	// Bit mask of SLC_TOKEN1_1TO0_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TOKEN1_1TO0_INT_ENA_Msk = 0x2000
	// Bit SLC_TOKEN1_1TO0_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TOKEN1_1TO0_INT_ENA = 0x2000
	// Position of SLC_TOKEN0_1TO0_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TOKEN0_1TO0_INT_ENA_Pos = 0xc
	// Bit mask of SLC_TOKEN0_1TO0_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TOKEN0_1TO0_INT_ENA_Msk = 0x1000
	// Bit SLC_TOKEN0_1TO0_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TOKEN0_1TO0_INT_ENA = 0x1000
	// Position of SLC_TX_OVF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_OVF_INT_ENA_Pos = 0xb
	// Bit mask of SLC_TX_OVF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_OVF_INT_ENA_Msk = 0x800
	// Bit SLC_TX_OVF_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TX_OVF_INT_ENA = 0x800
	// Position of SLC_RX_UDF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_UDF_INT_ENA_Pos = 0xa
	// Bit mask of SLC_RX_UDF_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_UDF_INT_ENA_Msk = 0x400
	// Bit SLC_RX_UDF_INT_ENA.
	SLC_SLC_INT_ENA_SLC_RX_UDF_INT_ENA = 0x400
	// Position of SLC_TX_START_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_START_INT_ENA_Pos = 0x9
	// Bit mask of SLC_TX_START_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_TX_START_INT_ENA_Msk = 0x200
	// Bit SLC_TX_START_INT_ENA.
	SLC_SLC_INT_ENA_SLC_TX_START_INT_ENA = 0x200
	// Position of SLC_RX_START_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_START_INT_ENA_Pos = 0x8
	// Bit mask of SLC_RX_START_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_RX_START_INT_ENA_Msk = 0x100
	// Bit SLC_RX_START_INT_ENA.
	SLC_SLC_INT_ENA_SLC_RX_START_INT_ENA = 0x100
	// Position of SLC_FRHOST_BIT7_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT7_INT_ENA_Pos = 0x7
	// Bit mask of SLC_FRHOST_BIT7_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT7_INT_ENA_Msk = 0x80
	// Bit SLC_FRHOST_BIT7_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT7_INT_ENA = 0x80
	// Position of SLC_FRHOST_BIT6_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT6_INT_ENA_Pos = 0x6
	// Bit mask of SLC_FRHOST_BIT6_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT6_INT_ENA_Msk = 0x40
	// Bit SLC_FRHOST_BIT6_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT6_INT_ENA = 0x40
	// Position of SLC_FRHOST_BIT5_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT5_INT_ENA_Pos = 0x5
	// Bit mask of SLC_FRHOST_BIT5_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT5_INT_ENA_Msk = 0x20
	// Bit SLC_FRHOST_BIT5_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT5_INT_ENA = 0x20
	// Position of SLC_FRHOST_BIT4_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT4_INT_ENA_Pos = 0x4
	// Bit mask of SLC_FRHOST_BIT4_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT4_INT_ENA_Msk = 0x10
	// Bit SLC_FRHOST_BIT4_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT4_INT_ENA = 0x10
	// Position of SLC_FRHOST_BIT3_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT3_INT_ENA_Pos = 0x3
	// Bit mask of SLC_FRHOST_BIT3_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT3_INT_ENA_Msk = 0x8
	// Bit SLC_FRHOST_BIT3_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT3_INT_ENA = 0x8
	// Position of SLC_FRHOST_BIT2_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT2_INT_ENA_Pos = 0x2
	// Bit mask of SLC_FRHOST_BIT2_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT2_INT_ENA_Msk = 0x4
	// Bit SLC_FRHOST_BIT2_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT2_INT_ENA = 0x4
	// Position of SLC_FRHOST_BIT1_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT1_INT_ENA_Pos = 0x1
	// Bit mask of SLC_FRHOST_BIT1_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT1_INT_ENA_Msk = 0x2
	// Bit SLC_FRHOST_BIT1_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT1_INT_ENA = 0x2
	// Position of SLC_FRHOST_BIT0_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT0_INT_ENA_Pos = 0x0
	// Bit mask of SLC_FRHOST_BIT0_INT_ENA field.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT0_INT_ENA_Msk = 0x1
	// Bit SLC_FRHOST_BIT0_INT_ENA.
	SLC_SLC_INT_ENA_SLC_FRHOST_BIT0_INT_ENA = 0x1

	// SLC_INT_CLR: SLC_INT_CLR
	// Position of SLC_TX_DSCR_EMPTY_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_DSCR_EMPTY_INT_CLR_Pos = 0x15
	// Bit mask of SLC_TX_DSCR_EMPTY_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_DSCR_EMPTY_INT_CLR_Msk = 0x200000
	// Bit SLC_TX_DSCR_EMPTY_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TX_DSCR_EMPTY_INT_CLR = 0x200000
	// Position of SLC_RX_DSCR_ERR_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_DSCR_ERR_INT_CLR_Pos = 0x14
	// Bit mask of SLC_RX_DSCR_ERR_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_DSCR_ERR_INT_CLR_Msk = 0x100000
	// Bit SLC_RX_DSCR_ERR_INT_CLR.
	SLC_SLC_INT_CLR_SLC_RX_DSCR_ERR_INT_CLR = 0x100000
	// Position of SLC_TX_DSCR_ERR_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_DSCR_ERR_INT_CLR_Pos = 0x13
	// Bit mask of SLC_TX_DSCR_ERR_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_DSCR_ERR_INT_CLR_Msk = 0x80000
	// Bit SLC_TX_DSCR_ERR_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TX_DSCR_ERR_INT_CLR = 0x80000
	// Position of SLC_TOHOST_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TOHOST_INT_CLR_Pos = 0x12
	// Bit mask of SLC_TOHOST_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TOHOST_INT_CLR_Msk = 0x40000
	// Bit SLC_TOHOST_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TOHOST_INT_CLR = 0x40000
	// Position of SLC_RX_EOF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_EOF_INT_CLR_Pos = 0x11
	// Bit mask of SLC_RX_EOF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_EOF_INT_CLR_Msk = 0x20000
	// Bit SLC_RX_EOF_INT_CLR.
	SLC_SLC_INT_CLR_SLC_RX_EOF_INT_CLR = 0x20000
	// Position of SLC_RX_DONE_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_DONE_INT_CLR_Pos = 0x10
	// Bit mask of SLC_RX_DONE_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_DONE_INT_CLR_Msk = 0x10000
	// Bit SLC_RX_DONE_INT_CLR.
	SLC_SLC_INT_CLR_SLC_RX_DONE_INT_CLR = 0x10000
	// Position of SLC_TX_EOF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_EOF_INT_CLR_Pos = 0xf
	// Bit mask of SLC_TX_EOF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_EOF_INT_CLR_Msk = 0x8000
	// Bit SLC_TX_EOF_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TX_EOF_INT_CLR = 0x8000
	// Position of SLC_TX_DONE_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_DONE_INT_CLR_Pos = 0xe
	// Bit mask of SLC_TX_DONE_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_DONE_INT_CLR_Msk = 0x4000
	// Bit SLC_TX_DONE_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TX_DONE_INT_CLR = 0x4000
	// Position of SLC_TOKEN1_1TO0_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TOKEN1_1TO0_INT_CLR_Pos = 0xd
	// Bit mask of SLC_TOKEN1_1TO0_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TOKEN1_1TO0_INT_CLR_Msk = 0x2000
	// Bit SLC_TOKEN1_1TO0_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TOKEN1_1TO0_INT_CLR = 0x2000
	// Position of SLC_TOKEN0_1TO0_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TOKEN0_1TO0_INT_CLR_Pos = 0xc
	// Bit mask of SLC_TOKEN0_1TO0_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TOKEN0_1TO0_INT_CLR_Msk = 0x1000
	// Bit SLC_TOKEN0_1TO0_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TOKEN0_1TO0_INT_CLR = 0x1000
	// Position of SLC_TX_OVF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_OVF_INT_CLR_Pos = 0xb
	// Bit mask of SLC_TX_OVF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_OVF_INT_CLR_Msk = 0x800
	// Bit SLC_TX_OVF_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TX_OVF_INT_CLR = 0x800
	// Position of SLC_RX_UDF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_UDF_INT_CLR_Pos = 0xa
	// Bit mask of SLC_RX_UDF_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_UDF_INT_CLR_Msk = 0x400
	// Bit SLC_RX_UDF_INT_CLR.
	SLC_SLC_INT_CLR_SLC_RX_UDF_INT_CLR = 0x400
	// Position of SLC_TX_START_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_START_INT_CLR_Pos = 0x9
	// Bit mask of SLC_TX_START_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_TX_START_INT_CLR_Msk = 0x200
	// Bit SLC_TX_START_INT_CLR.
	SLC_SLC_INT_CLR_SLC_TX_START_INT_CLR = 0x200
	// Position of SLC_RX_START_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_START_INT_CLR_Pos = 0x8
	// Bit mask of SLC_RX_START_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_RX_START_INT_CLR_Msk = 0x100
	// Bit SLC_RX_START_INT_CLR.
	SLC_SLC_INT_CLR_SLC_RX_START_INT_CLR = 0x100
	// Position of SLC_FRHOST_BIT7_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT7_INT_CLR_Pos = 0x7
	// Bit mask of SLC_FRHOST_BIT7_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT7_INT_CLR_Msk = 0x80
	// Bit SLC_FRHOST_BIT7_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT7_INT_CLR = 0x80
	// Position of SLC_FRHOST_BIT6_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT6_INT_CLR_Pos = 0x6
	// Bit mask of SLC_FRHOST_BIT6_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT6_INT_CLR_Msk = 0x40
	// Bit SLC_FRHOST_BIT6_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT6_INT_CLR = 0x40
	// Position of SLC_FRHOST_BIT5_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT5_INT_CLR_Pos = 0x5
	// Bit mask of SLC_FRHOST_BIT5_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT5_INT_CLR_Msk = 0x20
	// Bit SLC_FRHOST_BIT5_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT5_INT_CLR = 0x20
	// Position of SLC_FRHOST_BIT4_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT4_INT_CLR_Pos = 0x4
	// Bit mask of SLC_FRHOST_BIT4_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT4_INT_CLR_Msk = 0x10
	// Bit SLC_FRHOST_BIT4_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT4_INT_CLR = 0x10
	// Position of SLC_FRHOST_BIT3_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT3_INT_CLR_Pos = 0x3
	// Bit mask of SLC_FRHOST_BIT3_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT3_INT_CLR_Msk = 0x8
	// Bit SLC_FRHOST_BIT3_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT3_INT_CLR = 0x8
	// Position of SLC_FRHOST_BIT2_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT2_INT_CLR_Pos = 0x2
	// Bit mask of SLC_FRHOST_BIT2_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT2_INT_CLR_Msk = 0x4
	// Bit SLC_FRHOST_BIT2_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT2_INT_CLR = 0x4
	// Position of SLC_FRHOST_BIT1_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT1_INT_CLR_Pos = 0x1
	// Bit mask of SLC_FRHOST_BIT1_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT1_INT_CLR_Msk = 0x2
	// Bit SLC_FRHOST_BIT1_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT1_INT_CLR = 0x2
	// Position of SLC_FRHOST_BIT0_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT0_INT_CLR_Pos = 0x0
	// Bit mask of SLC_FRHOST_BIT0_INT_CLR field.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT0_INT_CLR_Msk = 0x1
	// Bit SLC_FRHOST_BIT0_INT_CLR.
	SLC_SLC_INT_CLR_SLC_FRHOST_BIT0_INT_CLR = 0x1

	// SLC_RX_STATUS: SLC_RX_STATUS
	// Position of SLC_RX_EMPTY field.
	SLC_SLC_RX_STATUS_SLC_RX_EMPTY_Pos = 0x1
	// Bit mask of SLC_RX_EMPTY field.
	SLC_SLC_RX_STATUS_SLC_RX_EMPTY_Msk = 0x2
	// Bit SLC_RX_EMPTY.
	SLC_SLC_RX_STATUS_SLC_RX_EMPTY = 0x2
	// Position of SLC_RX_FULL field.
	SLC_SLC_RX_STATUS_SLC_RX_FULL_Pos = 0x0
	// Bit mask of SLC_RX_FULL field.
	SLC_SLC_RX_STATUS_SLC_RX_FULL_Msk = 0x1
	// Bit SLC_RX_FULL.
	SLC_SLC_RX_STATUS_SLC_RX_FULL = 0x1

	// SLC_RX_FIFO_PUSH: SLC_RX_FIFO_PUSH
	// Position of SLC_RXFIFO_PUSH field.
	SLC_SLC_RX_FIFO_PUSH_SLC_RXFIFO_PUSH_Pos = 0x10
	// Bit mask of SLC_RXFIFO_PUSH field.
	SLC_SLC_RX_FIFO_PUSH_SLC_RXFIFO_PUSH_Msk = 0x10000
	// Bit SLC_RXFIFO_PUSH.
	SLC_SLC_RX_FIFO_PUSH_SLC_RXFIFO_PUSH = 0x10000
	// Position of SLC_RXFIFO_WDATA field.
	SLC_SLC_RX_FIFO_PUSH_SLC_RXFIFO_WDATA_Pos = 0x0
	// Bit mask of SLC_RXFIFO_WDATA field.
	SLC_SLC_RX_FIFO_PUSH_SLC_RXFIFO_WDATA_Msk = 0x1ff

	// SLC_TX_STATUS: SLC_TX_STATUS
	// Position of SLC_TX_EMPTY field.
	SLC_SLC_TX_STATUS_SLC_TX_EMPTY_Pos = 0x1
	// Bit mask of SLC_TX_EMPTY field.
	SLC_SLC_TX_STATUS_SLC_TX_EMPTY_Msk = 0x2
	// Bit SLC_TX_EMPTY.
	SLC_SLC_TX_STATUS_SLC_TX_EMPTY = 0x2
	// Position of SLC_TX_FULL field.
	SLC_SLC_TX_STATUS_SLC_TX_FULL_Pos = 0x0
	// Bit mask of SLC_TX_FULL field.
	SLC_SLC_TX_STATUS_SLC_TX_FULL_Msk = 0x1
	// Bit SLC_TX_FULL.
	SLC_SLC_TX_STATUS_SLC_TX_FULL = 0x1

	// SLC_TX_FIFO_POP: SLC_TX_FIFO_POP
	// Position of SLC_TXFIFO_POP field.
	SLC_SLC_TX_FIFO_POP_SLC_TXFIFO_POP_Pos = 0x10
	// Bit mask of SLC_TXFIFO_POP field.
	SLC_SLC_TX_FIFO_POP_SLC_TXFIFO_POP_Msk = 0x10000
	// Bit SLC_TXFIFO_POP.
	SLC_SLC_TX_FIFO_POP_SLC_TXFIFO_POP = 0x10000
	// Position of SLC_TXFIFO_RDATA field.
	SLC_SLC_TX_FIFO_POP_SLC_TXFIFO_RDATA_Pos = 0x0
	// Bit mask of SLC_TXFIFO_RDATA field.
	SLC_SLC_TX_FIFO_POP_SLC_TXFIFO_RDATA_Msk = 0x7ff

	// SLC_RX_LINK: SLC_RX_LINK
	// Position of SLC_RXLINK_PARK field.
	SLC_SLC_RX_LINK_SLC_RXLINK_PARK_Pos = 0x1f
	// Bit mask of SLC_RXLINK_PARK field.
	SLC_SLC_RX_LINK_SLC_RXLINK_PARK_Msk = 0x80000000
	// Bit SLC_RXLINK_PARK.
	SLC_SLC_RX_LINK_SLC_RXLINK_PARK = 0x80000000
	// Position of SLC_RXLINK_RESTART field.
	SLC_SLC_RX_LINK_SLC_RXLINK_RESTART_Pos = 0x1e
	// Bit mask of SLC_RXLINK_RESTART field.
	SLC_SLC_RX_LINK_SLC_RXLINK_RESTART_Msk = 0x40000000
	// Bit SLC_RXLINK_RESTART.
	SLC_SLC_RX_LINK_SLC_RXLINK_RESTART = 0x40000000
	// Position of SLC_RXLINK_START field.
	SLC_SLC_RX_LINK_SLC_RXLINK_START_Pos = 0x1d
	// Bit mask of SLC_RXLINK_START field.
	SLC_SLC_RX_LINK_SLC_RXLINK_START_Msk = 0x20000000
	// Bit SLC_RXLINK_START.
	SLC_SLC_RX_LINK_SLC_RXLINK_START = 0x20000000
	// Position of SLC_RXLINK_STOP field.
	SLC_SLC_RX_LINK_SLC_RXLINK_STOP_Pos = 0x1c
	// Bit mask of SLC_RXLINK_STOP field.
	SLC_SLC_RX_LINK_SLC_RXLINK_STOP_Msk = 0x10000000
	// Bit SLC_RXLINK_STOP.
	SLC_SLC_RX_LINK_SLC_RXLINK_STOP = 0x10000000
	// Position of SLC_RXLINK_ADDR field.
	SLC_SLC_RX_LINK_SLC_RXLINK_ADDR_Pos = 0x0
	// Bit mask of SLC_RXLINK_ADDR field.
	SLC_SLC_RX_LINK_SLC_RXLINK_ADDR_Msk = 0xfffff

	// SLC_TX_LINK: SLC_TX_LINK
	// Position of SLC_TXLINK_PARK field.
	SLC_SLC_TX_LINK_SLC_TXLINK_PARK_Pos = 0x1f
	// Bit mask of SLC_TXLINK_PARK field.
	SLC_SLC_TX_LINK_SLC_TXLINK_PARK_Msk = 0x80000000
	// Bit SLC_TXLINK_PARK.
	SLC_SLC_TX_LINK_SLC_TXLINK_PARK = 0x80000000
	// Position of SLC_TXLINK_RESTART field.
	SLC_SLC_TX_LINK_SLC_TXLINK_RESTART_Pos = 0x1e
	// Bit mask of SLC_TXLINK_RESTART field.
	SLC_SLC_TX_LINK_SLC_TXLINK_RESTART_Msk = 0x40000000
	// Bit SLC_TXLINK_RESTART.
	SLC_SLC_TX_LINK_SLC_TXLINK_RESTART = 0x40000000
	// Position of SLC_TXLINK_START field.
	SLC_SLC_TX_LINK_SLC_TXLINK_START_Pos = 0x1d
	// Bit mask of SLC_TXLINK_START field.
	SLC_SLC_TX_LINK_SLC_TXLINK_START_Msk = 0x20000000
	// Bit SLC_TXLINK_START.
	SLC_SLC_TX_LINK_SLC_TXLINK_START = 0x20000000
	// Position of SLC_TXLINK_STOP field.
	SLC_SLC_TX_LINK_SLC_TXLINK_STOP_Pos = 0x1c
	// Bit mask of SLC_TXLINK_STOP field.
	SLC_SLC_TX_LINK_SLC_TXLINK_STOP_Msk = 0x10000000
	// Bit SLC_TXLINK_STOP.
	SLC_SLC_TX_LINK_SLC_TXLINK_STOP = 0x10000000
	// Position of SLC_TXLINK_ADDR field.
	SLC_SLC_TX_LINK_SLC_TXLINK_ADDR_Pos = 0x0
	// Bit mask of SLC_TXLINK_ADDR field.
	SLC_SLC_TX_LINK_SLC_TXLINK_ADDR_Msk = 0xfffff

	// SLC_INTVEC_TOHOST: SLC_INTVEC_TOHOST
	// Position of SLC_TOHOST_INTVEC field.
	SLC_SLC_INTVEC_TOHOST_SLC_TOHOST_INTVEC_Pos = 0x0
	// Bit mask of SLC_TOHOST_INTVEC field.
	SLC_SLC_INTVEC_TOHOST_SLC_TOHOST_INTVEC_Msk = 0xff

	// SLC_TOKEN0: SLC_TOKEN0
	// Position of SLC_TOKEN0 field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_Pos = 0x10
	// Bit mask of SLC_TOKEN0 field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_Msk = 0xfff0000
	// Position of SLC_TOKEN0_LOCAL_INC_MORE field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_MORE_Pos = 0xe
	// Bit mask of SLC_TOKEN0_LOCAL_INC_MORE field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_MORE_Msk = 0x4000
	// Bit SLC_TOKEN0_LOCAL_INC_MORE.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_MORE = 0x4000
	// Position of SLC_TOKEN0_LOCAL_INC field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_Pos = 0xd
	// Bit mask of SLC_TOKEN0_LOCAL_INC field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_INC_Msk = 0x2000
	// Bit SLC_TOKEN0_LOCAL_INC.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_INC = 0x2000
	// Position of SLC_TOKEN0_LOCAL_WR field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_WR_Pos = 0xc
	// Bit mask of SLC_TOKEN0_LOCAL_WR field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_WR_Msk = 0x1000
	// Bit SLC_TOKEN0_LOCAL_WR.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_WR = 0x1000
	// Position of SLC_TOKEN0_LOCAL_WDATA field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_WDATA_Pos = 0x0
	// Bit mask of SLC_TOKEN0_LOCAL_WDATA field.
	SLC_SLC_TOKEN0_SLC_TOKEN0_LOCAL_WDATA_Msk = 0xfff

	// SLC_TOKEN1: SLC_TOKEN1
	// Position of SLC_TOKEN1 field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_Pos = 0x10
	// Bit mask of SLC_TOKEN1 field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_Msk = 0xfff0000
	// Position of SLC_TOKEN1_LOCAL_INC_MORE field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_MORE_Pos = 0xe
	// Bit mask of SLC_TOKEN1_LOCAL_INC_MORE field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_MORE_Msk = 0x4000
	// Bit SLC_TOKEN1_LOCAL_INC_MORE.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_MORE = 0x4000
	// Position of SLC_TOKEN1_LOCAL_INC field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_Pos = 0xd
	// Bit mask of SLC_TOKEN1_LOCAL_INC field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_INC_Msk = 0x2000
	// Bit SLC_TOKEN1_LOCAL_INC.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_INC = 0x2000
	// Position of SLC_TOKEN1_LOCAL_WR field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_WR_Pos = 0xc
	// Bit mask of SLC_TOKEN1_LOCAL_WR field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_WR_Msk = 0x1000
	// Bit SLC_TOKEN1_LOCAL_WR.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_WR = 0x1000
	// Position of SLC_TOKEN1_LOCAL_WDATA field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_WDATA_Pos = 0x0
	// Bit mask of SLC_TOKEN1_LOCAL_WDATA field.
	SLC_SLC_TOKEN1_SLC_TOKEN1_LOCAL_WDATA_Msk = 0xfff

	// SLC_CONF1: SLC_CONF1
	// Position of Register field.
	SLC_SLC_CONF1_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_CONF1_Register_Msk = 0xffffffff

	// SLC_STATE0: SLC_STATE0
	// Position of Register field.
	SLC_SLC_STATE0_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_STATE0_Register_Msk = 0xffffffff

	// SLC_STATE1: SLC_STATE1
	// Position of Register field.
	SLC_SLC_STATE1_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_STATE1_Register_Msk = 0xffffffff

	// SLC_BRIDGE_CONF: SLC_BRIDGE_CONF
	// Position of SLC_TX_PUSH_IDLE_NUM field.
	SLC_SLC_BRIDGE_CONF_SLC_TX_PUSH_IDLE_NUM_Pos = 0x10
	// Bit mask of SLC_TX_PUSH_IDLE_NUM field.
	SLC_SLC_BRIDGE_CONF_SLC_TX_PUSH_IDLE_NUM_Msk = 0xffff0000
	// Position of SLC_TX_DUMMY_MODE field.
	SLC_SLC_BRIDGE_CONF_SLC_TX_DUMMY_MODE_Pos = 0xc
	// Bit mask of SLC_TX_DUMMY_MODE field.
	SLC_SLC_BRIDGE_CONF_SLC_TX_DUMMY_MODE_Msk = 0x1000
	// Bit SLC_TX_DUMMY_MODE.
	SLC_SLC_BRIDGE_CONF_SLC_TX_DUMMY_MODE = 0x1000
	// Position of SLC_FIFO_MAP_ENA field.
	SLC_SLC_BRIDGE_CONF_SLC_FIFO_MAP_ENA_Pos = 0x8
	// Bit mask of SLC_FIFO_MAP_ENA field.
	SLC_SLC_BRIDGE_CONF_SLC_FIFO_MAP_ENA_Msk = 0xf00
	// Position of SLC_TXEOF_ENA field.
	SLC_SLC_BRIDGE_CONF_SLC_TXEOF_ENA_Pos = 0x0
	// Bit mask of SLC_TXEOF_ENA field.
	SLC_SLC_BRIDGE_CONF_SLC_TXEOF_ENA_Msk = 0x3f

	// SLC_RX_EOF_DES_ADDR: SLC_RX_EOF_DES_ADDR
	// Position of Register field.
	SLC_SLC_RX_EOF_DES_ADDR_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_RX_EOF_DES_ADDR_Register_Msk = 0xffffffff

	// SLC_TX_EOF_DES_ADDR: SLC_TX_EOF_DES_ADDR
	// Position of Register field.
	SLC_SLC_TX_EOF_DES_ADDR_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_TX_EOF_DES_ADDR_Register_Msk = 0xffffffff

	// SLC_RX_EOF_BFR_DES_ADDR: SLC_RX_EOF_BFR_DES_ADDR
	// Position of Register field.
	SLC_SLC_RX_EOF_BFR_DES_ADDR_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_RX_EOF_BFR_DES_ADDR_Register_Msk = 0xffffffff

	// SLC_AHB_TEST: SLC_AHB_TEST
	// Position of SLC_AHB_TESTADDR field.
	SLC_SLC_AHB_TEST_SLC_AHB_TESTADDR_Pos = 0x4
	// Bit mask of SLC_AHB_TESTADDR field.
	SLC_SLC_AHB_TEST_SLC_AHB_TESTADDR_Msk = 0x30
	// Position of SLC_AHB_TESTMODE field.
	SLC_SLC_AHB_TEST_SLC_AHB_TESTMODE_Pos = 0x0
	// Bit mask of SLC_AHB_TESTMODE field.
	SLC_SLC_AHB_TEST_SLC_AHB_TESTMODE_Msk = 0x7

	// SLC_SDIO_ST: SLC_SDIO_ST
	// Position of SLC_BUS_ST field.
	SLC_SLC_SDIO_ST_SLC_BUS_ST_Pos = 0xc
	// Bit mask of SLC_BUS_ST field.
	SLC_SLC_SDIO_ST_SLC_BUS_ST_Msk = 0x7000
	// Position of SLC_SDIO_WAKEUP field.
	SLC_SLC_SDIO_ST_SLC_SDIO_WAKEUP_Pos = 0x8
	// Bit mask of SLC_SDIO_WAKEUP field.
	SLC_SLC_SDIO_ST_SLC_SDIO_WAKEUP_Msk = 0x100
	// Bit SLC_SDIO_WAKEUP.
	SLC_SLC_SDIO_ST_SLC_SDIO_WAKEUP = 0x100
	// Position of SLC_FUNC_ST field.
	SLC_SLC_SDIO_ST_SLC_FUNC_ST_Pos = 0x4
	// Bit mask of SLC_FUNC_ST field.
	SLC_SLC_SDIO_ST_SLC_FUNC_ST_Msk = 0xf0
	// Position of SLC_CMD_ST field.
	SLC_SLC_SDIO_ST_SLC_CMD_ST_Pos = 0x0
	// Bit mask of SLC_CMD_ST field.
	SLC_SLC_SDIO_ST_SLC_CMD_ST_Msk = 0x7

	// SLC_RX_DSCR_CONF: SLC_RX_DSCR_CONF
	// Position of SLC_INFOR_NO_REPLACE field.
	SLC_SLC_RX_DSCR_CONF_SLC_INFOR_NO_REPLACE_Pos = 0x9
	// Bit mask of SLC_INFOR_NO_REPLACE field.
	SLC_SLC_RX_DSCR_CONF_SLC_INFOR_NO_REPLACE_Msk = 0x200
	// Bit SLC_INFOR_NO_REPLACE.
	SLC_SLC_RX_DSCR_CONF_SLC_INFOR_NO_REPLACE = 0x200
	// Position of SLC_TOKEN_NO_REPLACE field.
	SLC_SLC_RX_DSCR_CONF_SLC_TOKEN_NO_REPLACE_Pos = 0x8
	// Bit mask of SLC_TOKEN_NO_REPLACE field.
	SLC_SLC_RX_DSCR_CONF_SLC_TOKEN_NO_REPLACE_Msk = 0x100
	// Bit SLC_TOKEN_NO_REPLACE.
	SLC_SLC_RX_DSCR_CONF_SLC_TOKEN_NO_REPLACE = 0x100

	// SLC_TXLINK_DSCR: SLC_TXLINK_DSCR
	// Position of Register field.
	SLC_SLC_TXLINK_DSCR_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_TXLINK_DSCR_Register_Msk = 0xffffffff

	// SLC_TXLINK_DSCR_BF0: SLC_TXLINK_DSCR_BF0
	// Position of Register field.
	SLC_SLC_TXLINK_DSCR_BF0_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_TXLINK_DSCR_BF0_Register_Msk = 0xffffffff

	// SLC_TXLINK_DSCR_BF1: SLC_TXLINK_DSCR_BF1
	// Position of Register field.
	SLC_SLC_TXLINK_DSCR_BF1_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_TXLINK_DSCR_BF1_Register_Msk = 0xffffffff

	// SLC_RXLINK_DSCR: SLC_RXLINK_DSCR
	// Position of Register field.
	SLC_SLC_RXLINK_DSCR_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_RXLINK_DSCR_Register_Msk = 0xffffffff

	// SLC_RXLINK_DSCR_BF0: SLC_RXLINK_DSCR_BF0
	// Position of Register field.
	SLC_SLC_RXLINK_DSCR_BF0_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_RXLINK_DSCR_BF0_Register_Msk = 0xffffffff

	// SLC_RXLINK_DSCR_BF1: SLC_RXLINK_DSCR_BF1
	// Position of Register field.
	SLC_SLC_RXLINK_DSCR_BF1_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_RXLINK_DSCR_BF1_Register_Msk = 0xffffffff

	// SLC_DATE: SLC_DATE
	// Position of Register field.
	SLC_SLC_DATE_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_DATE_Register_Msk = 0xffffffff

	// SLC_ID: SLC_ID
	// Position of Register field.
	SLC_SLC_ID_Register_Pos = 0x0
	// Bit mask of Register field.
	SLC_SLC_ID_Register_Msk = 0xffffffff
)

// Constants for SPI0
const (
	// SPI_CMD: In the master mode, it is the start bit of a single operation. Self-clear by hardware
	// Position of SPI_USR field.
	SPI0_SPI_CMD_SPI_USR_Pos = 0x12
	// Bit mask of SPI_USR field.
	SPI0_SPI_CMD_SPI_USR_Msk = 0x40000
	// Bit SPI_USR.
	SPI0_SPI_CMD_SPI_USR = 0x40000
	// Position of SPI_READ field.
	SPI0_SPI_CMD_SPI_READ_Pos = 0x1f
	// Bit mask of SPI_READ field.
	SPI0_SPI_CMD_SPI_READ_Msk = 0x80000000
	// Bit SPI_READ.
	SPI0_SPI_CMD_SPI_READ = 0x80000000
	// Position of SPI_WRITE_ENABLE field.
	SPI0_SPI_CMD_SPI_WRITE_ENABLE_Pos = 0x1e
	// Bit mask of SPI_WRITE_ENABLE field.
	SPI0_SPI_CMD_SPI_WRITE_ENABLE_Msk = 0x40000000
	// Bit SPI_WRITE_ENABLE.
	SPI0_SPI_CMD_SPI_WRITE_ENABLE = 0x40000000
	// Position of SPI_WRITE_DISABLE field.
	SPI0_SPI_CMD_SPI_WRITE_DISABLE_Pos = 0x1d
	// Bit mask of SPI_WRITE_DISABLE field.
	SPI0_SPI_CMD_SPI_WRITE_DISABLE_Msk = 0x20000000
	// Bit SPI_WRITE_DISABLE.
	SPI0_SPI_CMD_SPI_WRITE_DISABLE = 0x20000000
	// Position of SPI_READ_ID field.
	SPI0_SPI_CMD_SPI_READ_ID_Pos = 0x1c
	// Bit mask of SPI_READ_ID field.
	SPI0_SPI_CMD_SPI_READ_ID_Msk = 0x10000000
	// Bit SPI_READ_ID.
	SPI0_SPI_CMD_SPI_READ_ID = 0x10000000
	// Position of SPI_READ_SR field.
	SPI0_SPI_CMD_SPI_READ_SR_Pos = 0x1b
	// Bit mask of SPI_READ_SR field.
	SPI0_SPI_CMD_SPI_READ_SR_Msk = 0x8000000
	// Bit SPI_READ_SR.
	SPI0_SPI_CMD_SPI_READ_SR = 0x8000000
	// Position of SPI_WRITE_SR field.
	SPI0_SPI_CMD_SPI_WRITE_SR_Pos = 0x1a
	// Bit mask of SPI_WRITE_SR field.
	SPI0_SPI_CMD_SPI_WRITE_SR_Msk = 0x4000000
	// Bit SPI_WRITE_SR.
	SPI0_SPI_CMD_SPI_WRITE_SR = 0x4000000
	// Position of SPI_PP field.
	SPI0_SPI_CMD_SPI_PP_Pos = 0x19
	// Bit mask of SPI_PP field.
	SPI0_SPI_CMD_SPI_PP_Msk = 0x2000000
	// Bit SPI_PP.
	SPI0_SPI_CMD_SPI_PP = 0x2000000
	// Position of SPI_SE field.
	SPI0_SPI_CMD_SPI_SE_Pos = 0x18
	// Bit mask of SPI_SE field.
	SPI0_SPI_CMD_SPI_SE_Msk = 0x1000000
	// Bit SPI_SE.
	SPI0_SPI_CMD_SPI_SE = 0x1000000
	// Position of SPI_BE field.
	SPI0_SPI_CMD_SPI_BE_Pos = 0x17
	// Bit mask of SPI_BE field.
	SPI0_SPI_CMD_SPI_BE_Msk = 0x800000
	// Bit SPI_BE.
	SPI0_SPI_CMD_SPI_BE = 0x800000
	// Position of SPI_CE field.
	SPI0_SPI_CMD_SPI_CE_Pos = 0x16
	// Bit mask of SPI_CE field.
	SPI0_SPI_CMD_SPI_CE_Msk = 0x400000
	// Bit SPI_CE.
	SPI0_SPI_CMD_SPI_CE = 0x400000
	// Position of SPI_DP field.
	SPI0_SPI_CMD_SPI_DP_Pos = 0x15
	// Bit mask of SPI_DP field.
	SPI0_SPI_CMD_SPI_DP_Msk = 0x200000
	// Bit SPI_DP.
	SPI0_SPI_CMD_SPI_DP = 0x200000
	// Position of SPI_RES field.
	SPI0_SPI_CMD_SPI_RES_Pos = 0x14
	// Bit mask of SPI_RES field.
	SPI0_SPI_CMD_SPI_RES_Msk = 0x100000
	// Bit SPI_RES.
	SPI0_SPI_CMD_SPI_RES = 0x100000
	// Position of SPI_HPM field.
	SPI0_SPI_CMD_SPI_HPM_Pos = 0x13
	// Bit mask of SPI_HPM field.
	SPI0_SPI_CMD_SPI_HPM_Msk = 0x80000
	// Bit SPI_HPM.
	SPI0_SPI_CMD_SPI_HPM = 0x80000

	// SPI_ADDR: In the master mode, it is the value of address in "address" phase.
	// Position of IODATA_START_ADDR field.
	SPI0_SPI_ADDR_IODATA_START_ADDR_Pos = 0x0
	// Bit mask of IODATA_START_ADDR field.
	SPI0_SPI_ADDR_IODATA_START_ADDR_Msk = 0xffffffff
	// Position of ADDRESS field.
	SPI0_SPI_ADDR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SPI0_SPI_ADDR_ADDRESS_Msk = 0xffffff
	// Position of SIZE field.
	SPI0_SPI_ADDR_SIZE_Pos = 0x18
	// Bit mask of SIZE field.
	SPI0_SPI_ADDR_SIZE_Msk = 0xff000000

	// SPI_CTRL: SPI_CTRL
	// Position of SPI_WR_BIT_ORDER field.
	SPI0_SPI_CTRL_SPI_WR_BIT_ORDER_Pos = 0x1a
	// Bit mask of SPI_WR_BIT_ORDER field.
	SPI0_SPI_CTRL_SPI_WR_BIT_ORDER_Msk = 0x4000000
	// Bit SPI_WR_BIT_ORDER.
	SPI0_SPI_CTRL_SPI_WR_BIT_ORDER = 0x4000000
	// Position of SPI_RD_BIT_ORDER field.
	SPI0_SPI_CTRL_SPI_RD_BIT_ORDER_Pos = 0x19
	// Bit mask of SPI_RD_BIT_ORDER field.
	SPI0_SPI_CTRL_SPI_RD_BIT_ORDER_Msk = 0x2000000
	// Bit SPI_RD_BIT_ORDER.
	SPI0_SPI_CTRL_SPI_RD_BIT_ORDER = 0x2000000
	// Position of SPI_QIO_MODE field.
	SPI0_SPI_CTRL_SPI_QIO_MODE_Pos = 0x18
	// Bit mask of SPI_QIO_MODE field.
	SPI0_SPI_CTRL_SPI_QIO_MODE_Msk = 0x1000000
	// Bit SPI_QIO_MODE.
	SPI0_SPI_CTRL_SPI_QIO_MODE = 0x1000000
	// Position of SPI_DIO_MODE field.
	SPI0_SPI_CTRL_SPI_DIO_MODE_Pos = 0x17
	// Bit mask of SPI_DIO_MODE field.
	SPI0_SPI_CTRL_SPI_DIO_MODE_Msk = 0x800000
	// Bit SPI_DIO_MODE.
	SPI0_SPI_CTRL_SPI_DIO_MODE = 0x800000
	// Position of SPI_QOUT_MODE field.
	SPI0_SPI_CTRL_SPI_QOUT_MODE_Pos = 0x14
	// Bit mask of SPI_QOUT_MODE field.
	SPI0_SPI_CTRL_SPI_QOUT_MODE_Msk = 0x100000
	// Bit SPI_QOUT_MODE.
	SPI0_SPI_CTRL_SPI_QOUT_MODE = 0x100000
	// Position of SPI_DOUT_MODE field.
	SPI0_SPI_CTRL_SPI_DOUT_MODE_Pos = 0xe
	// Bit mask of SPI_DOUT_MODE field.
	SPI0_SPI_CTRL_SPI_DOUT_MODE_Msk = 0x4000
	// Bit SPI_DOUT_MODE.
	SPI0_SPI_CTRL_SPI_DOUT_MODE = 0x4000
	// Position of SPI_FASTRD_MODE field.
	SPI0_SPI_CTRL_SPI_FASTRD_MODE_Pos = 0xd
	// Bit mask of SPI_FASTRD_MODE field.
	SPI0_SPI_CTRL_SPI_FASTRD_MODE_Msk = 0x2000
	// Bit SPI_FASTRD_MODE.
	SPI0_SPI_CTRL_SPI_FASTRD_MODE = 0x2000

	// SPI_CTRL1
	// Position of STATUS field.
	SPI0_SPI_CTRL1_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	SPI0_SPI_CTRL1_STATUS_Msk = 0xffff
	// Position of WB_MODE field.
	SPI0_SPI_CTRL1_WB_MODE_Pos = 0x10
	// Bit mask of WB_MODE field.
	SPI0_SPI_CTRL1_WB_MODE_Msk = 0xff0000
	// Position of STATUS_EXT field.
	SPI0_SPI_CTRL1_STATUS_EXT_Pos = 0x18
	// Bit mask of STATUS_EXT field.
	SPI0_SPI_CTRL1_STATUS_EXT_Msk = 0xff000000

	// SPI_RD_STATUS: In the slave mode, this register are the status register for the master to read out.
	// Position of SLV_RD_STATUS field.
	SPI0_SPI_RD_STATUS_SLV_RD_STATUS_Pos = 0x0
	// Bit mask of SLV_RD_STATUS field.
	SPI0_SPI_RD_STATUS_SLV_RD_STATUS_Msk = 0xffffffff

	// SPI_CTRL2: spi_cs signal is delayed by 80MHz clock cycles
	// Position of SPI_CS_DELAY_NUM field.
	SPI0_SPI_CTRL2_SPI_CS_DELAY_NUM_Pos = 0x1c
	// Bit mask of SPI_CS_DELAY_NUM field.
	SPI0_SPI_CTRL2_SPI_CS_DELAY_NUM_Msk = 0xf0000000
	// Position of SPI_CS_DELAY_MODE field.
	SPI0_SPI_CTRL2_SPI_CS_DELAY_MODE_Pos = 0x1a
	// Bit mask of SPI_CS_DELAY_MODE field.
	SPI0_SPI_CTRL2_SPI_CS_DELAY_MODE_Msk = 0xc000000
	// Position of SPI_MOSI_DELAY_NUM field.
	SPI0_SPI_CTRL2_SPI_MOSI_DELAY_NUM_Pos = 0x17
	// Bit mask of SPI_MOSI_DELAY_NUM field.
	SPI0_SPI_CTRL2_SPI_MOSI_DELAY_NUM_Msk = 0x3800000
	// Position of SPI_MOSI_DELAY_MODE field.
	SPI0_SPI_CTRL2_SPI_MOSI_DELAY_MODE_Pos = 0x15
	// Bit mask of SPI_MOSI_DELAY_MODE field.
	SPI0_SPI_CTRL2_SPI_MOSI_DELAY_MODE_Msk = 0x600000
	// Position of SPI_MISO_DELAY_NUM field.
	SPI0_SPI_CTRL2_SPI_MISO_DELAY_NUM_Pos = 0x12
	// Bit mask of SPI_MISO_DELAY_NUM field.
	SPI0_SPI_CTRL2_SPI_MISO_DELAY_NUM_Msk = 0x1c0000
	// Position of SPI_MISO_DELAY_MODE field.
	SPI0_SPI_CTRL2_SPI_MISO_DELAY_MODE_Pos = 0x10
	// Bit mask of SPI_MISO_DELAY_MODE field.
	SPI0_SPI_CTRL2_SPI_MISO_DELAY_MODE_Msk = 0x30000

	// SPI_CLOCK: In the master mode, 1: spi_clk is eqaul to 80MHz, 0: spi_clk is divided from 80 MHz clock.
	// Position of SPI_CLK_EQU_SYSCLK field.
	SPI0_SPI_CLOCK_SPI_CLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of SPI_CLK_EQU_SYSCLK field.
	SPI0_SPI_CLOCK_SPI_CLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit SPI_CLK_EQU_SYSCLK.
	SPI0_SPI_CLOCK_SPI_CLK_EQU_SYSCLK = 0x80000000
	// Position of SPI_CLKDIV_PRE field.
	SPI0_SPI_CLOCK_SPI_CLKDIV_PRE_Pos = 0x12
	// Bit mask of SPI_CLKDIV_PRE field.
	SPI0_SPI_CLOCK_SPI_CLKDIV_PRE_Msk = 0x7ffc0000
	// Position of SPI_CLKCNT_N field.
	SPI0_SPI_CLOCK_SPI_CLKCNT_N_Pos = 0xc
	// Bit mask of SPI_CLKCNT_N field.
	SPI0_SPI_CLOCK_SPI_CLKCNT_N_Msk = 0x3f000
	// Position of SPI_CLKCNT_H field.
	SPI0_SPI_CLOCK_SPI_CLKCNT_H_Pos = 0x6
	// Bit mask of SPI_CLKCNT_H field.
	SPI0_SPI_CLOCK_SPI_CLKCNT_H_Msk = 0xfc0
	// Position of SPI_CLKCNT_L field.
	SPI0_SPI_CLOCK_SPI_CLKCNT_L_Pos = 0x0
	// Bit mask of SPI_CLKCNT_L field.
	SPI0_SPI_CLOCK_SPI_CLKCNT_L_Msk = 0x3f

	// SPI_USER: This bit enable the "command" phase of an operation.
	// Position of SPI_USR_COMMAND field.
	SPI0_SPI_USER_SPI_USR_COMMAND_Pos = 0x1f
	// Bit mask of SPI_USR_COMMAND field.
	SPI0_SPI_USER_SPI_USR_COMMAND_Msk = 0x80000000
	// Bit SPI_USR_COMMAND.
	SPI0_SPI_USER_SPI_USR_COMMAND = 0x80000000
	// Position of SPI_USR_ADDR field.
	SPI0_SPI_USER_SPI_USR_ADDR_Pos = 0x1e
	// Bit mask of SPI_USR_ADDR field.
	SPI0_SPI_USER_SPI_USR_ADDR_Msk = 0x40000000
	// Bit SPI_USR_ADDR.
	SPI0_SPI_USER_SPI_USR_ADDR = 0x40000000
	// Position of SPI_USR_DUMMY field.
	SPI0_SPI_USER_SPI_USR_DUMMY_Pos = 0x1d
	// Bit mask of SPI_USR_DUMMY field.
	SPI0_SPI_USER_SPI_USR_DUMMY_Msk = 0x20000000
	// Bit SPI_USR_DUMMY.
	SPI0_SPI_USER_SPI_USR_DUMMY = 0x20000000
	// Position of SPI_USR_MISO field.
	SPI0_SPI_USER_SPI_USR_MISO_Pos = 0x1c
	// Bit mask of SPI_USR_MISO field.
	SPI0_SPI_USER_SPI_USR_MISO_Msk = 0x10000000
	// Bit SPI_USR_MISO.
	SPI0_SPI_USER_SPI_USR_MISO = 0x10000000
	// Position of SPI_USR_MOSI field.
	SPI0_SPI_USER_SPI_USR_MOSI_Pos = 0x1b
	// Bit mask of SPI_USR_MOSI field.
	SPI0_SPI_USER_SPI_USR_MOSI_Msk = 0x8000000
	// Bit SPI_USR_MOSI.
	SPI0_SPI_USER_SPI_USR_MOSI = 0x8000000
	// Position of REG_USR_MOSI_HIGHPART field.
	SPI0_SPI_USER_REG_USR_MOSI_HIGHPART_Pos = 0x19
	// Bit mask of REG_USR_MOSI_HIGHPART field.
	SPI0_SPI_USER_REG_USR_MOSI_HIGHPART_Msk = 0x2000000
	// Bit REG_USR_MOSI_HIGHPART.
	SPI0_SPI_USER_REG_USR_MOSI_HIGHPART = 0x2000000
	// Position of REG_USR_MISO_HIGHPART field.
	SPI0_SPI_USER_REG_USR_MISO_HIGHPART_Pos = 0x18
	// Bit mask of REG_USR_MISO_HIGHPART field.
	SPI0_SPI_USER_REG_USR_MISO_HIGHPART_Msk = 0x1000000
	// Bit REG_USR_MISO_HIGHPART.
	SPI0_SPI_USER_REG_USR_MISO_HIGHPART = 0x1000000
	// Position of SPI_SIO field.
	SPI0_SPI_USER_SPI_SIO_Pos = 0x10
	// Bit mask of SPI_SIO field.
	SPI0_SPI_USER_SPI_SIO_Msk = 0x10000
	// Bit SPI_SIO.
	SPI0_SPI_USER_SPI_SIO = 0x10000
	// Position of SPI_FWRITE_QIO field.
	SPI0_SPI_USER_SPI_FWRITE_QIO_Pos = 0xf
	// Bit mask of SPI_FWRITE_QIO field.
	SPI0_SPI_USER_SPI_FWRITE_QIO_Msk = 0x8000
	// Bit SPI_FWRITE_QIO.
	SPI0_SPI_USER_SPI_FWRITE_QIO = 0x8000
	// Position of SPI_FWRITE_DIO field.
	SPI0_SPI_USER_SPI_FWRITE_DIO_Pos = 0xe
	// Bit mask of SPI_FWRITE_DIO field.
	SPI0_SPI_USER_SPI_FWRITE_DIO_Msk = 0x4000
	// Bit SPI_FWRITE_DIO.
	SPI0_SPI_USER_SPI_FWRITE_DIO = 0x4000
	// Position of SPI_FWRITE_QUAD field.
	SPI0_SPI_USER_SPI_FWRITE_QUAD_Pos = 0xd
	// Bit mask of SPI_FWRITE_QUAD field.
	SPI0_SPI_USER_SPI_FWRITE_QUAD_Msk = 0x2000
	// Bit SPI_FWRITE_QUAD.
	SPI0_SPI_USER_SPI_FWRITE_QUAD = 0x2000
	// Position of SPI_FWRITE_DUAL field.
	SPI0_SPI_USER_SPI_FWRITE_DUAL_Pos = 0xc
	// Bit mask of SPI_FWRITE_DUAL field.
	SPI0_SPI_USER_SPI_FWRITE_DUAL_Msk = 0x1000
	// Bit SPI_FWRITE_DUAL.
	SPI0_SPI_USER_SPI_FWRITE_DUAL = 0x1000
	// Position of SPI_WR_BYTE_ORDER field.
	SPI0_SPI_USER_SPI_WR_BYTE_ORDER_Pos = 0xb
	// Bit mask of SPI_WR_BYTE_ORDER field.
	SPI0_SPI_USER_SPI_WR_BYTE_ORDER_Msk = 0x800
	// Bit SPI_WR_BYTE_ORDER.
	SPI0_SPI_USER_SPI_WR_BYTE_ORDER = 0x800
	// Position of SPI_RD_BYTE_ORDER field.
	SPI0_SPI_USER_SPI_RD_BYTE_ORDER_Pos = 0xa
	// Bit mask of SPI_RD_BYTE_ORDER field.
	SPI0_SPI_USER_SPI_RD_BYTE_ORDER_Msk = 0x400
	// Bit SPI_RD_BYTE_ORDER.
	SPI0_SPI_USER_SPI_RD_BYTE_ORDER = 0x400
	// Position of SPI_CK_I_EDGE field.
	SPI0_SPI_USER_SPI_CK_I_EDGE_Pos = 0x6
	// Bit mask of SPI_CK_I_EDGE field.
	SPI0_SPI_USER_SPI_CK_I_EDGE_Msk = 0x40
	// Bit SPI_CK_I_EDGE.
	SPI0_SPI_USER_SPI_CK_I_EDGE = 0x40
	// Position of SPI_CK_O_EDGE field.
	SPI0_SPI_USER_SPI_CK_O_EDGE_Pos = 0x7
	// Bit mask of SPI_CK_O_EDGE field.
	SPI0_SPI_USER_SPI_CK_O_EDGE_Msk = 0x80
	// Bit SPI_CK_O_EDGE.
	SPI0_SPI_USER_SPI_CK_O_EDGE = 0x80
	// Position of SPI_CS_SETUP field.
	SPI0_SPI_USER_SPI_CS_SETUP_Pos = 0x5
	// Bit mask of SPI_CS_SETUP field.
	SPI0_SPI_USER_SPI_CS_SETUP_Msk = 0x20
	// Bit SPI_CS_SETUP.
	SPI0_SPI_USER_SPI_CS_SETUP = 0x20
	// Position of SPI_CS_HOLD field.
	SPI0_SPI_USER_SPI_CS_HOLD_Pos = 0x4
	// Bit mask of SPI_CS_HOLD field.
	SPI0_SPI_USER_SPI_CS_HOLD_Msk = 0x10
	// Bit SPI_CS_HOLD.
	SPI0_SPI_USER_SPI_CS_HOLD = 0x10
	// Position of SPI_AHB_USER_COMMAND field.
	SPI0_SPI_USER_SPI_AHB_USER_COMMAND_Pos = 0x3
	// Bit mask of SPI_AHB_USER_COMMAND field.
	SPI0_SPI_USER_SPI_AHB_USER_COMMAND_Msk = 0x8
	// Bit SPI_AHB_USER_COMMAND.
	SPI0_SPI_USER_SPI_AHB_USER_COMMAND = 0x8
	// Position of SPI_FLASH_MODE field.
	SPI0_SPI_USER_SPI_FLASH_MODE_Pos = 0x2
	// Bit mask of SPI_FLASH_MODE field.
	SPI0_SPI_USER_SPI_FLASH_MODE_Msk = 0x4
	// Bit SPI_FLASH_MODE.
	SPI0_SPI_USER_SPI_FLASH_MODE = 0x4
	// Position of SPI_AHB_USER_COMMAND_4BYTE field.
	SPI0_SPI_USER_SPI_AHB_USER_COMMAND_4BYTE_Pos = 0x1
	// Bit mask of SPI_AHB_USER_COMMAND_4BYTE field.
	SPI0_SPI_USER_SPI_AHB_USER_COMMAND_4BYTE_Msk = 0x2
	// Bit SPI_AHB_USER_COMMAND_4BYTE.
	SPI0_SPI_USER_SPI_AHB_USER_COMMAND_4BYTE = 0x2
	// Position of SPI_DUPLEX field.
	SPI0_SPI_USER_SPI_DUPLEX_Pos = 0x0
	// Bit mask of SPI_DUPLEX field.
	SPI0_SPI_USER_SPI_DUPLEX_Msk = 0x1
	// Bit SPI_DUPLEX.
	SPI0_SPI_USER_SPI_DUPLEX = 0x1

	// SPI_USER1: The length in bits of "address" phase. The register value shall be (bit_num-1)
	// Position of REG_USR_ADDR_BITLEN field.
	SPI0_SPI_USER1_REG_USR_ADDR_BITLEN_Pos = 0x1a
	// Bit mask of REG_USR_ADDR_BITLEN field.
	SPI0_SPI_USER1_REG_USR_ADDR_BITLEN_Msk = 0xfc000000
	// Position of REG_USR_MOSI_BITLEN field.
	SPI0_SPI_USER1_REG_USR_MOSI_BITLEN_Pos = 0x11
	// Bit mask of REG_USR_MOSI_BITLEN field.
	SPI0_SPI_USER1_REG_USR_MOSI_BITLEN_Msk = 0x3fe0000
	// Position of REG_USR_MISO_BITLEN field.
	SPI0_SPI_USER1_REG_USR_MISO_BITLEN_Pos = 0x8
	// Bit mask of REG_USR_MISO_BITLEN field.
	SPI0_SPI_USER1_REG_USR_MISO_BITLEN_Msk = 0x1ff00
	// Position of REG_USR_DUMMY_CYCLELEN field.
	SPI0_SPI_USER1_REG_USR_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of REG_USR_DUMMY_CYCLELEN field.
	SPI0_SPI_USER1_REG_USR_DUMMY_CYCLELEN_Msk = 0xff

	// SPI_USER2: The length in bits of "command" phase. The register value shall be (bit_num-1)
	// Position of REG_USR_COMMAND_BITLEN field.
	SPI0_SPI_USER2_REG_USR_COMMAND_BITLEN_Pos = 0x1c
	// Bit mask of REG_USR_COMMAND_BITLEN field.
	SPI0_SPI_USER2_REG_USR_COMMAND_BITLEN_Msk = 0xf0000000
	// Position of REG_USR_COMMAND_VALUE field.
	SPI0_SPI_USER2_REG_USR_COMMAND_VALUE_Pos = 0x0
	// Bit mask of REG_USR_COMMAND_VALUE field.
	SPI0_SPI_USER2_REG_USR_COMMAND_VALUE_Msk = 0xffff

	// SPI_WR_STATUS: In the slave mode, this register are the status register for the master to write into.
	// Position of SLV_WR_STATUS field.
	SPI0_SPI_WR_STATUS_SLV_WR_STATUS_Pos = 0x0
	// Bit mask of SLV_WR_STATUS field.
	SPI0_SPI_WR_STATUS_SLV_WR_STATUS_Msk = 0xffffffff

	// SPI_PIN: 1: disable CS2; 0: spi_cs signal is from/to CS2 pin
	// Position of SPI_CS2_DIS field.
	SPI0_SPI_PIN_SPI_CS2_DIS_Pos = 0x2
	// Bit mask of SPI_CS2_DIS field.
	SPI0_SPI_PIN_SPI_CS2_DIS_Msk = 0x4
	// Bit SPI_CS2_DIS.
	SPI0_SPI_PIN_SPI_CS2_DIS = 0x4
	// Position of SPI_CS1_DIS field.
	SPI0_SPI_PIN_SPI_CS1_DIS_Pos = 0x1
	// Bit mask of SPI_CS1_DIS field.
	SPI0_SPI_PIN_SPI_CS1_DIS_Msk = 0x2
	// Bit SPI_CS1_DIS.
	SPI0_SPI_PIN_SPI_CS1_DIS = 0x2
	// Position of SPI_CS0_DIS field.
	SPI0_SPI_PIN_SPI_CS0_DIS_Pos = 0x0
	// Bit mask of SPI_CS0_DIS field.
	SPI0_SPI_PIN_SPI_CS0_DIS_Msk = 0x1
	// Bit SPI_CS0_DIS.
	SPI0_SPI_PIN_SPI_CS0_DIS = 0x1
	// Position of SPI_IDLE_EDGE field.
	SPI0_SPI_PIN_SPI_IDLE_EDGE_Pos = 0x1d
	// Bit mask of SPI_IDLE_EDGE field.
	SPI0_SPI_PIN_SPI_IDLE_EDGE_Msk = 0x20000000
	// Bit SPI_IDLE_EDGE.
	SPI0_SPI_PIN_SPI_IDLE_EDGE = 0x20000000

	// SPI_SLAVE: It is the synchronous reset signal of the module. This bit is self-cleared by hardware.
	// Position of SPI_SYNC_RESET field.
	SPI0_SPI_SLAVE_SPI_SYNC_RESET_Pos = 0x1f
	// Bit mask of SPI_SYNC_RESET field.
	SPI0_SPI_SLAVE_SPI_SYNC_RESET_Msk = 0x80000000
	// Bit SPI_SYNC_RESET.
	SPI0_SPI_SLAVE_SPI_SYNC_RESET = 0x80000000
	// Position of SPI_SLAVE_MODE field.
	SPI0_SPI_SLAVE_SPI_SLAVE_MODE_Pos = 0x1e
	// Bit mask of SPI_SLAVE_MODE field.
	SPI0_SPI_SLAVE_SPI_SLAVE_MODE_Msk = 0x40000000
	// Bit SPI_SLAVE_MODE.
	SPI0_SPI_SLAVE_SPI_SLAVE_MODE = 0x40000000
	// Position of SLV_CMD_DEFINE field.
	SPI0_SPI_SLAVE_SLV_CMD_DEFINE_Pos = 0x1b
	// Bit mask of SLV_CMD_DEFINE field.
	SPI0_SPI_SLAVE_SLV_CMD_DEFINE_Msk = 0x8000000
	// Bit SLV_CMD_DEFINE.
	SPI0_SPI_SLAVE_SLV_CMD_DEFINE = 0x8000000
	// Position of SPI_TRANS_CNT field.
	SPI0_SPI_SLAVE_SPI_TRANS_CNT_Pos = 0x17
	// Bit mask of SPI_TRANS_CNT field.
	SPI0_SPI_SLAVE_SPI_TRANS_CNT_Msk = 0x7800000
	// Position of SPI_INT_EN field.
	SPI0_SPI_SLAVE_SPI_INT_EN_Pos = 0x5
	// Bit mask of SPI_INT_EN field.
	SPI0_SPI_SLAVE_SPI_INT_EN_Msk = 0x3e0
	// Position of SPI_TRANS_DONE field.
	SPI0_SPI_SLAVE_SPI_TRANS_DONE_Pos = 0x4
	// Bit mask of SPI_TRANS_DONE field.
	SPI0_SPI_SLAVE_SPI_TRANS_DONE_Msk = 0x10
	// Bit SPI_TRANS_DONE.
	SPI0_SPI_SLAVE_SPI_TRANS_DONE = 0x10
	// Position of SLV_WR_STA_DONE field.
	SPI0_SPI_SLAVE_SLV_WR_STA_DONE_Pos = 0x3
	// Bit mask of SLV_WR_STA_DONE field.
	SPI0_SPI_SLAVE_SLV_WR_STA_DONE_Msk = 0x8
	// Bit SLV_WR_STA_DONE.
	SPI0_SPI_SLAVE_SLV_WR_STA_DONE = 0x8
	// Position of SLV_RD_STA_DONE field.
	SPI0_SPI_SLAVE_SLV_RD_STA_DONE_Pos = 0x2
	// Bit mask of SLV_RD_STA_DONE field.
	SPI0_SPI_SLAVE_SLV_RD_STA_DONE_Msk = 0x4
	// Bit SLV_RD_STA_DONE.
	SPI0_SPI_SLAVE_SLV_RD_STA_DONE = 0x4
	// Position of SLV_WR_BUF_DONE field.
	SPI0_SPI_SLAVE_SLV_WR_BUF_DONE_Pos = 0x1
	// Bit mask of SLV_WR_BUF_DONE field.
	SPI0_SPI_SLAVE_SLV_WR_BUF_DONE_Msk = 0x2
	// Bit SLV_WR_BUF_DONE.
	SPI0_SPI_SLAVE_SLV_WR_BUF_DONE = 0x2
	// Position of SLV_RD_BUF_DONE field.
	SPI0_SPI_SLAVE_SLV_RD_BUF_DONE_Pos = 0x0
	// Bit mask of SLV_RD_BUF_DONE field.
	SPI0_SPI_SLAVE_SLV_RD_BUF_DONE_Msk = 0x1
	// Bit SLV_RD_BUF_DONE.
	SPI0_SPI_SLAVE_SLV_RD_BUF_DONE = 0x1

	// SPI_SLAVE1: In the slave mode, it is the length in bits for "write-status" and "read-status" operations. The register valueshall be (bit_num-1)
	// Position of SLV_STATUS_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_STATUS_BITLEN_Pos = 0x1b
	// Bit mask of SLV_STATUS_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_STATUS_BITLEN_Msk = 0xf8000000
	// Position of SLV_BUF_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_BUF_BITLEN_Pos = 0x10
	// Bit mask of SLV_BUF_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_BUF_BITLEN_Msk = 0x1ff0000
	// Position of SLV_RD_ADDR_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_RD_ADDR_BITLEN_Pos = 0xa
	// Bit mask of SLV_RD_ADDR_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_RD_ADDR_BITLEN_Msk = 0xfc00
	// Position of SLV_WR_ADDR_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_WR_ADDR_BITLEN_Pos = 0x4
	// Bit mask of SLV_WR_ADDR_BITLEN field.
	SPI0_SPI_SLAVE1_SLV_WR_ADDR_BITLEN_Msk = 0x3f0
	// Position of SLV_WRSTA_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_WRSTA_DUMMY_EN_Pos = 0x3
	// Bit mask of SLV_WRSTA_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_WRSTA_DUMMY_EN_Msk = 0x8
	// Bit SLV_WRSTA_DUMMY_EN.
	SPI0_SPI_SLAVE1_SLV_WRSTA_DUMMY_EN = 0x8
	// Position of SLV_RDSTA_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_RDSTA_DUMMY_EN_Pos = 0x2
	// Bit mask of SLV_RDSTA_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_RDSTA_DUMMY_EN_Msk = 0x4
	// Bit SLV_RDSTA_DUMMY_EN.
	SPI0_SPI_SLAVE1_SLV_RDSTA_DUMMY_EN = 0x4
	// Position of SLV_WRBUF_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_WRBUF_DUMMY_EN_Pos = 0x1
	// Bit mask of SLV_WRBUF_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_WRBUF_DUMMY_EN_Msk = 0x2
	// Bit SLV_WRBUF_DUMMY_EN.
	SPI0_SPI_SLAVE1_SLV_WRBUF_DUMMY_EN = 0x2
	// Position of SLV_RDBUF_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_RDBUF_DUMMY_EN_Pos = 0x0
	// Bit mask of SLV_RDBUF_DUMMY_EN field.
	SPI0_SPI_SLAVE1_SLV_RDBUF_DUMMY_EN_Msk = 0x1
	// Bit SLV_RDBUF_DUMMY_EN.
	SPI0_SPI_SLAVE1_SLV_RDBUF_DUMMY_EN = 0x1

	// SPI_SLAVE2: In the slave mode, it is the length in spi_clk cycles "dummy" phase for "write-buffer" operations. The registervalue shall be (cycle_num-1)
	// Position of SLV_WRBUF_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN_Pos = 0x18
	// Bit mask of SLV_WRBUF_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN_Msk = 0xff000000
	// Position of SLV_RDBUF_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN_Pos = 0x10
	// Bit mask of SLV_RDBUF_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN_Msk = 0xff0000
	// Position of SLV_WRSTA_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN_Pos = 0x8
	// Bit mask of SLV_WRSTA_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN_Msk = 0xff00
	// Position of SLV_RDSTA_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of SLV_RDSTA_DUMMY_CYCLELEN field.
	SPI0_SPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN_Msk = 0xff

	// SPI_SLAVE3: In slave mode, it is the value of "write-status" command
	// Position of SLV_WRSTA_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_WRSTA_CMD_VALUE_Pos = 0x18
	// Bit mask of SLV_WRSTA_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_WRSTA_CMD_VALUE_Msk = 0xff000000
	// Position of SLV_RDSTA_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_RDSTA_CMD_VALUE_Pos = 0x10
	// Bit mask of SLV_RDSTA_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_RDSTA_CMD_VALUE_Msk = 0xff0000
	// Position of SLV_WRBUF_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_WRBUF_CMD_VALUE_Pos = 0x8
	// Bit mask of SLV_WRBUF_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_WRBUF_CMD_VALUE_Msk = 0xff00
	// Position of SLV_RDBUF_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_RDBUF_CMD_VALUE_Pos = 0x0
	// Bit mask of SLV_RDBUF_CMD_VALUE field.
	SPI0_SPI_SLAVE3_SLV_RDBUF_CMD_VALUE_Msk = 0xff

	// SPI_W0: the data inside the buffer of the SPI module, byte 0
	// Position of SPI_W0 field.
	SPI0_SPI_W0_SPI_W0_Pos = 0x0
	// Bit mask of SPI_W0 field.
	SPI0_SPI_W0_SPI_W0_Msk = 0xffffffff

	// SPI_W1: the data inside the buffer of the SPI module, byte 1
	// Position of SPI_W1 field.
	SPI0_SPI_W1_SPI_W1_Pos = 0x0
	// Bit mask of SPI_W1 field.
	SPI0_SPI_W1_SPI_W1_Msk = 0xffffffff

	// SPI_W2: the data inside the buffer of the SPI module, byte 2
	// Position of SPI_W2 field.
	SPI0_SPI_W2_SPI_W2_Pos = 0x0
	// Bit mask of SPI_W2 field.
	SPI0_SPI_W2_SPI_W2_Msk = 0xffffffff

	// SPI_W3: the data inside the buffer of the SPI module, byte 3
	// Position of SPI_W3 field.
	SPI0_SPI_W3_SPI_W3_Pos = 0x0
	// Bit mask of SPI_W3 field.
	SPI0_SPI_W3_SPI_W3_Msk = 0xffffffff

	// SPI_W4: the data inside the buffer of the SPI module, byte 4
	// Position of SPI_W4 field.
	SPI0_SPI_W4_SPI_W4_Pos = 0x0
	// Bit mask of SPI_W4 field.
	SPI0_SPI_W4_SPI_W4_Msk = 0xffffffff

	// SPI_W5: the data inside the buffer of the SPI module, byte 5
	// Position of SPI_W5 field.
	SPI0_SPI_W5_SPI_W5_Pos = 0x0
	// Bit mask of SPI_W5 field.
	SPI0_SPI_W5_SPI_W5_Msk = 0xffffffff

	// SPI_EXT3: This register is for two SPI masters to share the same cs, clock and data signals.
	// Position of REG_INT_HOLD_ENA field.
	SPI0_SPI_EXT3_REG_INT_HOLD_ENA_Pos = 0x0
	// Bit mask of REG_INT_HOLD_ENA field.
	SPI0_SPI_EXT3_REG_INT_HOLD_ENA_Msk = 0x3

	// SPI_W6: the data inside the buffer of the SPI module, byte 6
	// Position of SPI_W6 field.
	SPI0_SPI_W6_SPI_W6_Pos = 0x0
	// Bit mask of SPI_W6 field.
	SPI0_SPI_W6_SPI_W6_Msk = 0xffffffff

	// SPI_W7: the data inside the buffer of the SPI module, byte 7
	// Position of SPI_W7 field.
	SPI0_SPI_W7_SPI_W7_Pos = 0x0
	// Bit mask of SPI_W7 field.
	SPI0_SPI_W7_SPI_W7_Msk = 0xffffffff

	// SPI_W8: the data inside the buffer of the SPI module, byte 8
	// Position of SPI_W8 field.
	SPI0_SPI_W8_SPI_W8_Pos = 0x0
	// Bit mask of SPI_W8 field.
	SPI0_SPI_W8_SPI_W8_Msk = 0xffffffff

	// SPI_W9: the data inside the buffer of the SPI module, byte 9
	// Position of SPI_W9 field.
	SPI0_SPI_W9_SPI_W9_Pos = 0x0
	// Bit mask of SPI_W9 field.
	SPI0_SPI_W9_SPI_W9_Msk = 0xffffffff

	// SPI_W10: the data inside the buffer of the SPI module, byte 10
	// Position of SPI_W10 field.
	SPI0_SPI_W10_SPI_W10_Pos = 0x0
	// Bit mask of SPI_W10 field.
	SPI0_SPI_W10_SPI_W10_Msk = 0xffffffff

	// SPI_W11: the data inside the buffer of the SPI module, byte 11
	// Position of SPI_W11 field.
	SPI0_SPI_W11_SPI_W11_Pos = 0x0
	// Bit mask of SPI_W11 field.
	SPI0_SPI_W11_SPI_W11_Msk = 0xffffffff

	// SPI_W12: the data inside the buffer of the SPI module, byte 12
	// Position of SPI_W12 field.
	SPI0_SPI_W12_SPI_W12_Pos = 0x0
	// Bit mask of SPI_W12 field.
	SPI0_SPI_W12_SPI_W12_Msk = 0xffffffff

	// SPI_W13: the data inside the buffer of the SPI module, byte 13
	// Position of SPI_W13 field.
	SPI0_SPI_W13_SPI_W13_Pos = 0x0
	// Bit mask of SPI_W13 field.
	SPI0_SPI_W13_SPI_W13_Msk = 0xffffffff

	// SPI_W14: the data inside the buffer of the SPI module, byte 14
	// Position of SPI_W14 field.
	SPI0_SPI_W14_SPI_W14_Pos = 0x0
	// Bit mask of SPI_W14 field.
	SPI0_SPI_W14_SPI_W14_Msk = 0xffffffff

	// SPI_W15: the data inside the buffer of the SPI module, byte 15
	// Position of SPI_W15 field.
	SPI0_SPI_W15_SPI_W15_Pos = 0x0
	// Bit mask of SPI_W15 field.
	SPI0_SPI_W15_SPI_W15_Msk = 0xffffffff
)

// Constants for SPI1
const (
	// SPI_CMD: In the master mode, it is the start bit of a single operation. Self-clear by hardware
	// Position of SPI_USR field.
	SPI1_SPI_CMD_SPI_USR_Pos = 0x12
	// Bit mask of SPI_USR field.
	SPI1_SPI_CMD_SPI_USR_Msk = 0x40000
	// Bit SPI_USR.
	SPI1_SPI_CMD_SPI_USR = 0x40000
	// Position of SPI_READ field.
	SPI1_SPI_CMD_SPI_READ_Pos = 0x1f
	// Bit mask of SPI_READ field.
	SPI1_SPI_CMD_SPI_READ_Msk = 0x80000000
	// Bit SPI_READ.
	SPI1_SPI_CMD_SPI_READ = 0x80000000
	// Position of SPI_WRITE_ENABLE field.
	SPI1_SPI_CMD_SPI_WRITE_ENABLE_Pos = 0x1e
	// Bit mask of SPI_WRITE_ENABLE field.
	SPI1_SPI_CMD_SPI_WRITE_ENABLE_Msk = 0x40000000
	// Bit SPI_WRITE_ENABLE.
	SPI1_SPI_CMD_SPI_WRITE_ENABLE = 0x40000000
	// Position of SPI_WRITE_DISABLE field.
	SPI1_SPI_CMD_SPI_WRITE_DISABLE_Pos = 0x1d
	// Bit mask of SPI_WRITE_DISABLE field.
	SPI1_SPI_CMD_SPI_WRITE_DISABLE_Msk = 0x20000000
	// Bit SPI_WRITE_DISABLE.
	SPI1_SPI_CMD_SPI_WRITE_DISABLE = 0x20000000
	// Position of SPI_READ_ID field.
	SPI1_SPI_CMD_SPI_READ_ID_Pos = 0x1c
	// Bit mask of SPI_READ_ID field.
	SPI1_SPI_CMD_SPI_READ_ID_Msk = 0x10000000
	// Bit SPI_READ_ID.
	SPI1_SPI_CMD_SPI_READ_ID = 0x10000000
	// Position of SPI_READ_SR field.
	SPI1_SPI_CMD_SPI_READ_SR_Pos = 0x1b
	// Bit mask of SPI_READ_SR field.
	SPI1_SPI_CMD_SPI_READ_SR_Msk = 0x8000000
	// Bit SPI_READ_SR.
	SPI1_SPI_CMD_SPI_READ_SR = 0x8000000
	// Position of SPI_WRITE_SR field.
	SPI1_SPI_CMD_SPI_WRITE_SR_Pos = 0x1a
	// Bit mask of SPI_WRITE_SR field.
	SPI1_SPI_CMD_SPI_WRITE_SR_Msk = 0x4000000
	// Bit SPI_WRITE_SR.
	SPI1_SPI_CMD_SPI_WRITE_SR = 0x4000000
	// Position of SPI_PP field.
	SPI1_SPI_CMD_SPI_PP_Pos = 0x19
	// Bit mask of SPI_PP field.
	SPI1_SPI_CMD_SPI_PP_Msk = 0x2000000
	// Bit SPI_PP.
	SPI1_SPI_CMD_SPI_PP = 0x2000000
	// Position of SPI_SE field.
	SPI1_SPI_CMD_SPI_SE_Pos = 0x18
	// Bit mask of SPI_SE field.
	SPI1_SPI_CMD_SPI_SE_Msk = 0x1000000
	// Bit SPI_SE.
	SPI1_SPI_CMD_SPI_SE = 0x1000000
	// Position of SPI_BE field.
	SPI1_SPI_CMD_SPI_BE_Pos = 0x17
	// Bit mask of SPI_BE field.
	SPI1_SPI_CMD_SPI_BE_Msk = 0x800000
	// Bit SPI_BE.
	SPI1_SPI_CMD_SPI_BE = 0x800000
	// Position of SPI_CE field.
	SPI1_SPI_CMD_SPI_CE_Pos = 0x16
	// Bit mask of SPI_CE field.
	SPI1_SPI_CMD_SPI_CE_Msk = 0x400000
	// Bit SPI_CE.
	SPI1_SPI_CMD_SPI_CE = 0x400000
	// Position of SPI_DP field.
	SPI1_SPI_CMD_SPI_DP_Pos = 0x15
	// Bit mask of SPI_DP field.
	SPI1_SPI_CMD_SPI_DP_Msk = 0x200000
	// Bit SPI_DP.
	SPI1_SPI_CMD_SPI_DP = 0x200000
	// Position of SPI_RES field.
	SPI1_SPI_CMD_SPI_RES_Pos = 0x14
	// Bit mask of SPI_RES field.
	SPI1_SPI_CMD_SPI_RES_Msk = 0x100000
	// Bit SPI_RES.
	SPI1_SPI_CMD_SPI_RES = 0x100000
	// Position of SPI_HPM field.
	SPI1_SPI_CMD_SPI_HPM_Pos = 0x13
	// Bit mask of SPI_HPM field.
	SPI1_SPI_CMD_SPI_HPM_Msk = 0x80000
	// Bit SPI_HPM.
	SPI1_SPI_CMD_SPI_HPM = 0x80000

	// SPI_ADDR: In the master mode, it is the value of address in "address" phase.
	// Position of IODATA_START_ADDR field.
	SPI1_SPI_ADDR_IODATA_START_ADDR_Pos = 0x0
	// Bit mask of IODATA_START_ADDR field.
	SPI1_SPI_ADDR_IODATA_START_ADDR_Msk = 0xffffffff
	// Position of ADDRESS field.
	SPI1_SPI_ADDR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SPI1_SPI_ADDR_ADDRESS_Msk = 0xffffff
	// Position of SIZE field.
	SPI1_SPI_ADDR_SIZE_Pos = 0x18
	// Bit mask of SIZE field.
	SPI1_SPI_ADDR_SIZE_Msk = 0xff000000

	// SPI_CTRL: SPI_CTRL
	// Position of SPI_WR_BIT_ORDER field.
	SPI1_SPI_CTRL_SPI_WR_BIT_ORDER_Pos = 0x1a
	// Bit mask of SPI_WR_BIT_ORDER field.
	SPI1_SPI_CTRL_SPI_WR_BIT_ORDER_Msk = 0x4000000
	// Bit SPI_WR_BIT_ORDER.
	SPI1_SPI_CTRL_SPI_WR_BIT_ORDER = 0x4000000
	// Position of SPI_RD_BIT_ORDER field.
	SPI1_SPI_CTRL_SPI_RD_BIT_ORDER_Pos = 0x19
	// Bit mask of SPI_RD_BIT_ORDER field.
	SPI1_SPI_CTRL_SPI_RD_BIT_ORDER_Msk = 0x2000000
	// Bit SPI_RD_BIT_ORDER.
	SPI1_SPI_CTRL_SPI_RD_BIT_ORDER = 0x2000000
	// Position of SPI_QIO_MODE field.
	SPI1_SPI_CTRL_SPI_QIO_MODE_Pos = 0x18
	// Bit mask of SPI_QIO_MODE field.
	SPI1_SPI_CTRL_SPI_QIO_MODE_Msk = 0x1000000
	// Bit SPI_QIO_MODE.
	SPI1_SPI_CTRL_SPI_QIO_MODE = 0x1000000
	// Position of SPI_DIO_MODE field.
	SPI1_SPI_CTRL_SPI_DIO_MODE_Pos = 0x17
	// Bit mask of SPI_DIO_MODE field.
	SPI1_SPI_CTRL_SPI_DIO_MODE_Msk = 0x800000
	// Bit SPI_DIO_MODE.
	SPI1_SPI_CTRL_SPI_DIO_MODE = 0x800000
	// Position of SPI_QOUT_MODE field.
	SPI1_SPI_CTRL_SPI_QOUT_MODE_Pos = 0x14
	// Bit mask of SPI_QOUT_MODE field.
	SPI1_SPI_CTRL_SPI_QOUT_MODE_Msk = 0x100000
	// Bit SPI_QOUT_MODE.
	SPI1_SPI_CTRL_SPI_QOUT_MODE = 0x100000
	// Position of SPI_DOUT_MODE field.
	SPI1_SPI_CTRL_SPI_DOUT_MODE_Pos = 0xe
	// Bit mask of SPI_DOUT_MODE field.
	SPI1_SPI_CTRL_SPI_DOUT_MODE_Msk = 0x4000
	// Bit SPI_DOUT_MODE.
	SPI1_SPI_CTRL_SPI_DOUT_MODE = 0x4000
	// Position of SPI_FASTRD_MODE field.
	SPI1_SPI_CTRL_SPI_FASTRD_MODE_Pos = 0xd
	// Bit mask of SPI_FASTRD_MODE field.
	SPI1_SPI_CTRL_SPI_FASTRD_MODE_Msk = 0x2000
	// Bit SPI_FASTRD_MODE.
	SPI1_SPI_CTRL_SPI_FASTRD_MODE = 0x2000

	// SPI_CTRL1
	// Position of STATUS field.
	SPI1_SPI_CTRL1_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	SPI1_SPI_CTRL1_STATUS_Msk = 0xffff
	// Position of WB_MODE field.
	SPI1_SPI_CTRL1_WB_MODE_Pos = 0x10
	// Bit mask of WB_MODE field.
	SPI1_SPI_CTRL1_WB_MODE_Msk = 0xff0000
	// Position of STATUS_EXT field.
	SPI1_SPI_CTRL1_STATUS_EXT_Pos = 0x18
	// Bit mask of STATUS_EXT field.
	SPI1_SPI_CTRL1_STATUS_EXT_Msk = 0xff000000

	// SPI_RD_STATUS: In the slave mode, this register are the status register for the master to read out.
	// Position of SLV_RD_STATUS field.
	SPI1_SPI_RD_STATUS_SLV_RD_STATUS_Pos = 0x0
	// Bit mask of SLV_RD_STATUS field.
	SPI1_SPI_RD_STATUS_SLV_RD_STATUS_Msk = 0xffffffff

	// SPI_CTRL2: spi_cs signal is delayed by 80MHz clock cycles
	// Position of SPI_CS_DELAY_NUM field.
	SPI1_SPI_CTRL2_SPI_CS_DELAY_NUM_Pos = 0x1c
	// Bit mask of SPI_CS_DELAY_NUM field.
	SPI1_SPI_CTRL2_SPI_CS_DELAY_NUM_Msk = 0xf0000000
	// Position of SPI_CS_DELAY_MODE field.
	SPI1_SPI_CTRL2_SPI_CS_DELAY_MODE_Pos = 0x1a
	// Bit mask of SPI_CS_DELAY_MODE field.
	SPI1_SPI_CTRL2_SPI_CS_DELAY_MODE_Msk = 0xc000000
	// Position of SPI_MOSI_DELAY_NUM field.
	SPI1_SPI_CTRL2_SPI_MOSI_DELAY_NUM_Pos = 0x17
	// Bit mask of SPI_MOSI_DELAY_NUM field.
	SPI1_SPI_CTRL2_SPI_MOSI_DELAY_NUM_Msk = 0x3800000
	// Position of SPI_MOSI_DELAY_MODE field.
	SPI1_SPI_CTRL2_SPI_MOSI_DELAY_MODE_Pos = 0x15
	// Bit mask of SPI_MOSI_DELAY_MODE field.
	SPI1_SPI_CTRL2_SPI_MOSI_DELAY_MODE_Msk = 0x600000
	// Position of SPI_MISO_DELAY_NUM field.
	SPI1_SPI_CTRL2_SPI_MISO_DELAY_NUM_Pos = 0x12
	// Bit mask of SPI_MISO_DELAY_NUM field.
	SPI1_SPI_CTRL2_SPI_MISO_DELAY_NUM_Msk = 0x1c0000
	// Position of SPI_MISO_DELAY_MODE field.
	SPI1_SPI_CTRL2_SPI_MISO_DELAY_MODE_Pos = 0x10
	// Bit mask of SPI_MISO_DELAY_MODE field.
	SPI1_SPI_CTRL2_SPI_MISO_DELAY_MODE_Msk = 0x30000

	// SPI_CLOCK: In the master mode, 1: spi_clk is eqaul to 80MHz, 0: spi_clk is divided from 80 MHz clock.
	// Position of SPI_CLK_EQU_SYSCLK field.
	SPI1_SPI_CLOCK_SPI_CLK_EQU_SYSCLK_Pos = 0x1f
	// Bit mask of SPI_CLK_EQU_SYSCLK field.
	SPI1_SPI_CLOCK_SPI_CLK_EQU_SYSCLK_Msk = 0x80000000
	// Bit SPI_CLK_EQU_SYSCLK.
	SPI1_SPI_CLOCK_SPI_CLK_EQU_SYSCLK = 0x80000000
	// Position of SPI_CLKDIV_PRE field.
	SPI1_SPI_CLOCK_SPI_CLKDIV_PRE_Pos = 0x12
	// Bit mask of SPI_CLKDIV_PRE field.
	SPI1_SPI_CLOCK_SPI_CLKDIV_PRE_Msk = 0x7ffc0000
	// Position of SPI_CLKCNT_N field.
	SPI1_SPI_CLOCK_SPI_CLKCNT_N_Pos = 0xc
	// Bit mask of SPI_CLKCNT_N field.
	SPI1_SPI_CLOCK_SPI_CLKCNT_N_Msk = 0x3f000
	// Position of SPI_CLKCNT_H field.
	SPI1_SPI_CLOCK_SPI_CLKCNT_H_Pos = 0x6
	// Bit mask of SPI_CLKCNT_H field.
	SPI1_SPI_CLOCK_SPI_CLKCNT_H_Msk = 0xfc0
	// Position of SPI_CLKCNT_L field.
	SPI1_SPI_CLOCK_SPI_CLKCNT_L_Pos = 0x0
	// Bit mask of SPI_CLKCNT_L field.
	SPI1_SPI_CLOCK_SPI_CLKCNT_L_Msk = 0x3f

	// SPI_USER: This bit enable the "command" phase of an operation.
	// Position of SPI_USR_COMMAND field.
	SPI1_SPI_USER_SPI_USR_COMMAND_Pos = 0x1f
	// Bit mask of SPI_USR_COMMAND field.
	SPI1_SPI_USER_SPI_USR_COMMAND_Msk = 0x80000000
	// Bit SPI_USR_COMMAND.
	SPI1_SPI_USER_SPI_USR_COMMAND = 0x80000000
	// Position of SPI_USR_ADDR field.
	SPI1_SPI_USER_SPI_USR_ADDR_Pos = 0x1e
	// Bit mask of SPI_USR_ADDR field.
	SPI1_SPI_USER_SPI_USR_ADDR_Msk = 0x40000000
	// Bit SPI_USR_ADDR.
	SPI1_SPI_USER_SPI_USR_ADDR = 0x40000000
	// Position of SPI_USR_DUMMY field.
	SPI1_SPI_USER_SPI_USR_DUMMY_Pos = 0x1d
	// Bit mask of SPI_USR_DUMMY field.
	SPI1_SPI_USER_SPI_USR_DUMMY_Msk = 0x20000000
	// Bit SPI_USR_DUMMY.
	SPI1_SPI_USER_SPI_USR_DUMMY = 0x20000000
	// Position of SPI_USR_MISO field.
	SPI1_SPI_USER_SPI_USR_MISO_Pos = 0x1c
	// Bit mask of SPI_USR_MISO field.
	SPI1_SPI_USER_SPI_USR_MISO_Msk = 0x10000000
	// Bit SPI_USR_MISO.
	SPI1_SPI_USER_SPI_USR_MISO = 0x10000000
	// Position of SPI_USR_MOSI field.
	SPI1_SPI_USER_SPI_USR_MOSI_Pos = 0x1b
	// Bit mask of SPI_USR_MOSI field.
	SPI1_SPI_USER_SPI_USR_MOSI_Msk = 0x8000000
	// Bit SPI_USR_MOSI.
	SPI1_SPI_USER_SPI_USR_MOSI = 0x8000000
	// Position of REG_USR_MOSI_HIGHPART field.
	SPI1_SPI_USER_REG_USR_MOSI_HIGHPART_Pos = 0x19
	// Bit mask of REG_USR_MOSI_HIGHPART field.
	SPI1_SPI_USER_REG_USR_MOSI_HIGHPART_Msk = 0x2000000
	// Bit REG_USR_MOSI_HIGHPART.
	SPI1_SPI_USER_REG_USR_MOSI_HIGHPART = 0x2000000
	// Position of REG_USR_MISO_HIGHPART field.
	SPI1_SPI_USER_REG_USR_MISO_HIGHPART_Pos = 0x18
	// Bit mask of REG_USR_MISO_HIGHPART field.
	SPI1_SPI_USER_REG_USR_MISO_HIGHPART_Msk = 0x1000000
	// Bit REG_USR_MISO_HIGHPART.
	SPI1_SPI_USER_REG_USR_MISO_HIGHPART = 0x1000000
	// Position of SPI_SIO field.
	SPI1_SPI_USER_SPI_SIO_Pos = 0x10
	// Bit mask of SPI_SIO field.
	SPI1_SPI_USER_SPI_SIO_Msk = 0x10000
	// Bit SPI_SIO.
	SPI1_SPI_USER_SPI_SIO = 0x10000
	// Position of SPI_FWRITE_QIO field.
	SPI1_SPI_USER_SPI_FWRITE_QIO_Pos = 0xf
	// Bit mask of SPI_FWRITE_QIO field.
	SPI1_SPI_USER_SPI_FWRITE_QIO_Msk = 0x8000
	// Bit SPI_FWRITE_QIO.
	SPI1_SPI_USER_SPI_FWRITE_QIO = 0x8000
	// Position of SPI_FWRITE_DIO field.
	SPI1_SPI_USER_SPI_FWRITE_DIO_Pos = 0xe
	// Bit mask of SPI_FWRITE_DIO field.
	SPI1_SPI_USER_SPI_FWRITE_DIO_Msk = 0x4000
	// Bit SPI_FWRITE_DIO.
	SPI1_SPI_USER_SPI_FWRITE_DIO = 0x4000
	// Position of SPI_FWRITE_QUAD field.
	SPI1_SPI_USER_SPI_FWRITE_QUAD_Pos = 0xd
	// Bit mask of SPI_FWRITE_QUAD field.
	SPI1_SPI_USER_SPI_FWRITE_QUAD_Msk = 0x2000
	// Bit SPI_FWRITE_QUAD.
	SPI1_SPI_USER_SPI_FWRITE_QUAD = 0x2000
	// Position of SPI_FWRITE_DUAL field.
	SPI1_SPI_USER_SPI_FWRITE_DUAL_Pos = 0xc
	// Bit mask of SPI_FWRITE_DUAL field.
	SPI1_SPI_USER_SPI_FWRITE_DUAL_Msk = 0x1000
	// Bit SPI_FWRITE_DUAL.
	SPI1_SPI_USER_SPI_FWRITE_DUAL = 0x1000
	// Position of SPI_WR_BYTE_ORDER field.
	SPI1_SPI_USER_SPI_WR_BYTE_ORDER_Pos = 0xb
	// Bit mask of SPI_WR_BYTE_ORDER field.
	SPI1_SPI_USER_SPI_WR_BYTE_ORDER_Msk = 0x800
	// Bit SPI_WR_BYTE_ORDER.
	SPI1_SPI_USER_SPI_WR_BYTE_ORDER = 0x800
	// Position of SPI_RD_BYTE_ORDER field.
	SPI1_SPI_USER_SPI_RD_BYTE_ORDER_Pos = 0xa
	// Bit mask of SPI_RD_BYTE_ORDER field.
	SPI1_SPI_USER_SPI_RD_BYTE_ORDER_Msk = 0x400
	// Bit SPI_RD_BYTE_ORDER.
	SPI1_SPI_USER_SPI_RD_BYTE_ORDER = 0x400
	// Position of SPI_CK_I_EDGE field.
	SPI1_SPI_USER_SPI_CK_I_EDGE_Pos = 0x6
	// Bit mask of SPI_CK_I_EDGE field.
	SPI1_SPI_USER_SPI_CK_I_EDGE_Msk = 0x40
	// Bit SPI_CK_I_EDGE.
	SPI1_SPI_USER_SPI_CK_I_EDGE = 0x40
	// Position of SPI_CK_O_EDGE field.
	SPI1_SPI_USER_SPI_CK_O_EDGE_Pos = 0x7
	// Bit mask of SPI_CK_O_EDGE field.
	SPI1_SPI_USER_SPI_CK_O_EDGE_Msk = 0x80
	// Bit SPI_CK_O_EDGE.
	SPI1_SPI_USER_SPI_CK_O_EDGE = 0x80
	// Position of SPI_CS_SETUP field.
	SPI1_SPI_USER_SPI_CS_SETUP_Pos = 0x5
	// Bit mask of SPI_CS_SETUP field.
	SPI1_SPI_USER_SPI_CS_SETUP_Msk = 0x20
	// Bit SPI_CS_SETUP.
	SPI1_SPI_USER_SPI_CS_SETUP = 0x20
	// Position of SPI_CS_HOLD field.
	SPI1_SPI_USER_SPI_CS_HOLD_Pos = 0x4
	// Bit mask of SPI_CS_HOLD field.
	SPI1_SPI_USER_SPI_CS_HOLD_Msk = 0x10
	// Bit SPI_CS_HOLD.
	SPI1_SPI_USER_SPI_CS_HOLD = 0x10
	// Position of SPI_AHB_USER_COMMAND field.
	SPI1_SPI_USER_SPI_AHB_USER_COMMAND_Pos = 0x3
	// Bit mask of SPI_AHB_USER_COMMAND field.
	SPI1_SPI_USER_SPI_AHB_USER_COMMAND_Msk = 0x8
	// Bit SPI_AHB_USER_COMMAND.
	SPI1_SPI_USER_SPI_AHB_USER_COMMAND = 0x8
	// Position of SPI_FLASH_MODE field.
	SPI1_SPI_USER_SPI_FLASH_MODE_Pos = 0x2
	// Bit mask of SPI_FLASH_MODE field.
	SPI1_SPI_USER_SPI_FLASH_MODE_Msk = 0x4
	// Bit SPI_FLASH_MODE.
	SPI1_SPI_USER_SPI_FLASH_MODE = 0x4
	// Position of SPI_AHB_USER_COMMAND_4BYTE field.
	SPI1_SPI_USER_SPI_AHB_USER_COMMAND_4BYTE_Pos = 0x1
	// Bit mask of SPI_AHB_USER_COMMAND_4BYTE field.
	SPI1_SPI_USER_SPI_AHB_USER_COMMAND_4BYTE_Msk = 0x2
	// Bit SPI_AHB_USER_COMMAND_4BYTE.
	SPI1_SPI_USER_SPI_AHB_USER_COMMAND_4BYTE = 0x2
	// Position of SPI_DUPLEX field.
	SPI1_SPI_USER_SPI_DUPLEX_Pos = 0x0
	// Bit mask of SPI_DUPLEX field.
	SPI1_SPI_USER_SPI_DUPLEX_Msk = 0x1
	// Bit SPI_DUPLEX.
	SPI1_SPI_USER_SPI_DUPLEX = 0x1

	// SPI_USER1: The length in bits of "address" phase. The register value shall be (bit_num-1)
	// Position of REG_USR_ADDR_BITLEN field.
	SPI1_SPI_USER1_REG_USR_ADDR_BITLEN_Pos = 0x1a
	// Bit mask of REG_USR_ADDR_BITLEN field.
	SPI1_SPI_USER1_REG_USR_ADDR_BITLEN_Msk = 0xfc000000
	// Position of REG_USR_MOSI_BITLEN field.
	SPI1_SPI_USER1_REG_USR_MOSI_BITLEN_Pos = 0x11
	// Bit mask of REG_USR_MOSI_BITLEN field.
	SPI1_SPI_USER1_REG_USR_MOSI_BITLEN_Msk = 0x3fe0000
	// Position of REG_USR_MISO_BITLEN field.
	SPI1_SPI_USER1_REG_USR_MISO_BITLEN_Pos = 0x8
	// Bit mask of REG_USR_MISO_BITLEN field.
	SPI1_SPI_USER1_REG_USR_MISO_BITLEN_Msk = 0x1ff00
	// Position of REG_USR_DUMMY_CYCLELEN field.
	SPI1_SPI_USER1_REG_USR_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of REG_USR_DUMMY_CYCLELEN field.
	SPI1_SPI_USER1_REG_USR_DUMMY_CYCLELEN_Msk = 0xff

	// SPI_USER2: The length in bits of "command" phase. The register value shall be (bit_num-1)
	// Position of REG_USR_COMMAND_BITLEN field.
	SPI1_SPI_USER2_REG_USR_COMMAND_BITLEN_Pos = 0x1c
	// Bit mask of REG_USR_COMMAND_BITLEN field.
	SPI1_SPI_USER2_REG_USR_COMMAND_BITLEN_Msk = 0xf0000000
	// Position of REG_USR_COMMAND_VALUE field.
	SPI1_SPI_USER2_REG_USR_COMMAND_VALUE_Pos = 0x0
	// Bit mask of REG_USR_COMMAND_VALUE field.
	SPI1_SPI_USER2_REG_USR_COMMAND_VALUE_Msk = 0xffff

	// SPI_WR_STATUS: In the slave mode, this register are the status register for the master to write into.
	// Position of SLV_WR_STATUS field.
	SPI1_SPI_WR_STATUS_SLV_WR_STATUS_Pos = 0x0
	// Bit mask of SLV_WR_STATUS field.
	SPI1_SPI_WR_STATUS_SLV_WR_STATUS_Msk = 0xffffffff

	// SPI_PIN: 1: disable CS2; 0: spi_cs signal is from/to CS2 pin
	// Position of SPI_CS2_DIS field.
	SPI1_SPI_PIN_SPI_CS2_DIS_Pos = 0x2
	// Bit mask of SPI_CS2_DIS field.
	SPI1_SPI_PIN_SPI_CS2_DIS_Msk = 0x4
	// Bit SPI_CS2_DIS.
	SPI1_SPI_PIN_SPI_CS2_DIS = 0x4
	// Position of SPI_CS1_DIS field.
	SPI1_SPI_PIN_SPI_CS1_DIS_Pos = 0x1
	// Bit mask of SPI_CS1_DIS field.
	SPI1_SPI_PIN_SPI_CS1_DIS_Msk = 0x2
	// Bit SPI_CS1_DIS.
	SPI1_SPI_PIN_SPI_CS1_DIS = 0x2
	// Position of SPI_CS0_DIS field.
	SPI1_SPI_PIN_SPI_CS0_DIS_Pos = 0x0
	// Bit mask of SPI_CS0_DIS field.
	SPI1_SPI_PIN_SPI_CS0_DIS_Msk = 0x1
	// Bit SPI_CS0_DIS.
	SPI1_SPI_PIN_SPI_CS0_DIS = 0x1
	// Position of SPI_IDLE_EDGE field.
	SPI1_SPI_PIN_SPI_IDLE_EDGE_Pos = 0x1d
	// Bit mask of SPI_IDLE_EDGE field.
	SPI1_SPI_PIN_SPI_IDLE_EDGE_Msk = 0x20000000
	// Bit SPI_IDLE_EDGE.
	SPI1_SPI_PIN_SPI_IDLE_EDGE = 0x20000000

	// SPI_SLAVE: It is the synchronous reset signal of the module. This bit is self-cleared by hardware.
	// Position of SPI_SYNC_RESET field.
	SPI1_SPI_SLAVE_SPI_SYNC_RESET_Pos = 0x1f
	// Bit mask of SPI_SYNC_RESET field.
	SPI1_SPI_SLAVE_SPI_SYNC_RESET_Msk = 0x80000000
	// Bit SPI_SYNC_RESET.
	SPI1_SPI_SLAVE_SPI_SYNC_RESET = 0x80000000
	// Position of SPI_SLAVE_MODE field.
	SPI1_SPI_SLAVE_SPI_SLAVE_MODE_Pos = 0x1e
	// Bit mask of SPI_SLAVE_MODE field.
	SPI1_SPI_SLAVE_SPI_SLAVE_MODE_Msk = 0x40000000
	// Bit SPI_SLAVE_MODE.
	SPI1_SPI_SLAVE_SPI_SLAVE_MODE = 0x40000000
	// Position of SLV_CMD_DEFINE field.
	SPI1_SPI_SLAVE_SLV_CMD_DEFINE_Pos = 0x1b
	// Bit mask of SLV_CMD_DEFINE field.
	SPI1_SPI_SLAVE_SLV_CMD_DEFINE_Msk = 0x8000000
	// Bit SLV_CMD_DEFINE.
	SPI1_SPI_SLAVE_SLV_CMD_DEFINE = 0x8000000
	// Position of SPI_TRANS_CNT field.
	SPI1_SPI_SLAVE_SPI_TRANS_CNT_Pos = 0x17
	// Bit mask of SPI_TRANS_CNT field.
	SPI1_SPI_SLAVE_SPI_TRANS_CNT_Msk = 0x7800000
	// Position of SPI_INT_EN field.
	SPI1_SPI_SLAVE_SPI_INT_EN_Pos = 0x5
	// Bit mask of SPI_INT_EN field.
	SPI1_SPI_SLAVE_SPI_INT_EN_Msk = 0x3e0
	// Position of SPI_TRANS_DONE field.
	SPI1_SPI_SLAVE_SPI_TRANS_DONE_Pos = 0x4
	// Bit mask of SPI_TRANS_DONE field.
	SPI1_SPI_SLAVE_SPI_TRANS_DONE_Msk = 0x10
	// Bit SPI_TRANS_DONE.
	SPI1_SPI_SLAVE_SPI_TRANS_DONE = 0x10
	// Position of SLV_WR_STA_DONE field.
	SPI1_SPI_SLAVE_SLV_WR_STA_DONE_Pos = 0x3
	// Bit mask of SLV_WR_STA_DONE field.
	SPI1_SPI_SLAVE_SLV_WR_STA_DONE_Msk = 0x8
	// Bit SLV_WR_STA_DONE.
	SPI1_SPI_SLAVE_SLV_WR_STA_DONE = 0x8
	// Position of SLV_RD_STA_DONE field.
	SPI1_SPI_SLAVE_SLV_RD_STA_DONE_Pos = 0x2
	// Bit mask of SLV_RD_STA_DONE field.
	SPI1_SPI_SLAVE_SLV_RD_STA_DONE_Msk = 0x4
	// Bit SLV_RD_STA_DONE.
	SPI1_SPI_SLAVE_SLV_RD_STA_DONE = 0x4
	// Position of SLV_WR_BUF_DONE field.
	SPI1_SPI_SLAVE_SLV_WR_BUF_DONE_Pos = 0x1
	// Bit mask of SLV_WR_BUF_DONE field.
	SPI1_SPI_SLAVE_SLV_WR_BUF_DONE_Msk = 0x2
	// Bit SLV_WR_BUF_DONE.
	SPI1_SPI_SLAVE_SLV_WR_BUF_DONE = 0x2
	// Position of SLV_RD_BUF_DONE field.
	SPI1_SPI_SLAVE_SLV_RD_BUF_DONE_Pos = 0x0
	// Bit mask of SLV_RD_BUF_DONE field.
	SPI1_SPI_SLAVE_SLV_RD_BUF_DONE_Msk = 0x1
	// Bit SLV_RD_BUF_DONE.
	SPI1_SPI_SLAVE_SLV_RD_BUF_DONE = 0x1

	// SPI_SLAVE1: In the slave mode, it is the length in bits for "write-status" and "read-status" operations. The register valueshall be (bit_num-1)
	// Position of SLV_STATUS_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_STATUS_BITLEN_Pos = 0x1b
	// Bit mask of SLV_STATUS_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_STATUS_BITLEN_Msk = 0xf8000000
	// Position of SLV_BUF_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_BUF_BITLEN_Pos = 0x10
	// Bit mask of SLV_BUF_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_BUF_BITLEN_Msk = 0x1ff0000
	// Position of SLV_RD_ADDR_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_RD_ADDR_BITLEN_Pos = 0xa
	// Bit mask of SLV_RD_ADDR_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_RD_ADDR_BITLEN_Msk = 0xfc00
	// Position of SLV_WR_ADDR_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_WR_ADDR_BITLEN_Pos = 0x4
	// Bit mask of SLV_WR_ADDR_BITLEN field.
	SPI1_SPI_SLAVE1_SLV_WR_ADDR_BITLEN_Msk = 0x3f0
	// Position of SLV_WRSTA_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_WRSTA_DUMMY_EN_Pos = 0x3
	// Bit mask of SLV_WRSTA_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_WRSTA_DUMMY_EN_Msk = 0x8
	// Bit SLV_WRSTA_DUMMY_EN.
	SPI1_SPI_SLAVE1_SLV_WRSTA_DUMMY_EN = 0x8
	// Position of SLV_RDSTA_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_RDSTA_DUMMY_EN_Pos = 0x2
	// Bit mask of SLV_RDSTA_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_RDSTA_DUMMY_EN_Msk = 0x4
	// Bit SLV_RDSTA_DUMMY_EN.
	SPI1_SPI_SLAVE1_SLV_RDSTA_DUMMY_EN = 0x4
	// Position of SLV_WRBUF_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_WRBUF_DUMMY_EN_Pos = 0x1
	// Bit mask of SLV_WRBUF_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_WRBUF_DUMMY_EN_Msk = 0x2
	// Bit SLV_WRBUF_DUMMY_EN.
	SPI1_SPI_SLAVE1_SLV_WRBUF_DUMMY_EN = 0x2
	// Position of SLV_RDBUF_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_RDBUF_DUMMY_EN_Pos = 0x0
	// Bit mask of SLV_RDBUF_DUMMY_EN field.
	SPI1_SPI_SLAVE1_SLV_RDBUF_DUMMY_EN_Msk = 0x1
	// Bit SLV_RDBUF_DUMMY_EN.
	SPI1_SPI_SLAVE1_SLV_RDBUF_DUMMY_EN = 0x1

	// SPI_SLAVE2: In the slave mode, it is the length in spi_clk cycles "dummy" phase for "write-buffer" operations. The registervalue shall be (cycle_num-1)
	// Position of SLV_WRBUF_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN_Pos = 0x18
	// Bit mask of SLV_WRBUF_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_WRBUF_DUMMY_CYCLELEN_Msk = 0xff000000
	// Position of SLV_RDBUF_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN_Pos = 0x10
	// Bit mask of SLV_RDBUF_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_RDBUF_DUMMY_CYCLELEN_Msk = 0xff0000
	// Position of SLV_WRSTA_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN_Pos = 0x8
	// Bit mask of SLV_WRSTA_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_WRSTA_DUMMY_CYCLELEN_Msk = 0xff00
	// Position of SLV_RDSTA_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN_Pos = 0x0
	// Bit mask of SLV_RDSTA_DUMMY_CYCLELEN field.
	SPI1_SPI_SLAVE2_SLV_RDSTA_DUMMY_CYCLELEN_Msk = 0xff

	// SPI_SLAVE3: In slave mode, it is the value of "write-status" command
	// Position of SLV_WRSTA_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_WRSTA_CMD_VALUE_Pos = 0x18
	// Bit mask of SLV_WRSTA_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_WRSTA_CMD_VALUE_Msk = 0xff000000
	// Position of SLV_RDSTA_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_RDSTA_CMD_VALUE_Pos = 0x10
	// Bit mask of SLV_RDSTA_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_RDSTA_CMD_VALUE_Msk = 0xff0000
	// Position of SLV_WRBUF_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_WRBUF_CMD_VALUE_Pos = 0x8
	// Bit mask of SLV_WRBUF_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_WRBUF_CMD_VALUE_Msk = 0xff00
	// Position of SLV_RDBUF_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_RDBUF_CMD_VALUE_Pos = 0x0
	// Bit mask of SLV_RDBUF_CMD_VALUE field.
	SPI1_SPI_SLAVE3_SLV_RDBUF_CMD_VALUE_Msk = 0xff

	// SPI_W0: the data inside the buffer of the SPI module, byte 0
	// Position of SPI_W0 field.
	SPI1_SPI_W0_SPI_W0_Pos = 0x0
	// Bit mask of SPI_W0 field.
	SPI1_SPI_W0_SPI_W0_Msk = 0xffffffff

	// SPI_W1: the data inside the buffer of the SPI module, byte 1
	// Position of SPI_W1 field.
	SPI1_SPI_W1_SPI_W1_Pos = 0x0
	// Bit mask of SPI_W1 field.
	SPI1_SPI_W1_SPI_W1_Msk = 0xffffffff

	// SPI_W2: the data inside the buffer of the SPI module, byte 2
	// Position of SPI_W2 field.
	SPI1_SPI_W2_SPI_W2_Pos = 0x0
	// Bit mask of SPI_W2 field.
	SPI1_SPI_W2_SPI_W2_Msk = 0xffffffff

	// SPI_W3: the data inside the buffer of the SPI module, byte 3
	// Position of SPI_W3 field.
	SPI1_SPI_W3_SPI_W3_Pos = 0x0
	// Bit mask of SPI_W3 field.
	SPI1_SPI_W3_SPI_W3_Msk = 0xffffffff

	// SPI_W4: the data inside the buffer of the SPI module, byte 4
	// Position of SPI_W4 field.
	SPI1_SPI_W4_SPI_W4_Pos = 0x0
	// Bit mask of SPI_W4 field.
	SPI1_SPI_W4_SPI_W4_Msk = 0xffffffff

	// SPI_W5: the data inside the buffer of the SPI module, byte 5
	// Position of SPI_W5 field.
	SPI1_SPI_W5_SPI_W5_Pos = 0x0
	// Bit mask of SPI_W5 field.
	SPI1_SPI_W5_SPI_W5_Msk = 0xffffffff

	// SPI_EXT3: This register is for two SPI masters to share the same cs, clock and data signals.
	// Position of REG_INT_HOLD_ENA field.
	SPI1_SPI_EXT3_REG_INT_HOLD_ENA_Pos = 0x0
	// Bit mask of REG_INT_HOLD_ENA field.
	SPI1_SPI_EXT3_REG_INT_HOLD_ENA_Msk = 0x3

	// SPI_W6: the data inside the buffer of the SPI module, byte 6
	// Position of SPI_W6 field.
	SPI1_SPI_W6_SPI_W6_Pos = 0x0
	// Bit mask of SPI_W6 field.
	SPI1_SPI_W6_SPI_W6_Msk = 0xffffffff

	// SPI_W7: the data inside the buffer of the SPI module, byte 7
	// Position of SPI_W7 field.
	SPI1_SPI_W7_SPI_W7_Pos = 0x0
	// Bit mask of SPI_W7 field.
	SPI1_SPI_W7_SPI_W7_Msk = 0xffffffff

	// SPI_W8: the data inside the buffer of the SPI module, byte 8
	// Position of SPI_W8 field.
	SPI1_SPI_W8_SPI_W8_Pos = 0x0
	// Bit mask of SPI_W8 field.
	SPI1_SPI_W8_SPI_W8_Msk = 0xffffffff

	// SPI_W9: the data inside the buffer of the SPI module, byte 9
	// Position of SPI_W9 field.
	SPI1_SPI_W9_SPI_W9_Pos = 0x0
	// Bit mask of SPI_W9 field.
	SPI1_SPI_W9_SPI_W9_Msk = 0xffffffff

	// SPI_W10: the data inside the buffer of the SPI module, byte 10
	// Position of SPI_W10 field.
	SPI1_SPI_W10_SPI_W10_Pos = 0x0
	// Bit mask of SPI_W10 field.
	SPI1_SPI_W10_SPI_W10_Msk = 0xffffffff

	// SPI_W11: the data inside the buffer of the SPI module, byte 11
	// Position of SPI_W11 field.
	SPI1_SPI_W11_SPI_W11_Pos = 0x0
	// Bit mask of SPI_W11 field.
	SPI1_SPI_W11_SPI_W11_Msk = 0xffffffff

	// SPI_W12: the data inside the buffer of the SPI module, byte 12
	// Position of SPI_W12 field.
	SPI1_SPI_W12_SPI_W12_Pos = 0x0
	// Bit mask of SPI_W12 field.
	SPI1_SPI_W12_SPI_W12_Msk = 0xffffffff

	// SPI_W13: the data inside the buffer of the SPI module, byte 13
	// Position of SPI_W13 field.
	SPI1_SPI_W13_SPI_W13_Pos = 0x0
	// Bit mask of SPI_W13 field.
	SPI1_SPI_W13_SPI_W13_Msk = 0xffffffff

	// SPI_W14: the data inside the buffer of the SPI module, byte 14
	// Position of SPI_W14 field.
	SPI1_SPI_W14_SPI_W14_Pos = 0x0
	// Bit mask of SPI_W14 field.
	SPI1_SPI_W14_SPI_W14_Msk = 0xffffffff

	// SPI_W15: the data inside the buffer of the SPI module, byte 15
	// Position of SPI_W15 field.
	SPI1_SPI_W15_SPI_W15_Pos = 0x0
	// Bit mask of SPI_W15 field.
	SPI1_SPI_W15_SPI_W15_Msk = 0xffffffff
)

// Constants for TIMER
const (
	// FRC1_LOAD: the load value into the counter
	// Position of FRC1_LOAD_VALUE field.
	TIMER_FRC1_LOAD_FRC1_LOAD_VALUE_Pos = 0x0
	// Bit mask of FRC1_LOAD_VALUE field.
	TIMER_FRC1_LOAD_FRC1_LOAD_VALUE_Msk = 0x7fffff

	// FRC1_COUNT: the current value of the counter. It is a decreasingcounter.
	// Position of FRC1_COUNT field.
	TIMER_FRC1_COUNT_FRC1_COUNT_Pos = 0x0
	// Bit mask of FRC1_COUNT field.
	TIMER_FRC1_COUNT_FRC1_COUNT_Msk = 0x7fffff

	// FRC1_CTRL: FRC1_CTRL
	// Position of FRC1_INT field.
	TIMER_FRC1_CTRL_FRC1_INT_Pos = 0x8
	// Bit mask of FRC1_INT field.
	TIMER_FRC1_CTRL_FRC1_INT_Msk = 0x100
	// Bit FRC1_INT.
	TIMER_FRC1_CTRL_FRC1_INT = 0x100
	// Position of FRC1_CTRL field.
	TIMER_FRC1_CTRL_FRC1_CTRL_Pos = 0x0
	// Bit mask of FRC1_CTRL field.
	TIMER_FRC1_CTRL_FRC1_CTRL_Msk = 0xff
	// Position of TIMER_ENABLE field.
	TIMER_FRC1_CTRL_TIMER_ENABLE_Pos = 0x7
	// Bit mask of TIMER_ENABLE field.
	TIMER_FRC1_CTRL_TIMER_ENABLE_Msk = 0x80
	// Bit TIMER_ENABLE.
	TIMER_FRC1_CTRL_TIMER_ENABLE = 0x80
	// Position of ROLLOVER field.
	TIMER_FRC1_CTRL_ROLLOVER_Pos = 0x6
	// Bit mask of ROLLOVER field.
	TIMER_FRC1_CTRL_ROLLOVER_Msk = 0x40
	// Bit ROLLOVER.
	TIMER_FRC1_CTRL_ROLLOVER = 0x40
	// Position of PRESCALE_DIVIDER field.
	TIMER_FRC1_CTRL_PRESCALE_DIVIDER_Pos = 0x2
	// Bit mask of PRESCALE_DIVIDER field.
	TIMER_FRC1_CTRL_PRESCALE_DIVIDER_Msk = 0xc
	// divided by 1
	TIMER_FRC1_CTRL_PRESCALE_DIVIDER_DEVIDED_BY_1 = 0x0
	// divided by 16
	TIMER_FRC1_CTRL_PRESCALE_DIVIDER_DEVIDED_BY_16 = 0x1
	// divided by 256
	TIMER_FRC1_CTRL_PRESCALE_DIVIDER_DEVIDED_BY_256 = 0x2
	// Position of INTERRUPT_TYPE field.
	TIMER_FRC1_CTRL_INTERRUPT_TYPE_Pos = 0x0
	// Bit mask of INTERRUPT_TYPE field.
	TIMER_FRC1_CTRL_INTERRUPT_TYPE_Msk = 0x1
	// Bit INTERRUPT_TYPE.
	TIMER_FRC1_CTRL_INTERRUPT_TYPE = 0x1
	// edge
	TIMER_FRC1_CTRL_INTERRUPT_TYPE_EDGE = 0x0
	// level
	TIMER_FRC1_CTRL_INTERRUPT_TYPE_LEVEL = 0x1

	// FRC1_INT: FRC1_INT
	// Position of FRC1_INT_CLR_MASK field.
	TIMER_FRC1_INT_FRC1_INT_CLR_MASK_Pos = 0x0
	// Bit mask of FRC1_INT_CLR_MASK field.
	TIMER_FRC1_INT_FRC1_INT_CLR_MASK_Msk = 0x1
	// Bit FRC1_INT_CLR_MASK.
	TIMER_FRC1_INT_FRC1_INT_CLR_MASK = 0x1

	// FRC2_LOAD: the load value into the counter
	// Position of FRC2_LOAD_VALUE field.
	TIMER_FRC2_LOAD_FRC2_LOAD_VALUE_Pos = 0x0
	// Bit mask of FRC2_LOAD_VALUE field.
	TIMER_FRC2_LOAD_FRC2_LOAD_VALUE_Msk = 0xffffffff

	// FRC2_COUNT: the current value of the counter. It is a increasingcounter.
	// Position of FRC2_COUNT field.
	TIMER_FRC2_COUNT_FRC2_COUNT_Pos = 0x0
	// Bit mask of FRC2_COUNT field.
	TIMER_FRC2_COUNT_FRC2_COUNT_Msk = 0xffffffff

	// FRC2_CTRL: FRC2_CTRL
	// Position of FRC2_INT field.
	TIMER_FRC2_CTRL_FRC2_INT_Pos = 0x8
	// Bit mask of FRC2_INT field.
	TIMER_FRC2_CTRL_FRC2_INT_Msk = 0x100
	// Bit FRC2_INT.
	TIMER_FRC2_CTRL_FRC2_INT = 0x100
	// Position of FRC2_CTRL field.
	TIMER_FRC2_CTRL_FRC2_CTRL_Pos = 0x0
	// Bit mask of FRC2_CTRL field.
	TIMER_FRC2_CTRL_FRC2_CTRL_Msk = 0xff
	// Position of TIMER_ENABLE field.
	TIMER_FRC2_CTRL_TIMER_ENABLE_Pos = 0x7
	// Bit mask of TIMER_ENABLE field.
	TIMER_FRC2_CTRL_TIMER_ENABLE_Msk = 0x80
	// Bit TIMER_ENABLE.
	TIMER_FRC2_CTRL_TIMER_ENABLE = 0x80
	// Position of ROLLOVER field.
	TIMER_FRC2_CTRL_ROLLOVER_Pos = 0x6
	// Bit mask of ROLLOVER field.
	TIMER_FRC2_CTRL_ROLLOVER_Msk = 0x40
	// Bit ROLLOVER.
	TIMER_FRC2_CTRL_ROLLOVER = 0x40
	// Position of PRESCALE_DIVIDER field.
	TIMER_FRC2_CTRL_PRESCALE_DIVIDER_Pos = 0x2
	// Bit mask of PRESCALE_DIVIDER field.
	TIMER_FRC2_CTRL_PRESCALE_DIVIDER_Msk = 0xc
	// divided by 1
	TIMER_FRC2_CTRL_PRESCALE_DIVIDER_DEVIDED_BY_1 = 0x0
	// divided by 16
	TIMER_FRC2_CTRL_PRESCALE_DIVIDER_DEVIDED_BY_16 = 0x1
	// divided by 256
	TIMER_FRC2_CTRL_PRESCALE_DIVIDER_DEVIDED_BY_256 = 0x2
	// Position of INTERRUPT_TYPE field.
	TIMER_FRC2_CTRL_INTERRUPT_TYPE_Pos = 0x0
	// Bit mask of INTERRUPT_TYPE field.
	TIMER_FRC2_CTRL_INTERRUPT_TYPE_Msk = 0x1
	// Bit INTERRUPT_TYPE.
	TIMER_FRC2_CTRL_INTERRUPT_TYPE = 0x1
	// edge
	TIMER_FRC2_CTRL_INTERRUPT_TYPE_EDGE = 0x0
	// level
	TIMER_FRC2_CTRL_INTERRUPT_TYPE_LEVEL = 0x1

	// FRC2_INT: FRC2_INT
	// Position of FRC2_INT_CLR_MASK field.
	TIMER_FRC2_INT_FRC2_INT_CLR_MASK_Pos = 0x0
	// Bit mask of FRC2_INT_CLR_MASK field.
	TIMER_FRC2_INT_FRC2_INT_CLR_MASK_Msk = 0x1
	// Bit FRC2_INT_CLR_MASK.
	TIMER_FRC2_INT_FRC2_INT_CLR_MASK = 0x1

	// FRC2_ALARM: the alarm value for the counter
	// Position of FRC2_ALARM field.
	TIMER_FRC2_ALARM_FRC2_ALARM_Pos = 0x0
	// Bit mask of FRC2_ALARM field.
	TIMER_FRC2_ALARM_FRC2_ALARM_Msk = 0xffffffff
)

// Constants for UART0
const (
	// UART_FIFO: UART FIFO,length 128
	// Position of RXFIFO_RD_BYTE field.
	UART0_UART_FIFO_RXFIFO_RD_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_RD_BYTE field.
	UART0_UART_FIFO_RXFIFO_RD_BYTE_Msk = 0xff
	// Position of RXFIFO_WRITE_BYTE field.
	UART0_UART_FIFO_RXFIFO_WRITE_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_WRITE_BYTE field.
	UART0_UART_FIFO_RXFIFO_WRITE_BYTE_Msk = 0xff

	// UART_INT_RAW: UART INTERRUPT RAW STATE
	// Position of RXFIFO_TOUT_INT_RAW field.
	UART0_UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_RAW field.
	UART0_UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_RAW.
	UART0_UART_INT_RAW_RXFIFO_TOUT_INT_RAW = 0x100
	// Position of BRK_DET_INT_RAW field.
	UART0_UART_INT_RAW_BRK_DET_INT_RAW_Pos = 0x7
	// Bit mask of BRK_DET_INT_RAW field.
	UART0_UART_INT_RAW_BRK_DET_INT_RAW_Msk = 0x80
	// Bit BRK_DET_INT_RAW.
	UART0_UART_INT_RAW_BRK_DET_INT_RAW = 0x80
	// Position of CTS_CHG_INT_RAW field.
	UART0_UART_INT_RAW_CTS_CHG_INT_RAW_Pos = 0x6
	// Bit mask of CTS_CHG_INT_RAW field.
	UART0_UART_INT_RAW_CTS_CHG_INT_RAW_Msk = 0x40
	// Bit CTS_CHG_INT_RAW.
	UART0_UART_INT_RAW_CTS_CHG_INT_RAW = 0x40
	// Position of DSR_CHG_INT_RAW field.
	UART0_UART_INT_RAW_DSR_CHG_INT_RAW_Pos = 0x5
	// Bit mask of DSR_CHG_INT_RAW field.
	UART0_UART_INT_RAW_DSR_CHG_INT_RAW_Msk = 0x20
	// Bit DSR_CHG_INT_RAW.
	UART0_UART_INT_RAW_DSR_CHG_INT_RAW = 0x20
	// Position of RXFIFO_OVF_INT_RAW field.
	UART0_UART_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	UART0_UART_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x10
	// Bit RXFIFO_OVF_INT_RAW.
	UART0_UART_INT_RAW_RXFIFO_OVF_INT_RAW = 0x10
	// Position of FRM_ERR_INT_RAW field.
	UART0_UART_INT_RAW_FRM_ERR_INT_RAW_Pos = 0x3
	// Bit mask of FRM_ERR_INT_RAW field.
	UART0_UART_INT_RAW_FRM_ERR_INT_RAW_Msk = 0x8
	// Bit FRM_ERR_INT_RAW.
	UART0_UART_INT_RAW_FRM_ERR_INT_RAW = 0x8
	// Position of PARITY_ERR_INT_RAW field.
	UART0_UART_INT_RAW_PARITY_ERR_INT_RAW_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_RAW field.
	UART0_UART_INT_RAW_PARITY_ERR_INT_RAW_Msk = 0x4
	// Bit PARITY_ERR_INT_RAW.
	UART0_UART_INT_RAW_PARITY_ERR_INT_RAW = 0x4
	// Position of TXFIFO_EMPTY_INT_RAW field.
	UART0_UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_RAW field.
	UART0_UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_RAW.
	UART0_UART_INT_RAW_TXFIFO_EMPTY_INT_RAW = 0x2
	// Position of RXFIFO_FULL_INT_RAW field.
	UART0_UART_INT_RAW_RXFIFO_FULL_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_RAW field.
	UART0_UART_INT_RAW_RXFIFO_FULL_INT_RAW_Msk = 0x1
	// Bit RXFIFO_FULL_INT_RAW.
	UART0_UART_INT_RAW_RXFIFO_FULL_INT_RAW = 0x1

	// UART_INT_ST: UART INTERRUPT STATEREGISTERUART_INT_RAW&UART_INT_ENA
	// Position of RXFIFO_TOUT_INT_ST field.
	UART0_UART_INT_ST_RXFIFO_TOUT_INT_ST_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ST field.
	UART0_UART_INT_ST_RXFIFO_TOUT_INT_ST_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ST.
	UART0_UART_INT_ST_RXFIFO_TOUT_INT_ST = 0x100
	// Position of BRK_DET_INT_ST field.
	UART0_UART_INT_ST_BRK_DET_INT_ST_Pos = 0x7
	// Bit mask of BRK_DET_INT_ST field.
	UART0_UART_INT_ST_BRK_DET_INT_ST_Msk = 0x80
	// Bit BRK_DET_INT_ST.
	UART0_UART_INT_ST_BRK_DET_INT_ST = 0x80
	// Position of CTS_CHG_INT_ST field.
	UART0_UART_INT_ST_CTS_CHG_INT_ST_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ST field.
	UART0_UART_INT_ST_CTS_CHG_INT_ST_Msk = 0x40
	// Bit CTS_CHG_INT_ST.
	UART0_UART_INT_ST_CTS_CHG_INT_ST = 0x40
	// Position of DSR_CHG_INT_ST field.
	UART0_UART_INT_ST_DSR_CHG_INT_ST_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ST field.
	UART0_UART_INT_ST_DSR_CHG_INT_ST_Msk = 0x20
	// Bit DSR_CHG_INT_ST.
	UART0_UART_INT_ST_DSR_CHG_INT_ST = 0x20
	// Position of RXFIFO_OVF_INT_ST field.
	UART0_UART_INT_ST_RXFIFO_OVF_INT_ST_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ST field.
	UART0_UART_INT_ST_RXFIFO_OVF_INT_ST_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ST.
	UART0_UART_INT_ST_RXFIFO_OVF_INT_ST = 0x10
	// Position of FRM_ERR_INT_ST field.
	UART0_UART_INT_ST_FRM_ERR_INT_ST_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ST field.
	UART0_UART_INT_ST_FRM_ERR_INT_ST_Msk = 0x8
	// Bit FRM_ERR_INT_ST.
	UART0_UART_INT_ST_FRM_ERR_INT_ST = 0x8
	// Position of PARITY_ERR_INT_ST field.
	UART0_UART_INT_ST_PARITY_ERR_INT_ST_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ST field.
	UART0_UART_INT_ST_PARITY_ERR_INT_ST_Msk = 0x4
	// Bit PARITY_ERR_INT_ST.
	UART0_UART_INT_ST_PARITY_ERR_INT_ST = 0x4
	// Position of TXFIFO_EMPTY_INT_ST field.
	UART0_UART_INT_ST_TXFIFO_EMPTY_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ST field.
	UART0_UART_INT_ST_TXFIFO_EMPTY_INT_ST_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ST.
	UART0_UART_INT_ST_TXFIFO_EMPTY_INT_ST = 0x2
	// Position of RXFIFO_FULL_INT_ST field.
	UART0_UART_INT_ST_RXFIFO_FULL_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ST field.
	UART0_UART_INT_ST_RXFIFO_FULL_INT_ST_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ST.
	UART0_UART_INT_ST_RXFIFO_FULL_INT_ST = 0x1

	// UART_INT_ENA: UART INTERRUPT ENABLE REGISTER
	// Position of RXFIFO_TOUT_INT_ENA field.
	UART0_UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ENA field.
	UART0_UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ENA.
	UART0_UART_INT_ENA_RXFIFO_TOUT_INT_ENA = 0x100
	// Position of BRK_DET_INT_ENA field.
	UART0_UART_INT_ENA_BRK_DET_INT_ENA_Pos = 0x7
	// Bit mask of BRK_DET_INT_ENA field.
	UART0_UART_INT_ENA_BRK_DET_INT_ENA_Msk = 0x80
	// Bit BRK_DET_INT_ENA.
	UART0_UART_INT_ENA_BRK_DET_INT_ENA = 0x80
	// Position of CTS_CHG_INT_ENA field.
	UART0_UART_INT_ENA_CTS_CHG_INT_ENA_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ENA field.
	UART0_UART_INT_ENA_CTS_CHG_INT_ENA_Msk = 0x40
	// Bit CTS_CHG_INT_ENA.
	UART0_UART_INT_ENA_CTS_CHG_INT_ENA = 0x40
	// Position of DSR_CHG_INT_ENA field.
	UART0_UART_INT_ENA_DSR_CHG_INT_ENA_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ENA field.
	UART0_UART_INT_ENA_DSR_CHG_INT_ENA_Msk = 0x20
	// Bit DSR_CHG_INT_ENA.
	UART0_UART_INT_ENA_DSR_CHG_INT_ENA = 0x20
	// Position of RXFIFO_OVF_INT_ENA field.
	UART0_UART_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	UART0_UART_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ENA.
	UART0_UART_INT_ENA_RXFIFO_OVF_INT_ENA = 0x10
	// Position of FRM_ERR_INT_ENA field.
	UART0_UART_INT_ENA_FRM_ERR_INT_ENA_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ENA field.
	UART0_UART_INT_ENA_FRM_ERR_INT_ENA_Msk = 0x8
	// Bit FRM_ERR_INT_ENA.
	UART0_UART_INT_ENA_FRM_ERR_INT_ENA = 0x8
	// Position of PARITY_ERR_INT_ENA field.
	UART0_UART_INT_ENA_PARITY_ERR_INT_ENA_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ENA field.
	UART0_UART_INT_ENA_PARITY_ERR_INT_ENA_Msk = 0x4
	// Bit PARITY_ERR_INT_ENA.
	UART0_UART_INT_ENA_PARITY_ERR_INT_ENA = 0x4
	// Position of TXFIFO_EMPTY_INT_ENA field.
	UART0_UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ENA field.
	UART0_UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ENA.
	UART0_UART_INT_ENA_TXFIFO_EMPTY_INT_ENA = 0x2
	// Position of RXFIFO_FULL_INT_ENA field.
	UART0_UART_INT_ENA_RXFIFO_FULL_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ENA field.
	UART0_UART_INT_ENA_RXFIFO_FULL_INT_ENA_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ENA.
	UART0_UART_INT_ENA_RXFIFO_FULL_INT_ENA = 0x1

	// UART_INT_CLR: UART INTERRUPT CLEAR REGISTER
	// Position of RXFIFO_TOUT_INT_CLR field.
	UART0_UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_CLR field.
	UART0_UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_CLR.
	UART0_UART_INT_CLR_RXFIFO_TOUT_INT_CLR = 0x100
	// Position of BRK_DET_INT_CLR field.
	UART0_UART_INT_CLR_BRK_DET_INT_CLR_Pos = 0x7
	// Bit mask of BRK_DET_INT_CLR field.
	UART0_UART_INT_CLR_BRK_DET_INT_CLR_Msk = 0x80
	// Bit BRK_DET_INT_CLR.
	UART0_UART_INT_CLR_BRK_DET_INT_CLR = 0x80
	// Position of CTS_CHG_INT_CLR field.
	UART0_UART_INT_CLR_CTS_CHG_INT_CLR_Pos = 0x6
	// Bit mask of CTS_CHG_INT_CLR field.
	UART0_UART_INT_CLR_CTS_CHG_INT_CLR_Msk = 0x40
	// Bit CTS_CHG_INT_CLR.
	UART0_UART_INT_CLR_CTS_CHG_INT_CLR = 0x40
	// Position of DSR_CHG_INT_CLR field.
	UART0_UART_INT_CLR_DSR_CHG_INT_CLR_Pos = 0x5
	// Bit mask of DSR_CHG_INT_CLR field.
	UART0_UART_INT_CLR_DSR_CHG_INT_CLR_Msk = 0x20
	// Bit DSR_CHG_INT_CLR.
	UART0_UART_INT_CLR_DSR_CHG_INT_CLR = 0x20
	// Position of RXFIFO_OVF_INT_CLR field.
	UART0_UART_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	UART0_UART_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x10
	// Bit RXFIFO_OVF_INT_CLR.
	UART0_UART_INT_CLR_RXFIFO_OVF_INT_CLR = 0x10
	// Position of FRM_ERR_INT_CLR field.
	UART0_UART_INT_CLR_FRM_ERR_INT_CLR_Pos = 0x3
	// Bit mask of FRM_ERR_INT_CLR field.
	UART0_UART_INT_CLR_FRM_ERR_INT_CLR_Msk = 0x8
	// Bit FRM_ERR_INT_CLR.
	UART0_UART_INT_CLR_FRM_ERR_INT_CLR = 0x8
	// Position of PARITY_ERR_INT_CLR field.
	UART0_UART_INT_CLR_PARITY_ERR_INT_CLR_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_CLR field.
	UART0_UART_INT_CLR_PARITY_ERR_INT_CLR_Msk = 0x4
	// Bit PARITY_ERR_INT_CLR.
	UART0_UART_INT_CLR_PARITY_ERR_INT_CLR = 0x4
	// Position of TXFIFO_EMPTY_INT_CLR field.
	UART0_UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_CLR field.
	UART0_UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_CLR.
	UART0_UART_INT_CLR_TXFIFO_EMPTY_INT_CLR = 0x2
	// Position of RXFIFO_FULL_INT_CLR field.
	UART0_UART_INT_CLR_RXFIFO_FULL_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_CLR field.
	UART0_UART_INT_CLR_RXFIFO_FULL_INT_CLR_Msk = 0x1
	// Bit RXFIFO_FULL_INT_CLR.
	UART0_UART_INT_CLR_RXFIFO_FULL_INT_CLR = 0x1

	// UART_CLKDIV: UART CLK DIV REGISTER
	// Position of UART_CLKDIV field.
	UART0_UART_CLKDIV_UART_CLKDIV_Pos = 0x0
	// Bit mask of UART_CLKDIV field.
	UART0_UART_CLKDIV_UART_CLKDIV_Msk = 0xfffff

	// UART_AUTOBAUD: UART BAUDRATE DETECT REGISTER
	// Position of GLITCH_FILT field.
	UART0_UART_AUTOBAUD_GLITCH_FILT_Pos = 0x8
	// Bit mask of GLITCH_FILT field.
	UART0_UART_AUTOBAUD_GLITCH_FILT_Msk = 0xff00
	// Position of AUTOBAUD_EN field.
	UART0_UART_AUTOBAUD_AUTOBAUD_EN_Pos = 0x0
	// Bit mask of AUTOBAUD_EN field.
	UART0_UART_AUTOBAUD_AUTOBAUD_EN_Msk = 0x1
	// Bit AUTOBAUD_EN.
	UART0_UART_AUTOBAUD_AUTOBAUD_EN = 0x1

	// UART_STATUS: UART STATUS REGISTER
	// Position of TXD field.
	UART0_UART_STATUS_TXD_Pos = 0x1f
	// Bit mask of TXD field.
	UART0_UART_STATUS_TXD_Msk = 0x80000000
	// Bit TXD.
	UART0_UART_STATUS_TXD = 0x80000000
	// Position of RTSN field.
	UART0_UART_STATUS_RTSN_Pos = 0x1e
	// Bit mask of RTSN field.
	UART0_UART_STATUS_RTSN_Msk = 0x40000000
	// Bit RTSN.
	UART0_UART_STATUS_RTSN = 0x40000000
	// Position of DTRN field.
	UART0_UART_STATUS_DTRN_Pos = 0x1d
	// Bit mask of DTRN field.
	UART0_UART_STATUS_DTRN_Msk = 0x20000000
	// Bit DTRN.
	UART0_UART_STATUS_DTRN = 0x20000000
	// Position of TXFIFO_CNT field.
	UART0_UART_STATUS_TXFIFO_CNT_Pos = 0x10
	// Bit mask of TXFIFO_CNT field.
	UART0_UART_STATUS_TXFIFO_CNT_Msk = 0xff0000
	// Position of RXD field.
	UART0_UART_STATUS_RXD_Pos = 0xf
	// Bit mask of RXD field.
	UART0_UART_STATUS_RXD_Msk = 0x8000
	// Bit RXD.
	UART0_UART_STATUS_RXD = 0x8000
	// Position of CTSN field.
	UART0_UART_STATUS_CTSN_Pos = 0xe
	// Bit mask of CTSN field.
	UART0_UART_STATUS_CTSN_Msk = 0x4000
	// Bit CTSN.
	UART0_UART_STATUS_CTSN = 0x4000
	// Position of DSRN field.
	UART0_UART_STATUS_DSRN_Pos = 0xd
	// Bit mask of DSRN field.
	UART0_UART_STATUS_DSRN_Msk = 0x2000
	// Bit DSRN.
	UART0_UART_STATUS_DSRN = 0x2000
	// Position of RXFIFO_CNT field.
	UART0_UART_STATUS_RXFIFO_CNT_Pos = 0x0
	// Bit mask of RXFIFO_CNT field.
	UART0_UART_STATUS_RXFIFO_CNT_Msk = 0xff

	// UART_CONF0: UART CONFIG0(UART0 and UART1)
	// Position of UART_DTR_INV field.
	UART0_UART_CONF0_UART_DTR_INV_Pos = 0x18
	// Bit mask of UART_DTR_INV field.
	UART0_UART_CONF0_UART_DTR_INV_Msk = 0x1000000
	// Bit UART_DTR_INV.
	UART0_UART_CONF0_UART_DTR_INV = 0x1000000
	// Position of UART_RTS_INV field.
	UART0_UART_CONF0_UART_RTS_INV_Pos = 0x17
	// Bit mask of UART_RTS_INV field.
	UART0_UART_CONF0_UART_RTS_INV_Msk = 0x800000
	// Bit UART_RTS_INV.
	UART0_UART_CONF0_UART_RTS_INV = 0x800000
	// Position of UART_TXD_INV field.
	UART0_UART_CONF0_UART_TXD_INV_Pos = 0x16
	// Bit mask of UART_TXD_INV field.
	UART0_UART_CONF0_UART_TXD_INV_Msk = 0x400000
	// Bit UART_TXD_INV.
	UART0_UART_CONF0_UART_TXD_INV = 0x400000
	// Position of UART_DSR_INV field.
	UART0_UART_CONF0_UART_DSR_INV_Pos = 0x15
	// Bit mask of UART_DSR_INV field.
	UART0_UART_CONF0_UART_DSR_INV_Msk = 0x200000
	// Bit UART_DSR_INV.
	UART0_UART_CONF0_UART_DSR_INV = 0x200000
	// Position of UART_CTS_INV field.
	UART0_UART_CONF0_UART_CTS_INV_Pos = 0x14
	// Bit mask of UART_CTS_INV field.
	UART0_UART_CONF0_UART_CTS_INV_Msk = 0x100000
	// Bit UART_CTS_INV.
	UART0_UART_CONF0_UART_CTS_INV = 0x100000
	// Position of UART_RXD_INV field.
	UART0_UART_CONF0_UART_RXD_INV_Pos = 0x13
	// Bit mask of UART_RXD_INV field.
	UART0_UART_CONF0_UART_RXD_INV_Msk = 0x80000
	// Bit UART_RXD_INV.
	UART0_UART_CONF0_UART_RXD_INV = 0x80000
	// Position of TXFIFO_RST field.
	UART0_UART_CONF0_TXFIFO_RST_Pos = 0x12
	// Bit mask of TXFIFO_RST field.
	UART0_UART_CONF0_TXFIFO_RST_Msk = 0x40000
	// Bit TXFIFO_RST.
	UART0_UART_CONF0_TXFIFO_RST = 0x40000
	// Position of RXFIFO_RST field.
	UART0_UART_CONF0_RXFIFO_RST_Pos = 0x11
	// Bit mask of RXFIFO_RST field.
	UART0_UART_CONF0_RXFIFO_RST_Msk = 0x20000
	// Bit RXFIFO_RST.
	UART0_UART_CONF0_RXFIFO_RST = 0x20000
	// Position of TX_FLOW_EN field.
	UART0_UART_CONF0_TX_FLOW_EN_Pos = 0xf
	// Bit mask of TX_FLOW_EN field.
	UART0_UART_CONF0_TX_FLOW_EN_Msk = 0x8000
	// Bit TX_FLOW_EN.
	UART0_UART_CONF0_TX_FLOW_EN = 0x8000
	// Position of UART_LOOPBACK field.
	UART0_UART_CONF0_UART_LOOPBACK_Pos = 0xe
	// Bit mask of UART_LOOPBACK field.
	UART0_UART_CONF0_UART_LOOPBACK_Msk = 0x4000
	// Bit UART_LOOPBACK.
	UART0_UART_CONF0_UART_LOOPBACK = 0x4000
	// Position of TXD_BRK field.
	UART0_UART_CONF0_TXD_BRK_Pos = 0x8
	// Bit mask of TXD_BRK field.
	UART0_UART_CONF0_TXD_BRK_Msk = 0x100
	// Bit TXD_BRK.
	UART0_UART_CONF0_TXD_BRK = 0x100
	// Position of SW_DTR field.
	UART0_UART_CONF0_SW_DTR_Pos = 0x7
	// Bit mask of SW_DTR field.
	UART0_UART_CONF0_SW_DTR_Msk = 0x80
	// Bit SW_DTR.
	UART0_UART_CONF0_SW_DTR = 0x80
	// Position of SW_RTS field.
	UART0_UART_CONF0_SW_RTS_Pos = 0x6
	// Bit mask of SW_RTS field.
	UART0_UART_CONF0_SW_RTS_Msk = 0x40
	// Bit SW_RTS.
	UART0_UART_CONF0_SW_RTS = 0x40
	// Position of STOP_BIT_NUM field.
	UART0_UART_CONF0_STOP_BIT_NUM_Pos = 0x4
	// Bit mask of STOP_BIT_NUM field.
	UART0_UART_CONF0_STOP_BIT_NUM_Msk = 0x30
	// Position of BIT_NUM field.
	UART0_UART_CONF0_BIT_NUM_Pos = 0x2
	// Bit mask of BIT_NUM field.
	UART0_UART_CONF0_BIT_NUM_Msk = 0xc
	// Position of PARITY_EN field.
	UART0_UART_CONF0_PARITY_EN_Pos = 0x1
	// Bit mask of PARITY_EN field.
	UART0_UART_CONF0_PARITY_EN_Msk = 0x2
	// Bit PARITY_EN.
	UART0_UART_CONF0_PARITY_EN = 0x2
	// Position of PARITY field.
	UART0_UART_CONF0_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	UART0_UART_CONF0_PARITY_Msk = 0x1
	// Bit PARITY.
	UART0_UART_CONF0_PARITY = 0x1

	// UART_CONF1: Set this bit to enable rx time-out function
	// Position of RX_TOUT_EN field.
	UART0_UART_CONF1_RX_TOUT_EN_Pos = 0x1f
	// Bit mask of RX_TOUT_EN field.
	UART0_UART_CONF1_RX_TOUT_EN_Msk = 0x80000000
	// Bit RX_TOUT_EN.
	UART0_UART_CONF1_RX_TOUT_EN = 0x80000000
	// Position of RX_TOUT_THRHD field.
	UART0_UART_CONF1_RX_TOUT_THRHD_Pos = 0x18
	// Bit mask of RX_TOUT_THRHD field.
	UART0_UART_CONF1_RX_TOUT_THRHD_Msk = 0x7f000000
	// Position of RX_FLOW_EN field.
	UART0_UART_CONF1_RX_FLOW_EN_Pos = 0x17
	// Bit mask of RX_FLOW_EN field.
	UART0_UART_CONF1_RX_FLOW_EN_Msk = 0x800000
	// Bit RX_FLOW_EN.
	UART0_UART_CONF1_RX_FLOW_EN = 0x800000
	// Position of RX_FLOW_THRHD field.
	UART0_UART_CONF1_RX_FLOW_THRHD_Pos = 0x10
	// Bit mask of RX_FLOW_THRHD field.
	UART0_UART_CONF1_RX_FLOW_THRHD_Msk = 0x7f0000
	// Position of TXFIFO_EMPTY_THRHD field.
	UART0_UART_CONF1_TXFIFO_EMPTY_THRHD_Pos = 0x8
	// Bit mask of TXFIFO_EMPTY_THRHD field.
	UART0_UART_CONF1_TXFIFO_EMPTY_THRHD_Msk = 0x7f00
	// Position of RXFIFO_FULL_THRHD field.
	UART0_UART_CONF1_RXFIFO_FULL_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_FULL_THRHD field.
	UART0_UART_CONF1_RXFIFO_FULL_THRHD_Msk = 0x7f

	// UART_LOWPULSE: UART_LOWPULSE
	// Position of LOWPULSE_MIN_CNT field.
	UART0_UART_LOWPULSE_LOWPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of LOWPULSE_MIN_CNT field.
	UART0_UART_LOWPULSE_LOWPULSE_MIN_CNT_Msk = 0xfffff

	// UART_HIGHPULSE: UART_HIGHPULSE
	// Position of HIGHPULSE_MIN_CNT field.
	UART0_UART_HIGHPULSE_HIGHPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of HIGHPULSE_MIN_CNT field.
	UART0_UART_HIGHPULSE_HIGHPULSE_MIN_CNT_Msk = 0xfffff

	// UART_RXD_CNT: UART_RXD_CNT
	// Position of RXD_EDGE_CNT field.
	UART0_UART_RXD_CNT_RXD_EDGE_CNT_Pos = 0x0
	// Bit mask of RXD_EDGE_CNT field.
	UART0_UART_RXD_CNT_RXD_EDGE_CNT_Msk = 0x3ff

	// UART_DATE: UART HW INFO
	// Position of UART_DATE field.
	UART0_UART_DATE_UART_DATE_Pos = 0x0
	// Bit mask of UART_DATE field.
	UART0_UART_DATE_UART_DATE_Msk = 0xffffffff

	// UART_ID: UART_ID
	// Position of UART_ID field.
	UART0_UART_ID_UART_ID_Pos = 0x0
	// Bit mask of UART_ID field.
	UART0_UART_ID_UART_ID_Msk = 0xffffffff
)

// Constants for UART1
const (
	// UART_FIFO: UART FIFO,length 128
	// Position of RXFIFO_RD_BYTE field.
	UART1_UART_FIFO_RXFIFO_RD_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_RD_BYTE field.
	UART1_UART_FIFO_RXFIFO_RD_BYTE_Msk = 0xff
	// Position of RXFIFO_WRITE_BYTE field.
	UART1_UART_FIFO_RXFIFO_WRITE_BYTE_Pos = 0x0
	// Bit mask of RXFIFO_WRITE_BYTE field.
	UART1_UART_FIFO_RXFIFO_WRITE_BYTE_Msk = 0xff

	// UART_INT_RAW: UART INTERRUPT RAW STATE
	// Position of RXFIFO_TOUT_INT_RAW field.
	UART1_UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_RAW field.
	UART1_UART_INT_RAW_RXFIFO_TOUT_INT_RAW_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_RAW.
	UART1_UART_INT_RAW_RXFIFO_TOUT_INT_RAW = 0x100
	// Position of BRK_DET_INT_RAW field.
	UART1_UART_INT_RAW_BRK_DET_INT_RAW_Pos = 0x7
	// Bit mask of BRK_DET_INT_RAW field.
	UART1_UART_INT_RAW_BRK_DET_INT_RAW_Msk = 0x80
	// Bit BRK_DET_INT_RAW.
	UART1_UART_INT_RAW_BRK_DET_INT_RAW = 0x80
	// Position of CTS_CHG_INT_RAW field.
	UART1_UART_INT_RAW_CTS_CHG_INT_RAW_Pos = 0x6
	// Bit mask of CTS_CHG_INT_RAW field.
	UART1_UART_INT_RAW_CTS_CHG_INT_RAW_Msk = 0x40
	// Bit CTS_CHG_INT_RAW.
	UART1_UART_INT_RAW_CTS_CHG_INT_RAW = 0x40
	// Position of DSR_CHG_INT_RAW field.
	UART1_UART_INT_RAW_DSR_CHG_INT_RAW_Pos = 0x5
	// Bit mask of DSR_CHG_INT_RAW field.
	UART1_UART_INT_RAW_DSR_CHG_INT_RAW_Msk = 0x20
	// Bit DSR_CHG_INT_RAW.
	UART1_UART_INT_RAW_DSR_CHG_INT_RAW = 0x20
	// Position of RXFIFO_OVF_INT_RAW field.
	UART1_UART_INT_RAW_RXFIFO_OVF_INT_RAW_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_RAW field.
	UART1_UART_INT_RAW_RXFIFO_OVF_INT_RAW_Msk = 0x10
	// Bit RXFIFO_OVF_INT_RAW.
	UART1_UART_INT_RAW_RXFIFO_OVF_INT_RAW = 0x10
	// Position of FRM_ERR_INT_RAW field.
	UART1_UART_INT_RAW_FRM_ERR_INT_RAW_Pos = 0x3
	// Bit mask of FRM_ERR_INT_RAW field.
	UART1_UART_INT_RAW_FRM_ERR_INT_RAW_Msk = 0x8
	// Bit FRM_ERR_INT_RAW.
	UART1_UART_INT_RAW_FRM_ERR_INT_RAW = 0x8
	// Position of PARITY_ERR_INT_RAW field.
	UART1_UART_INT_RAW_PARITY_ERR_INT_RAW_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_RAW field.
	UART1_UART_INT_RAW_PARITY_ERR_INT_RAW_Msk = 0x4
	// Bit PARITY_ERR_INT_RAW.
	UART1_UART_INT_RAW_PARITY_ERR_INT_RAW = 0x4
	// Position of TXFIFO_EMPTY_INT_RAW field.
	UART1_UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_RAW field.
	UART1_UART_INT_RAW_TXFIFO_EMPTY_INT_RAW_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_RAW.
	UART1_UART_INT_RAW_TXFIFO_EMPTY_INT_RAW = 0x2
	// Position of RXFIFO_FULL_INT_RAW field.
	UART1_UART_INT_RAW_RXFIFO_FULL_INT_RAW_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_RAW field.
	UART1_UART_INT_RAW_RXFIFO_FULL_INT_RAW_Msk = 0x1
	// Bit RXFIFO_FULL_INT_RAW.
	UART1_UART_INT_RAW_RXFIFO_FULL_INT_RAW = 0x1

	// UART_INT_ST: UART INTERRUPT STATEREGISTERUART_INT_RAW&UART_INT_ENA
	// Position of RXFIFO_TOUT_INT_ST field.
	UART1_UART_INT_ST_RXFIFO_TOUT_INT_ST_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ST field.
	UART1_UART_INT_ST_RXFIFO_TOUT_INT_ST_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ST.
	UART1_UART_INT_ST_RXFIFO_TOUT_INT_ST = 0x100
	// Position of BRK_DET_INT_ST field.
	UART1_UART_INT_ST_BRK_DET_INT_ST_Pos = 0x7
	// Bit mask of BRK_DET_INT_ST field.
	UART1_UART_INT_ST_BRK_DET_INT_ST_Msk = 0x80
	// Bit BRK_DET_INT_ST.
	UART1_UART_INT_ST_BRK_DET_INT_ST = 0x80
	// Position of CTS_CHG_INT_ST field.
	UART1_UART_INT_ST_CTS_CHG_INT_ST_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ST field.
	UART1_UART_INT_ST_CTS_CHG_INT_ST_Msk = 0x40
	// Bit CTS_CHG_INT_ST.
	UART1_UART_INT_ST_CTS_CHG_INT_ST = 0x40
	// Position of DSR_CHG_INT_ST field.
	UART1_UART_INT_ST_DSR_CHG_INT_ST_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ST field.
	UART1_UART_INT_ST_DSR_CHG_INT_ST_Msk = 0x20
	// Bit DSR_CHG_INT_ST.
	UART1_UART_INT_ST_DSR_CHG_INT_ST = 0x20
	// Position of RXFIFO_OVF_INT_ST field.
	UART1_UART_INT_ST_RXFIFO_OVF_INT_ST_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ST field.
	UART1_UART_INT_ST_RXFIFO_OVF_INT_ST_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ST.
	UART1_UART_INT_ST_RXFIFO_OVF_INT_ST = 0x10
	// Position of FRM_ERR_INT_ST field.
	UART1_UART_INT_ST_FRM_ERR_INT_ST_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ST field.
	UART1_UART_INT_ST_FRM_ERR_INT_ST_Msk = 0x8
	// Bit FRM_ERR_INT_ST.
	UART1_UART_INT_ST_FRM_ERR_INT_ST = 0x8
	// Position of PARITY_ERR_INT_ST field.
	UART1_UART_INT_ST_PARITY_ERR_INT_ST_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ST field.
	UART1_UART_INT_ST_PARITY_ERR_INT_ST_Msk = 0x4
	// Bit PARITY_ERR_INT_ST.
	UART1_UART_INT_ST_PARITY_ERR_INT_ST = 0x4
	// Position of TXFIFO_EMPTY_INT_ST field.
	UART1_UART_INT_ST_TXFIFO_EMPTY_INT_ST_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ST field.
	UART1_UART_INT_ST_TXFIFO_EMPTY_INT_ST_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ST.
	UART1_UART_INT_ST_TXFIFO_EMPTY_INT_ST = 0x2
	// Position of RXFIFO_FULL_INT_ST field.
	UART1_UART_INT_ST_RXFIFO_FULL_INT_ST_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ST field.
	UART1_UART_INT_ST_RXFIFO_FULL_INT_ST_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ST.
	UART1_UART_INT_ST_RXFIFO_FULL_INT_ST = 0x1

	// UART_INT_ENA: UART INTERRUPT ENABLE REGISTER
	// Position of RXFIFO_TOUT_INT_ENA field.
	UART1_UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_ENA field.
	UART1_UART_INT_ENA_RXFIFO_TOUT_INT_ENA_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_ENA.
	UART1_UART_INT_ENA_RXFIFO_TOUT_INT_ENA = 0x100
	// Position of BRK_DET_INT_ENA field.
	UART1_UART_INT_ENA_BRK_DET_INT_ENA_Pos = 0x7
	// Bit mask of BRK_DET_INT_ENA field.
	UART1_UART_INT_ENA_BRK_DET_INT_ENA_Msk = 0x80
	// Bit BRK_DET_INT_ENA.
	UART1_UART_INT_ENA_BRK_DET_INT_ENA = 0x80
	// Position of CTS_CHG_INT_ENA field.
	UART1_UART_INT_ENA_CTS_CHG_INT_ENA_Pos = 0x6
	// Bit mask of CTS_CHG_INT_ENA field.
	UART1_UART_INT_ENA_CTS_CHG_INT_ENA_Msk = 0x40
	// Bit CTS_CHG_INT_ENA.
	UART1_UART_INT_ENA_CTS_CHG_INT_ENA = 0x40
	// Position of DSR_CHG_INT_ENA field.
	UART1_UART_INT_ENA_DSR_CHG_INT_ENA_Pos = 0x5
	// Bit mask of DSR_CHG_INT_ENA field.
	UART1_UART_INT_ENA_DSR_CHG_INT_ENA_Msk = 0x20
	// Bit DSR_CHG_INT_ENA.
	UART1_UART_INT_ENA_DSR_CHG_INT_ENA = 0x20
	// Position of RXFIFO_OVF_INT_ENA field.
	UART1_UART_INT_ENA_RXFIFO_OVF_INT_ENA_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_ENA field.
	UART1_UART_INT_ENA_RXFIFO_OVF_INT_ENA_Msk = 0x10
	// Bit RXFIFO_OVF_INT_ENA.
	UART1_UART_INT_ENA_RXFIFO_OVF_INT_ENA = 0x10
	// Position of FRM_ERR_INT_ENA field.
	UART1_UART_INT_ENA_FRM_ERR_INT_ENA_Pos = 0x3
	// Bit mask of FRM_ERR_INT_ENA field.
	UART1_UART_INT_ENA_FRM_ERR_INT_ENA_Msk = 0x8
	// Bit FRM_ERR_INT_ENA.
	UART1_UART_INT_ENA_FRM_ERR_INT_ENA = 0x8
	// Position of PARITY_ERR_INT_ENA field.
	UART1_UART_INT_ENA_PARITY_ERR_INT_ENA_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_ENA field.
	UART1_UART_INT_ENA_PARITY_ERR_INT_ENA_Msk = 0x4
	// Bit PARITY_ERR_INT_ENA.
	UART1_UART_INT_ENA_PARITY_ERR_INT_ENA = 0x4
	// Position of TXFIFO_EMPTY_INT_ENA field.
	UART1_UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_ENA field.
	UART1_UART_INT_ENA_TXFIFO_EMPTY_INT_ENA_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_ENA.
	UART1_UART_INT_ENA_TXFIFO_EMPTY_INT_ENA = 0x2
	// Position of RXFIFO_FULL_INT_ENA field.
	UART1_UART_INT_ENA_RXFIFO_FULL_INT_ENA_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_ENA field.
	UART1_UART_INT_ENA_RXFIFO_FULL_INT_ENA_Msk = 0x1
	// Bit RXFIFO_FULL_INT_ENA.
	UART1_UART_INT_ENA_RXFIFO_FULL_INT_ENA = 0x1

	// UART_INT_CLR: UART INTERRUPT CLEAR REGISTER
	// Position of RXFIFO_TOUT_INT_CLR field.
	UART1_UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Pos = 0x8
	// Bit mask of RXFIFO_TOUT_INT_CLR field.
	UART1_UART_INT_CLR_RXFIFO_TOUT_INT_CLR_Msk = 0x100
	// Bit RXFIFO_TOUT_INT_CLR.
	UART1_UART_INT_CLR_RXFIFO_TOUT_INT_CLR = 0x100
	// Position of BRK_DET_INT_CLR field.
	UART1_UART_INT_CLR_BRK_DET_INT_CLR_Pos = 0x7
	// Bit mask of BRK_DET_INT_CLR field.
	UART1_UART_INT_CLR_BRK_DET_INT_CLR_Msk = 0x80
	// Bit BRK_DET_INT_CLR.
	UART1_UART_INT_CLR_BRK_DET_INT_CLR = 0x80
	// Position of CTS_CHG_INT_CLR field.
	UART1_UART_INT_CLR_CTS_CHG_INT_CLR_Pos = 0x6
	// Bit mask of CTS_CHG_INT_CLR field.
	UART1_UART_INT_CLR_CTS_CHG_INT_CLR_Msk = 0x40
	// Bit CTS_CHG_INT_CLR.
	UART1_UART_INT_CLR_CTS_CHG_INT_CLR = 0x40
	// Position of DSR_CHG_INT_CLR field.
	UART1_UART_INT_CLR_DSR_CHG_INT_CLR_Pos = 0x5
	// Bit mask of DSR_CHG_INT_CLR field.
	UART1_UART_INT_CLR_DSR_CHG_INT_CLR_Msk = 0x20
	// Bit DSR_CHG_INT_CLR.
	UART1_UART_INT_CLR_DSR_CHG_INT_CLR = 0x20
	// Position of RXFIFO_OVF_INT_CLR field.
	UART1_UART_INT_CLR_RXFIFO_OVF_INT_CLR_Pos = 0x4
	// Bit mask of RXFIFO_OVF_INT_CLR field.
	UART1_UART_INT_CLR_RXFIFO_OVF_INT_CLR_Msk = 0x10
	// Bit RXFIFO_OVF_INT_CLR.
	UART1_UART_INT_CLR_RXFIFO_OVF_INT_CLR = 0x10
	// Position of FRM_ERR_INT_CLR field.
	UART1_UART_INT_CLR_FRM_ERR_INT_CLR_Pos = 0x3
	// Bit mask of FRM_ERR_INT_CLR field.
	UART1_UART_INT_CLR_FRM_ERR_INT_CLR_Msk = 0x8
	// Bit FRM_ERR_INT_CLR.
	UART1_UART_INT_CLR_FRM_ERR_INT_CLR = 0x8
	// Position of PARITY_ERR_INT_CLR field.
	UART1_UART_INT_CLR_PARITY_ERR_INT_CLR_Pos = 0x2
	// Bit mask of PARITY_ERR_INT_CLR field.
	UART1_UART_INT_CLR_PARITY_ERR_INT_CLR_Msk = 0x4
	// Bit PARITY_ERR_INT_CLR.
	UART1_UART_INT_CLR_PARITY_ERR_INT_CLR = 0x4
	// Position of TXFIFO_EMPTY_INT_CLR field.
	UART1_UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Pos = 0x1
	// Bit mask of TXFIFO_EMPTY_INT_CLR field.
	UART1_UART_INT_CLR_TXFIFO_EMPTY_INT_CLR_Msk = 0x2
	// Bit TXFIFO_EMPTY_INT_CLR.
	UART1_UART_INT_CLR_TXFIFO_EMPTY_INT_CLR = 0x2
	// Position of RXFIFO_FULL_INT_CLR field.
	UART1_UART_INT_CLR_RXFIFO_FULL_INT_CLR_Pos = 0x0
	// Bit mask of RXFIFO_FULL_INT_CLR field.
	UART1_UART_INT_CLR_RXFIFO_FULL_INT_CLR_Msk = 0x1
	// Bit RXFIFO_FULL_INT_CLR.
	UART1_UART_INT_CLR_RXFIFO_FULL_INT_CLR = 0x1

	// UART_CLKDIV: UART CLK DIV REGISTER
	// Position of UART_CLKDIV field.
	UART1_UART_CLKDIV_UART_CLKDIV_Pos = 0x0
	// Bit mask of UART_CLKDIV field.
	UART1_UART_CLKDIV_UART_CLKDIV_Msk = 0xfffff

	// UART_AUTOBAUD: UART BAUDRATE DETECT REGISTER
	// Position of GLITCH_FILT field.
	UART1_UART_AUTOBAUD_GLITCH_FILT_Pos = 0x8
	// Bit mask of GLITCH_FILT field.
	UART1_UART_AUTOBAUD_GLITCH_FILT_Msk = 0xff00
	// Position of AUTOBAUD_EN field.
	UART1_UART_AUTOBAUD_AUTOBAUD_EN_Pos = 0x0
	// Bit mask of AUTOBAUD_EN field.
	UART1_UART_AUTOBAUD_AUTOBAUD_EN_Msk = 0x1
	// Bit AUTOBAUD_EN.
	UART1_UART_AUTOBAUD_AUTOBAUD_EN = 0x1

	// UART_STATUS: UART STATUS REGISTER
	// Position of TXD field.
	UART1_UART_STATUS_TXD_Pos = 0x1f
	// Bit mask of TXD field.
	UART1_UART_STATUS_TXD_Msk = 0x80000000
	// Bit TXD.
	UART1_UART_STATUS_TXD = 0x80000000
	// Position of RTSN field.
	UART1_UART_STATUS_RTSN_Pos = 0x1e
	// Bit mask of RTSN field.
	UART1_UART_STATUS_RTSN_Msk = 0x40000000
	// Bit RTSN.
	UART1_UART_STATUS_RTSN = 0x40000000
	// Position of DTRN field.
	UART1_UART_STATUS_DTRN_Pos = 0x1d
	// Bit mask of DTRN field.
	UART1_UART_STATUS_DTRN_Msk = 0x20000000
	// Bit DTRN.
	UART1_UART_STATUS_DTRN = 0x20000000
	// Position of TXFIFO_CNT field.
	UART1_UART_STATUS_TXFIFO_CNT_Pos = 0x10
	// Bit mask of TXFIFO_CNT field.
	UART1_UART_STATUS_TXFIFO_CNT_Msk = 0xff0000
	// Position of RXD field.
	UART1_UART_STATUS_RXD_Pos = 0xf
	// Bit mask of RXD field.
	UART1_UART_STATUS_RXD_Msk = 0x8000
	// Bit RXD.
	UART1_UART_STATUS_RXD = 0x8000
	// Position of CTSN field.
	UART1_UART_STATUS_CTSN_Pos = 0xe
	// Bit mask of CTSN field.
	UART1_UART_STATUS_CTSN_Msk = 0x4000
	// Bit CTSN.
	UART1_UART_STATUS_CTSN = 0x4000
	// Position of DSRN field.
	UART1_UART_STATUS_DSRN_Pos = 0xd
	// Bit mask of DSRN field.
	UART1_UART_STATUS_DSRN_Msk = 0x2000
	// Bit DSRN.
	UART1_UART_STATUS_DSRN = 0x2000
	// Position of RXFIFO_CNT field.
	UART1_UART_STATUS_RXFIFO_CNT_Pos = 0x0
	// Bit mask of RXFIFO_CNT field.
	UART1_UART_STATUS_RXFIFO_CNT_Msk = 0xff

	// UART_CONF0: UART CONFIG0(UART0 and UART1)
	// Position of UART_DTR_INV field.
	UART1_UART_CONF0_UART_DTR_INV_Pos = 0x18
	// Bit mask of UART_DTR_INV field.
	UART1_UART_CONF0_UART_DTR_INV_Msk = 0x1000000
	// Bit UART_DTR_INV.
	UART1_UART_CONF0_UART_DTR_INV = 0x1000000
	// Position of UART_RTS_INV field.
	UART1_UART_CONF0_UART_RTS_INV_Pos = 0x17
	// Bit mask of UART_RTS_INV field.
	UART1_UART_CONF0_UART_RTS_INV_Msk = 0x800000
	// Bit UART_RTS_INV.
	UART1_UART_CONF0_UART_RTS_INV = 0x800000
	// Position of UART_TXD_INV field.
	UART1_UART_CONF0_UART_TXD_INV_Pos = 0x16
	// Bit mask of UART_TXD_INV field.
	UART1_UART_CONF0_UART_TXD_INV_Msk = 0x400000
	// Bit UART_TXD_INV.
	UART1_UART_CONF0_UART_TXD_INV = 0x400000
	// Position of UART_DSR_INV field.
	UART1_UART_CONF0_UART_DSR_INV_Pos = 0x15
	// Bit mask of UART_DSR_INV field.
	UART1_UART_CONF0_UART_DSR_INV_Msk = 0x200000
	// Bit UART_DSR_INV.
	UART1_UART_CONF0_UART_DSR_INV = 0x200000
	// Position of UART_CTS_INV field.
	UART1_UART_CONF0_UART_CTS_INV_Pos = 0x14
	// Bit mask of UART_CTS_INV field.
	UART1_UART_CONF0_UART_CTS_INV_Msk = 0x100000
	// Bit UART_CTS_INV.
	UART1_UART_CONF0_UART_CTS_INV = 0x100000
	// Position of UART_RXD_INV field.
	UART1_UART_CONF0_UART_RXD_INV_Pos = 0x13
	// Bit mask of UART_RXD_INV field.
	UART1_UART_CONF0_UART_RXD_INV_Msk = 0x80000
	// Bit UART_RXD_INV.
	UART1_UART_CONF0_UART_RXD_INV = 0x80000
	// Position of TXFIFO_RST field.
	UART1_UART_CONF0_TXFIFO_RST_Pos = 0x12
	// Bit mask of TXFIFO_RST field.
	UART1_UART_CONF0_TXFIFO_RST_Msk = 0x40000
	// Bit TXFIFO_RST.
	UART1_UART_CONF0_TXFIFO_RST = 0x40000
	// Position of RXFIFO_RST field.
	UART1_UART_CONF0_RXFIFO_RST_Pos = 0x11
	// Bit mask of RXFIFO_RST field.
	UART1_UART_CONF0_RXFIFO_RST_Msk = 0x20000
	// Bit RXFIFO_RST.
	UART1_UART_CONF0_RXFIFO_RST = 0x20000
	// Position of TX_FLOW_EN field.
	UART1_UART_CONF0_TX_FLOW_EN_Pos = 0xf
	// Bit mask of TX_FLOW_EN field.
	UART1_UART_CONF0_TX_FLOW_EN_Msk = 0x8000
	// Bit TX_FLOW_EN.
	UART1_UART_CONF0_TX_FLOW_EN = 0x8000
	// Position of UART_LOOPBACK field.
	UART1_UART_CONF0_UART_LOOPBACK_Pos = 0xe
	// Bit mask of UART_LOOPBACK field.
	UART1_UART_CONF0_UART_LOOPBACK_Msk = 0x4000
	// Bit UART_LOOPBACK.
	UART1_UART_CONF0_UART_LOOPBACK = 0x4000
	// Position of TXD_BRK field.
	UART1_UART_CONF0_TXD_BRK_Pos = 0x8
	// Bit mask of TXD_BRK field.
	UART1_UART_CONF0_TXD_BRK_Msk = 0x100
	// Bit TXD_BRK.
	UART1_UART_CONF0_TXD_BRK = 0x100
	// Position of SW_DTR field.
	UART1_UART_CONF0_SW_DTR_Pos = 0x7
	// Bit mask of SW_DTR field.
	UART1_UART_CONF0_SW_DTR_Msk = 0x80
	// Bit SW_DTR.
	UART1_UART_CONF0_SW_DTR = 0x80
	// Position of SW_RTS field.
	UART1_UART_CONF0_SW_RTS_Pos = 0x6
	// Bit mask of SW_RTS field.
	UART1_UART_CONF0_SW_RTS_Msk = 0x40
	// Bit SW_RTS.
	UART1_UART_CONF0_SW_RTS = 0x40
	// Position of STOP_BIT_NUM field.
	UART1_UART_CONF0_STOP_BIT_NUM_Pos = 0x4
	// Bit mask of STOP_BIT_NUM field.
	UART1_UART_CONF0_STOP_BIT_NUM_Msk = 0x30
	// Position of BIT_NUM field.
	UART1_UART_CONF0_BIT_NUM_Pos = 0x2
	// Bit mask of BIT_NUM field.
	UART1_UART_CONF0_BIT_NUM_Msk = 0xc
	// Position of PARITY_EN field.
	UART1_UART_CONF0_PARITY_EN_Pos = 0x1
	// Bit mask of PARITY_EN field.
	UART1_UART_CONF0_PARITY_EN_Msk = 0x2
	// Bit PARITY_EN.
	UART1_UART_CONF0_PARITY_EN = 0x2
	// Position of PARITY field.
	UART1_UART_CONF0_PARITY_Pos = 0x0
	// Bit mask of PARITY field.
	UART1_UART_CONF0_PARITY_Msk = 0x1
	// Bit PARITY.
	UART1_UART_CONF0_PARITY = 0x1

	// UART_CONF1: Set this bit to enable rx time-out function
	// Position of RX_TOUT_EN field.
	UART1_UART_CONF1_RX_TOUT_EN_Pos = 0x1f
	// Bit mask of RX_TOUT_EN field.
	UART1_UART_CONF1_RX_TOUT_EN_Msk = 0x80000000
	// Bit RX_TOUT_EN.
	UART1_UART_CONF1_RX_TOUT_EN = 0x80000000
	// Position of RX_TOUT_THRHD field.
	UART1_UART_CONF1_RX_TOUT_THRHD_Pos = 0x18
	// Bit mask of RX_TOUT_THRHD field.
	UART1_UART_CONF1_RX_TOUT_THRHD_Msk = 0x7f000000
	// Position of RX_FLOW_EN field.
	UART1_UART_CONF1_RX_FLOW_EN_Pos = 0x17
	// Bit mask of RX_FLOW_EN field.
	UART1_UART_CONF1_RX_FLOW_EN_Msk = 0x800000
	// Bit RX_FLOW_EN.
	UART1_UART_CONF1_RX_FLOW_EN = 0x800000
	// Position of RX_FLOW_THRHD field.
	UART1_UART_CONF1_RX_FLOW_THRHD_Pos = 0x10
	// Bit mask of RX_FLOW_THRHD field.
	UART1_UART_CONF1_RX_FLOW_THRHD_Msk = 0x7f0000
	// Position of TXFIFO_EMPTY_THRHD field.
	UART1_UART_CONF1_TXFIFO_EMPTY_THRHD_Pos = 0x8
	// Bit mask of TXFIFO_EMPTY_THRHD field.
	UART1_UART_CONF1_TXFIFO_EMPTY_THRHD_Msk = 0x7f00
	// Position of RXFIFO_FULL_THRHD field.
	UART1_UART_CONF1_RXFIFO_FULL_THRHD_Pos = 0x0
	// Bit mask of RXFIFO_FULL_THRHD field.
	UART1_UART_CONF1_RXFIFO_FULL_THRHD_Msk = 0x7f

	// UART_LOWPULSE: UART_LOWPULSE
	// Position of LOWPULSE_MIN_CNT field.
	UART1_UART_LOWPULSE_LOWPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of LOWPULSE_MIN_CNT field.
	UART1_UART_LOWPULSE_LOWPULSE_MIN_CNT_Msk = 0xfffff

	// UART_HIGHPULSE: UART_HIGHPULSE
	// Position of HIGHPULSE_MIN_CNT field.
	UART1_UART_HIGHPULSE_HIGHPULSE_MIN_CNT_Pos = 0x0
	// Bit mask of HIGHPULSE_MIN_CNT field.
	UART1_UART_HIGHPULSE_HIGHPULSE_MIN_CNT_Msk = 0xfffff

	// UART_RXD_CNT: UART_RXD_CNT
	// Position of RXD_EDGE_CNT field.
	UART1_UART_RXD_CNT_RXD_EDGE_CNT_Pos = 0x0
	// Bit mask of RXD_EDGE_CNT field.
	UART1_UART_RXD_CNT_RXD_EDGE_CNT_Msk = 0x3ff

	// UART_DATE: UART HW INFO
	// Position of UART_DATE field.
	UART1_UART_DATE_UART_DATE_Pos = 0x0
	// Bit mask of UART_DATE field.
	UART1_UART_DATE_UART_DATE_Msk = 0xffffffff

	// UART_ID: UART_ID
	// Position of UART_ID field.
	UART1_UART_ID_UART_ID_Pos = 0x0
	// Bit mask of UART_ID field.
	UART1_UART_ID_UART_ID_Msk = 0xffffffff
)

// Constants for WDT
const (
	// WDT_CTL: WDT_CTL
	// Position of Register field.
	WDT_WDT_CTL_Register_Pos = 0x0
	// Bit mask of Register field.
	WDT_WDT_CTL_Register_Msk = 0xffffffff

	// WDT_OP: WDT_OP
	// Position of Register field.
	WDT_WDT_OP_Register_Pos = 0x0
	// Bit mask of Register field.
	WDT_WDT_OP_Register_Msk = 0xffffffff

	// WDT_OP_ND: WDT_OP_ND
	// Position of Register field.
	WDT_WDT_OP_ND_Register_Pos = 0x0
	// Bit mask of Register field.
	WDT_WDT_OP_ND_Register_Msk = 0xffffffff

	// WDT_RST: WDT_RST
	// Position of Register field.
	WDT_WDT_RST_Register_Pos = 0x0
	// Bit mask of Register field.
	WDT_WDT_RST_Register_Msk = 0xffffffff
)

// Constants for RNG: RNG register
const ()

// Constants for WATCHDOG: Watchdog registers
const (
	// CTL: Watchdog control
	// Position of ENABLE field.
	WATCHDOG_CTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	WATCHDOG_CTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	WATCHDOG_CTL_ENABLE = 0x1
	// Position of STAGE_1_NO_RESET field.
	WATCHDOG_CTL_STAGE_1_NO_RESET_Pos = 0x1
	// Bit mask of STAGE_1_NO_RESET field.
	WATCHDOG_CTL_STAGE_1_NO_RESET_Msk = 0x2
	// Bit STAGE_1_NO_RESET.
	WATCHDOG_CTL_STAGE_1_NO_RESET = 0x2
	// Position of STAGE_1_DISABLE field.
	WATCHDOG_CTL_STAGE_1_DISABLE_Pos = 0x2
	// Bit mask of STAGE_1_DISABLE field.
	WATCHDOG_CTL_STAGE_1_DISABLE_Msk = 0x4
	// Bit STAGE_1_DISABLE.
	WATCHDOG_CTL_STAGE_1_DISABLE = 0x4
	// Position of UNKNOWN_3 field.
	WATCHDOG_CTL_UNKNOWN_3_Pos = 0x3
	// Bit mask of UNKNOWN_3 field.
	WATCHDOG_CTL_UNKNOWN_3_Msk = 0x8
	// Bit UNKNOWN_3.
	WATCHDOG_CTL_UNKNOWN_3 = 0x8
	// Position of UNKNOWN_4 field.
	WATCHDOG_CTL_UNKNOWN_4_Pos = 0x4
	// Bit mask of UNKNOWN_4 field.
	WATCHDOG_CTL_UNKNOWN_4_Msk = 0x10
	// Bit UNKNOWN_4.
	WATCHDOG_CTL_UNKNOWN_4 = 0x10
	// Position of UNKNOWN_5 field.
	WATCHDOG_CTL_UNKNOWN_5_Pos = 0x5
	// Bit mask of UNKNOWN_5 field.
	WATCHDOG_CTL_UNKNOWN_5_Msk = 0x20
	// Bit UNKNOWN_5.
	WATCHDOG_CTL_UNKNOWN_5 = 0x20
)
