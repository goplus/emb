// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from nrf52820.svd, see https://github.com/NordicSemiconductor/nrfx/tree/master/mdk

//go:build nrf && nrf52820

/*
// nRF52833 reference description for radio MCU with ARM 32-bit Cortex-M4 Microcontroller
*/
//     Copyright (c) 2010 - 2020, Nordic Semiconductor ASA All rights reserved.
//
//     Redistribution and use in source and binary forms, with or without
//     modification, are permitted provided that the following conditions are met:
//
//     1. Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//
//     2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
//     3. Neither the name of Nordic Semiconductor ASA nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
//
//     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//     IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
//     ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
//     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
//     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
//     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//     POSSIBILITY OF SUCH DAMAGE.
package nrf

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "nrf52820"
	CPU          = "CM4"
	FPUPresent   = false
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Clock control // Power control
	IRQ_POWER_CLOCK = 0

	// Clock control
	IRQ_CLOCK = 0

	// Power control
	IRQ_POWER = 0

	// 2.4 GHz radio
	IRQ_RADIO = 1

	// Universal Asynchronous Receiver/Transmitter // UART with EasyDMA
	IRQ_UARTE0_UART0 = 2

	// Universal Asynchronous Receiver/Transmitter
	IRQ_UART0 = 2

	// UART with EasyDMA
	IRQ_UARTE0 = 2

	// Serial Peripheral Interface 0 // Serial Peripheral Interface Master with EasyDMA 0 // SPI Slave 0 // I2C compatible Two-Wire Interface 0 // I2C compatible Two-Wire Master Interface with EasyDMA 0 // I2C compatible Two-Wire Slave Interface with EasyDMA 0
	IRQ_SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0 = 3

	// Serial Peripheral Interface 0
	IRQ_SPI0 = 3

	// Serial Peripheral Interface Master with EasyDMA 0
	IRQ_SPIM0 = 3

	// SPI Slave 0
	IRQ_SPIS0 = 3

	// I2C compatible Two-Wire Interface 0
	IRQ_TWI0 = 3

	// I2C compatible Two-Wire Master Interface with EasyDMA 0
	IRQ_TWIM0 = 3

	// I2C compatible Two-Wire Slave Interface with EasyDMA 0
	IRQ_TWIS0 = 3

	// Serial Peripheral Interface 1 // Serial Peripheral Interface Master with EasyDMA 1 // SPI Slave 1 // I2C compatible Two-Wire Interface 1 // I2C compatible Two-Wire Master Interface with EasyDMA 1 // I2C compatible Two-Wire Slave Interface with EasyDMA 1
	IRQ_SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1 = 4

	// Serial Peripheral Interface 1
	IRQ_SPI1 = 4

	// Serial Peripheral Interface Master with EasyDMA 1
	IRQ_SPIM1 = 4

	// SPI Slave 1
	IRQ_SPIS1 = 4

	// I2C compatible Two-Wire Interface 1
	IRQ_TWI1 = 4

	// I2C compatible Two-Wire Master Interface with EasyDMA 1
	IRQ_TWIM1 = 4

	// I2C compatible Two-Wire Slave Interface with EasyDMA 1
	IRQ_TWIS1 = 4

	// GPIO Tasks and Events
	IRQ_GPIOTE = 6

	// Timer/Counter 0
	IRQ_TIMER0 = 8

	// Timer/Counter 1
	IRQ_TIMER1 = 9

	// Timer/Counter 2
	IRQ_TIMER2 = 10

	// Real time counter 0
	IRQ_RTC0 = 11

	// Temperature Sensor
	IRQ_TEMP = 12

	// Random Number Generator
	IRQ_RNG = 13

	// AES ECB Mode Encryption
	IRQ_ECB = 14

	// Accelerated Address Resolver // AES CCM Mode Encryption
	IRQ_CCM_AAR = 15

	// Accelerated Address Resolver
	IRQ_AAR = 15

	// AES CCM Mode Encryption
	IRQ_CCM = 15

	// Watchdog Timer
	IRQ_WDT = 16

	// Real time counter 1
	IRQ_RTC1 = 17

	// Quadrature Decoder
	IRQ_QDEC = 18

	// Comparator
	IRQ_COMP = 19

	// Event generator unit 0 // Software interrupt 0
	IRQ_SWI0_EGU0 = 20

	// Event generator unit 0
	IRQ_EGU0 = 20

	// Software interrupt 0
	IRQ_SWI0 = 20

	// Event generator unit 1 // Software interrupt 1
	IRQ_SWI1_EGU1 = 21

	// Event generator unit 1
	IRQ_EGU1 = 21

	// Software interrupt 1
	IRQ_SWI1 = 21

	// Event generator unit 2 // Software interrupt 2
	IRQ_SWI2_EGU2 = 22

	// Event generator unit 2
	IRQ_EGU2 = 22

	// Software interrupt 2
	IRQ_SWI2 = 22

	// Event generator unit 3 // Software interrupt 3
	IRQ_SWI3_EGU3 = 23

	// Event generator unit 3
	IRQ_EGU3 = 23

	// Software interrupt 3
	IRQ_SWI3 = 23

	// Event generator unit 4 // Software interrupt 4
	IRQ_SWI4_EGU4 = 24

	// Event generator unit 4
	IRQ_EGU4 = 24

	// Software interrupt 4
	IRQ_SWI4 = 24

	// Event generator unit 5 // Software interrupt 5
	IRQ_SWI5_EGU5 = 25

	// Event generator unit 5
	IRQ_EGU5 = 25

	// Software interrupt 5
	IRQ_SWI5 = 25

	// Timer/Counter 3
	IRQ_TIMER3 = 26

	// Universal serial bus device
	IRQ_USBD = 39

	// Highest interrupt number on this device.
	IRQ_max = 39
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export POWER_CLOCK_IRQHandler
func interruptPOWER_CLOCK() {
	callHandlers(IRQ_POWER_CLOCK)
}

//export RADIO_IRQHandler
func interruptRADIO() {
	callHandlers(IRQ_RADIO)
}

//export UARTE0_UART0_IRQHandler
func interruptUARTE0_UART0() {
	callHandlers(IRQ_UARTE0_UART0)
}

//export SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
func interruptSPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0() {
	callHandlers(IRQ_SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0)
}

//export SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
func interruptSPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1() {
	callHandlers(IRQ_SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1)
}

//export GPIOTE_IRQHandler
func interruptGPIOTE() {
	callHandlers(IRQ_GPIOTE)
}

//export TIMER0_IRQHandler
func interruptTIMER0() {
	callHandlers(IRQ_TIMER0)
}

//export TIMER1_IRQHandler
func interruptTIMER1() {
	callHandlers(IRQ_TIMER1)
}

//export TIMER2_IRQHandler
func interruptTIMER2() {
	callHandlers(IRQ_TIMER2)
}

//export RTC0_IRQHandler
func interruptRTC0() {
	callHandlers(IRQ_RTC0)
}

//export TEMP_IRQHandler
func interruptTEMP() {
	callHandlers(IRQ_TEMP)
}

//export RNG_IRQHandler
func interruptRNG() {
	callHandlers(IRQ_RNG)
}

//export ECB_IRQHandler
func interruptECB() {
	callHandlers(IRQ_ECB)
}

//export CCM_AAR_IRQHandler
func interruptCCM_AAR() {
	callHandlers(IRQ_CCM_AAR)
}

//export WDT_IRQHandler
func interruptWDT() {
	callHandlers(IRQ_WDT)
}

//export RTC1_IRQHandler
func interruptRTC1() {
	callHandlers(IRQ_RTC1)
}

//export QDEC_IRQHandler
func interruptQDEC() {
	callHandlers(IRQ_QDEC)
}

//export COMP_IRQHandler
func interruptCOMP() {
	callHandlers(IRQ_COMP)
}

//export SWI0_EGU0_IRQHandler
func interruptSWI0_EGU0() {
	callHandlers(IRQ_SWI0_EGU0)
}

//export SWI1_EGU1_IRQHandler
func interruptSWI1_EGU1() {
	callHandlers(IRQ_SWI1_EGU1)
}

//export SWI2_EGU2_IRQHandler
func interruptSWI2_EGU2() {
	callHandlers(IRQ_SWI2_EGU2)
}

//export SWI3_EGU3_IRQHandler
func interruptSWI3_EGU3() {
	callHandlers(IRQ_SWI3_EGU3)
}

//export SWI4_EGU4_IRQHandler
func interruptSWI4_EGU4() {
	callHandlers(IRQ_SWI4_EGU4)
}

//export SWI5_EGU5_IRQHandler
func interruptSWI5_EGU5() {
	callHandlers(IRQ_SWI5_EGU5)
}

//export TIMER3_IRQHandler
func interruptTIMER3() {
	callHandlers(IRQ_TIMER3)
}

//export USBD_IRQHandler
func interruptUSBD() {
	callHandlers(IRQ_USBD)
}

// Peripherals.
var (
	// Factory information configuration registers
	FICR = (*FICR_Type)(unsafe.Pointer(uintptr(0x10000000)))

	// User information configuration registers
	UICR = (*UICR_Type)(unsafe.Pointer(uintptr(0x10001000)))

	// Clock control
	CLOCK = (*CLOCK_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Power control
	POWER = (*POWER_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// GPIO Port 1
	P0 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// 2.4 GHz radio
	RADIO = (*RADIO_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// Universal Asynchronous Receiver/Transmitter
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// UART with EasyDMA
	UARTE0 = (*UARTE_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Peripheral Interface Master with EasyDMA 0
	SPIM0 = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// SPI Slave 0
	SPIS0 = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// I2C compatible Two-Wire Interface 0
	TWI0 = (*TWI_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 0
	TWIM0 = (*TWIM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 0
	TWIS0 = (*TWIS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// GPIO Tasks and Events
	GPIOTE = (*GPIOTE_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Timer/Counter 0
	TIMER0 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// Real time counter 0
	RTC0 = (*RTC_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// Temperature Sensor
	TEMP = (*TEMP_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// Random Number Generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x4000d000)))

	// AES ECB Mode Encryption
	ECB = (*ECB_Type)(unsafe.Pointer(uintptr(0x4000e000)))

	// Accelerated Address Resolver
	AAR = (*AAR_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// AES CCM Mode Encryption
	CCM = (*CCM_Type)(unsafe.Pointer(uintptr(0x4000f000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Quadrature Decoder
	QDEC = (*QDEC_Type)(unsafe.Pointer(uintptr(0x40012000)))

	// Comparator
	COMP = (*COMP_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Event generator unit 0
	EGU0 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Software interrupt 0
	SWI0 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Access control lists
	ACL = (*ACL_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Non Volatile Memory Controller
	NVMC = (*NVMC_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Programmable Peripheral Interconnect
	PPI = (*PPI_Type)(unsafe.Pointer(uintptr(0x4001f000)))

	// Universal serial bus device
	USBD = (*USBD_Type)(unsafe.Pointer(uintptr(0x40027000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Serial Peripheral Interface Master with EasyDMA 1
	SPIM1 = (*SPIM_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// SPI Slave 1
	SPIS1 = (*SPIS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// I2C compatible Two-Wire Interface 1
	TWI1 = (*TWI_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// I2C compatible Two-Wire Master Interface with EasyDMA 1
	TWIM1 = (*TWIM_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// I2C compatible Two-Wire Slave Interface with EasyDMA 1
	TWIS1 = (*TWIS_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Timer/Counter 1
	TIMER1 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40009000)))

	// Timer/Counter 2
	TIMER2 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x4000a000)))

	// Real time counter 1
	RTC1 = (*RTC_Type)(unsafe.Pointer(uintptr(0x40011000)))

	// Event generator unit 1
	EGU1 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Software interrupt 1
	SWI1 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Event generator unit 2
	EGU2 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40016000)))

	// Software interrupt 2
	SWI2 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40016000)))

	// Event generator unit 3
	EGU3 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40017000)))

	// Software interrupt 3
	SWI3 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40017000)))

	// Event generator unit 4
	EGU4 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// Software interrupt 4
	SWI4 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// Event generator unit 5
	EGU5 = (*EGU_Type)(unsafe.Pointer(uintptr(0x40019000)))

	// Software interrupt 5
	SWI5 = (*SWI_Type)(unsafe.Pointer(uintptr(0x40019000)))

	// Timer/Counter 3
	TIMER3 = (*TIMER_Type)(unsafe.Pointer(uintptr(0x4001a000)))
)

// Factory information configuration registers
type FICR_Type struct {
	_              [16]byte
	CODEPAGESIZE   volatile.Register32 // 0x10
	CODESIZE       volatile.Register32 // 0x14
	_              [72]byte
	DEVICEID       [2]volatile.Register32 // 0x60
	_              [24]byte
	ER             [4]volatile.Register32 // 0x80
	IR             [4]volatile.Register32 // 0x90
	DEVICEADDRTYPE volatile.Register32    // 0xA0
	DEVICEADDR     [2]volatile.Register32 // 0xA4
	_              [84]byte
	INFO           FICR_INFO_Type // 0x100
	_              [572]byte
	PRODTEST       [3]volatile.Register32 // 0x350
	_              [168]byte
	TEMP           FICR_TEMP_Type // 0x404
}

// FICR.CODEPAGESIZE: Code memory page size
func (o *FICR_Type) SetCODEPAGESIZE(value uint32) {
	volatile.StoreUint32(&o.CODEPAGESIZE.Reg, value)
}
func (o *FICR_Type) GetCODEPAGESIZE() uint32 {
	return volatile.LoadUint32(&o.CODEPAGESIZE.Reg)
}

// FICR.CODESIZE: Code memory size
func (o *FICR_Type) SetCODESIZE(value uint32) {
	volatile.StoreUint32(&o.CODESIZE.Reg, value)
}
func (o *FICR_Type) GetCODESIZE() uint32 {
	return volatile.LoadUint32(&o.CODESIZE.Reg)
}

// FICR.DEVICEID: Description collection: Device identifier
func (o *FICR_Type) SetDEVICEID(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVICEID[idx].Reg, value)
}
func (o *FICR_Type) GetDEVICEID(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVICEID[idx].Reg)
}

// FICR.ER: Description collection: Encryption root, word n
func (o *FICR_Type) SetER(idx int, value uint32) {
	volatile.StoreUint32(&o.ER[idx].Reg, value)
}
func (o *FICR_Type) GetER(idx int) uint32 {
	return volatile.LoadUint32(&o.ER[idx].Reg)
}

// FICR.IR: Description collection: Identity Root, word n
func (o *FICR_Type) SetIR(idx int, value uint32) {
	volatile.StoreUint32(&o.IR[idx].Reg, value)
}
func (o *FICR_Type) GetIR(idx int) uint32 {
	return volatile.LoadUint32(&o.IR[idx].Reg)
}

// FICR.DEVICEADDRTYPE: Device address type
func (o *FICR_Type) SetDEVICEADDRTYPE(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDRTYPE.Reg, volatile.LoadUint32(&o.DEVICEADDRTYPE.Reg)&^(0x1)|value)
}
func (o *FICR_Type) GetDEVICEADDRTYPE() uint32 {
	return volatile.LoadUint32(&o.DEVICEADDRTYPE.Reg) & 0x1
}

// FICR.DEVICEADDR: Description collection: Device address n
func (o *FICR_Type) SetDEVICEADDR(idx int, value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR[idx].Reg, value)
}
func (o *FICR_Type) GetDEVICEADDR(idx int) uint32 {
	return volatile.LoadUint32(&o.DEVICEADDR[idx].Reg)
}

// FICR.PRODTEST: Description collection: Production test signature n
func (o *FICR_Type) SetPRODTEST(idx int, value uint32) {
	volatile.StoreUint32(&o.PRODTEST[idx].Reg, value)
}
func (o *FICR_Type) GetPRODTEST(idx int) uint32 {
	return volatile.LoadUint32(&o.PRODTEST[idx].Reg)
}

// Device info
type FICR_INFO_Type struct {
	PART    volatile.Register32 // 0x100
	VARIANT volatile.Register32 // 0x104
	PACKAGE volatile.Register32 // 0x108
	RAM     volatile.Register32 // 0x10C
	FLASH   volatile.Register32 // 0x110
}

// FICR_INFO.PART: Part code
func (o *FICR_INFO_Type) SetPART(value uint32) {
	volatile.StoreUint32(&o.PART.Reg, value)
}
func (o *FICR_INFO_Type) GetPART() uint32 {
	return volatile.LoadUint32(&o.PART.Reg)
}

// FICR_INFO.VARIANT: Build code (hardware version and production configuration)
func (o *FICR_INFO_Type) SetVARIANT(value uint32) {
	volatile.StoreUint32(&o.VARIANT.Reg, value)
}
func (o *FICR_INFO_Type) GetVARIANT() uint32 {
	return volatile.LoadUint32(&o.VARIANT.Reg)
}

// FICR_INFO.PACKAGE: Package option
func (o *FICR_INFO_Type) SetPACKAGE(value uint32) {
	volatile.StoreUint32(&o.PACKAGE.Reg, value)
}
func (o *FICR_INFO_Type) GetPACKAGE() uint32 {
	return volatile.LoadUint32(&o.PACKAGE.Reg)
}

// FICR_INFO.RAM: RAM variant
func (o *FICR_INFO_Type) SetRAM(value uint32) {
	volatile.StoreUint32(&o.RAM.Reg, value)
}
func (o *FICR_INFO_Type) GetRAM() uint32 {
	return volatile.LoadUint32(&o.RAM.Reg)
}

// FICR_INFO.FLASH: Flash variant
func (o *FICR_INFO_Type) SetFLASH(value uint32) {
	volatile.StoreUint32(&o.FLASH.Reg, value)
}
func (o *FICR_INFO_Type) GetFLASH() uint32 {
	return volatile.LoadUint32(&o.FLASH.Reg)
}

// Registers storing factory TEMP module linearization coefficients
type FICR_TEMP_Type struct {
	A0 volatile.Register32 // 0x404
	A1 volatile.Register32 // 0x408
	A2 volatile.Register32 // 0x40C
	A3 volatile.Register32 // 0x410
	A4 volatile.Register32 // 0x414
	A5 volatile.Register32 // 0x418
	B0 volatile.Register32 // 0x41C
	B1 volatile.Register32 // 0x420
	B2 volatile.Register32 // 0x424
	B3 volatile.Register32 // 0x428
	B4 volatile.Register32 // 0x42C
	B5 volatile.Register32 // 0x430
	T0 volatile.Register32 // 0x434
	T1 volatile.Register32 // 0x438
	T2 volatile.Register32 // 0x43C
	T3 volatile.Register32 // 0x440
	T4 volatile.Register32 // 0x444
}

// FICR_TEMP.A0: Slope definition A0
func (o *FICR_TEMP_Type) SetA0_A(value uint32) {
	volatile.StoreUint32(&o.A0.Reg, volatile.LoadUint32(&o.A0.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA0_A() uint32 {
	return volatile.LoadUint32(&o.A0.Reg) & 0xfff
}

// FICR_TEMP.A1: Slope definition A1
func (o *FICR_TEMP_Type) SetA1_A(value uint32) {
	volatile.StoreUint32(&o.A1.Reg, volatile.LoadUint32(&o.A1.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA1_A() uint32 {
	return volatile.LoadUint32(&o.A1.Reg) & 0xfff
}

// FICR_TEMP.A2: Slope definition A2
func (o *FICR_TEMP_Type) SetA2_A(value uint32) {
	volatile.StoreUint32(&o.A2.Reg, volatile.LoadUint32(&o.A2.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA2_A() uint32 {
	return volatile.LoadUint32(&o.A2.Reg) & 0xfff
}

// FICR_TEMP.A3: Slope definition A3
func (o *FICR_TEMP_Type) SetA3_A(value uint32) {
	volatile.StoreUint32(&o.A3.Reg, volatile.LoadUint32(&o.A3.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA3_A() uint32 {
	return volatile.LoadUint32(&o.A3.Reg) & 0xfff
}

// FICR_TEMP.A4: Slope definition A4
func (o *FICR_TEMP_Type) SetA4_A(value uint32) {
	volatile.StoreUint32(&o.A4.Reg, volatile.LoadUint32(&o.A4.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA4_A() uint32 {
	return volatile.LoadUint32(&o.A4.Reg) & 0xfff
}

// FICR_TEMP.A5: Slope definition A5
func (o *FICR_TEMP_Type) SetA5_A(value uint32) {
	volatile.StoreUint32(&o.A5.Reg, volatile.LoadUint32(&o.A5.Reg)&^(0xfff)|value)
}
func (o *FICR_TEMP_Type) GetA5_A() uint32 {
	return volatile.LoadUint32(&o.A5.Reg) & 0xfff
}

// FICR_TEMP.B0: Y-intercept B0
func (o *FICR_TEMP_Type) SetB0_B(value uint32) {
	volatile.StoreUint32(&o.B0.Reg, volatile.LoadUint32(&o.B0.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB0_B() uint32 {
	return volatile.LoadUint32(&o.B0.Reg) & 0x3fff
}

// FICR_TEMP.B1: Y-intercept B1
func (o *FICR_TEMP_Type) SetB1_B(value uint32) {
	volatile.StoreUint32(&o.B1.Reg, volatile.LoadUint32(&o.B1.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB1_B() uint32 {
	return volatile.LoadUint32(&o.B1.Reg) & 0x3fff
}

// FICR_TEMP.B2: Y-intercept B2
func (o *FICR_TEMP_Type) SetB2_B(value uint32) {
	volatile.StoreUint32(&o.B2.Reg, volatile.LoadUint32(&o.B2.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB2_B() uint32 {
	return volatile.LoadUint32(&o.B2.Reg) & 0x3fff
}

// FICR_TEMP.B3: Y-intercept B3
func (o *FICR_TEMP_Type) SetB3_B(value uint32) {
	volatile.StoreUint32(&o.B3.Reg, volatile.LoadUint32(&o.B3.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB3_B() uint32 {
	return volatile.LoadUint32(&o.B3.Reg) & 0x3fff
}

// FICR_TEMP.B4: Y-intercept B4
func (o *FICR_TEMP_Type) SetB4_B(value uint32) {
	volatile.StoreUint32(&o.B4.Reg, volatile.LoadUint32(&o.B4.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB4_B() uint32 {
	return volatile.LoadUint32(&o.B4.Reg) & 0x3fff
}

// FICR_TEMP.B5: Y-intercept B5
func (o *FICR_TEMP_Type) SetB5_B(value uint32) {
	volatile.StoreUint32(&o.B5.Reg, volatile.LoadUint32(&o.B5.Reg)&^(0x3fff)|value)
}
func (o *FICR_TEMP_Type) GetB5_B() uint32 {
	return volatile.LoadUint32(&o.B5.Reg) & 0x3fff
}

// FICR_TEMP.T0: Segment end T0
func (o *FICR_TEMP_Type) SetT0_T(value uint32) {
	volatile.StoreUint32(&o.T0.Reg, volatile.LoadUint32(&o.T0.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT0_T() uint32 {
	return volatile.LoadUint32(&o.T0.Reg) & 0xff
}

// FICR_TEMP.T1: Segment end T1
func (o *FICR_TEMP_Type) SetT1_T(value uint32) {
	volatile.StoreUint32(&o.T1.Reg, volatile.LoadUint32(&o.T1.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT1_T() uint32 {
	return volatile.LoadUint32(&o.T1.Reg) & 0xff
}

// FICR_TEMP.T2: Segment end T2
func (o *FICR_TEMP_Type) SetT2_T(value uint32) {
	volatile.StoreUint32(&o.T2.Reg, volatile.LoadUint32(&o.T2.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT2_T() uint32 {
	return volatile.LoadUint32(&o.T2.Reg) & 0xff
}

// FICR_TEMP.T3: Segment end T3
func (o *FICR_TEMP_Type) SetT3_T(value uint32) {
	volatile.StoreUint32(&o.T3.Reg, volatile.LoadUint32(&o.T3.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT3_T() uint32 {
	return volatile.LoadUint32(&o.T3.Reg) & 0xff
}

// FICR_TEMP.T4: Segment end T4
func (o *FICR_TEMP_Type) SetT4_T(value uint32) {
	volatile.StoreUint32(&o.T4.Reg, volatile.LoadUint32(&o.T4.Reg)&^(0xff)|value)
}
func (o *FICR_TEMP_Type) GetT4_T() uint32 {
	return volatile.LoadUint32(&o.T4.Reg) & 0xff
}

// User information configuration registers
type UICR_Type struct {
	_         [20]byte
	NRFFW     [13]volatile.Register32 // 0x14
	_         [8]byte
	NRFHW     [12]volatile.Register32 // 0x50
	CUSTOMER  [32]volatile.Register32 // 0x80
	_         [256]byte
	PSELRESET [2]volatile.Register32 // 0x200
	APPROTECT volatile.Register32    // 0x208
	_         [4]byte
	DEBUGCTRL volatile.Register32 // 0x210
	_         [240]byte
	REGOUT0   volatile.Register32 // 0x304
}

// UICR.NRFFW: Description collection: Reserved for Nordic firmware design
func (o *UICR_Type) SetNRFFW(idx int, value uint32) {
	volatile.StoreUint32(&o.NRFFW[idx].Reg, value)
}
func (o *UICR_Type) GetNRFFW(idx int) uint32 {
	return volatile.LoadUint32(&o.NRFFW[idx].Reg)
}

// UICR.NRFHW: Description collection: Reserved for Nordic hardware design
func (o *UICR_Type) SetNRFHW(idx int, value uint32) {
	volatile.StoreUint32(&o.NRFHW[idx].Reg, value)
}
func (o *UICR_Type) GetNRFHW(idx int) uint32 {
	return volatile.LoadUint32(&o.NRFHW[idx].Reg)
}

// UICR.CUSTOMER: Description collection: Reserved for customer
func (o *UICR_Type) SetCUSTOMER(idx int, value uint32) {
	volatile.StoreUint32(&o.CUSTOMER[idx].Reg, value)
}
func (o *UICR_Type) GetCUSTOMER(idx int) uint32 {
	return volatile.LoadUint32(&o.CUSTOMER[idx].Reg)
}

// UICR.PSELRESET: Description collection: Mapping of the nRESET function (see POWER chapter for details)
func (o *UICR_Type) SetPSELRESET_PIN(idx int, value uint32) {
	volatile.StoreUint32(&o.PSELRESET[idx].Reg, volatile.LoadUint32(&o.PSELRESET[idx].Reg)&^(0x1f)|value)
}
func (o *UICR_Type) GetPSELRESET_PIN(idx int) uint32 {
	return volatile.LoadUint32(&o.PSELRESET[idx].Reg) & 0x1f
}
func (o *UICR_Type) SetPSELRESET_CONNECT(idx int, value uint32) {
	volatile.StoreUint32(&o.PSELRESET[idx].Reg, volatile.LoadUint32(&o.PSELRESET[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *UICR_Type) GetPSELRESET_CONNECT(idx int) uint32 {
	return (volatile.LoadUint32(&o.PSELRESET[idx].Reg) & 0x80000000) >> 31
}

// UICR.APPROTECT: Access port protection
func (o *UICR_Type) SetAPPROTECT_PALL(value uint32) {
	volatile.StoreUint32(&o.APPROTECT.Reg, volatile.LoadUint32(&o.APPROTECT.Reg)&^(0xff)|value)
}
func (o *UICR_Type) GetAPPROTECT_PALL() uint32 {
	return volatile.LoadUint32(&o.APPROTECT.Reg) & 0xff
}

// UICR.DEBUGCTRL: Processor debug control
func (o *UICR_Type) SetDEBUGCTRL_CPUFPBEN(value uint32) {
	volatile.StoreUint32(&o.DEBUGCTRL.Reg, volatile.LoadUint32(&o.DEBUGCTRL.Reg)&^(0xff00)|value<<8)
}
func (o *UICR_Type) GetDEBUGCTRL_CPUFPBEN() uint32 {
	return (volatile.LoadUint32(&o.DEBUGCTRL.Reg) & 0xff00) >> 8
}

// UICR.REGOUT0: Output voltage from REG0 regulator stage. The maximum output voltage from this stage is given as VDDH - VREG0DROP.
func (o *UICR_Type) SetREGOUT0_VOUT(value uint32) {
	volatile.StoreUint32(&o.REGOUT0.Reg, volatile.LoadUint32(&o.REGOUT0.Reg)&^(0x7)|value)
}
func (o *UICR_Type) GetREGOUT0_VOUT() uint32 {
	return volatile.LoadUint32(&o.REGOUT0.Reg) & 0x7
}

// Clock control
type CLOCK_Type struct {
	TASKS_HFCLKSTART    volatile.Register32 // 0x0
	TASKS_HFCLKSTOP     volatile.Register32 // 0x4
	TASKS_LFCLKSTART    volatile.Register32 // 0x8
	TASKS_LFCLKSTOP     volatile.Register32 // 0xC
	TASKS_CAL           volatile.Register32 // 0x10
	TASKS_CTSTART       volatile.Register32 // 0x14
	TASKS_CTSTOP        volatile.Register32 // 0x18
	_                   [228]byte
	EVENTS_HFCLKSTARTED volatile.Register32 // 0x100
	EVENTS_LFCLKSTARTED volatile.Register32 // 0x104
	_                   [4]byte
	EVENTS_DONE         volatile.Register32 // 0x10C
	EVENTS_CTTO         volatile.Register32 // 0x110
	_                   [20]byte
	EVENTS_CTSTARTED    volatile.Register32 // 0x128
	EVENTS_CTSTOPPED    volatile.Register32 // 0x12C
	_                   [468]byte
	INTENSET            volatile.Register32 // 0x304
	INTENCLR            volatile.Register32 // 0x308
	_                   [252]byte
	HFCLKRUN            volatile.Register32 // 0x408
	HFCLKSTAT           volatile.Register32 // 0x40C
	_                   [4]byte
	LFCLKRUN            volatile.Register32 // 0x414
	LFCLKSTAT           volatile.Register32 // 0x418
	LFCLKSRCCOPY        volatile.Register32 // 0x41C
	_                   [248]byte
	LFCLKSRC            volatile.Register32 // 0x518
	_                   [12]byte
	HFXODEBOUNCE        volatile.Register32 // 0x528
	LFXODEBOUNCE        volatile.Register32 // 0x52C
	_                   [8]byte
	CTIV                volatile.Register32 // 0x538
}

// CLOCK.TASKS_HFCLKSTART: Start HFXO crystal oscillator
func (o *CLOCK_Type) SetTASKS_HFCLKSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLKSTART.Reg, volatile.LoadUint32(&o.TASKS_HFCLKSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLKSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLKSTART.Reg) & 0x1
}

// CLOCK.TASKS_HFCLKSTOP: Stop HFXO crystal oscillator
func (o *CLOCK_Type) SetTASKS_HFCLKSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_HFCLKSTOP.Reg, volatile.LoadUint32(&o.TASKS_HFCLKSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_HFCLKSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_HFCLKSTOP.Reg) & 0x1
}

// CLOCK.TASKS_LFCLKSTART: Start LFCLK
func (o *CLOCK_Type) SetTASKS_LFCLKSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_LFCLKSTART.Reg, volatile.LoadUint32(&o.TASKS_LFCLKSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_LFCLKSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_LFCLKSTART.Reg) & 0x1
}

// CLOCK.TASKS_LFCLKSTOP: Stop LFCLK
func (o *CLOCK_Type) SetTASKS_LFCLKSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_LFCLKSTOP.Reg, volatile.LoadUint32(&o.TASKS_LFCLKSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_LFCLKSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_LFCLKSTOP.Reg) & 0x1
}

// CLOCK.TASKS_CAL: Start calibration of LFRC
func (o *CLOCK_Type) SetTASKS_CAL(value uint32) {
	volatile.StoreUint32(&o.TASKS_CAL.Reg, volatile.LoadUint32(&o.TASKS_CAL.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_CAL() uint32 {
	return volatile.LoadUint32(&o.TASKS_CAL.Reg) & 0x1
}

// CLOCK.TASKS_CTSTART: Start calibration timer
func (o *CLOCK_Type) SetTASKS_CTSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_CTSTART.Reg, volatile.LoadUint32(&o.TASKS_CTSTART.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_CTSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_CTSTART.Reg) & 0x1
}

// CLOCK.TASKS_CTSTOP: Stop calibration timer
func (o *CLOCK_Type) SetTASKS_CTSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_CTSTOP.Reg, volatile.LoadUint32(&o.TASKS_CTSTOP.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetTASKS_CTSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_CTSTOP.Reg) & 0x1
}

// CLOCK.EVENTS_HFCLKSTARTED: HFXO crystal oscillator started
func (o *CLOCK_Type) SetEVENTS_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_HFCLKSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_HFCLKSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_HFCLKSTARTED.Reg) & 0x1
}

// CLOCK.EVENTS_LFCLKSTARTED: LFCLK started
func (o *CLOCK_Type) SetEVENTS_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LFCLKSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_LFCLKSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_LFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LFCLKSTARTED.Reg) & 0x1
}

// CLOCK.EVENTS_DONE: Calibration of LFRC completed
func (o *CLOCK_Type) SetEVENTS_DONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DONE.Reg, volatile.LoadUint32(&o.EVENTS_DONE.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_DONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DONE.Reg) & 0x1
}

// CLOCK.EVENTS_CTTO: Calibration timer timeout
func (o *CLOCK_Type) SetEVENTS_CTTO(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTTO.Reg, volatile.LoadUint32(&o.EVENTS_CTTO.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_CTTO() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTTO.Reg) & 0x1
}

// CLOCK.EVENTS_CTSTARTED: Calibration timer has been started and is ready to process new tasks
func (o *CLOCK_Type) SetEVENTS_CTSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_CTSTARTED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_CTSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTSTARTED.Reg) & 0x1
}

// CLOCK.EVENTS_CTSTOPPED: Calibration timer has been stopped and is ready to process new tasks
func (o *CLOCK_Type) SetEVENTS_CTSTOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTSTOPPED.Reg, volatile.LoadUint32(&o.EVENTS_CTSTOPPED.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetEVENTS_CTSTOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTSTOPPED.Reg) & 0x1
}

// CLOCK.INTENSET: Enable interrupt
func (o *CLOCK_Type) SetINTENSET_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTENSET_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTENSET_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTENSET_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTENSET_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *CLOCK_Type) GetINTENSET_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *CLOCK_Type) SetINTENSET_CTTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetINTENSET_CTTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *CLOCK_Type) SetINTENSET_CTSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *CLOCK_Type) GetINTENSET_CTSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *CLOCK_Type) SetINTENSET_CTSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *CLOCK_Type) GetINTENSET_CTSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}

// CLOCK.INTENCLR: Disable interrupt
func (o *CLOCK_Type) SetINTENCLR_HFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetINTENCLR_HFCLKSTARTED() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *CLOCK_Type) SetINTENCLR_LFCLKSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *CLOCK_Type) GetINTENCLR_LFCLKSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *CLOCK_Type) SetINTENCLR_DONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *CLOCK_Type) GetINTENCLR_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *CLOCK_Type) SetINTENCLR_CTTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *CLOCK_Type) GetINTENCLR_CTTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *CLOCK_Type) SetINTENCLR_CTSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *CLOCK_Type) GetINTENCLR_CTSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *CLOCK_Type) SetINTENCLR_CTSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *CLOCK_Type) GetINTENCLR_CTSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}

// CLOCK.HFCLKRUN: Status indicating that HFCLKSTART task has been triggered
func (o *CLOCK_Type) SetHFCLKRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.HFCLKRUN.Reg, volatile.LoadUint32(&o.HFCLKRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.HFCLKRUN.Reg) & 0x1
}

// CLOCK.HFCLKSTAT: HFCLK status
func (o *CLOCK_Type) SetHFCLKSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetHFCLKSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x1
}
func (o *CLOCK_Type) SetHFCLKSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.HFCLKSTAT.Reg, volatile.LoadUint32(&o.HFCLKSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetHFCLKSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.HFCLKSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.LFCLKRUN: Status indicating that LFCLKSTART task has been triggered
func (o *CLOCK_Type) SetLFCLKRUN_STATUS(value uint32) {
	volatile.StoreUint32(&o.LFCLKRUN.Reg, volatile.LoadUint32(&o.LFCLKRUN.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetLFCLKRUN_STATUS() uint32 {
	return volatile.LoadUint32(&o.LFCLKRUN.Reg) & 0x1
}

// CLOCK.LFCLKSTAT: LFCLK status
func (o *CLOCK_Type) SetLFCLKSTAT_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSTAT_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x3
}
func (o *CLOCK_Type) SetLFCLKSTAT_STATE(value uint32) {
	volatile.StoreUint32(&o.LFCLKSTAT.Reg, volatile.LoadUint32(&o.LFCLKSTAT.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetLFCLKSTAT_STATE() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSTAT.Reg) & 0x10000) >> 16
}

// CLOCK.LFCLKSRCCOPY: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
func (o *CLOCK_Type) SetLFCLKSRCCOPY_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRCCOPY.Reg, volatile.LoadUint32(&o.LFCLKSRCCOPY.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSRCCOPY_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSRCCOPY.Reg) & 0x3
}

// CLOCK.LFCLKSRC: Clock source for the LFCLK
func (o *CLOCK_Type) SetLFCLKSRC_SRC(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x3)|value)
}
func (o *CLOCK_Type) GetLFCLKSRC_SRC() uint32 {
	return volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x3
}
func (o *CLOCK_Type) SetLFCLKSRC_BYPASS(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCK_Type) GetLFCLKSRC_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x10000) >> 16
}
func (o *CLOCK_Type) SetLFCLKSRC_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.LFCLKSRC.Reg, volatile.LoadUint32(&o.LFCLKSRC.Reg)&^(0x20000)|value<<17)
}
func (o *CLOCK_Type) GetLFCLKSRC_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.LFCLKSRC.Reg) & 0x20000) >> 17
}

// CLOCK.HFXODEBOUNCE: HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task.
func (o *CLOCK_Type) SetHFXODEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.HFXODEBOUNCE.Reg, volatile.LoadUint32(&o.HFXODEBOUNCE.Reg)&^(0xff)|value)
}
func (o *CLOCK_Type) GetHFXODEBOUNCE() uint32 {
	return volatile.LoadUint32(&o.HFXODEBOUNCE.Reg) & 0xff
}

// CLOCK.LFXODEBOUNCE: LFXO debounce time. The LFXO is started by triggering the TASKS_LFCLKSTART task when the LFCLKSRC register is configured for Xtal.
func (o *CLOCK_Type) SetLFXODEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.LFXODEBOUNCE.Reg, volatile.LoadUint32(&o.LFXODEBOUNCE.Reg)&^(0x1)|value)
}
func (o *CLOCK_Type) GetLFXODEBOUNCE() uint32 {
	return volatile.LoadUint32(&o.LFXODEBOUNCE.Reg) & 0x1
}

// CLOCK.CTIV: Calibration timer interval
func (o *CLOCK_Type) SetCTIV(value uint32) {
	volatile.StoreUint32(&o.CTIV.Reg, volatile.LoadUint32(&o.CTIV.Reg)&^(0x7f)|value)
}
func (o *CLOCK_Type) GetCTIV() uint32 {
	return volatile.LoadUint32(&o.CTIV.Reg) & 0x7f
}

// Power control
type POWER_Type struct {
	_                  [120]byte
	TASKS_CONSTLAT     volatile.Register32 // 0x78
	TASKS_LOWPWR       volatile.Register32 // 0x7C
	_                  [136]byte
	EVENTS_POFWARN     volatile.Register32 // 0x108
	_                  [8]byte
	EVENTS_SLEEPENTER  volatile.Register32 // 0x114
	EVENTS_SLEEPEXIT   volatile.Register32 // 0x118
	EVENTS_USBDETECTED volatile.Register32 // 0x11C
	EVENTS_USBREMOVED  volatile.Register32 // 0x120
	EVENTS_USBPWRRDY   volatile.Register32 // 0x124
	_                  [476]byte
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [244]byte
	RESETREAS          volatile.Register32 // 0x400
	_                  [36]byte
	RAMSTATUS          volatile.Register32 // 0x428
	_                  [12]byte
	USBREGSTATUS       volatile.Register32 // 0x438
	_                  [196]byte
	SYSTEMOFF          volatile.Register32 // 0x500
	_                  [12]byte
	POFCON             volatile.Register32 // 0x510
	_                  [8]byte
	GPREGRET           volatile.Register32 // 0x51C
	GPREGRET2          volatile.Register32 // 0x520
	_                  [84]byte
	DCDCEN             volatile.Register32 // 0x578
	_                  [196]byte
	MAINREGSTATUS      volatile.Register32 // 0x640
	_                  [700]byte
	RAM                [4]POWER_RAM_Type // 0x900
}

// POWER.TASKS_CONSTLAT: Enable Constant Latency mode
func (o *POWER_Type) SetTASKS_CONSTLAT(value uint32) {
	volatile.StoreUint32(&o.TASKS_CONSTLAT.Reg, volatile.LoadUint32(&o.TASKS_CONSTLAT.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetTASKS_CONSTLAT() uint32 {
	return volatile.LoadUint32(&o.TASKS_CONSTLAT.Reg) & 0x1
}

// POWER.TASKS_LOWPWR: Enable Low-power mode (variable latency)
func (o *POWER_Type) SetTASKS_LOWPWR(value uint32) {
	volatile.StoreUint32(&o.TASKS_LOWPWR.Reg, volatile.LoadUint32(&o.TASKS_LOWPWR.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetTASKS_LOWPWR() uint32 {
	return volatile.LoadUint32(&o.TASKS_LOWPWR.Reg) & 0x1
}

// POWER.EVENTS_POFWARN: Power failure warning
func (o *POWER_Type) SetEVENTS_POFWARN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_POFWARN.Reg, volatile.LoadUint32(&o.EVENTS_POFWARN.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_POFWARN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_POFWARN.Reg) & 0x1
}

// POWER.EVENTS_SLEEPENTER: CPU entered WFI/WFE sleep
func (o *POWER_Type) SetEVENTS_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SLEEPENTER.Reg, volatile.LoadUint32(&o.EVENTS_SLEEPENTER.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_SLEEPENTER() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SLEEPENTER.Reg) & 0x1
}

// POWER.EVENTS_SLEEPEXIT: CPU exited WFI/WFE sleep
func (o *POWER_Type) SetEVENTS_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SLEEPEXIT.Reg, volatile.LoadUint32(&o.EVENTS_SLEEPEXIT.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_SLEEPEXIT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SLEEPEXIT.Reg) & 0x1
}

// POWER.EVENTS_USBDETECTED: Voltage supply detected on VBUS
func (o *POWER_Type) SetEVENTS_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBDETECTED.Reg, volatile.LoadUint32(&o.EVENTS_USBDETECTED.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_USBDETECTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBDETECTED.Reg) & 0x1
}

// POWER.EVENTS_USBREMOVED: Voltage supply removed from VBUS
func (o *POWER_Type) SetEVENTS_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBREMOVED.Reg, volatile.LoadUint32(&o.EVENTS_USBREMOVED.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_USBREMOVED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBREMOVED.Reg) & 0x1
}

// POWER.EVENTS_USBPWRRDY: USB 3.3 V supply ready
func (o *POWER_Type) SetEVENTS_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBPWRRDY.Reg, volatile.LoadUint32(&o.EVENTS_USBPWRRDY.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetEVENTS_USBPWRRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBPWRRDY.Reg) & 0x1
}

// POWER.INTENSET: Enable interrupt
func (o *POWER_Type) SetINTENSET_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTENSET_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTENSET_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTENSET_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTENSET_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTENSET_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *POWER_Type) SetINTENSET_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *POWER_Type) GetINTENSET_USBDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *POWER_Type) SetINTENSET_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *POWER_Type) GetINTENSET_USBREMOVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *POWER_Type) SetINTENSET_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *POWER_Type) GetINTENSET_USBPWRRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}

// POWER.INTENCLR: Disable interrupt
func (o *POWER_Type) SetINTENCLR_POFWARN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetINTENCLR_POFWARN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetINTENCLR_SLEEPENTER(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *POWER_Type) GetINTENCLR_SLEEPENTER() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *POWER_Type) SetINTENCLR_SLEEPEXIT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *POWER_Type) GetINTENCLR_SLEEPEXIT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *POWER_Type) SetINTENCLR_USBDETECTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *POWER_Type) GetINTENCLR_USBDETECTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *POWER_Type) SetINTENCLR_USBREMOVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *POWER_Type) GetINTENCLR_USBREMOVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *POWER_Type) SetINTENCLR_USBPWRRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *POWER_Type) GetINTENCLR_USBPWRRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}

// POWER.RESETREAS: Reset reason
func (o *POWER_Type) SetRESETREAS_RESETPIN(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetRESETREAS_RESETPIN() uint32 {
	return volatile.LoadUint32(&o.RESETREAS.Reg) & 0x1
}
func (o *POWER_Type) SetRESETREAS_DOG(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetRESETREAS_DOG() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x2) >> 1
}
func (o *POWER_Type) SetRESETREAS_SREQ(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x4)|value<<2)
}
func (o *POWER_Type) GetRESETREAS_SREQ() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x4) >> 2
}
func (o *POWER_Type) SetRESETREAS_LOCKUP(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x8)|value<<3)
}
func (o *POWER_Type) GetRESETREAS_LOCKUP() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x8) >> 3
}
func (o *POWER_Type) SetRESETREAS_OFF(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_Type) GetRESETREAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x10000) >> 16
}
func (o *POWER_Type) SetRESETREAS_DIF(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x40000)|value<<18)
}
func (o *POWER_Type) GetRESETREAS_DIF() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x40000) >> 18
}
func (o *POWER_Type) SetRESETREAS_VBUS(value uint32) {
	volatile.StoreUint32(&o.RESETREAS.Reg, volatile.LoadUint32(&o.RESETREAS.Reg)&^(0x100000)|value<<20)
}
func (o *POWER_Type) GetRESETREAS_VBUS() uint32 {
	return (volatile.LoadUint32(&o.RESETREAS.Reg) & 0x100000) >> 20
}

// POWER.RAMSTATUS: Deprecated register - RAM status register
func (o *POWER_Type) SetRAMSTATUS_RAMBLOCK0(value uint32) {
	volatile.StoreUint32(&o.RAMSTATUS.Reg, volatile.LoadUint32(&o.RAMSTATUS.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetRAMSTATUS_RAMBLOCK0() uint32 {
	return volatile.LoadUint32(&o.RAMSTATUS.Reg) & 0x1
}
func (o *POWER_Type) SetRAMSTATUS_RAMBLOCK1(value uint32) {
	volatile.StoreUint32(&o.RAMSTATUS.Reg, volatile.LoadUint32(&o.RAMSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetRAMSTATUS_RAMBLOCK1() uint32 {
	return (volatile.LoadUint32(&o.RAMSTATUS.Reg) & 0x2) >> 1
}

// POWER.USBREGSTATUS: USB supply status
func (o *POWER_Type) SetUSBREGSTATUS_VBUSDETECT(value uint32) {
	volatile.StoreUint32(&o.USBREGSTATUS.Reg, volatile.LoadUint32(&o.USBREGSTATUS.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetUSBREGSTATUS_VBUSDETECT() uint32 {
	return volatile.LoadUint32(&o.USBREGSTATUS.Reg) & 0x1
}
func (o *POWER_Type) SetUSBREGSTATUS_OUTPUTRDY(value uint32) {
	volatile.StoreUint32(&o.USBREGSTATUS.Reg, volatile.LoadUint32(&o.USBREGSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *POWER_Type) GetUSBREGSTATUS_OUTPUTRDY() uint32 {
	return (volatile.LoadUint32(&o.USBREGSTATUS.Reg) & 0x2) >> 1
}

// POWER.SYSTEMOFF: System OFF register
func (o *POWER_Type) SetSYSTEMOFF(value uint32) {
	volatile.StoreUint32(&o.SYSTEMOFF.Reg, volatile.LoadUint32(&o.SYSTEMOFF.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetSYSTEMOFF() uint32 {
	return volatile.LoadUint32(&o.SYSTEMOFF.Reg) & 0x1
}

// POWER.POFCON: Power-fail comparator configuration
func (o *POWER_Type) SetPOFCON_POF(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetPOFCON_POF() uint32 {
	return volatile.LoadUint32(&o.POFCON.Reg) & 0x1
}
func (o *POWER_Type) SetPOFCON_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0x1e)|value<<1)
}
func (o *POWER_Type) GetPOFCON_THRESHOLD() uint32 {
	return (volatile.LoadUint32(&o.POFCON.Reg) & 0x1e) >> 1
}
func (o *POWER_Type) SetPOFCON_THRESHOLDVDDH(value uint32) {
	volatile.StoreUint32(&o.POFCON.Reg, volatile.LoadUint32(&o.POFCON.Reg)&^(0xf00)|value<<8)
}
func (o *POWER_Type) GetPOFCON_THRESHOLDVDDH() uint32 {
	return (volatile.LoadUint32(&o.POFCON.Reg) & 0xf00) >> 8
}

// POWER.GPREGRET: General purpose retention register
func (o *POWER_Type) SetGPREGRET(value uint32) {
	volatile.StoreUint32(&o.GPREGRET.Reg, volatile.LoadUint32(&o.GPREGRET.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetGPREGRET() uint32 {
	return volatile.LoadUint32(&o.GPREGRET.Reg) & 0xff
}

// POWER.GPREGRET2: General purpose retention register
func (o *POWER_Type) SetGPREGRET2_GPREGRET(value uint32) {
	volatile.StoreUint32(&o.GPREGRET2.Reg, volatile.LoadUint32(&o.GPREGRET2.Reg)&^(0xff)|value)
}
func (o *POWER_Type) GetGPREGRET2_GPREGRET() uint32 {
	return volatile.LoadUint32(&o.GPREGRET2.Reg) & 0xff
}

// POWER.DCDCEN: Enable DC/DC converter for REG1 stage
func (o *POWER_Type) SetDCDCEN(value uint32) {
	volatile.StoreUint32(&o.DCDCEN.Reg, volatile.LoadUint32(&o.DCDCEN.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetDCDCEN() uint32 {
	return volatile.LoadUint32(&o.DCDCEN.Reg) & 0x1
}

// POWER.MAINREGSTATUS: Main supply status
func (o *POWER_Type) SetMAINREGSTATUS(value uint32) {
	volatile.StoreUint32(&o.MAINREGSTATUS.Reg, volatile.LoadUint32(&o.MAINREGSTATUS.Reg)&^(0x1)|value)
}
func (o *POWER_Type) GetMAINREGSTATUS() uint32 {
	return volatile.LoadUint32(&o.MAINREGSTATUS.Reg) & 0x1
}

// Unspecified
type POWER_RAM_Type struct {
	POWER    volatile.Register32 // 0x900
	POWERSET volatile.Register32 // 0x904
	POWERCLR volatile.Register32 // 0x908
	_        [4]byte
}

// POWER_RAM.POWER: Description cluster: RAMn power control register
func (o *POWER_RAM_Type) SetPOWER_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1)|value)
}
func (o *POWER_RAM_Type) GetPOWER_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x1
}
func (o *POWER_RAM_Type) SetPOWER_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x2)|value<<1)
}
func (o *POWER_RAM_Type) GetPOWER_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x2) >> 1
}
func (o *POWER_RAM_Type) SetPOWER_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_RAM_Type) GetPOWER_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x10000) >> 16
}
func (o *POWER_RAM_Type) SetPOWER_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_RAM_Type) GetPOWER_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWER.Reg) & 0x20000) >> 17
}

// POWER_RAM.POWERSET: Description cluster: RAMn power control set register
func (o *POWER_RAM_Type) SetPOWERSET_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x1)|value)
}
func (o *POWER_RAM_Type) GetPOWERSET_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWERSET.Reg) & 0x1
}
func (o *POWER_RAM_Type) SetPOWERSET_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x2)|value<<1)
}
func (o *POWER_RAM_Type) GetPOWERSET_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x2) >> 1
}
func (o *POWER_RAM_Type) SetPOWERSET_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_RAM_Type) GetPOWERSET_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x10000) >> 16
}
func (o *POWER_RAM_Type) SetPOWERSET_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERSET.Reg, volatile.LoadUint32(&o.POWERSET.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_RAM_Type) GetPOWERSET_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERSET.Reg) & 0x20000) >> 17
}

// POWER_RAM.POWERCLR: Description cluster: RAMn power control clear register
func (o *POWER_RAM_Type) SetPOWERCLR_S0POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x1)|value)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S0POWER() uint32 {
	return volatile.LoadUint32(&o.POWERCLR.Reg) & 0x1
}
func (o *POWER_RAM_Type) SetPOWERCLR_S1POWER(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x2)|value<<1)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S1POWER() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x2) >> 1
}
func (o *POWER_RAM_Type) SetPOWERCLR_S0RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x10000)|value<<16)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S0RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x10000) >> 16
}
func (o *POWER_RAM_Type) SetPOWERCLR_S1RETENTION(value uint32) {
	volatile.StoreUint32(&o.POWERCLR.Reg, volatile.LoadUint32(&o.POWERCLR.Reg)&^(0x20000)|value<<17)
}
func (o *POWER_RAM_Type) GetPOWERCLR_S1RETENTION() uint32 {
	return (volatile.LoadUint32(&o.POWERCLR.Reg) & 0x20000) >> 17
}

// GPIO Port 1
type GPIO_Type struct {
	_          [1284]byte
	OUT        volatile.Register32 // 0x504
	OUTSET     volatile.Register32 // 0x508
	OUTCLR     volatile.Register32 // 0x50C
	IN         volatile.Register32 // 0x510
	DIR        volatile.Register32 // 0x514
	DIRSET     volatile.Register32 // 0x518
	DIRCLR     volatile.Register32 // 0x51C
	LATCH      volatile.Register32 // 0x520
	DETECTMODE volatile.Register32 // 0x524
	_          [472]byte
	PIN_CNF    [32]volatile.Register32 // 0x700
}

// GPIO.OUT: Write GPIO port
func (o *GPIO_Type) SetOUT_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUT_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg) & 0x1
}
func (o *GPIO_Type) SetOUT_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUT_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUT_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUT_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUT_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUT_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUT_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUT_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUT_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUT_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUT_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUT_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUT_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUT_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUT_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUT_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUT_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUT_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUT_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUT_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUT_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUT_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUT_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUT_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUT_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUT_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUT_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUT_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUT_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUT_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUT_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUT_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUT_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUT_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUT_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUT_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUT_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUT_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUT_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUT_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUT_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUT_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUT_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUT_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUT_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUT_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUT_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUT_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUT_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUT_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUT_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUT_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUT_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUT_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUT_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUT_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUT_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUT_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUT_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUT_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUT_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, volatile.LoadUint32(&o.OUT.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUT_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUT.Reg) & 0x80000000) >> 31
}

// GPIO.OUTSET: Set individual bits in GPIO port
func (o *GPIO_Type) SetOUTSET_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTSET_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUTSET.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTSET_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTSET_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTSET_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTSET_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTSET_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTSET_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTSET_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTSET_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTSET_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTSET_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTSET_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTSET_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTSET_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTSET_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUTSET_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUTSET_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUTSET_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUTSET_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUTSET_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUTSET_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUTSET_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUTSET_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUTSET_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUTSET_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUTSET_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUTSET_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUTSET_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUTSET_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUTSET_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUTSET_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUTSET_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUTSET_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUTSET_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUTSET_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUTSET_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUTSET_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUTSET_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUTSET_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUTSET_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUTSET_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUTSET_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUTSET_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUTSET_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUTSET_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUTSET_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUTSET_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUTSET_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUTSET_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUTSET_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUTSET_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUTSET_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUTSET_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUTSET_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUTSET_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUTSET_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUTSET_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUTSET_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUTSET_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUTSET_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUTSET_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUTSET_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, volatile.LoadUint32(&o.OUTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUTSET_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUTSET.Reg) & 0x80000000) >> 31
}

// GPIO.OUTCLR: Clear individual bits in GPIO port
func (o *GPIO_Type) SetOUTCLR_PIN0(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOUTCLR_PIN0() uint32 {
	return volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1
}
func (o *GPIO_Type) SetOUTCLR_PIN1(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOUTCLR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOUTCLR_PIN2(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOUTCLR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOUTCLR_PIN3(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOUTCLR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOUTCLR_PIN4(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOUTCLR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOUTCLR_PIN5(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOUTCLR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOUTCLR_PIN6(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOUTCLR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOUTCLR_PIN7(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOUTCLR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOUTCLR_PIN8(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOUTCLR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOUTCLR_PIN9(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOUTCLR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOUTCLR_PIN10(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOUTCLR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOUTCLR_PIN11(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOUTCLR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOUTCLR_PIN12(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOUTCLR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOUTCLR_PIN13(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOUTCLR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOUTCLR_PIN14(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOUTCLR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOUTCLR_PIN15(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOUTCLR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOUTCLR_PIN16(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetOUTCLR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetOUTCLR_PIN17(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetOUTCLR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetOUTCLR_PIN18(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetOUTCLR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetOUTCLR_PIN19(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetOUTCLR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetOUTCLR_PIN20(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetOUTCLR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetOUTCLR_PIN21(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetOUTCLR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetOUTCLR_PIN22(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetOUTCLR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetOUTCLR_PIN23(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetOUTCLR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetOUTCLR_PIN24(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetOUTCLR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetOUTCLR_PIN25(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetOUTCLR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetOUTCLR_PIN26(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetOUTCLR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetOUTCLR_PIN27(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetOUTCLR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetOUTCLR_PIN28(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetOUTCLR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetOUTCLR_PIN29(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetOUTCLR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetOUTCLR_PIN30(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetOUTCLR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetOUTCLR_PIN31(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, volatile.LoadUint32(&o.OUTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetOUTCLR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.OUTCLR.Reg) & 0x80000000) >> 31
}

// GPIO.IN: Read GPIO port
func (o *GPIO_Type) SetIN_PIN0(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIN_PIN0() uint32 {
	return volatile.LoadUint32(&o.IN.Reg) & 0x1
}
func (o *GPIO_Type) SetIN_PIN1(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIN_PIN1() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIN_PIN2(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIN_PIN2() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIN_PIN3(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIN_PIN3() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIN_PIN4(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIN_PIN4() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIN_PIN5(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIN_PIN5() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIN_PIN6(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIN_PIN6() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIN_PIN7(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIN_PIN7() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIN_PIN8(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIN_PIN8() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIN_PIN9(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIN_PIN9() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIN_PIN10(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIN_PIN10() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIN_PIN11(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIN_PIN11() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIN_PIN12(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIN_PIN12() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIN_PIN13(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIN_PIN13() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIN_PIN14(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIN_PIN14() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIN_PIN15(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIN_PIN15() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIN_PIN16(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetIN_PIN16() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetIN_PIN17(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetIN_PIN17() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetIN_PIN18(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetIN_PIN18() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetIN_PIN19(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetIN_PIN19() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetIN_PIN20(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetIN_PIN20() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetIN_PIN21(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetIN_PIN21() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetIN_PIN22(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetIN_PIN22() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetIN_PIN23(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetIN_PIN23() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetIN_PIN24(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetIN_PIN24() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetIN_PIN25(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetIN_PIN25() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetIN_PIN26(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetIN_PIN26() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetIN_PIN27(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetIN_PIN27() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetIN_PIN28(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetIN_PIN28() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetIN_PIN29(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetIN_PIN29() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetIN_PIN30(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetIN_PIN30() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetIN_PIN31(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, volatile.LoadUint32(&o.IN.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetIN_PIN31() uint32 {
	return (volatile.LoadUint32(&o.IN.Reg) & 0x80000000) >> 31
}

// GPIO.DIR: Direction of GPIO pins
func (o *GPIO_Type) SetDIR_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80000000) >> 31
}

// GPIO.DIRSET: DIR set register
func (o *GPIO_Type) SetDIRSET_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIRSET_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIRSET.Reg) & 0x1
}
func (o *GPIO_Type) SetDIRSET_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIRSET_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIRSET_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIRSET_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIRSET_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIRSET_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIRSET_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIRSET_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIRSET_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIRSET_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIRSET_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIRSET_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIRSET_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIRSET_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIRSET_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIRSET_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIRSET_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIRSET_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIRSET_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIRSET_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIRSET_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIRSET_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIRSET_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIRSET_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIRSET_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIRSET_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIRSET_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIRSET_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIRSET_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIRSET_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIRSET_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIRSET_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIRSET_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIRSET_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIRSET_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIRSET_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIRSET_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIRSET_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIRSET_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIRSET_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIRSET_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIRSET_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIRSET_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIRSET_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIRSET_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIRSET_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIRSET_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIRSET_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIRSET_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIRSET_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIRSET_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIRSET_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIRSET_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIRSET_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIRSET_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIRSET_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIRSET_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIRSET_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIRSET_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIRSET_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIRSET_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, volatile.LoadUint32(&o.DIRSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIRSET_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIRSET.Reg) & 0x80000000) >> 31
}

// GPIO.DIRCLR: DIR clear register
func (o *GPIO_Type) SetDIRCLR_PIN0(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIRCLR_PIN0() uint32 {
	return volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIRCLR_PIN1(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIRCLR_PIN1() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIRCLR_PIN2(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIRCLR_PIN2() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIRCLR_PIN3(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIRCLR_PIN3() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIRCLR_PIN4(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIRCLR_PIN4() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIRCLR_PIN5(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIRCLR_PIN5() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIRCLR_PIN6(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIRCLR_PIN6() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIRCLR_PIN7(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIRCLR_PIN7() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIRCLR_PIN8(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIRCLR_PIN8() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIRCLR_PIN9(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIRCLR_PIN9() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIRCLR_PIN10(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIRCLR_PIN10() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIRCLR_PIN11(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIRCLR_PIN11() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIRCLR_PIN12(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIRCLR_PIN12() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIRCLR_PIN13(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIRCLR_PIN13() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIRCLR_PIN14(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIRCLR_PIN14() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIRCLR_PIN15(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIRCLR_PIN15() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIRCLR_PIN16(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIRCLR_PIN16() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIRCLR_PIN17(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIRCLR_PIN17() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIRCLR_PIN18(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIRCLR_PIN18() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIRCLR_PIN19(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIRCLR_PIN19() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIRCLR_PIN20(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIRCLR_PIN20() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIRCLR_PIN21(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIRCLR_PIN21() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIRCLR_PIN22(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIRCLR_PIN22() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIRCLR_PIN23(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIRCLR_PIN23() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIRCLR_PIN24(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIRCLR_PIN24() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIRCLR_PIN25(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIRCLR_PIN25() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIRCLR_PIN26(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIRCLR_PIN26() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIRCLR_PIN27(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIRCLR_PIN27() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIRCLR_PIN28(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIRCLR_PIN28() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIRCLR_PIN29(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIRCLR_PIN29() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIRCLR_PIN30(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIRCLR_PIN30() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIRCLR_PIN31(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, volatile.LoadUint32(&o.DIRCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIRCLR_PIN31() uint32 {
	return (volatile.LoadUint32(&o.DIRCLR.Reg) & 0x80000000) >> 31
}

// GPIO.LATCH: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
func (o *GPIO_Type) SetLATCH_PIN0(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLATCH_PIN0() uint32 {
	return volatile.LoadUint32(&o.LATCH.Reg) & 0x1
}
func (o *GPIO_Type) SetLATCH_PIN1(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLATCH_PIN1() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLATCH_PIN2(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLATCH_PIN2() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLATCH_PIN3(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLATCH_PIN3() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLATCH_PIN4(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLATCH_PIN4() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLATCH_PIN5(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLATCH_PIN5() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLATCH_PIN6(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLATCH_PIN6() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLATCH_PIN7(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLATCH_PIN7() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLATCH_PIN8(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLATCH_PIN8() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLATCH_PIN9(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLATCH_PIN9() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLATCH_PIN10(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLATCH_PIN10() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLATCH_PIN11(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLATCH_PIN11() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLATCH_PIN12(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLATCH_PIN12() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLATCH_PIN13(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLATCH_PIN13() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLATCH_PIN14(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLATCH_PIN14() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLATCH_PIN15(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLATCH_PIN15() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLATCH_PIN16(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLATCH_PIN16() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLATCH_PIN17(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetLATCH_PIN17() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetLATCH_PIN18(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetLATCH_PIN18() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetLATCH_PIN19(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetLATCH_PIN19() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetLATCH_PIN20(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetLATCH_PIN20() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetLATCH_PIN21(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetLATCH_PIN21() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetLATCH_PIN22(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetLATCH_PIN22() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetLATCH_PIN23(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetLATCH_PIN23() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetLATCH_PIN24(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetLATCH_PIN24() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetLATCH_PIN25(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetLATCH_PIN25() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetLATCH_PIN26(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetLATCH_PIN26() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetLATCH_PIN27(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetLATCH_PIN27() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetLATCH_PIN28(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetLATCH_PIN28() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetLATCH_PIN29(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetLATCH_PIN29() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetLATCH_PIN30(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetLATCH_PIN30() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetLATCH_PIN31(value uint32) {
	volatile.StoreUint32(&o.LATCH.Reg, volatile.LoadUint32(&o.LATCH.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetLATCH_PIN31() uint32 {
	return (volatile.LoadUint32(&o.LATCH.Reg) & 0x80000000) >> 31
}

// GPIO.DETECTMODE: Select between default DETECT signal behaviour and LDETECT mode
func (o *GPIO_Type) SetDETECTMODE(value uint32) {
	volatile.StoreUint32(&o.DETECTMODE.Reg, volatile.LoadUint32(&o.DETECTMODE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDETECTMODE() uint32 {
	return volatile.LoadUint32(&o.DETECTMODE.Reg) & 0x1
}

// GPIO.PIN_CNF: Description collection: Configuration of GPIO pins
func (o *GPIO_Type) SetPIN_CNF_DIR(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN_CNF_DIR(idx int) uint32 {
	return volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x1
}
func (o *GPIO_Type) SetPIN_CNF_INPUT(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN_CNF_INPUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN_CNF_PULL(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPIN_CNF_PULL(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPIN_CNF_DRIVE(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x700)|value<<8)
}
func (o *GPIO_Type) GetPIN_CNF_DRIVE(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x700) >> 8
}
func (o *GPIO_Type) SetPIN_CNF_SENSE(idx int, value uint32) {
	volatile.StoreUint32(&o.PIN_CNF[idx].Reg, volatile.LoadUint32(&o.PIN_CNF[idx].Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPIN_CNF_SENSE(idx int) uint32 {
	return (volatile.LoadUint32(&o.PIN_CNF[idx].Reg) & 0x30000) >> 16
}

// 2.4 GHz radio
type RADIO_Type struct {
	TASKS_TXEN        volatile.Register32 // 0x0
	TASKS_RXEN        volatile.Register32 // 0x4
	TASKS_START       volatile.Register32 // 0x8
	TASKS_STOP        volatile.Register32 // 0xC
	TASKS_DISABLE     volatile.Register32 // 0x10
	TASKS_RSSISTART   volatile.Register32 // 0x14
	TASKS_RSSISTOP    volatile.Register32 // 0x18
	TASKS_BCSTART     volatile.Register32 // 0x1C
	TASKS_BCSTOP      volatile.Register32 // 0x20
	TASKS_EDSTART     volatile.Register32 // 0x24
	TASKS_EDSTOP      volatile.Register32 // 0x28
	TASKS_CCASTART    volatile.Register32 // 0x2C
	TASKS_CCASTOP     volatile.Register32 // 0x30
	_                 [204]byte
	EVENTS_READY      volatile.Register32 // 0x100
	EVENTS_ADDRESS    volatile.Register32 // 0x104
	EVENTS_PAYLOAD    volatile.Register32 // 0x108
	EVENTS_END        volatile.Register32 // 0x10C
	EVENTS_DISABLED   volatile.Register32 // 0x110
	EVENTS_DEVMATCH   volatile.Register32 // 0x114
	EVENTS_DEVMISS    volatile.Register32 // 0x118
	EVENTS_RSSIEND    volatile.Register32 // 0x11C
	_                 [8]byte
	EVENTS_BCMATCH    volatile.Register32 // 0x128
	_                 [4]byte
	EVENTS_CRCOK      volatile.Register32 // 0x130
	EVENTS_CRCERROR   volatile.Register32 // 0x134
	EVENTS_FRAMESTART volatile.Register32 // 0x138
	EVENTS_EDEND      volatile.Register32 // 0x13C
	EVENTS_EDSTOPPED  volatile.Register32 // 0x140
	EVENTS_CCAIDLE    volatile.Register32 // 0x144
	EVENTS_CCABUSY    volatile.Register32 // 0x148
	EVENTS_CCASTOPPED volatile.Register32 // 0x14C
	EVENTS_RATEBOOST  volatile.Register32 // 0x150
	EVENTS_TXREADY    volatile.Register32 // 0x154
	EVENTS_RXREADY    volatile.Register32 // 0x158
	EVENTS_MHRMATCH   volatile.Register32 // 0x15C
	_                 [8]byte
	EVENTS_SYNC       volatile.Register32 // 0x168
	EVENTS_PHYEND     volatile.Register32 // 0x16C
	EVENTS_CTEPRESENT volatile.Register32 // 0x170
	_                 [140]byte
	SHORTS            volatile.Register32 // 0x200
	_                 [256]byte
	INTENSET          volatile.Register32 // 0x304
	INTENCLR          volatile.Register32 // 0x308
	_                 [244]byte
	CRCSTATUS         volatile.Register32 // 0x400
	_                 [4]byte
	RXMATCH           volatile.Register32 // 0x408
	RXCRC             volatile.Register32 // 0x40C
	DAI               volatile.Register32 // 0x410
	PDUSTAT           volatile.Register32 // 0x414
	_                 [52]byte
	CTESTATUS         volatile.Register32 // 0x44C
	_                 [8]byte
	DFESTATUS         volatile.Register32 // 0x458
	_                 [168]byte
	PACKETPTR         volatile.Register32 // 0x504
	FREQUENCY         volatile.Register32 // 0x508
	TXPOWER           volatile.Register32 // 0x50C
	MODE              volatile.Register32 // 0x510
	PCNF0             volatile.Register32 // 0x514
	PCNF1             volatile.Register32 // 0x518
	BASE0             volatile.Register32 // 0x51C
	BASE1             volatile.Register32 // 0x520
	PREFIX0           volatile.Register32 // 0x524
	PREFIX1           volatile.Register32 // 0x528
	TXADDRESS         volatile.Register32 // 0x52C
	RXADDRESSES       volatile.Register32 // 0x530
	CRCCNF            volatile.Register32 // 0x534
	CRCPOLY           volatile.Register32 // 0x538
	CRCINIT           volatile.Register32 // 0x53C
	_                 [4]byte
	TIFS              volatile.Register32 // 0x544
	RSSISAMPLE        volatile.Register32 // 0x548
	_                 [4]byte
	STATE             volatile.Register32 // 0x550
	DATAWHITEIV       volatile.Register32 // 0x554
	_                 [8]byte
	BCC               volatile.Register32 // 0x560
	_                 [156]byte
	DAB               [8]volatile.Register32 // 0x600
	DAP               [8]volatile.Register32 // 0x620
	DACNF             volatile.Register32    // 0x640
	MHRMATCHCONF      volatile.Register32    // 0x644
	MHRMATCHMAS       volatile.Register32    // 0x648
	_                 [4]byte
	MODECNF0          volatile.Register32 // 0x650
	_                 [12]byte
	SFD               volatile.Register32 // 0x660
	EDCNT             volatile.Register32 // 0x664
	EDSAMPLE          volatile.Register32 // 0x668
	CCACTRL           volatile.Register32 // 0x66C
	_                 [656]byte
	DFEMODE           volatile.Register32 // 0x900
	CTEINLINECONF     volatile.Register32 // 0x904
	_                 [8]byte
	DFECTRL1          volatile.Register32 // 0x910
	DFECTRL2          volatile.Register32 // 0x914
	_                 [16]byte
	SWITCHPATTERN     volatile.Register32  // 0x928
	CLEARPATTERN      volatile.Register32  // 0x92C
	PSEL              RADIO_PSEL_Type      // 0x930
	DFEPACKET         RADIO_DFEPACKET_Type // 0x950
	_                 [1696]byte
	POWER             volatile.Register32 // 0xFFC
}

// RADIO.TASKS_TXEN: Enable RADIO in TX mode
func (o *RADIO_Type) SetTASKS_TXEN(value uint32) {
	volatile.StoreUint32(&o.TASKS_TXEN.Reg, volatile.LoadUint32(&o.TASKS_TXEN.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_TXEN() uint32 {
	return volatile.LoadUint32(&o.TASKS_TXEN.Reg) & 0x1
}

// RADIO.TASKS_RXEN: Enable RADIO in RX mode
func (o *RADIO_Type) SetTASKS_RXEN(value uint32) {
	volatile.StoreUint32(&o.TASKS_RXEN.Reg, volatile.LoadUint32(&o.TASKS_RXEN.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_RXEN() uint32 {
	return volatile.LoadUint32(&o.TASKS_RXEN.Reg) & 0x1
}

// RADIO.TASKS_START: Start RADIO
func (o *RADIO_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// RADIO.TASKS_STOP: Stop RADIO
func (o *RADIO_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// RADIO.TASKS_DISABLE: Disable RADIO
func (o *RADIO_Type) SetTASKS_DISABLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DISABLE.Reg, volatile.LoadUint32(&o.TASKS_DISABLE.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_DISABLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DISABLE.Reg) & 0x1
}

// RADIO.TASKS_RSSISTART: Start the RSSI and take one single sample of the receive signal strength
func (o *RADIO_Type) SetTASKS_RSSISTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_RSSISTART.Reg, volatile.LoadUint32(&o.TASKS_RSSISTART.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_RSSISTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_RSSISTART.Reg) & 0x1
}

// RADIO.TASKS_RSSISTOP: Stop the RSSI measurement
func (o *RADIO_Type) SetTASKS_RSSISTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_RSSISTOP.Reg, volatile.LoadUint32(&o.TASKS_RSSISTOP.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_RSSISTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_RSSISTOP.Reg) & 0x1
}

// RADIO.TASKS_BCSTART: Start the bit counter
func (o *RADIO_Type) SetTASKS_BCSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_BCSTART.Reg, volatile.LoadUint32(&o.TASKS_BCSTART.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_BCSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_BCSTART.Reg) & 0x1
}

// RADIO.TASKS_BCSTOP: Stop the bit counter
func (o *RADIO_Type) SetTASKS_BCSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_BCSTOP.Reg, volatile.LoadUint32(&o.TASKS_BCSTOP.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_BCSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_BCSTOP.Reg) & 0x1
}

// RADIO.TASKS_EDSTART: Start the energy detect measurement used in IEEE 802.15.4 mode
func (o *RADIO_Type) SetTASKS_EDSTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_EDSTART.Reg, volatile.LoadUint32(&o.TASKS_EDSTART.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_EDSTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_EDSTART.Reg) & 0x1
}

// RADIO.TASKS_EDSTOP: Stop the energy detect measurement
func (o *RADIO_Type) SetTASKS_EDSTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_EDSTOP.Reg, volatile.LoadUint32(&o.TASKS_EDSTOP.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_EDSTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_EDSTOP.Reg) & 0x1
}

// RADIO.TASKS_CCASTART: Start the clear channel assessment used in IEEE 802.15.4 mode
func (o *RADIO_Type) SetTASKS_CCASTART(value uint32) {
	volatile.StoreUint32(&o.TASKS_CCASTART.Reg, volatile.LoadUint32(&o.TASKS_CCASTART.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_CCASTART() uint32 {
	return volatile.LoadUint32(&o.TASKS_CCASTART.Reg) & 0x1
}

// RADIO.TASKS_CCASTOP: Stop the clear channel assessment
func (o *RADIO_Type) SetTASKS_CCASTOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_CCASTOP.Reg, volatile.LoadUint32(&o.TASKS_CCASTOP.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetTASKS_CCASTOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_CCASTOP.Reg) & 0x1
}

// RADIO.EVENTS_READY: RADIO has ramped up and is ready to be started
func (o *RADIO_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// RADIO.EVENTS_ADDRESS: Address sent or received
func (o *RADIO_Type) SetEVENTS_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ADDRESS.Reg, volatile.LoadUint32(&o.EVENTS_ADDRESS.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ADDRESS.Reg) & 0x1
}

// RADIO.EVENTS_PAYLOAD: Packet payload sent or received
func (o *RADIO_Type) SetEVENTS_PAYLOAD(value uint32) {
	volatile.StoreUint32(&o.EVENTS_PAYLOAD.Reg, volatile.LoadUint32(&o.EVENTS_PAYLOAD.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_PAYLOAD() uint32 {
	return volatile.LoadUint32(&o.EVENTS_PAYLOAD.Reg) & 0x1
}

// RADIO.EVENTS_END: Packet sent or received
func (o *RADIO_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// RADIO.EVENTS_DISABLED: RADIO has been disabled
func (o *RADIO_Type) SetEVENTS_DISABLED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DISABLED.Reg, volatile.LoadUint32(&o.EVENTS_DISABLED.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_DISABLED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DISABLED.Reg) & 0x1
}

// RADIO.EVENTS_DEVMATCH: A device address match occurred on the last received packet
func (o *RADIO_Type) SetEVENTS_DEVMATCH(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DEVMATCH.Reg, volatile.LoadUint32(&o.EVENTS_DEVMATCH.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_DEVMATCH() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DEVMATCH.Reg) & 0x1
}

// RADIO.EVENTS_DEVMISS: No device address match occurred on the last received packet
func (o *RADIO_Type) SetEVENTS_DEVMISS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DEVMISS.Reg, volatile.LoadUint32(&o.EVENTS_DEVMISS.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_DEVMISS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DEVMISS.Reg) & 0x1
}

// RADIO.EVENTS_RSSIEND: Sampling of receive signal strength complete
func (o *RADIO_Type) SetEVENTS_RSSIEND(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RSSIEND.Reg, volatile.LoadUint32(&o.EVENTS_RSSIEND.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_RSSIEND() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RSSIEND.Reg) & 0x1
}

// RADIO.EVENTS_BCMATCH: Bit counter reached bit count value
func (o *RADIO_Type) SetEVENTS_BCMATCH(value uint32) {
	volatile.StoreUint32(&o.EVENTS_BCMATCH.Reg, volatile.LoadUint32(&o.EVENTS_BCMATCH.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_BCMATCH() uint32 {
	return volatile.LoadUint32(&o.EVENTS_BCMATCH.Reg) & 0x1
}

// RADIO.EVENTS_CRCOK: Packet received with CRC ok
func (o *RADIO_Type) SetEVENTS_CRCOK(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CRCOK.Reg, volatile.LoadUint32(&o.EVENTS_CRCOK.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_CRCOK() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CRCOK.Reg) & 0x1
}

// RADIO.EVENTS_CRCERROR: Packet received with CRC error
func (o *RADIO_Type) SetEVENTS_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CRCERROR.Reg, volatile.LoadUint32(&o.EVENTS_CRCERROR.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_CRCERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CRCERROR.Reg) & 0x1
}

// RADIO.EVENTS_FRAMESTART: IEEE 802.15.4 length field received
func (o *RADIO_Type) SetEVENTS_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.EVENTS_FRAMESTART.Reg, volatile.LoadUint32(&o.EVENTS_FRAMESTART.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_FRAMESTART() uint32 {
	return volatile.LoadUint32(&o.EVENTS_FRAMESTART.Reg) & 0x1
}

// RADIO.EVENTS_EDEND: Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register
func (o *RADIO_Type) SetEVENTS_EDEND(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EDEND.Reg, volatile.LoadUint32(&o.EVENTS_EDEND.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_EDEND() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EDEND.Reg) & 0x1
}

// RADIO.EVENTS_EDSTOPPED: The sampling of energy detection has stopped
func (o *RADIO_Type) SetEVENTS_EDSTOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EDSTOPPED.Reg, volatile.LoadUint32(&o.EVENTS_EDSTOPPED.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_EDSTOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EDSTOPPED.Reg) & 0x1
}

// RADIO.EVENTS_CCAIDLE: Wireless medium in idle - clear to send
func (o *RADIO_Type) SetEVENTS_CCAIDLE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CCAIDLE.Reg, volatile.LoadUint32(&o.EVENTS_CCAIDLE.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_CCAIDLE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CCAIDLE.Reg) & 0x1
}

// RADIO.EVENTS_CCABUSY: Wireless medium busy - do not send
func (o *RADIO_Type) SetEVENTS_CCABUSY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CCABUSY.Reg, volatile.LoadUint32(&o.EVENTS_CCABUSY.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_CCABUSY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CCABUSY.Reg) & 0x1
}

// RADIO.EVENTS_CCASTOPPED: The CCA has stopped
func (o *RADIO_Type) SetEVENTS_CCASTOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CCASTOPPED.Reg, volatile.LoadUint32(&o.EVENTS_CCASTOPPED.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_CCASTOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CCASTOPPED.Reg) & 0x1
}

// RADIO.EVENTS_RATEBOOST: Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
func (o *RADIO_Type) SetEVENTS_RATEBOOST(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RATEBOOST.Reg, volatile.LoadUint32(&o.EVENTS_RATEBOOST.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_RATEBOOST() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RATEBOOST.Reg) & 0x1
}

// RADIO.EVENTS_TXREADY: RADIO has ramped up and is ready to be started TX path
func (o *RADIO_Type) SetEVENTS_TXREADY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXREADY.Reg, volatile.LoadUint32(&o.EVENTS_TXREADY.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_TXREADY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXREADY.Reg) & 0x1
}

// RADIO.EVENTS_RXREADY: RADIO has ramped up and is ready to be started RX path
func (o *RADIO_Type) SetEVENTS_RXREADY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXREADY.Reg, volatile.LoadUint32(&o.EVENTS_RXREADY.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_RXREADY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXREADY.Reg) & 0x1
}

// RADIO.EVENTS_MHRMATCH: MAC header match found
func (o *RADIO_Type) SetEVENTS_MHRMATCH(value uint32) {
	volatile.StoreUint32(&o.EVENTS_MHRMATCH.Reg, volatile.LoadUint32(&o.EVENTS_MHRMATCH.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_MHRMATCH() uint32 {
	return volatile.LoadUint32(&o.EVENTS_MHRMATCH.Reg) & 0x1
}

// RADIO.EVENTS_SYNC: Preamble indicator
func (o *RADIO_Type) SetEVENTS_SYNC(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SYNC.Reg, volatile.LoadUint32(&o.EVENTS_SYNC.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_SYNC() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SYNC.Reg) & 0x1
}

// RADIO.EVENTS_PHYEND: Generated when last bit is sent on air, or received from air
func (o *RADIO_Type) SetEVENTS_PHYEND(value uint32) {
	volatile.StoreUint32(&o.EVENTS_PHYEND.Reg, volatile.LoadUint32(&o.EVENTS_PHYEND.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_PHYEND() uint32 {
	return volatile.LoadUint32(&o.EVENTS_PHYEND.Reg) & 0x1
}

// RADIO.EVENTS_CTEPRESENT: CTE is present (early warning right after receiving CTEInfo byte)
func (o *RADIO_Type) SetEVENTS_CTEPRESENT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTEPRESENT.Reg, volatile.LoadUint32(&o.EVENTS_CTEPRESENT.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetEVENTS_CTEPRESENT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTEPRESENT.Reg) & 0x1
}

// RADIO.SHORTS: Shortcuts between local events and tasks
func (o *RADIO_Type) SetSHORTS_READY_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetSHORTS_READY_START() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *RADIO_Type) SetSHORTS_END_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetSHORTS_END_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetSHORTS_DISABLED_TXEN(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetSHORTS_DISABLED_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetSHORTS_DISABLED_RXEN(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetSHORTS_DISABLED_RXEN() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetSHORTS_ADDRESS_RSSISTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetSHORTS_ADDRESS_RSSISTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetSHORTS_END_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetSHORTS_END_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetSHORTS_ADDRESS_BCSTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetSHORTS_ADDRESS_BCSTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetSHORTS_DISABLED_RSSISTOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetSHORTS_DISABLED_RSSISTOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}
func (o *RADIO_Type) SetSHORTS_RXREADY_CCASTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x800)|value<<11)
}
func (o *RADIO_Type) GetSHORTS_RXREADY_CCASTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x800) >> 11
}
func (o *RADIO_Type) SetSHORTS_CCAIDLE_TXEN(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetSHORTS_CCAIDLE_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetSHORTS_CCABUSY_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetSHORTS_CCABUSY_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2000) >> 13
}
func (o *RADIO_Type) SetSHORTS_FRAMESTART_BCSTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4000)|value<<14)
}
func (o *RADIO_Type) GetSHORTS_FRAMESTART_BCSTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4000) >> 14
}
func (o *RADIO_Type) SetSHORTS_READY_EDSTART(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8000)|value<<15)
}
func (o *RADIO_Type) GetSHORTS_READY_EDSTART() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8000) >> 15
}
func (o *RADIO_Type) SetSHORTS_EDEND_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10000)|value<<16)
}
func (o *RADIO_Type) GetSHORTS_EDEND_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10000) >> 16
}
func (o *RADIO_Type) SetSHORTS_CCAIDLE_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20000)|value<<17)
}
func (o *RADIO_Type) GetSHORTS_CCAIDLE_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20000) >> 17
}
func (o *RADIO_Type) SetSHORTS_TXREADY_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40000)|value<<18)
}
func (o *RADIO_Type) GetSHORTS_TXREADY_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40000) >> 18
}
func (o *RADIO_Type) SetSHORTS_RXREADY_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x80000)|value<<19)
}
func (o *RADIO_Type) GetSHORTS_RXREADY_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x80000) >> 19
}
func (o *RADIO_Type) SetSHORTS_PHYEND_DISABLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100000)|value<<20)
}
func (o *RADIO_Type) GetSHORTS_PHYEND_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100000) >> 20
}
func (o *RADIO_Type) SetSHORTS_PHYEND_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200000)|value<<21)
}
func (o *RADIO_Type) GetSHORTS_PHYEND_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200000) >> 21
}

// RADIO.INTENSET: Enable interrupt
func (o *RADIO_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *RADIO_Type) SetINTENSET_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetINTENSET_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetINTENSET_PAYLOAD(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetINTENSET_PAYLOAD() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetINTENSET_DISABLED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetINTENSET_DISABLED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetINTENSET_DEVMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetINTENSET_DEVMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetINTENSET_DEVMISS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetINTENSET_DEVMISS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetINTENSET_RSSIEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetINTENSET_RSSIEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetINTENSET_BCMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *RADIO_Type) GetINTENSET_BCMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *RADIO_Type) SetINTENSET_CRCOK(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetINTENSET_CRCOK() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetINTENSET_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetINTENSET_CRCERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *RADIO_Type) SetINTENSET_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *RADIO_Type) GetINTENSET_FRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *RADIO_Type) SetINTENSET_EDEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *RADIO_Type) GetINTENSET_EDEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *RADIO_Type) SetINTENSET_EDSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RADIO_Type) GetINTENSET_EDSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *RADIO_Type) SetINTENSET_CCAIDLE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RADIO_Type) GetINTENSET_CCAIDLE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *RADIO_Type) SetINTENSET_CCABUSY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RADIO_Type) GetINTENSET_CCABUSY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *RADIO_Type) SetINTENSET_CCASTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RADIO_Type) GetINTENSET_CCASTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *RADIO_Type) SetINTENSET_RATEBOOST(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *RADIO_Type) GetINTENSET_RATEBOOST() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *RADIO_Type) SetINTENSET_TXREADY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *RADIO_Type) GetINTENSET_TXREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}
func (o *RADIO_Type) SetINTENSET_RXREADY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400000)|value<<22)
}
func (o *RADIO_Type) GetINTENSET_RXREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400000) >> 22
}
func (o *RADIO_Type) SetINTENSET_MHRMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800000)|value<<23)
}
func (o *RADIO_Type) GetINTENSET_MHRMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800000) >> 23
}
func (o *RADIO_Type) SetINTENSET_SYNC(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *RADIO_Type) GetINTENSET_SYNC() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000000) >> 26
}
func (o *RADIO_Type) SetINTENSET_PHYEND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *RADIO_Type) GetINTENSET_PHYEND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000000) >> 27
}
func (o *RADIO_Type) SetINTENSET_CTEPRESENT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000000)|value<<28)
}
func (o *RADIO_Type) GetINTENSET_CTEPRESENT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000000) >> 28
}

// RADIO.INTENCLR: Disable interrupt
func (o *RADIO_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *RADIO_Type) SetINTENCLR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetINTENCLR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetINTENCLR_PAYLOAD(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetINTENCLR_PAYLOAD() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetINTENCLR_DISABLED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetINTENCLR_DISABLED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetINTENCLR_DEVMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetINTENCLR_DEVMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetINTENCLR_DEVMISS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetINTENCLR_DEVMISS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetINTENCLR_RSSIEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetINTENCLR_RSSIEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetINTENCLR_BCMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *RADIO_Type) GetINTENCLR_BCMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *RADIO_Type) SetINTENCLR_CRCOK(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetINTENCLR_CRCOK() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetINTENCLR_CRCERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetINTENCLR_CRCERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *RADIO_Type) SetINTENCLR_FRAMESTART(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *RADIO_Type) GetINTENCLR_FRAMESTART() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *RADIO_Type) SetINTENCLR_EDEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *RADIO_Type) GetINTENCLR_EDEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *RADIO_Type) SetINTENCLR_EDSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RADIO_Type) GetINTENCLR_EDSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *RADIO_Type) SetINTENCLR_CCAIDLE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RADIO_Type) GetINTENCLR_CCAIDLE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *RADIO_Type) SetINTENCLR_CCABUSY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RADIO_Type) GetINTENCLR_CCABUSY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *RADIO_Type) SetINTENCLR_CCASTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RADIO_Type) GetINTENCLR_CCASTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *RADIO_Type) SetINTENCLR_RATEBOOST(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *RADIO_Type) GetINTENCLR_RATEBOOST() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *RADIO_Type) SetINTENCLR_TXREADY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *RADIO_Type) GetINTENCLR_TXREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}
func (o *RADIO_Type) SetINTENCLR_RXREADY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *RADIO_Type) GetINTENCLR_RXREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400000) >> 22
}
func (o *RADIO_Type) SetINTENCLR_MHRMATCH(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *RADIO_Type) GetINTENCLR_MHRMATCH() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800000) >> 23
}
func (o *RADIO_Type) SetINTENCLR_SYNC(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *RADIO_Type) GetINTENCLR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000000) >> 26
}
func (o *RADIO_Type) SetINTENCLR_PHYEND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *RADIO_Type) GetINTENCLR_PHYEND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000000) >> 27
}
func (o *RADIO_Type) SetINTENCLR_CTEPRESENT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *RADIO_Type) GetINTENCLR_CTEPRESENT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000000) >> 28
}

// RADIO.CRCSTATUS: CRC status
func (o *RADIO_Type) SetCRCSTATUS(value uint32) {
	volatile.StoreUint32(&o.CRCSTATUS.Reg, volatile.LoadUint32(&o.CRCSTATUS.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetCRCSTATUS() uint32 {
	return volatile.LoadUint32(&o.CRCSTATUS.Reg) & 0x1
}

// RADIO.RXMATCH: Received address
func (o *RADIO_Type) SetRXMATCH(value uint32) {
	volatile.StoreUint32(&o.RXMATCH.Reg, volatile.LoadUint32(&o.RXMATCH.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetRXMATCH() uint32 {
	return volatile.LoadUint32(&o.RXMATCH.Reg) & 0x7
}

// RADIO.RXCRC: CRC field of previously received packet
func (o *RADIO_Type) SetRXCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRC.Reg, volatile.LoadUint32(&o.RXCRC.Reg)&^(0xffffff)|value)
}
func (o *RADIO_Type) GetRXCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRC.Reg) & 0xffffff
}

// RADIO.DAI: Device address match index
func (o *RADIO_Type) SetDAI(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetDAI() uint32 {
	return volatile.LoadUint32(&o.DAI.Reg) & 0x7
}

// RADIO.PDUSTAT: Payload status
func (o *RADIO_Type) SetPDUSTAT(value uint32) {
	volatile.StoreUint32(&o.PDUSTAT.Reg, volatile.LoadUint32(&o.PDUSTAT.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetPDUSTAT() uint32 {
	return volatile.LoadUint32(&o.PDUSTAT.Reg) & 0x1
}
func (o *RADIO_Type) SetPDUSTAT_CISTAT(value uint32) {
	volatile.StoreUint32(&o.PDUSTAT.Reg, volatile.LoadUint32(&o.PDUSTAT.Reg)&^(0x6)|value<<1)
}
func (o *RADIO_Type) GetPDUSTAT_CISTAT() uint32 {
	return (volatile.LoadUint32(&o.PDUSTAT.Reg) & 0x6) >> 1
}

// RADIO.CTESTATUS: CTEInfo parsed from received packet
func (o *RADIO_Type) SetCTESTATUS_CTETIME(value uint32) {
	volatile.StoreUint32(&o.CTESTATUS.Reg, volatile.LoadUint32(&o.CTESTATUS.Reg)&^(0x1f)|value)
}
func (o *RADIO_Type) GetCTESTATUS_CTETIME() uint32 {
	return volatile.LoadUint32(&o.CTESTATUS.Reg) & 0x1f
}
func (o *RADIO_Type) SetCTESTATUS_RFU(value uint32) {
	volatile.StoreUint32(&o.CTESTATUS.Reg, volatile.LoadUint32(&o.CTESTATUS.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetCTESTATUS_RFU() uint32 {
	return (volatile.LoadUint32(&o.CTESTATUS.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetCTESTATUS_CTETYPE(value uint32) {
	volatile.StoreUint32(&o.CTESTATUS.Reg, volatile.LoadUint32(&o.CTESTATUS.Reg)&^(0xc0)|value<<6)
}
func (o *RADIO_Type) GetCTESTATUS_CTETYPE() uint32 {
	return (volatile.LoadUint32(&o.CTESTATUS.Reg) & 0xc0) >> 6
}

// RADIO.DFESTATUS: DFE status information
func (o *RADIO_Type) SetDFESTATUS_SWITCHINGSTATE(value uint32) {
	volatile.StoreUint32(&o.DFESTATUS.Reg, volatile.LoadUint32(&o.DFESTATUS.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetDFESTATUS_SWITCHINGSTATE() uint32 {
	return volatile.LoadUint32(&o.DFESTATUS.Reg) & 0x7
}
func (o *RADIO_Type) SetDFESTATUS_SAMPLINGSTATE(value uint32) {
	volatile.StoreUint32(&o.DFESTATUS.Reg, volatile.LoadUint32(&o.DFESTATUS.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetDFESTATUS_SAMPLINGSTATE() uint32 {
	return (volatile.LoadUint32(&o.DFESTATUS.Reg) & 0x10) >> 4
}

// RADIO.PACKETPTR: Packet pointer
func (o *RADIO_Type) SetPACKETPTR(value uint32) {
	volatile.StoreUint32(&o.PACKETPTR.Reg, value)
}
func (o *RADIO_Type) GetPACKETPTR() uint32 {
	return volatile.LoadUint32(&o.PACKETPTR.Reg)
}

// RADIO.FREQUENCY: Frequency
func (o *RADIO_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, volatile.LoadUint32(&o.FREQUENCY.Reg)&^(0x7f)|value)
}
func (o *RADIO_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg) & 0x7f
}
func (o *RADIO_Type) SetFREQUENCY_MAP(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, volatile.LoadUint32(&o.FREQUENCY.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetFREQUENCY_MAP() uint32 {
	return (volatile.LoadUint32(&o.FREQUENCY.Reg) & 0x100) >> 8
}

// RADIO.TXPOWER: Output power
func (o *RADIO_Type) SetTXPOWER(value uint32) {
	volatile.StoreUint32(&o.TXPOWER.Reg, volatile.LoadUint32(&o.TXPOWER.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetTXPOWER() uint32 {
	return volatile.LoadUint32(&o.TXPOWER.Reg) & 0xff
}

// RADIO.MODE: Data rate and modulation
func (o *RADIO_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0xf)|value)
}
func (o *RADIO_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0xf
}

// RADIO.PCNF0: Packet configuration register 0
func (o *RADIO_Type) SetPCNF0_LFLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0xf)|value)
}
func (o *RADIO_Type) GetPCNF0_LFLEN() uint32 {
	return volatile.LoadUint32(&o.PCNF0.Reg) & 0xf
}
func (o *RADIO_Type) SetPCNF0_S0LEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetPCNF0_S0LEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x100) >> 8
}
func (o *RADIO_Type) SetPCNF0_S1LEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0xf0000)|value<<16)
}
func (o *RADIO_Type) GetPCNF0_S1LEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0xf0000) >> 16
}
func (o *RADIO_Type) SetPCNF0_S1INCL(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x100000)|value<<20)
}
func (o *RADIO_Type) GetPCNF0_S1INCL() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x100000) >> 20
}
func (o *RADIO_Type) SetPCNF0_CILEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0xc00000)|value<<22)
}
func (o *RADIO_Type) GetPCNF0_CILEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0xc00000) >> 22
}
func (o *RADIO_Type) SetPCNF0_PLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x3000000)|value<<24)
}
func (o *RADIO_Type) GetPCNF0_PLEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x3000000) >> 24
}
func (o *RADIO_Type) SetPCNF0_CRCINC(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x4000000)|value<<26)
}
func (o *RADIO_Type) GetPCNF0_CRCINC() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x4000000) >> 26
}
func (o *RADIO_Type) SetPCNF0_TERMLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF0.Reg, volatile.LoadUint32(&o.PCNF0.Reg)&^(0x60000000)|value<<29)
}
func (o *RADIO_Type) GetPCNF0_TERMLEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF0.Reg) & 0x60000000) >> 29
}

// RADIO.PCNF1: Packet configuration register 1
func (o *RADIO_Type) SetPCNF1_MAXLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetPCNF1_MAXLEN() uint32 {
	return volatile.LoadUint32(&o.PCNF1.Reg) & 0xff
}
func (o *RADIO_Type) SetPCNF1_STATLEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetPCNF1_STATLEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetPCNF1_BALEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0x70000)|value<<16)
}
func (o *RADIO_Type) GetPCNF1_BALEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0x70000) >> 16
}
func (o *RADIO_Type) SetPCNF1_ENDIAN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0x1000000)|value<<24)
}
func (o *RADIO_Type) GetPCNF1_ENDIAN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0x1000000) >> 24
}
func (o *RADIO_Type) SetPCNF1_WHITEEN(value uint32) {
	volatile.StoreUint32(&o.PCNF1.Reg, volatile.LoadUint32(&o.PCNF1.Reg)&^(0x2000000)|value<<25)
}
func (o *RADIO_Type) GetPCNF1_WHITEEN() uint32 {
	return (volatile.LoadUint32(&o.PCNF1.Reg) & 0x2000000) >> 25
}

// RADIO.BASE0: Base address 0
func (o *RADIO_Type) SetBASE0(value uint32) {
	volatile.StoreUint32(&o.BASE0.Reg, value)
}
func (o *RADIO_Type) GetBASE0() uint32 {
	return volatile.LoadUint32(&o.BASE0.Reg)
}

// RADIO.BASE1: Base address 1
func (o *RADIO_Type) SetBASE1(value uint32) {
	volatile.StoreUint32(&o.BASE1.Reg, value)
}
func (o *RADIO_Type) GetBASE1() uint32 {
	return volatile.LoadUint32(&o.BASE1.Reg)
}

// RADIO.PREFIX0: Prefixes bytes for logical addresses 0-3
func (o *RADIO_Type) SetPREFIX0_AP0(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetPREFIX0_AP0() uint32 {
	return volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff
}
func (o *RADIO_Type) SetPREFIX0_AP1(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetPREFIX0_AP1() uint32 {
	return (volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetPREFIX0_AP2(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff0000)|value<<16)
}
func (o *RADIO_Type) GetPREFIX0_AP2() uint32 {
	return (volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff0000) >> 16
}
func (o *RADIO_Type) SetPREFIX0_AP3(value uint32) {
	volatile.StoreUint32(&o.PREFIX0.Reg, volatile.LoadUint32(&o.PREFIX0.Reg)&^(0xff000000)|value<<24)
}
func (o *RADIO_Type) GetPREFIX0_AP3() uint32 {
	return (volatile.LoadUint32(&o.PREFIX0.Reg) & 0xff000000) >> 24
}

// RADIO.PREFIX1: Prefixes bytes for logical addresses 4-7
func (o *RADIO_Type) SetPREFIX1_AP4(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetPREFIX1_AP4() uint32 {
	return volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff
}
func (o *RADIO_Type) SetPREFIX1_AP5(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetPREFIX1_AP5() uint32 {
	return (volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetPREFIX1_AP6(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff0000)|value<<16)
}
func (o *RADIO_Type) GetPREFIX1_AP6() uint32 {
	return (volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff0000) >> 16
}
func (o *RADIO_Type) SetPREFIX1_AP7(value uint32) {
	volatile.StoreUint32(&o.PREFIX1.Reg, volatile.LoadUint32(&o.PREFIX1.Reg)&^(0xff000000)|value<<24)
}
func (o *RADIO_Type) GetPREFIX1_AP7() uint32 {
	return (volatile.LoadUint32(&o.PREFIX1.Reg) & 0xff000000) >> 24
}

// RADIO.TXADDRESS: Transmit address select
func (o *RADIO_Type) SetTXADDRESS(value uint32) {
	volatile.StoreUint32(&o.TXADDRESS.Reg, volatile.LoadUint32(&o.TXADDRESS.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetTXADDRESS() uint32 {
	return volatile.LoadUint32(&o.TXADDRESS.Reg) & 0x7
}

// RADIO.RXADDRESSES: Receive address select
func (o *RADIO_Type) SetRXADDRESSES_ADDR0(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR0() uint32 {
	return volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x1
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR1(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR1() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR2(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR2() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR3(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR3() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR4(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR4() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR5(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR5() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR6(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR6() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetRXADDRESSES_ADDR7(value uint32) {
	volatile.StoreUint32(&o.RXADDRESSES.Reg, volatile.LoadUint32(&o.RXADDRESSES.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetRXADDRESSES_ADDR7() uint32 {
	return (volatile.LoadUint32(&o.RXADDRESSES.Reg) & 0x80) >> 7
}

// RADIO.CRCCNF: CRC configuration
func (o *RADIO_Type) SetCRCCNF_LEN(value uint32) {
	volatile.StoreUint32(&o.CRCCNF.Reg, volatile.LoadUint32(&o.CRCCNF.Reg)&^(0x3)|value)
}
func (o *RADIO_Type) GetCRCCNF_LEN() uint32 {
	return volatile.LoadUint32(&o.CRCCNF.Reg) & 0x3
}
func (o *RADIO_Type) SetCRCCNF_SKIPADDR(value uint32) {
	volatile.StoreUint32(&o.CRCCNF.Reg, volatile.LoadUint32(&o.CRCCNF.Reg)&^(0x300)|value<<8)
}
func (o *RADIO_Type) GetCRCCNF_SKIPADDR() uint32 {
	return (volatile.LoadUint32(&o.CRCCNF.Reg) & 0x300) >> 8
}

// RADIO.CRCPOLY: CRC polynomial
func (o *RADIO_Type) SetCRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPOLY.Reg, volatile.LoadUint32(&o.CRCPOLY.Reg)&^(0xffffff)|value)
}
func (o *RADIO_Type) GetCRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPOLY.Reg) & 0xffffff
}

// RADIO.CRCINIT: CRC initial value
func (o *RADIO_Type) SetCRCINIT(value uint32) {
	volatile.StoreUint32(&o.CRCINIT.Reg, volatile.LoadUint32(&o.CRCINIT.Reg)&^(0xffffff)|value)
}
func (o *RADIO_Type) GetCRCINIT() uint32 {
	return volatile.LoadUint32(&o.CRCINIT.Reg) & 0xffffff
}

// RADIO.TIFS: Interframe spacing in us
func (o *RADIO_Type) SetTIFS(value uint32) {
	volatile.StoreUint32(&o.TIFS.Reg, volatile.LoadUint32(&o.TIFS.Reg)&^(0x3ff)|value)
}
func (o *RADIO_Type) GetTIFS() uint32 {
	return volatile.LoadUint32(&o.TIFS.Reg) & 0x3ff
}

// RADIO.RSSISAMPLE: RSSI sample
func (o *RADIO_Type) SetRSSISAMPLE(value uint32) {
	volatile.StoreUint32(&o.RSSISAMPLE.Reg, volatile.LoadUint32(&o.RSSISAMPLE.Reg)&^(0x7f)|value)
}
func (o *RADIO_Type) GetRSSISAMPLE() uint32 {
	return volatile.LoadUint32(&o.RSSISAMPLE.Reg) & 0x7f
}

// RADIO.STATE: Current radio state
func (o *RADIO_Type) SetSTATE(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf)|value)
}
func (o *RADIO_Type) GetSTATE() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0xf
}

// RADIO.DATAWHITEIV: Data whitening initial value
func (o *RADIO_Type) SetDATAWHITEIV(value uint32) {
	volatile.StoreUint32(&o.DATAWHITEIV.Reg, volatile.LoadUint32(&o.DATAWHITEIV.Reg)&^(0x7f)|value)
}
func (o *RADIO_Type) GetDATAWHITEIV() uint32 {
	return volatile.LoadUint32(&o.DATAWHITEIV.Reg) & 0x7f
}

// RADIO.BCC: Bit counter compare
func (o *RADIO_Type) SetBCC(value uint32) {
	volatile.StoreUint32(&o.BCC.Reg, value)
}
func (o *RADIO_Type) GetBCC() uint32 {
	return volatile.LoadUint32(&o.BCC.Reg)
}

// RADIO.DAB: Description collection: Device address base segment n
func (o *RADIO_Type) SetDAB(idx int, value uint32) {
	volatile.StoreUint32(&o.DAB[idx].Reg, value)
}
func (o *RADIO_Type) GetDAB(idx int) uint32 {
	return volatile.LoadUint32(&o.DAB[idx].Reg)
}

// RADIO.DAP: Description collection: Device address prefix n
func (o *RADIO_Type) SetDAP(idx int, value uint32) {
	volatile.StoreUint32(&o.DAP[idx].Reg, volatile.LoadUint32(&o.DAP[idx].Reg)&^(0xffff)|value)
}
func (o *RADIO_Type) GetDAP(idx int) uint32 {
	return volatile.LoadUint32(&o.DAP[idx].Reg) & 0xffff
}

// RADIO.DACNF: Device address match configuration
func (o *RADIO_Type) SetDACNF_ENA0(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetDACNF_ENA0() uint32 {
	return volatile.LoadUint32(&o.DACNF.Reg) & 0x1
}
func (o *RADIO_Type) SetDACNF_ENA1(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x2)|value<<1)
}
func (o *RADIO_Type) GetDACNF_ENA1() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x2) >> 1
}
func (o *RADIO_Type) SetDACNF_ENA2(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x4)|value<<2)
}
func (o *RADIO_Type) GetDACNF_ENA2() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x4) >> 2
}
func (o *RADIO_Type) SetDACNF_ENA3(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetDACNF_ENA3() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetDACNF_ENA4(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetDACNF_ENA4() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetDACNF_ENA5(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x20)|value<<5)
}
func (o *RADIO_Type) GetDACNF_ENA5() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x20) >> 5
}
func (o *RADIO_Type) SetDACNF_ENA6(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x40)|value<<6)
}
func (o *RADIO_Type) GetDACNF_ENA6() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x40) >> 6
}
func (o *RADIO_Type) SetDACNF_ENA7(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetDACNF_ENA7() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetDACNF_TXADD0(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x100)|value<<8)
}
func (o *RADIO_Type) GetDACNF_TXADD0() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x100) >> 8
}
func (o *RADIO_Type) SetDACNF_TXADD1(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x200)|value<<9)
}
func (o *RADIO_Type) GetDACNF_TXADD1() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x200) >> 9
}
func (o *RADIO_Type) SetDACNF_TXADD2(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x400)|value<<10)
}
func (o *RADIO_Type) GetDACNF_TXADD2() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x400) >> 10
}
func (o *RADIO_Type) SetDACNF_TXADD3(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x800)|value<<11)
}
func (o *RADIO_Type) GetDACNF_TXADD3() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x800) >> 11
}
func (o *RADIO_Type) SetDACNF_TXADD4(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x1000)|value<<12)
}
func (o *RADIO_Type) GetDACNF_TXADD4() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x1000) >> 12
}
func (o *RADIO_Type) SetDACNF_TXADD5(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x2000)|value<<13)
}
func (o *RADIO_Type) GetDACNF_TXADD5() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x2000) >> 13
}
func (o *RADIO_Type) SetDACNF_TXADD6(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x4000)|value<<14)
}
func (o *RADIO_Type) GetDACNF_TXADD6() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x4000) >> 14
}
func (o *RADIO_Type) SetDACNF_TXADD7(value uint32) {
	volatile.StoreUint32(&o.DACNF.Reg, volatile.LoadUint32(&o.DACNF.Reg)&^(0x8000)|value<<15)
}
func (o *RADIO_Type) GetDACNF_TXADD7() uint32 {
	return (volatile.LoadUint32(&o.DACNF.Reg) & 0x8000) >> 15
}

// RADIO.MHRMATCHCONF: Search pattern configuration
func (o *RADIO_Type) SetMHRMATCHCONF(value uint32) {
	volatile.StoreUint32(&o.MHRMATCHCONF.Reg, value)
}
func (o *RADIO_Type) GetMHRMATCHCONF() uint32 {
	return volatile.LoadUint32(&o.MHRMATCHCONF.Reg)
}

// RADIO.MHRMATCHMAS: Pattern mask
func (o *RADIO_Type) SetMHRMATCHMAS(value uint32) {
	volatile.StoreUint32(&o.MHRMATCHMAS.Reg, value)
}
func (o *RADIO_Type) GetMHRMATCHMAS() uint32 {
	return volatile.LoadUint32(&o.MHRMATCHMAS.Reg)
}

// RADIO.MODECNF0: Radio mode configuration register 0
func (o *RADIO_Type) SetMODECNF0_RU(value uint32) {
	volatile.StoreUint32(&o.MODECNF0.Reg, volatile.LoadUint32(&o.MODECNF0.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetMODECNF0_RU() uint32 {
	return volatile.LoadUint32(&o.MODECNF0.Reg) & 0x1
}
func (o *RADIO_Type) SetMODECNF0_DTX(value uint32) {
	volatile.StoreUint32(&o.MODECNF0.Reg, volatile.LoadUint32(&o.MODECNF0.Reg)&^(0x300)|value<<8)
}
func (o *RADIO_Type) GetMODECNF0_DTX() uint32 {
	return (volatile.LoadUint32(&o.MODECNF0.Reg) & 0x300) >> 8
}

// RADIO.SFD: IEEE 802.15.4 start of frame delimiter
func (o *RADIO_Type) SetSFD(value uint32) {
	volatile.StoreUint32(&o.SFD.Reg, volatile.LoadUint32(&o.SFD.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetSFD() uint32 {
	return volatile.LoadUint32(&o.SFD.Reg) & 0xff
}

// RADIO.EDCNT: IEEE 802.15.4 energy detect loop count
func (o *RADIO_Type) SetEDCNT(value uint32) {
	volatile.StoreUint32(&o.EDCNT.Reg, volatile.LoadUint32(&o.EDCNT.Reg)&^(0x1fffff)|value)
}
func (o *RADIO_Type) GetEDCNT() uint32 {
	return volatile.LoadUint32(&o.EDCNT.Reg) & 0x1fffff
}

// RADIO.EDSAMPLE: IEEE 802.15.4 energy detect level
func (o *RADIO_Type) SetEDSAMPLE_EDLVL(value uint32) {
	volatile.StoreUint32(&o.EDSAMPLE.Reg, volatile.LoadUint32(&o.EDSAMPLE.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetEDSAMPLE_EDLVL() uint32 {
	return volatile.LoadUint32(&o.EDSAMPLE.Reg) & 0xff
}

// RADIO.CCACTRL: IEEE 802.15.4 clear channel assessment control
func (o *RADIO_Type) SetCCACTRL_CCAMODE(value uint32) {
	volatile.StoreUint32(&o.CCACTRL.Reg, volatile.LoadUint32(&o.CCACTRL.Reg)&^(0x7)|value)
}
func (o *RADIO_Type) GetCCACTRL_CCAMODE() uint32 {
	return volatile.LoadUint32(&o.CCACTRL.Reg) & 0x7
}
func (o *RADIO_Type) SetCCACTRL_CCAEDTHRES(value uint32) {
	volatile.StoreUint32(&o.CCACTRL.Reg, volatile.LoadUint32(&o.CCACTRL.Reg)&^(0xff00)|value<<8)
}
func (o *RADIO_Type) GetCCACTRL_CCAEDTHRES() uint32 {
	return (volatile.LoadUint32(&o.CCACTRL.Reg) & 0xff00) >> 8
}
func (o *RADIO_Type) SetCCACTRL_CCACORRTHRES(value uint32) {
	volatile.StoreUint32(&o.CCACTRL.Reg, volatile.LoadUint32(&o.CCACTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *RADIO_Type) GetCCACTRL_CCACORRTHRES() uint32 {
	return (volatile.LoadUint32(&o.CCACTRL.Reg) & 0xff0000) >> 16
}
func (o *RADIO_Type) SetCCACTRL_CCACORRCNT(value uint32) {
	volatile.StoreUint32(&o.CCACTRL.Reg, volatile.LoadUint32(&o.CCACTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *RADIO_Type) GetCCACTRL_CCACORRCNT() uint32 {
	return (volatile.LoadUint32(&o.CCACTRL.Reg) & 0xff000000) >> 24
}

// RADIO.DFEMODE: Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
func (o *RADIO_Type) SetDFEMODE_DFEOPMODE(value uint32) {
	volatile.StoreUint32(&o.DFEMODE.Reg, volatile.LoadUint32(&o.DFEMODE.Reg)&^(0x3)|value)
}
func (o *RADIO_Type) GetDFEMODE_DFEOPMODE() uint32 {
	return volatile.LoadUint32(&o.DFEMODE.Reg) & 0x3
}

// RADIO.CTEINLINECONF: Configuration for CTE inline mode
func (o *RADIO_Type) SetCTEINLINECONF_CTEINLINECTRLEN(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetCTEINLINECONF_CTEINLINECTRLEN() uint32 {
	return volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0x1
}
func (o *RADIO_Type) SetCTEINLINECONF_CTEINFOINS1(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0x8)|value<<3)
}
func (o *RADIO_Type) GetCTEINLINECONF_CTEINFOINS1() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0x8) >> 3
}
func (o *RADIO_Type) SetCTEINLINECONF_CTEERRORHANDLING(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0x10)|value<<4)
}
func (o *RADIO_Type) GetCTEINLINECONF_CTEERRORHANDLING() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0x10) >> 4
}
func (o *RADIO_Type) SetCTEINLINECONF_CTETIMEVALIDRANGE(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0xc0)|value<<6)
}
func (o *RADIO_Type) GetCTEINLINECONF_CTETIMEVALIDRANGE() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0xc0) >> 6
}
func (o *RADIO_Type) SetCTEINLINECONF_CTEINLINERXMODE1US(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0x1c00)|value<<10)
}
func (o *RADIO_Type) GetCTEINLINECONF_CTEINLINERXMODE1US() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0x1c00) >> 10
}
func (o *RADIO_Type) SetCTEINLINECONF_CTEINLINERXMODE2US(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0xe000)|value<<13)
}
func (o *RADIO_Type) GetCTEINLINECONF_CTEINLINERXMODE2US() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0xe000) >> 13
}
func (o *RADIO_Type) SetCTEINLINECONF_S0CONF(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0xff0000)|value<<16)
}
func (o *RADIO_Type) GetCTEINLINECONF_S0CONF() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0xff0000) >> 16
}
func (o *RADIO_Type) SetCTEINLINECONF_S0MASK(value uint32) {
	volatile.StoreUint32(&o.CTEINLINECONF.Reg, volatile.LoadUint32(&o.CTEINLINECONF.Reg)&^(0xff000000)|value<<24)
}
func (o *RADIO_Type) GetCTEINLINECONF_S0MASK() uint32 {
	return (volatile.LoadUint32(&o.CTEINLINECONF.Reg) & 0xff000000) >> 24
}

// RADIO.DFECTRL1: Various configuration for Direction finding
func (o *RADIO_Type) SetDFECTRL1_NUMBEROF8US(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0x3f)|value)
}
func (o *RADIO_Type) GetDFECTRL1_NUMBEROF8US() uint32 {
	return volatile.LoadUint32(&o.DFECTRL1.Reg) & 0x3f
}
func (o *RADIO_Type) SetDFECTRL1_DFEINEXTENSION(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0x80)|value<<7)
}
func (o *RADIO_Type) GetDFECTRL1_DFEINEXTENSION() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0x80) >> 7
}
func (o *RADIO_Type) SetDFECTRL1_TSWITCHSPACING(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0x700)|value<<8)
}
func (o *RADIO_Type) GetDFECTRL1_TSWITCHSPACING() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0x700) >> 8
}
func (o *RADIO_Type) SetDFECTRL1_TSAMPLESPACINGREF(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0x7000)|value<<12)
}
func (o *RADIO_Type) GetDFECTRL1_TSAMPLESPACINGREF() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0x7000) >> 12
}
func (o *RADIO_Type) SetDFECTRL1_SAMPLETYPE(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0x8000)|value<<15)
}
func (o *RADIO_Type) GetDFECTRL1_SAMPLETYPE() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0x8000) >> 15
}
func (o *RADIO_Type) SetDFECTRL1_TSAMPLESPACING(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0x70000)|value<<16)
}
func (o *RADIO_Type) GetDFECTRL1_TSAMPLESPACING() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0x70000) >> 16
}
func (o *RADIO_Type) SetDFECTRL1_REPEATPATTERN(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0xf00000)|value<<20)
}
func (o *RADIO_Type) GetDFECTRL1_REPEATPATTERN() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0xf00000) >> 20
}
func (o *RADIO_Type) SetDFECTRL1_AGCBACKOFFGAIN(value uint32) {
	volatile.StoreUint32(&o.DFECTRL1.Reg, volatile.LoadUint32(&o.DFECTRL1.Reg)&^(0xf000000)|value<<24)
}
func (o *RADIO_Type) GetDFECTRL1_AGCBACKOFFGAIN() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL1.Reg) & 0xf000000) >> 24
}

// RADIO.DFECTRL2: Start offset for Direction finding
func (o *RADIO_Type) SetDFECTRL2_TSWITCHOFFSET(value uint32) {
	volatile.StoreUint32(&o.DFECTRL2.Reg, volatile.LoadUint32(&o.DFECTRL2.Reg)&^(0x1fff)|value)
}
func (o *RADIO_Type) GetDFECTRL2_TSWITCHOFFSET() uint32 {
	return volatile.LoadUint32(&o.DFECTRL2.Reg) & 0x1fff
}
func (o *RADIO_Type) SetDFECTRL2_TSAMPLEOFFSET(value uint32) {
	volatile.StoreUint32(&o.DFECTRL2.Reg, volatile.LoadUint32(&o.DFECTRL2.Reg)&^(0xfff0000)|value<<16)
}
func (o *RADIO_Type) GetDFECTRL2_TSAMPLEOFFSET() uint32 {
	return (volatile.LoadUint32(&o.DFECTRL2.Reg) & 0xfff0000) >> 16
}

// RADIO.SWITCHPATTERN: GPIO patterns to be used for each antenna
func (o *RADIO_Type) SetSWITCHPATTERN(value uint32) {
	volatile.StoreUint32(&o.SWITCHPATTERN.Reg, volatile.LoadUint32(&o.SWITCHPATTERN.Reg)&^(0xff)|value)
}
func (o *RADIO_Type) GetSWITCHPATTERN() uint32 {
	return volatile.LoadUint32(&o.SWITCHPATTERN.Reg) & 0xff
}

// RADIO.CLEARPATTERN: Clear the GPIO pattern array for antenna control
func (o *RADIO_Type) SetCLEARPATTERN(value uint32) {
	volatile.StoreUint32(&o.CLEARPATTERN.Reg, volatile.LoadUint32(&o.CLEARPATTERN.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetCLEARPATTERN() uint32 {
	return volatile.LoadUint32(&o.CLEARPATTERN.Reg) & 0x1
}

// RADIO.POWER: Peripheral power control
func (o *RADIO_Type) SetPOWER(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x1)|value)
}
func (o *RADIO_Type) GetPOWER() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x1
}

// Unspecified
type RADIO_PSEL_Type struct {
	DFEGPIO [8]volatile.Register32 // 0x930
}

// DFE packet EasyDMA channel
type RADIO_DFEPACKET_Type struct {
	PTR    volatile.Register32 // 0x950
	MAXCNT volatile.Register32 // 0x954
	AMOUNT volatile.Register32 // 0x958
}

// RADIO_DFEPACKET.PTR: Data pointer
func (o *RADIO_DFEPACKET_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *RADIO_DFEPACKET_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// RADIO_DFEPACKET.MAXCNT: Maximum number of buffer words to transfer
func (o *RADIO_DFEPACKET_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3fff)|value)
}
func (o *RADIO_DFEPACKET_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3fff
}

// RADIO_DFEPACKET.AMOUNT: Number of samples transferred in the last transaction
func (o *RADIO_DFEPACKET_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0xffff)|value)
}
func (o *RADIO_DFEPACKET_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0xffff
}

// Universal Asynchronous Receiver/Transmitter
type UART_Type struct {
	TASKS_STARTRX volatile.Register32 // 0x0
	TASKS_STOPRX  volatile.Register32 // 0x4
	TASKS_STARTTX volatile.Register32 // 0x8
	TASKS_STOPTX  volatile.Register32 // 0xC
	_             [12]byte
	TASKS_SUSPEND volatile.Register32 // 0x1C
	_             [224]byte
	EVENTS_CTS    volatile.Register32 // 0x100
	EVENTS_NCTS   volatile.Register32 // 0x104
	EVENTS_RXDRDY volatile.Register32 // 0x108
	_             [16]byte
	EVENTS_TXDRDY volatile.Register32 // 0x11C
	_             [4]byte
	EVENTS_ERROR  volatile.Register32 // 0x124
	_             [28]byte
	EVENTS_RXTO   volatile.Register32 // 0x144
	_             [184]byte
	SHORTS        volatile.Register32 // 0x200
	_             [256]byte
	INTENSET      volatile.Register32 // 0x304
	INTENCLR      volatile.Register32 // 0x308
	_             [372]byte
	ERRORSRC      volatile.Register32 // 0x480
	_             [124]byte
	ENABLE        volatile.Register32 // 0x500
	_             [4]byte
	PSEL          UART_PSEL_Type      // 0x508
	RXD           volatile.Register32 // 0x518
	TXD           volatile.Register32 // 0x51C
	_             [4]byte
	BAUDRATE      volatile.Register32 // 0x524
	_             [68]byte
	CONFIG        volatile.Register32 // 0x56C
}

// UART.TASKS_STARTRX: Start UART receiver
func (o *UART_Type) SetTASKS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTRX.Reg, volatile.LoadUint32(&o.TASKS_STARTRX.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetTASKS_STARTRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTRX.Reg) & 0x1
}

// UART.TASKS_STOPRX: Stop UART receiver
func (o *UART_Type) SetTASKS_STOPRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPRX.Reg, volatile.LoadUint32(&o.TASKS_STOPRX.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetTASKS_STOPRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPRX.Reg) & 0x1
}

// UART.TASKS_STARTTX: Start UART transmitter
func (o *UART_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// UART.TASKS_STOPTX: Stop UART transmitter
func (o *UART_Type) SetTASKS_STOPTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPTX.Reg, volatile.LoadUint32(&o.TASKS_STOPTX.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetTASKS_STOPTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPTX.Reg) & 0x1
}

// UART.TASKS_SUSPEND: Suspend UART
func (o *UART_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// UART.EVENTS_CTS: CTS is activated (set low). Clear To Send.
func (o *UART_Type) SetEVENTS_CTS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTS.Reg, volatile.LoadUint32(&o.EVENTS_CTS.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetEVENTS_CTS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTS.Reg) & 0x1
}

// UART.EVENTS_NCTS: CTS is deactivated (set high). Not Clear To Send.
func (o *UART_Type) SetEVENTS_NCTS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_NCTS.Reg, volatile.LoadUint32(&o.EVENTS_NCTS.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetEVENTS_NCTS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_NCTS.Reg) & 0x1
}

// UART.EVENTS_RXDRDY: Data received in RXD
func (o *UART_Type) SetEVENTS_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXDRDY.Reg, volatile.LoadUint32(&o.EVENTS_RXDRDY.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetEVENTS_RXDRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXDRDY.Reg) & 0x1
}

// UART.EVENTS_TXDRDY: Data sent from TXD
func (o *UART_Type) SetEVENTS_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXDRDY.Reg, volatile.LoadUint32(&o.EVENTS_TXDRDY.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetEVENTS_TXDRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXDRDY.Reg) & 0x1
}

// UART.EVENTS_ERROR: Error detected
func (o *UART_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// UART.EVENTS_RXTO: Receiver timeout
func (o *UART_Type) SetEVENTS_RXTO(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXTO.Reg, volatile.LoadUint32(&o.EVENTS_RXTO.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetEVENTS_RXTO() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXTO.Reg) & 0x1
}

// UART.SHORTS: Shortcuts between local events and tasks
func (o *UART_Type) SetSHORTS_CTS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetSHORTS_CTS_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetSHORTS_NCTS_STOPRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetSHORTS_NCTS_STOPRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// UART.INTENSET: Enable interrupt
func (o *UART_Type) SetINTENSET_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINTENSET_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *UART_Type) SetINTENSET_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINTENSET_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINTENSET_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINTENSET_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINTENSET_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINTENSET_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINTENSET_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINTENSET_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}

// UART.INTENCLR: Disable interrupt
func (o *UART_Type) SetINTENCLR_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetINTENCLR_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *UART_Type) SetINTENCLR_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetINTENCLR_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetINTENCLR_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetINTENCLR_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetINTENCLR_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetINTENCLR_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetINTENCLR_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *UART_Type) GetINTENCLR_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}

// UART.ERRORSRC: Error source
func (o *UART_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *UART_Type) SetERRORSRC_PARITY(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetERRORSRC_PARITY() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetERRORSRC_FRAMING(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetERRORSRC_FRAMING() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetERRORSRC_BREAK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetERRORSRC_BREAK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// UART.ENABLE: Enable UART
func (o *UART_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// UART.RXD: RXD register
func (o *UART_Type) SetRXD(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRXD() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0xff
}

// UART.TXD: TXD register
func (o *UART_Type) SetTXD(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetTXD() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0xff
}

// UART.BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
func (o *UART_Type) SetBAUDRATE(value uint32) {
	volatile.StoreUint32(&o.BAUDRATE.Reg, value)
}
func (o *UART_Type) GetBAUDRATE() uint32 {
	return volatile.LoadUint32(&o.BAUDRATE.Reg)
}

// UART.CONFIG: Configuration of parity and hardware flow control
func (o *UART_Type) SetCONFIG_HWFC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetCONFIG_HWFC() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *UART_Type) SetCONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xe)|value<<1)
}
func (o *UART_Type) GetCONFIG_PARITY() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xe) >> 1
}
func (o *UART_Type) SetCONFIG_STOP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetCONFIG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetCONFIG_PARITYTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetCONFIG_PARITYTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}

// Unspecified
type UART_PSEL_Type struct {
	RTS volatile.Register32 // 0x508
	TXD volatile.Register32 // 0x50C
	CTS volatile.Register32 // 0x510
	RXD volatile.Register32 // 0x514
}

// UART_PSEL.RTS: Pin select for RTS
func (o *UART_PSEL_Type) SetRTS_PIN(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x1f)|value)
}
func (o *UART_PSEL_Type) GetRTS_PIN() uint32 {
	return volatile.LoadUint32(&o.RTS.Reg) & 0x1f
}
func (o *UART_PSEL_Type) SetRTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_PSEL_Type) GetRTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RTS.Reg) & 0x80000000) >> 31
}

// UART_PSEL.TXD: Pin select for TXD
func (o *UART_PSEL_Type) SetTXD_PIN(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x1f)|value)
}
func (o *UART_PSEL_Type) GetTXD_PIN() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0x1f
}
func (o *UART_PSEL_Type) SetTXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_PSEL_Type) GetTXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TXD.Reg) & 0x80000000) >> 31
}

// UART_PSEL.CTS: Pin select for CTS
func (o *UART_PSEL_Type) SetCTS_PIN(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x1f)|value)
}
func (o *UART_PSEL_Type) GetCTS_PIN() uint32 {
	return volatile.LoadUint32(&o.CTS.Reg) & 0x1f
}
func (o *UART_PSEL_Type) SetCTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_PSEL_Type) GetCTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CTS.Reg) & 0x80000000) >> 31
}

// UART_PSEL.RXD: Pin select for RXD
func (o *UART_PSEL_Type) SetRXD_PIN(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x1f)|value)
}
func (o *UART_PSEL_Type) GetRXD_PIN() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0x1f
}
func (o *UART_PSEL_Type) SetRXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UART_PSEL_Type) GetRXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RXD.Reg) & 0x80000000) >> 31
}

// UART with EasyDMA
type UARTE_Type struct {
	TASKS_STARTRX    volatile.Register32 // 0x0
	TASKS_STOPRX     volatile.Register32 // 0x4
	TASKS_STARTTX    volatile.Register32 // 0x8
	TASKS_STOPTX     volatile.Register32 // 0xC
	_                [28]byte
	TASKS_FLUSHRX    volatile.Register32 // 0x2C
	_                [208]byte
	EVENTS_CTS       volatile.Register32 // 0x100
	EVENTS_NCTS      volatile.Register32 // 0x104
	EVENTS_RXDRDY    volatile.Register32 // 0x108
	_                [4]byte
	EVENTS_ENDRX     volatile.Register32 // 0x110
	_                [8]byte
	EVENTS_TXDRDY    volatile.Register32 // 0x11C
	EVENTS_ENDTX     volatile.Register32 // 0x120
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [28]byte
	EVENTS_RXTO      volatile.Register32 // 0x144
	_                [4]byte
	EVENTS_RXSTARTED volatile.Register32 // 0x14C
	EVENTS_TXSTARTED volatile.Register32 // 0x150
	_                [4]byte
	EVENTS_TXSTOPPED volatile.Register32 // 0x158
	_                [164]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [372]byte
	ERRORSRC         volatile.Register32 // 0x480
	_                [124]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             UARTE_PSEL_Type // 0x508
	_                [12]byte
	BAUDRATE         volatile.Register32 // 0x524
	_                [12]byte
	RXD              UARTE_RXD_Type // 0x534
	_                [4]byte
	TXD              UARTE_TXD_Type // 0x544
	_                [28]byte
	CONFIG           volatile.Register32 // 0x56C
}

// UARTE.TASKS_STARTRX: Start UART receiver
func (o *UARTE_Type) SetTASKS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTRX.Reg, volatile.LoadUint32(&o.TASKS_STARTRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STARTRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTRX.Reg) & 0x1
}

// UARTE.TASKS_STOPRX: Stop UART receiver
func (o *UARTE_Type) SetTASKS_STOPRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPRX.Reg, volatile.LoadUint32(&o.TASKS_STOPRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STOPRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPRX.Reg) & 0x1
}

// UARTE.TASKS_STARTTX: Start UART transmitter
func (o *UARTE_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// UARTE.TASKS_STOPTX: Stop UART transmitter
func (o *UARTE_Type) SetTASKS_STOPTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPTX.Reg, volatile.LoadUint32(&o.TASKS_STOPTX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_STOPTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPTX.Reg) & 0x1
}

// UARTE.TASKS_FLUSHRX: Flush RX FIFO into RX buffer
func (o *UARTE_Type) SetTASKS_FLUSHRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_FLUSHRX.Reg, volatile.LoadUint32(&o.TASKS_FLUSHRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetTASKS_FLUSHRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_FLUSHRX.Reg) & 0x1
}

// UARTE.EVENTS_CTS: CTS is activated (set low). Clear To Send.
func (o *UARTE_Type) SetEVENTS_CTS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CTS.Reg, volatile.LoadUint32(&o.EVENTS_CTS.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_CTS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CTS.Reg) & 0x1
}

// UARTE.EVENTS_NCTS: CTS is deactivated (set high). Not Clear To Send.
func (o *UARTE_Type) SetEVENTS_NCTS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_NCTS.Reg, volatile.LoadUint32(&o.EVENTS_NCTS.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_NCTS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_NCTS.Reg) & 0x1
}

// UARTE.EVENTS_RXDRDY: Data received in RXD (but potentially not yet transferred to Data RAM)
func (o *UARTE_Type) SetEVENTS_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXDRDY.Reg, volatile.LoadUint32(&o.EVENTS_RXDRDY.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_RXDRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXDRDY.Reg) & 0x1
}

// UARTE.EVENTS_ENDRX: Receive buffer is filled up
func (o *UARTE_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// UARTE.EVENTS_TXDRDY: Data sent from TXD
func (o *UARTE_Type) SetEVENTS_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXDRDY.Reg, volatile.LoadUint32(&o.EVENTS_TXDRDY.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_TXDRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXDRDY.Reg) & 0x1
}

// UARTE.EVENTS_ENDTX: Last TX byte transmitted
func (o *UARTE_Type) SetEVENTS_ENDTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDTX.Reg, volatile.LoadUint32(&o.EVENTS_ENDTX.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_ENDTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDTX.Reg) & 0x1
}

// UARTE.EVENTS_ERROR: Error detected
func (o *UARTE_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// UARTE.EVENTS_RXTO: Receiver timeout
func (o *UARTE_Type) SetEVENTS_RXTO(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXTO.Reg, volatile.LoadUint32(&o.EVENTS_RXTO.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_RXTO() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXTO.Reg) & 0x1
}

// UARTE.EVENTS_RXSTARTED: UART receiver has started
func (o *UARTE_Type) SetEVENTS_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_RXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg) & 0x1
}

// UARTE.EVENTS_TXSTARTED: UART transmitter has started
func (o *UARTE_Type) SetEVENTS_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_TXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg) & 0x1
}

// UARTE.EVENTS_TXSTOPPED: Transmitter stopped
func (o *UARTE_Type) SetEVENTS_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTOPPED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTOPPED.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetEVENTS_TXSTOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTOPPED.Reg) & 0x1
}

// UARTE.SHORTS: Shortcuts between local events and tasks
func (o *UARTE_Type) SetSHORTS_ENDRX_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *UARTE_Type) GetSHORTS_ENDRX_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *UARTE_Type) SetSHORTS_ENDRX_STOPRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *UARTE_Type) GetSHORTS_ENDRX_STOPRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}

// UARTE.INTEN: Enable or disable interrupt
func (o *UARTE_Type) SetINTEN_CTS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTEN_CTS() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *UARTE_Type) SetINTEN_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTEN_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTEN_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTEN_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTEN_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTEN_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTEN_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTEN_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTEN_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTEN_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTEN_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTEN_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTEN_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTEN_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400000) >> 22
}

// UARTE.INTENSET: Enable interrupt
func (o *UARTE_Type) SetINTENSET_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTENSET_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *UARTE_Type) SetINTENSET_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTENSET_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTENSET_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTENSET_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTENSET_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTENSET_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTENSET_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTENSET_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTENSET_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTENSET_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400000) >> 22
}

// UARTE.INTENCLR: Disable interrupt
func (o *UARTE_Type) SetINTENCLR_CTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetINTENCLR_CTS() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *UARTE_Type) SetINTENCLR_NCTS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetINTENCLR_NCTS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetINTENCLR_RXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetINTENCLR_RXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetINTENCLR_TXDRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *UARTE_Type) GetINTENCLR_TXDRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *UARTE_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *UARTE_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *UARTE_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *UARTE_Type) SetINTENCLR_RXTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *UARTE_Type) GetINTENCLR_RXTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *UARTE_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *UARTE_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *UARTE_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *UARTE_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *UARTE_Type) SetINTENCLR_TXSTOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *UARTE_Type) GetINTENCLR_TXSTOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400000) >> 22
}

// UARTE.ERRORSRC: Error source Note : this register is read / write one to clear.
func (o *UARTE_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *UARTE_Type) SetERRORSRC_PARITY(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *UARTE_Type) GetERRORSRC_PARITY() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *UARTE_Type) SetERRORSRC_FRAMING(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *UARTE_Type) GetERRORSRC_FRAMING() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *UARTE_Type) SetERRORSRC_BREAK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *UARTE_Type) GetERRORSRC_BREAK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// UARTE.ENABLE: Enable UART
func (o *UARTE_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *UARTE_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// UARTE.BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
func (o *UARTE_Type) SetBAUDRATE(value uint32) {
	volatile.StoreUint32(&o.BAUDRATE.Reg, value)
}
func (o *UARTE_Type) GetBAUDRATE() uint32 {
	return volatile.LoadUint32(&o.BAUDRATE.Reg)
}

// UARTE.CONFIG: Configuration of parity and hardware flow control
func (o *UARTE_Type) SetCONFIG_HWFC(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *UARTE_Type) GetCONFIG_HWFC() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *UARTE_Type) SetCONFIG_PARITY(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xe)|value<<1)
}
func (o *UARTE_Type) GetCONFIG_PARITY() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xe) >> 1
}
func (o *UARTE_Type) SetCONFIG_STOP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x10)|value<<4)
}
func (o *UARTE_Type) GetCONFIG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x10) >> 4
}
func (o *UARTE_Type) SetCONFIG_PARITYTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *UARTE_Type) GetCONFIG_PARITYTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}

// Unspecified
type UARTE_PSEL_Type struct {
	RTS volatile.Register32 // 0x508
	TXD volatile.Register32 // 0x50C
	CTS volatile.Register32 // 0x510
	RXD volatile.Register32 // 0x514
}

// UARTE_PSEL.RTS: Pin select for RTS signal
func (o *UARTE_PSEL_Type) SetRTS_PIN(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetRTS_PIN() uint32 {
	return volatile.LoadUint32(&o.RTS.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetRTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RTS.Reg, volatile.LoadUint32(&o.RTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetRTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RTS.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.TXD: Pin select for TXD signal
func (o *UARTE_PSEL_Type) SetTXD_PIN(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetTXD_PIN() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetTXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetTXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.TXD.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.CTS: Pin select for CTS signal
func (o *UARTE_PSEL_Type) SetCTS_PIN(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetCTS_PIN() uint32 {
	return volatile.LoadUint32(&o.CTS.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetCTS_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CTS.Reg, volatile.LoadUint32(&o.CTS.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetCTS_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CTS.Reg) & 0x80000000) >> 31
}

// UARTE_PSEL.RXD: Pin select for RXD signal
func (o *UARTE_PSEL_Type) SetRXD_PIN(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x1f)|value)
}
func (o *UARTE_PSEL_Type) GetRXD_PIN() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0x1f
}
func (o *UARTE_PSEL_Type) SetRXD_CONNECT(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0x80000000)|value<<31)
}
func (o *UARTE_PSEL_Type) GetRXD_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.RXD.Reg) & 0x80000000) >> 31
}

// RXD EasyDMA channel
type UARTE_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
}

// UARTE_RXD.PTR: Data pointer
func (o *UARTE_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *UARTE_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// UARTE_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *UARTE_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *UARTE_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// UARTE_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *UARTE_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *UARTE_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// TXD EasyDMA channel
type UARTE_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
}

// UARTE_TXD.PTR: Data pointer
func (o *UARTE_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *UARTE_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// UARTE_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *UARTE_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *UARTE_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// UARTE_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *UARTE_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *UARTE_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// Serial Peripheral Interface 0
type SPI_Type struct {
	_            [264]byte
	EVENTS_READY volatile.Register32 // 0x108
	_            [504]byte
	INTENSET     volatile.Register32 // 0x304
	INTENCLR     volatile.Register32 // 0x308
	_            [500]byte
	ENABLE       volatile.Register32 // 0x500
	_            [4]byte
	PSEL         SPI_PSEL_Type // 0x508
	_            [4]byte
	RXD          volatile.Register32 // 0x518
	TXD          volatile.Register32 // 0x51C
	_            [4]byte
	FREQUENCY    volatile.Register32 // 0x524
	_            [44]byte
	CONFIG       volatile.Register32 // 0x554
}

// SPI.EVENTS_READY: TXD byte sent and RXD byte received
func (o *SPI_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// SPI.INTENSET: Enable interrupt
func (o *SPI_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetINTENSET_READY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// SPI.INTENCLR: Disable interrupt
func (o *SPI_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetINTENCLR_READY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// SPI.ENABLE: Enable SPI
func (o *SPI_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPI.RXD: RXD register
func (o *SPI_Type) SetRXD(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetRXD() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0xff
}

// SPI.TXD: TXD register
func (o *SPI_Type) SetTXD(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetTXD() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0xff
}

// SPI.FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
func (o *SPI_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *SPI_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// SPI.CONFIG: Configuration register
func (o *SPI_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPI_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// Unspecified
type SPI_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MOSI volatile.Register32 // 0x50C
	MISO volatile.Register32 // 0x510
}

// SPI_PSEL.SCK: Pin select for SCK
func (o *SPI_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPI_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPI_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPI_PSEL.MOSI: Pin select for MOSI signal
func (o *SPI_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPI_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPI_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPI_PSEL.MISO: Pin select for MISO signal
func (o *SPI_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPI_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPI_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPI_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

// Serial Peripheral Interface Master with EasyDMA 0
type SPIM_Type struct {
	_              [16]byte
	TASKS_START    volatile.Register32 // 0x10
	TASKS_STOP     volatile.Register32 // 0x14
	_              [4]byte
	TASKS_SUSPEND  volatile.Register32 // 0x1C
	TASKS_RESUME   volatile.Register32 // 0x20
	_              [224]byte
	EVENTS_STOPPED volatile.Register32 // 0x104
	_              [8]byte
	EVENTS_ENDRX   volatile.Register32 // 0x110
	_              [4]byte
	EVENTS_END     volatile.Register32 // 0x118
	_              [4]byte
	EVENTS_ENDTX   volatile.Register32 // 0x120
	_              [40]byte
	EVENTS_STARTED volatile.Register32 // 0x14C
	_              [176]byte
	SHORTS         volatile.Register32 // 0x200
	_              [256]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [500]byte
	ENABLE         volatile.Register32 // 0x500
	_              [4]byte
	PSEL           SPIM_PSEL_Type // 0x508
	_              [16]byte
	FREQUENCY      volatile.Register32 // 0x524
	_              [12]byte
	RXD            SPIM_RXD_Type       // 0x534
	TXD            SPIM_TXD_Type       // 0x544
	CONFIG         volatile.Register32 // 0x554
	_              [104]byte
	ORC            volatile.Register32 // 0x5C0
}

// SPIM.TASKS_START: Start SPI transaction
func (o *SPIM_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// SPIM.TASKS_STOP: Stop SPI transaction
func (o *SPIM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// SPIM.TASKS_SUSPEND: Suspend SPI transaction
func (o *SPIM_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// SPIM.TASKS_RESUME: Resume SPI transaction
func (o *SPIM_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// SPIM.EVENTS_STOPPED: SPI transaction has stopped
func (o *SPIM_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// SPIM.EVENTS_ENDRX: End of RXD buffer reached
func (o *SPIM_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// SPIM.EVENTS_END: End of RXD buffer and TXD buffer reached
func (o *SPIM_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// SPIM.EVENTS_ENDTX: End of TXD buffer reached
func (o *SPIM_Type) SetEVENTS_ENDTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDTX.Reg, volatile.LoadUint32(&o.EVENTS_ENDTX.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_ENDTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDTX.Reg) & 0x1
}

// SPIM.EVENTS_STARTED: Transaction started
func (o *SPIM_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// SPIM.SHORTS: Shortcuts between local events and tasks
func (o *SPIM_Type) SetSHORTS_END_START(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20000)|value<<17)
}
func (o *SPIM_Type) GetSHORTS_END_START() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20000) >> 17
}

// SPIM.INTENSET: Enable interrupt
func (o *SPIM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPIM_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPIM_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *SPIM_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *SPIM_Type) SetINTENSET_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SPIM_Type) GetINTENSET_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *SPIM_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *SPIM_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}

// SPIM.INTENCLR: Disable interrupt
func (o *SPIM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPIM_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPIM_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *SPIM_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *SPIM_Type) SetINTENCLR_ENDTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SPIM_Type) GetINTENCLR_ENDTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *SPIM_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *SPIM_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}

// SPIM.ENABLE: Enable SPIM
func (o *SPIM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPIM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPIM.FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
func (o *SPIM_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *SPIM_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// SPIM.CONFIG: Configuration register
func (o *SPIM_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPIM_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPIM_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPIM_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPIM_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPIM_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// SPIM.ORC: Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
func (o *SPIM_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *SPIM_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

// Unspecified
type SPIM_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MOSI volatile.Register32 // 0x50C
	MISO volatile.Register32 // 0x510
}

// SPIM_PSEL.SCK: Pin select for SCK
func (o *SPIM_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.MOSI: Pin select for MOSI signal
func (o *SPIM_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPIM_PSEL.MISO: Pin select for MISO signal
func (o *SPIM_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPIM_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPIM_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIM_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

// RXD EasyDMA channel
type SPIM_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// SPIM_RXD.PTR: Data pointer
func (o *SPIM_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIM_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIM_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *SPIM_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *SPIM_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// SPIM_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *SPIM_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *SPIM_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// SPIM_RXD.LIST: EasyDMA list type
func (o *SPIM_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIM_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// TXD EasyDMA channel
type SPIM_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// SPIM_TXD.PTR: Data pointer
func (o *SPIM_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIM_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIM_TXD.MAXCNT: Number of bytes in transmit buffer
func (o *SPIM_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *SPIM_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// SPIM_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *SPIM_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *SPIM_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// SPIM_TXD.LIST: EasyDMA list type
func (o *SPIM_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIM_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// SPI Slave 0
type SPIS_Type struct {
	_               [36]byte
	TASKS_ACQUIRE   volatile.Register32 // 0x24
	TASKS_RELEASE   volatile.Register32 // 0x28
	_               [216]byte
	EVENTS_END      volatile.Register32 // 0x104
	_               [8]byte
	EVENTS_ENDRX    volatile.Register32 // 0x110
	_               [20]byte
	EVENTS_ACQUIRED volatile.Register32 // 0x128
	_               [212]byte
	SHORTS          volatile.Register32 // 0x200
	_               [256]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [244]byte
	SEMSTAT         volatile.Register32 // 0x400
	_               [60]byte
	STATUS          volatile.Register32 // 0x440
	_               [188]byte
	ENABLE          volatile.Register32 // 0x500
	_               [4]byte
	PSEL            SPIS_PSEL_Type // 0x508
	_               [28]byte
	RXD             SPIS_RXD_Type       // 0x534
	TXD             SPIS_TXD_Type       // 0x544
	CONFIG          volatile.Register32 // 0x554
	_               [4]byte
	DEF             volatile.Register32 // 0x55C
	_               [96]byte
	ORC             volatile.Register32 // 0x5C0
}

// SPIS.TASKS_ACQUIRE: Acquire SPI semaphore
func (o *SPIS_Type) SetTASKS_ACQUIRE(value uint32) {
	volatile.StoreUint32(&o.TASKS_ACQUIRE.Reg, volatile.LoadUint32(&o.TASKS_ACQUIRE.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetTASKS_ACQUIRE() uint32 {
	return volatile.LoadUint32(&o.TASKS_ACQUIRE.Reg) & 0x1
}

// SPIS.TASKS_RELEASE: Release SPI semaphore, enabling the SPI slave to acquire it
func (o *SPIS_Type) SetTASKS_RELEASE(value uint32) {
	volatile.StoreUint32(&o.TASKS_RELEASE.Reg, volatile.LoadUint32(&o.TASKS_RELEASE.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetTASKS_RELEASE() uint32 {
	return volatile.LoadUint32(&o.TASKS_RELEASE.Reg) & 0x1
}

// SPIS.EVENTS_END: Granted transaction completed
func (o *SPIS_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// SPIS.EVENTS_ENDRX: End of RXD buffer reached
func (o *SPIS_Type) SetEVENTS_ENDRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDRX.Reg, volatile.LoadUint32(&o.EVENTS_ENDRX.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetEVENTS_ENDRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDRX.Reg) & 0x1
}

// SPIS.EVENTS_ACQUIRED: Semaphore acquired
func (o *SPIS_Type) SetEVENTS_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ACQUIRED.Reg, volatile.LoadUint32(&o.EVENTS_ACQUIRED.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetEVENTS_ACQUIRED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ACQUIRED.Reg) & 0x1
}

// SPIS.SHORTS: Shortcuts between local events and tasks
func (o *SPIS_Type) SetSHORTS_END_ACQUIRE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *SPIS_Type) GetSHORTS_END_ACQUIRE() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}

// SPIS.INTENSET: Enable interrupt
func (o *SPIS_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetINTENSET_END() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetINTENSET_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SPIS_Type) GetINTENSET_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SPIS_Type) SetINTENSET_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *SPIS_Type) GetINTENSET_ACQUIRED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}

// SPIS.INTENCLR: Disable interrupt
func (o *SPIS_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetINTENCLR_END() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetINTENCLR_ENDRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SPIS_Type) GetINTENCLR_ENDRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SPIS_Type) SetINTENCLR_ACQUIRED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *SPIS_Type) GetINTENCLR_ACQUIRED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}

// SPIS.SEMSTAT: Semaphore status register
func (o *SPIS_Type) SetSEMSTAT(value uint32) {
	volatile.StoreUint32(&o.SEMSTAT.Reg, volatile.LoadUint32(&o.SEMSTAT.Reg)&^(0x3)|value)
}
func (o *SPIS_Type) GetSEMSTAT() uint32 {
	return volatile.LoadUint32(&o.SEMSTAT.Reg) & 0x3
}

// SPIS.STATUS: Status from last transaction
func (o *SPIS_Type) SetSTATUS_OVERREAD(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetSTATUS_OVERREAD() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *SPIS_Type) SetSTATUS_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetSTATUS_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}

// SPIS.ENABLE: Enable SPI slave
func (o *SPIS_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *SPIS_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// SPIS.CONFIG: Configuration register
func (o *SPIS_Type) SetCONFIG_ORDER(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *SPIS_Type) GetCONFIG_ORDER() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *SPIS_Type) SetCONFIG_CPHA(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SPIS_Type) GetCONFIG_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *SPIS_Type) SetCONFIG_CPOL(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x4)|value<<2)
}
func (o *SPIS_Type) GetCONFIG_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x4) >> 2
}

// SPIS.DEF: Default character. Character clocked out in case of an ignored transaction.
func (o *SPIS_Type) SetDEF(value uint32) {
	volatile.StoreUint32(&o.DEF.Reg, volatile.LoadUint32(&o.DEF.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetDEF() uint32 {
	return volatile.LoadUint32(&o.DEF.Reg) & 0xff
}

// SPIS.ORC: Over-read character
func (o *SPIS_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *SPIS_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

// Unspecified
type SPIS_PSEL_Type struct {
	SCK  volatile.Register32 // 0x508
	MISO volatile.Register32 // 0x50C
	MOSI volatile.Register32 // 0x510
	CSN  volatile.Register32 // 0x514
}

// SPIS_PSEL.SCK: Pin select for SCK
func (o *SPIS_PSEL_Type) SetSCK_PIN(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetSCK_PIN() uint32 {
	return volatile.LoadUint32(&o.SCK.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetSCK_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCK.Reg, volatile.LoadUint32(&o.SCK.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetSCK_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCK.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.MISO: Pin select for MISO signal
func (o *SPIS_PSEL_Type) SetMISO_PIN(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetMISO_PIN() uint32 {
	return volatile.LoadUint32(&o.MISO.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetMISO_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MISO.Reg, volatile.LoadUint32(&o.MISO.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetMISO_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MISO.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.MOSI: Pin select for MOSI signal
func (o *SPIS_PSEL_Type) SetMOSI_PIN(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetMOSI_PIN() uint32 {
	return volatile.LoadUint32(&o.MOSI.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetMOSI_CONNECT(value uint32) {
	volatile.StoreUint32(&o.MOSI.Reg, volatile.LoadUint32(&o.MOSI.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetMOSI_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.MOSI.Reg) & 0x80000000) >> 31
}

// SPIS_PSEL.CSN: Pin select for CSN signal
func (o *SPIS_PSEL_Type) SetCSN_PIN(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x1f)|value)
}
func (o *SPIS_PSEL_Type) GetCSN_PIN() uint32 {
	return volatile.LoadUint32(&o.CSN.Reg) & 0x1f
}
func (o *SPIS_PSEL_Type) SetCSN_CONNECT(value uint32) {
	volatile.StoreUint32(&o.CSN.Reg, volatile.LoadUint32(&o.CSN.Reg)&^(0x80000000)|value<<31)
}
func (o *SPIS_PSEL_Type) GetCSN_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.CSN.Reg) & 0x80000000) >> 31
}

// Unspecified
type SPIS_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// SPIS_RXD.PTR: RXD data pointer
func (o *SPIS_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIS_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIS_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *SPIS_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *SPIS_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// SPIS_RXD.AMOUNT: Number of bytes received in last granted transaction
func (o *SPIS_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *SPIS_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// SPIS_RXD.LIST: EasyDMA list type
func (o *SPIS_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIS_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// Unspecified
type SPIS_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// SPIS_TXD.PTR: TXD data pointer
func (o *SPIS_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *SPIS_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// SPIS_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *SPIS_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *SPIS_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// SPIS_TXD.AMOUNT: Number of bytes transmitted in last granted transaction
func (o *SPIS_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *SPIS_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// SPIS_TXD.LIST: EasyDMA list type
func (o *SPIS_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *SPIS_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// I2C compatible Two-Wire Interface 0
type TWI_Type struct {
	TASKS_STARTRX    volatile.Register32 // 0x0
	_                [4]byte
	TASKS_STARTTX    volatile.Register32 // 0x8
	_                [8]byte
	TASKS_STOP       volatile.Register32 // 0x14
	_                [4]byte
	TASKS_SUSPEND    volatile.Register32 // 0x1C
	TASKS_RESUME     volatile.Register32 // 0x20
	_                [224]byte
	EVENTS_STOPPED   volatile.Register32 // 0x104
	EVENTS_RXDREADY  volatile.Register32 // 0x108
	_                [16]byte
	EVENTS_TXDSENT   volatile.Register32 // 0x11C
	_                [4]byte
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [16]byte
	EVENTS_BB        volatile.Register32 // 0x138
	_                [12]byte
	EVENTS_SUSPENDED volatile.Register32 // 0x148
	_                [180]byte
	SHORTS           volatile.Register32 // 0x200
	_                [256]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [440]byte
	ERRORSRC         volatile.Register32 // 0x4C4
	_                [56]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             TWI_PSEL_Type // 0x508
	_                [8]byte
	RXD              volatile.Register32 // 0x518
	TXD              volatile.Register32 // 0x51C
	_                [4]byte
	FREQUENCY        volatile.Register32 // 0x524
	_                [96]byte
	ADDRESS          volatile.Register32 // 0x588
}

// TWI.TASKS_STARTRX: Start TWI receive sequence
func (o *TWI_Type) SetTASKS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTRX.Reg, volatile.LoadUint32(&o.TASKS_STARTRX.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetTASKS_STARTRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTRX.Reg) & 0x1
}

// TWI.TASKS_STARTTX: Start TWI transmit sequence
func (o *TWI_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// TWI.TASKS_STOP: Stop TWI transaction
func (o *TWI_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TWI.TASKS_SUSPEND: Suspend TWI transaction
func (o *TWI_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// TWI.TASKS_RESUME: Resume TWI transaction
func (o *TWI_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// TWI.EVENTS_STOPPED: TWI stopped
func (o *TWI_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// TWI.EVENTS_RXDREADY: TWI RXD byte received
func (o *TWI_Type) SetEVENTS_RXDREADY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXDREADY.Reg, volatile.LoadUint32(&o.EVENTS_RXDREADY.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetEVENTS_RXDREADY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXDREADY.Reg) & 0x1
}

// TWI.EVENTS_TXDSENT: TWI TXD byte sent
func (o *TWI_Type) SetEVENTS_TXDSENT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXDSENT.Reg, volatile.LoadUint32(&o.EVENTS_TXDSENT.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetEVENTS_TXDSENT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXDSENT.Reg) & 0x1
}

// TWI.EVENTS_ERROR: TWI error
func (o *TWI_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// TWI.EVENTS_BB: TWI byte boundary, generated before each byte that is sent or received
func (o *TWI_Type) SetEVENTS_BB(value uint32) {
	volatile.StoreUint32(&o.EVENTS_BB.Reg, volatile.LoadUint32(&o.EVENTS_BB.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetEVENTS_BB() uint32 {
	return volatile.LoadUint32(&o.EVENTS_BB.Reg) & 0x1
}

// TWI.EVENTS_SUSPENDED: TWI entered the suspended state
func (o *TWI_Type) SetEVENTS_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SUSPENDED.Reg, volatile.LoadUint32(&o.EVENTS_SUSPENDED.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetEVENTS_SUSPENDED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SUSPENDED.Reg) & 0x1
}

// TWI.SHORTS: Shortcuts between local events and tasks
func (o *TWI_Type) SetSHORTS_BB_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetSHORTS_BB_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *TWI_Type) SetSHORTS_BB_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetSHORTS_BB_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}

// TWI.INTENSET: Enable interrupt
func (o *TWI_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetINTENSET_RXDREADY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetINTENSET_RXDREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetINTENSET_TXDSENT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetINTENSET_TXDSENT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *TWI_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetINTENSET_BB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *TWI_Type) GetINTENSET_BB() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *TWI_Type) SetINTENSET_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TWI_Type) GetINTENSET_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}

// TWI.INTENCLR: Disable interrupt
func (o *TWI_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetINTENCLR_RXDREADY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetINTENCLR_RXDREADY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetINTENCLR_TXDSENT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetINTENCLR_TXDSENT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *TWI_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetINTENCLR_BB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *TWI_Type) GetINTENCLR_BB() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *TWI_Type) SetINTENCLR_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TWI_Type) GetINTENCLR_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}

// TWI.ERRORSRC: Error source
func (o *TWI_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWI_Type) SetERRORSRC_ANACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetERRORSRC_ANACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}

// TWI.ENABLE: Enable TWI
func (o *TWI_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWI_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWI.RXD: RXD register
func (o *TWI_Type) SetRXD(value uint32) {
	volatile.StoreUint32(&o.RXD.Reg, volatile.LoadUint32(&o.RXD.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetRXD() uint32 {
	return volatile.LoadUint32(&o.RXD.Reg) & 0xff
}

// TWI.TXD: TXD register
func (o *TWI_Type) SetTXD(value uint32) {
	volatile.StoreUint32(&o.TXD.Reg, volatile.LoadUint32(&o.TXD.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetTXD() uint32 {
	return volatile.LoadUint32(&o.TXD.Reg) & 0xff
}

// TWI.FREQUENCY: TWI frequency. Accuracy depends on the HFCLK source selected.
func (o *TWI_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *TWI_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// TWI.ADDRESS: Address used in the TWI transfer
func (o *TWI_Type) SetADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDRESS.Reg, volatile.LoadUint32(&o.ADDRESS.Reg)&^(0x7f)|value)
}
func (o *TWI_Type) GetADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDRESS.Reg) & 0x7f
}

// Unspecified
type TWI_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWI_PSEL.SCL: Pin select for SCL
func (o *TWI_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWI_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWI_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWI_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWI_PSEL.SDA: Pin select for SDA
func (o *TWI_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWI_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWI_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWI_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

// I2C compatible Two-Wire Master Interface with EasyDMA 0
type TWIM_Type struct {
	TASKS_STARTRX    volatile.Register32 // 0x0
	_                [4]byte
	TASKS_STARTTX    volatile.Register32 // 0x8
	_                [8]byte
	TASKS_STOP       volatile.Register32 // 0x14
	_                [4]byte
	TASKS_SUSPEND    volatile.Register32 // 0x1C
	TASKS_RESUME     volatile.Register32 // 0x20
	_                [224]byte
	EVENTS_STOPPED   volatile.Register32 // 0x104
	_                [28]byte
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [32]byte
	EVENTS_SUSPENDED volatile.Register32 // 0x148
	EVENTS_RXSTARTED volatile.Register32 // 0x14C
	EVENTS_TXSTARTED volatile.Register32 // 0x150
	_                [8]byte
	EVENTS_LASTRX    volatile.Register32 // 0x15C
	EVENTS_LASTTX    volatile.Register32 // 0x160
	_                [156]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [440]byte
	ERRORSRC         volatile.Register32 // 0x4C4
	_                [56]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             TWIM_PSEL_Type // 0x508
	_                [20]byte
	FREQUENCY        volatile.Register32 // 0x524
	_                [12]byte
	RXD              TWIM_RXD_Type // 0x534
	TXD              TWIM_TXD_Type // 0x544
	_                [52]byte
	ADDRESS          volatile.Register32 // 0x588
}

// TWIM.TASKS_STARTRX: Start TWI receive sequence
func (o *TWIM_Type) SetTASKS_STARTRX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTRX.Reg, volatile.LoadUint32(&o.TASKS_STARTRX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_STARTRX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTRX.Reg) & 0x1
}

// TWIM.TASKS_STARTTX: Start TWI transmit sequence
func (o *TWIM_Type) SetTASKS_STARTTX(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTTX.Reg, volatile.LoadUint32(&o.TASKS_STARTTX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_STARTTX() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTTX.Reg) & 0x1
}

// TWIM.TASKS_STOP: Stop TWI transaction. Must be issued while the TWI master is not suspended.
func (o *TWIM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TWIM.TASKS_SUSPEND: Suspend TWI transaction
func (o *TWIM_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// TWIM.TASKS_RESUME: Resume TWI transaction
func (o *TWIM_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// TWIM.EVENTS_STOPPED: TWI stopped
func (o *TWIM_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// TWIM.EVENTS_ERROR: TWI error
func (o *TWIM_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// TWIM.EVENTS_SUSPENDED: Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended.
func (o *TWIM_Type) SetEVENTS_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SUSPENDED.Reg, volatile.LoadUint32(&o.EVENTS_SUSPENDED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_SUSPENDED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SUSPENDED.Reg) & 0x1
}

// TWIM.EVENTS_RXSTARTED: Receive sequence started
func (o *TWIM_Type) SetEVENTS_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_RXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg) & 0x1
}

// TWIM.EVENTS_TXSTARTED: Transmit sequence started
func (o *TWIM_Type) SetEVENTS_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_TXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg) & 0x1
}

// TWIM.EVENTS_LASTRX: Byte boundary, starting to receive the last byte
func (o *TWIM_Type) SetEVENTS_LASTRX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LASTRX.Reg, volatile.LoadUint32(&o.EVENTS_LASTRX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_LASTRX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LASTRX.Reg) & 0x1
}

// TWIM.EVENTS_LASTTX: Byte boundary, starting to transmit the last byte
func (o *TWIM_Type) SetEVENTS_LASTTX(value uint32) {
	volatile.StoreUint32(&o.EVENTS_LASTTX.Reg, volatile.LoadUint32(&o.EVENTS_LASTTX.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetEVENTS_LASTTX() uint32 {
	return volatile.LoadUint32(&o.EVENTS_LASTTX.Reg) & 0x1
}

// TWIM.SHORTS: Shortcuts between local events and tasks
func (o *TWIM_Type) SetSHORTS_LASTTX_STARTRX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x80)|value<<7)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_STARTRX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x80) >> 7
}
func (o *TWIM_Type) SetSHORTS_LASTTX_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}
func (o *TWIM_Type) SetSHORTS_LASTTX_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetSHORTS_LASTTX_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetSHORTS_LASTRX_STARTTX(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x400)|value<<10)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_STARTTX() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x400) >> 10
}
func (o *TWIM_Type) SetSHORTS_LASTRX_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x800)|value<<11)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x800) >> 11
}
func (o *TWIM_Type) SetSHORTS_LASTRX_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1000)|value<<12)
}
func (o *TWIM_Type) GetSHORTS_LASTRX_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x1000) >> 12
}

// TWIM.INTEN: Enable or disable interrupt
func (o *TWIM_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTEN_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTEN_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTEN_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTEN_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTEN_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTEN_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}

// TWIM.INTENSET: Enable interrupt
func (o *TWIM_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTENSET_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTENSET_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTENSET_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTENSET_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTENSET_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTENSET_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}

// TWIM.INTENCLR: Disable interrupt
func (o *TWIM_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWIM_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWIM_Type) SetINTENCLR_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TWIM_Type) GetINTENCLR_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TWIM_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIM_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TWIM_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIM_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TWIM_Type) SetINTENCLR_LASTRX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *TWIM_Type) GetINTENCLR_LASTRX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800000) >> 23
}
func (o *TWIM_Type) SetINTENCLR_LASTTX(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *TWIM_Type) GetINTENCLR_LASTTX() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}

// TWIM.ERRORSRC: Error source
func (o *TWIM_Type) SetERRORSRC_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWIM_Type) GetERRORSRC_OVERRUN() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWIM_Type) SetERRORSRC_ANACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x2)|value<<1)
}
func (o *TWIM_Type) GetERRORSRC_ANACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x2) >> 1
}
func (o *TWIM_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWIM_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}

// TWIM.ENABLE: Enable TWIM
func (o *TWIM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWIM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWIM.FREQUENCY: TWI frequency. Accuracy depends on the HFCLK source selected.
func (o *TWIM_Type) SetFREQUENCY(value uint32) {
	volatile.StoreUint32(&o.FREQUENCY.Reg, value)
}
func (o *TWIM_Type) GetFREQUENCY() uint32 {
	return volatile.LoadUint32(&o.FREQUENCY.Reg)
}

// TWIM.ADDRESS: Address used in the TWI transfer
func (o *TWIM_Type) SetADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDRESS.Reg, volatile.LoadUint32(&o.ADDRESS.Reg)&^(0x7f)|value)
}
func (o *TWIM_Type) GetADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDRESS.Reg) & 0x7f
}

// Unspecified
type TWIM_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWIM_PSEL.SCL: Pin select for SCL signal
func (o *TWIM_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWIM_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWIM_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWIM_PSEL.SDA: Pin select for SDA signal
func (o *TWIM_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWIM_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWIM_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIM_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

// RXD EasyDMA channel
type TWIM_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// TWIM_RXD.PTR: Data pointer
func (o *TWIM_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIM_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIM_RXD.MAXCNT: Maximum number of bytes in receive buffer
func (o *TWIM_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *TWIM_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// TWIM_RXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *TWIM_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *TWIM_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// TWIM_RXD.LIST: EasyDMA list type
func (o *TWIM_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *TWIM_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

// TXD EasyDMA channel
type TWIM_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// TWIM_TXD.PTR: Data pointer
func (o *TWIM_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIM_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIM_TXD.MAXCNT: Maximum number of bytes in transmit buffer
func (o *TWIM_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *TWIM_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// TWIM_TXD.AMOUNT: Number of bytes transferred in the last transaction
func (o *TWIM_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *TWIM_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// TWIM_TXD.LIST: EasyDMA list type
func (o *TWIM_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x7)|value)
}
func (o *TWIM_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x7
}

// I2C compatible Two-Wire Slave Interface with EasyDMA 0
type TWIS_Type struct {
	_                [20]byte
	TASKS_STOP       volatile.Register32 // 0x14
	_                [4]byte
	TASKS_SUSPEND    volatile.Register32 // 0x1C
	TASKS_RESUME     volatile.Register32 // 0x20
	_                [12]byte
	TASKS_PREPARERX  volatile.Register32 // 0x30
	TASKS_PREPARETX  volatile.Register32 // 0x34
	_                [204]byte
	EVENTS_STOPPED   volatile.Register32 // 0x104
	_                [28]byte
	EVENTS_ERROR     volatile.Register32 // 0x124
	_                [36]byte
	EVENTS_RXSTARTED volatile.Register32 // 0x14C
	EVENTS_TXSTARTED volatile.Register32 // 0x150
	_                [16]byte
	EVENTS_WRITE     volatile.Register32 // 0x164
	EVENTS_READ      volatile.Register32 // 0x168
	_                [148]byte
	SHORTS           volatile.Register32 // 0x200
	_                [252]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [452]byte
	ERRORSRC         volatile.Register32 // 0x4D0
	MATCH            volatile.Register32 // 0x4D4
	_                [40]byte
	ENABLE           volatile.Register32 // 0x500
	_                [4]byte
	PSEL             TWIS_PSEL_Type // 0x508
	_                [36]byte
	RXD              TWIS_RXD_Type // 0x534
	TXD              TWIS_TXD_Type // 0x544
	_                [52]byte
	ADDRESS          [2]volatile.Register32 // 0x588
	_                [4]byte
	CONFIG           volatile.Register32 // 0x594
	_                [40]byte
	ORC              volatile.Register32 // 0x5C0
}

// TWIS.TASKS_STOP: Stop TWI transaction
func (o *TWIS_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TWIS.TASKS_SUSPEND: Suspend TWI transaction
func (o *TWIS_Type) SetTASKS_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.TASKS_SUSPEND.Reg, volatile.LoadUint32(&o.TASKS_SUSPEND.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_SUSPEND() uint32 {
	return volatile.LoadUint32(&o.TASKS_SUSPEND.Reg) & 0x1
}

// TWIS.TASKS_RESUME: Resume TWI transaction
func (o *TWIS_Type) SetTASKS_RESUME(value uint32) {
	volatile.StoreUint32(&o.TASKS_RESUME.Reg, volatile.LoadUint32(&o.TASKS_RESUME.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_RESUME() uint32 {
	return volatile.LoadUint32(&o.TASKS_RESUME.Reg) & 0x1
}

// TWIS.TASKS_PREPARERX: Prepare the TWI slave to respond to a write command
func (o *TWIS_Type) SetTASKS_PREPARERX(value uint32) {
	volatile.StoreUint32(&o.TASKS_PREPARERX.Reg, volatile.LoadUint32(&o.TASKS_PREPARERX.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_PREPARERX() uint32 {
	return volatile.LoadUint32(&o.TASKS_PREPARERX.Reg) & 0x1
}

// TWIS.TASKS_PREPARETX: Prepare the TWI slave to respond to a read command
func (o *TWIS_Type) SetTASKS_PREPARETX(value uint32) {
	volatile.StoreUint32(&o.TASKS_PREPARETX.Reg, volatile.LoadUint32(&o.TASKS_PREPARETX.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetTASKS_PREPARETX() uint32 {
	return volatile.LoadUint32(&o.TASKS_PREPARETX.Reg) & 0x1
}

// TWIS.EVENTS_STOPPED: TWI stopped
func (o *TWIS_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// TWIS.EVENTS_ERROR: TWI error
func (o *TWIS_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// TWIS.EVENTS_RXSTARTED: Receive sequence started
func (o *TWIS_Type) SetEVENTS_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_RXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RXSTARTED.Reg) & 0x1
}

// TWIS.EVENTS_TXSTARTED: Transmit sequence started
func (o *TWIS_Type) SetEVENTS_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TXSTARTED.Reg, volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_TXSTARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TXSTARTED.Reg) & 0x1
}

// TWIS.EVENTS_WRITE: Write command received
func (o *TWIS_Type) SetEVENTS_WRITE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_WRITE.Reg, volatile.LoadUint32(&o.EVENTS_WRITE.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_WRITE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_WRITE.Reg) & 0x1
}

// TWIS.EVENTS_READ: Read command received
func (o *TWIS_Type) SetEVENTS_READ(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READ.Reg, volatile.LoadUint32(&o.EVENTS_READ.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetEVENTS_READ() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READ.Reg) & 0x1
}

// TWIS.SHORTS: Shortcuts between local events and tasks
func (o *TWIS_Type) SetSHORTS_WRITE_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2000)|value<<13)
}
func (o *TWIS_Type) GetSHORTS_WRITE_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2000) >> 13
}
func (o *TWIS_Type) SetSHORTS_READ_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4000)|value<<14)
}
func (o *TWIS_Type) GetSHORTS_READ_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4000) >> 14
}

// TWIS.INTEN: Enable or disable interrupt
func (o *TWIS_Type) SetINTEN_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTEN_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTEN_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTEN_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTEN_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTEN_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTEN_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTEN_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTEN_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTEN_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTEN_READ(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTEN_READ() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000000) >> 26
}

// TWIS.INTENSET: Enable interrupt
func (o *TWIS_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTENSET_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTENSET_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTENSET_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTENSET_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTENSET_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTENSET_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTENSET_READ(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTENSET_READ() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000000) >> 26
}

// TWIS.INTENCLR: Disable interrupt
func (o *TWIS_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TWIS_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *TWIS_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *TWIS_Type) SetINTENCLR_RXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TWIS_Type) GetINTENCLR_RXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TWIS_Type) SetINTENCLR_TXSTARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TWIS_Type) GetINTENCLR_TXSTARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TWIS_Type) SetINTENCLR_WRITE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *TWIS_Type) GetINTENCLR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000000) >> 25
}
func (o *TWIS_Type) SetINTENCLR_READ(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *TWIS_Type) GetINTENCLR_READ() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000000) >> 26
}

// TWIS.ERRORSRC: Error source
func (o *TWIS_Type) SetERRORSRC_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetERRORSRC_OVERFLOW() uint32 {
	return volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x1
}
func (o *TWIS_Type) SetERRORSRC_DNACK(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x4)|value<<2)
}
func (o *TWIS_Type) GetERRORSRC_DNACK() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x4) >> 2
}
func (o *TWIS_Type) SetERRORSRC_OVERREAD(value uint32) {
	volatile.StoreUint32(&o.ERRORSRC.Reg, volatile.LoadUint32(&o.ERRORSRC.Reg)&^(0x8)|value<<3)
}
func (o *TWIS_Type) GetERRORSRC_OVERREAD() uint32 {
	return (volatile.LoadUint32(&o.ERRORSRC.Reg) & 0x8) >> 3
}

// TWIS.MATCH: Status register indicating which address had a match
func (o *TWIS_Type) SetMATCH(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetMATCH() uint32 {
	return volatile.LoadUint32(&o.MATCH.Reg) & 0x1
}

// TWIS.ENABLE: Enable TWIS
func (o *TWIS_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0xf)|value)
}
func (o *TWIS_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0xf
}

// TWIS.ADDRESS: Description collection: TWI slave address n
func (o *TWIS_Type) SetADDRESS(idx int, value uint32) {
	volatile.StoreUint32(&o.ADDRESS[idx].Reg, volatile.LoadUint32(&o.ADDRESS[idx].Reg)&^(0x7f)|value)
}
func (o *TWIS_Type) GetADDRESS(idx int) uint32 {
	return volatile.LoadUint32(&o.ADDRESS[idx].Reg) & 0x7f
}

// TWIS.CONFIG: Configuration register for the address match mechanism
func (o *TWIS_Type) SetCONFIG_ADDRESS0(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *TWIS_Type) GetCONFIG_ADDRESS0() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *TWIS_Type) SetCONFIG_ADDRESS1(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *TWIS_Type) GetCONFIG_ADDRESS1() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}

// TWIS.ORC: Over-read character. Character sent out in case of an over-read of the transmit buffer.
func (o *TWIS_Type) SetORC(value uint32) {
	volatile.StoreUint32(&o.ORC.Reg, volatile.LoadUint32(&o.ORC.Reg)&^(0xff)|value)
}
func (o *TWIS_Type) GetORC() uint32 {
	return volatile.LoadUint32(&o.ORC.Reg) & 0xff
}

// Unspecified
type TWIS_PSEL_Type struct {
	SCL volatile.Register32 // 0x508
	SDA volatile.Register32 // 0x50C
}

// TWIS_PSEL.SCL: Pin select for SCL signal
func (o *TWIS_PSEL_Type) SetSCL_PIN(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x1f)|value)
}
func (o *TWIS_PSEL_Type) GetSCL_PIN() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg) & 0x1f
}
func (o *TWIS_PSEL_Type) SetSCL_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, volatile.LoadUint32(&o.SCL.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_PSEL_Type) GetSCL_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SCL.Reg) & 0x80000000) >> 31
}

// TWIS_PSEL.SDA: Pin select for SDA signal
func (o *TWIS_PSEL_Type) SetSDA_PIN(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x1f)|value)
}
func (o *TWIS_PSEL_Type) GetSDA_PIN() uint32 {
	return volatile.LoadUint32(&o.SDA.Reg) & 0x1f
}
func (o *TWIS_PSEL_Type) SetSDA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.SDA.Reg, volatile.LoadUint32(&o.SDA.Reg)&^(0x80000000)|value<<31)
}
func (o *TWIS_PSEL_Type) GetSDA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.SDA.Reg) & 0x80000000) >> 31
}

// RXD EasyDMA channel
type TWIS_RXD_Type struct {
	PTR    volatile.Register32 // 0x534
	MAXCNT volatile.Register32 // 0x538
	AMOUNT volatile.Register32 // 0x53C
	LIST   volatile.Register32 // 0x540
}

// TWIS_RXD.PTR: RXD Data pointer
func (o *TWIS_RXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIS_RXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIS_RXD.MAXCNT: Maximum number of bytes in RXD buffer
func (o *TWIS_RXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *TWIS_RXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// TWIS_RXD.AMOUNT: Number of bytes transferred in the last RXD transaction
func (o *TWIS_RXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *TWIS_RXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// TWIS_RXD.LIST: EasyDMA list type
func (o *TWIS_RXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *TWIS_RXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// TXD EasyDMA channel
type TWIS_TXD_Type struct {
	PTR    volatile.Register32 // 0x544
	MAXCNT volatile.Register32 // 0x548
	AMOUNT volatile.Register32 // 0x54C
	LIST   volatile.Register32 // 0x550
}

// TWIS_TXD.PTR: TXD Data pointer
func (o *TWIS_TXD_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *TWIS_TXD_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// TWIS_TXD.MAXCNT: Maximum number of bytes in TXD buffer
func (o *TWIS_TXD_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7fff)|value)
}
func (o *TWIS_TXD_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7fff
}

// TWIS_TXD.AMOUNT: Number of bytes transferred in the last TXD transaction
func (o *TWIS_TXD_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7fff)|value)
}
func (o *TWIS_TXD_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7fff
}

// TWIS_TXD.LIST: EasyDMA list type
func (o *TWIS_TXD_Type) SetLIST(value uint32) {
	volatile.StoreUint32(&o.LIST.Reg, volatile.LoadUint32(&o.LIST.Reg)&^(0x3)|value)
}
func (o *TWIS_TXD_Type) GetLIST() uint32 {
	return volatile.LoadUint32(&o.LIST.Reg) & 0x3
}

// GPIO Tasks and Events
type GPIOTE_Type struct {
	TASKS_OUT   [8]volatile.Register32 // 0x0
	_           [16]byte
	TASKS_SET   [8]volatile.Register32 // 0x30
	_           [16]byte
	TASKS_CLR   [8]volatile.Register32 // 0x60
	_           [128]byte
	EVENTS_IN   [8]volatile.Register32 // 0x100
	_           [92]byte
	EVENTS_PORT volatile.Register32 // 0x17C
	_           [388]byte
	INTENSET    volatile.Register32 // 0x304
	INTENCLR    volatile.Register32 // 0x308
	_           [516]byte
	CONFIG      [8]volatile.Register32 // 0x510
}

// GPIOTE.TASKS_OUT: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
func (o *GPIOTE_Type) SetTASKS_OUT(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_OUT[idx].Reg, volatile.LoadUint32(&o.TASKS_OUT[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetTASKS_OUT(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_OUT[idx].Reg) & 0x1
}

// GPIOTE.TASKS_SET: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
func (o *GPIOTE_Type) SetTASKS_SET(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_SET[idx].Reg, volatile.LoadUint32(&o.TASKS_SET[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetTASKS_SET(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_SET[idx].Reg) & 0x1
}

// GPIOTE.TASKS_CLR: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
func (o *GPIOTE_Type) SetTASKS_CLR(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_CLR[idx].Reg, volatile.LoadUint32(&o.TASKS_CLR[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetTASKS_CLR(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_CLR[idx].Reg) & 0x1
}

// GPIOTE.EVENTS_IN: Description collection: Event generated from pin specified in CONFIG[n].PSEL
func (o *GPIOTE_Type) SetEVENTS_IN(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_IN[idx].Reg, volatile.LoadUint32(&o.EVENTS_IN[idx].Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetEVENTS_IN(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_IN[idx].Reg) & 0x1
}

// GPIOTE.EVENTS_PORT: Event generated from multiple input GPIO pins with SENSE mechanism enabled
func (o *GPIOTE_Type) SetEVENTS_PORT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_PORT.Reg, volatile.LoadUint32(&o.EVENTS_PORT.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetEVENTS_PORT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_PORT.Reg) & 0x1
}

// GPIOTE.INTENSET: Enable interrupt
func (o *GPIOTE_Type) SetINTENSET_IN0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetINTENSET_IN0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *GPIOTE_Type) SetINTENSET_IN1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *GPIOTE_Type) GetINTENSET_IN1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *GPIOTE_Type) SetINTENSET_IN2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *GPIOTE_Type) GetINTENSET_IN2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *GPIOTE_Type) SetINTENSET_IN3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *GPIOTE_Type) GetINTENSET_IN3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *GPIOTE_Type) SetINTENSET_IN4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *GPIOTE_Type) GetINTENSET_IN4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *GPIOTE_Type) SetINTENSET_IN5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *GPIOTE_Type) GetINTENSET_IN5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *GPIOTE_Type) SetINTENSET_IN6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *GPIOTE_Type) GetINTENSET_IN6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *GPIOTE_Type) SetINTENSET_IN7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *GPIOTE_Type) GetINTENSET_IN7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *GPIOTE_Type) SetINTENSET_PORT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetINTENSET_PORT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000000) >> 31
}

// GPIOTE.INTENCLR: Disable interrupt
func (o *GPIOTE_Type) SetINTENCLR_IN0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *GPIOTE_Type) GetINTENCLR_IN0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *GPIOTE_Type) SetINTENCLR_IN1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPIOTE_Type) GetINTENCLR_IN1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *GPIOTE_Type) SetINTENCLR_IN2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPIOTE_Type) GetINTENCLR_IN2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *GPIOTE_Type) SetINTENCLR_IN3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPIOTE_Type) GetINTENCLR_IN3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *GPIOTE_Type) SetINTENCLR_IN4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPIOTE_Type) GetINTENCLR_IN4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *GPIOTE_Type) SetINTENCLR_IN5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPIOTE_Type) GetINTENCLR_IN5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *GPIOTE_Type) SetINTENCLR_IN6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPIOTE_Type) GetINTENCLR_IN6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *GPIOTE_Type) SetINTENCLR_IN7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPIOTE_Type) GetINTENCLR_IN7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *GPIOTE_Type) SetINTENCLR_PORT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOTE_Type) GetINTENCLR_PORT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000000) >> 31
}

// GPIOTE.CONFIG: Description collection: Configuration for OUT[n], SET[n], and CLR[n] tasks and IN[n] event
func (o *GPIOTE_Type) SetCONFIG_MODE(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x3)|value)
}
func (o *GPIOTE_Type) GetCONFIG_MODE(idx int) uint32 {
	return volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x3
}
func (o *GPIOTE_Type) SetCONFIG_PSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x1f00)|value<<8)
}
func (o *GPIOTE_Type) GetCONFIG_PSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x1f00) >> 8
}
func (o *GPIOTE_Type) SetCONFIG_POLARITY(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *GPIOTE_Type) GetCONFIG_POLARITY(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x30000) >> 16
}
func (o *GPIOTE_Type) SetCONFIG_OUTINIT(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x100000)|value<<20)
}
func (o *GPIOTE_Type) GetCONFIG_OUTINIT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x100000) >> 20
}

// Timer/Counter 0
type TIMER_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	TASKS_STOP     volatile.Register32 // 0x4
	TASKS_COUNT    volatile.Register32 // 0x8
	TASKS_CLEAR    volatile.Register32 // 0xC
	TASKS_SHUTDOWN volatile.Register32 // 0x10
	_              [44]byte
	TASKS_CAPTURE  [6]volatile.Register32 // 0x40
	_              [232]byte
	EVENTS_COMPARE [6]volatile.Register32 // 0x140
	_              [168]byte
	SHORTS         volatile.Register32 // 0x200
	_              [256]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [504]byte
	MODE           volatile.Register32 // 0x504
	BITMODE        volatile.Register32 // 0x508
	_              [4]byte
	PRESCALER      volatile.Register32 // 0x510
	_              [44]byte
	CC             [6]volatile.Register32 // 0x540
}

// TIMER.TASKS_START: Start Timer
func (o *TIMER_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// TIMER.TASKS_STOP: Stop Timer
func (o *TIMER_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TIMER.TASKS_COUNT: Increment Timer (Counter mode only)
func (o *TIMER_Type) SetTASKS_COUNT(value uint32) {
	volatile.StoreUint32(&o.TASKS_COUNT.Reg, volatile.LoadUint32(&o.TASKS_COUNT.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_COUNT() uint32 {
	return volatile.LoadUint32(&o.TASKS_COUNT.Reg) & 0x1
}

// TIMER.TASKS_CLEAR: Clear time
func (o *TIMER_Type) SetTASKS_CLEAR(value uint32) {
	volatile.StoreUint32(&o.TASKS_CLEAR.Reg, volatile.LoadUint32(&o.TASKS_CLEAR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_CLEAR() uint32 {
	return volatile.LoadUint32(&o.TASKS_CLEAR.Reg) & 0x1
}

// TIMER.TASKS_SHUTDOWN: Deprecated register - Shut down timer
func (o *TIMER_Type) SetTASKS_SHUTDOWN(value uint32) {
	volatile.StoreUint32(&o.TASKS_SHUTDOWN.Reg, volatile.LoadUint32(&o.TASKS_SHUTDOWN.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_SHUTDOWN() uint32 {
	return volatile.LoadUint32(&o.TASKS_SHUTDOWN.Reg) & 0x1
}

// TIMER.TASKS_CAPTURE: Description collection: Capture Timer value to CC[n] register
func (o *TIMER_Type) SetTASKS_CAPTURE(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_CAPTURE[idx].Reg, volatile.LoadUint32(&o.TASKS_CAPTURE[idx].Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetTASKS_CAPTURE(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_CAPTURE[idx].Reg) & 0x1
}

// TIMER.EVENTS_COMPARE: Description collection: Compare event on CC[n] match
func (o *TIMER_Type) SetEVENTS_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_COMPARE[idx].Reg, volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetEVENTS_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg) & 0x1
}

// TIMER.SHORTS: Shortcuts between local events and tasks
func (o *TIMER_Type) SetSHORTS_COMPARE0_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetSHORTS_COMPARE0_CLEAR() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *TIMER_Type) SetSHORTS_COMPARE1_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetSHORTS_COMPARE1_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetSHORTS_COMPARE2_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetSHORTS_COMPARE2_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetSHORTS_COMPARE3_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetSHORTS_COMPARE3_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetSHORTS_COMPARE4_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *TIMER_Type) GetSHORTS_COMPARE4_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *TIMER_Type) SetSHORTS_COMPARE5_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *TIMER_Type) GetSHORTS_COMPARE5_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *TIMER_Type) SetSHORTS_COMPARE0_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x100)|value<<8)
}
func (o *TIMER_Type) GetSHORTS_COMPARE0_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x100) >> 8
}
func (o *TIMER_Type) SetSHORTS_COMPARE1_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x200)|value<<9)
}
func (o *TIMER_Type) GetSHORTS_COMPARE1_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x200) >> 9
}
func (o *TIMER_Type) SetSHORTS_COMPARE2_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x400)|value<<10)
}
func (o *TIMER_Type) GetSHORTS_COMPARE2_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x400) >> 10
}
func (o *TIMER_Type) SetSHORTS_COMPARE3_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x800)|value<<11)
}
func (o *TIMER_Type) GetSHORTS_COMPARE3_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x800) >> 11
}
func (o *TIMER_Type) SetSHORTS_COMPARE4_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1000)|value<<12)
}
func (o *TIMER_Type) GetSHORTS_COMPARE4_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x1000) >> 12
}
func (o *TIMER_Type) SetSHORTS_COMPARE5_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2000)|value<<13)
}
func (o *TIMER_Type) GetSHORTS_COMPARE5_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2000) >> 13
}

// TIMER.INTENSET: Enable interrupt
func (o *TIMER_Type) SetINTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTENSET_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTENSET_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTENSET_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTENSET_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}

// TIMER.INTENCLR: Disable interrupt
func (o *TIMER_Type) SetINTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *TIMER_Type) SetINTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *TIMER_Type) SetINTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TIMER_Type) SetINTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TIMER_Type) SetINTENCLR_COMPARE4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TIMER_Type) SetINTENCLR_COMPARE5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *TIMER_Type) GetINTENCLR_COMPARE5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}

// TIMER.MODE: Timer mode selection
func (o *TIMER_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}

// TIMER.BITMODE: Configure the number of bits used by the TIMER
func (o *TIMER_Type) SetBITMODE(value uint32) {
	volatile.StoreUint32(&o.BITMODE.Reg, volatile.LoadUint32(&o.BITMODE.Reg)&^(0x3)|value)
}
func (o *TIMER_Type) GetBITMODE() uint32 {
	return volatile.LoadUint32(&o.BITMODE.Reg) & 0x3
}

// TIMER.PRESCALER: Timer prescaler register
func (o *TIMER_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0xf)|value)
}
func (o *TIMER_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0xf
}

// TIMER.CC: Description collection: Capture/Compare register n
func (o *TIMER_Type) SetCC(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, value)
}
func (o *TIMER_Type) GetCC(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg)
}

// Real time counter 0
type RTC_Type struct {
	TASKS_START      volatile.Register32 // 0x0
	TASKS_STOP       volatile.Register32 // 0x4
	TASKS_CLEAR      volatile.Register32 // 0x8
	TASKS_TRIGOVRFLW volatile.Register32 // 0xC
	_                [240]byte
	EVENTS_TICK      volatile.Register32 // 0x100
	EVENTS_OVRFLW    volatile.Register32 // 0x104
	_                [56]byte
	EVENTS_COMPARE   [4]volatile.Register32 // 0x140
	_                [436]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [52]byte
	EVTEN            volatile.Register32 // 0x340
	EVTENSET         volatile.Register32 // 0x344
	EVTENCLR         volatile.Register32 // 0x348
	_                [440]byte
	COUNTER          volatile.Register32 // 0x504
	PRESCALER        volatile.Register32 // 0x508
	_                [52]byte
	CC               [4]volatile.Register32 // 0x540
}

// RTC.TASKS_START: Start RTC COUNTER
func (o *RTC_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// RTC.TASKS_STOP: Stop RTC COUNTER
func (o *RTC_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// RTC.TASKS_CLEAR: Clear RTC COUNTER
func (o *RTC_Type) SetTASKS_CLEAR(value uint32) {
	volatile.StoreUint32(&o.TASKS_CLEAR.Reg, volatile.LoadUint32(&o.TASKS_CLEAR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_CLEAR() uint32 {
	return volatile.LoadUint32(&o.TASKS_CLEAR.Reg) & 0x1
}

// RTC.TASKS_TRIGOVRFLW: Set COUNTER to 0xFFFFF0
func (o *RTC_Type) SetTASKS_TRIGOVRFLW(value uint32) {
	volatile.StoreUint32(&o.TASKS_TRIGOVRFLW.Reg, volatile.LoadUint32(&o.TASKS_TRIGOVRFLW.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTASKS_TRIGOVRFLW() uint32 {
	return volatile.LoadUint32(&o.TASKS_TRIGOVRFLW.Reg) & 0x1
}

// RTC.EVENTS_TICK: Event on COUNTER increment
func (o *RTC_Type) SetEVENTS_TICK(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TICK.Reg, volatile.LoadUint32(&o.EVENTS_TICK.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVENTS_TICK() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TICK.Reg) & 0x1
}

// RTC.EVENTS_OVRFLW: Event on COUNTER overflow
func (o *RTC_Type) SetEVENTS_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVENTS_OVRFLW.Reg, volatile.LoadUint32(&o.EVENTS_OVRFLW.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVENTS_OVRFLW() uint32 {
	return volatile.LoadUint32(&o.EVENTS_OVRFLW.Reg) & 0x1
}

// RTC.EVENTS_COMPARE: Description collection: Compare event on CC[n] match
func (o *RTC_Type) SetEVENTS_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_COMPARE[idx].Reg, volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVENTS_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_COMPARE[idx].Reg) & 0x1
}

// RTC.INTENSET: Enable interrupt
func (o *RTC_Type) SetINTENSET_TICK(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTENSET_TICK() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *RTC_Type) SetINTENSET_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetINTENSET_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetINTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetINTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetINTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetINTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetINTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetINTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetINTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetINTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}

// RTC.INTENCLR: Disable interrupt
func (o *RTC_Type) SetINTENCLR_TICK(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTENCLR_TICK() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *RTC_Type) SetINTENCLR_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetINTENCLR_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetINTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetINTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetINTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetINTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetINTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetINTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetINTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetINTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}

// RTC.EVTEN: Enable or disable event routing
func (o *RTC_Type) SetEVTEN_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTEN_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTEN.Reg) & 0x1
}
func (o *RTC_Type) SetEVTEN_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTEN_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTEN_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTEN_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTEN_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTEN_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTEN_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTEN_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTEN_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTEN.Reg, volatile.LoadUint32(&o.EVTEN.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTEN_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTEN.Reg) & 0x80000) >> 19
}

// RTC.EVTENSET: Enable event routing
func (o *RTC_Type) SetEVTENSET_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTENSET_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTENSET.Reg) & 0x1
}
func (o *RTC_Type) SetEVTENSET_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTENSET_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTENSET_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTENSET_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTENSET_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTENSET_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTENSET_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTENSET_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTENSET_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTENSET.Reg, volatile.LoadUint32(&o.EVTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTENSET_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTENSET.Reg) & 0x80000) >> 19
}

// RTC.EVTENCLR: Disable event routing
func (o *RTC_Type) SetEVTENCLR_TICK(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetEVTENCLR_TICK() uint32 {
	return volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x1
}
func (o *RTC_Type) SetEVTENCLR_OVRFLW(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetEVTENCLR_OVRFLW() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetEVTENCLR_COMPARE0(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE0() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetEVTENCLR_COMPARE1(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE1() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetEVTENCLR_COMPARE2(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE2() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetEVTENCLR_COMPARE3(value uint32) {
	volatile.StoreUint32(&o.EVTENCLR.Reg, volatile.LoadUint32(&o.EVTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetEVTENCLR_COMPARE3() uint32 {
	return (volatile.LoadUint32(&o.EVTENCLR.Reg) & 0x80000) >> 19
}

// RTC.COUNTER: Current COUNTER value
func (o *RTC_Type) SetCOUNTER(value uint32) {
	volatile.StoreUint32(&o.COUNTER.Reg, volatile.LoadUint32(&o.COUNTER.Reg)&^(0xffffff)|value)
}
func (o *RTC_Type) GetCOUNTER() uint32 {
	return volatile.LoadUint32(&o.COUNTER.Reg) & 0xffffff
}

// RTC.PRESCALER: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
func (o *RTC_Type) SetPRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESCALER.Reg, volatile.LoadUint32(&o.PRESCALER.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetPRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESCALER.Reg) & 0xfff
}

// RTC.CC: Description collection: Compare register n
func (o *RTC_Type) SetCC_COMPARE(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, volatile.LoadUint32(&o.CC[idx].Reg)&^(0xffffff)|value)
}
func (o *RTC_Type) GetCC_COMPARE(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg) & 0xffffff
}

// Temperature Sensor
type TEMP_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	TASKS_STOP     volatile.Register32 // 0x4
	_              [248]byte
	EVENTS_DATARDY volatile.Register32 // 0x100
	_              [512]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [508]byte
	TEMP           volatile.Register32 // 0x508
	_              [20]byte
	A0             volatile.Register32 // 0x520
	A1             volatile.Register32 // 0x524
	A2             volatile.Register32 // 0x528
	A3             volatile.Register32 // 0x52C
	A4             volatile.Register32 // 0x530
	A5             volatile.Register32 // 0x534
	_              [8]byte
	B0             volatile.Register32 // 0x540
	B1             volatile.Register32 // 0x544
	B2             volatile.Register32 // 0x548
	B3             volatile.Register32 // 0x54C
	B4             volatile.Register32 // 0x550
	B5             volatile.Register32 // 0x554
	_              [8]byte
	T0             volatile.Register32 // 0x560
	T1             volatile.Register32 // 0x564
	T2             volatile.Register32 // 0x568
	T3             volatile.Register32 // 0x56C
	T4             volatile.Register32 // 0x570
}

// TEMP.TASKS_START: Start temperature measurement
func (o *TEMP_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// TEMP.TASKS_STOP: Stop temperature measurement
func (o *TEMP_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// TEMP.EVENTS_DATARDY: Temperature measurement complete, data ready
func (o *TEMP_Type) SetEVENTS_DATARDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DATARDY.Reg, volatile.LoadUint32(&o.EVENTS_DATARDY.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetEVENTS_DATARDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DATARDY.Reg) & 0x1
}

// TEMP.INTENSET: Enable interrupt
func (o *TEMP_Type) SetINTENSET_DATARDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetINTENSET_DATARDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// TEMP.INTENCLR: Disable interrupt
func (o *TEMP_Type) SetINTENCLR_DATARDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TEMP_Type) GetINTENCLR_DATARDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// TEMP.TEMP: Temperature in degC (0.25deg steps)
func (o *TEMP_Type) SetTEMP(value uint32) {
	volatile.StoreUint32(&o.TEMP.Reg, value)
}
func (o *TEMP_Type) GetTEMP() uint32 {
	return volatile.LoadUint32(&o.TEMP.Reg)
}

// TEMP.A0: Slope of 1st piece wise linear function
func (o *TEMP_Type) SetA0(value uint32) {
	volatile.StoreUint32(&o.A0.Reg, volatile.LoadUint32(&o.A0.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA0() uint32 {
	return volatile.LoadUint32(&o.A0.Reg) & 0xfff
}

// TEMP.A1: Slope of 2nd piece wise linear function
func (o *TEMP_Type) SetA1(value uint32) {
	volatile.StoreUint32(&o.A1.Reg, volatile.LoadUint32(&o.A1.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA1() uint32 {
	return volatile.LoadUint32(&o.A1.Reg) & 0xfff
}

// TEMP.A2: Slope of 3rd piece wise linear function
func (o *TEMP_Type) SetA2(value uint32) {
	volatile.StoreUint32(&o.A2.Reg, volatile.LoadUint32(&o.A2.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA2() uint32 {
	return volatile.LoadUint32(&o.A2.Reg) & 0xfff
}

// TEMP.A3: Slope of 4th piece wise linear function
func (o *TEMP_Type) SetA3(value uint32) {
	volatile.StoreUint32(&o.A3.Reg, volatile.LoadUint32(&o.A3.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA3() uint32 {
	return volatile.LoadUint32(&o.A3.Reg) & 0xfff
}

// TEMP.A4: Slope of 5th piece wise linear function
func (o *TEMP_Type) SetA4(value uint32) {
	volatile.StoreUint32(&o.A4.Reg, volatile.LoadUint32(&o.A4.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA4() uint32 {
	return volatile.LoadUint32(&o.A4.Reg) & 0xfff
}

// TEMP.A5: Slope of 6th piece wise linear function
func (o *TEMP_Type) SetA5(value uint32) {
	volatile.StoreUint32(&o.A5.Reg, volatile.LoadUint32(&o.A5.Reg)&^(0xfff)|value)
}
func (o *TEMP_Type) GetA5() uint32 {
	return volatile.LoadUint32(&o.A5.Reg) & 0xfff
}

// TEMP.B0: y-intercept of 1st piece wise linear function
func (o *TEMP_Type) SetB0(value uint32) {
	volatile.StoreUint32(&o.B0.Reg, volatile.LoadUint32(&o.B0.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB0() uint32 {
	return volatile.LoadUint32(&o.B0.Reg) & 0x3fff
}

// TEMP.B1: y-intercept of 2nd piece wise linear function
func (o *TEMP_Type) SetB1(value uint32) {
	volatile.StoreUint32(&o.B1.Reg, volatile.LoadUint32(&o.B1.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB1() uint32 {
	return volatile.LoadUint32(&o.B1.Reg) & 0x3fff
}

// TEMP.B2: y-intercept of 3rd piece wise linear function
func (o *TEMP_Type) SetB2(value uint32) {
	volatile.StoreUint32(&o.B2.Reg, volatile.LoadUint32(&o.B2.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB2() uint32 {
	return volatile.LoadUint32(&o.B2.Reg) & 0x3fff
}

// TEMP.B3: y-intercept of 4th piece wise linear function
func (o *TEMP_Type) SetB3(value uint32) {
	volatile.StoreUint32(&o.B3.Reg, volatile.LoadUint32(&o.B3.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB3() uint32 {
	return volatile.LoadUint32(&o.B3.Reg) & 0x3fff
}

// TEMP.B4: y-intercept of 5th piece wise linear function
func (o *TEMP_Type) SetB4(value uint32) {
	volatile.StoreUint32(&o.B4.Reg, volatile.LoadUint32(&o.B4.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB4() uint32 {
	return volatile.LoadUint32(&o.B4.Reg) & 0x3fff
}

// TEMP.B5: y-intercept of 6th piece wise linear function
func (o *TEMP_Type) SetB5(value uint32) {
	volatile.StoreUint32(&o.B5.Reg, volatile.LoadUint32(&o.B5.Reg)&^(0x3fff)|value)
}
func (o *TEMP_Type) GetB5() uint32 {
	return volatile.LoadUint32(&o.B5.Reg) & 0x3fff
}

// TEMP.T0: End point of 1st piece wise linear function
func (o *TEMP_Type) SetT0(value uint32) {
	volatile.StoreUint32(&o.T0.Reg, volatile.LoadUint32(&o.T0.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT0() uint32 {
	return volatile.LoadUint32(&o.T0.Reg) & 0xff
}

// TEMP.T1: End point of 2nd piece wise linear function
func (o *TEMP_Type) SetT1(value uint32) {
	volatile.StoreUint32(&o.T1.Reg, volatile.LoadUint32(&o.T1.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT1() uint32 {
	return volatile.LoadUint32(&o.T1.Reg) & 0xff
}

// TEMP.T2: End point of 3rd piece wise linear function
func (o *TEMP_Type) SetT2(value uint32) {
	volatile.StoreUint32(&o.T2.Reg, volatile.LoadUint32(&o.T2.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT2() uint32 {
	return volatile.LoadUint32(&o.T2.Reg) & 0xff
}

// TEMP.T3: End point of 4th piece wise linear function
func (o *TEMP_Type) SetT3(value uint32) {
	volatile.StoreUint32(&o.T3.Reg, volatile.LoadUint32(&o.T3.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT3() uint32 {
	return volatile.LoadUint32(&o.T3.Reg) & 0xff
}

// TEMP.T4: End point of 5th piece wise linear function
func (o *TEMP_Type) SetT4(value uint32) {
	volatile.StoreUint32(&o.T4.Reg, volatile.LoadUint32(&o.T4.Reg)&^(0xff)|value)
}
func (o *TEMP_Type) GetT4() uint32 {
	return volatile.LoadUint32(&o.T4.Reg) & 0xff
}

// Random Number Generator
type RNG_Type struct {
	TASKS_START   volatile.Register32 // 0x0
	TASKS_STOP    volatile.Register32 // 0x4
	_             [248]byte
	EVENTS_VALRDY volatile.Register32 // 0x100
	_             [252]byte
	SHORTS        volatile.Register32 // 0x200
	_             [256]byte
	INTENSET      volatile.Register32 // 0x304
	INTENCLR      volatile.Register32 // 0x308
	_             [504]byte
	CONFIG        volatile.Register32 // 0x504
	VALUE         volatile.Register32 // 0x508
}

// RNG.TASKS_START: Task starting the random number generator
func (o *RNG_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// RNG.TASKS_STOP: Task stopping the random number generator
func (o *RNG_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// RNG.EVENTS_VALRDY: Event being generated for every new random number written to the VALUE register
func (o *RNG_Type) SetEVENTS_VALRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_VALRDY.Reg, volatile.LoadUint32(&o.EVENTS_VALRDY.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetEVENTS_VALRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_VALRDY.Reg) & 0x1
}

// RNG.SHORTS: Shortcuts between local events and tasks
func (o *RNG_Type) SetSHORTS_VALRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSHORTS_VALRDY_STOP() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}

// RNG.INTENSET: Enable interrupt
func (o *RNG_Type) SetINTENSET_VALRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetINTENSET_VALRDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// RNG.INTENCLR: Disable interrupt
func (o *RNG_Type) SetINTENCLR_VALRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetINTENCLR_VALRDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// RNG.CONFIG: Configuration register
func (o *RNG_Type) SetCONFIG_DERCEN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetCONFIG_DERCEN() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}

// RNG.VALUE: Output random number
func (o *RNG_Type) SetVALUE(value uint32) {
	volatile.StoreUint32(&o.VALUE.Reg, volatile.LoadUint32(&o.VALUE.Reg)&^(0xff)|value)
}
func (o *RNG_Type) GetVALUE() uint32 {
	return volatile.LoadUint32(&o.VALUE.Reg) & 0xff
}

// AES ECB Mode Encryption
type ECB_Type struct {
	TASKS_STARTECB  volatile.Register32 // 0x0
	TASKS_STOPECB   volatile.Register32 // 0x4
	_               [248]byte
	EVENTS_ENDECB   volatile.Register32 // 0x100
	EVENTS_ERRORECB volatile.Register32 // 0x104
	_               [508]byte
	INTENSET        volatile.Register32 // 0x304
	INTENCLR        volatile.Register32 // 0x308
	_               [504]byte
	ECBDATAPTR      volatile.Register32 // 0x504
}

// ECB.TASKS_STARTECB: Start ECB block encrypt
func (o *ECB_Type) SetTASKS_STARTECB(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTECB.Reg, volatile.LoadUint32(&o.TASKS_STARTECB.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetTASKS_STARTECB() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTECB.Reg) & 0x1
}

// ECB.TASKS_STOPECB: Abort a possible executing ECB operation
func (o *ECB_Type) SetTASKS_STOPECB(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOPECB.Reg, volatile.LoadUint32(&o.TASKS_STOPECB.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetTASKS_STOPECB() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOPECB.Reg) & 0x1
}

// ECB.EVENTS_ENDECB: ECB block encrypt complete
func (o *ECB_Type) SetEVENTS_ENDECB(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDECB.Reg, volatile.LoadUint32(&o.EVENTS_ENDECB.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetEVENTS_ENDECB() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDECB.Reg) & 0x1
}

// ECB.EVENTS_ERRORECB: ECB block encrypt aborted because of a STOPECB task or due to an error
func (o *ECB_Type) SetEVENTS_ERRORECB(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERRORECB.Reg, volatile.LoadUint32(&o.EVENTS_ERRORECB.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetEVENTS_ERRORECB() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERRORECB.Reg) & 0x1
}

// ECB.INTENSET: Enable interrupt
func (o *ECB_Type) SetINTENSET_ENDECB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetINTENSET_ENDECB() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *ECB_Type) SetINTENSET_ERRORECB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *ECB_Type) GetINTENSET_ERRORECB() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}

// ECB.INTENCLR: Disable interrupt
func (o *ECB_Type) SetINTENCLR_ENDECB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *ECB_Type) GetINTENCLR_ENDECB() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *ECB_Type) SetINTENCLR_ERRORECB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *ECB_Type) GetINTENCLR_ERRORECB() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}

// ECB.ECBDATAPTR: ECB block encrypt memory pointers
func (o *ECB_Type) SetECBDATAPTR(value uint32) {
	volatile.StoreUint32(&o.ECBDATAPTR.Reg, value)
}
func (o *ECB_Type) GetECBDATAPTR() uint32 {
	return volatile.LoadUint32(&o.ECBDATAPTR.Reg)
}

// Accelerated Address Resolver
type AAR_Type struct {
	TASKS_START        volatile.Register32 // 0x0
	_                  [4]byte
	TASKS_STOP         volatile.Register32 // 0x8
	_                  [244]byte
	EVENTS_END         volatile.Register32 // 0x100
	EVENTS_RESOLVED    volatile.Register32 // 0x104
	EVENTS_NOTRESOLVED volatile.Register32 // 0x108
	_                  [504]byte
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [244]byte
	STATUS             volatile.Register32 // 0x400
	_                  [252]byte
	ENABLE             volatile.Register32 // 0x500
	NIRK               volatile.Register32 // 0x504
	IRKPTR             volatile.Register32 // 0x508
	_                  [4]byte
	ADDRPTR            volatile.Register32 // 0x510
	SCRATCHPTR         volatile.Register32 // 0x514
}

// AAR.TASKS_START: Start resolving addresses based on IRKs specified in the IRK data structure
func (o *AAR_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// AAR.TASKS_STOP: Stop resolving addresses
func (o *AAR_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// AAR.EVENTS_END: Address resolution procedure complete
func (o *AAR_Type) SetEVENTS_END(value uint32) {
	volatile.StoreUint32(&o.EVENTS_END.Reg, volatile.LoadUint32(&o.EVENTS_END.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetEVENTS_END() uint32 {
	return volatile.LoadUint32(&o.EVENTS_END.Reg) & 0x1
}

// AAR.EVENTS_RESOLVED: Address resolved
func (o *AAR_Type) SetEVENTS_RESOLVED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_RESOLVED.Reg, volatile.LoadUint32(&o.EVENTS_RESOLVED.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetEVENTS_RESOLVED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_RESOLVED.Reg) & 0x1
}

// AAR.EVENTS_NOTRESOLVED: Address not resolved
func (o *AAR_Type) SetEVENTS_NOTRESOLVED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_NOTRESOLVED.Reg, volatile.LoadUint32(&o.EVENTS_NOTRESOLVED.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetEVENTS_NOTRESOLVED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_NOTRESOLVED.Reg) & 0x1
}

// AAR.INTENSET: Enable interrupt
func (o *AAR_Type) SetINTENSET_END(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetINTENSET_END() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *AAR_Type) SetINTENSET_RESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *AAR_Type) GetINTENSET_RESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *AAR_Type) SetINTENSET_NOTRESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *AAR_Type) GetINTENSET_NOTRESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// AAR.INTENCLR: Disable interrupt
func (o *AAR_Type) SetINTENCLR_END(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *AAR_Type) GetINTENCLR_END() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *AAR_Type) SetINTENCLR_RESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *AAR_Type) GetINTENCLR_RESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *AAR_Type) SetINTENCLR_NOTRESOLVED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *AAR_Type) GetINTENCLR_NOTRESOLVED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// AAR.STATUS: Resolution status
func (o *AAR_Type) SetSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf)|value)
}
func (o *AAR_Type) GetSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0xf
}

// AAR.ENABLE: Enable AAR
func (o *AAR_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *AAR_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// AAR.NIRK: Number of IRKs
func (o *AAR_Type) SetNIRK(value uint32) {
	volatile.StoreUint32(&o.NIRK.Reg, volatile.LoadUint32(&o.NIRK.Reg)&^(0x1f)|value)
}
func (o *AAR_Type) GetNIRK() uint32 {
	return volatile.LoadUint32(&o.NIRK.Reg) & 0x1f
}

// AAR.IRKPTR: Pointer to IRK data structure
func (o *AAR_Type) SetIRKPTR(value uint32) {
	volatile.StoreUint32(&o.IRKPTR.Reg, value)
}
func (o *AAR_Type) GetIRKPTR() uint32 {
	return volatile.LoadUint32(&o.IRKPTR.Reg)
}

// AAR.ADDRPTR: Pointer to the resolvable address
func (o *AAR_Type) SetADDRPTR(value uint32) {
	volatile.StoreUint32(&o.ADDRPTR.Reg, value)
}
func (o *AAR_Type) GetADDRPTR() uint32 {
	return volatile.LoadUint32(&o.ADDRPTR.Reg)
}

// AAR.SCRATCHPTR: Pointer to data area used for temporary storage
func (o *AAR_Type) SetSCRATCHPTR(value uint32) {
	volatile.StoreUint32(&o.SCRATCHPTR.Reg, value)
}
func (o *AAR_Type) GetSCRATCHPTR() uint32 {
	return volatile.LoadUint32(&o.SCRATCHPTR.Reg)
}

// AES CCM Mode Encryption
type CCM_Type struct {
	TASKS_KSGEN        volatile.Register32 // 0x0
	TASKS_CRYPT        volatile.Register32 // 0x4
	TASKS_STOP         volatile.Register32 // 0x8
	TASKS_RATEOVERRIDE volatile.Register32 // 0xC
	_                  [240]byte
	EVENTS_ENDKSGEN    volatile.Register32 // 0x100
	EVENTS_ENDCRYPT    volatile.Register32 // 0x104
	EVENTS_ERROR       volatile.Register32 // 0x108
	_                  [244]byte
	SHORTS             volatile.Register32 // 0x200
	_                  [256]byte
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [244]byte
	MICSTATUS          volatile.Register32 // 0x400
	_                  [252]byte
	ENABLE             volatile.Register32 // 0x500
	MODE               volatile.Register32 // 0x504
	CNFPTR             volatile.Register32 // 0x508
	INPTR              volatile.Register32 // 0x50C
	OUTPTR             volatile.Register32 // 0x510
	SCRATCHPTR         volatile.Register32 // 0x514
	MAXPACKETSIZE      volatile.Register32 // 0x518
	RATEOVERRIDE       volatile.Register32 // 0x51C
}

// CCM.TASKS_KSGEN: Start generation of key-stream. This operation will stop by itself when completed.
func (o *CCM_Type) SetTASKS_KSGEN(value uint32) {
	volatile.StoreUint32(&o.TASKS_KSGEN.Reg, volatile.LoadUint32(&o.TASKS_KSGEN.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetTASKS_KSGEN() uint32 {
	return volatile.LoadUint32(&o.TASKS_KSGEN.Reg) & 0x1
}

// CCM.TASKS_CRYPT: Start encryption/decryption. This operation will stop by itself when completed.
func (o *CCM_Type) SetTASKS_CRYPT(value uint32) {
	volatile.StoreUint32(&o.TASKS_CRYPT.Reg, volatile.LoadUint32(&o.TASKS_CRYPT.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetTASKS_CRYPT() uint32 {
	return volatile.LoadUint32(&o.TASKS_CRYPT.Reg) & 0x1
}

// CCM.TASKS_STOP: Stop encryption/decryption
func (o *CCM_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// CCM.TASKS_RATEOVERRIDE: Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
func (o *CCM_Type) SetTASKS_RATEOVERRIDE(value uint32) {
	volatile.StoreUint32(&o.TASKS_RATEOVERRIDE.Reg, volatile.LoadUint32(&o.TASKS_RATEOVERRIDE.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetTASKS_RATEOVERRIDE() uint32 {
	return volatile.LoadUint32(&o.TASKS_RATEOVERRIDE.Reg) & 0x1
}

// CCM.EVENTS_ENDKSGEN: Key-stream generation complete
func (o *CCM_Type) SetEVENTS_ENDKSGEN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDKSGEN.Reg, volatile.LoadUint32(&o.EVENTS_ENDKSGEN.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetEVENTS_ENDKSGEN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDKSGEN.Reg) & 0x1
}

// CCM.EVENTS_ENDCRYPT: Encrypt/decrypt complete
func (o *CCM_Type) SetEVENTS_ENDCRYPT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDCRYPT.Reg, volatile.LoadUint32(&o.EVENTS_ENDCRYPT.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetEVENTS_ENDCRYPT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDCRYPT.Reg) & 0x1
}

// CCM.EVENTS_ERROR: Deprecated register - CCM error event
func (o *CCM_Type) SetEVENTS_ERROR(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ERROR.Reg, volatile.LoadUint32(&o.EVENTS_ERROR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetEVENTS_ERROR() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ERROR.Reg) & 0x1
}

// CCM.SHORTS: Shortcuts between local events and tasks
func (o *CCM_Type) SetSHORTS_ENDKSGEN_CRYPT(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetSHORTS_ENDKSGEN_CRYPT() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}

// CCM.INTENSET: Enable interrupt
func (o *CCM_Type) SetINTENSET_ENDKSGEN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetINTENSET_ENDKSGEN() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *CCM_Type) SetINTENSET_ENDCRYPT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *CCM_Type) GetINTENSET_ENDCRYPT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *CCM_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *CCM_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// CCM.INTENCLR: Disable interrupt
func (o *CCM_Type) SetINTENCLR_ENDKSGEN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetINTENCLR_ENDKSGEN() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *CCM_Type) SetINTENCLR_ENDCRYPT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *CCM_Type) GetINTENCLR_ENDCRYPT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *CCM_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *CCM_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// CCM.MICSTATUS: MIC check result
func (o *CCM_Type) SetMICSTATUS(value uint32) {
	volatile.StoreUint32(&o.MICSTATUS.Reg, volatile.LoadUint32(&o.MICSTATUS.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetMICSTATUS() uint32 {
	return volatile.LoadUint32(&o.MICSTATUS.Reg) & 0x1
}

// CCM.ENABLE: Enable
func (o *CCM_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// CCM.MODE: Operation mode
func (o *CCM_Type) SetMODE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetMODE() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x1
}
func (o *CCM_Type) SetMODE_DATARATE(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetMODE_DATARATE() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetMODE_LENGTH(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x1000000)|value<<24)
}
func (o *CCM_Type) GetMODE_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x1000000) >> 24
}

// CCM.CNFPTR: Pointer to data structure holding AES key and NONCE vector
func (o *CCM_Type) SetCNFPTR(value uint32) {
	volatile.StoreUint32(&o.CNFPTR.Reg, value)
}
func (o *CCM_Type) GetCNFPTR() uint32 {
	return volatile.LoadUint32(&o.CNFPTR.Reg)
}

// CCM.INPTR: Input pointer
func (o *CCM_Type) SetINPTR(value uint32) {
	volatile.StoreUint32(&o.INPTR.Reg, value)
}
func (o *CCM_Type) GetINPTR() uint32 {
	return volatile.LoadUint32(&o.INPTR.Reg)
}

// CCM.OUTPTR: Output pointer
func (o *CCM_Type) SetOUTPTR(value uint32) {
	volatile.StoreUint32(&o.OUTPTR.Reg, value)
}
func (o *CCM_Type) GetOUTPTR() uint32 {
	return volatile.LoadUint32(&o.OUTPTR.Reg)
}

// CCM.SCRATCHPTR: Pointer to data area used for temporary storage
func (o *CCM_Type) SetSCRATCHPTR(value uint32) {
	volatile.StoreUint32(&o.SCRATCHPTR.Reg, value)
}
func (o *CCM_Type) GetSCRATCHPTR() uint32 {
	return volatile.LoadUint32(&o.SCRATCHPTR.Reg)
}

// CCM.MAXPACKETSIZE: Length of key-stream generated when MODE.LENGTH = Extended.
func (o *CCM_Type) SetMAXPACKETSIZE(value uint32) {
	volatile.StoreUint32(&o.MAXPACKETSIZE.Reg, volatile.LoadUint32(&o.MAXPACKETSIZE.Reg)&^(0xff)|value)
}
func (o *CCM_Type) GetMAXPACKETSIZE() uint32 {
	return volatile.LoadUint32(&o.MAXPACKETSIZE.Reg) & 0xff
}

// CCM.RATEOVERRIDE: Data rate override setting.
func (o *CCM_Type) SetRATEOVERRIDE(value uint32) {
	volatile.StoreUint32(&o.RATEOVERRIDE.Reg, volatile.LoadUint32(&o.RATEOVERRIDE.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetRATEOVERRIDE() uint32 {
	return volatile.LoadUint32(&o.RATEOVERRIDE.Reg) & 0x3
}

// Watchdog Timer
type WDT_Type struct {
	TASKS_START    volatile.Register32 // 0x0
	_              [252]byte
	EVENTS_TIMEOUT volatile.Register32 // 0x100
	_              [512]byte
	INTENSET       volatile.Register32 // 0x304
	INTENCLR       volatile.Register32 // 0x308
	_              [244]byte
	RUNSTATUS      volatile.Register32 // 0x400
	REQSTATUS      volatile.Register32 // 0x404
	_              [252]byte
	CRV            volatile.Register32 // 0x504
	RREN           volatile.Register32 // 0x508
	CONFIG         volatile.Register32 // 0x50C
	_              [240]byte
	RR             [8]volatile.Register32 // 0x600
}

// WDT.TASKS_START: Start the watchdog
func (o *WDT_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// WDT.EVENTS_TIMEOUT: Watchdog timeout
func (o *WDT_Type) SetEVENTS_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_TIMEOUT.Reg, volatile.LoadUint32(&o.EVENTS_TIMEOUT.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetEVENTS_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_TIMEOUT.Reg) & 0x1
}

// WDT.INTENSET: Enable interrupt
func (o *WDT_Type) SetINTENSET_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENSET_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}

// WDT.INTENCLR: Disable interrupt
func (o *WDT_Type) SetINTENCLR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENCLR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}

// WDT.RUNSTATUS: Run status
func (o *WDT_Type) SetRUNSTATUS(value uint32) {
	volatile.StoreUint32(&o.RUNSTATUS.Reg, volatile.LoadUint32(&o.RUNSTATUS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetRUNSTATUS() uint32 {
	return volatile.LoadUint32(&o.RUNSTATUS.Reg) & 0x1
}

// WDT.REQSTATUS: Request status
func (o *WDT_Type) SetREQSTATUS_RR0(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetREQSTATUS_RR0() uint32 {
	return volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x1
}
func (o *WDT_Type) SetREQSTATUS_RR1(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetREQSTATUS_RR1() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetREQSTATUS_RR2(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetREQSTATUS_RR2() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetREQSTATUS_RR3(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetREQSTATUS_RR3() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetREQSTATUS_RR4(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetREQSTATUS_RR4() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x10) >> 4
}
func (o *WDT_Type) SetREQSTATUS_RR5(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *WDT_Type) GetREQSTATUS_RR5() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x20) >> 5
}
func (o *WDT_Type) SetREQSTATUS_RR6(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetREQSTATUS_RR6() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x40) >> 6
}
func (o *WDT_Type) SetREQSTATUS_RR7(value uint32) {
	volatile.StoreUint32(&o.REQSTATUS.Reg, volatile.LoadUint32(&o.REQSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetREQSTATUS_RR7() uint32 {
	return (volatile.LoadUint32(&o.REQSTATUS.Reg) & 0x80) >> 7
}

// WDT.CRV: Counter reload value
func (o *WDT_Type) SetCRV(value uint32) {
	volatile.StoreUint32(&o.CRV.Reg, value)
}
func (o *WDT_Type) GetCRV() uint32 {
	return volatile.LoadUint32(&o.CRV.Reg)
}

// WDT.RREN: Enable register for reload request registers
func (o *WDT_Type) SetRREN_RR0(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetRREN_RR0() uint32 {
	return volatile.LoadUint32(&o.RREN.Reg) & 0x1
}
func (o *WDT_Type) SetRREN_RR1(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetRREN_RR1() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetRREN_RR2(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetRREN_RR2() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetRREN_RR3(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetRREN_RR3() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetRREN_RR4(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetRREN_RR4() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x10) >> 4
}
func (o *WDT_Type) SetRREN_RR5(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x20)|value<<5)
}
func (o *WDT_Type) GetRREN_RR5() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x20) >> 5
}
func (o *WDT_Type) SetRREN_RR6(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x40)|value<<6)
}
func (o *WDT_Type) GetRREN_RR6() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x40) >> 6
}
func (o *WDT_Type) SetRREN_RR7(value uint32) {
	volatile.StoreUint32(&o.RREN.Reg, volatile.LoadUint32(&o.RREN.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetRREN_RR7() uint32 {
	return (volatile.LoadUint32(&o.RREN.Reg) & 0x80) >> 7
}

// WDT.CONFIG: Configuration register
func (o *WDT_Type) SetCONFIG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetCONFIG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *WDT_Type) SetCONFIG_HALT(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetCONFIG_HALT() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x8) >> 3
}

// WDT.RR: Description collection: Reload request n
func (o *WDT_Type) SetRR(idx int, value uint32) {
	volatile.StoreUint32(&o.RR[idx].Reg, value)
}
func (o *WDT_Type) GetRR(idx int) uint32 {
	return volatile.LoadUint32(&o.RR[idx].Reg)
}

// Quadrature Decoder
type QDEC_Type struct {
	TASKS_START      volatile.Register32 // 0x0
	TASKS_STOP       volatile.Register32 // 0x4
	TASKS_READCLRACC volatile.Register32 // 0x8
	TASKS_RDCLRACC   volatile.Register32 // 0xC
	TASKS_RDCLRDBL   volatile.Register32 // 0x10
	_                [236]byte
	EVENTS_SAMPLERDY volatile.Register32 // 0x100
	EVENTS_REPORTRDY volatile.Register32 // 0x104
	EVENTS_ACCOF     volatile.Register32 // 0x108
	EVENTS_DBLRDY    volatile.Register32 // 0x10C
	EVENTS_STOPPED   volatile.Register32 // 0x110
	_                [236]byte
	SHORTS           volatile.Register32 // 0x200
	_                [256]byte
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
	_                [500]byte
	ENABLE           volatile.Register32 // 0x500
	LEDPOL           volatile.Register32 // 0x504
	SAMPLEPER        volatile.Register32 // 0x508
	SAMPLE           volatile.Register32 // 0x50C
	REPORTPER        volatile.Register32 // 0x510
	ACC              volatile.Register32 // 0x514
	ACCREAD          volatile.Register32 // 0x518
	PSEL             QDEC_PSEL_Type      // 0x51C
	DBFEN            volatile.Register32 // 0x528
	_                [20]byte
	LEDPRE           volatile.Register32 // 0x540
	ACCDBL           volatile.Register32 // 0x544
	ACCDBLREAD       volatile.Register32 // 0x548
}

// QDEC.TASKS_START: Task starting the quadrature decoder
func (o *QDEC_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// QDEC.TASKS_STOP: Task stopping the quadrature decoder
func (o *QDEC_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// QDEC.TASKS_READCLRACC: Read and clear ACC and ACCDBL
func (o *QDEC_Type) SetTASKS_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.TASKS_READCLRACC.Reg, volatile.LoadUint32(&o.TASKS_READCLRACC.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_READCLRACC() uint32 {
	return volatile.LoadUint32(&o.TASKS_READCLRACC.Reg) & 0x1
}

// QDEC.TASKS_RDCLRACC: Read and clear ACC
func (o *QDEC_Type) SetTASKS_RDCLRACC(value uint32) {
	volatile.StoreUint32(&o.TASKS_RDCLRACC.Reg, volatile.LoadUint32(&o.TASKS_RDCLRACC.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_RDCLRACC() uint32 {
	return volatile.LoadUint32(&o.TASKS_RDCLRACC.Reg) & 0x1
}

// QDEC.TASKS_RDCLRDBL: Read and clear ACCDBL
func (o *QDEC_Type) SetTASKS_RDCLRDBL(value uint32) {
	volatile.StoreUint32(&o.TASKS_RDCLRDBL.Reg, volatile.LoadUint32(&o.TASKS_RDCLRDBL.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetTASKS_RDCLRDBL() uint32 {
	return volatile.LoadUint32(&o.TASKS_RDCLRDBL.Reg) & 0x1
}

// QDEC.EVENTS_SAMPLERDY: Event being generated for every new sample value written to the SAMPLE register
func (o *QDEC_Type) SetEVENTS_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SAMPLERDY.Reg, volatile.LoadUint32(&o.EVENTS_SAMPLERDY.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SAMPLERDY.Reg) & 0x1
}

// QDEC.EVENTS_REPORTRDY: Non-null report ready
func (o *QDEC_Type) SetEVENTS_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_REPORTRDY.Reg, volatile.LoadUint32(&o.EVENTS_REPORTRDY.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_REPORTRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_REPORTRDY.Reg) & 0x1
}

// QDEC.EVENTS_ACCOF: ACC or ACCDBL register overflow
func (o *QDEC_Type) SetEVENTS_ACCOF(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ACCOF.Reg, volatile.LoadUint32(&o.EVENTS_ACCOF.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_ACCOF() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ACCOF.Reg) & 0x1
}

// QDEC.EVENTS_DBLRDY: Double displacement(s) detected
func (o *QDEC_Type) SetEVENTS_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DBLRDY.Reg, volatile.LoadUint32(&o.EVENTS_DBLRDY.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_DBLRDY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DBLRDY.Reg) & 0x1
}

// QDEC.EVENTS_STOPPED: QDEC has been stopped
func (o *QDEC_Type) SetEVENTS_STOPPED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STOPPED.Reg, volatile.LoadUint32(&o.EVENTS_STOPPED.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetEVENTS_STOPPED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STOPPED.Reg) & 0x1
}

// QDEC.SHORTS: Shortcuts between local events and tasks
func (o *QDEC_Type) SetSHORTS_REPORTRDY_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_READCLRACC() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *QDEC_Type) SetSHORTS_SAMPLERDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetSHORTS_SAMPLERDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetSHORTS_REPORTRDY_RDCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_RDCLRACC() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetSHORTS_REPORTRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetSHORTS_REPORTRDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetSHORTS_DBLRDY_RDCLRDBL(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetSHORTS_DBLRDY_RDCLRDBL() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}
func (o *QDEC_Type) SetSHORTS_DBLRDY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x20)|value<<5)
}
func (o *QDEC_Type) GetSHORTS_DBLRDY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x20) >> 5
}
func (o *QDEC_Type) SetSHORTS_SAMPLERDY_READCLRACC(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x40)|value<<6)
}
func (o *QDEC_Type) GetSHORTS_SAMPLERDY_READCLRACC() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x40) >> 6
}

// QDEC.INTENSET: Enable interrupt
func (o *QDEC_Type) SetINTENSET_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTENSET_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *QDEC_Type) SetINTENSET_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTENSET_REPORTRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTENSET_ACCOF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTENSET_ACCOF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTENSET_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTENSET_DBLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetINTENSET_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetINTENSET_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}

// QDEC.INTENCLR: Disable interrupt
func (o *QDEC_Type) SetINTENCLR_SAMPLERDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetINTENCLR_SAMPLERDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *QDEC_Type) SetINTENCLR_REPORTRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *QDEC_Type) GetINTENCLR_REPORTRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *QDEC_Type) SetINTENCLR_ACCOF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *QDEC_Type) GetINTENCLR_ACCOF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *QDEC_Type) SetINTENCLR_DBLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *QDEC_Type) GetINTENCLR_DBLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *QDEC_Type) SetINTENCLR_STOPPED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *QDEC_Type) GetINTENCLR_STOPPED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}

// QDEC.ENABLE: Enable the quadrature decoder
func (o *QDEC_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// QDEC.LEDPOL: LED output pin polarity
func (o *QDEC_Type) SetLEDPOL(value uint32) {
	volatile.StoreUint32(&o.LEDPOL.Reg, volatile.LoadUint32(&o.LEDPOL.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetLEDPOL() uint32 {
	return volatile.LoadUint32(&o.LEDPOL.Reg) & 0x1
}

// QDEC.SAMPLEPER: Sample period
func (o *QDEC_Type) SetSAMPLEPER(value uint32) {
	volatile.StoreUint32(&o.SAMPLEPER.Reg, volatile.LoadUint32(&o.SAMPLEPER.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetSAMPLEPER() uint32 {
	return volatile.LoadUint32(&o.SAMPLEPER.Reg) & 0xf
}

// QDEC.SAMPLE: Motion sample value
func (o *QDEC_Type) SetSAMPLE(value uint32) {
	volatile.StoreUint32(&o.SAMPLE.Reg, value)
}
func (o *QDEC_Type) GetSAMPLE() uint32 {
	return volatile.LoadUint32(&o.SAMPLE.Reg)
}

// QDEC.REPORTPER: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
func (o *QDEC_Type) SetREPORTPER(value uint32) {
	volatile.StoreUint32(&o.REPORTPER.Reg, volatile.LoadUint32(&o.REPORTPER.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetREPORTPER() uint32 {
	return volatile.LoadUint32(&o.REPORTPER.Reg) & 0xf
}

// QDEC.ACC: Register accumulating the valid transitions
func (o *QDEC_Type) SetACC(value uint32) {
	volatile.StoreUint32(&o.ACC.Reg, value)
}
func (o *QDEC_Type) GetACC() uint32 {
	return volatile.LoadUint32(&o.ACC.Reg)
}

// QDEC.ACCREAD: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
func (o *QDEC_Type) SetACCREAD(value uint32) {
	volatile.StoreUint32(&o.ACCREAD.Reg, value)
}
func (o *QDEC_Type) GetACCREAD() uint32 {
	return volatile.LoadUint32(&o.ACCREAD.Reg)
}

// QDEC.DBFEN: Enable input debounce filters
func (o *QDEC_Type) SetDBFEN(value uint32) {
	volatile.StoreUint32(&o.DBFEN.Reg, volatile.LoadUint32(&o.DBFEN.Reg)&^(0x1)|value)
}
func (o *QDEC_Type) GetDBFEN() uint32 {
	return volatile.LoadUint32(&o.DBFEN.Reg) & 0x1
}

// QDEC.LEDPRE: Time period the LED is switched ON prior to sampling
func (o *QDEC_Type) SetLEDPRE(value uint32) {
	volatile.StoreUint32(&o.LEDPRE.Reg, volatile.LoadUint32(&o.LEDPRE.Reg)&^(0x1ff)|value)
}
func (o *QDEC_Type) GetLEDPRE() uint32 {
	return volatile.LoadUint32(&o.LEDPRE.Reg) & 0x1ff
}

// QDEC.ACCDBL: Register accumulating the number of detected double transitions
func (o *QDEC_Type) SetACCDBL(value uint32) {
	volatile.StoreUint32(&o.ACCDBL.Reg, volatile.LoadUint32(&o.ACCDBL.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetACCDBL() uint32 {
	return volatile.LoadUint32(&o.ACCDBL.Reg) & 0xf
}

// QDEC.ACCDBLREAD: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
func (o *QDEC_Type) SetACCDBLREAD(value uint32) {
	volatile.StoreUint32(&o.ACCDBLREAD.Reg, volatile.LoadUint32(&o.ACCDBLREAD.Reg)&^(0xf)|value)
}
func (o *QDEC_Type) GetACCDBLREAD() uint32 {
	return volatile.LoadUint32(&o.ACCDBLREAD.Reg) & 0xf
}

// Unspecified
type QDEC_PSEL_Type struct {
	LED volatile.Register32 // 0x51C
	A   volatile.Register32 // 0x520
	B   volatile.Register32 // 0x524
}

// QDEC_PSEL.LED: Pin select for LED signal
func (o *QDEC_PSEL_Type) SetLED_PIN(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetLED_PIN() uint32 {
	return volatile.LoadUint32(&o.LED.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetLED_CONNECT(value uint32) {
	volatile.StoreUint32(&o.LED.Reg, volatile.LoadUint32(&o.LED.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetLED_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.LED.Reg) & 0x80000000) >> 31
}

// QDEC_PSEL.A: Pin select for A signal
func (o *QDEC_PSEL_Type) SetA_PIN(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetA_PIN() uint32 {
	return volatile.LoadUint32(&o.A.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetA_CONNECT(value uint32) {
	volatile.StoreUint32(&o.A.Reg, volatile.LoadUint32(&o.A.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetA_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.A.Reg) & 0x80000000) >> 31
}

// QDEC_PSEL.B: Pin select for B signal
func (o *QDEC_PSEL_Type) SetB_PIN(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x1f)|value)
}
func (o *QDEC_PSEL_Type) GetB_PIN() uint32 {
	return volatile.LoadUint32(&o.B.Reg) & 0x1f
}
func (o *QDEC_PSEL_Type) SetB_CONNECT(value uint32) {
	volatile.StoreUint32(&o.B.Reg, volatile.LoadUint32(&o.B.Reg)&^(0x80000000)|value<<31)
}
func (o *QDEC_PSEL_Type) GetB_CONNECT() uint32 {
	return (volatile.LoadUint32(&o.B.Reg) & 0x80000000) >> 31
}

// Comparator
type COMP_Type struct {
	TASKS_START  volatile.Register32 // 0x0
	TASKS_STOP   volatile.Register32 // 0x4
	TASKS_SAMPLE volatile.Register32 // 0x8
	_            [244]byte
	EVENTS_READY volatile.Register32 // 0x100
	EVENTS_DOWN  volatile.Register32 // 0x104
	EVENTS_UP    volatile.Register32 // 0x108
	EVENTS_CROSS volatile.Register32 // 0x10C
	_            [240]byte
	SHORTS       volatile.Register32 // 0x200
	_            [252]byte
	INTEN        volatile.Register32 // 0x300
	INTENSET     volatile.Register32 // 0x304
	INTENCLR     volatile.Register32 // 0x308
	_            [244]byte
	RESULT       volatile.Register32 // 0x400
	_            [252]byte
	ENABLE       volatile.Register32 // 0x500
	PSEL         volatile.Register32 // 0x504
	REFSEL       volatile.Register32 // 0x508
	EXTREFSEL    volatile.Register32 // 0x50C
	_            [32]byte
	TH           volatile.Register32 // 0x530
	MODE         volatile.Register32 // 0x534
	HYST         volatile.Register32 // 0x538
}

// COMP.TASKS_START: Start comparator
func (o *COMP_Type) SetTASKS_START(value uint32) {
	volatile.StoreUint32(&o.TASKS_START.Reg, volatile.LoadUint32(&o.TASKS_START.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetTASKS_START() uint32 {
	return volatile.LoadUint32(&o.TASKS_START.Reg) & 0x1
}

// COMP.TASKS_STOP: Stop comparator
func (o *COMP_Type) SetTASKS_STOP(value uint32) {
	volatile.StoreUint32(&o.TASKS_STOP.Reg, volatile.LoadUint32(&o.TASKS_STOP.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetTASKS_STOP() uint32 {
	return volatile.LoadUint32(&o.TASKS_STOP.Reg) & 0x1
}

// COMP.TASKS_SAMPLE: Sample comparator value
func (o *COMP_Type) SetTASKS_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.TASKS_SAMPLE.Reg, volatile.LoadUint32(&o.TASKS_SAMPLE.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetTASKS_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.TASKS_SAMPLE.Reg) & 0x1
}

// COMP.EVENTS_READY: COMP is ready and output is valid
func (o *COMP_Type) SetEVENTS_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTS_READY.Reg, volatile.LoadUint32(&o.EVENTS_READY.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_READY() uint32 {
	return volatile.LoadUint32(&o.EVENTS_READY.Reg) & 0x1
}

// COMP.EVENTS_DOWN: Downward crossing
func (o *COMP_Type) SetEVENTS_DOWN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_DOWN.Reg, volatile.LoadUint32(&o.EVENTS_DOWN.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_DOWN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_DOWN.Reg) & 0x1
}

// COMP.EVENTS_UP: Upward crossing
func (o *COMP_Type) SetEVENTS_UP(value uint32) {
	volatile.StoreUint32(&o.EVENTS_UP.Reg, volatile.LoadUint32(&o.EVENTS_UP.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_UP() uint32 {
	return volatile.LoadUint32(&o.EVENTS_UP.Reg) & 0x1
}

// COMP.EVENTS_CROSS: Downward or upward crossing
func (o *COMP_Type) SetEVENTS_CROSS(value uint32) {
	volatile.StoreUint32(&o.EVENTS_CROSS.Reg, volatile.LoadUint32(&o.EVENTS_CROSS.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetEVENTS_CROSS() uint32 {
	return volatile.LoadUint32(&o.EVENTS_CROSS.Reg) & 0x1
}

// COMP.SHORTS: Shortcuts between local events and tasks
func (o *COMP_Type) SetSHORTS_READY_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetSHORTS_READY_SAMPLE() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *COMP_Type) SetSHORTS_READY_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetSHORTS_READY_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetSHORTS_DOWN_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetSHORTS_DOWN_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetSHORTS_UP_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetSHORTS_UP_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *COMP_Type) SetSHORTS_CROSS_STOP(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *COMP_Type) GetSHORTS_CROSS_STOP() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// COMP.INTEN: Enable or disable interrupt
func (o *COMP_Type) SetINTEN_READY(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTEN_READY() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *COMP_Type) SetINTEN_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTEN_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTEN_UP(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTEN_UP() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTEN_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTEN_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}

// COMP.INTENSET: Enable interrupt
func (o *COMP_Type) SetINTENSET_READY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTENSET_READY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *COMP_Type) SetINTENSET_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTENSET_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTENSET_UP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTENSET_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTENSET_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTENSET_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}

// COMP.INTENCLR: Disable interrupt
func (o *COMP_Type) SetINTENCLR_READY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetINTENCLR_READY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *COMP_Type) SetINTENCLR_DOWN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *COMP_Type) GetINTENCLR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *COMP_Type) SetINTENCLR_UP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *COMP_Type) GetINTENCLR_UP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *COMP_Type) SetINTENCLR_CROSS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *COMP_Type) GetINTENCLR_CROSS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}

// COMP.RESULT: Compare result
func (o *COMP_Type) SetRESULT(value uint32) {
	volatile.StoreUint32(&o.RESULT.Reg, volatile.LoadUint32(&o.RESULT.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetRESULT() uint32 {
	return volatile.LoadUint32(&o.RESULT.Reg) & 0x1
}

// COMP.ENABLE: COMP enable
func (o *COMP_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x3
}

// COMP.PSEL: Pin select
func (o *COMP_Type) SetPSEL(value uint32) {
	volatile.StoreUint32(&o.PSEL.Reg, volatile.LoadUint32(&o.PSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetPSEL() uint32 {
	return volatile.LoadUint32(&o.PSEL.Reg) & 0x7
}

// COMP.REFSEL: Reference source select for single-ended mode
func (o *COMP_Type) SetREFSEL(value uint32) {
	volatile.StoreUint32(&o.REFSEL.Reg, volatile.LoadUint32(&o.REFSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetREFSEL() uint32 {
	return volatile.LoadUint32(&o.REFSEL.Reg) & 0x7
}

// COMP.EXTREFSEL: External reference select
func (o *COMP_Type) SetEXTREFSEL(value uint32) {
	volatile.StoreUint32(&o.EXTREFSEL.Reg, volatile.LoadUint32(&o.EXTREFSEL.Reg)&^(0x7)|value)
}
func (o *COMP_Type) GetEXTREFSEL() uint32 {
	return volatile.LoadUint32(&o.EXTREFSEL.Reg) & 0x7
}

// COMP.TH: Threshold configuration for hysteresis unit
func (o *COMP_Type) SetTH_THDOWN(value uint32) {
	volatile.StoreUint32(&o.TH.Reg, volatile.LoadUint32(&o.TH.Reg)&^(0x3f)|value)
}
func (o *COMP_Type) GetTH_THDOWN() uint32 {
	return volatile.LoadUint32(&o.TH.Reg) & 0x3f
}
func (o *COMP_Type) SetTH_THUP(value uint32) {
	volatile.StoreUint32(&o.TH.Reg, volatile.LoadUint32(&o.TH.Reg)&^(0x3f00)|value<<8)
}
func (o *COMP_Type) GetTH_THUP() uint32 {
	return (volatile.LoadUint32(&o.TH.Reg) & 0x3f00) >> 8
}

// COMP.MODE: Mode configuration
func (o *COMP_Type) SetMODE_SP(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *COMP_Type) GetMODE_SP() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}
func (o *COMP_Type) SetMODE_MAIN(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x100)|value<<8)
}
func (o *COMP_Type) GetMODE_MAIN() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x100) >> 8
}

// COMP.HYST: Comparator hysteresis enable
func (o *COMP_Type) SetHYST(value uint32) {
	volatile.StoreUint32(&o.HYST.Reg, volatile.LoadUint32(&o.HYST.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetHYST() uint32 {
	return volatile.LoadUint32(&o.HYST.Reg) & 0x1
}

// Event generator unit 0
type EGU_Type struct {
	TASKS_TRIGGER    [16]volatile.Register32 // 0x0
	_                [192]byte
	EVENTS_TRIGGERED [16]volatile.Register32 // 0x100
	_                [448]byte
	INTEN            volatile.Register32 // 0x300
	INTENSET         volatile.Register32 // 0x304
	INTENCLR         volatile.Register32 // 0x308
}

// EGU.TASKS_TRIGGER: Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
func (o *EGU_Type) SetTASKS_TRIGGER(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_TRIGGER[idx].Reg, volatile.LoadUint32(&o.TASKS_TRIGGER[idx].Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetTASKS_TRIGGER(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_TRIGGER[idx].Reg) & 0x1
}

// EGU.EVENTS_TRIGGERED: Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
func (o *EGU_Type) SetEVENTS_TRIGGERED(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_TRIGGERED[idx].Reg, volatile.LoadUint32(&o.EVENTS_TRIGGERED[idx].Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetEVENTS_TRIGGERED(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_TRIGGERED[idx].Reg) & 0x1
}

// EGU.INTEN: Enable or disable interrupt
func (o *EGU_Type) SetINTEN_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTEN_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *EGU_Type) SetINTEN_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTEN_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTEN_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTEN_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTEN_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTEN_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTEN_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTEN_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTEN_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTEN_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTEN_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTEN_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTEN_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTEN_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTEN_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTEN_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTEN_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTEN_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTEN_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTEN_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTEN_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTEN_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTEN_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTEN_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTEN_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTEN_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTEN_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTEN_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTEN_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTEN_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}

// EGU.INTENSET: Enable interrupt
func (o *EGU_Type) SetINTENSET_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *EGU_Type) SetINTENSET_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTENSET_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTENSET_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTENSET_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTENSET_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTENSET_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTENSET_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTENSET_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTENSET_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTENSET_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTENSET_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTENSET_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTENSET_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTENSET_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTENSET_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTENSET_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}

// EGU.INTENCLR: Disable interrupt
func (o *EGU_Type) SetINTENCLR_TRIGGERED0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED8(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED8() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED9(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED9() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED10(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED10() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED11(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED11() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED12(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED12() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED13(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED13() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED14(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED14() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *EGU_Type) SetINTENCLR_TRIGGERED15(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *EGU_Type) GetINTENCLR_TRIGGERED15() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// Software interrupt 0
type SWI_Type struct {
	UNUSED volatile.Register32 // 0x0
}

// Access control lists
type ACL_Type struct {
	_   [2048]byte
	ACL [8]ACL_ACL_Type // 0x800
}

// Unspecified
type ACL_ACL_Type struct {
	ADDR volatile.Register32 // 0x800
	SIZE volatile.Register32 // 0x804
	PERM volatile.Register32 // 0x808
	_    [4]byte
}

// ACL_ACL.ADDR: Description cluster: Start address of region to protect. The start address must be word-aligned.
func (o *ACL_ACL_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, value)
}
func (o *ACL_ACL_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg)
}

// ACL_ACL.SIZE: Description cluster: Size of region to protect counting from address ACL[n].ADDR. Write '0' as no effect.
func (o *ACL_ACL_Type) SetSIZE(value uint32) {
	volatile.StoreUint32(&o.SIZE.Reg, value)
}
func (o *ACL_ACL_Type) GetSIZE() uint32 {
	return volatile.LoadUint32(&o.SIZE.Reg)
}

// ACL_ACL.PERM: Description cluster: Access permissions for region n as defined by start address ACL[n].ADDR and size ACL[n].SIZE
func (o *ACL_ACL_Type) SetPERM_WRITE(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x2)|value<<1)
}
func (o *ACL_ACL_Type) GetPERM_WRITE() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x2) >> 1
}
func (o *ACL_ACL_Type) SetPERM_READ(value uint32) {
	volatile.StoreUint32(&o.PERM.Reg, volatile.LoadUint32(&o.PERM.Reg)&^(0x4)|value<<2)
}
func (o *ACL_ACL_Type) GetPERM_READ() uint32 {
	return (volatile.LoadUint32(&o.PERM.Reg) & 0x4) >> 2
}

// Non Volatile Memory Controller
type NVMC_Type struct {
	_                   [1024]byte
	READY               volatile.Register32 // 0x400
	_                   [4]byte
	READYNEXT           volatile.Register32 // 0x408
	_                   [248]byte
	CONFIG              volatile.Register32 // 0x504
	ERASEPAGE           volatile.Register32 // 0x508
	ERASEALL            volatile.Register32 // 0x50C
	ERASEPCR0           volatile.Register32 // 0x510
	ERASEUICR           volatile.Register32 // 0x514
	ERASEPAGEPARTIAL    volatile.Register32 // 0x518
	ERASEPAGEPARTIALCFG volatile.Register32 // 0x51C
}

// NVMC.READY: Ready flag
func (o *NVMC_Type) SetREADY(value uint32) {
	volatile.StoreUint32(&o.READY.Reg, volatile.LoadUint32(&o.READY.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetREADY() uint32 {
	return volatile.LoadUint32(&o.READY.Reg) & 0x1
}

// NVMC.READYNEXT: Ready flag
func (o *NVMC_Type) SetREADYNEXT(value uint32) {
	volatile.StoreUint32(&o.READYNEXT.Reg, volatile.LoadUint32(&o.READYNEXT.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetREADYNEXT() uint32 {
	return volatile.LoadUint32(&o.READYNEXT.Reg) & 0x1
}

// NVMC.CONFIG: Configuration register
func (o *NVMC_Type) SetCONFIG_WEN(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x3)|value)
}
func (o *NVMC_Type) GetCONFIG_WEN() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x3
}

// NVMC.ERASEPAGE: Register for erasing a page in code area
func (o *NVMC_Type) SetERASEPAGE(value uint32) {
	volatile.StoreUint32(&o.ERASEPAGE.Reg, value)
}
func (o *NVMC_Type) GetERASEPAGE() uint32 {
	return volatile.LoadUint32(&o.ERASEPAGE.Reg)
}

// NVMC.ERASEALL: Register for erasing all non-volatile user memory
func (o *NVMC_Type) SetERASEALL(value uint32) {
	volatile.StoreUint32(&o.ERASEALL.Reg, volatile.LoadUint32(&o.ERASEALL.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetERASEALL() uint32 {
	return volatile.LoadUint32(&o.ERASEALL.Reg) & 0x1
}

// NVMC.ERASEPCR0: Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE
func (o *NVMC_Type) SetERASEPCR0(value uint32) {
	volatile.StoreUint32(&o.ERASEPCR0.Reg, value)
}
func (o *NVMC_Type) GetERASEPCR0() uint32 {
	return volatile.LoadUint32(&o.ERASEPCR0.Reg)
}

// NVMC.ERASEUICR: Register for erasing user information configuration registers
func (o *NVMC_Type) SetERASEUICR(value uint32) {
	volatile.StoreUint32(&o.ERASEUICR.Reg, volatile.LoadUint32(&o.ERASEUICR.Reg)&^(0x1)|value)
}
func (o *NVMC_Type) GetERASEUICR() uint32 {
	return volatile.LoadUint32(&o.ERASEUICR.Reg) & 0x1
}

// NVMC.ERASEPAGEPARTIAL: Register for partial erase of a page in code area
func (o *NVMC_Type) SetERASEPAGEPARTIAL(value uint32) {
	volatile.StoreUint32(&o.ERASEPAGEPARTIAL.Reg, value)
}
func (o *NVMC_Type) GetERASEPAGEPARTIAL() uint32 {
	return volatile.LoadUint32(&o.ERASEPAGEPARTIAL.Reg)
}

// NVMC.ERASEPAGEPARTIALCFG: Register for partial erase configuration
func (o *NVMC_Type) SetERASEPAGEPARTIALCFG_DURATION(value uint32) {
	volatile.StoreUint32(&o.ERASEPAGEPARTIALCFG.Reg, volatile.LoadUint32(&o.ERASEPAGEPARTIALCFG.Reg)&^(0x7f)|value)
}
func (o *NVMC_Type) GetERASEPAGEPARTIALCFG_DURATION() uint32 {
	return volatile.LoadUint32(&o.ERASEPAGEPARTIALCFG.Reg) & 0x7f
}

// Programmable Peripheral Interconnect
type PPI_Type struct {
	TASKS_CHG [6]PPI_TASKS_CHG_Type // 0x0
	_         [1232]byte
	CHEN      volatile.Register32 // 0x500
	CHENSET   volatile.Register32 // 0x504
	CHENCLR   volatile.Register32 // 0x508
	_         [4]byte
	CH        [20]PPI_CH_Type // 0x510
	_         [592]byte
	CHG       [6]volatile.Register32 // 0x800
	_         [248]byte
	FORK      [32]PPI_FORK_Type // 0x910
}

// PPI.CHEN: Channel enable register
func (o *PPI_Type) SetCHEN_CH0(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHEN_CH0() uint32 {
	return volatile.LoadUint32(&o.CHEN.Reg) & 0x1
}
func (o *PPI_Type) SetCHEN_CH1(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHEN_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHEN_CH2(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHEN_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHEN_CH3(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHEN_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHEN_CH4(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHEN_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHEN_CH5(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHEN_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHEN_CH6(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHEN_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHEN_CH7(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHEN_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHEN_CH8(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHEN_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHEN_CH9(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHEN_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHEN_CH10(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHEN_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHEN_CH11(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHEN_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHEN_CH12(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHEN_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHEN_CH13(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHEN_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHEN_CH14(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHEN_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHEN_CH15(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHEN_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHEN_CH16(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHEN_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHEN_CH17(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHEN_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHEN_CH18(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHEN_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHEN_CH19(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHEN_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHEN_CH20(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHEN_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHEN_CH21(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHEN_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHEN_CH22(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHEN_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHEN_CH23(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHEN_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHEN_CH24(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHEN_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHEN_CH25(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHEN_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHEN_CH26(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHEN_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHEN_CH27(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHEN_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHEN_CH28(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHEN_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHEN_CH29(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHEN_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHEN_CH30(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHEN_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHEN_CH31(value uint32) {
	volatile.StoreUint32(&o.CHEN.Reg, volatile.LoadUint32(&o.CHEN.Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHEN_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHEN.Reg) & 0x80000000) >> 31
}

// PPI.CHENSET: Channel enable set register
func (o *PPI_Type) SetCHENSET_CH0(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHENSET_CH0() uint32 {
	return volatile.LoadUint32(&o.CHENSET.Reg) & 0x1
}
func (o *PPI_Type) SetCHENSET_CH1(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHENSET_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHENSET_CH2(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHENSET_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHENSET_CH3(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHENSET_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHENSET_CH4(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHENSET_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHENSET_CH5(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHENSET_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHENSET_CH6(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHENSET_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHENSET_CH7(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHENSET_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHENSET_CH8(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHENSET_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHENSET_CH9(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHENSET_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHENSET_CH10(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHENSET_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHENSET_CH11(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHENSET_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHENSET_CH12(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHENSET_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHENSET_CH13(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHENSET_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHENSET_CH14(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHENSET_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHENSET_CH15(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHENSET_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHENSET_CH16(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHENSET_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHENSET_CH17(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHENSET_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHENSET_CH18(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHENSET_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHENSET_CH19(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHENSET_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHENSET_CH20(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHENSET_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHENSET_CH21(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHENSET_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHENSET_CH22(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHENSET_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHENSET_CH23(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHENSET_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHENSET_CH24(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHENSET_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHENSET_CH25(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHENSET_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHENSET_CH26(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHENSET_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHENSET_CH27(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHENSET_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHENSET_CH28(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHENSET_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHENSET_CH29(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHENSET_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHENSET_CH30(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHENSET_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHENSET_CH31(value uint32) {
	volatile.StoreUint32(&o.CHENSET.Reg, volatile.LoadUint32(&o.CHENSET.Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHENSET_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHENSET.Reg) & 0x80000000) >> 31
}

// PPI.CHENCLR: Channel enable clear register
func (o *PPI_Type) SetCHENCLR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHENCLR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1
}
func (o *PPI_Type) SetCHENCLR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHENCLR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHENCLR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHENCLR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHENCLR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHENCLR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHENCLR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHENCLR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHENCLR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHENCLR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHENCLR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHENCLR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHENCLR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHENCLR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHENCLR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHENCLR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHENCLR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHENCLR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHENCLR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHENCLR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHENCLR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHENCLR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHENCLR_CH12(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHENCLR_CH12() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHENCLR_CH13(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHENCLR_CH13() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHENCLR_CH14(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHENCLR_CH14() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHENCLR_CH15(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHENCLR_CH15() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHENCLR_CH16(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHENCLR_CH16() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHENCLR_CH17(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHENCLR_CH17() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHENCLR_CH18(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHENCLR_CH18() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHENCLR_CH19(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHENCLR_CH19() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHENCLR_CH20(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHENCLR_CH20() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHENCLR_CH21(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHENCLR_CH21() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHENCLR_CH22(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHENCLR_CH22() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHENCLR_CH23(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHENCLR_CH23() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHENCLR_CH24(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHENCLR_CH24() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHENCLR_CH25(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHENCLR_CH25() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHENCLR_CH26(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHENCLR_CH26() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHENCLR_CH27(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHENCLR_CH27() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHENCLR_CH28(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHENCLR_CH28() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHENCLR_CH29(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHENCLR_CH29() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHENCLR_CH30(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHENCLR_CH30() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHENCLR_CH31(value uint32) {
	volatile.StoreUint32(&o.CHENCLR.Reg, volatile.LoadUint32(&o.CHENCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHENCLR_CH31() uint32 {
	return (volatile.LoadUint32(&o.CHENCLR.Reg) & 0x80000000) >> 31
}

// PPI.CHG: Description collection: Channel group n
func (o *PPI_Type) SetCHG_CH0(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1)|value)
}
func (o *PPI_Type) GetCHG_CH0(idx int) uint32 {
	return volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1
}
func (o *PPI_Type) SetCHG_CH1(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2)|value<<1)
}
func (o *PPI_Type) GetCHG_CH1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2) >> 1
}
func (o *PPI_Type) SetCHG_CH2(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4)|value<<2)
}
func (o *PPI_Type) GetCHG_CH2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4) >> 2
}
func (o *PPI_Type) SetCHG_CH3(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8)|value<<3)
}
func (o *PPI_Type) GetCHG_CH3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8) >> 3
}
func (o *PPI_Type) SetCHG_CH4(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10)|value<<4)
}
func (o *PPI_Type) GetCHG_CH4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10) >> 4
}
func (o *PPI_Type) SetCHG_CH5(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20)|value<<5)
}
func (o *PPI_Type) GetCHG_CH5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20) >> 5
}
func (o *PPI_Type) SetCHG_CH6(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40)|value<<6)
}
func (o *PPI_Type) GetCHG_CH6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40) >> 6
}
func (o *PPI_Type) SetCHG_CH7(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80)|value<<7)
}
func (o *PPI_Type) GetCHG_CH7(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80) >> 7
}
func (o *PPI_Type) SetCHG_CH8(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x100)|value<<8)
}
func (o *PPI_Type) GetCHG_CH8(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x100) >> 8
}
func (o *PPI_Type) SetCHG_CH9(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x200)|value<<9)
}
func (o *PPI_Type) GetCHG_CH9(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x200) >> 9
}
func (o *PPI_Type) SetCHG_CH10(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x400)|value<<10)
}
func (o *PPI_Type) GetCHG_CH10(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x400) >> 10
}
func (o *PPI_Type) SetCHG_CH11(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x800)|value<<11)
}
func (o *PPI_Type) GetCHG_CH11(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x800) >> 11
}
func (o *PPI_Type) SetCHG_CH12(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1000)|value<<12)
}
func (o *PPI_Type) GetCHG_CH12(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1000) >> 12
}
func (o *PPI_Type) SetCHG_CH13(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2000)|value<<13)
}
func (o *PPI_Type) GetCHG_CH13(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2000) >> 13
}
func (o *PPI_Type) SetCHG_CH14(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4000)|value<<14)
}
func (o *PPI_Type) GetCHG_CH14(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4000) >> 14
}
func (o *PPI_Type) SetCHG_CH15(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8000)|value<<15)
}
func (o *PPI_Type) GetCHG_CH15(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8000) >> 15
}
func (o *PPI_Type) SetCHG_CH16(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10000)|value<<16)
}
func (o *PPI_Type) GetCHG_CH16(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10000) >> 16
}
func (o *PPI_Type) SetCHG_CH17(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20000)|value<<17)
}
func (o *PPI_Type) GetCHG_CH17(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20000) >> 17
}
func (o *PPI_Type) SetCHG_CH18(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40000)|value<<18)
}
func (o *PPI_Type) GetCHG_CH18(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40000) >> 18
}
func (o *PPI_Type) SetCHG_CH19(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80000)|value<<19)
}
func (o *PPI_Type) GetCHG_CH19(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80000) >> 19
}
func (o *PPI_Type) SetCHG_CH20(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x100000)|value<<20)
}
func (o *PPI_Type) GetCHG_CH20(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x100000) >> 20
}
func (o *PPI_Type) SetCHG_CH21(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x200000)|value<<21)
}
func (o *PPI_Type) GetCHG_CH21(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x200000) >> 21
}
func (o *PPI_Type) SetCHG_CH22(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x400000)|value<<22)
}
func (o *PPI_Type) GetCHG_CH22(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x400000) >> 22
}
func (o *PPI_Type) SetCHG_CH23(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x800000)|value<<23)
}
func (o *PPI_Type) GetCHG_CH23(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x800000) >> 23
}
func (o *PPI_Type) SetCHG_CH24(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *PPI_Type) GetCHG_CH24(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x1000000) >> 24
}
func (o *PPI_Type) SetCHG_CH25(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x2000000)|value<<25)
}
func (o *PPI_Type) GetCHG_CH25(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x2000000) >> 25
}
func (o *PPI_Type) SetCHG_CH26(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x4000000)|value<<26)
}
func (o *PPI_Type) GetCHG_CH26(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x4000000) >> 26
}
func (o *PPI_Type) SetCHG_CH27(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *PPI_Type) GetCHG_CH27(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x8000000) >> 27
}
func (o *PPI_Type) SetCHG_CH28(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *PPI_Type) GetCHG_CH28(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x10000000) >> 28
}
func (o *PPI_Type) SetCHG_CH29(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *PPI_Type) GetCHG_CH29(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x20000000) >> 29
}
func (o *PPI_Type) SetCHG_CH30(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *PPI_Type) GetCHG_CH30(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x40000000) >> 30
}
func (o *PPI_Type) SetCHG_CH31(idx int, value uint32) {
	volatile.StoreUint32(&o.CHG[idx].Reg, volatile.LoadUint32(&o.CHG[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PPI_Type) GetCHG_CH31(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHG[idx].Reg) & 0x80000000) >> 31
}

// Channel group tasks
type PPI_TASKS_CHG_Type struct {
	EN  volatile.Register32 // 0x0
	DIS volatile.Register32 // 0x4
}

// PPI_TASKS_CHG.EN: Description cluster: Enable channel group n
func (o *PPI_TASKS_CHG_Type) SetEN(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x1)|value)
}
func (o *PPI_TASKS_CHG_Type) GetEN() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0x1
}

// PPI_TASKS_CHG.DIS: Description cluster: Disable channel group n
func (o *PPI_TASKS_CHG_Type) SetDIS(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x1)|value)
}
func (o *PPI_TASKS_CHG_Type) GetDIS() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0x1
}

// PPI Channel
type PPI_CH_Type struct {
	EEP volatile.Register32 // 0x510
	TEP volatile.Register32 // 0x514
}

// PPI_CH.EEP: Description cluster: Channel n event end-point
func (o *PPI_CH_Type) SetEEP(value uint32) {
	volatile.StoreUint32(&o.EEP.Reg, value)
}
func (o *PPI_CH_Type) GetEEP() uint32 {
	return volatile.LoadUint32(&o.EEP.Reg)
}

// PPI_CH.TEP: Description cluster: Channel n task end-point
func (o *PPI_CH_Type) SetTEP(value uint32) {
	volatile.StoreUint32(&o.TEP.Reg, value)
}
func (o *PPI_CH_Type) GetTEP() uint32 {
	return volatile.LoadUint32(&o.TEP.Reg)
}

// Fork
type PPI_FORK_Type struct {
	TEP volatile.Register32 // 0x910
}

// PPI_FORK.TEP: Description cluster: Channel n task end-point
func (o *PPI_FORK_Type) SetTEP(value uint32) {
	volatile.StoreUint32(&o.TEP.Reg, value)
}
func (o *PPI_FORK_Type) GetTEP() uint32 {
	return volatile.LoadUint32(&o.TEP.Reg)
}

// Universal serial bus device
type USBD_Type struct {
	_                  [4]byte
	TASKS_STARTEPIN    [8]volatile.Register32 // 0x4
	TASKS_STARTISOIN   volatile.Register32    // 0x24
	TASKS_STARTEPOUT   [8]volatile.Register32 // 0x28
	TASKS_STARTISOOUT  volatile.Register32    // 0x48
	TASKS_EP0RCVOUT    volatile.Register32    // 0x4C
	TASKS_EP0STATUS    volatile.Register32    // 0x50
	TASKS_EP0STALL     volatile.Register32    // 0x54
	TASKS_DPDMDRIVE    volatile.Register32    // 0x58
	TASKS_DPDMNODRIVE  volatile.Register32    // 0x5C
	_                  [160]byte
	EVENTS_USBRESET    volatile.Register32    // 0x100
	EVENTS_STARTED     volatile.Register32    // 0x104
	EVENTS_ENDEPIN     [8]volatile.Register32 // 0x108
	EVENTS_EP0DATADONE volatile.Register32    // 0x128
	EVENTS_ENDISOIN    volatile.Register32    // 0x12C
	EVENTS_ENDEPOUT    [8]volatile.Register32 // 0x130
	EVENTS_ENDISOOUT   volatile.Register32    // 0x150
	EVENTS_SOF         volatile.Register32    // 0x154
	EVENTS_USBEVENT    volatile.Register32    // 0x158
	EVENTS_EP0SETUP    volatile.Register32    // 0x15C
	EVENTS_EPDATA      volatile.Register32    // 0x160
	_                  [156]byte
	SHORTS             volatile.Register32 // 0x200
	_                  [252]byte
	INTEN              volatile.Register32 // 0x300
	INTENSET           volatile.Register32 // 0x304
	INTENCLR           volatile.Register32 // 0x308
	_                  [244]byte
	EVENTCAUSE         volatile.Register32 // 0x400
	_                  [28]byte
	HALTED             USBD_HALTED_Type // 0x420
	_                  [4]byte
	EPSTATUS           volatile.Register32 // 0x468
	EPDATASTATUS       volatile.Register32 // 0x46C
	USBADDR            volatile.Register32 // 0x470
	_                  [12]byte
	BMREQUESTTYPE      volatile.Register32 // 0x480
	BREQUEST           volatile.Register32 // 0x484
	WVALUEL            volatile.Register32 // 0x488
	WVALUEH            volatile.Register32 // 0x48C
	WINDEXL            volatile.Register32 // 0x490
	WINDEXH            volatile.Register32 // 0x494
	WLENGTHL           volatile.Register32 // 0x498
	WLENGTHH           volatile.Register32 // 0x49C
	SIZE               USBD_SIZE_Type      // 0x4A0
	_                  [60]byte
	ENABLE             volatile.Register32 // 0x500
	USBPULLUP          volatile.Register32 // 0x504
	DPDMVALUE          volatile.Register32 // 0x508
	DTOGGLE            volatile.Register32 // 0x50C
	EPINEN             volatile.Register32 // 0x510
	EPOUTEN            volatile.Register32 // 0x514
	EPSTALL            volatile.Register32 // 0x518
	ISOSPLIT           volatile.Register32 // 0x51C
	FRAMECNTR          volatile.Register32 // 0x520
	_                  [8]byte
	LOWPOWER           volatile.Register32 // 0x52C
	ISOINCONFIG        volatile.Register32 // 0x530
	_                  [204]byte
	EPIN               [8]USBD_EPIN_Type // 0x600
	ISOIN              USBD_ISOIN_Type   // 0x6A0
	_                  [84]byte
	EPOUT              [8]USBD_EPOUT_Type // 0x700
	ISOOUT             USBD_ISOOUT_Type   // 0x7A0
}

// USBD.TASKS_STARTEPIN: Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
func (o *USBD_Type) SetTASKS_STARTEPIN(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTEPIN[idx].Reg, volatile.LoadUint32(&o.TASKS_STARTEPIN[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTEPIN(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTEPIN[idx].Reg) & 0x1
}

// USBD.TASKS_STARTISOIN: Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
func (o *USBD_Type) SetTASKS_STARTISOIN(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTISOIN.Reg, volatile.LoadUint32(&o.TASKS_STARTISOIN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTISOIN() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTISOIN.Reg) & 0x1
}

// USBD.TASKS_STARTEPOUT: Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
func (o *USBD_Type) SetTASKS_STARTEPOUT(idx int, value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTEPOUT[idx].Reg, volatile.LoadUint32(&o.TASKS_STARTEPOUT[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTEPOUT(idx int) uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTEPOUT[idx].Reg) & 0x1
}

// USBD.TASKS_STARTISOOUT: Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
func (o *USBD_Type) SetTASKS_STARTISOOUT(value uint32) {
	volatile.StoreUint32(&o.TASKS_STARTISOOUT.Reg, volatile.LoadUint32(&o.TASKS_STARTISOOUT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_STARTISOOUT() uint32 {
	return volatile.LoadUint32(&o.TASKS_STARTISOOUT.Reg) & 0x1
}

// USBD.TASKS_EP0RCVOUT: Allows OUT data stage on control endpoint 0
func (o *USBD_Type) SetTASKS_EP0RCVOUT(value uint32) {
	volatile.StoreUint32(&o.TASKS_EP0RCVOUT.Reg, volatile.LoadUint32(&o.TASKS_EP0RCVOUT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_EP0RCVOUT() uint32 {
	return volatile.LoadUint32(&o.TASKS_EP0RCVOUT.Reg) & 0x1
}

// USBD.TASKS_EP0STATUS: Allows status stage on control endpoint 0
func (o *USBD_Type) SetTASKS_EP0STATUS(value uint32) {
	volatile.StoreUint32(&o.TASKS_EP0STATUS.Reg, volatile.LoadUint32(&o.TASKS_EP0STATUS.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_EP0STATUS() uint32 {
	return volatile.LoadUint32(&o.TASKS_EP0STATUS.Reg) & 0x1
}

// USBD.TASKS_EP0STALL: Stalls data and status stage on control endpoint 0
func (o *USBD_Type) SetTASKS_EP0STALL(value uint32) {
	volatile.StoreUint32(&o.TASKS_EP0STALL.Reg, volatile.LoadUint32(&o.TASKS_EP0STALL.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_EP0STALL() uint32 {
	return volatile.LoadUint32(&o.TASKS_EP0STALL.Reg) & 0x1
}

// USBD.TASKS_DPDMDRIVE: Forces D+ and D- lines into the state defined in the DPDMVALUE register
func (o *USBD_Type) SetTASKS_DPDMDRIVE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DPDMDRIVE.Reg, volatile.LoadUint32(&o.TASKS_DPDMDRIVE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_DPDMDRIVE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DPDMDRIVE.Reg) & 0x1
}

// USBD.TASKS_DPDMNODRIVE: Stops forcing D+ and D- lines into any state (USB engine takes control)
func (o *USBD_Type) SetTASKS_DPDMNODRIVE(value uint32) {
	volatile.StoreUint32(&o.TASKS_DPDMNODRIVE.Reg, volatile.LoadUint32(&o.TASKS_DPDMNODRIVE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetTASKS_DPDMNODRIVE() uint32 {
	return volatile.LoadUint32(&o.TASKS_DPDMNODRIVE.Reg) & 0x1
}

// USBD.EVENTS_USBRESET: Signals that a USB reset condition has been detected on USB lines
func (o *USBD_Type) SetEVENTS_USBRESET(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBRESET.Reg, volatile.LoadUint32(&o.EVENTS_USBRESET.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_USBRESET() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBRESET.Reg) & 0x1
}

// USBD.EVENTS_STARTED: Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
func (o *USBD_Type) SetEVENTS_STARTED(value uint32) {
	volatile.StoreUint32(&o.EVENTS_STARTED.Reg, volatile.LoadUint32(&o.EVENTS_STARTED.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_STARTED() uint32 {
	return volatile.LoadUint32(&o.EVENTS_STARTED.Reg) & 0x1
}

// USBD.EVENTS_ENDEPIN: Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDEPIN(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDEPIN[idx].Reg, volatile.LoadUint32(&o.EVENTS_ENDEPIN[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDEPIN(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDEPIN[idx].Reg) & 0x1
}

// USBD.EVENTS_EP0DATADONE: An acknowledged data transfer has taken place on the control endpoint
func (o *USBD_Type) SetEVENTS_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EP0DATADONE.Reg, volatile.LoadUint32(&o.EVENTS_EP0DATADONE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_EP0DATADONE() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EP0DATADONE.Reg) & 0x1
}

// USBD.EVENTS_ENDISOIN: The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDISOIN.Reg, volatile.LoadUint32(&o.EVENTS_ENDISOIN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDISOIN() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDISOIN.Reg) & 0x1
}

// USBD.EVENTS_ENDEPOUT: Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDEPOUT(idx int, value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDEPOUT[idx].Reg, volatile.LoadUint32(&o.EVENTS_ENDEPOUT[idx].Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDEPOUT(idx int) uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDEPOUT[idx].Reg) & 0x1
}

// USBD.EVENTS_ENDISOOUT: The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software.
func (o *USBD_Type) SetEVENTS_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_ENDISOOUT.Reg, volatile.LoadUint32(&o.EVENTS_ENDISOOUT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_ENDISOOUT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_ENDISOOUT.Reg) & 0x1
}

// USBD.EVENTS_SOF: Signals that a SOF (start of frame) condition has been detected on USB lines
func (o *USBD_Type) SetEVENTS_SOF(value uint32) {
	volatile.StoreUint32(&o.EVENTS_SOF.Reg, volatile.LoadUint32(&o.EVENTS_SOF.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_SOF() uint32 {
	return volatile.LoadUint32(&o.EVENTS_SOF.Reg) & 0x1
}

// USBD.EVENTS_USBEVENT: An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
func (o *USBD_Type) SetEVENTS_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.EVENTS_USBEVENT.Reg, volatile.LoadUint32(&o.EVENTS_USBEVENT.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_USBEVENT() uint32 {
	return volatile.LoadUint32(&o.EVENTS_USBEVENT.Reg) & 0x1
}

// USBD.EVENTS_EP0SETUP: A valid SETUP token has been received (and acknowledged) on the control endpoint
func (o *USBD_Type) SetEVENTS_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EP0SETUP.Reg, volatile.LoadUint32(&o.EVENTS_EP0SETUP.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_EP0SETUP() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EP0SETUP.Reg) & 0x1
}

// USBD.EVENTS_EPDATA: A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
func (o *USBD_Type) SetEVENTS_EPDATA(value uint32) {
	volatile.StoreUint32(&o.EVENTS_EPDATA.Reg, volatile.LoadUint32(&o.EVENTS_EPDATA.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTS_EPDATA() uint32 {
	return volatile.LoadUint32(&o.EVENTS_EPDATA.Reg) & 0x1
}

// USBD.SHORTS: Shortcuts between local events and tasks
func (o *USBD_Type) SetSHORTS_EP0DATADONE_STARTEPIN0(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetSHORTS_EP0DATADONE_STARTEPIN0() uint32 {
	return volatile.LoadUint32(&o.SHORTS.Reg) & 0x1
}
func (o *USBD_Type) SetSHORTS_EP0DATADONE_STARTEPOUT0(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetSHORTS_EP0DATADONE_STARTEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetSHORTS_EP0DATADONE_EP0STATUS(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetSHORTS_EP0DATADONE_EP0STATUS() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetSHORTS_ENDEPOUT0_EP0STATUS(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetSHORTS_ENDEPOUT0_EP0STATUS() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetSHORTS_ENDEPOUT0_EP0RCVOUT(value uint32) {
	volatile.StoreUint32(&o.SHORTS.Reg, volatile.LoadUint32(&o.SHORTS.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetSHORTS_ENDEPOUT0_EP0RCVOUT() uint32 {
	return (volatile.LoadUint32(&o.SHORTS.Reg) & 0x10) >> 4
}

// USBD.INTEN: Enable or disable interrupt
func (o *USBD_Type) SetINTEN_USBRESET(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetINTEN_USBRESET() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *USBD_Type) SetINTEN_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetINTEN_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetINTEN_ENDEPIN0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetINTEN_ENDEPIN0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetINTEN_ENDEPIN1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetINTEN_ENDEPIN1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetINTEN_ENDEPIN2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetINTEN_ENDEPIN2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetINTEN_ENDEPIN3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetINTEN_ENDEPIN3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetINTEN_ENDEPIN4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetINTEN_ENDEPIN4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetINTEN_ENDEPIN5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetINTEN_ENDEPIN5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetINTEN_ENDEPIN6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetINTEN_ENDEPIN6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetINTEN_ENDEPIN7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetINTEN_ENDEPIN7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetINTEN_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetINTEN_EP0DATADONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetINTEN_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetINTEN_ENDISOIN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *USBD_Type) SetINTEN_ENDEPOUT0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *USBD_Type) SetINTEN_ENDEPOUT1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}
func (o *USBD_Type) SetINTEN_ENDEPOUT2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000)|value<<14)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000) >> 14
}
func (o *USBD_Type) SetINTEN_ENDEPOUT3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}
func (o *USBD_Type) SetINTEN_ENDEPOUT4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetINTEN_ENDEPOUT5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetINTEN_ENDEPOUT6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetINTEN_ENDEPOUT7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetINTEN_ENDEPOUT7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetINTEN_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetINTEN_ENDISOOUT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetINTEN_SOF(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetINTEN_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetINTEN_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetINTEN_USBEVENT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetINTEN_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetINTEN_EP0SETUP() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetINTEN_EPDATA(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetINTEN_EPDATA() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000000) >> 24
}

// USBD.INTENSET: Enable interrupt
func (o *USBD_Type) SetINTENSET_USBRESET(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetINTENSET_USBRESET() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *USBD_Type) SetINTENSET_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetINTENSET_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetINTENSET_ENDEPIN0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetINTENSET_ENDEPIN1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetINTENSET_ENDEPIN2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetINTENSET_ENDEPIN3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetINTENSET_ENDEPIN4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetINTENSET_ENDEPIN5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetINTENSET_ENDEPIN6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetINTENSET_ENDEPIN7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetINTENSET_ENDEPIN7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetINTENSET_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetINTENSET_EP0DATADONE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetINTENSET_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetINTENSET_ENDISOIN() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT6(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT6() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetINTENSET_ENDEPOUT7(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetINTENSET_ENDEPOUT7() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetINTENSET_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetINTENSET_ENDISOOUT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetINTENSET_SOF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetINTENSET_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetINTENSET_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetINTENSET_USBEVENT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetINTENSET_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetINTENSET_EP0SETUP() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetINTENSET_EPDATA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetINTENSET_EPDATA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}

// USBD.INTENCLR: Disable interrupt
func (o *USBD_Type) SetINTENCLR_USBRESET(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetINTENCLR_USBRESET() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *USBD_Type) SetINTENCLR_STARTED(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetINTENCLR_STARTED() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetINTENCLR_ENDEPIN7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetINTENCLR_ENDEPIN7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetINTENCLR_EP0DATADONE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetINTENCLR_EP0DATADONE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetINTENCLR_ENDISOIN(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetINTENCLR_ENDISOIN() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT6(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT6() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetINTENCLR_ENDEPOUT7(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetINTENCLR_ENDEPOUT7() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetINTENCLR_ENDISOOUT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetINTENCLR_ENDISOOUT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetINTENCLR_SOF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetINTENCLR_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetINTENCLR_USBEVENT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetINTENCLR_USBEVENT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetINTENCLR_EP0SETUP(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetINTENCLR_EP0SETUP() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetINTENCLR_EPDATA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetINTENCLR_EPDATA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}

// USBD.EVENTCAUSE: Details on what caused the USBEVENT event
func (o *USBD_Type) SetEVENTCAUSE_ISOOUTCRC(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEVENTCAUSE_ISOOUTCRC() uint32 {
	return volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x1
}
func (o *USBD_Type) SetEVENTCAUSE_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEVENTCAUSE_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetEVENTCAUSE_RESUME(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x200)|value<<9)
}
func (o *USBD_Type) GetEVENTCAUSE_RESUME() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x200) >> 9
}
func (o *USBD_Type) SetEVENTCAUSE_USBWUALLOWED(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x400)|value<<10)
}
func (o *USBD_Type) GetEVENTCAUSE_USBWUALLOWED() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x400) >> 10
}
func (o *USBD_Type) SetEVENTCAUSE_READY(value uint32) {
	volatile.StoreUint32(&o.EVENTCAUSE.Reg, volatile.LoadUint32(&o.EVENTCAUSE.Reg)&^(0x800)|value<<11)
}
func (o *USBD_Type) GetEVENTCAUSE_READY() uint32 {
	return (volatile.LoadUint32(&o.EVENTCAUSE.Reg) & 0x800) >> 11
}

// USBD.EPSTATUS: Provides information on which endpoint's EasyDMA registers have been captured
func (o *USBD_Type) SetEPSTATUS_EPIN0(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEPSTATUS_EPIN0() uint32 {
	return volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x1
}
func (o *USBD_Type) SetEPSTATUS_EPIN1(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPSTATUS_EPIN1() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPSTATUS_EPIN2(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPSTATUS_EPIN2() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPSTATUS_EPIN3(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPSTATUS_EPIN3() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPSTATUS_EPIN4(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPSTATUS_EPIN4() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPSTATUS_EPIN5(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPSTATUS_EPIN5() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPSTATUS_EPIN6(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPSTATUS_EPIN6() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPSTATUS_EPIN7(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPSTATUS_EPIN7() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPSTATUS_EPIN8(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPSTATUS_EPIN8() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x100) >> 8
}
func (o *USBD_Type) SetEPSTATUS_EPOUT0(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT0() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x10000) >> 16
}
func (o *USBD_Type) SetEPSTATUS_EPOUT1(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT1() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetEPSTATUS_EPOUT2(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT2() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetEPSTATUS_EPOUT3(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT3() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetEPSTATUS_EPOUT4(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT4() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetEPSTATUS_EPOUT5(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT5() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetEPSTATUS_EPOUT6(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT6() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetEPSTATUS_EPOUT7(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT7() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x800000) >> 23
}
func (o *USBD_Type) SetEPSTATUS_EPOUT8(value uint32) {
	volatile.StoreUint32(&o.EPSTATUS.Reg, volatile.LoadUint32(&o.EPSTATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *USBD_Type) GetEPSTATUS_EPOUT8() uint32 {
	return (volatile.LoadUint32(&o.EPSTATUS.Reg) & 0x1000000) >> 24
}

// USBD.EPDATASTATUS: Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)
func (o *USBD_Type) SetEPDATASTATUS_EPIN1(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN1() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN2(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN2() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN3(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN3() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN4(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN4() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN5(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN5() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN6(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN6() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPDATASTATUS_EPIN7(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPDATASTATUS_EPIN7() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT1(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x20000)|value<<17)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT1() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x20000) >> 17
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT2(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x40000)|value<<18)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT2() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x40000) >> 18
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT3(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x80000)|value<<19)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT3() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x80000) >> 19
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT4(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT4() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x100000) >> 20
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT5(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT5() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x200000) >> 21
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT6(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT6() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x400000) >> 22
}
func (o *USBD_Type) SetEPDATASTATUS_EPOUT7(value uint32) {
	volatile.StoreUint32(&o.EPDATASTATUS.Reg, volatile.LoadUint32(&o.EPDATASTATUS.Reg)&^(0x800000)|value<<23)
}
func (o *USBD_Type) GetEPDATASTATUS_EPOUT7() uint32 {
	return (volatile.LoadUint32(&o.EPDATASTATUS.Reg) & 0x800000) >> 23
}

// USBD.USBADDR: Device USB address
func (o *USBD_Type) SetUSBADDR_ADDR(value uint32) {
	volatile.StoreUint32(&o.USBADDR.Reg, volatile.LoadUint32(&o.USBADDR.Reg)&^(0x7f)|value)
}
func (o *USBD_Type) GetUSBADDR_ADDR() uint32 {
	return volatile.LoadUint32(&o.USBADDR.Reg) & 0x7f
}

// USBD.BMREQUESTTYPE: SETUP data, byte 0, bmRequestType
func (o *USBD_Type) SetBMREQUESTTYPE_RECIPIENT(value uint32) {
	volatile.StoreUint32(&o.BMREQUESTTYPE.Reg, volatile.LoadUint32(&o.BMREQUESTTYPE.Reg)&^(0x1f)|value)
}
func (o *USBD_Type) GetBMREQUESTTYPE_RECIPIENT() uint32 {
	return volatile.LoadUint32(&o.BMREQUESTTYPE.Reg) & 0x1f
}
func (o *USBD_Type) SetBMREQUESTTYPE_TYPE(value uint32) {
	volatile.StoreUint32(&o.BMREQUESTTYPE.Reg, volatile.LoadUint32(&o.BMREQUESTTYPE.Reg)&^(0x60)|value<<5)
}
func (o *USBD_Type) GetBMREQUESTTYPE_TYPE() uint32 {
	return (volatile.LoadUint32(&o.BMREQUESTTYPE.Reg) & 0x60) >> 5
}
func (o *USBD_Type) SetBMREQUESTTYPE_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.BMREQUESTTYPE.Reg, volatile.LoadUint32(&o.BMREQUESTTYPE.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetBMREQUESTTYPE_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.BMREQUESTTYPE.Reg) & 0x80) >> 7
}

// USBD.BREQUEST: SETUP data, byte 1, bRequest
func (o *USBD_Type) SetBREQUEST(value uint32) {
	volatile.StoreUint32(&o.BREQUEST.Reg, volatile.LoadUint32(&o.BREQUEST.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetBREQUEST() uint32 {
	return volatile.LoadUint32(&o.BREQUEST.Reg) & 0xff
}

// USBD.WVALUEL: SETUP data, byte 2, LSB of wValue
func (o *USBD_Type) SetWVALUEL(value uint32) {
	volatile.StoreUint32(&o.WVALUEL.Reg, volatile.LoadUint32(&o.WVALUEL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWVALUEL() uint32 {
	return volatile.LoadUint32(&o.WVALUEL.Reg) & 0xff
}

// USBD.WVALUEH: SETUP data, byte 3, MSB of wValue
func (o *USBD_Type) SetWVALUEH(value uint32) {
	volatile.StoreUint32(&o.WVALUEH.Reg, volatile.LoadUint32(&o.WVALUEH.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWVALUEH() uint32 {
	return volatile.LoadUint32(&o.WVALUEH.Reg) & 0xff
}

// USBD.WINDEXL: SETUP data, byte 4, LSB of wIndex
func (o *USBD_Type) SetWINDEXL(value uint32) {
	volatile.StoreUint32(&o.WINDEXL.Reg, volatile.LoadUint32(&o.WINDEXL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWINDEXL() uint32 {
	return volatile.LoadUint32(&o.WINDEXL.Reg) & 0xff
}

// USBD.WINDEXH: SETUP data, byte 5, MSB of wIndex
func (o *USBD_Type) SetWINDEXH(value uint32) {
	volatile.StoreUint32(&o.WINDEXH.Reg, volatile.LoadUint32(&o.WINDEXH.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWINDEXH() uint32 {
	return volatile.LoadUint32(&o.WINDEXH.Reg) & 0xff
}

// USBD.WLENGTHL: SETUP data, byte 6, LSB of wLength
func (o *USBD_Type) SetWLENGTHL(value uint32) {
	volatile.StoreUint32(&o.WLENGTHL.Reg, volatile.LoadUint32(&o.WLENGTHL.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWLENGTHL() uint32 {
	return volatile.LoadUint32(&o.WLENGTHL.Reg) & 0xff
}

// USBD.WLENGTHH: SETUP data, byte 7, MSB of wLength
func (o *USBD_Type) SetWLENGTHH(value uint32) {
	volatile.StoreUint32(&o.WLENGTHH.Reg, volatile.LoadUint32(&o.WLENGTHH.Reg)&^(0xff)|value)
}
func (o *USBD_Type) GetWLENGTHH() uint32 {
	return volatile.LoadUint32(&o.WLENGTHH.Reg) & 0xff
}

// USBD.ENABLE: Enable USB
func (o *USBD_Type) SetENABLE(value uint32) {
	volatile.StoreUint32(&o.ENABLE.Reg, volatile.LoadUint32(&o.ENABLE.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetENABLE() uint32 {
	return volatile.LoadUint32(&o.ENABLE.Reg) & 0x1
}

// USBD.USBPULLUP: Control of the USB pull-up
func (o *USBD_Type) SetUSBPULLUP_CONNECT(value uint32) {
	volatile.StoreUint32(&o.USBPULLUP.Reg, volatile.LoadUint32(&o.USBPULLUP.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetUSBPULLUP_CONNECT() uint32 {
	return volatile.LoadUint32(&o.USBPULLUP.Reg) & 0x1
}

// USBD.DPDMVALUE: State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing).
func (o *USBD_Type) SetDPDMVALUE_STATE(value uint32) {
	volatile.StoreUint32(&o.DPDMVALUE.Reg, volatile.LoadUint32(&o.DPDMVALUE.Reg)&^(0x1f)|value)
}
func (o *USBD_Type) GetDPDMVALUE_STATE() uint32 {
	return volatile.LoadUint32(&o.DPDMVALUE.Reg) & 0x1f
}

// USBD.DTOGGLE: Data toggle control and status
func (o *USBD_Type) SetDTOGGLE_EP(value uint32) {
	volatile.StoreUint32(&o.DTOGGLE.Reg, volatile.LoadUint32(&o.DTOGGLE.Reg)&^(0x7)|value)
}
func (o *USBD_Type) GetDTOGGLE_EP() uint32 {
	return volatile.LoadUint32(&o.DTOGGLE.Reg) & 0x7
}
func (o *USBD_Type) SetDTOGGLE_IO(value uint32) {
	volatile.StoreUint32(&o.DTOGGLE.Reg, volatile.LoadUint32(&o.DTOGGLE.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetDTOGGLE_IO() uint32 {
	return (volatile.LoadUint32(&o.DTOGGLE.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetDTOGGLE_VALUE(value uint32) {
	volatile.StoreUint32(&o.DTOGGLE.Reg, volatile.LoadUint32(&o.DTOGGLE.Reg)&^(0x300)|value<<8)
}
func (o *USBD_Type) GetDTOGGLE_VALUE() uint32 {
	return (volatile.LoadUint32(&o.DTOGGLE.Reg) & 0x300) >> 8
}

// USBD.EPINEN: Endpoint IN enable
func (o *USBD_Type) SetEPINEN_IN0(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEPINEN_IN0() uint32 {
	return volatile.LoadUint32(&o.EPINEN.Reg) & 0x1
}
func (o *USBD_Type) SetEPINEN_IN1(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPINEN_IN1() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPINEN_IN2(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPINEN_IN2() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPINEN_IN3(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPINEN_IN3() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPINEN_IN4(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPINEN_IN4() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPINEN_IN5(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPINEN_IN5() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPINEN_IN6(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPINEN_IN6() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPINEN_IN7(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPINEN_IN7() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPINEN_ISOIN(value uint32) {
	volatile.StoreUint32(&o.EPINEN.Reg, volatile.LoadUint32(&o.EPINEN.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPINEN_ISOIN() uint32 {
	return (volatile.LoadUint32(&o.EPINEN.Reg) & 0x100) >> 8
}

// USBD.EPOUTEN: Endpoint OUT enable
func (o *USBD_Type) SetEPOUTEN_OUT0(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetEPOUTEN_OUT0() uint32 {
	return volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x1
}
func (o *USBD_Type) SetEPOUTEN_OUT1(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x2)|value<<1)
}
func (o *USBD_Type) GetEPOUTEN_OUT1() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x2) >> 1
}
func (o *USBD_Type) SetEPOUTEN_OUT2(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x4)|value<<2)
}
func (o *USBD_Type) GetEPOUTEN_OUT2() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x4) >> 2
}
func (o *USBD_Type) SetEPOUTEN_OUT3(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x8)|value<<3)
}
func (o *USBD_Type) GetEPOUTEN_OUT3() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x8) >> 3
}
func (o *USBD_Type) SetEPOUTEN_OUT4(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x10)|value<<4)
}
func (o *USBD_Type) GetEPOUTEN_OUT4() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x10) >> 4
}
func (o *USBD_Type) SetEPOUTEN_OUT5(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x20)|value<<5)
}
func (o *USBD_Type) GetEPOUTEN_OUT5() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x20) >> 5
}
func (o *USBD_Type) SetEPOUTEN_OUT6(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x40)|value<<6)
}
func (o *USBD_Type) GetEPOUTEN_OUT6() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x40) >> 6
}
func (o *USBD_Type) SetEPOUTEN_OUT7(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPOUTEN_OUT7() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPOUTEN_ISOOUT(value uint32) {
	volatile.StoreUint32(&o.EPOUTEN.Reg, volatile.LoadUint32(&o.EPOUTEN.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPOUTEN_ISOOUT() uint32 {
	return (volatile.LoadUint32(&o.EPOUTEN.Reg) & 0x100) >> 8
}

// USBD.EPSTALL: STALL endpoints
func (o *USBD_Type) SetEPSTALL_EP(value uint32) {
	volatile.StoreUint32(&o.EPSTALL.Reg, volatile.LoadUint32(&o.EPSTALL.Reg)&^(0x7)|value)
}
func (o *USBD_Type) GetEPSTALL_EP() uint32 {
	return volatile.LoadUint32(&o.EPSTALL.Reg) & 0x7
}
func (o *USBD_Type) SetEPSTALL_IO(value uint32) {
	volatile.StoreUint32(&o.EPSTALL.Reg, volatile.LoadUint32(&o.EPSTALL.Reg)&^(0x80)|value<<7)
}
func (o *USBD_Type) GetEPSTALL_IO() uint32 {
	return (volatile.LoadUint32(&o.EPSTALL.Reg) & 0x80) >> 7
}
func (o *USBD_Type) SetEPSTALL_STALL(value uint32) {
	volatile.StoreUint32(&o.EPSTALL.Reg, volatile.LoadUint32(&o.EPSTALL.Reg)&^(0x100)|value<<8)
}
func (o *USBD_Type) GetEPSTALL_STALL() uint32 {
	return (volatile.LoadUint32(&o.EPSTALL.Reg) & 0x100) >> 8
}

// USBD.ISOSPLIT: Controls the split of ISO buffers
func (o *USBD_Type) SetISOSPLIT_SPLIT(value uint32) {
	volatile.StoreUint32(&o.ISOSPLIT.Reg, volatile.LoadUint32(&o.ISOSPLIT.Reg)&^(0xffff)|value)
}
func (o *USBD_Type) GetISOSPLIT_SPLIT() uint32 {
	return volatile.LoadUint32(&o.ISOSPLIT.Reg) & 0xffff
}

// USBD.FRAMECNTR: Returns the current value of the start of frame counter
func (o *USBD_Type) SetFRAMECNTR(value uint32) {
	volatile.StoreUint32(&o.FRAMECNTR.Reg, volatile.LoadUint32(&o.FRAMECNTR.Reg)&^(0x7ff)|value)
}
func (o *USBD_Type) GetFRAMECNTR() uint32 {
	return volatile.LoadUint32(&o.FRAMECNTR.Reg) & 0x7ff
}

// USBD.LOWPOWER: Controls USBD peripheral low power mode during USB suspend
func (o *USBD_Type) SetLOWPOWER(value uint32) {
	volatile.StoreUint32(&o.LOWPOWER.Reg, volatile.LoadUint32(&o.LOWPOWER.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetLOWPOWER() uint32 {
	return volatile.LoadUint32(&o.LOWPOWER.Reg) & 0x1
}

// USBD.ISOINCONFIG: Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
func (o *USBD_Type) SetISOINCONFIG_RESPONSE(value uint32) {
	volatile.StoreUint32(&o.ISOINCONFIG.Reg, volatile.LoadUint32(&o.ISOINCONFIG.Reg)&^(0x1)|value)
}
func (o *USBD_Type) GetISOINCONFIG_RESPONSE() uint32 {
	return volatile.LoadUint32(&o.ISOINCONFIG.Reg) & 0x1
}

// Unspecified
type USBD_HALTED_Type struct {
	EPIN  [8]volatile.Register32 // 0x420
	_     [4]byte
	EPOUT [8]volatile.Register32 // 0x444
}

// Unspecified
type USBD_SIZE_Type struct {
	EPOUT  [8]volatile.Register32 // 0x4A0
	ISOOUT volatile.Register32    // 0x4C0
}

// USBD_SIZE.ISOOUT: Number of bytes received last on this ISO OUT data endpoint
func (o *USBD_SIZE_Type) SetISOOUT_SIZE(value uint32) {
	volatile.StoreUint32(&o.ISOOUT.Reg, volatile.LoadUint32(&o.ISOOUT.Reg)&^(0x3ff)|value)
}
func (o *USBD_SIZE_Type) GetISOOUT_SIZE() uint32 {
	return volatile.LoadUint32(&o.ISOOUT.Reg) & 0x3ff
}
func (o *USBD_SIZE_Type) SetISOOUT_ZERO(value uint32) {
	volatile.StoreUint32(&o.ISOOUT.Reg, volatile.LoadUint32(&o.ISOOUT.Reg)&^(0x10000)|value<<16)
}
func (o *USBD_SIZE_Type) GetISOOUT_ZERO() uint32 {
	return (volatile.LoadUint32(&o.ISOOUT.Reg) & 0x10000) >> 16
}

// Unspecified
type USBD_EPIN_Type struct {
	PTR    volatile.Register32 // 0x600
	MAXCNT volatile.Register32 // 0x604
	AMOUNT volatile.Register32 // 0x608
	_      [8]byte
}

// USBD_EPIN.PTR: Description cluster: Data pointer
func (o *USBD_EPIN_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_EPIN_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_EPIN.MAXCNT: Description cluster: Maximum number of bytes to transfer
func (o *USBD_EPIN_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPIN_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7f
}

// USBD_EPIN.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
func (o *USBD_EPIN_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPIN_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7f
}

// Unspecified
type USBD_ISOIN_Type struct {
	PTR    volatile.Register32 // 0x6A0
	MAXCNT volatile.Register32 // 0x6A4
	AMOUNT volatile.Register32 // 0x6A8
}

// USBD_ISOIN.PTR: Data pointer
func (o *USBD_ISOIN_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_ISOIN_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_ISOIN.MAXCNT: Maximum number of bytes to transfer
func (o *USBD_ISOIN_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOIN_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3ff
}

// USBD_ISOIN.AMOUNT: Number of bytes transferred in the last transaction
func (o *USBD_ISOIN_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOIN_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x3ff
}

// Unspecified
type USBD_EPOUT_Type struct {
	PTR    volatile.Register32 // 0x700
	MAXCNT volatile.Register32 // 0x704
	AMOUNT volatile.Register32 // 0x708
	_      [8]byte
}

// USBD_EPOUT.PTR: Description cluster: Data pointer
func (o *USBD_EPOUT_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_EPOUT_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_EPOUT.MAXCNT: Description cluster: Maximum number of bytes to transfer
func (o *USBD_EPOUT_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPOUT_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x7f
}

// USBD_EPOUT.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
func (o *USBD_EPOUT_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x7f)|value)
}
func (o *USBD_EPOUT_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x7f
}

// Unspecified
type USBD_ISOOUT_Type struct {
	PTR    volatile.Register32 // 0x7A0
	MAXCNT volatile.Register32 // 0x7A4
	AMOUNT volatile.Register32 // 0x7A8
}

// USBD_ISOOUT.PTR: Data pointer
func (o *USBD_ISOOUT_Type) SetPTR(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, value)
}
func (o *USBD_ISOOUT_Type) GetPTR() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg)
}

// USBD_ISOOUT.MAXCNT: Maximum number of bytes to transfer
func (o *USBD_ISOOUT_Type) SetMAXCNT(value uint32) {
	volatile.StoreUint32(&o.MAXCNT.Reg, volatile.LoadUint32(&o.MAXCNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOOUT_Type) GetMAXCNT() uint32 {
	return volatile.LoadUint32(&o.MAXCNT.Reg) & 0x3ff
}

// USBD_ISOOUT.AMOUNT: Number of bytes transferred in the last transaction
func (o *USBD_ISOOUT_Type) SetAMOUNT(value uint32) {
	volatile.StoreUint32(&o.AMOUNT.Reg, volatile.LoadUint32(&o.AMOUNT.Reg)&^(0x3ff)|value)
}
func (o *USBD_ISOOUT_Type) GetAMOUNT() uint32 {
	return volatile.LoadUint32(&o.AMOUNT.Reg) & 0x3ff
}

// Constants for FICR: Factory information configuration registers
const (
	// CODEPAGESIZE: Code memory page size
	// Position of CODEPAGESIZE field.
	FICR_CODEPAGESIZE_CODEPAGESIZE_Pos = 0x0
	// Bit mask of CODEPAGESIZE field.
	FICR_CODEPAGESIZE_CODEPAGESIZE_Msk = 0xffffffff

	// CODESIZE: Code memory size
	// Position of CODESIZE field.
	FICR_CODESIZE_CODESIZE_Pos = 0x0
	// Bit mask of CODESIZE field.
	FICR_CODESIZE_CODESIZE_Msk = 0xffffffff

	// DEVICEID: Description collection: Device identifier
	// Position of DEVICEID field.
	FICR_DEVICEID_DEVICEID_Pos = 0x0
	// Bit mask of DEVICEID field.
	FICR_DEVICEID_DEVICEID_Msk = 0xffffffff

	// ER: Description collection: Encryption root, word n
	// Position of ER field.
	FICR_ER_ER_Pos = 0x0
	// Bit mask of ER field.
	FICR_ER_ER_Msk = 0xffffffff

	// IR: Description collection: Identity Root, word n
	// Position of IR field.
	FICR_IR_IR_Pos = 0x0
	// Bit mask of IR field.
	FICR_IR_IR_Msk = 0xffffffff

	// DEVICEADDRTYPE: Device address type
	// Position of DEVICEADDRTYPE field.
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos = 0x0
	// Bit mask of DEVICEADDRTYPE field.
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk = 0x1
	// Bit DEVICEADDRTYPE.
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE = 0x1
	// Public address
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public = 0x0
	// Random address
	FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random = 0x1

	// DEVICEADDR: Description collection: Device address n
	// Position of DEVICEADDR field.
	FICR_DEVICEADDR_DEVICEADDR_Pos = 0x0
	// Bit mask of DEVICEADDR field.
	FICR_DEVICEADDR_DEVICEADDR_Msk = 0xffffffff

	// INFO.PART: Part code
	// Position of PART field.
	FICR_INFO_PART_PART_Pos = 0x0
	// Bit mask of PART field.
	FICR_INFO_PART_PART_Msk = 0xffffffff
	// nRF52820
	FICR_INFO_PART_PART_N52820 = 0x52820
	// nRF52833
	FICR_INFO_PART_PART_N52833 = 0x52833
	// nRF52840
	FICR_INFO_PART_PART_N52840 = 0x52840
	// Unspecified
	FICR_INFO_PART_PART_Unspecified = 0xffffffff

	// INFO.VARIANT: Build code (hardware version and production configuration)
	// Position of VARIANT field.
	FICR_INFO_VARIANT_VARIANT_Pos = 0x0
	// Bit mask of VARIANT field.
	FICR_INFO_VARIANT_VARIANT_Msk = 0xffffffff
	// AAAA
	FICR_INFO_VARIANT_VARIANT_AAAA = 0x41414141
	// Unspecified
	FICR_INFO_VARIANT_VARIANT_Unspecified = 0xffffffff

	// INFO.PACKAGE: Package option
	// Position of PACKAGE field.
	FICR_INFO_PACKAGE_PACKAGE_Pos = 0x0
	// Bit mask of PACKAGE field.
	FICR_INFO_PACKAGE_PACKAGE_Msk = 0xffffffff
	// QDxx - 40-pin QFN
	FICR_INFO_PACKAGE_PACKAGE_QD = 0x2007
	// Unspecified
	FICR_INFO_PACKAGE_PACKAGE_Unspecified = 0xffffffff

	// INFO.RAM: RAM variant
	// Position of RAM field.
	FICR_INFO_RAM_RAM_Pos = 0x0
	// Bit mask of RAM field.
	FICR_INFO_RAM_RAM_Msk = 0xffffffff
	// 16 kByte RAM
	FICR_INFO_RAM_RAM_K16 = 0x10
	// 32 kByte RAM
	FICR_INFO_RAM_RAM_K32 = 0x20
	// 64 kByte RAM
	FICR_INFO_RAM_RAM_K64 = 0x40
	// 128 kByte RAM
	FICR_INFO_RAM_RAM_K128 = 0x80
	// 256 kByte RAM
	FICR_INFO_RAM_RAM_K256 = 0x100
	// Unspecified
	FICR_INFO_RAM_RAM_Unspecified = 0xffffffff

	// INFO.FLASH: Flash variant
	// Position of FLASH field.
	FICR_INFO_FLASH_FLASH_Pos = 0x0
	// Bit mask of FLASH field.
	FICR_INFO_FLASH_FLASH_Msk = 0xffffffff
	// 128 kByte FLASH
	FICR_INFO_FLASH_FLASH_K128 = 0x80
	// 256 kByte FLASH
	FICR_INFO_FLASH_FLASH_K256 = 0x100
	// 512 kByte FLASH
	FICR_INFO_FLASH_FLASH_K512 = 0x200
	// 1 MByte FLASH
	FICR_INFO_FLASH_FLASH_K1024 = 0x400
	// 2 MByte FLASH
	FICR_INFO_FLASH_FLASH_K2048 = 0x800
	// Unspecified
	FICR_INFO_FLASH_FLASH_Unspecified = 0xffffffff

	// PRODTEST: Description collection: Production test signature n
	// Position of PRODTEST field.
	FICR_PRODTEST_PRODTEST_Pos = 0x0
	// Bit mask of PRODTEST field.
	FICR_PRODTEST_PRODTEST_Msk = 0xffffffff
	// Production tests done
	FICR_PRODTEST_PRODTEST_Done = 0xbb42319f
	// Production tests not done
	FICR_PRODTEST_PRODTEST_NotDone = 0xffffffff

	// TEMP.A0: Slope definition A0
	// Position of A field.
	FICR_TEMP_A0_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A0_A_Msk = 0xfff

	// TEMP.A1: Slope definition A1
	// Position of A field.
	FICR_TEMP_A1_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A1_A_Msk = 0xfff

	// TEMP.A2: Slope definition A2
	// Position of A field.
	FICR_TEMP_A2_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A2_A_Msk = 0xfff

	// TEMP.A3: Slope definition A3
	// Position of A field.
	FICR_TEMP_A3_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A3_A_Msk = 0xfff

	// TEMP.A4: Slope definition A4
	// Position of A field.
	FICR_TEMP_A4_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A4_A_Msk = 0xfff

	// TEMP.A5: Slope definition A5
	// Position of A field.
	FICR_TEMP_A5_A_Pos = 0x0
	// Bit mask of A field.
	FICR_TEMP_A5_A_Msk = 0xfff

	// TEMP.B0: Y-intercept B0
	// Position of B field.
	FICR_TEMP_B0_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B0_B_Msk = 0x3fff

	// TEMP.B1: Y-intercept B1
	// Position of B field.
	FICR_TEMP_B1_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B1_B_Msk = 0x3fff

	// TEMP.B2: Y-intercept B2
	// Position of B field.
	FICR_TEMP_B2_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B2_B_Msk = 0x3fff

	// TEMP.B3: Y-intercept B3
	// Position of B field.
	FICR_TEMP_B3_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B3_B_Msk = 0x3fff

	// TEMP.B4: Y-intercept B4
	// Position of B field.
	FICR_TEMP_B4_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B4_B_Msk = 0x3fff

	// TEMP.B5: Y-intercept B5
	// Position of B field.
	FICR_TEMP_B5_B_Pos = 0x0
	// Bit mask of B field.
	FICR_TEMP_B5_B_Msk = 0x3fff

	// TEMP.T0: Segment end T0
	// Position of T field.
	FICR_TEMP_T0_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T0_T_Msk = 0xff

	// TEMP.T1: Segment end T1
	// Position of T field.
	FICR_TEMP_T1_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T1_T_Msk = 0xff

	// TEMP.T2: Segment end T2
	// Position of T field.
	FICR_TEMP_T2_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T2_T_Msk = 0xff

	// TEMP.T3: Segment end T3
	// Position of T field.
	FICR_TEMP_T3_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T3_T_Msk = 0xff

	// TEMP.T4: Segment end T4
	// Position of T field.
	FICR_TEMP_T4_T_Pos = 0x0
	// Bit mask of T field.
	FICR_TEMP_T4_T_Msk = 0xff
)

// Constants for UICR: User information configuration registers
const (
	// NRFFW: Description collection: Reserved for Nordic firmware design
	// Position of NRFFW field.
	UICR_NRFFW_NRFFW_Pos = 0x0
	// Bit mask of NRFFW field.
	UICR_NRFFW_NRFFW_Msk = 0xffffffff

	// NRFHW: Description collection: Reserved for Nordic hardware design
	// Position of NRFHW field.
	UICR_NRFHW_NRFHW_Pos = 0x0
	// Bit mask of NRFHW field.
	UICR_NRFHW_NRFHW_Msk = 0xffffffff

	// CUSTOMER: Description collection: Reserved for customer
	// Position of CUSTOMER field.
	UICR_CUSTOMER_CUSTOMER_Pos = 0x0
	// Bit mask of CUSTOMER field.
	UICR_CUSTOMER_CUSTOMER_Msk = 0xffffffff

	// PSELRESET: Description collection: Mapping of the nRESET function (see POWER chapter for details)
	// Position of PIN field.
	UICR_PSELRESET_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UICR_PSELRESET_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UICR_PSELRESET_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UICR_PSELRESET_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UICR_PSELRESET_CONNECT = 0x80000000
	// Disconnect
	UICR_PSELRESET_CONNECT_Disconnected = 0x1
	// Connect
	UICR_PSELRESET_CONNECT_Connected = 0x0

	// APPROTECT: Access port protection
	// Position of PALL field.
	UICR_APPROTECT_PALL_Pos = 0x0
	// Bit mask of PALL field.
	UICR_APPROTECT_PALL_Msk = 0xff
	// Disable
	UICR_APPROTECT_PALL_Disabled = 0xff
	// Enable
	UICR_APPROTECT_PALL_Enabled = 0x0

	// DEBUGCTRL: Processor debug control
	// Position of CPUFPBEN field.
	UICR_DEBUGCTRL_CPUFPBEN_Pos = 0x8
	// Bit mask of CPUFPBEN field.
	UICR_DEBUGCTRL_CPUFPBEN_Msk = 0xff00
	// Enable CPU FPB unit (default behavior)
	UICR_DEBUGCTRL_CPUFPBEN_Enabled = 0xff
	// Disable CPU FPB unit. Writes into the FPB registers will be ignored.
	UICR_DEBUGCTRL_CPUFPBEN_Disabled = 0x0

	// REGOUT0: Output voltage from REG0 regulator stage. The maximum output voltage from this stage is given as VDDH - VREG0DROP.
	// Position of VOUT field.
	UICR_REGOUT0_VOUT_Pos = 0x0
	// Bit mask of VOUT field.
	UICR_REGOUT0_VOUT_Msk = 0x7
	// 1.8 V
	UICR_REGOUT0_VOUT_1V8 = 0x0
	// 2.1 V
	UICR_REGOUT0_VOUT_2V1 = 0x1
	// 2.4 V
	UICR_REGOUT0_VOUT_2V4 = 0x2
	// 2.7 V
	UICR_REGOUT0_VOUT_2V7 = 0x3
	// 3.0 V
	UICR_REGOUT0_VOUT_3V0 = 0x4
	// 3.3 V
	UICR_REGOUT0_VOUT_3V3 = 0x5
	// Default voltage: 1.8 V
	UICR_REGOUT0_VOUT_DEFAULT = 0x7
)

// Constants for CLOCK: Clock control
const (
	// TASKS_HFCLKSTART: Start HFXO crystal oscillator
	// Position of TASKS_HFCLKSTART field.
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Pos = 0x0
	// Bit mask of TASKS_HFCLKSTART field.
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Msk = 0x1
	// Bit TASKS_HFCLKSTART.
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Trigger = 0x1

	// TASKS_HFCLKSTOP: Stop HFXO crystal oscillator
	// Position of TASKS_HFCLKSTOP field.
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Pos = 0x0
	// Bit mask of TASKS_HFCLKSTOP field.
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Msk = 0x1
	// Bit TASKS_HFCLKSTOP.
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Trigger = 0x1

	// TASKS_LFCLKSTART: Start LFCLK
	// Position of TASKS_LFCLKSTART field.
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Pos = 0x0
	// Bit mask of TASKS_LFCLKSTART field.
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Msk = 0x1
	// Bit TASKS_LFCLKSTART.
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART = 0x1
	// Trigger task
	CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Trigger = 0x1

	// TASKS_LFCLKSTOP: Stop LFCLK
	// Position of TASKS_LFCLKSTOP field.
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Pos = 0x0
	// Bit mask of TASKS_LFCLKSTOP field.
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Msk = 0x1
	// Bit TASKS_LFCLKSTOP.
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Trigger = 0x1

	// TASKS_CAL: Start calibration of LFRC
	// Position of TASKS_CAL field.
	CLOCK_TASKS_CAL_TASKS_CAL_Pos = 0x0
	// Bit mask of TASKS_CAL field.
	CLOCK_TASKS_CAL_TASKS_CAL_Msk = 0x1
	// Bit TASKS_CAL.
	CLOCK_TASKS_CAL_TASKS_CAL = 0x1
	// Trigger task
	CLOCK_TASKS_CAL_TASKS_CAL_Trigger = 0x1

	// TASKS_CTSTART: Start calibration timer
	// Position of TASKS_CTSTART field.
	CLOCK_TASKS_CTSTART_TASKS_CTSTART_Pos = 0x0
	// Bit mask of TASKS_CTSTART field.
	CLOCK_TASKS_CTSTART_TASKS_CTSTART_Msk = 0x1
	// Bit TASKS_CTSTART.
	CLOCK_TASKS_CTSTART_TASKS_CTSTART = 0x1
	// Trigger task
	CLOCK_TASKS_CTSTART_TASKS_CTSTART_Trigger = 0x1

	// TASKS_CTSTOP: Stop calibration timer
	// Position of TASKS_CTSTOP field.
	CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Pos = 0x0
	// Bit mask of TASKS_CTSTOP field.
	CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Msk = 0x1
	// Bit TASKS_CTSTOP.
	CLOCK_TASKS_CTSTOP_TASKS_CTSTOP = 0x1
	// Trigger task
	CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Trigger = 0x1

	// EVENTS_HFCLKSTARTED: HFXO crystal oscillator started
	// Position of EVENTS_HFCLKSTARTED field.
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Pos = 0x0
	// Bit mask of EVENTS_HFCLKSTARTED field.
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Msk = 0x1
	// Bit EVENTS_HFCLKSTARTED.
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Generated = 0x1

	// EVENTS_LFCLKSTARTED: LFCLK started
	// Position of EVENTS_LFCLKSTARTED field.
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Pos = 0x0
	// Bit mask of EVENTS_LFCLKSTARTED field.
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Msk = 0x1
	// Bit EVENTS_LFCLKSTARTED.
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Generated = 0x1

	// EVENTS_DONE: Calibration of LFRC completed
	// Position of EVENTS_DONE field.
	CLOCK_EVENTS_DONE_EVENTS_DONE_Pos = 0x0
	// Bit mask of EVENTS_DONE field.
	CLOCK_EVENTS_DONE_EVENTS_DONE_Msk = 0x1
	// Bit EVENTS_DONE.
	CLOCK_EVENTS_DONE_EVENTS_DONE = 0x1
	// Event not generated
	CLOCK_EVENTS_DONE_EVENTS_DONE_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_DONE_EVENTS_DONE_Generated = 0x1

	// EVENTS_CTTO: Calibration timer timeout
	// Position of EVENTS_CTTO field.
	CLOCK_EVENTS_CTTO_EVENTS_CTTO_Pos = 0x0
	// Bit mask of EVENTS_CTTO field.
	CLOCK_EVENTS_CTTO_EVENTS_CTTO_Msk = 0x1
	// Bit EVENTS_CTTO.
	CLOCK_EVENTS_CTTO_EVENTS_CTTO = 0x1
	// Event not generated
	CLOCK_EVENTS_CTTO_EVENTS_CTTO_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_CTTO_EVENTS_CTTO_Generated = 0x1

	// EVENTS_CTSTARTED: Calibration timer has been started and is ready to process new tasks
	// Position of EVENTS_CTSTARTED field.
	CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Pos = 0x0
	// Bit mask of EVENTS_CTSTARTED field.
	CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Msk = 0x1
	// Bit EVENTS_CTSTARTED.
	CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED = 0x1
	// Event not generated
	CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Generated = 0x1

	// EVENTS_CTSTOPPED: Calibration timer has been stopped and is ready to process new tasks
	// Position of EVENTS_CTSTOPPED field.
	CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Pos = 0x0
	// Bit mask of EVENTS_CTSTOPPED field.
	CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Msk = 0x1
	// Bit EVENTS_CTSTOPPED.
	CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED = 0x1
	// Event not generated
	CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_NotGenerated = 0x0
	// Event generated
	CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTENSET_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTENSET_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTENSET_HFCLKSTARTED = 0x1
	// Read: Disabled
	CLOCK_INTENSET_HFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_HFCLKSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_HFCLKSTARTED_Set = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTENSET_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTENSET_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTENSET_LFCLKSTARTED = 0x2
	// Read: Disabled
	CLOCK_INTENSET_LFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_LFCLKSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_LFCLKSTARTED_Set = 0x1
	// Position of DONE field.
	CLOCK_INTENSET_DONE_Pos = 0x3
	// Bit mask of DONE field.
	CLOCK_INTENSET_DONE_Msk = 0x8
	// Bit DONE.
	CLOCK_INTENSET_DONE = 0x8
	// Read: Disabled
	CLOCK_INTENSET_DONE_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_DONE_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_DONE_Set = 0x1
	// Position of CTTO field.
	CLOCK_INTENSET_CTTO_Pos = 0x4
	// Bit mask of CTTO field.
	CLOCK_INTENSET_CTTO_Msk = 0x10
	// Bit CTTO.
	CLOCK_INTENSET_CTTO = 0x10
	// Read: Disabled
	CLOCK_INTENSET_CTTO_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_CTTO_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_CTTO_Set = 0x1
	// Position of CTSTARTED field.
	CLOCK_INTENSET_CTSTARTED_Pos = 0xa
	// Bit mask of CTSTARTED field.
	CLOCK_INTENSET_CTSTARTED_Msk = 0x400
	// Bit CTSTARTED.
	CLOCK_INTENSET_CTSTARTED = 0x400
	// Read: Disabled
	CLOCK_INTENSET_CTSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_CTSTARTED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_CTSTARTED_Set = 0x1
	// Position of CTSTOPPED field.
	CLOCK_INTENSET_CTSTOPPED_Pos = 0xb
	// Bit mask of CTSTOPPED field.
	CLOCK_INTENSET_CTSTOPPED_Msk = 0x800
	// Bit CTSTOPPED.
	CLOCK_INTENSET_CTSTOPPED = 0x800
	// Read: Disabled
	CLOCK_INTENSET_CTSTOPPED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENSET_CTSTOPPED_Enabled = 0x1
	// Enable
	CLOCK_INTENSET_CTSTOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of HFCLKSTARTED field.
	CLOCK_INTENCLR_HFCLKSTARTED_Pos = 0x0
	// Bit mask of HFCLKSTARTED field.
	CLOCK_INTENCLR_HFCLKSTARTED_Msk = 0x1
	// Bit HFCLKSTARTED.
	CLOCK_INTENCLR_HFCLKSTARTED = 0x1
	// Read: Disabled
	CLOCK_INTENCLR_HFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_HFCLKSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_HFCLKSTARTED_Clear = 0x1
	// Position of LFCLKSTARTED field.
	CLOCK_INTENCLR_LFCLKSTARTED_Pos = 0x1
	// Bit mask of LFCLKSTARTED field.
	CLOCK_INTENCLR_LFCLKSTARTED_Msk = 0x2
	// Bit LFCLKSTARTED.
	CLOCK_INTENCLR_LFCLKSTARTED = 0x2
	// Read: Disabled
	CLOCK_INTENCLR_LFCLKSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_LFCLKSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_LFCLKSTARTED_Clear = 0x1
	// Position of DONE field.
	CLOCK_INTENCLR_DONE_Pos = 0x3
	// Bit mask of DONE field.
	CLOCK_INTENCLR_DONE_Msk = 0x8
	// Bit DONE.
	CLOCK_INTENCLR_DONE = 0x8
	// Read: Disabled
	CLOCK_INTENCLR_DONE_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_DONE_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_DONE_Clear = 0x1
	// Position of CTTO field.
	CLOCK_INTENCLR_CTTO_Pos = 0x4
	// Bit mask of CTTO field.
	CLOCK_INTENCLR_CTTO_Msk = 0x10
	// Bit CTTO.
	CLOCK_INTENCLR_CTTO = 0x10
	// Read: Disabled
	CLOCK_INTENCLR_CTTO_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_CTTO_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_CTTO_Clear = 0x1
	// Position of CTSTARTED field.
	CLOCK_INTENCLR_CTSTARTED_Pos = 0xa
	// Bit mask of CTSTARTED field.
	CLOCK_INTENCLR_CTSTARTED_Msk = 0x400
	// Bit CTSTARTED.
	CLOCK_INTENCLR_CTSTARTED = 0x400
	// Read: Disabled
	CLOCK_INTENCLR_CTSTARTED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_CTSTARTED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_CTSTARTED_Clear = 0x1
	// Position of CTSTOPPED field.
	CLOCK_INTENCLR_CTSTOPPED_Pos = 0xb
	// Bit mask of CTSTOPPED field.
	CLOCK_INTENCLR_CTSTOPPED_Msk = 0x800
	// Bit CTSTOPPED.
	CLOCK_INTENCLR_CTSTOPPED = 0x800
	// Read: Disabled
	CLOCK_INTENCLR_CTSTOPPED_Disabled = 0x0
	// Read: Enabled
	CLOCK_INTENCLR_CTSTOPPED_Enabled = 0x1
	// Disable
	CLOCK_INTENCLR_CTSTOPPED_Clear = 0x1

	// HFCLKRUN: Status indicating that HFCLKSTART task has been triggered
	// Position of STATUS field.
	CLOCK_HFCLKRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_HFCLKRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_HFCLKRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_HFCLKRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_HFCLKRUN_STATUS_Triggered = 0x1

	// HFCLKSTAT: HFCLK status
	// Position of SRC field.
	CLOCK_HFCLKSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_HFCLKSTAT_SRC_Msk = 0x1
	// Bit SRC.
	CLOCK_HFCLKSTAT_SRC = 0x1
	// 64 MHz internal oscillator (HFINT)
	CLOCK_HFCLKSTAT_SRC_RC = 0x0
	// 64 MHz crystal oscillator (HFXO)
	CLOCK_HFCLKSTAT_SRC_Xtal = 0x1
	// Position of STATE field.
	CLOCK_HFCLKSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_HFCLKSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_HFCLKSTAT_STATE = 0x10000
	// HFCLK not running
	CLOCK_HFCLKSTAT_STATE_NotRunning = 0x0
	// HFCLK running
	CLOCK_HFCLKSTAT_STATE_Running = 0x1

	// LFCLKRUN: Status indicating that LFCLKSTART task has been triggered
	// Position of STATUS field.
	CLOCK_LFCLKRUN_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	CLOCK_LFCLKRUN_STATUS_Msk = 0x1
	// Bit STATUS.
	CLOCK_LFCLKRUN_STATUS = 0x1
	// Task not triggered
	CLOCK_LFCLKRUN_STATUS_NotTriggered = 0x0
	// Task triggered
	CLOCK_LFCLKRUN_STATUS_Triggered = 0x1

	// LFCLKSTAT: LFCLK status
	// Position of SRC field.
	CLOCK_LFCLKSTAT_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSTAT_SRC_Msk = 0x3
	// 32.768 kHz RC oscillator (LFRC)
	CLOCK_LFCLKSTAT_SRC_RC = 0x0
	// 32.768 kHz crystal oscillator (LFXO)
	CLOCK_LFCLKSTAT_SRC_Xtal = 0x1
	// 32.768 kHz synthesized from HFCLK (LFSYNT)
	CLOCK_LFCLKSTAT_SRC_Synth = 0x2
	// Position of STATE field.
	CLOCK_LFCLKSTAT_STATE_Pos = 0x10
	// Bit mask of STATE field.
	CLOCK_LFCLKSTAT_STATE_Msk = 0x10000
	// Bit STATE.
	CLOCK_LFCLKSTAT_STATE = 0x10000
	// LFCLK not running
	CLOCK_LFCLKSTAT_STATE_NotRunning = 0x0
	// LFCLK running
	CLOCK_LFCLKSTAT_STATE_Running = 0x1

	// LFCLKSRCCOPY: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered
	// Position of SRC field.
	CLOCK_LFCLKSRCCOPY_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSRCCOPY_SRC_Msk = 0x3
	// 32.768 kHz RC oscillator (LFRC)
	CLOCK_LFCLKSRCCOPY_SRC_RC = 0x0
	// 32.768 kHz crystal oscillator (LFXO)
	CLOCK_LFCLKSRCCOPY_SRC_Xtal = 0x1
	// 32.768 kHz synthesized from HFCLK (LFSYNT)
	CLOCK_LFCLKSRCCOPY_SRC_Synth = 0x2

	// LFCLKSRC: Clock source for the LFCLK
	// Position of SRC field.
	CLOCK_LFCLKSRC_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCK_LFCLKSRC_SRC_Msk = 0x3
	// 32.768 kHz RC oscillator (LFRC)
	CLOCK_LFCLKSRC_SRC_RC = 0x0
	// 32.768 kHz crystal oscillator (LFXO)
	CLOCK_LFCLKSRC_SRC_Xtal = 0x1
	// 32.768 kHz synthesized from HFCLK (LFSYNT)
	CLOCK_LFCLKSRC_SRC_Synth = 0x2
	// Position of BYPASS field.
	CLOCK_LFCLKSRC_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CLOCK_LFCLKSRC_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CLOCK_LFCLKSRC_BYPASS = 0x10000
	// Disable (use with Xtal or low-swing external source)
	CLOCK_LFCLKSRC_BYPASS_Disabled = 0x0
	// Enable (use with rail-to-rail external source)
	CLOCK_LFCLKSRC_BYPASS_Enabled = 0x1
	// Position of EXTERNAL field.
	CLOCK_LFCLKSRC_EXTERNAL_Pos = 0x11
	// Bit mask of EXTERNAL field.
	CLOCK_LFCLKSRC_EXTERNAL_Msk = 0x20000
	// Bit EXTERNAL.
	CLOCK_LFCLKSRC_EXTERNAL = 0x20000
	// Disable external source (use with Xtal)
	CLOCK_LFCLKSRC_EXTERNAL_Disabled = 0x0
	// Enable use of external source instead of Xtal (SRC needs to be set to Xtal)
	CLOCK_LFCLKSRC_EXTERNAL_Enabled = 0x1

	// HFXODEBOUNCE: HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task.
	// Position of HFXODEBOUNCE field.
	CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Pos = 0x0
	// Bit mask of HFXODEBOUNCE field.
	CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Msk = 0xff
	// 256 us debounce time. Recommended for 1.6 mm x 2.0 mm crystals and larger.
	CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Db256us = 0x10
	// 1024 us debounce time. Recommended for 1.6 mm x 1.2 mm crystals and smaller.
	CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Db1024us = 0x40

	// LFXODEBOUNCE: LFXO debounce time. The LFXO is started by triggering the TASKS_LFCLKSTART task when the LFCLKSRC register is configured for Xtal.
	// Position of LFXODEBOUNCE field.
	CLOCK_LFXODEBOUNCE_LFXODEBOUNCE_Pos = 0x0
	// Bit mask of LFXODEBOUNCE field.
	CLOCK_LFXODEBOUNCE_LFXODEBOUNCE_Msk = 0x1
	// Bit LFXODEBOUNCE.
	CLOCK_LFXODEBOUNCE_LFXODEBOUNCE = 0x1
	// 8192 32.768 kHz periods, or 0.25 s. Recommended for normal Operating Temperature conditions.
	CLOCK_LFXODEBOUNCE_LFXODEBOUNCE_Normal = 0x0
	// 16384 32.768 kHz periods, or 0.5 s. Recommended for Extended Operating Temperature conditions.
	CLOCK_LFXODEBOUNCE_LFXODEBOUNCE_Extended = 0x1

	// CTIV: Calibration timer interval
	// Position of CTIV field.
	CLOCK_CTIV_CTIV_Pos = 0x0
	// Bit mask of CTIV field.
	CLOCK_CTIV_CTIV_Msk = 0x7f
)

// Constants for POWER: Power control
const (
	// TASKS_CONSTLAT: Enable Constant Latency mode
	// Position of TASKS_CONSTLAT field.
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Pos = 0x0
	// Bit mask of TASKS_CONSTLAT field.
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Msk = 0x1
	// Bit TASKS_CONSTLAT.
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT = 0x1
	// Trigger task
	POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Trigger = 0x1

	// TASKS_LOWPWR: Enable Low-power mode (variable latency)
	// Position of TASKS_LOWPWR field.
	POWER_TASKS_LOWPWR_TASKS_LOWPWR_Pos = 0x0
	// Bit mask of TASKS_LOWPWR field.
	POWER_TASKS_LOWPWR_TASKS_LOWPWR_Msk = 0x1
	// Bit TASKS_LOWPWR.
	POWER_TASKS_LOWPWR_TASKS_LOWPWR = 0x1
	// Trigger task
	POWER_TASKS_LOWPWR_TASKS_LOWPWR_Trigger = 0x1

	// EVENTS_POFWARN: Power failure warning
	// Position of EVENTS_POFWARN field.
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_Pos = 0x0
	// Bit mask of EVENTS_POFWARN field.
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_Msk = 0x1
	// Bit EVENTS_POFWARN.
	POWER_EVENTS_POFWARN_EVENTS_POFWARN = 0x1
	// Event not generated
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_POFWARN_EVENTS_POFWARN_Generated = 0x1

	// EVENTS_SLEEPENTER: CPU entered WFI/WFE sleep
	// Position of EVENTS_SLEEPENTER field.
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos = 0x0
	// Bit mask of EVENTS_SLEEPENTER field.
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Msk = 0x1
	// Bit EVENTS_SLEEPENTER.
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER = 0x1
	// Event not generated
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Generated = 0x1

	// EVENTS_SLEEPEXIT: CPU exited WFI/WFE sleep
	// Position of EVENTS_SLEEPEXIT field.
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos = 0x0
	// Bit mask of EVENTS_SLEEPEXIT field.
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Msk = 0x1
	// Bit EVENTS_SLEEPEXIT.
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT = 0x1
	// Event not generated
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Generated = 0x1

	// EVENTS_USBDETECTED: Voltage supply detected on VBUS
	// Position of EVENTS_USBDETECTED field.
	POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Pos = 0x0
	// Bit mask of EVENTS_USBDETECTED field.
	POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Msk = 0x1
	// Bit EVENTS_USBDETECTED.
	POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED = 0x1
	// Event not generated
	POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Generated = 0x1

	// EVENTS_USBREMOVED: Voltage supply removed from VBUS
	// Position of EVENTS_USBREMOVED field.
	POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Pos = 0x0
	// Bit mask of EVENTS_USBREMOVED field.
	POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Msk = 0x1
	// Bit EVENTS_USBREMOVED.
	POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED = 0x1
	// Event not generated
	POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Generated = 0x1

	// EVENTS_USBPWRRDY: USB 3.3 V supply ready
	// Position of EVENTS_USBPWRRDY field.
	POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Pos = 0x0
	// Bit mask of EVENTS_USBPWRRDY field.
	POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Msk = 0x1
	// Bit EVENTS_USBPWRRDY.
	POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY = 0x1
	// Event not generated
	POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_NotGenerated = 0x0
	// Event generated
	POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of POFWARN field.
	POWER_INTENSET_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTENSET_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTENSET_POFWARN = 0x4
	// Read: Disabled
	POWER_INTENSET_POFWARN_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_POFWARN_Enabled = 0x1
	// Enable
	POWER_INTENSET_POFWARN_Set = 0x1
	// Position of SLEEPENTER field.
	POWER_INTENSET_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTENSET_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTENSET_SLEEPENTER = 0x20
	// Read: Disabled
	POWER_INTENSET_SLEEPENTER_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_SLEEPENTER_Enabled = 0x1
	// Enable
	POWER_INTENSET_SLEEPENTER_Set = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTENSET_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTENSET_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTENSET_SLEEPEXIT = 0x40
	// Read: Disabled
	POWER_INTENSET_SLEEPEXIT_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_SLEEPEXIT_Enabled = 0x1
	// Enable
	POWER_INTENSET_SLEEPEXIT_Set = 0x1
	// Position of USBDETECTED field.
	POWER_INTENSET_USBDETECTED_Pos = 0x7
	// Bit mask of USBDETECTED field.
	POWER_INTENSET_USBDETECTED_Msk = 0x80
	// Bit USBDETECTED.
	POWER_INTENSET_USBDETECTED = 0x80
	// Read: Disabled
	POWER_INTENSET_USBDETECTED_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_USBDETECTED_Enabled = 0x1
	// Enable
	POWER_INTENSET_USBDETECTED_Set = 0x1
	// Position of USBREMOVED field.
	POWER_INTENSET_USBREMOVED_Pos = 0x8
	// Bit mask of USBREMOVED field.
	POWER_INTENSET_USBREMOVED_Msk = 0x100
	// Bit USBREMOVED.
	POWER_INTENSET_USBREMOVED = 0x100
	// Read: Disabled
	POWER_INTENSET_USBREMOVED_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_USBREMOVED_Enabled = 0x1
	// Enable
	POWER_INTENSET_USBREMOVED_Set = 0x1
	// Position of USBPWRRDY field.
	POWER_INTENSET_USBPWRRDY_Pos = 0x9
	// Bit mask of USBPWRRDY field.
	POWER_INTENSET_USBPWRRDY_Msk = 0x200
	// Bit USBPWRRDY.
	POWER_INTENSET_USBPWRRDY = 0x200
	// Read: Disabled
	POWER_INTENSET_USBPWRRDY_Disabled = 0x0
	// Read: Enabled
	POWER_INTENSET_USBPWRRDY_Enabled = 0x1
	// Enable
	POWER_INTENSET_USBPWRRDY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of POFWARN field.
	POWER_INTENCLR_POFWARN_Pos = 0x2
	// Bit mask of POFWARN field.
	POWER_INTENCLR_POFWARN_Msk = 0x4
	// Bit POFWARN.
	POWER_INTENCLR_POFWARN = 0x4
	// Read: Disabled
	POWER_INTENCLR_POFWARN_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_POFWARN_Enabled = 0x1
	// Disable
	POWER_INTENCLR_POFWARN_Clear = 0x1
	// Position of SLEEPENTER field.
	POWER_INTENCLR_SLEEPENTER_Pos = 0x5
	// Bit mask of SLEEPENTER field.
	POWER_INTENCLR_SLEEPENTER_Msk = 0x20
	// Bit SLEEPENTER.
	POWER_INTENCLR_SLEEPENTER = 0x20
	// Read: Disabled
	POWER_INTENCLR_SLEEPENTER_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_SLEEPENTER_Enabled = 0x1
	// Disable
	POWER_INTENCLR_SLEEPENTER_Clear = 0x1
	// Position of SLEEPEXIT field.
	POWER_INTENCLR_SLEEPEXIT_Pos = 0x6
	// Bit mask of SLEEPEXIT field.
	POWER_INTENCLR_SLEEPEXIT_Msk = 0x40
	// Bit SLEEPEXIT.
	POWER_INTENCLR_SLEEPEXIT = 0x40
	// Read: Disabled
	POWER_INTENCLR_SLEEPEXIT_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_SLEEPEXIT_Enabled = 0x1
	// Disable
	POWER_INTENCLR_SLEEPEXIT_Clear = 0x1
	// Position of USBDETECTED field.
	POWER_INTENCLR_USBDETECTED_Pos = 0x7
	// Bit mask of USBDETECTED field.
	POWER_INTENCLR_USBDETECTED_Msk = 0x80
	// Bit USBDETECTED.
	POWER_INTENCLR_USBDETECTED = 0x80
	// Read: Disabled
	POWER_INTENCLR_USBDETECTED_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_USBDETECTED_Enabled = 0x1
	// Disable
	POWER_INTENCLR_USBDETECTED_Clear = 0x1
	// Position of USBREMOVED field.
	POWER_INTENCLR_USBREMOVED_Pos = 0x8
	// Bit mask of USBREMOVED field.
	POWER_INTENCLR_USBREMOVED_Msk = 0x100
	// Bit USBREMOVED.
	POWER_INTENCLR_USBREMOVED = 0x100
	// Read: Disabled
	POWER_INTENCLR_USBREMOVED_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_USBREMOVED_Enabled = 0x1
	// Disable
	POWER_INTENCLR_USBREMOVED_Clear = 0x1
	// Position of USBPWRRDY field.
	POWER_INTENCLR_USBPWRRDY_Pos = 0x9
	// Bit mask of USBPWRRDY field.
	POWER_INTENCLR_USBPWRRDY_Msk = 0x200
	// Bit USBPWRRDY.
	POWER_INTENCLR_USBPWRRDY = 0x200
	// Read: Disabled
	POWER_INTENCLR_USBPWRRDY_Disabled = 0x0
	// Read: Enabled
	POWER_INTENCLR_USBPWRRDY_Enabled = 0x1
	// Disable
	POWER_INTENCLR_USBPWRRDY_Clear = 0x1

	// RESETREAS: Reset reason
	// Position of RESETPIN field.
	POWER_RESETREAS_RESETPIN_Pos = 0x0
	// Bit mask of RESETPIN field.
	POWER_RESETREAS_RESETPIN_Msk = 0x1
	// Bit RESETPIN.
	POWER_RESETREAS_RESETPIN = 0x1
	// Not detected
	POWER_RESETREAS_RESETPIN_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_RESETPIN_Detected = 0x1
	// Position of DOG field.
	POWER_RESETREAS_DOG_Pos = 0x1
	// Bit mask of DOG field.
	POWER_RESETREAS_DOG_Msk = 0x2
	// Bit DOG.
	POWER_RESETREAS_DOG = 0x2
	// Not detected
	POWER_RESETREAS_DOG_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_DOG_Detected = 0x1
	// Position of SREQ field.
	POWER_RESETREAS_SREQ_Pos = 0x2
	// Bit mask of SREQ field.
	POWER_RESETREAS_SREQ_Msk = 0x4
	// Bit SREQ.
	POWER_RESETREAS_SREQ = 0x4
	// Not detected
	POWER_RESETREAS_SREQ_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_SREQ_Detected = 0x1
	// Position of LOCKUP field.
	POWER_RESETREAS_LOCKUP_Pos = 0x3
	// Bit mask of LOCKUP field.
	POWER_RESETREAS_LOCKUP_Msk = 0x8
	// Bit LOCKUP.
	POWER_RESETREAS_LOCKUP = 0x8
	// Not detected
	POWER_RESETREAS_LOCKUP_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_LOCKUP_Detected = 0x1
	// Position of OFF field.
	POWER_RESETREAS_OFF_Pos = 0x10
	// Bit mask of OFF field.
	POWER_RESETREAS_OFF_Msk = 0x10000
	// Bit OFF.
	POWER_RESETREAS_OFF = 0x10000
	// Not detected
	POWER_RESETREAS_OFF_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_OFF_Detected = 0x1
	// Position of DIF field.
	POWER_RESETREAS_DIF_Pos = 0x12
	// Bit mask of DIF field.
	POWER_RESETREAS_DIF_Msk = 0x40000
	// Bit DIF.
	POWER_RESETREAS_DIF = 0x40000
	// Not detected
	POWER_RESETREAS_DIF_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_DIF_Detected = 0x1
	// Position of VBUS field.
	POWER_RESETREAS_VBUS_Pos = 0x14
	// Bit mask of VBUS field.
	POWER_RESETREAS_VBUS_Msk = 0x100000
	// Bit VBUS.
	POWER_RESETREAS_VBUS = 0x100000
	// Not detected
	POWER_RESETREAS_VBUS_NotDetected = 0x0
	// Detected
	POWER_RESETREAS_VBUS_Detected = 0x1

	// RAMSTATUS: Deprecated register - RAM status register
	// Position of RAMBLOCK0 field.
	POWER_RAMSTATUS_RAMBLOCK0_Pos = 0x0
	// Bit mask of RAMBLOCK0 field.
	POWER_RAMSTATUS_RAMBLOCK0_Msk = 0x1
	// Bit RAMBLOCK0.
	POWER_RAMSTATUS_RAMBLOCK0 = 0x1
	// Off
	POWER_RAMSTATUS_RAMBLOCK0_Off = 0x0
	// On
	POWER_RAMSTATUS_RAMBLOCK0_On = 0x1
	// Position of RAMBLOCK1 field.
	POWER_RAMSTATUS_RAMBLOCK1_Pos = 0x1
	// Bit mask of RAMBLOCK1 field.
	POWER_RAMSTATUS_RAMBLOCK1_Msk = 0x2
	// Bit RAMBLOCK1.
	POWER_RAMSTATUS_RAMBLOCK1 = 0x2
	// Off
	POWER_RAMSTATUS_RAMBLOCK1_Off = 0x0
	// On
	POWER_RAMSTATUS_RAMBLOCK1_On = 0x1

	// USBREGSTATUS: USB supply status
	// Position of VBUSDETECT field.
	POWER_USBREGSTATUS_VBUSDETECT_Pos = 0x0
	// Bit mask of VBUSDETECT field.
	POWER_USBREGSTATUS_VBUSDETECT_Msk = 0x1
	// Bit VBUSDETECT.
	POWER_USBREGSTATUS_VBUSDETECT = 0x1
	// VBUS voltage below valid threshold
	POWER_USBREGSTATUS_VBUSDETECT_NoVbus = 0x0
	// VBUS voltage above valid threshold
	POWER_USBREGSTATUS_VBUSDETECT_VbusPresent = 0x1
	// Position of OUTPUTRDY field.
	POWER_USBREGSTATUS_OUTPUTRDY_Pos = 0x1
	// Bit mask of OUTPUTRDY field.
	POWER_USBREGSTATUS_OUTPUTRDY_Msk = 0x2
	// Bit OUTPUTRDY.
	POWER_USBREGSTATUS_OUTPUTRDY = 0x2
	// USBREG output settling time not elapsed
	POWER_USBREGSTATUS_OUTPUTRDY_NotReady = 0x0
	// USBREG output settling time elapsed (same information as USBPWRRDY event)
	POWER_USBREGSTATUS_OUTPUTRDY_Ready = 0x1

	// SYSTEMOFF: System OFF register
	// Position of SYSTEMOFF field.
	POWER_SYSTEMOFF_SYSTEMOFF_Pos = 0x0
	// Bit mask of SYSTEMOFF field.
	POWER_SYSTEMOFF_SYSTEMOFF_Msk = 0x1
	// Bit SYSTEMOFF.
	POWER_SYSTEMOFF_SYSTEMOFF = 0x1
	// Enable System OFF mode
	POWER_SYSTEMOFF_SYSTEMOFF_Enter = 0x1

	// POFCON: Power-fail comparator configuration
	// Position of POF field.
	POWER_POFCON_POF_Pos = 0x0
	// Bit mask of POF field.
	POWER_POFCON_POF_Msk = 0x1
	// Bit POF.
	POWER_POFCON_POF = 0x1
	// Disable
	POWER_POFCON_POF_Disabled = 0x0
	// Enable
	POWER_POFCON_POF_Enabled = 0x1
	// Position of THRESHOLD field.
	POWER_POFCON_THRESHOLD_Pos = 0x1
	// Bit mask of THRESHOLD field.
	POWER_POFCON_THRESHOLD_Msk = 0x1e
	// Set threshold to 1.7 V
	POWER_POFCON_THRESHOLD_V17 = 0x4
	// Set threshold to 1.8 V
	POWER_POFCON_THRESHOLD_V18 = 0x5
	// Set threshold to 1.9 V
	POWER_POFCON_THRESHOLD_V19 = 0x6
	// Set threshold to 2.0 V
	POWER_POFCON_THRESHOLD_V20 = 0x7
	// Set threshold to 2.1 V
	POWER_POFCON_THRESHOLD_V21 = 0x8
	// Set threshold to 2.2 V
	POWER_POFCON_THRESHOLD_V22 = 0x9
	// Set threshold to 2.3 V
	POWER_POFCON_THRESHOLD_V23 = 0xa
	// Set threshold to 2.4 V
	POWER_POFCON_THRESHOLD_V24 = 0xb
	// Set threshold to 2.5 V
	POWER_POFCON_THRESHOLD_V25 = 0xc
	// Set threshold to 2.6 V
	POWER_POFCON_THRESHOLD_V26 = 0xd
	// Set threshold to 2.7 V
	POWER_POFCON_THRESHOLD_V27 = 0xe
	// Set threshold to 2.8 V
	POWER_POFCON_THRESHOLD_V28 = 0xf
	// Position of THRESHOLDVDDH field.
	POWER_POFCON_THRESHOLDVDDH_Pos = 0x8
	// Bit mask of THRESHOLDVDDH field.
	POWER_POFCON_THRESHOLDVDDH_Msk = 0xf00
	// Set threshold to 2.7 V
	POWER_POFCON_THRESHOLDVDDH_V27 = 0x0
	// Set threshold to 2.8 V
	POWER_POFCON_THRESHOLDVDDH_V28 = 0x1
	// Set threshold to 2.9 V
	POWER_POFCON_THRESHOLDVDDH_V29 = 0x2
	// Set threshold to 3.0 V
	POWER_POFCON_THRESHOLDVDDH_V30 = 0x3
	// Set threshold to 3.1 V
	POWER_POFCON_THRESHOLDVDDH_V31 = 0x4
	// Set threshold to 3.2 V
	POWER_POFCON_THRESHOLDVDDH_V32 = 0x5
	// Set threshold to 3.3 V
	POWER_POFCON_THRESHOLDVDDH_V33 = 0x6
	// Set threshold to 3.4 V
	POWER_POFCON_THRESHOLDVDDH_V34 = 0x7
	// Set threshold to 3.5 V
	POWER_POFCON_THRESHOLDVDDH_V35 = 0x8
	// Set threshold to 3.6 V
	POWER_POFCON_THRESHOLDVDDH_V36 = 0x9
	// Set threshold to 3.7 V
	POWER_POFCON_THRESHOLDVDDH_V37 = 0xa
	// Set threshold to 3.8 V
	POWER_POFCON_THRESHOLDVDDH_V38 = 0xb
	// Set threshold to 3.9 V
	POWER_POFCON_THRESHOLDVDDH_V39 = 0xc
	// Set threshold to 4.0 V
	POWER_POFCON_THRESHOLDVDDH_V40 = 0xd
	// Set threshold to 4.1 V
	POWER_POFCON_THRESHOLDVDDH_V41 = 0xe
	// Set threshold to 4.2 V
	POWER_POFCON_THRESHOLDVDDH_V42 = 0xf

	// GPREGRET: General purpose retention register
	// Position of GPREGRET field.
	POWER_GPREGRET_GPREGRET_Pos = 0x0
	// Bit mask of GPREGRET field.
	POWER_GPREGRET_GPREGRET_Msk = 0xff

	// GPREGRET2: General purpose retention register
	// Position of GPREGRET field.
	POWER_GPREGRET2_GPREGRET_Pos = 0x0
	// Bit mask of GPREGRET field.
	POWER_GPREGRET2_GPREGRET_Msk = 0xff

	// DCDCEN: Enable DC/DC converter for REG1 stage
	// Position of DCDCEN field.
	POWER_DCDCEN_DCDCEN_Pos = 0x0
	// Bit mask of DCDCEN field.
	POWER_DCDCEN_DCDCEN_Msk = 0x1
	// Bit DCDCEN.
	POWER_DCDCEN_DCDCEN = 0x1
	// Disable
	POWER_DCDCEN_DCDCEN_Disabled = 0x0
	// Enable
	POWER_DCDCEN_DCDCEN_Enabled = 0x1

	// MAINREGSTATUS: Main supply status
	// Position of MAINREGSTATUS field.
	POWER_MAINREGSTATUS_MAINREGSTATUS_Pos = 0x0
	// Bit mask of MAINREGSTATUS field.
	POWER_MAINREGSTATUS_MAINREGSTATUS_Msk = 0x1
	// Bit MAINREGSTATUS.
	POWER_MAINREGSTATUS_MAINREGSTATUS = 0x1
	// Normal voltage mode. Voltage supplied on VDD.
	POWER_MAINREGSTATUS_MAINREGSTATUS_Normal = 0x0
	// High voltage mode. Voltage supplied on VDDH.
	POWER_MAINREGSTATUS_MAINREGSTATUS_High = 0x1

	// RAM.POWER: Description cluster: RAMn power control register
	// Position of S0POWER field.
	POWER_RAM_POWER_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	POWER_RAM_POWER_S0POWER_Msk = 0x1
	// Bit S0POWER.
	POWER_RAM_POWER_S0POWER = 0x1
	// Off
	POWER_RAM_POWER_S0POWER_Off = 0x0
	// On
	POWER_RAM_POWER_S0POWER_On = 0x1
	// Position of S1POWER field.
	POWER_RAM_POWER_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	POWER_RAM_POWER_S1POWER_Msk = 0x2
	// Bit S1POWER.
	POWER_RAM_POWER_S1POWER = 0x2
	// Off
	POWER_RAM_POWER_S1POWER_Off = 0x0
	// On
	POWER_RAM_POWER_S1POWER_On = 0x1
	// Position of S0RETENTION field.
	POWER_RAM_POWER_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	POWER_RAM_POWER_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	POWER_RAM_POWER_S0RETENTION = 0x10000
	// Off
	POWER_RAM_POWER_S0RETENTION_Off = 0x0
	// On
	POWER_RAM_POWER_S0RETENTION_On = 0x1
	// Position of S1RETENTION field.
	POWER_RAM_POWER_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	POWER_RAM_POWER_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	POWER_RAM_POWER_S1RETENTION = 0x20000
	// Off
	POWER_RAM_POWER_S1RETENTION_Off = 0x0
	// On
	POWER_RAM_POWER_S1RETENTION_On = 0x1

	// RAM.POWERSET: Description cluster: RAMn power control set register
	// Position of S0POWER field.
	POWER_RAM_POWERSET_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	POWER_RAM_POWERSET_S0POWER_Msk = 0x1
	// Bit S0POWER.
	POWER_RAM_POWERSET_S0POWER = 0x1
	// On
	POWER_RAM_POWERSET_S0POWER_On = 0x1
	// Position of S1POWER field.
	POWER_RAM_POWERSET_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	POWER_RAM_POWERSET_S1POWER_Msk = 0x2
	// Bit S1POWER.
	POWER_RAM_POWERSET_S1POWER = 0x2
	// On
	POWER_RAM_POWERSET_S1POWER_On = 0x1
	// Position of S0RETENTION field.
	POWER_RAM_POWERSET_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	POWER_RAM_POWERSET_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	POWER_RAM_POWERSET_S0RETENTION = 0x10000
	// On
	POWER_RAM_POWERSET_S0RETENTION_On = 0x1
	// Position of S1RETENTION field.
	POWER_RAM_POWERSET_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	POWER_RAM_POWERSET_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	POWER_RAM_POWERSET_S1RETENTION = 0x20000
	// On
	POWER_RAM_POWERSET_S1RETENTION_On = 0x1

	// RAM.POWERCLR: Description cluster: RAMn power control clear register
	// Position of S0POWER field.
	POWER_RAM_POWERCLR_S0POWER_Pos = 0x0
	// Bit mask of S0POWER field.
	POWER_RAM_POWERCLR_S0POWER_Msk = 0x1
	// Bit S0POWER.
	POWER_RAM_POWERCLR_S0POWER = 0x1
	// Off
	POWER_RAM_POWERCLR_S0POWER_Off = 0x1
	// Position of S1POWER field.
	POWER_RAM_POWERCLR_S1POWER_Pos = 0x1
	// Bit mask of S1POWER field.
	POWER_RAM_POWERCLR_S1POWER_Msk = 0x2
	// Bit S1POWER.
	POWER_RAM_POWERCLR_S1POWER = 0x2
	// Off
	POWER_RAM_POWERCLR_S1POWER_Off = 0x1
	// Position of S0RETENTION field.
	POWER_RAM_POWERCLR_S0RETENTION_Pos = 0x10
	// Bit mask of S0RETENTION field.
	POWER_RAM_POWERCLR_S0RETENTION_Msk = 0x10000
	// Bit S0RETENTION.
	POWER_RAM_POWERCLR_S0RETENTION = 0x10000
	// Off
	POWER_RAM_POWERCLR_S0RETENTION_Off = 0x1
	// Position of S1RETENTION field.
	POWER_RAM_POWERCLR_S1RETENTION_Pos = 0x11
	// Bit mask of S1RETENTION field.
	POWER_RAM_POWERCLR_S1RETENTION_Msk = 0x20000
	// Bit S1RETENTION.
	POWER_RAM_POWERCLR_S1RETENTION = 0x20000
	// Off
	POWER_RAM_POWERCLR_S1RETENTION_Off = 0x1
)

// Constants for P0: GPIO Port 1
const (
	// OUT: Write GPIO port
	// Position of PIN0 field.
	GPIO_OUT_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUT_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUT_PIN0 = 0x1
	// Pin driver is low
	GPIO_OUT_PIN0_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN0_High = 0x1
	// Position of PIN1 field.
	GPIO_OUT_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUT_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUT_PIN1 = 0x2
	// Pin driver is low
	GPIO_OUT_PIN1_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN1_High = 0x1
	// Position of PIN2 field.
	GPIO_OUT_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUT_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUT_PIN2 = 0x4
	// Pin driver is low
	GPIO_OUT_PIN2_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN2_High = 0x1
	// Position of PIN3 field.
	GPIO_OUT_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUT_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUT_PIN3 = 0x8
	// Pin driver is low
	GPIO_OUT_PIN3_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN3_High = 0x1
	// Position of PIN4 field.
	GPIO_OUT_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUT_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUT_PIN4 = 0x10
	// Pin driver is low
	GPIO_OUT_PIN4_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN4_High = 0x1
	// Position of PIN5 field.
	GPIO_OUT_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUT_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUT_PIN5 = 0x20
	// Pin driver is low
	GPIO_OUT_PIN5_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN5_High = 0x1
	// Position of PIN6 field.
	GPIO_OUT_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUT_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUT_PIN6 = 0x40
	// Pin driver is low
	GPIO_OUT_PIN6_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN6_High = 0x1
	// Position of PIN7 field.
	GPIO_OUT_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUT_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUT_PIN7 = 0x80
	// Pin driver is low
	GPIO_OUT_PIN7_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN7_High = 0x1
	// Position of PIN8 field.
	GPIO_OUT_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUT_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUT_PIN8 = 0x100
	// Pin driver is low
	GPIO_OUT_PIN8_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN8_High = 0x1
	// Position of PIN9 field.
	GPIO_OUT_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUT_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUT_PIN9 = 0x200
	// Pin driver is low
	GPIO_OUT_PIN9_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN9_High = 0x1
	// Position of PIN10 field.
	GPIO_OUT_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUT_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUT_PIN10 = 0x400
	// Pin driver is low
	GPIO_OUT_PIN10_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN10_High = 0x1
	// Position of PIN11 field.
	GPIO_OUT_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUT_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUT_PIN11 = 0x800
	// Pin driver is low
	GPIO_OUT_PIN11_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN11_High = 0x1
	// Position of PIN12 field.
	GPIO_OUT_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUT_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUT_PIN12 = 0x1000
	// Pin driver is low
	GPIO_OUT_PIN12_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN12_High = 0x1
	// Position of PIN13 field.
	GPIO_OUT_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUT_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUT_PIN13 = 0x2000
	// Pin driver is low
	GPIO_OUT_PIN13_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN13_High = 0x1
	// Position of PIN14 field.
	GPIO_OUT_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUT_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUT_PIN14 = 0x4000
	// Pin driver is low
	GPIO_OUT_PIN14_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN14_High = 0x1
	// Position of PIN15 field.
	GPIO_OUT_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUT_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUT_PIN15 = 0x8000
	// Pin driver is low
	GPIO_OUT_PIN15_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN15_High = 0x1
	// Position of PIN16 field.
	GPIO_OUT_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUT_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUT_PIN16 = 0x10000
	// Pin driver is low
	GPIO_OUT_PIN16_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN16_High = 0x1
	// Position of PIN17 field.
	GPIO_OUT_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUT_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUT_PIN17 = 0x20000
	// Pin driver is low
	GPIO_OUT_PIN17_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN17_High = 0x1
	// Position of PIN18 field.
	GPIO_OUT_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUT_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUT_PIN18 = 0x40000
	// Pin driver is low
	GPIO_OUT_PIN18_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN18_High = 0x1
	// Position of PIN19 field.
	GPIO_OUT_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUT_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUT_PIN19 = 0x80000
	// Pin driver is low
	GPIO_OUT_PIN19_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN19_High = 0x1
	// Position of PIN20 field.
	GPIO_OUT_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUT_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUT_PIN20 = 0x100000
	// Pin driver is low
	GPIO_OUT_PIN20_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN20_High = 0x1
	// Position of PIN21 field.
	GPIO_OUT_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUT_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUT_PIN21 = 0x200000
	// Pin driver is low
	GPIO_OUT_PIN21_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN21_High = 0x1
	// Position of PIN22 field.
	GPIO_OUT_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUT_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUT_PIN22 = 0x400000
	// Pin driver is low
	GPIO_OUT_PIN22_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN22_High = 0x1
	// Position of PIN23 field.
	GPIO_OUT_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUT_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUT_PIN23 = 0x800000
	// Pin driver is low
	GPIO_OUT_PIN23_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN23_High = 0x1
	// Position of PIN24 field.
	GPIO_OUT_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUT_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUT_PIN24 = 0x1000000
	// Pin driver is low
	GPIO_OUT_PIN24_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN24_High = 0x1
	// Position of PIN25 field.
	GPIO_OUT_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUT_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUT_PIN25 = 0x2000000
	// Pin driver is low
	GPIO_OUT_PIN25_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN25_High = 0x1
	// Position of PIN26 field.
	GPIO_OUT_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUT_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUT_PIN26 = 0x4000000
	// Pin driver is low
	GPIO_OUT_PIN26_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN26_High = 0x1
	// Position of PIN27 field.
	GPIO_OUT_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUT_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUT_PIN27 = 0x8000000
	// Pin driver is low
	GPIO_OUT_PIN27_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN27_High = 0x1
	// Position of PIN28 field.
	GPIO_OUT_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUT_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUT_PIN28 = 0x10000000
	// Pin driver is low
	GPIO_OUT_PIN28_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN28_High = 0x1
	// Position of PIN29 field.
	GPIO_OUT_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUT_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUT_PIN29 = 0x20000000
	// Pin driver is low
	GPIO_OUT_PIN29_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN29_High = 0x1
	// Position of PIN30 field.
	GPIO_OUT_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUT_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUT_PIN30 = 0x40000000
	// Pin driver is low
	GPIO_OUT_PIN30_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN30_High = 0x1
	// Position of PIN31 field.
	GPIO_OUT_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUT_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUT_PIN31 = 0x80000000
	// Pin driver is low
	GPIO_OUT_PIN31_Low = 0x0
	// Pin driver is high
	GPIO_OUT_PIN31_High = 0x1

	// OUTSET: Set individual bits in GPIO port
	// Position of PIN0 field.
	GPIO_OUTSET_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUTSET_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUTSET_PIN0 = 0x1
	// Read: pin driver is low
	GPIO_OUTSET_PIN0_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN0_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN0_Set = 0x1
	// Position of PIN1 field.
	GPIO_OUTSET_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUTSET_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUTSET_PIN1 = 0x2
	// Read: pin driver is low
	GPIO_OUTSET_PIN1_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN1_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN1_Set = 0x1
	// Position of PIN2 field.
	GPIO_OUTSET_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUTSET_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUTSET_PIN2 = 0x4
	// Read: pin driver is low
	GPIO_OUTSET_PIN2_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN2_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN2_Set = 0x1
	// Position of PIN3 field.
	GPIO_OUTSET_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUTSET_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUTSET_PIN3 = 0x8
	// Read: pin driver is low
	GPIO_OUTSET_PIN3_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN3_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN3_Set = 0x1
	// Position of PIN4 field.
	GPIO_OUTSET_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUTSET_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUTSET_PIN4 = 0x10
	// Read: pin driver is low
	GPIO_OUTSET_PIN4_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN4_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN4_Set = 0x1
	// Position of PIN5 field.
	GPIO_OUTSET_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUTSET_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUTSET_PIN5 = 0x20
	// Read: pin driver is low
	GPIO_OUTSET_PIN5_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN5_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN5_Set = 0x1
	// Position of PIN6 field.
	GPIO_OUTSET_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUTSET_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUTSET_PIN6 = 0x40
	// Read: pin driver is low
	GPIO_OUTSET_PIN6_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN6_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN6_Set = 0x1
	// Position of PIN7 field.
	GPIO_OUTSET_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUTSET_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUTSET_PIN7 = 0x80
	// Read: pin driver is low
	GPIO_OUTSET_PIN7_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN7_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN7_Set = 0x1
	// Position of PIN8 field.
	GPIO_OUTSET_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUTSET_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUTSET_PIN8 = 0x100
	// Read: pin driver is low
	GPIO_OUTSET_PIN8_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN8_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN8_Set = 0x1
	// Position of PIN9 field.
	GPIO_OUTSET_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUTSET_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUTSET_PIN9 = 0x200
	// Read: pin driver is low
	GPIO_OUTSET_PIN9_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN9_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN9_Set = 0x1
	// Position of PIN10 field.
	GPIO_OUTSET_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUTSET_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUTSET_PIN10 = 0x400
	// Read: pin driver is low
	GPIO_OUTSET_PIN10_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN10_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN10_Set = 0x1
	// Position of PIN11 field.
	GPIO_OUTSET_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUTSET_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUTSET_PIN11 = 0x800
	// Read: pin driver is low
	GPIO_OUTSET_PIN11_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN11_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN11_Set = 0x1
	// Position of PIN12 field.
	GPIO_OUTSET_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUTSET_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUTSET_PIN12 = 0x1000
	// Read: pin driver is low
	GPIO_OUTSET_PIN12_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN12_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN12_Set = 0x1
	// Position of PIN13 field.
	GPIO_OUTSET_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUTSET_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUTSET_PIN13 = 0x2000
	// Read: pin driver is low
	GPIO_OUTSET_PIN13_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN13_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN13_Set = 0x1
	// Position of PIN14 field.
	GPIO_OUTSET_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUTSET_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUTSET_PIN14 = 0x4000
	// Read: pin driver is low
	GPIO_OUTSET_PIN14_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN14_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN14_Set = 0x1
	// Position of PIN15 field.
	GPIO_OUTSET_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUTSET_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUTSET_PIN15 = 0x8000
	// Read: pin driver is low
	GPIO_OUTSET_PIN15_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN15_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN15_Set = 0x1
	// Position of PIN16 field.
	GPIO_OUTSET_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUTSET_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUTSET_PIN16 = 0x10000
	// Read: pin driver is low
	GPIO_OUTSET_PIN16_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN16_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN16_Set = 0x1
	// Position of PIN17 field.
	GPIO_OUTSET_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUTSET_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUTSET_PIN17 = 0x20000
	// Read: pin driver is low
	GPIO_OUTSET_PIN17_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN17_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN17_Set = 0x1
	// Position of PIN18 field.
	GPIO_OUTSET_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUTSET_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUTSET_PIN18 = 0x40000
	// Read: pin driver is low
	GPIO_OUTSET_PIN18_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN18_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN18_Set = 0x1
	// Position of PIN19 field.
	GPIO_OUTSET_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUTSET_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUTSET_PIN19 = 0x80000
	// Read: pin driver is low
	GPIO_OUTSET_PIN19_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN19_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN19_Set = 0x1
	// Position of PIN20 field.
	GPIO_OUTSET_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUTSET_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUTSET_PIN20 = 0x100000
	// Read: pin driver is low
	GPIO_OUTSET_PIN20_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN20_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN20_Set = 0x1
	// Position of PIN21 field.
	GPIO_OUTSET_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUTSET_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUTSET_PIN21 = 0x200000
	// Read: pin driver is low
	GPIO_OUTSET_PIN21_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN21_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN21_Set = 0x1
	// Position of PIN22 field.
	GPIO_OUTSET_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUTSET_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUTSET_PIN22 = 0x400000
	// Read: pin driver is low
	GPIO_OUTSET_PIN22_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN22_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN22_Set = 0x1
	// Position of PIN23 field.
	GPIO_OUTSET_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUTSET_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUTSET_PIN23 = 0x800000
	// Read: pin driver is low
	GPIO_OUTSET_PIN23_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN23_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN23_Set = 0x1
	// Position of PIN24 field.
	GPIO_OUTSET_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUTSET_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUTSET_PIN24 = 0x1000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN24_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN24_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN24_Set = 0x1
	// Position of PIN25 field.
	GPIO_OUTSET_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUTSET_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUTSET_PIN25 = 0x2000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN25_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN25_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN25_Set = 0x1
	// Position of PIN26 field.
	GPIO_OUTSET_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUTSET_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUTSET_PIN26 = 0x4000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN26_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN26_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN26_Set = 0x1
	// Position of PIN27 field.
	GPIO_OUTSET_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUTSET_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUTSET_PIN27 = 0x8000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN27_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN27_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN27_Set = 0x1
	// Position of PIN28 field.
	GPIO_OUTSET_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUTSET_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUTSET_PIN28 = 0x10000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN28_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN28_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN28_Set = 0x1
	// Position of PIN29 field.
	GPIO_OUTSET_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUTSET_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUTSET_PIN29 = 0x20000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN29_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN29_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN29_Set = 0x1
	// Position of PIN30 field.
	GPIO_OUTSET_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUTSET_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUTSET_PIN30 = 0x40000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN30_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN30_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN30_Set = 0x1
	// Position of PIN31 field.
	GPIO_OUTSET_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUTSET_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUTSET_PIN31 = 0x80000000
	// Read: pin driver is low
	GPIO_OUTSET_PIN31_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTSET_PIN31_High = 0x1
	// Write: writing a '1' sets the pin high; writing a '0' has no effect
	GPIO_OUTSET_PIN31_Set = 0x1

	// OUTCLR: Clear individual bits in GPIO port
	// Position of PIN0 field.
	GPIO_OUTCLR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_OUTCLR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_OUTCLR_PIN0 = 0x1
	// Read: pin driver is low
	GPIO_OUTCLR_PIN0_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN0_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN0_Clear = 0x1
	// Position of PIN1 field.
	GPIO_OUTCLR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_OUTCLR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_OUTCLR_PIN1 = 0x2
	// Read: pin driver is low
	GPIO_OUTCLR_PIN1_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN1_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN1_Clear = 0x1
	// Position of PIN2 field.
	GPIO_OUTCLR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_OUTCLR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_OUTCLR_PIN2 = 0x4
	// Read: pin driver is low
	GPIO_OUTCLR_PIN2_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN2_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN2_Clear = 0x1
	// Position of PIN3 field.
	GPIO_OUTCLR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_OUTCLR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_OUTCLR_PIN3 = 0x8
	// Read: pin driver is low
	GPIO_OUTCLR_PIN3_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN3_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN3_Clear = 0x1
	// Position of PIN4 field.
	GPIO_OUTCLR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_OUTCLR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_OUTCLR_PIN4 = 0x10
	// Read: pin driver is low
	GPIO_OUTCLR_PIN4_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN4_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN4_Clear = 0x1
	// Position of PIN5 field.
	GPIO_OUTCLR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_OUTCLR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_OUTCLR_PIN5 = 0x20
	// Read: pin driver is low
	GPIO_OUTCLR_PIN5_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN5_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN5_Clear = 0x1
	// Position of PIN6 field.
	GPIO_OUTCLR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_OUTCLR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_OUTCLR_PIN6 = 0x40
	// Read: pin driver is low
	GPIO_OUTCLR_PIN6_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN6_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN6_Clear = 0x1
	// Position of PIN7 field.
	GPIO_OUTCLR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_OUTCLR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_OUTCLR_PIN7 = 0x80
	// Read: pin driver is low
	GPIO_OUTCLR_PIN7_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN7_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN7_Clear = 0x1
	// Position of PIN8 field.
	GPIO_OUTCLR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_OUTCLR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_OUTCLR_PIN8 = 0x100
	// Read: pin driver is low
	GPIO_OUTCLR_PIN8_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN8_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN8_Clear = 0x1
	// Position of PIN9 field.
	GPIO_OUTCLR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_OUTCLR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_OUTCLR_PIN9 = 0x200
	// Read: pin driver is low
	GPIO_OUTCLR_PIN9_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN9_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN9_Clear = 0x1
	// Position of PIN10 field.
	GPIO_OUTCLR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_OUTCLR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_OUTCLR_PIN10 = 0x400
	// Read: pin driver is low
	GPIO_OUTCLR_PIN10_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN10_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN10_Clear = 0x1
	// Position of PIN11 field.
	GPIO_OUTCLR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_OUTCLR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_OUTCLR_PIN11 = 0x800
	// Read: pin driver is low
	GPIO_OUTCLR_PIN11_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN11_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN11_Clear = 0x1
	// Position of PIN12 field.
	GPIO_OUTCLR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_OUTCLR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_OUTCLR_PIN12 = 0x1000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN12_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN12_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN12_Clear = 0x1
	// Position of PIN13 field.
	GPIO_OUTCLR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_OUTCLR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_OUTCLR_PIN13 = 0x2000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN13_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN13_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN13_Clear = 0x1
	// Position of PIN14 field.
	GPIO_OUTCLR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_OUTCLR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_OUTCLR_PIN14 = 0x4000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN14_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN14_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN14_Clear = 0x1
	// Position of PIN15 field.
	GPIO_OUTCLR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_OUTCLR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_OUTCLR_PIN15 = 0x8000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN15_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN15_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN15_Clear = 0x1
	// Position of PIN16 field.
	GPIO_OUTCLR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_OUTCLR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_OUTCLR_PIN16 = 0x10000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN16_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN16_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN16_Clear = 0x1
	// Position of PIN17 field.
	GPIO_OUTCLR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_OUTCLR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_OUTCLR_PIN17 = 0x20000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN17_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN17_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN17_Clear = 0x1
	// Position of PIN18 field.
	GPIO_OUTCLR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_OUTCLR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_OUTCLR_PIN18 = 0x40000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN18_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN18_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN18_Clear = 0x1
	// Position of PIN19 field.
	GPIO_OUTCLR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_OUTCLR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_OUTCLR_PIN19 = 0x80000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN19_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN19_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN19_Clear = 0x1
	// Position of PIN20 field.
	GPIO_OUTCLR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_OUTCLR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_OUTCLR_PIN20 = 0x100000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN20_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN20_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN20_Clear = 0x1
	// Position of PIN21 field.
	GPIO_OUTCLR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_OUTCLR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_OUTCLR_PIN21 = 0x200000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN21_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN21_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN21_Clear = 0x1
	// Position of PIN22 field.
	GPIO_OUTCLR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_OUTCLR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_OUTCLR_PIN22 = 0x400000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN22_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN22_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN22_Clear = 0x1
	// Position of PIN23 field.
	GPIO_OUTCLR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_OUTCLR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_OUTCLR_PIN23 = 0x800000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN23_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN23_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN23_Clear = 0x1
	// Position of PIN24 field.
	GPIO_OUTCLR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_OUTCLR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_OUTCLR_PIN24 = 0x1000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN24_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN24_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN24_Clear = 0x1
	// Position of PIN25 field.
	GPIO_OUTCLR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_OUTCLR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_OUTCLR_PIN25 = 0x2000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN25_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN25_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN25_Clear = 0x1
	// Position of PIN26 field.
	GPIO_OUTCLR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_OUTCLR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_OUTCLR_PIN26 = 0x4000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN26_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN26_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN26_Clear = 0x1
	// Position of PIN27 field.
	GPIO_OUTCLR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_OUTCLR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_OUTCLR_PIN27 = 0x8000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN27_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN27_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN27_Clear = 0x1
	// Position of PIN28 field.
	GPIO_OUTCLR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_OUTCLR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_OUTCLR_PIN28 = 0x10000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN28_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN28_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN28_Clear = 0x1
	// Position of PIN29 field.
	GPIO_OUTCLR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_OUTCLR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_OUTCLR_PIN29 = 0x20000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN29_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN29_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN29_Clear = 0x1
	// Position of PIN30 field.
	GPIO_OUTCLR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_OUTCLR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_OUTCLR_PIN30 = 0x40000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN30_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN30_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN30_Clear = 0x1
	// Position of PIN31 field.
	GPIO_OUTCLR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_OUTCLR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_OUTCLR_PIN31 = 0x80000000
	// Read: pin driver is low
	GPIO_OUTCLR_PIN31_Low = 0x0
	// Read: pin driver is high
	GPIO_OUTCLR_PIN31_High = 0x1
	// Write: writing a '1' sets the pin low; writing a '0' has no effect
	GPIO_OUTCLR_PIN31_Clear = 0x1

	// IN: Read GPIO port
	// Position of PIN0 field.
	GPIO_IN_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_IN_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_IN_PIN0 = 0x1
	// Pin input is low
	GPIO_IN_PIN0_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN0_High = 0x1
	// Position of PIN1 field.
	GPIO_IN_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_IN_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_IN_PIN1 = 0x2
	// Pin input is low
	GPIO_IN_PIN1_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN1_High = 0x1
	// Position of PIN2 field.
	GPIO_IN_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_IN_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_IN_PIN2 = 0x4
	// Pin input is low
	GPIO_IN_PIN2_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN2_High = 0x1
	// Position of PIN3 field.
	GPIO_IN_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_IN_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_IN_PIN3 = 0x8
	// Pin input is low
	GPIO_IN_PIN3_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN3_High = 0x1
	// Position of PIN4 field.
	GPIO_IN_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_IN_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_IN_PIN4 = 0x10
	// Pin input is low
	GPIO_IN_PIN4_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN4_High = 0x1
	// Position of PIN5 field.
	GPIO_IN_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_IN_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_IN_PIN5 = 0x20
	// Pin input is low
	GPIO_IN_PIN5_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN5_High = 0x1
	// Position of PIN6 field.
	GPIO_IN_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_IN_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_IN_PIN6 = 0x40
	// Pin input is low
	GPIO_IN_PIN6_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN6_High = 0x1
	// Position of PIN7 field.
	GPIO_IN_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_IN_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_IN_PIN7 = 0x80
	// Pin input is low
	GPIO_IN_PIN7_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN7_High = 0x1
	// Position of PIN8 field.
	GPIO_IN_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_IN_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_IN_PIN8 = 0x100
	// Pin input is low
	GPIO_IN_PIN8_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN8_High = 0x1
	// Position of PIN9 field.
	GPIO_IN_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_IN_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_IN_PIN9 = 0x200
	// Pin input is low
	GPIO_IN_PIN9_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN9_High = 0x1
	// Position of PIN10 field.
	GPIO_IN_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_IN_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_IN_PIN10 = 0x400
	// Pin input is low
	GPIO_IN_PIN10_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN10_High = 0x1
	// Position of PIN11 field.
	GPIO_IN_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_IN_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_IN_PIN11 = 0x800
	// Pin input is low
	GPIO_IN_PIN11_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN11_High = 0x1
	// Position of PIN12 field.
	GPIO_IN_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_IN_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_IN_PIN12 = 0x1000
	// Pin input is low
	GPIO_IN_PIN12_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN12_High = 0x1
	// Position of PIN13 field.
	GPIO_IN_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_IN_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_IN_PIN13 = 0x2000
	// Pin input is low
	GPIO_IN_PIN13_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN13_High = 0x1
	// Position of PIN14 field.
	GPIO_IN_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_IN_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_IN_PIN14 = 0x4000
	// Pin input is low
	GPIO_IN_PIN14_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN14_High = 0x1
	// Position of PIN15 field.
	GPIO_IN_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_IN_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_IN_PIN15 = 0x8000
	// Pin input is low
	GPIO_IN_PIN15_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN15_High = 0x1
	// Position of PIN16 field.
	GPIO_IN_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_IN_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_IN_PIN16 = 0x10000
	// Pin input is low
	GPIO_IN_PIN16_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN16_High = 0x1
	// Position of PIN17 field.
	GPIO_IN_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_IN_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_IN_PIN17 = 0x20000
	// Pin input is low
	GPIO_IN_PIN17_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN17_High = 0x1
	// Position of PIN18 field.
	GPIO_IN_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_IN_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_IN_PIN18 = 0x40000
	// Pin input is low
	GPIO_IN_PIN18_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN18_High = 0x1
	// Position of PIN19 field.
	GPIO_IN_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_IN_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_IN_PIN19 = 0x80000
	// Pin input is low
	GPIO_IN_PIN19_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN19_High = 0x1
	// Position of PIN20 field.
	GPIO_IN_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_IN_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_IN_PIN20 = 0x100000
	// Pin input is low
	GPIO_IN_PIN20_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN20_High = 0x1
	// Position of PIN21 field.
	GPIO_IN_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_IN_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_IN_PIN21 = 0x200000
	// Pin input is low
	GPIO_IN_PIN21_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN21_High = 0x1
	// Position of PIN22 field.
	GPIO_IN_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_IN_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_IN_PIN22 = 0x400000
	// Pin input is low
	GPIO_IN_PIN22_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN22_High = 0x1
	// Position of PIN23 field.
	GPIO_IN_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_IN_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_IN_PIN23 = 0x800000
	// Pin input is low
	GPIO_IN_PIN23_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN23_High = 0x1
	// Position of PIN24 field.
	GPIO_IN_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_IN_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_IN_PIN24 = 0x1000000
	// Pin input is low
	GPIO_IN_PIN24_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN24_High = 0x1
	// Position of PIN25 field.
	GPIO_IN_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_IN_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_IN_PIN25 = 0x2000000
	// Pin input is low
	GPIO_IN_PIN25_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN25_High = 0x1
	// Position of PIN26 field.
	GPIO_IN_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_IN_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_IN_PIN26 = 0x4000000
	// Pin input is low
	GPIO_IN_PIN26_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN26_High = 0x1
	// Position of PIN27 field.
	GPIO_IN_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_IN_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_IN_PIN27 = 0x8000000
	// Pin input is low
	GPIO_IN_PIN27_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN27_High = 0x1
	// Position of PIN28 field.
	GPIO_IN_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_IN_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_IN_PIN28 = 0x10000000
	// Pin input is low
	GPIO_IN_PIN28_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN28_High = 0x1
	// Position of PIN29 field.
	GPIO_IN_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_IN_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_IN_PIN29 = 0x20000000
	// Pin input is low
	GPIO_IN_PIN29_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN29_High = 0x1
	// Position of PIN30 field.
	GPIO_IN_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_IN_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_IN_PIN30 = 0x40000000
	// Pin input is low
	GPIO_IN_PIN30_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN30_High = 0x1
	// Position of PIN31 field.
	GPIO_IN_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_IN_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_IN_PIN31 = 0x80000000
	// Pin input is low
	GPIO_IN_PIN31_Low = 0x0
	// Pin input is high
	GPIO_IN_PIN31_High = 0x1

	// DIR: Direction of GPIO pins
	// Position of PIN0 field.
	GPIO_DIR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIR_PIN0 = 0x1
	// Pin set as input
	GPIO_DIR_PIN0_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN0_Output = 0x1
	// Position of PIN1 field.
	GPIO_DIR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIR_PIN1 = 0x2
	// Pin set as input
	GPIO_DIR_PIN1_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN1_Output = 0x1
	// Position of PIN2 field.
	GPIO_DIR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIR_PIN2 = 0x4
	// Pin set as input
	GPIO_DIR_PIN2_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN2_Output = 0x1
	// Position of PIN3 field.
	GPIO_DIR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIR_PIN3 = 0x8
	// Pin set as input
	GPIO_DIR_PIN3_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN3_Output = 0x1
	// Position of PIN4 field.
	GPIO_DIR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIR_PIN4 = 0x10
	// Pin set as input
	GPIO_DIR_PIN4_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN4_Output = 0x1
	// Position of PIN5 field.
	GPIO_DIR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIR_PIN5 = 0x20
	// Pin set as input
	GPIO_DIR_PIN5_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN5_Output = 0x1
	// Position of PIN6 field.
	GPIO_DIR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIR_PIN6 = 0x40
	// Pin set as input
	GPIO_DIR_PIN6_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN6_Output = 0x1
	// Position of PIN7 field.
	GPIO_DIR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIR_PIN7 = 0x80
	// Pin set as input
	GPIO_DIR_PIN7_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN7_Output = 0x1
	// Position of PIN8 field.
	GPIO_DIR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIR_PIN8 = 0x100
	// Pin set as input
	GPIO_DIR_PIN8_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN8_Output = 0x1
	// Position of PIN9 field.
	GPIO_DIR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIR_PIN9 = 0x200
	// Pin set as input
	GPIO_DIR_PIN9_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN9_Output = 0x1
	// Position of PIN10 field.
	GPIO_DIR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIR_PIN10 = 0x400
	// Pin set as input
	GPIO_DIR_PIN10_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN10_Output = 0x1
	// Position of PIN11 field.
	GPIO_DIR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIR_PIN11 = 0x800
	// Pin set as input
	GPIO_DIR_PIN11_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN11_Output = 0x1
	// Position of PIN12 field.
	GPIO_DIR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIR_PIN12 = 0x1000
	// Pin set as input
	GPIO_DIR_PIN12_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN12_Output = 0x1
	// Position of PIN13 field.
	GPIO_DIR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIR_PIN13 = 0x2000
	// Pin set as input
	GPIO_DIR_PIN13_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN13_Output = 0x1
	// Position of PIN14 field.
	GPIO_DIR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIR_PIN14 = 0x4000
	// Pin set as input
	GPIO_DIR_PIN14_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN14_Output = 0x1
	// Position of PIN15 field.
	GPIO_DIR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIR_PIN15 = 0x8000
	// Pin set as input
	GPIO_DIR_PIN15_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN15_Output = 0x1
	// Position of PIN16 field.
	GPIO_DIR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIR_PIN16 = 0x10000
	// Pin set as input
	GPIO_DIR_PIN16_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN16_Output = 0x1
	// Position of PIN17 field.
	GPIO_DIR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIR_PIN17 = 0x20000
	// Pin set as input
	GPIO_DIR_PIN17_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN17_Output = 0x1
	// Position of PIN18 field.
	GPIO_DIR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIR_PIN18 = 0x40000
	// Pin set as input
	GPIO_DIR_PIN18_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN18_Output = 0x1
	// Position of PIN19 field.
	GPIO_DIR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIR_PIN19 = 0x80000
	// Pin set as input
	GPIO_DIR_PIN19_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN19_Output = 0x1
	// Position of PIN20 field.
	GPIO_DIR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIR_PIN20 = 0x100000
	// Pin set as input
	GPIO_DIR_PIN20_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN20_Output = 0x1
	// Position of PIN21 field.
	GPIO_DIR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIR_PIN21 = 0x200000
	// Pin set as input
	GPIO_DIR_PIN21_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN21_Output = 0x1
	// Position of PIN22 field.
	GPIO_DIR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIR_PIN22 = 0x400000
	// Pin set as input
	GPIO_DIR_PIN22_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN22_Output = 0x1
	// Position of PIN23 field.
	GPIO_DIR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIR_PIN23 = 0x800000
	// Pin set as input
	GPIO_DIR_PIN23_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN23_Output = 0x1
	// Position of PIN24 field.
	GPIO_DIR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIR_PIN24 = 0x1000000
	// Pin set as input
	GPIO_DIR_PIN24_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN24_Output = 0x1
	// Position of PIN25 field.
	GPIO_DIR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIR_PIN25 = 0x2000000
	// Pin set as input
	GPIO_DIR_PIN25_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN25_Output = 0x1
	// Position of PIN26 field.
	GPIO_DIR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIR_PIN26 = 0x4000000
	// Pin set as input
	GPIO_DIR_PIN26_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN26_Output = 0x1
	// Position of PIN27 field.
	GPIO_DIR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIR_PIN27 = 0x8000000
	// Pin set as input
	GPIO_DIR_PIN27_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN27_Output = 0x1
	// Position of PIN28 field.
	GPIO_DIR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIR_PIN28 = 0x10000000
	// Pin set as input
	GPIO_DIR_PIN28_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN28_Output = 0x1
	// Position of PIN29 field.
	GPIO_DIR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIR_PIN29 = 0x20000000
	// Pin set as input
	GPIO_DIR_PIN29_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN29_Output = 0x1
	// Position of PIN30 field.
	GPIO_DIR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIR_PIN30 = 0x40000000
	// Pin set as input
	GPIO_DIR_PIN30_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN30_Output = 0x1
	// Position of PIN31 field.
	GPIO_DIR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIR_PIN31 = 0x80000000
	// Pin set as input
	GPIO_DIR_PIN31_Input = 0x0
	// Pin set as output
	GPIO_DIR_PIN31_Output = 0x1

	// DIRSET: DIR set register
	// Position of PIN0 field.
	GPIO_DIRSET_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIRSET_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIRSET_PIN0 = 0x1
	// Read: pin set as input
	GPIO_DIRSET_PIN0_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN0_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN0_Set = 0x1
	// Position of PIN1 field.
	GPIO_DIRSET_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIRSET_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIRSET_PIN1 = 0x2
	// Read: pin set as input
	GPIO_DIRSET_PIN1_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN1_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN1_Set = 0x1
	// Position of PIN2 field.
	GPIO_DIRSET_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIRSET_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIRSET_PIN2 = 0x4
	// Read: pin set as input
	GPIO_DIRSET_PIN2_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN2_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN2_Set = 0x1
	// Position of PIN3 field.
	GPIO_DIRSET_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIRSET_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIRSET_PIN3 = 0x8
	// Read: pin set as input
	GPIO_DIRSET_PIN3_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN3_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN3_Set = 0x1
	// Position of PIN4 field.
	GPIO_DIRSET_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIRSET_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIRSET_PIN4 = 0x10
	// Read: pin set as input
	GPIO_DIRSET_PIN4_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN4_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN4_Set = 0x1
	// Position of PIN5 field.
	GPIO_DIRSET_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIRSET_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIRSET_PIN5 = 0x20
	// Read: pin set as input
	GPIO_DIRSET_PIN5_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN5_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN5_Set = 0x1
	// Position of PIN6 field.
	GPIO_DIRSET_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIRSET_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIRSET_PIN6 = 0x40
	// Read: pin set as input
	GPIO_DIRSET_PIN6_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN6_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN6_Set = 0x1
	// Position of PIN7 field.
	GPIO_DIRSET_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIRSET_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIRSET_PIN7 = 0x80
	// Read: pin set as input
	GPIO_DIRSET_PIN7_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN7_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN7_Set = 0x1
	// Position of PIN8 field.
	GPIO_DIRSET_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIRSET_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIRSET_PIN8 = 0x100
	// Read: pin set as input
	GPIO_DIRSET_PIN8_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN8_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN8_Set = 0x1
	// Position of PIN9 field.
	GPIO_DIRSET_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIRSET_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIRSET_PIN9 = 0x200
	// Read: pin set as input
	GPIO_DIRSET_PIN9_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN9_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN9_Set = 0x1
	// Position of PIN10 field.
	GPIO_DIRSET_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIRSET_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIRSET_PIN10 = 0x400
	// Read: pin set as input
	GPIO_DIRSET_PIN10_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN10_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN10_Set = 0x1
	// Position of PIN11 field.
	GPIO_DIRSET_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIRSET_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIRSET_PIN11 = 0x800
	// Read: pin set as input
	GPIO_DIRSET_PIN11_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN11_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN11_Set = 0x1
	// Position of PIN12 field.
	GPIO_DIRSET_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIRSET_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIRSET_PIN12 = 0x1000
	// Read: pin set as input
	GPIO_DIRSET_PIN12_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN12_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN12_Set = 0x1
	// Position of PIN13 field.
	GPIO_DIRSET_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIRSET_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIRSET_PIN13 = 0x2000
	// Read: pin set as input
	GPIO_DIRSET_PIN13_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN13_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN13_Set = 0x1
	// Position of PIN14 field.
	GPIO_DIRSET_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIRSET_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIRSET_PIN14 = 0x4000
	// Read: pin set as input
	GPIO_DIRSET_PIN14_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN14_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN14_Set = 0x1
	// Position of PIN15 field.
	GPIO_DIRSET_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIRSET_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIRSET_PIN15 = 0x8000
	// Read: pin set as input
	GPIO_DIRSET_PIN15_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN15_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN15_Set = 0x1
	// Position of PIN16 field.
	GPIO_DIRSET_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIRSET_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIRSET_PIN16 = 0x10000
	// Read: pin set as input
	GPIO_DIRSET_PIN16_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN16_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN16_Set = 0x1
	// Position of PIN17 field.
	GPIO_DIRSET_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIRSET_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIRSET_PIN17 = 0x20000
	// Read: pin set as input
	GPIO_DIRSET_PIN17_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN17_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN17_Set = 0x1
	// Position of PIN18 field.
	GPIO_DIRSET_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIRSET_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIRSET_PIN18 = 0x40000
	// Read: pin set as input
	GPIO_DIRSET_PIN18_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN18_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN18_Set = 0x1
	// Position of PIN19 field.
	GPIO_DIRSET_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIRSET_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIRSET_PIN19 = 0x80000
	// Read: pin set as input
	GPIO_DIRSET_PIN19_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN19_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN19_Set = 0x1
	// Position of PIN20 field.
	GPIO_DIRSET_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIRSET_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIRSET_PIN20 = 0x100000
	// Read: pin set as input
	GPIO_DIRSET_PIN20_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN20_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN20_Set = 0x1
	// Position of PIN21 field.
	GPIO_DIRSET_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIRSET_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIRSET_PIN21 = 0x200000
	// Read: pin set as input
	GPIO_DIRSET_PIN21_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN21_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN21_Set = 0x1
	// Position of PIN22 field.
	GPIO_DIRSET_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIRSET_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIRSET_PIN22 = 0x400000
	// Read: pin set as input
	GPIO_DIRSET_PIN22_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN22_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN22_Set = 0x1
	// Position of PIN23 field.
	GPIO_DIRSET_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIRSET_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIRSET_PIN23 = 0x800000
	// Read: pin set as input
	GPIO_DIRSET_PIN23_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN23_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN23_Set = 0x1
	// Position of PIN24 field.
	GPIO_DIRSET_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIRSET_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIRSET_PIN24 = 0x1000000
	// Read: pin set as input
	GPIO_DIRSET_PIN24_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN24_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN24_Set = 0x1
	// Position of PIN25 field.
	GPIO_DIRSET_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIRSET_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIRSET_PIN25 = 0x2000000
	// Read: pin set as input
	GPIO_DIRSET_PIN25_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN25_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN25_Set = 0x1
	// Position of PIN26 field.
	GPIO_DIRSET_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIRSET_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIRSET_PIN26 = 0x4000000
	// Read: pin set as input
	GPIO_DIRSET_PIN26_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN26_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN26_Set = 0x1
	// Position of PIN27 field.
	GPIO_DIRSET_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIRSET_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIRSET_PIN27 = 0x8000000
	// Read: pin set as input
	GPIO_DIRSET_PIN27_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN27_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN27_Set = 0x1
	// Position of PIN28 field.
	GPIO_DIRSET_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIRSET_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIRSET_PIN28 = 0x10000000
	// Read: pin set as input
	GPIO_DIRSET_PIN28_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN28_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN28_Set = 0x1
	// Position of PIN29 field.
	GPIO_DIRSET_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIRSET_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIRSET_PIN29 = 0x20000000
	// Read: pin set as input
	GPIO_DIRSET_PIN29_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN29_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN29_Set = 0x1
	// Position of PIN30 field.
	GPIO_DIRSET_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIRSET_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIRSET_PIN30 = 0x40000000
	// Read: pin set as input
	GPIO_DIRSET_PIN30_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN30_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN30_Set = 0x1
	// Position of PIN31 field.
	GPIO_DIRSET_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIRSET_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIRSET_PIN31 = 0x80000000
	// Read: pin set as input
	GPIO_DIRSET_PIN31_Input = 0x0
	// Read: pin set as output
	GPIO_DIRSET_PIN31_Output = 0x1
	// Write: writing a '1' sets pin to output; writing a '0' has no effect
	GPIO_DIRSET_PIN31_Set = 0x1

	// DIRCLR: DIR clear register
	// Position of PIN0 field.
	GPIO_DIRCLR_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_DIRCLR_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_DIRCLR_PIN0 = 0x1
	// Read: pin set as input
	GPIO_DIRCLR_PIN0_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN0_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN0_Clear = 0x1
	// Position of PIN1 field.
	GPIO_DIRCLR_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_DIRCLR_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_DIRCLR_PIN1 = 0x2
	// Read: pin set as input
	GPIO_DIRCLR_PIN1_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN1_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN1_Clear = 0x1
	// Position of PIN2 field.
	GPIO_DIRCLR_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_DIRCLR_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_DIRCLR_PIN2 = 0x4
	// Read: pin set as input
	GPIO_DIRCLR_PIN2_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN2_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN2_Clear = 0x1
	// Position of PIN3 field.
	GPIO_DIRCLR_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_DIRCLR_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_DIRCLR_PIN3 = 0x8
	// Read: pin set as input
	GPIO_DIRCLR_PIN3_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN3_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN3_Clear = 0x1
	// Position of PIN4 field.
	GPIO_DIRCLR_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_DIRCLR_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_DIRCLR_PIN4 = 0x10
	// Read: pin set as input
	GPIO_DIRCLR_PIN4_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN4_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN4_Clear = 0x1
	// Position of PIN5 field.
	GPIO_DIRCLR_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_DIRCLR_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_DIRCLR_PIN5 = 0x20
	// Read: pin set as input
	GPIO_DIRCLR_PIN5_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN5_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN5_Clear = 0x1
	// Position of PIN6 field.
	GPIO_DIRCLR_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_DIRCLR_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_DIRCLR_PIN6 = 0x40
	// Read: pin set as input
	GPIO_DIRCLR_PIN6_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN6_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN6_Clear = 0x1
	// Position of PIN7 field.
	GPIO_DIRCLR_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_DIRCLR_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_DIRCLR_PIN7 = 0x80
	// Read: pin set as input
	GPIO_DIRCLR_PIN7_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN7_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN7_Clear = 0x1
	// Position of PIN8 field.
	GPIO_DIRCLR_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_DIRCLR_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_DIRCLR_PIN8 = 0x100
	// Read: pin set as input
	GPIO_DIRCLR_PIN8_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN8_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN8_Clear = 0x1
	// Position of PIN9 field.
	GPIO_DIRCLR_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_DIRCLR_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_DIRCLR_PIN9 = 0x200
	// Read: pin set as input
	GPIO_DIRCLR_PIN9_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN9_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN9_Clear = 0x1
	// Position of PIN10 field.
	GPIO_DIRCLR_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_DIRCLR_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_DIRCLR_PIN10 = 0x400
	// Read: pin set as input
	GPIO_DIRCLR_PIN10_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN10_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN10_Clear = 0x1
	// Position of PIN11 field.
	GPIO_DIRCLR_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_DIRCLR_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_DIRCLR_PIN11 = 0x800
	// Read: pin set as input
	GPIO_DIRCLR_PIN11_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN11_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN11_Clear = 0x1
	// Position of PIN12 field.
	GPIO_DIRCLR_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_DIRCLR_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_DIRCLR_PIN12 = 0x1000
	// Read: pin set as input
	GPIO_DIRCLR_PIN12_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN12_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN12_Clear = 0x1
	// Position of PIN13 field.
	GPIO_DIRCLR_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_DIRCLR_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_DIRCLR_PIN13 = 0x2000
	// Read: pin set as input
	GPIO_DIRCLR_PIN13_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN13_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN13_Clear = 0x1
	// Position of PIN14 field.
	GPIO_DIRCLR_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_DIRCLR_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_DIRCLR_PIN14 = 0x4000
	// Read: pin set as input
	GPIO_DIRCLR_PIN14_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN14_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN14_Clear = 0x1
	// Position of PIN15 field.
	GPIO_DIRCLR_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_DIRCLR_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_DIRCLR_PIN15 = 0x8000
	// Read: pin set as input
	GPIO_DIRCLR_PIN15_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN15_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN15_Clear = 0x1
	// Position of PIN16 field.
	GPIO_DIRCLR_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_DIRCLR_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_DIRCLR_PIN16 = 0x10000
	// Read: pin set as input
	GPIO_DIRCLR_PIN16_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN16_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN16_Clear = 0x1
	// Position of PIN17 field.
	GPIO_DIRCLR_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_DIRCLR_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_DIRCLR_PIN17 = 0x20000
	// Read: pin set as input
	GPIO_DIRCLR_PIN17_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN17_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN17_Clear = 0x1
	// Position of PIN18 field.
	GPIO_DIRCLR_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_DIRCLR_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_DIRCLR_PIN18 = 0x40000
	// Read: pin set as input
	GPIO_DIRCLR_PIN18_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN18_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN18_Clear = 0x1
	// Position of PIN19 field.
	GPIO_DIRCLR_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_DIRCLR_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_DIRCLR_PIN19 = 0x80000
	// Read: pin set as input
	GPIO_DIRCLR_PIN19_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN19_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN19_Clear = 0x1
	// Position of PIN20 field.
	GPIO_DIRCLR_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_DIRCLR_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_DIRCLR_PIN20 = 0x100000
	// Read: pin set as input
	GPIO_DIRCLR_PIN20_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN20_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN20_Clear = 0x1
	// Position of PIN21 field.
	GPIO_DIRCLR_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_DIRCLR_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_DIRCLR_PIN21 = 0x200000
	// Read: pin set as input
	GPIO_DIRCLR_PIN21_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN21_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN21_Clear = 0x1
	// Position of PIN22 field.
	GPIO_DIRCLR_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_DIRCLR_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_DIRCLR_PIN22 = 0x400000
	// Read: pin set as input
	GPIO_DIRCLR_PIN22_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN22_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN22_Clear = 0x1
	// Position of PIN23 field.
	GPIO_DIRCLR_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_DIRCLR_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_DIRCLR_PIN23 = 0x800000
	// Read: pin set as input
	GPIO_DIRCLR_PIN23_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN23_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN23_Clear = 0x1
	// Position of PIN24 field.
	GPIO_DIRCLR_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_DIRCLR_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_DIRCLR_PIN24 = 0x1000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN24_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN24_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN24_Clear = 0x1
	// Position of PIN25 field.
	GPIO_DIRCLR_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_DIRCLR_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_DIRCLR_PIN25 = 0x2000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN25_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN25_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN25_Clear = 0x1
	// Position of PIN26 field.
	GPIO_DIRCLR_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_DIRCLR_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_DIRCLR_PIN26 = 0x4000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN26_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN26_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN26_Clear = 0x1
	// Position of PIN27 field.
	GPIO_DIRCLR_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_DIRCLR_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_DIRCLR_PIN27 = 0x8000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN27_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN27_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN27_Clear = 0x1
	// Position of PIN28 field.
	GPIO_DIRCLR_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_DIRCLR_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_DIRCLR_PIN28 = 0x10000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN28_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN28_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN28_Clear = 0x1
	// Position of PIN29 field.
	GPIO_DIRCLR_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_DIRCLR_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_DIRCLR_PIN29 = 0x20000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN29_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN29_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN29_Clear = 0x1
	// Position of PIN30 field.
	GPIO_DIRCLR_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_DIRCLR_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_DIRCLR_PIN30 = 0x40000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN30_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN30_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN30_Clear = 0x1
	// Position of PIN31 field.
	GPIO_DIRCLR_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_DIRCLR_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_DIRCLR_PIN31 = 0x80000000
	// Read: pin set as input
	GPIO_DIRCLR_PIN31_Input = 0x0
	// Read: pin set as output
	GPIO_DIRCLR_PIN31_Output = 0x1
	// Write: writing a '1' sets pin to input; writing a '0' has no effect
	GPIO_DIRCLR_PIN31_Clear = 0x1

	// LATCH: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers
	// Position of PIN0 field.
	GPIO_LATCH_PIN0_Pos = 0x0
	// Bit mask of PIN0 field.
	GPIO_LATCH_PIN0_Msk = 0x1
	// Bit PIN0.
	GPIO_LATCH_PIN0 = 0x1
	// Criteria has not been met
	GPIO_LATCH_PIN0_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN0_Latched = 0x1
	// Position of PIN1 field.
	GPIO_LATCH_PIN1_Pos = 0x1
	// Bit mask of PIN1 field.
	GPIO_LATCH_PIN1_Msk = 0x2
	// Bit PIN1.
	GPIO_LATCH_PIN1 = 0x2
	// Criteria has not been met
	GPIO_LATCH_PIN1_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN1_Latched = 0x1
	// Position of PIN2 field.
	GPIO_LATCH_PIN2_Pos = 0x2
	// Bit mask of PIN2 field.
	GPIO_LATCH_PIN2_Msk = 0x4
	// Bit PIN2.
	GPIO_LATCH_PIN2 = 0x4
	// Criteria has not been met
	GPIO_LATCH_PIN2_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN2_Latched = 0x1
	// Position of PIN3 field.
	GPIO_LATCH_PIN3_Pos = 0x3
	// Bit mask of PIN3 field.
	GPIO_LATCH_PIN3_Msk = 0x8
	// Bit PIN3.
	GPIO_LATCH_PIN3 = 0x8
	// Criteria has not been met
	GPIO_LATCH_PIN3_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN3_Latched = 0x1
	// Position of PIN4 field.
	GPIO_LATCH_PIN4_Pos = 0x4
	// Bit mask of PIN4 field.
	GPIO_LATCH_PIN4_Msk = 0x10
	// Bit PIN4.
	GPIO_LATCH_PIN4 = 0x10
	// Criteria has not been met
	GPIO_LATCH_PIN4_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN4_Latched = 0x1
	// Position of PIN5 field.
	GPIO_LATCH_PIN5_Pos = 0x5
	// Bit mask of PIN5 field.
	GPIO_LATCH_PIN5_Msk = 0x20
	// Bit PIN5.
	GPIO_LATCH_PIN5 = 0x20
	// Criteria has not been met
	GPIO_LATCH_PIN5_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN5_Latched = 0x1
	// Position of PIN6 field.
	GPIO_LATCH_PIN6_Pos = 0x6
	// Bit mask of PIN6 field.
	GPIO_LATCH_PIN6_Msk = 0x40
	// Bit PIN6.
	GPIO_LATCH_PIN6 = 0x40
	// Criteria has not been met
	GPIO_LATCH_PIN6_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN6_Latched = 0x1
	// Position of PIN7 field.
	GPIO_LATCH_PIN7_Pos = 0x7
	// Bit mask of PIN7 field.
	GPIO_LATCH_PIN7_Msk = 0x80
	// Bit PIN7.
	GPIO_LATCH_PIN7 = 0x80
	// Criteria has not been met
	GPIO_LATCH_PIN7_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN7_Latched = 0x1
	// Position of PIN8 field.
	GPIO_LATCH_PIN8_Pos = 0x8
	// Bit mask of PIN8 field.
	GPIO_LATCH_PIN8_Msk = 0x100
	// Bit PIN8.
	GPIO_LATCH_PIN8 = 0x100
	// Criteria has not been met
	GPIO_LATCH_PIN8_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN8_Latched = 0x1
	// Position of PIN9 field.
	GPIO_LATCH_PIN9_Pos = 0x9
	// Bit mask of PIN9 field.
	GPIO_LATCH_PIN9_Msk = 0x200
	// Bit PIN9.
	GPIO_LATCH_PIN9 = 0x200
	// Criteria has not been met
	GPIO_LATCH_PIN9_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN9_Latched = 0x1
	// Position of PIN10 field.
	GPIO_LATCH_PIN10_Pos = 0xa
	// Bit mask of PIN10 field.
	GPIO_LATCH_PIN10_Msk = 0x400
	// Bit PIN10.
	GPIO_LATCH_PIN10 = 0x400
	// Criteria has not been met
	GPIO_LATCH_PIN10_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN10_Latched = 0x1
	// Position of PIN11 field.
	GPIO_LATCH_PIN11_Pos = 0xb
	// Bit mask of PIN11 field.
	GPIO_LATCH_PIN11_Msk = 0x800
	// Bit PIN11.
	GPIO_LATCH_PIN11 = 0x800
	// Criteria has not been met
	GPIO_LATCH_PIN11_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN11_Latched = 0x1
	// Position of PIN12 field.
	GPIO_LATCH_PIN12_Pos = 0xc
	// Bit mask of PIN12 field.
	GPIO_LATCH_PIN12_Msk = 0x1000
	// Bit PIN12.
	GPIO_LATCH_PIN12 = 0x1000
	// Criteria has not been met
	GPIO_LATCH_PIN12_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN12_Latched = 0x1
	// Position of PIN13 field.
	GPIO_LATCH_PIN13_Pos = 0xd
	// Bit mask of PIN13 field.
	GPIO_LATCH_PIN13_Msk = 0x2000
	// Bit PIN13.
	GPIO_LATCH_PIN13 = 0x2000
	// Criteria has not been met
	GPIO_LATCH_PIN13_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN13_Latched = 0x1
	// Position of PIN14 field.
	GPIO_LATCH_PIN14_Pos = 0xe
	// Bit mask of PIN14 field.
	GPIO_LATCH_PIN14_Msk = 0x4000
	// Bit PIN14.
	GPIO_LATCH_PIN14 = 0x4000
	// Criteria has not been met
	GPIO_LATCH_PIN14_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN14_Latched = 0x1
	// Position of PIN15 field.
	GPIO_LATCH_PIN15_Pos = 0xf
	// Bit mask of PIN15 field.
	GPIO_LATCH_PIN15_Msk = 0x8000
	// Bit PIN15.
	GPIO_LATCH_PIN15 = 0x8000
	// Criteria has not been met
	GPIO_LATCH_PIN15_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN15_Latched = 0x1
	// Position of PIN16 field.
	GPIO_LATCH_PIN16_Pos = 0x10
	// Bit mask of PIN16 field.
	GPIO_LATCH_PIN16_Msk = 0x10000
	// Bit PIN16.
	GPIO_LATCH_PIN16 = 0x10000
	// Criteria has not been met
	GPIO_LATCH_PIN16_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN16_Latched = 0x1
	// Position of PIN17 field.
	GPIO_LATCH_PIN17_Pos = 0x11
	// Bit mask of PIN17 field.
	GPIO_LATCH_PIN17_Msk = 0x20000
	// Bit PIN17.
	GPIO_LATCH_PIN17 = 0x20000
	// Criteria has not been met
	GPIO_LATCH_PIN17_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN17_Latched = 0x1
	// Position of PIN18 field.
	GPIO_LATCH_PIN18_Pos = 0x12
	// Bit mask of PIN18 field.
	GPIO_LATCH_PIN18_Msk = 0x40000
	// Bit PIN18.
	GPIO_LATCH_PIN18 = 0x40000
	// Criteria has not been met
	GPIO_LATCH_PIN18_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN18_Latched = 0x1
	// Position of PIN19 field.
	GPIO_LATCH_PIN19_Pos = 0x13
	// Bit mask of PIN19 field.
	GPIO_LATCH_PIN19_Msk = 0x80000
	// Bit PIN19.
	GPIO_LATCH_PIN19 = 0x80000
	// Criteria has not been met
	GPIO_LATCH_PIN19_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN19_Latched = 0x1
	// Position of PIN20 field.
	GPIO_LATCH_PIN20_Pos = 0x14
	// Bit mask of PIN20 field.
	GPIO_LATCH_PIN20_Msk = 0x100000
	// Bit PIN20.
	GPIO_LATCH_PIN20 = 0x100000
	// Criteria has not been met
	GPIO_LATCH_PIN20_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN20_Latched = 0x1
	// Position of PIN21 field.
	GPIO_LATCH_PIN21_Pos = 0x15
	// Bit mask of PIN21 field.
	GPIO_LATCH_PIN21_Msk = 0x200000
	// Bit PIN21.
	GPIO_LATCH_PIN21 = 0x200000
	// Criteria has not been met
	GPIO_LATCH_PIN21_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN21_Latched = 0x1
	// Position of PIN22 field.
	GPIO_LATCH_PIN22_Pos = 0x16
	// Bit mask of PIN22 field.
	GPIO_LATCH_PIN22_Msk = 0x400000
	// Bit PIN22.
	GPIO_LATCH_PIN22 = 0x400000
	// Criteria has not been met
	GPIO_LATCH_PIN22_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN22_Latched = 0x1
	// Position of PIN23 field.
	GPIO_LATCH_PIN23_Pos = 0x17
	// Bit mask of PIN23 field.
	GPIO_LATCH_PIN23_Msk = 0x800000
	// Bit PIN23.
	GPIO_LATCH_PIN23 = 0x800000
	// Criteria has not been met
	GPIO_LATCH_PIN23_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN23_Latched = 0x1
	// Position of PIN24 field.
	GPIO_LATCH_PIN24_Pos = 0x18
	// Bit mask of PIN24 field.
	GPIO_LATCH_PIN24_Msk = 0x1000000
	// Bit PIN24.
	GPIO_LATCH_PIN24 = 0x1000000
	// Criteria has not been met
	GPIO_LATCH_PIN24_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN24_Latched = 0x1
	// Position of PIN25 field.
	GPIO_LATCH_PIN25_Pos = 0x19
	// Bit mask of PIN25 field.
	GPIO_LATCH_PIN25_Msk = 0x2000000
	// Bit PIN25.
	GPIO_LATCH_PIN25 = 0x2000000
	// Criteria has not been met
	GPIO_LATCH_PIN25_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN25_Latched = 0x1
	// Position of PIN26 field.
	GPIO_LATCH_PIN26_Pos = 0x1a
	// Bit mask of PIN26 field.
	GPIO_LATCH_PIN26_Msk = 0x4000000
	// Bit PIN26.
	GPIO_LATCH_PIN26 = 0x4000000
	// Criteria has not been met
	GPIO_LATCH_PIN26_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN26_Latched = 0x1
	// Position of PIN27 field.
	GPIO_LATCH_PIN27_Pos = 0x1b
	// Bit mask of PIN27 field.
	GPIO_LATCH_PIN27_Msk = 0x8000000
	// Bit PIN27.
	GPIO_LATCH_PIN27 = 0x8000000
	// Criteria has not been met
	GPIO_LATCH_PIN27_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN27_Latched = 0x1
	// Position of PIN28 field.
	GPIO_LATCH_PIN28_Pos = 0x1c
	// Bit mask of PIN28 field.
	GPIO_LATCH_PIN28_Msk = 0x10000000
	// Bit PIN28.
	GPIO_LATCH_PIN28 = 0x10000000
	// Criteria has not been met
	GPIO_LATCH_PIN28_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN28_Latched = 0x1
	// Position of PIN29 field.
	GPIO_LATCH_PIN29_Pos = 0x1d
	// Bit mask of PIN29 field.
	GPIO_LATCH_PIN29_Msk = 0x20000000
	// Bit PIN29.
	GPIO_LATCH_PIN29 = 0x20000000
	// Criteria has not been met
	GPIO_LATCH_PIN29_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN29_Latched = 0x1
	// Position of PIN30 field.
	GPIO_LATCH_PIN30_Pos = 0x1e
	// Bit mask of PIN30 field.
	GPIO_LATCH_PIN30_Msk = 0x40000000
	// Bit PIN30.
	GPIO_LATCH_PIN30 = 0x40000000
	// Criteria has not been met
	GPIO_LATCH_PIN30_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN30_Latched = 0x1
	// Position of PIN31 field.
	GPIO_LATCH_PIN31_Pos = 0x1f
	// Bit mask of PIN31 field.
	GPIO_LATCH_PIN31_Msk = 0x80000000
	// Bit PIN31.
	GPIO_LATCH_PIN31 = 0x80000000
	// Criteria has not been met
	GPIO_LATCH_PIN31_NotLatched = 0x0
	// Criteria has been met
	GPIO_LATCH_PIN31_Latched = 0x1

	// DETECTMODE: Select between default DETECT signal behaviour and LDETECT mode
	// Position of DETECTMODE field.
	GPIO_DETECTMODE_DETECTMODE_Pos = 0x0
	// Bit mask of DETECTMODE field.
	GPIO_DETECTMODE_DETECTMODE_Msk = 0x1
	// Bit DETECTMODE.
	GPIO_DETECTMODE_DETECTMODE = 0x1
	// DETECT directly connected to PIN DETECT signals
	GPIO_DETECTMODE_DETECTMODE_Default = 0x0
	// Use the latched LDETECT behaviour
	GPIO_DETECTMODE_DETECTMODE_LDETECT = 0x1

	// PIN_CNF: Description collection: Configuration of GPIO pins
	// Position of DIR field.
	GPIO_PIN_CNF_DIR_Pos = 0x0
	// Bit mask of DIR field.
	GPIO_PIN_CNF_DIR_Msk = 0x1
	// Bit DIR.
	GPIO_PIN_CNF_DIR = 0x1
	// Configure pin as an input pin
	GPIO_PIN_CNF_DIR_Input = 0x0
	// Configure pin as an output pin
	GPIO_PIN_CNF_DIR_Output = 0x1
	// Position of INPUT field.
	GPIO_PIN_CNF_INPUT_Pos = 0x1
	// Bit mask of INPUT field.
	GPIO_PIN_CNF_INPUT_Msk = 0x2
	// Bit INPUT.
	GPIO_PIN_CNF_INPUT = 0x2
	// Connect input buffer
	GPIO_PIN_CNF_INPUT_Connect = 0x0
	// Disconnect input buffer
	GPIO_PIN_CNF_INPUT_Disconnect = 0x1
	// Position of PULL field.
	GPIO_PIN_CNF_PULL_Pos = 0x2
	// Bit mask of PULL field.
	GPIO_PIN_CNF_PULL_Msk = 0xc
	// No pull
	GPIO_PIN_CNF_PULL_Disabled = 0x0
	// Pull down on pin
	GPIO_PIN_CNF_PULL_Pulldown = 0x1
	// Pull up on pin
	GPIO_PIN_CNF_PULL_Pullup = 0x3
	// Position of DRIVE field.
	GPIO_PIN_CNF_DRIVE_Pos = 0x8
	// Bit mask of DRIVE field.
	GPIO_PIN_CNF_DRIVE_Msk = 0x700
	// Standard '0', standard '1'
	GPIO_PIN_CNF_DRIVE_S0S1 = 0x0
	// High drive '0', standard '1'
	GPIO_PIN_CNF_DRIVE_H0S1 = 0x1
	// Standard '0', high drive '1'
	GPIO_PIN_CNF_DRIVE_S0H1 = 0x2
	// High drive '0', high 'drive '1''
	GPIO_PIN_CNF_DRIVE_H0H1 = 0x3
	// Disconnect '0' standard '1' (normally used for wired-or connections)
	GPIO_PIN_CNF_DRIVE_D0S1 = 0x4
	// Disconnect '0', high drive '1' (normally used for wired-or connections)
	GPIO_PIN_CNF_DRIVE_D0H1 = 0x5
	// Standard '0'. disconnect '1' (normally used for wired-and connections)
	GPIO_PIN_CNF_DRIVE_S0D1 = 0x6
	// High drive '0', disconnect '1' (normally used for wired-and connections)
	GPIO_PIN_CNF_DRIVE_H0D1 = 0x7
	// Position of SENSE field.
	GPIO_PIN_CNF_SENSE_Pos = 0x10
	// Bit mask of SENSE field.
	GPIO_PIN_CNF_SENSE_Msk = 0x30000
	// Disabled
	GPIO_PIN_CNF_SENSE_Disabled = 0x0
	// Sense for high level
	GPIO_PIN_CNF_SENSE_High = 0x2
	// Sense for low level
	GPIO_PIN_CNF_SENSE_Low = 0x3
)

// Constants for RADIO: 2.4 GHz radio
const (
	// TASKS_TXEN: Enable RADIO in TX mode
	// Position of TASKS_TXEN field.
	RADIO_TASKS_TXEN_TASKS_TXEN_Pos = 0x0
	// Bit mask of TASKS_TXEN field.
	RADIO_TASKS_TXEN_TASKS_TXEN_Msk = 0x1
	// Bit TASKS_TXEN.
	RADIO_TASKS_TXEN_TASKS_TXEN = 0x1
	// Trigger task
	RADIO_TASKS_TXEN_TASKS_TXEN_Trigger = 0x1

	// TASKS_RXEN: Enable RADIO in RX mode
	// Position of TASKS_RXEN field.
	RADIO_TASKS_RXEN_TASKS_RXEN_Pos = 0x0
	// Bit mask of TASKS_RXEN field.
	RADIO_TASKS_RXEN_TASKS_RXEN_Msk = 0x1
	// Bit TASKS_RXEN.
	RADIO_TASKS_RXEN_TASKS_RXEN = 0x1
	// Trigger task
	RADIO_TASKS_RXEN_TASKS_RXEN_Trigger = 0x1

	// TASKS_START: Start RADIO
	// Position of TASKS_START field.
	RADIO_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	RADIO_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	RADIO_TASKS_START_TASKS_START = 0x1
	// Trigger task
	RADIO_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop RADIO
	// Position of TASKS_STOP field.
	RADIO_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	RADIO_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	RADIO_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	RADIO_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_DISABLE: Disable RADIO
	// Position of TASKS_DISABLE field.
	RADIO_TASKS_DISABLE_TASKS_DISABLE_Pos = 0x0
	// Bit mask of TASKS_DISABLE field.
	RADIO_TASKS_DISABLE_TASKS_DISABLE_Msk = 0x1
	// Bit TASKS_DISABLE.
	RADIO_TASKS_DISABLE_TASKS_DISABLE = 0x1
	// Trigger task
	RADIO_TASKS_DISABLE_TASKS_DISABLE_Trigger = 0x1

	// TASKS_RSSISTART: Start the RSSI and take one single sample of the receive signal strength
	// Position of TASKS_RSSISTART field.
	RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Pos = 0x0
	// Bit mask of TASKS_RSSISTART field.
	RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Msk = 0x1
	// Bit TASKS_RSSISTART.
	RADIO_TASKS_RSSISTART_TASKS_RSSISTART = 0x1
	// Trigger task
	RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Trigger = 0x1

	// TASKS_RSSISTOP: Stop the RSSI measurement
	// Position of TASKS_RSSISTOP field.
	RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Pos = 0x0
	// Bit mask of TASKS_RSSISTOP field.
	RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Msk = 0x1
	// Bit TASKS_RSSISTOP.
	RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP = 0x1
	// Trigger task
	RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Trigger = 0x1

	// TASKS_BCSTART: Start the bit counter
	// Position of TASKS_BCSTART field.
	RADIO_TASKS_BCSTART_TASKS_BCSTART_Pos = 0x0
	// Bit mask of TASKS_BCSTART field.
	RADIO_TASKS_BCSTART_TASKS_BCSTART_Msk = 0x1
	// Bit TASKS_BCSTART.
	RADIO_TASKS_BCSTART_TASKS_BCSTART = 0x1
	// Trigger task
	RADIO_TASKS_BCSTART_TASKS_BCSTART_Trigger = 0x1

	// TASKS_BCSTOP: Stop the bit counter
	// Position of TASKS_BCSTOP field.
	RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Pos = 0x0
	// Bit mask of TASKS_BCSTOP field.
	RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Msk = 0x1
	// Bit TASKS_BCSTOP.
	RADIO_TASKS_BCSTOP_TASKS_BCSTOP = 0x1
	// Trigger task
	RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Trigger = 0x1

	// TASKS_EDSTART: Start the energy detect measurement used in IEEE 802.15.4 mode
	// Position of TASKS_EDSTART field.
	RADIO_TASKS_EDSTART_TASKS_EDSTART_Pos = 0x0
	// Bit mask of TASKS_EDSTART field.
	RADIO_TASKS_EDSTART_TASKS_EDSTART_Msk = 0x1
	// Bit TASKS_EDSTART.
	RADIO_TASKS_EDSTART_TASKS_EDSTART = 0x1
	// Trigger task
	RADIO_TASKS_EDSTART_TASKS_EDSTART_Trigger = 0x1

	// TASKS_EDSTOP: Stop the energy detect measurement
	// Position of TASKS_EDSTOP field.
	RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Pos = 0x0
	// Bit mask of TASKS_EDSTOP field.
	RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Msk = 0x1
	// Bit TASKS_EDSTOP.
	RADIO_TASKS_EDSTOP_TASKS_EDSTOP = 0x1
	// Trigger task
	RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Trigger = 0x1

	// TASKS_CCASTART: Start the clear channel assessment used in IEEE 802.15.4 mode
	// Position of TASKS_CCASTART field.
	RADIO_TASKS_CCASTART_TASKS_CCASTART_Pos = 0x0
	// Bit mask of TASKS_CCASTART field.
	RADIO_TASKS_CCASTART_TASKS_CCASTART_Msk = 0x1
	// Bit TASKS_CCASTART.
	RADIO_TASKS_CCASTART_TASKS_CCASTART = 0x1
	// Trigger task
	RADIO_TASKS_CCASTART_TASKS_CCASTART_Trigger = 0x1

	// TASKS_CCASTOP: Stop the clear channel assessment
	// Position of TASKS_CCASTOP field.
	RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Pos = 0x0
	// Bit mask of TASKS_CCASTOP field.
	RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Msk = 0x1
	// Bit TASKS_CCASTOP.
	RADIO_TASKS_CCASTOP_TASKS_CCASTOP = 0x1
	// Trigger task
	RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Trigger = 0x1

	// EVENTS_READY: RADIO has ramped up and is ready to be started
	// Position of EVENTS_READY field.
	RADIO_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	RADIO_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	RADIO_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	RADIO_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// EVENTS_ADDRESS: Address sent or received
	// Position of EVENTS_ADDRESS field.
	RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Pos = 0x0
	// Bit mask of EVENTS_ADDRESS field.
	RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Msk = 0x1
	// Bit EVENTS_ADDRESS.
	RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS = 0x1
	// Event not generated
	RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Generated = 0x1

	// EVENTS_PAYLOAD: Packet payload sent or received
	// Position of EVENTS_PAYLOAD field.
	RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Pos = 0x0
	// Bit mask of EVENTS_PAYLOAD field.
	RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Msk = 0x1
	// Bit EVENTS_PAYLOAD.
	RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD = 0x1
	// Event not generated
	RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Generated = 0x1

	// EVENTS_END: Packet sent or received
	// Position of EVENTS_END field.
	RADIO_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	RADIO_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	RADIO_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	RADIO_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_DISABLED: RADIO has been disabled
	// Position of EVENTS_DISABLED field.
	RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Pos = 0x0
	// Bit mask of EVENTS_DISABLED field.
	RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Msk = 0x1
	// Bit EVENTS_DISABLED.
	RADIO_EVENTS_DISABLED_EVENTS_DISABLED = 0x1
	// Event not generated
	RADIO_EVENTS_DISABLED_EVENTS_DISABLED_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Generated = 0x1

	// EVENTS_DEVMATCH: A device address match occurred on the last received packet
	// Position of EVENTS_DEVMATCH field.
	RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Pos = 0x0
	// Bit mask of EVENTS_DEVMATCH field.
	RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Msk = 0x1
	// Bit EVENTS_DEVMATCH.
	RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH = 0x1
	// Event not generated
	RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Generated = 0x1

	// EVENTS_DEVMISS: No device address match occurred on the last received packet
	// Position of EVENTS_DEVMISS field.
	RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Pos = 0x0
	// Bit mask of EVENTS_DEVMISS field.
	RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Msk = 0x1
	// Bit EVENTS_DEVMISS.
	RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS = 0x1
	// Event not generated
	RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Generated = 0x1

	// EVENTS_RSSIEND: Sampling of receive signal strength complete
	// Position of EVENTS_RSSIEND field.
	RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Pos = 0x0
	// Bit mask of EVENTS_RSSIEND field.
	RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Msk = 0x1
	// Bit EVENTS_RSSIEND.
	RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND = 0x1
	// Event not generated
	RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Generated = 0x1

	// EVENTS_BCMATCH: Bit counter reached bit count value
	// Position of EVENTS_BCMATCH field.
	RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Pos = 0x0
	// Bit mask of EVENTS_BCMATCH field.
	RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Msk = 0x1
	// Bit EVENTS_BCMATCH.
	RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH = 0x1
	// Event not generated
	RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Generated = 0x1

	// EVENTS_CRCOK: Packet received with CRC ok
	// Position of EVENTS_CRCOK field.
	RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Pos = 0x0
	// Bit mask of EVENTS_CRCOK field.
	RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Msk = 0x1
	// Bit EVENTS_CRCOK.
	RADIO_EVENTS_CRCOK_EVENTS_CRCOK = 0x1
	// Event not generated
	RADIO_EVENTS_CRCOK_EVENTS_CRCOK_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Generated = 0x1

	// EVENTS_CRCERROR: Packet received with CRC error
	// Position of EVENTS_CRCERROR field.
	RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Pos = 0x0
	// Bit mask of EVENTS_CRCERROR field.
	RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Msk = 0x1
	// Bit EVENTS_CRCERROR.
	RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR = 0x1
	// Event not generated
	RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Generated = 0x1

	// EVENTS_FRAMESTART: IEEE 802.15.4 length field received
	// Position of EVENTS_FRAMESTART field.
	RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Pos = 0x0
	// Bit mask of EVENTS_FRAMESTART field.
	RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Msk = 0x1
	// Bit EVENTS_FRAMESTART.
	RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART = 0x1
	// Event not generated
	RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Generated = 0x1

	// EVENTS_EDEND: Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register
	// Position of EVENTS_EDEND field.
	RADIO_EVENTS_EDEND_EVENTS_EDEND_Pos = 0x0
	// Bit mask of EVENTS_EDEND field.
	RADIO_EVENTS_EDEND_EVENTS_EDEND_Msk = 0x1
	// Bit EVENTS_EDEND.
	RADIO_EVENTS_EDEND_EVENTS_EDEND = 0x1
	// Event not generated
	RADIO_EVENTS_EDEND_EVENTS_EDEND_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_EDEND_EVENTS_EDEND_Generated = 0x1

	// EVENTS_EDSTOPPED: The sampling of energy detection has stopped
	// Position of EVENTS_EDSTOPPED field.
	RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Pos = 0x0
	// Bit mask of EVENTS_EDSTOPPED field.
	RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Msk = 0x1
	// Bit EVENTS_EDSTOPPED.
	RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED = 0x1
	// Event not generated
	RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Generated = 0x1

	// EVENTS_CCAIDLE: Wireless medium in idle - clear to send
	// Position of EVENTS_CCAIDLE field.
	RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Pos = 0x0
	// Bit mask of EVENTS_CCAIDLE field.
	RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Msk = 0x1
	// Bit EVENTS_CCAIDLE.
	RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE = 0x1
	// Event not generated
	RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Generated = 0x1

	// EVENTS_CCABUSY: Wireless medium busy - do not send
	// Position of EVENTS_CCABUSY field.
	RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Pos = 0x0
	// Bit mask of EVENTS_CCABUSY field.
	RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Msk = 0x1
	// Bit EVENTS_CCABUSY.
	RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY = 0x1
	// Event not generated
	RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Generated = 0x1

	// EVENTS_CCASTOPPED: The CCA has stopped
	// Position of EVENTS_CCASTOPPED field.
	RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Pos = 0x0
	// Bit mask of EVENTS_CCASTOPPED field.
	RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Msk = 0x1
	// Bit EVENTS_CCASTOPPED.
	RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED = 0x1
	// Event not generated
	RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Generated = 0x1

	// EVENTS_RATEBOOST: Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit.
	// Position of EVENTS_RATEBOOST field.
	RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Pos = 0x0
	// Bit mask of EVENTS_RATEBOOST field.
	RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Msk = 0x1
	// Bit EVENTS_RATEBOOST.
	RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST = 0x1
	// Event not generated
	RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Generated = 0x1

	// EVENTS_TXREADY: RADIO has ramped up and is ready to be started TX path
	// Position of EVENTS_TXREADY field.
	RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Pos = 0x0
	// Bit mask of EVENTS_TXREADY field.
	RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Msk = 0x1
	// Bit EVENTS_TXREADY.
	RADIO_EVENTS_TXREADY_EVENTS_TXREADY = 0x1
	// Event not generated
	RADIO_EVENTS_TXREADY_EVENTS_TXREADY_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Generated = 0x1

	// EVENTS_RXREADY: RADIO has ramped up and is ready to be started RX path
	// Position of EVENTS_RXREADY field.
	RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Pos = 0x0
	// Bit mask of EVENTS_RXREADY field.
	RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Msk = 0x1
	// Bit EVENTS_RXREADY.
	RADIO_EVENTS_RXREADY_EVENTS_RXREADY = 0x1
	// Event not generated
	RADIO_EVENTS_RXREADY_EVENTS_RXREADY_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Generated = 0x1

	// EVENTS_MHRMATCH: MAC header match found
	// Position of EVENTS_MHRMATCH field.
	RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Pos = 0x0
	// Bit mask of EVENTS_MHRMATCH field.
	RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Msk = 0x1
	// Bit EVENTS_MHRMATCH.
	RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH = 0x1
	// Event not generated
	RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Generated = 0x1

	// EVENTS_SYNC: Preamble indicator
	// Position of EVENTS_SYNC field.
	RADIO_EVENTS_SYNC_EVENTS_SYNC_Pos = 0x0
	// Bit mask of EVENTS_SYNC field.
	RADIO_EVENTS_SYNC_EVENTS_SYNC_Msk = 0x1
	// Bit EVENTS_SYNC.
	RADIO_EVENTS_SYNC_EVENTS_SYNC = 0x1
	// Event not generated
	RADIO_EVENTS_SYNC_EVENTS_SYNC_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_SYNC_EVENTS_SYNC_Generated = 0x1

	// EVENTS_PHYEND: Generated when last bit is sent on air, or received from air
	// Position of EVENTS_PHYEND field.
	RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Pos = 0x0
	// Bit mask of EVENTS_PHYEND field.
	RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Msk = 0x1
	// Bit EVENTS_PHYEND.
	RADIO_EVENTS_PHYEND_EVENTS_PHYEND = 0x1
	// Event not generated
	RADIO_EVENTS_PHYEND_EVENTS_PHYEND_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Generated = 0x1

	// EVENTS_CTEPRESENT: CTE is present (early warning right after receiving CTEInfo byte)
	// Position of EVENTS_CTEPRESENT field.
	RADIO_EVENTS_CTEPRESENT_EVENTS_CTEPRESENT_Pos = 0x0
	// Bit mask of EVENTS_CTEPRESENT field.
	RADIO_EVENTS_CTEPRESENT_EVENTS_CTEPRESENT_Msk = 0x1
	// Bit EVENTS_CTEPRESENT.
	RADIO_EVENTS_CTEPRESENT_EVENTS_CTEPRESENT = 0x1
	// Event not generated
	RADIO_EVENTS_CTEPRESENT_EVENTS_CTEPRESENT_NotGenerated = 0x0
	// Event generated
	RADIO_EVENTS_CTEPRESENT_EVENTS_CTEPRESENT_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of READY_START field.
	RADIO_SHORTS_READY_START_Pos = 0x0
	// Bit mask of READY_START field.
	RADIO_SHORTS_READY_START_Msk = 0x1
	// Bit READY_START.
	RADIO_SHORTS_READY_START = 0x1
	// Disable shortcut
	RADIO_SHORTS_READY_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_READY_START_Enabled = 0x1
	// Position of END_DISABLE field.
	RADIO_SHORTS_END_DISABLE_Pos = 0x1
	// Bit mask of END_DISABLE field.
	RADIO_SHORTS_END_DISABLE_Msk = 0x2
	// Bit END_DISABLE.
	RADIO_SHORTS_END_DISABLE = 0x2
	// Disable shortcut
	RADIO_SHORTS_END_DISABLE_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_END_DISABLE_Enabled = 0x1
	// Position of DISABLED_TXEN field.
	RADIO_SHORTS_DISABLED_TXEN_Pos = 0x2
	// Bit mask of DISABLED_TXEN field.
	RADIO_SHORTS_DISABLED_TXEN_Msk = 0x4
	// Bit DISABLED_TXEN.
	RADIO_SHORTS_DISABLED_TXEN = 0x4
	// Disable shortcut
	RADIO_SHORTS_DISABLED_TXEN_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_DISABLED_TXEN_Enabled = 0x1
	// Position of DISABLED_RXEN field.
	RADIO_SHORTS_DISABLED_RXEN_Pos = 0x3
	// Bit mask of DISABLED_RXEN field.
	RADIO_SHORTS_DISABLED_RXEN_Msk = 0x8
	// Bit DISABLED_RXEN.
	RADIO_SHORTS_DISABLED_RXEN = 0x8
	// Disable shortcut
	RADIO_SHORTS_DISABLED_RXEN_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_DISABLED_RXEN_Enabled = 0x1
	// Position of ADDRESS_RSSISTART field.
	RADIO_SHORTS_ADDRESS_RSSISTART_Pos = 0x4
	// Bit mask of ADDRESS_RSSISTART field.
	RADIO_SHORTS_ADDRESS_RSSISTART_Msk = 0x10
	// Bit ADDRESS_RSSISTART.
	RADIO_SHORTS_ADDRESS_RSSISTART = 0x10
	// Disable shortcut
	RADIO_SHORTS_ADDRESS_RSSISTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_ADDRESS_RSSISTART_Enabled = 0x1
	// Position of END_START field.
	RADIO_SHORTS_END_START_Pos = 0x5
	// Bit mask of END_START field.
	RADIO_SHORTS_END_START_Msk = 0x20
	// Bit END_START.
	RADIO_SHORTS_END_START = 0x20
	// Disable shortcut
	RADIO_SHORTS_END_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_END_START_Enabled = 0x1
	// Position of ADDRESS_BCSTART field.
	RADIO_SHORTS_ADDRESS_BCSTART_Pos = 0x6
	// Bit mask of ADDRESS_BCSTART field.
	RADIO_SHORTS_ADDRESS_BCSTART_Msk = 0x40
	// Bit ADDRESS_BCSTART.
	RADIO_SHORTS_ADDRESS_BCSTART = 0x40
	// Disable shortcut
	RADIO_SHORTS_ADDRESS_BCSTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_ADDRESS_BCSTART_Enabled = 0x1
	// Position of DISABLED_RSSISTOP field.
	RADIO_SHORTS_DISABLED_RSSISTOP_Pos = 0x8
	// Bit mask of DISABLED_RSSISTOP field.
	RADIO_SHORTS_DISABLED_RSSISTOP_Msk = 0x100
	// Bit DISABLED_RSSISTOP.
	RADIO_SHORTS_DISABLED_RSSISTOP = 0x100
	// Disable shortcut
	RADIO_SHORTS_DISABLED_RSSISTOP_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_DISABLED_RSSISTOP_Enabled = 0x1
	// Position of RXREADY_CCASTART field.
	RADIO_SHORTS_RXREADY_CCASTART_Pos = 0xb
	// Bit mask of RXREADY_CCASTART field.
	RADIO_SHORTS_RXREADY_CCASTART_Msk = 0x800
	// Bit RXREADY_CCASTART.
	RADIO_SHORTS_RXREADY_CCASTART = 0x800
	// Disable shortcut
	RADIO_SHORTS_RXREADY_CCASTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_RXREADY_CCASTART_Enabled = 0x1
	// Position of CCAIDLE_TXEN field.
	RADIO_SHORTS_CCAIDLE_TXEN_Pos = 0xc
	// Bit mask of CCAIDLE_TXEN field.
	RADIO_SHORTS_CCAIDLE_TXEN_Msk = 0x1000
	// Bit CCAIDLE_TXEN.
	RADIO_SHORTS_CCAIDLE_TXEN = 0x1000
	// Disable shortcut
	RADIO_SHORTS_CCAIDLE_TXEN_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_CCAIDLE_TXEN_Enabled = 0x1
	// Position of CCABUSY_DISABLE field.
	RADIO_SHORTS_CCABUSY_DISABLE_Pos = 0xd
	// Bit mask of CCABUSY_DISABLE field.
	RADIO_SHORTS_CCABUSY_DISABLE_Msk = 0x2000
	// Bit CCABUSY_DISABLE.
	RADIO_SHORTS_CCABUSY_DISABLE = 0x2000
	// Disable shortcut
	RADIO_SHORTS_CCABUSY_DISABLE_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_CCABUSY_DISABLE_Enabled = 0x1
	// Position of FRAMESTART_BCSTART field.
	RADIO_SHORTS_FRAMESTART_BCSTART_Pos = 0xe
	// Bit mask of FRAMESTART_BCSTART field.
	RADIO_SHORTS_FRAMESTART_BCSTART_Msk = 0x4000
	// Bit FRAMESTART_BCSTART.
	RADIO_SHORTS_FRAMESTART_BCSTART = 0x4000
	// Disable shortcut
	RADIO_SHORTS_FRAMESTART_BCSTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_FRAMESTART_BCSTART_Enabled = 0x1
	// Position of READY_EDSTART field.
	RADIO_SHORTS_READY_EDSTART_Pos = 0xf
	// Bit mask of READY_EDSTART field.
	RADIO_SHORTS_READY_EDSTART_Msk = 0x8000
	// Bit READY_EDSTART.
	RADIO_SHORTS_READY_EDSTART = 0x8000
	// Disable shortcut
	RADIO_SHORTS_READY_EDSTART_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_READY_EDSTART_Enabled = 0x1
	// Position of EDEND_DISABLE field.
	RADIO_SHORTS_EDEND_DISABLE_Pos = 0x10
	// Bit mask of EDEND_DISABLE field.
	RADIO_SHORTS_EDEND_DISABLE_Msk = 0x10000
	// Bit EDEND_DISABLE.
	RADIO_SHORTS_EDEND_DISABLE = 0x10000
	// Disable shortcut
	RADIO_SHORTS_EDEND_DISABLE_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_EDEND_DISABLE_Enabled = 0x1
	// Position of CCAIDLE_STOP field.
	RADIO_SHORTS_CCAIDLE_STOP_Pos = 0x11
	// Bit mask of CCAIDLE_STOP field.
	RADIO_SHORTS_CCAIDLE_STOP_Msk = 0x20000
	// Bit CCAIDLE_STOP.
	RADIO_SHORTS_CCAIDLE_STOP = 0x20000
	// Disable shortcut
	RADIO_SHORTS_CCAIDLE_STOP_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_CCAIDLE_STOP_Enabled = 0x1
	// Position of TXREADY_START field.
	RADIO_SHORTS_TXREADY_START_Pos = 0x12
	// Bit mask of TXREADY_START field.
	RADIO_SHORTS_TXREADY_START_Msk = 0x40000
	// Bit TXREADY_START.
	RADIO_SHORTS_TXREADY_START = 0x40000
	// Disable shortcut
	RADIO_SHORTS_TXREADY_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_TXREADY_START_Enabled = 0x1
	// Position of RXREADY_START field.
	RADIO_SHORTS_RXREADY_START_Pos = 0x13
	// Bit mask of RXREADY_START field.
	RADIO_SHORTS_RXREADY_START_Msk = 0x80000
	// Bit RXREADY_START.
	RADIO_SHORTS_RXREADY_START = 0x80000
	// Disable shortcut
	RADIO_SHORTS_RXREADY_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_RXREADY_START_Enabled = 0x1
	// Position of PHYEND_DISABLE field.
	RADIO_SHORTS_PHYEND_DISABLE_Pos = 0x14
	// Bit mask of PHYEND_DISABLE field.
	RADIO_SHORTS_PHYEND_DISABLE_Msk = 0x100000
	// Bit PHYEND_DISABLE.
	RADIO_SHORTS_PHYEND_DISABLE = 0x100000
	// Disable shortcut
	RADIO_SHORTS_PHYEND_DISABLE_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_PHYEND_DISABLE_Enabled = 0x1
	// Position of PHYEND_START field.
	RADIO_SHORTS_PHYEND_START_Pos = 0x15
	// Bit mask of PHYEND_START field.
	RADIO_SHORTS_PHYEND_START_Msk = 0x200000
	// Bit PHYEND_START.
	RADIO_SHORTS_PHYEND_START = 0x200000
	// Disable shortcut
	RADIO_SHORTS_PHYEND_START_Disabled = 0x0
	// Enable shortcut
	RADIO_SHORTS_PHYEND_START_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	RADIO_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	RADIO_INTENSET_READY_Msk = 0x1
	// Bit READY.
	RADIO_INTENSET_READY = 0x1
	// Read: Disabled
	RADIO_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_READY_Enabled = 0x1
	// Enable
	RADIO_INTENSET_READY_Set = 0x1
	// Position of ADDRESS field.
	RADIO_INTENSET_ADDRESS_Pos = 0x1
	// Bit mask of ADDRESS field.
	RADIO_INTENSET_ADDRESS_Msk = 0x2
	// Bit ADDRESS.
	RADIO_INTENSET_ADDRESS = 0x2
	// Read: Disabled
	RADIO_INTENSET_ADDRESS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_ADDRESS_Enabled = 0x1
	// Enable
	RADIO_INTENSET_ADDRESS_Set = 0x1
	// Position of PAYLOAD field.
	RADIO_INTENSET_PAYLOAD_Pos = 0x2
	// Bit mask of PAYLOAD field.
	RADIO_INTENSET_PAYLOAD_Msk = 0x4
	// Bit PAYLOAD.
	RADIO_INTENSET_PAYLOAD = 0x4
	// Read: Disabled
	RADIO_INTENSET_PAYLOAD_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_PAYLOAD_Enabled = 0x1
	// Enable
	RADIO_INTENSET_PAYLOAD_Set = 0x1
	// Position of END field.
	RADIO_INTENSET_END_Pos = 0x3
	// Bit mask of END field.
	RADIO_INTENSET_END_Msk = 0x8
	// Bit END.
	RADIO_INTENSET_END = 0x8
	// Read: Disabled
	RADIO_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_END_Enabled = 0x1
	// Enable
	RADIO_INTENSET_END_Set = 0x1
	// Position of DISABLED field.
	RADIO_INTENSET_DISABLED_Pos = 0x4
	// Bit mask of DISABLED field.
	RADIO_INTENSET_DISABLED_Msk = 0x10
	// Bit DISABLED.
	RADIO_INTENSET_DISABLED = 0x10
	// Read: Disabled
	RADIO_INTENSET_DISABLED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_DISABLED_Enabled = 0x1
	// Enable
	RADIO_INTENSET_DISABLED_Set = 0x1
	// Position of DEVMATCH field.
	RADIO_INTENSET_DEVMATCH_Pos = 0x5
	// Bit mask of DEVMATCH field.
	RADIO_INTENSET_DEVMATCH_Msk = 0x20
	// Bit DEVMATCH.
	RADIO_INTENSET_DEVMATCH = 0x20
	// Read: Disabled
	RADIO_INTENSET_DEVMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_DEVMATCH_Enabled = 0x1
	// Enable
	RADIO_INTENSET_DEVMATCH_Set = 0x1
	// Position of DEVMISS field.
	RADIO_INTENSET_DEVMISS_Pos = 0x6
	// Bit mask of DEVMISS field.
	RADIO_INTENSET_DEVMISS_Msk = 0x40
	// Bit DEVMISS.
	RADIO_INTENSET_DEVMISS = 0x40
	// Read: Disabled
	RADIO_INTENSET_DEVMISS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_DEVMISS_Enabled = 0x1
	// Enable
	RADIO_INTENSET_DEVMISS_Set = 0x1
	// Position of RSSIEND field.
	RADIO_INTENSET_RSSIEND_Pos = 0x7
	// Bit mask of RSSIEND field.
	RADIO_INTENSET_RSSIEND_Msk = 0x80
	// Bit RSSIEND.
	RADIO_INTENSET_RSSIEND = 0x80
	// Read: Disabled
	RADIO_INTENSET_RSSIEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_RSSIEND_Enabled = 0x1
	// Enable
	RADIO_INTENSET_RSSIEND_Set = 0x1
	// Position of BCMATCH field.
	RADIO_INTENSET_BCMATCH_Pos = 0xa
	// Bit mask of BCMATCH field.
	RADIO_INTENSET_BCMATCH_Msk = 0x400
	// Bit BCMATCH.
	RADIO_INTENSET_BCMATCH = 0x400
	// Read: Disabled
	RADIO_INTENSET_BCMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_BCMATCH_Enabled = 0x1
	// Enable
	RADIO_INTENSET_BCMATCH_Set = 0x1
	// Position of CRCOK field.
	RADIO_INTENSET_CRCOK_Pos = 0xc
	// Bit mask of CRCOK field.
	RADIO_INTENSET_CRCOK_Msk = 0x1000
	// Bit CRCOK.
	RADIO_INTENSET_CRCOK = 0x1000
	// Read: Disabled
	RADIO_INTENSET_CRCOK_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CRCOK_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CRCOK_Set = 0x1
	// Position of CRCERROR field.
	RADIO_INTENSET_CRCERROR_Pos = 0xd
	// Bit mask of CRCERROR field.
	RADIO_INTENSET_CRCERROR_Msk = 0x2000
	// Bit CRCERROR.
	RADIO_INTENSET_CRCERROR = 0x2000
	// Read: Disabled
	RADIO_INTENSET_CRCERROR_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CRCERROR_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CRCERROR_Set = 0x1
	// Position of FRAMESTART field.
	RADIO_INTENSET_FRAMESTART_Pos = 0xe
	// Bit mask of FRAMESTART field.
	RADIO_INTENSET_FRAMESTART_Msk = 0x4000
	// Bit FRAMESTART.
	RADIO_INTENSET_FRAMESTART = 0x4000
	// Read: Disabled
	RADIO_INTENSET_FRAMESTART_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_FRAMESTART_Enabled = 0x1
	// Enable
	RADIO_INTENSET_FRAMESTART_Set = 0x1
	// Position of EDEND field.
	RADIO_INTENSET_EDEND_Pos = 0xf
	// Bit mask of EDEND field.
	RADIO_INTENSET_EDEND_Msk = 0x8000
	// Bit EDEND.
	RADIO_INTENSET_EDEND = 0x8000
	// Read: Disabled
	RADIO_INTENSET_EDEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_EDEND_Enabled = 0x1
	// Enable
	RADIO_INTENSET_EDEND_Set = 0x1
	// Position of EDSTOPPED field.
	RADIO_INTENSET_EDSTOPPED_Pos = 0x10
	// Bit mask of EDSTOPPED field.
	RADIO_INTENSET_EDSTOPPED_Msk = 0x10000
	// Bit EDSTOPPED.
	RADIO_INTENSET_EDSTOPPED = 0x10000
	// Read: Disabled
	RADIO_INTENSET_EDSTOPPED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_EDSTOPPED_Enabled = 0x1
	// Enable
	RADIO_INTENSET_EDSTOPPED_Set = 0x1
	// Position of CCAIDLE field.
	RADIO_INTENSET_CCAIDLE_Pos = 0x11
	// Bit mask of CCAIDLE field.
	RADIO_INTENSET_CCAIDLE_Msk = 0x20000
	// Bit CCAIDLE.
	RADIO_INTENSET_CCAIDLE = 0x20000
	// Read: Disabled
	RADIO_INTENSET_CCAIDLE_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CCAIDLE_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CCAIDLE_Set = 0x1
	// Position of CCABUSY field.
	RADIO_INTENSET_CCABUSY_Pos = 0x12
	// Bit mask of CCABUSY field.
	RADIO_INTENSET_CCABUSY_Msk = 0x40000
	// Bit CCABUSY.
	RADIO_INTENSET_CCABUSY = 0x40000
	// Read: Disabled
	RADIO_INTENSET_CCABUSY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CCABUSY_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CCABUSY_Set = 0x1
	// Position of CCASTOPPED field.
	RADIO_INTENSET_CCASTOPPED_Pos = 0x13
	// Bit mask of CCASTOPPED field.
	RADIO_INTENSET_CCASTOPPED_Msk = 0x80000
	// Bit CCASTOPPED.
	RADIO_INTENSET_CCASTOPPED = 0x80000
	// Read: Disabled
	RADIO_INTENSET_CCASTOPPED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CCASTOPPED_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CCASTOPPED_Set = 0x1
	// Position of RATEBOOST field.
	RADIO_INTENSET_RATEBOOST_Pos = 0x14
	// Bit mask of RATEBOOST field.
	RADIO_INTENSET_RATEBOOST_Msk = 0x100000
	// Bit RATEBOOST.
	RADIO_INTENSET_RATEBOOST = 0x100000
	// Read: Disabled
	RADIO_INTENSET_RATEBOOST_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_RATEBOOST_Enabled = 0x1
	// Enable
	RADIO_INTENSET_RATEBOOST_Set = 0x1
	// Position of TXREADY field.
	RADIO_INTENSET_TXREADY_Pos = 0x15
	// Bit mask of TXREADY field.
	RADIO_INTENSET_TXREADY_Msk = 0x200000
	// Bit TXREADY.
	RADIO_INTENSET_TXREADY = 0x200000
	// Read: Disabled
	RADIO_INTENSET_TXREADY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_TXREADY_Enabled = 0x1
	// Enable
	RADIO_INTENSET_TXREADY_Set = 0x1
	// Position of RXREADY field.
	RADIO_INTENSET_RXREADY_Pos = 0x16
	// Bit mask of RXREADY field.
	RADIO_INTENSET_RXREADY_Msk = 0x400000
	// Bit RXREADY.
	RADIO_INTENSET_RXREADY = 0x400000
	// Read: Disabled
	RADIO_INTENSET_RXREADY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_RXREADY_Enabled = 0x1
	// Enable
	RADIO_INTENSET_RXREADY_Set = 0x1
	// Position of MHRMATCH field.
	RADIO_INTENSET_MHRMATCH_Pos = 0x17
	// Bit mask of MHRMATCH field.
	RADIO_INTENSET_MHRMATCH_Msk = 0x800000
	// Bit MHRMATCH.
	RADIO_INTENSET_MHRMATCH = 0x800000
	// Read: Disabled
	RADIO_INTENSET_MHRMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_MHRMATCH_Enabled = 0x1
	// Enable
	RADIO_INTENSET_MHRMATCH_Set = 0x1
	// Position of SYNC field.
	RADIO_INTENSET_SYNC_Pos = 0x1a
	// Bit mask of SYNC field.
	RADIO_INTENSET_SYNC_Msk = 0x4000000
	// Bit SYNC.
	RADIO_INTENSET_SYNC = 0x4000000
	// Read: Disabled
	RADIO_INTENSET_SYNC_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_SYNC_Enabled = 0x1
	// Enable
	RADIO_INTENSET_SYNC_Set = 0x1
	// Position of PHYEND field.
	RADIO_INTENSET_PHYEND_Pos = 0x1b
	// Bit mask of PHYEND field.
	RADIO_INTENSET_PHYEND_Msk = 0x8000000
	// Bit PHYEND.
	RADIO_INTENSET_PHYEND = 0x8000000
	// Read: Disabled
	RADIO_INTENSET_PHYEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_PHYEND_Enabled = 0x1
	// Enable
	RADIO_INTENSET_PHYEND_Set = 0x1
	// Position of CTEPRESENT field.
	RADIO_INTENSET_CTEPRESENT_Pos = 0x1c
	// Bit mask of CTEPRESENT field.
	RADIO_INTENSET_CTEPRESENT_Msk = 0x10000000
	// Bit CTEPRESENT.
	RADIO_INTENSET_CTEPRESENT = 0x10000000
	// Read: Disabled
	RADIO_INTENSET_CTEPRESENT_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENSET_CTEPRESENT_Enabled = 0x1
	// Enable
	RADIO_INTENSET_CTEPRESENT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	RADIO_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	RADIO_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	RADIO_INTENCLR_READY = 0x1
	// Read: Disabled
	RADIO_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_READY_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_READY_Clear = 0x1
	// Position of ADDRESS field.
	RADIO_INTENCLR_ADDRESS_Pos = 0x1
	// Bit mask of ADDRESS field.
	RADIO_INTENCLR_ADDRESS_Msk = 0x2
	// Bit ADDRESS.
	RADIO_INTENCLR_ADDRESS = 0x2
	// Read: Disabled
	RADIO_INTENCLR_ADDRESS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_ADDRESS_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_ADDRESS_Clear = 0x1
	// Position of PAYLOAD field.
	RADIO_INTENCLR_PAYLOAD_Pos = 0x2
	// Bit mask of PAYLOAD field.
	RADIO_INTENCLR_PAYLOAD_Msk = 0x4
	// Bit PAYLOAD.
	RADIO_INTENCLR_PAYLOAD = 0x4
	// Read: Disabled
	RADIO_INTENCLR_PAYLOAD_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_PAYLOAD_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_PAYLOAD_Clear = 0x1
	// Position of END field.
	RADIO_INTENCLR_END_Pos = 0x3
	// Bit mask of END field.
	RADIO_INTENCLR_END_Msk = 0x8
	// Bit END.
	RADIO_INTENCLR_END = 0x8
	// Read: Disabled
	RADIO_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_END_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_END_Clear = 0x1
	// Position of DISABLED field.
	RADIO_INTENCLR_DISABLED_Pos = 0x4
	// Bit mask of DISABLED field.
	RADIO_INTENCLR_DISABLED_Msk = 0x10
	// Bit DISABLED.
	RADIO_INTENCLR_DISABLED = 0x10
	// Read: Disabled
	RADIO_INTENCLR_DISABLED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_DISABLED_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_DISABLED_Clear = 0x1
	// Position of DEVMATCH field.
	RADIO_INTENCLR_DEVMATCH_Pos = 0x5
	// Bit mask of DEVMATCH field.
	RADIO_INTENCLR_DEVMATCH_Msk = 0x20
	// Bit DEVMATCH.
	RADIO_INTENCLR_DEVMATCH = 0x20
	// Read: Disabled
	RADIO_INTENCLR_DEVMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_DEVMATCH_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_DEVMATCH_Clear = 0x1
	// Position of DEVMISS field.
	RADIO_INTENCLR_DEVMISS_Pos = 0x6
	// Bit mask of DEVMISS field.
	RADIO_INTENCLR_DEVMISS_Msk = 0x40
	// Bit DEVMISS.
	RADIO_INTENCLR_DEVMISS = 0x40
	// Read: Disabled
	RADIO_INTENCLR_DEVMISS_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_DEVMISS_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_DEVMISS_Clear = 0x1
	// Position of RSSIEND field.
	RADIO_INTENCLR_RSSIEND_Pos = 0x7
	// Bit mask of RSSIEND field.
	RADIO_INTENCLR_RSSIEND_Msk = 0x80
	// Bit RSSIEND.
	RADIO_INTENCLR_RSSIEND = 0x80
	// Read: Disabled
	RADIO_INTENCLR_RSSIEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_RSSIEND_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_RSSIEND_Clear = 0x1
	// Position of BCMATCH field.
	RADIO_INTENCLR_BCMATCH_Pos = 0xa
	// Bit mask of BCMATCH field.
	RADIO_INTENCLR_BCMATCH_Msk = 0x400
	// Bit BCMATCH.
	RADIO_INTENCLR_BCMATCH = 0x400
	// Read: Disabled
	RADIO_INTENCLR_BCMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_BCMATCH_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_BCMATCH_Clear = 0x1
	// Position of CRCOK field.
	RADIO_INTENCLR_CRCOK_Pos = 0xc
	// Bit mask of CRCOK field.
	RADIO_INTENCLR_CRCOK_Msk = 0x1000
	// Bit CRCOK.
	RADIO_INTENCLR_CRCOK = 0x1000
	// Read: Disabled
	RADIO_INTENCLR_CRCOK_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CRCOK_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CRCOK_Clear = 0x1
	// Position of CRCERROR field.
	RADIO_INTENCLR_CRCERROR_Pos = 0xd
	// Bit mask of CRCERROR field.
	RADIO_INTENCLR_CRCERROR_Msk = 0x2000
	// Bit CRCERROR.
	RADIO_INTENCLR_CRCERROR = 0x2000
	// Read: Disabled
	RADIO_INTENCLR_CRCERROR_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CRCERROR_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CRCERROR_Clear = 0x1
	// Position of FRAMESTART field.
	RADIO_INTENCLR_FRAMESTART_Pos = 0xe
	// Bit mask of FRAMESTART field.
	RADIO_INTENCLR_FRAMESTART_Msk = 0x4000
	// Bit FRAMESTART.
	RADIO_INTENCLR_FRAMESTART = 0x4000
	// Read: Disabled
	RADIO_INTENCLR_FRAMESTART_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_FRAMESTART_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_FRAMESTART_Clear = 0x1
	// Position of EDEND field.
	RADIO_INTENCLR_EDEND_Pos = 0xf
	// Bit mask of EDEND field.
	RADIO_INTENCLR_EDEND_Msk = 0x8000
	// Bit EDEND.
	RADIO_INTENCLR_EDEND = 0x8000
	// Read: Disabled
	RADIO_INTENCLR_EDEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_EDEND_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_EDEND_Clear = 0x1
	// Position of EDSTOPPED field.
	RADIO_INTENCLR_EDSTOPPED_Pos = 0x10
	// Bit mask of EDSTOPPED field.
	RADIO_INTENCLR_EDSTOPPED_Msk = 0x10000
	// Bit EDSTOPPED.
	RADIO_INTENCLR_EDSTOPPED = 0x10000
	// Read: Disabled
	RADIO_INTENCLR_EDSTOPPED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_EDSTOPPED_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_EDSTOPPED_Clear = 0x1
	// Position of CCAIDLE field.
	RADIO_INTENCLR_CCAIDLE_Pos = 0x11
	// Bit mask of CCAIDLE field.
	RADIO_INTENCLR_CCAIDLE_Msk = 0x20000
	// Bit CCAIDLE.
	RADIO_INTENCLR_CCAIDLE = 0x20000
	// Read: Disabled
	RADIO_INTENCLR_CCAIDLE_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CCAIDLE_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CCAIDLE_Clear = 0x1
	// Position of CCABUSY field.
	RADIO_INTENCLR_CCABUSY_Pos = 0x12
	// Bit mask of CCABUSY field.
	RADIO_INTENCLR_CCABUSY_Msk = 0x40000
	// Bit CCABUSY.
	RADIO_INTENCLR_CCABUSY = 0x40000
	// Read: Disabled
	RADIO_INTENCLR_CCABUSY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CCABUSY_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CCABUSY_Clear = 0x1
	// Position of CCASTOPPED field.
	RADIO_INTENCLR_CCASTOPPED_Pos = 0x13
	// Bit mask of CCASTOPPED field.
	RADIO_INTENCLR_CCASTOPPED_Msk = 0x80000
	// Bit CCASTOPPED.
	RADIO_INTENCLR_CCASTOPPED = 0x80000
	// Read: Disabled
	RADIO_INTENCLR_CCASTOPPED_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CCASTOPPED_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CCASTOPPED_Clear = 0x1
	// Position of RATEBOOST field.
	RADIO_INTENCLR_RATEBOOST_Pos = 0x14
	// Bit mask of RATEBOOST field.
	RADIO_INTENCLR_RATEBOOST_Msk = 0x100000
	// Bit RATEBOOST.
	RADIO_INTENCLR_RATEBOOST = 0x100000
	// Read: Disabled
	RADIO_INTENCLR_RATEBOOST_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_RATEBOOST_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_RATEBOOST_Clear = 0x1
	// Position of TXREADY field.
	RADIO_INTENCLR_TXREADY_Pos = 0x15
	// Bit mask of TXREADY field.
	RADIO_INTENCLR_TXREADY_Msk = 0x200000
	// Bit TXREADY.
	RADIO_INTENCLR_TXREADY = 0x200000
	// Read: Disabled
	RADIO_INTENCLR_TXREADY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_TXREADY_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_TXREADY_Clear = 0x1
	// Position of RXREADY field.
	RADIO_INTENCLR_RXREADY_Pos = 0x16
	// Bit mask of RXREADY field.
	RADIO_INTENCLR_RXREADY_Msk = 0x400000
	// Bit RXREADY.
	RADIO_INTENCLR_RXREADY = 0x400000
	// Read: Disabled
	RADIO_INTENCLR_RXREADY_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_RXREADY_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_RXREADY_Clear = 0x1
	// Position of MHRMATCH field.
	RADIO_INTENCLR_MHRMATCH_Pos = 0x17
	// Bit mask of MHRMATCH field.
	RADIO_INTENCLR_MHRMATCH_Msk = 0x800000
	// Bit MHRMATCH.
	RADIO_INTENCLR_MHRMATCH = 0x800000
	// Read: Disabled
	RADIO_INTENCLR_MHRMATCH_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_MHRMATCH_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_MHRMATCH_Clear = 0x1
	// Position of SYNC field.
	RADIO_INTENCLR_SYNC_Pos = 0x1a
	// Bit mask of SYNC field.
	RADIO_INTENCLR_SYNC_Msk = 0x4000000
	// Bit SYNC.
	RADIO_INTENCLR_SYNC = 0x4000000
	// Read: Disabled
	RADIO_INTENCLR_SYNC_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_SYNC_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_SYNC_Clear = 0x1
	// Position of PHYEND field.
	RADIO_INTENCLR_PHYEND_Pos = 0x1b
	// Bit mask of PHYEND field.
	RADIO_INTENCLR_PHYEND_Msk = 0x8000000
	// Bit PHYEND.
	RADIO_INTENCLR_PHYEND = 0x8000000
	// Read: Disabled
	RADIO_INTENCLR_PHYEND_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_PHYEND_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_PHYEND_Clear = 0x1
	// Position of CTEPRESENT field.
	RADIO_INTENCLR_CTEPRESENT_Pos = 0x1c
	// Bit mask of CTEPRESENT field.
	RADIO_INTENCLR_CTEPRESENT_Msk = 0x10000000
	// Bit CTEPRESENT.
	RADIO_INTENCLR_CTEPRESENT = 0x10000000
	// Read: Disabled
	RADIO_INTENCLR_CTEPRESENT_Disabled = 0x0
	// Read: Enabled
	RADIO_INTENCLR_CTEPRESENT_Enabled = 0x1
	// Disable
	RADIO_INTENCLR_CTEPRESENT_Clear = 0x1

	// CRCSTATUS: CRC status
	// Position of CRCSTATUS field.
	RADIO_CRCSTATUS_CRCSTATUS_Pos = 0x0
	// Bit mask of CRCSTATUS field.
	RADIO_CRCSTATUS_CRCSTATUS_Msk = 0x1
	// Bit CRCSTATUS.
	RADIO_CRCSTATUS_CRCSTATUS = 0x1
	// Packet received with CRC error
	RADIO_CRCSTATUS_CRCSTATUS_CRCError = 0x0
	// Packet received with CRC ok
	RADIO_CRCSTATUS_CRCSTATUS_CRCOk = 0x1

	// RXMATCH: Received address
	// Position of RXMATCH field.
	RADIO_RXMATCH_RXMATCH_Pos = 0x0
	// Bit mask of RXMATCH field.
	RADIO_RXMATCH_RXMATCH_Msk = 0x7

	// RXCRC: CRC field of previously received packet
	// Position of RXCRC field.
	RADIO_RXCRC_RXCRC_Pos = 0x0
	// Bit mask of RXCRC field.
	RADIO_RXCRC_RXCRC_Msk = 0xffffff

	// DAI: Device address match index
	// Position of DAI field.
	RADIO_DAI_DAI_Pos = 0x0
	// Bit mask of DAI field.
	RADIO_DAI_DAI_Msk = 0x7

	// PDUSTAT: Payload status
	// Position of PDUSTAT field.
	RADIO_PDUSTAT_PDUSTAT_Pos = 0x0
	// Bit mask of PDUSTAT field.
	RADIO_PDUSTAT_PDUSTAT_Msk = 0x1
	// Bit PDUSTAT.
	RADIO_PDUSTAT_PDUSTAT = 0x1
	// Payload less than PCNF1.MAXLEN
	RADIO_PDUSTAT_PDUSTAT_LessThan = 0x0
	// Payload greater than PCNF1.MAXLEN
	RADIO_PDUSTAT_PDUSTAT_GreaterThan = 0x1
	// Position of CISTAT field.
	RADIO_PDUSTAT_CISTAT_Pos = 0x1
	// Bit mask of CISTAT field.
	RADIO_PDUSTAT_CISTAT_Msk = 0x6
	// Frame is received at 125 kbps
	RADIO_PDUSTAT_CISTAT_LR125kbit = 0x0
	// Frame is received at 500 kbps
	RADIO_PDUSTAT_CISTAT_LR500kbit = 0x1

	// CTESTATUS: CTEInfo parsed from received packet
	// Position of CTETIME field.
	RADIO_CTESTATUS_CTETIME_Pos = 0x0
	// Bit mask of CTETIME field.
	RADIO_CTESTATUS_CTETIME_Msk = 0x1f
	// Position of RFU field.
	RADIO_CTESTATUS_RFU_Pos = 0x5
	// Bit mask of RFU field.
	RADIO_CTESTATUS_RFU_Msk = 0x20
	// Bit RFU.
	RADIO_CTESTATUS_RFU = 0x20
	// Position of CTETYPE field.
	RADIO_CTESTATUS_CTETYPE_Pos = 0x6
	// Bit mask of CTETYPE field.
	RADIO_CTESTATUS_CTETYPE_Msk = 0xc0

	// DFESTATUS: DFE status information
	// Position of SWITCHINGSTATE field.
	RADIO_DFESTATUS_SWITCHINGSTATE_Pos = 0x0
	// Bit mask of SWITCHINGSTATE field.
	RADIO_DFESTATUS_SWITCHINGSTATE_Msk = 0x7
	// Switching state Idle
	RADIO_DFESTATUS_SWITCHINGSTATE_Idle = 0x0
	// Switching state Offset
	RADIO_DFESTATUS_SWITCHINGSTATE_Offset = 0x1
	// Switching state Guard
	RADIO_DFESTATUS_SWITCHINGSTATE_Guard = 0x2
	// Switching state Ref
	RADIO_DFESTATUS_SWITCHINGSTATE_Ref = 0x3
	// Switching state Switching
	RADIO_DFESTATUS_SWITCHINGSTATE_Switching = 0x4
	// Switching state Ending
	RADIO_DFESTATUS_SWITCHINGSTATE_Ending = 0x5
	// Position of SAMPLINGSTATE field.
	RADIO_DFESTATUS_SAMPLINGSTATE_Pos = 0x4
	// Bit mask of SAMPLINGSTATE field.
	RADIO_DFESTATUS_SAMPLINGSTATE_Msk = 0x10
	// Bit SAMPLINGSTATE.
	RADIO_DFESTATUS_SAMPLINGSTATE = 0x10
	// Sampling state Idle
	RADIO_DFESTATUS_SAMPLINGSTATE_Idle = 0x0
	// Sampling state Sampling
	RADIO_DFESTATUS_SAMPLINGSTATE_Sampling = 0x1

	// PACKETPTR: Packet pointer
	// Position of PACKETPTR field.
	RADIO_PACKETPTR_PACKETPTR_Pos = 0x0
	// Bit mask of PACKETPTR field.
	RADIO_PACKETPTR_PACKETPTR_Msk = 0xffffffff

	// FREQUENCY: Frequency
	// Position of FREQUENCY field.
	RADIO_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	RADIO_FREQUENCY_FREQUENCY_Msk = 0x7f
	// Position of MAP field.
	RADIO_FREQUENCY_MAP_Pos = 0x8
	// Bit mask of MAP field.
	RADIO_FREQUENCY_MAP_Msk = 0x100
	// Bit MAP.
	RADIO_FREQUENCY_MAP = 0x100
	// Channel map between 2400 MHZ .. 2500 MHz
	RADIO_FREQUENCY_MAP_Default = 0x0
	// Channel map between 2360 MHZ .. 2460 MHz
	RADIO_FREQUENCY_MAP_Low = 0x1

	// TXPOWER: Output power
	// Position of TXPOWER field.
	RADIO_TXPOWER_TXPOWER_Pos = 0x0
	// Bit mask of TXPOWER field.
	RADIO_TXPOWER_TXPOWER_Msk = 0xff
	// +8 dBm
	RADIO_TXPOWER_TXPOWER_Pos8dBm = 0x8
	// +7 dBm
	RADIO_TXPOWER_TXPOWER_Pos7dBm = 0x7
	// +6 dBm
	RADIO_TXPOWER_TXPOWER_Pos6dBm = 0x6
	// +5 dBm
	RADIO_TXPOWER_TXPOWER_Pos5dBm = 0x5
	// +4 dBm
	RADIO_TXPOWER_TXPOWER_Pos4dBm = 0x4
	// +3 dBm
	RADIO_TXPOWER_TXPOWER_Pos3dBm = 0x3
	// +2 dBm
	RADIO_TXPOWER_TXPOWER_Pos2dBm = 0x2
	// 0 dBm
	RADIO_TXPOWER_TXPOWER_0dBm = 0x0
	// -4 dBm
	RADIO_TXPOWER_TXPOWER_Neg4dBm = 0xfc
	// -8 dBm
	RADIO_TXPOWER_TXPOWER_Neg8dBm = 0xf8
	// -12 dBm
	RADIO_TXPOWER_TXPOWER_Neg12dBm = 0xf4
	// -16 dBm
	RADIO_TXPOWER_TXPOWER_Neg16dBm = 0xf0
	// -20 dBm
	RADIO_TXPOWER_TXPOWER_Neg20dBm = 0xec
	// Deprecated enumerator - -40 dBm
	RADIO_TXPOWER_TXPOWER_Neg30dBm = 0xe2
	// -40 dBm
	RADIO_TXPOWER_TXPOWER_Neg40dBm = 0xd8

	// MODE: Data rate and modulation
	// Position of MODE field.
	RADIO_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	RADIO_MODE_MODE_Msk = 0xf
	// 1 Mbps Nordic proprietary radio mode
	RADIO_MODE_MODE_Nrf_1Mbit = 0x0
	// 2 Mbps Nordic proprietary radio mode
	RADIO_MODE_MODE_Nrf_2Mbit = 0x1
	// 1 Mbps BLE
	RADIO_MODE_MODE_Ble_1Mbit = 0x3
	// 2 Mbps BLE
	RADIO_MODE_MODE_Ble_2Mbit = 0x4
	// Long range 125 kbps TX, 125 kbps and 500 kbps RX
	RADIO_MODE_MODE_Ble_LR125Kbit = 0x5
	// Long range 500 kbps TX, 125 kbps and 500 kbps RX
	RADIO_MODE_MODE_Ble_LR500Kbit = 0x6
	// IEEE 802.15.4-2006 250 kbps
	RADIO_MODE_MODE_Ieee802154_250Kbit = 0xf

	// PCNF0: Packet configuration register 0
	// Position of LFLEN field.
	RADIO_PCNF0_LFLEN_Pos = 0x0
	// Bit mask of LFLEN field.
	RADIO_PCNF0_LFLEN_Msk = 0xf
	// Position of S0LEN field.
	RADIO_PCNF0_S0LEN_Pos = 0x8
	// Bit mask of S0LEN field.
	RADIO_PCNF0_S0LEN_Msk = 0x100
	// Bit S0LEN.
	RADIO_PCNF0_S0LEN = 0x100
	// Position of S1LEN field.
	RADIO_PCNF0_S1LEN_Pos = 0x10
	// Bit mask of S1LEN field.
	RADIO_PCNF0_S1LEN_Msk = 0xf0000
	// Position of S1INCL field.
	RADIO_PCNF0_S1INCL_Pos = 0x14
	// Bit mask of S1INCL field.
	RADIO_PCNF0_S1INCL_Msk = 0x100000
	// Bit S1INCL.
	RADIO_PCNF0_S1INCL = 0x100000
	// Include S1 field in RAM only if S1LEN &gt; 0
	RADIO_PCNF0_S1INCL_Automatic = 0x0
	// Always include S1 field in RAM independent of S1LEN
	RADIO_PCNF0_S1INCL_Include = 0x1
	// Position of CILEN field.
	RADIO_PCNF0_CILEN_Pos = 0x16
	// Bit mask of CILEN field.
	RADIO_PCNF0_CILEN_Msk = 0xc00000
	// Position of PLEN field.
	RADIO_PCNF0_PLEN_Pos = 0x18
	// Bit mask of PLEN field.
	RADIO_PCNF0_PLEN_Msk = 0x3000000
	// 8-bit preamble
	RADIO_PCNF0_PLEN_8bit = 0x0
	// 16-bit preamble
	RADIO_PCNF0_PLEN_16bit = 0x1
	// 32-bit zero preamble - used for IEEE 802.15.4
	RADIO_PCNF0_PLEN_32bitZero = 0x2
	// Preamble - used for BLE long range
	RADIO_PCNF0_PLEN_LongRange = 0x3
	// Position of CRCINC field.
	RADIO_PCNF0_CRCINC_Pos = 0x1a
	// Bit mask of CRCINC field.
	RADIO_PCNF0_CRCINC_Msk = 0x4000000
	// Bit CRCINC.
	RADIO_PCNF0_CRCINC = 0x4000000
	// LENGTH does not contain CRC
	RADIO_PCNF0_CRCINC_Exclude = 0x0
	// LENGTH includes CRC
	RADIO_PCNF0_CRCINC_Include = 0x1
	// Position of TERMLEN field.
	RADIO_PCNF0_TERMLEN_Pos = 0x1d
	// Bit mask of TERMLEN field.
	RADIO_PCNF0_TERMLEN_Msk = 0x60000000

	// PCNF1: Packet configuration register 1
	// Position of MAXLEN field.
	RADIO_PCNF1_MAXLEN_Pos = 0x0
	// Bit mask of MAXLEN field.
	RADIO_PCNF1_MAXLEN_Msk = 0xff
	// Position of STATLEN field.
	RADIO_PCNF1_STATLEN_Pos = 0x8
	// Bit mask of STATLEN field.
	RADIO_PCNF1_STATLEN_Msk = 0xff00
	// Position of BALEN field.
	RADIO_PCNF1_BALEN_Pos = 0x10
	// Bit mask of BALEN field.
	RADIO_PCNF1_BALEN_Msk = 0x70000
	// Position of ENDIAN field.
	RADIO_PCNF1_ENDIAN_Pos = 0x18
	// Bit mask of ENDIAN field.
	RADIO_PCNF1_ENDIAN_Msk = 0x1000000
	// Bit ENDIAN.
	RADIO_PCNF1_ENDIAN = 0x1000000
	// Least significant bit on air first
	RADIO_PCNF1_ENDIAN_Little = 0x0
	// Most significant bit on air first
	RADIO_PCNF1_ENDIAN_Big = 0x1
	// Position of WHITEEN field.
	RADIO_PCNF1_WHITEEN_Pos = 0x19
	// Bit mask of WHITEEN field.
	RADIO_PCNF1_WHITEEN_Msk = 0x2000000
	// Bit WHITEEN.
	RADIO_PCNF1_WHITEEN = 0x2000000
	// Disable
	RADIO_PCNF1_WHITEEN_Disabled = 0x0
	// Enable
	RADIO_PCNF1_WHITEEN_Enabled = 0x1

	// BASE0: Base address 0
	// Position of BASE0 field.
	RADIO_BASE0_BASE0_Pos = 0x0
	// Bit mask of BASE0 field.
	RADIO_BASE0_BASE0_Msk = 0xffffffff

	// BASE1: Base address 1
	// Position of BASE1 field.
	RADIO_BASE1_BASE1_Pos = 0x0
	// Bit mask of BASE1 field.
	RADIO_BASE1_BASE1_Msk = 0xffffffff

	// PREFIX0: Prefixes bytes for logical addresses 0-3
	// Position of AP0 field.
	RADIO_PREFIX0_AP0_Pos = 0x0
	// Bit mask of AP0 field.
	RADIO_PREFIX0_AP0_Msk = 0xff
	// Position of AP1 field.
	RADIO_PREFIX0_AP1_Pos = 0x8
	// Bit mask of AP1 field.
	RADIO_PREFIX0_AP1_Msk = 0xff00
	// Position of AP2 field.
	RADIO_PREFIX0_AP2_Pos = 0x10
	// Bit mask of AP2 field.
	RADIO_PREFIX0_AP2_Msk = 0xff0000
	// Position of AP3 field.
	RADIO_PREFIX0_AP3_Pos = 0x18
	// Bit mask of AP3 field.
	RADIO_PREFIX0_AP3_Msk = 0xff000000

	// PREFIX1: Prefixes bytes for logical addresses 4-7
	// Position of AP4 field.
	RADIO_PREFIX1_AP4_Pos = 0x0
	// Bit mask of AP4 field.
	RADIO_PREFIX1_AP4_Msk = 0xff
	// Position of AP5 field.
	RADIO_PREFIX1_AP5_Pos = 0x8
	// Bit mask of AP5 field.
	RADIO_PREFIX1_AP5_Msk = 0xff00
	// Position of AP6 field.
	RADIO_PREFIX1_AP6_Pos = 0x10
	// Bit mask of AP6 field.
	RADIO_PREFIX1_AP6_Msk = 0xff0000
	// Position of AP7 field.
	RADIO_PREFIX1_AP7_Pos = 0x18
	// Bit mask of AP7 field.
	RADIO_PREFIX1_AP7_Msk = 0xff000000

	// TXADDRESS: Transmit address select
	// Position of TXADDRESS field.
	RADIO_TXADDRESS_TXADDRESS_Pos = 0x0
	// Bit mask of TXADDRESS field.
	RADIO_TXADDRESS_TXADDRESS_Msk = 0x7

	// RXADDRESSES: Receive address select
	// Position of ADDR0 field.
	RADIO_RXADDRESSES_ADDR0_Pos = 0x0
	// Bit mask of ADDR0 field.
	RADIO_RXADDRESSES_ADDR0_Msk = 0x1
	// Bit ADDR0.
	RADIO_RXADDRESSES_ADDR0 = 0x1
	// Disable
	RADIO_RXADDRESSES_ADDR0_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR0_Enabled = 0x1
	// Position of ADDR1 field.
	RADIO_RXADDRESSES_ADDR1_Pos = 0x1
	// Bit mask of ADDR1 field.
	RADIO_RXADDRESSES_ADDR1_Msk = 0x2
	// Bit ADDR1.
	RADIO_RXADDRESSES_ADDR1 = 0x2
	// Disable
	RADIO_RXADDRESSES_ADDR1_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR1_Enabled = 0x1
	// Position of ADDR2 field.
	RADIO_RXADDRESSES_ADDR2_Pos = 0x2
	// Bit mask of ADDR2 field.
	RADIO_RXADDRESSES_ADDR2_Msk = 0x4
	// Bit ADDR2.
	RADIO_RXADDRESSES_ADDR2 = 0x4
	// Disable
	RADIO_RXADDRESSES_ADDR2_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR2_Enabled = 0x1
	// Position of ADDR3 field.
	RADIO_RXADDRESSES_ADDR3_Pos = 0x3
	// Bit mask of ADDR3 field.
	RADIO_RXADDRESSES_ADDR3_Msk = 0x8
	// Bit ADDR3.
	RADIO_RXADDRESSES_ADDR3 = 0x8
	// Disable
	RADIO_RXADDRESSES_ADDR3_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR3_Enabled = 0x1
	// Position of ADDR4 field.
	RADIO_RXADDRESSES_ADDR4_Pos = 0x4
	// Bit mask of ADDR4 field.
	RADIO_RXADDRESSES_ADDR4_Msk = 0x10
	// Bit ADDR4.
	RADIO_RXADDRESSES_ADDR4 = 0x10
	// Disable
	RADIO_RXADDRESSES_ADDR4_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR4_Enabled = 0x1
	// Position of ADDR5 field.
	RADIO_RXADDRESSES_ADDR5_Pos = 0x5
	// Bit mask of ADDR5 field.
	RADIO_RXADDRESSES_ADDR5_Msk = 0x20
	// Bit ADDR5.
	RADIO_RXADDRESSES_ADDR5 = 0x20
	// Disable
	RADIO_RXADDRESSES_ADDR5_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR5_Enabled = 0x1
	// Position of ADDR6 field.
	RADIO_RXADDRESSES_ADDR6_Pos = 0x6
	// Bit mask of ADDR6 field.
	RADIO_RXADDRESSES_ADDR6_Msk = 0x40
	// Bit ADDR6.
	RADIO_RXADDRESSES_ADDR6 = 0x40
	// Disable
	RADIO_RXADDRESSES_ADDR6_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR6_Enabled = 0x1
	// Position of ADDR7 field.
	RADIO_RXADDRESSES_ADDR7_Pos = 0x7
	// Bit mask of ADDR7 field.
	RADIO_RXADDRESSES_ADDR7_Msk = 0x80
	// Bit ADDR7.
	RADIO_RXADDRESSES_ADDR7 = 0x80
	// Disable
	RADIO_RXADDRESSES_ADDR7_Disabled = 0x0
	// Enable
	RADIO_RXADDRESSES_ADDR7_Enabled = 0x1

	// CRCCNF: CRC configuration
	// Position of LEN field.
	RADIO_CRCCNF_LEN_Pos = 0x0
	// Bit mask of LEN field.
	RADIO_CRCCNF_LEN_Msk = 0x3
	// CRC length is zero and CRC calculation is disabled
	RADIO_CRCCNF_LEN_Disabled = 0x0
	// CRC length is one byte and CRC calculation is enabled
	RADIO_CRCCNF_LEN_One = 0x1
	// CRC length is two bytes and CRC calculation is enabled
	RADIO_CRCCNF_LEN_Two = 0x2
	// CRC length is three bytes and CRC calculation is enabled
	RADIO_CRCCNF_LEN_Three = 0x3
	// Position of SKIPADDR field.
	RADIO_CRCCNF_SKIPADDR_Pos = 0x8
	// Bit mask of SKIPADDR field.
	RADIO_CRCCNF_SKIPADDR_Msk = 0x300
	// CRC calculation includes address field
	RADIO_CRCCNF_SKIPADDR_Include = 0x0
	// CRC calculation does not include address field. The CRC calculation will start at the first byte after the address.
	RADIO_CRCCNF_SKIPADDR_Skip = 0x1
	// CRC calculation as per 802.15.4 standard. Starting at first byte after length field.
	RADIO_CRCCNF_SKIPADDR_Ieee802154 = 0x2

	// CRCPOLY: CRC polynomial
	// Position of CRCPOLY field.
	RADIO_CRCPOLY_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	RADIO_CRCPOLY_CRCPOLY_Msk = 0xffffff

	// CRCINIT: CRC initial value
	// Position of CRCINIT field.
	RADIO_CRCINIT_CRCINIT_Pos = 0x0
	// Bit mask of CRCINIT field.
	RADIO_CRCINIT_CRCINIT_Msk = 0xffffff

	// TIFS: Interframe spacing in us
	// Position of TIFS field.
	RADIO_TIFS_TIFS_Pos = 0x0
	// Bit mask of TIFS field.
	RADIO_TIFS_TIFS_Msk = 0x3ff

	// RSSISAMPLE: RSSI sample
	// Position of RSSISAMPLE field.
	RADIO_RSSISAMPLE_RSSISAMPLE_Pos = 0x0
	// Bit mask of RSSISAMPLE field.
	RADIO_RSSISAMPLE_RSSISAMPLE_Msk = 0x7f

	// STATE: Current radio state
	// Position of STATE field.
	RADIO_STATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	RADIO_STATE_STATE_Msk = 0xf
	// RADIO is in the Disabled state
	RADIO_STATE_STATE_Disabled = 0x0
	// RADIO is in the RXRU state
	RADIO_STATE_STATE_RxRu = 0x1
	// RADIO is in the RXIDLE state
	RADIO_STATE_STATE_RxIdle = 0x2
	// RADIO is in the RX state
	RADIO_STATE_STATE_Rx = 0x3
	// RADIO is in the RXDISABLED state
	RADIO_STATE_STATE_RxDisable = 0x4
	// RADIO is in the TXRU state
	RADIO_STATE_STATE_TxRu = 0x9
	// RADIO is in the TXIDLE state
	RADIO_STATE_STATE_TxIdle = 0xa
	// RADIO is in the TX state
	RADIO_STATE_STATE_Tx = 0xb
	// RADIO is in the TXDISABLED state
	RADIO_STATE_STATE_TxDisable = 0xc

	// DATAWHITEIV: Data whitening initial value
	// Position of DATAWHITEIV field.
	RADIO_DATAWHITEIV_DATAWHITEIV_Pos = 0x0
	// Bit mask of DATAWHITEIV field.
	RADIO_DATAWHITEIV_DATAWHITEIV_Msk = 0x7f

	// BCC: Bit counter compare
	// Position of BCC field.
	RADIO_BCC_BCC_Pos = 0x0
	// Bit mask of BCC field.
	RADIO_BCC_BCC_Msk = 0xffffffff

	// DAB: Description collection: Device address base segment n
	// Position of DAB field.
	RADIO_DAB_DAB_Pos = 0x0
	// Bit mask of DAB field.
	RADIO_DAB_DAB_Msk = 0xffffffff

	// DAP: Description collection: Device address prefix n
	// Position of DAP field.
	RADIO_DAP_DAP_Pos = 0x0
	// Bit mask of DAP field.
	RADIO_DAP_DAP_Msk = 0xffff

	// DACNF: Device address match configuration
	// Position of ENA0 field.
	RADIO_DACNF_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	RADIO_DACNF_ENA0_Msk = 0x1
	// Bit ENA0.
	RADIO_DACNF_ENA0 = 0x1
	// Disabled
	RADIO_DACNF_ENA0_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA0_Enabled = 0x1
	// Position of ENA1 field.
	RADIO_DACNF_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	RADIO_DACNF_ENA1_Msk = 0x2
	// Bit ENA1.
	RADIO_DACNF_ENA1 = 0x2
	// Disabled
	RADIO_DACNF_ENA1_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA1_Enabled = 0x1
	// Position of ENA2 field.
	RADIO_DACNF_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	RADIO_DACNF_ENA2_Msk = 0x4
	// Bit ENA2.
	RADIO_DACNF_ENA2 = 0x4
	// Disabled
	RADIO_DACNF_ENA2_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA2_Enabled = 0x1
	// Position of ENA3 field.
	RADIO_DACNF_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	RADIO_DACNF_ENA3_Msk = 0x8
	// Bit ENA3.
	RADIO_DACNF_ENA3 = 0x8
	// Disabled
	RADIO_DACNF_ENA3_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA3_Enabled = 0x1
	// Position of ENA4 field.
	RADIO_DACNF_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	RADIO_DACNF_ENA4_Msk = 0x10
	// Bit ENA4.
	RADIO_DACNF_ENA4 = 0x10
	// Disabled
	RADIO_DACNF_ENA4_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA4_Enabled = 0x1
	// Position of ENA5 field.
	RADIO_DACNF_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	RADIO_DACNF_ENA5_Msk = 0x20
	// Bit ENA5.
	RADIO_DACNF_ENA5 = 0x20
	// Disabled
	RADIO_DACNF_ENA5_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA5_Enabled = 0x1
	// Position of ENA6 field.
	RADIO_DACNF_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	RADIO_DACNF_ENA6_Msk = 0x40
	// Bit ENA6.
	RADIO_DACNF_ENA6 = 0x40
	// Disabled
	RADIO_DACNF_ENA6_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA6_Enabled = 0x1
	// Position of ENA7 field.
	RADIO_DACNF_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	RADIO_DACNF_ENA7_Msk = 0x80
	// Bit ENA7.
	RADIO_DACNF_ENA7 = 0x80
	// Disabled
	RADIO_DACNF_ENA7_Disabled = 0x0
	// Enabled
	RADIO_DACNF_ENA7_Enabled = 0x1
	// Position of TXADD0 field.
	RADIO_DACNF_TXADD0_Pos = 0x8
	// Bit mask of TXADD0 field.
	RADIO_DACNF_TXADD0_Msk = 0x100
	// Bit TXADD0.
	RADIO_DACNF_TXADD0 = 0x100
	// Position of TXADD1 field.
	RADIO_DACNF_TXADD1_Pos = 0x9
	// Bit mask of TXADD1 field.
	RADIO_DACNF_TXADD1_Msk = 0x200
	// Bit TXADD1.
	RADIO_DACNF_TXADD1 = 0x200
	// Position of TXADD2 field.
	RADIO_DACNF_TXADD2_Pos = 0xa
	// Bit mask of TXADD2 field.
	RADIO_DACNF_TXADD2_Msk = 0x400
	// Bit TXADD2.
	RADIO_DACNF_TXADD2 = 0x400
	// Position of TXADD3 field.
	RADIO_DACNF_TXADD3_Pos = 0xb
	// Bit mask of TXADD3 field.
	RADIO_DACNF_TXADD3_Msk = 0x800
	// Bit TXADD3.
	RADIO_DACNF_TXADD3 = 0x800
	// Position of TXADD4 field.
	RADIO_DACNF_TXADD4_Pos = 0xc
	// Bit mask of TXADD4 field.
	RADIO_DACNF_TXADD4_Msk = 0x1000
	// Bit TXADD4.
	RADIO_DACNF_TXADD4 = 0x1000
	// Position of TXADD5 field.
	RADIO_DACNF_TXADD5_Pos = 0xd
	// Bit mask of TXADD5 field.
	RADIO_DACNF_TXADD5_Msk = 0x2000
	// Bit TXADD5.
	RADIO_DACNF_TXADD5 = 0x2000
	// Position of TXADD6 field.
	RADIO_DACNF_TXADD6_Pos = 0xe
	// Bit mask of TXADD6 field.
	RADIO_DACNF_TXADD6_Msk = 0x4000
	// Bit TXADD6.
	RADIO_DACNF_TXADD6 = 0x4000
	// Position of TXADD7 field.
	RADIO_DACNF_TXADD7_Pos = 0xf
	// Bit mask of TXADD7 field.
	RADIO_DACNF_TXADD7_Msk = 0x8000
	// Bit TXADD7.
	RADIO_DACNF_TXADD7 = 0x8000

	// MHRMATCHCONF: Search pattern configuration
	// Position of MHRMATCHCONF field.
	RADIO_MHRMATCHCONF_MHRMATCHCONF_Pos = 0x0
	// Bit mask of MHRMATCHCONF field.
	RADIO_MHRMATCHCONF_MHRMATCHCONF_Msk = 0xffffffff

	// MHRMATCHMAS: Pattern mask
	// Position of MHRMATCHMAS field.
	RADIO_MHRMATCHMAS_MHRMATCHMAS_Pos = 0x0
	// Bit mask of MHRMATCHMAS field.
	RADIO_MHRMATCHMAS_MHRMATCHMAS_Msk = 0xffffffff

	// MODECNF0: Radio mode configuration register 0
	// Position of RU field.
	RADIO_MODECNF0_RU_Pos = 0x0
	// Bit mask of RU field.
	RADIO_MODECNF0_RU_Msk = 0x1
	// Bit RU.
	RADIO_MODECNF0_RU = 0x1
	// Default ramp-up time (tRXEN and tTXEN), compatible with firmware written for nRF51
	RADIO_MODECNF0_RU_Default = 0x0
	// Fast ramp-up (tRXEN,FAST and tTXEN,FAST), see electrical specification for more information
	RADIO_MODECNF0_RU_Fast = 0x1
	// Position of DTX field.
	RADIO_MODECNF0_DTX_Pos = 0x8
	// Bit mask of DTX field.
	RADIO_MODECNF0_DTX_Msk = 0x300
	// Transmit '1'
	RADIO_MODECNF0_DTX_B1 = 0x0
	// Transmit '0'
	RADIO_MODECNF0_DTX_B0 = 0x1
	// Transmit center frequency
	RADIO_MODECNF0_DTX_Center = 0x2

	// SFD: IEEE 802.15.4 start of frame delimiter
	// Position of SFD field.
	RADIO_SFD_SFD_Pos = 0x0
	// Bit mask of SFD field.
	RADIO_SFD_SFD_Msk = 0xff

	// EDCNT: IEEE 802.15.4 energy detect loop count
	// Position of EDCNT field.
	RADIO_EDCNT_EDCNT_Pos = 0x0
	// Bit mask of EDCNT field.
	RADIO_EDCNT_EDCNT_Msk = 0x1fffff

	// EDSAMPLE: IEEE 802.15.4 energy detect level
	// Position of EDLVL field.
	RADIO_EDSAMPLE_EDLVL_Pos = 0x0
	// Bit mask of EDLVL field.
	RADIO_EDSAMPLE_EDLVL_Msk = 0xff

	// CCACTRL: IEEE 802.15.4 clear channel assessment control
	// Position of CCAMODE field.
	RADIO_CCACTRL_CCAMODE_Pos = 0x0
	// Bit mask of CCAMODE field.
	RADIO_CCACTRL_CCAMODE_Msk = 0x7
	// Energy above threshold
	RADIO_CCACTRL_CCAMODE_EdMode = 0x0
	// Carrier seen
	RADIO_CCACTRL_CCAMODE_CarrierMode = 0x1
	// Energy above threshold AND carrier seen
	RADIO_CCACTRL_CCAMODE_CarrierAndEdMode = 0x2
	// Energy above threshold OR carrier seen
	RADIO_CCACTRL_CCAMODE_CarrierOrEdMode = 0x3
	// Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging.
	RADIO_CCACTRL_CCAMODE_EdModeTest1 = 0x4
	// Position of CCAEDTHRES field.
	RADIO_CCACTRL_CCAEDTHRES_Pos = 0x8
	// Bit mask of CCAEDTHRES field.
	RADIO_CCACTRL_CCAEDTHRES_Msk = 0xff00
	// Position of CCACORRTHRES field.
	RADIO_CCACTRL_CCACORRTHRES_Pos = 0x10
	// Bit mask of CCACORRTHRES field.
	RADIO_CCACTRL_CCACORRTHRES_Msk = 0xff0000
	// Position of CCACORRCNT field.
	RADIO_CCACTRL_CCACORRCNT_Pos = 0x18
	// Bit mask of CCACORRCNT field.
	RADIO_CCACTRL_CCACORRCNT_Msk = 0xff000000

	// DFEMODE: Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)
	// Position of DFEOPMODE field.
	RADIO_DFEMODE_DFEOPMODE_Pos = 0x0
	// Bit mask of DFEOPMODE field.
	RADIO_DFEMODE_DFEOPMODE_Msk = 0x3
	// Direction finding mode disabled
	RADIO_DFEMODE_DFEOPMODE_Disabled = 0x0
	// Direction finding mode set to AoD
	RADIO_DFEMODE_DFEOPMODE_AoD = 0x2
	// Direction finding mode set to AoA
	RADIO_DFEMODE_DFEOPMODE_AoA = 0x3

	// CTEINLINECONF: Configuration for CTE inline mode
	// Position of CTEINLINECTRLEN field.
	RADIO_CTEINLINECONF_CTEINLINECTRLEN_Pos = 0x0
	// Bit mask of CTEINLINECTRLEN field.
	RADIO_CTEINLINECONF_CTEINLINECTRLEN_Msk = 0x1
	// Bit CTEINLINECTRLEN.
	RADIO_CTEINLINECONF_CTEINLINECTRLEN = 0x1
	// Parsing of CTEInfo is enabled
	RADIO_CTEINLINECONF_CTEINLINECTRLEN_Enabled = 0x1
	// Parsing of CTEInfo is disabled
	RADIO_CTEINLINECONF_CTEINLINECTRLEN_Disabled = 0x0
	// Position of CTEINFOINS1 field.
	RADIO_CTEINLINECONF_CTEINFOINS1_Pos = 0x3
	// Bit mask of CTEINFOINS1 field.
	RADIO_CTEINLINECONF_CTEINFOINS1_Msk = 0x8
	// Bit CTEINFOINS1.
	RADIO_CTEINLINECONF_CTEINFOINS1 = 0x8
	// CTEInfo is in S1 byte (data PDU)
	RADIO_CTEINLINECONF_CTEINFOINS1_InS1 = 0x1
	// CTEInfo is NOT in S1 byte (advertising PDU)
	RADIO_CTEINLINECONF_CTEINFOINS1_NotInS1 = 0x0
	// Position of CTEERRORHANDLING field.
	RADIO_CTEINLINECONF_CTEERRORHANDLING_Pos = 0x4
	// Bit mask of CTEERRORHANDLING field.
	RADIO_CTEINLINECONF_CTEERRORHANDLING_Msk = 0x10
	// Bit CTEERRORHANDLING.
	RADIO_CTEINLINECONF_CTEERRORHANDLING = 0x10
	// Sampling and antenna switching also when CRC is not OK
	RADIO_CTEINLINECONF_CTEERRORHANDLING_Yes = 0x1
	// No sampling and antenna switching when CRC is not OK
	RADIO_CTEINLINECONF_CTEERRORHANDLING_No = 0x0
	// Position of CTETIMEVALIDRANGE field.
	RADIO_CTEINLINECONF_CTETIMEVALIDRANGE_Pos = 0x6
	// Bit mask of CTETIMEVALIDRANGE field.
	RADIO_CTEINLINECONF_CTETIMEVALIDRANGE_Msk = 0xc0
	// 20 in 8us unit (default) Set to 20 if parsed CTETime is larger han 20
	RADIO_CTEINLINECONF_CTETIMEVALIDRANGE_20 = 0x0
	// 31 in 8us unit
	RADIO_CTEINLINECONF_CTETIMEVALIDRANGE_31 = 0x1
	// 63 in 8us unit
	RADIO_CTEINLINECONF_CTETIMEVALIDRANGE_63 = 0x2
	// Position of CTEINLINERXMODE1US field.
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_Pos = 0xa
	// Bit mask of CTEINLINERXMODE1US field.
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_Msk = 0x1c00
	// 4us
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_4us = 0x1
	// 2us
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_2us = 0x2
	// 1us
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_1us = 0x3
	// 0.5us
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_500ns = 0x4
	// 0.25us
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_250ns = 0x5
	// 0.125us
	RADIO_CTEINLINECONF_CTEINLINERXMODE1US_125ns = 0x6
	// Position of CTEINLINERXMODE2US field.
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_Pos = 0xd
	// Bit mask of CTEINLINERXMODE2US field.
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_Msk = 0xe000
	// 4us
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_4us = 0x1
	// 2us
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_2us = 0x2
	// 1us
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_1us = 0x3
	// 0.5us
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_500ns = 0x4
	// 0.25us
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_250ns = 0x5
	// 0.125us
	RADIO_CTEINLINECONF_CTEINLINERXMODE2US_125ns = 0x6
	// Position of S0CONF field.
	RADIO_CTEINLINECONF_S0CONF_Pos = 0x10
	// Bit mask of S0CONF field.
	RADIO_CTEINLINECONF_S0CONF_Msk = 0xff0000
	// Position of S0MASK field.
	RADIO_CTEINLINECONF_S0MASK_Pos = 0x18
	// Bit mask of S0MASK field.
	RADIO_CTEINLINECONF_S0MASK_Msk = 0xff000000

	// DFECTRL1: Various configuration for Direction finding
	// Position of NUMBEROF8US field.
	RADIO_DFECTRL1_NUMBEROF8US_Pos = 0x0
	// Bit mask of NUMBEROF8US field.
	RADIO_DFECTRL1_NUMBEROF8US_Msk = 0x3f
	// Position of DFEINEXTENSION field.
	RADIO_DFECTRL1_DFEINEXTENSION_Pos = 0x7
	// Bit mask of DFEINEXTENSION field.
	RADIO_DFECTRL1_DFEINEXTENSION_Msk = 0x80
	// Bit DFEINEXTENSION.
	RADIO_DFECTRL1_DFEINEXTENSION = 0x80
	// AoA/AoD procedure triggered at end of CRC
	RADIO_DFECTRL1_DFEINEXTENSION_CRC = 0x1
	// Antenna switching/sampling is done in the packet payload
	RADIO_DFECTRL1_DFEINEXTENSION_Payload = 0x0
	// Position of TSWITCHSPACING field.
	RADIO_DFECTRL1_TSWITCHSPACING_Pos = 0x8
	// Bit mask of TSWITCHSPACING field.
	RADIO_DFECTRL1_TSWITCHSPACING_Msk = 0x700
	// 4us
	RADIO_DFECTRL1_TSWITCHSPACING_4us = 0x1
	// 2us
	RADIO_DFECTRL1_TSWITCHSPACING_2us = 0x2
	// 1us
	RADIO_DFECTRL1_TSWITCHSPACING_1us = 0x3
	// Position of TSAMPLESPACINGREF field.
	RADIO_DFECTRL1_TSAMPLESPACINGREF_Pos = 0xc
	// Bit mask of TSAMPLESPACINGREF field.
	RADIO_DFECTRL1_TSAMPLESPACINGREF_Msk = 0x7000
	// 4us
	RADIO_DFECTRL1_TSAMPLESPACINGREF_4us = 0x1
	// 2us
	RADIO_DFECTRL1_TSAMPLESPACINGREF_2us = 0x2
	// 1us
	RADIO_DFECTRL1_TSAMPLESPACINGREF_1us = 0x3
	// 0.5us
	RADIO_DFECTRL1_TSAMPLESPACINGREF_500ns = 0x4
	// 0.25us
	RADIO_DFECTRL1_TSAMPLESPACINGREF_250ns = 0x5
	// 0.125us
	RADIO_DFECTRL1_TSAMPLESPACINGREF_125ns = 0x6
	// Position of SAMPLETYPE field.
	RADIO_DFECTRL1_SAMPLETYPE_Pos = 0xf
	// Bit mask of SAMPLETYPE field.
	RADIO_DFECTRL1_SAMPLETYPE_Msk = 0x8000
	// Bit SAMPLETYPE.
	RADIO_DFECTRL1_SAMPLETYPE = 0x8000
	// Complex samples in I and Q
	RADIO_DFECTRL1_SAMPLETYPE_IQ = 0x0
	// Complex samples as magnitude and phase
	RADIO_DFECTRL1_SAMPLETYPE_MagPhase = 0x1
	// Position of TSAMPLESPACING field.
	RADIO_DFECTRL1_TSAMPLESPACING_Pos = 0x10
	// Bit mask of TSAMPLESPACING field.
	RADIO_DFECTRL1_TSAMPLESPACING_Msk = 0x70000
	// 4us
	RADIO_DFECTRL1_TSAMPLESPACING_4us = 0x1
	// 2us
	RADIO_DFECTRL1_TSAMPLESPACING_2us = 0x2
	// 1us
	RADIO_DFECTRL1_TSAMPLESPACING_1us = 0x3
	// 0.5us
	RADIO_DFECTRL1_TSAMPLESPACING_500ns = 0x4
	// 0.25us
	RADIO_DFECTRL1_TSAMPLESPACING_250ns = 0x5
	// 0.125us
	RADIO_DFECTRL1_TSAMPLESPACING_125ns = 0x6
	// Position of REPEATPATTERN field.
	RADIO_DFECTRL1_REPEATPATTERN_Pos = 0x14
	// Bit mask of REPEATPATTERN field.
	RADIO_DFECTRL1_REPEATPATTERN_Msk = 0xf00000
	// Do not repeat (1 time in total)
	RADIO_DFECTRL1_REPEATPATTERN_NoRepeat = 0x0
	// Position of AGCBACKOFFGAIN field.
	RADIO_DFECTRL1_AGCBACKOFFGAIN_Pos = 0x18
	// Bit mask of AGCBACKOFFGAIN field.
	RADIO_DFECTRL1_AGCBACKOFFGAIN_Msk = 0xf000000

	// DFECTRL2: Start offset for Direction finding
	// Position of TSWITCHOFFSET field.
	RADIO_DFECTRL2_TSWITCHOFFSET_Pos = 0x0
	// Bit mask of TSWITCHOFFSET field.
	RADIO_DFECTRL2_TSWITCHOFFSET_Msk = 0x1fff
	// Position of TSAMPLEOFFSET field.
	RADIO_DFECTRL2_TSAMPLEOFFSET_Pos = 0x10
	// Bit mask of TSAMPLEOFFSET field.
	RADIO_DFECTRL2_TSAMPLEOFFSET_Msk = 0xfff0000

	// SWITCHPATTERN: GPIO patterns to be used for each antenna
	// Position of SWITCHPATTERN field.
	RADIO_SWITCHPATTERN_SWITCHPATTERN_Pos = 0x0
	// Bit mask of SWITCHPATTERN field.
	RADIO_SWITCHPATTERN_SWITCHPATTERN_Msk = 0xff

	// CLEARPATTERN: Clear the GPIO pattern array for antenna control
	// Position of CLEARPATTERN field.
	RADIO_CLEARPATTERN_CLEARPATTERN_Pos = 0x0
	// Bit mask of CLEARPATTERN field.
	RADIO_CLEARPATTERN_CLEARPATTERN_Msk = 0x1
	// Bit CLEARPATTERN.
	RADIO_CLEARPATTERN_CLEARPATTERN = 0x1
	// Clear the GPIO pattern
	RADIO_CLEARPATTERN_CLEARPATTERN_Clear = 0x1

	// PSEL.DFEGPIO: Description collection: Pin select for DFE pin n
	// Position of PIN field.
	RADIO_PSEL_DFEGPIO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	RADIO_PSEL_DFEGPIO_PIN_Msk = 0x1f
	// Position of CONNECT field.
	RADIO_PSEL_DFEGPIO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	RADIO_PSEL_DFEGPIO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	RADIO_PSEL_DFEGPIO_CONNECT = 0x80000000
	// Disconnect
	RADIO_PSEL_DFEGPIO_CONNECT_Disconnected = 0x1
	// Connect
	RADIO_PSEL_DFEGPIO_CONNECT_Connected = 0x0

	// DFEPACKET.PTR: Data pointer
	// Position of PTR field.
	RADIO_DFEPACKET_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	RADIO_DFEPACKET_PTR_PTR_Msk = 0xffffffff

	// DFEPACKET.MAXCNT: Maximum number of buffer words to transfer
	// Position of MAXCNT field.
	RADIO_DFEPACKET_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	RADIO_DFEPACKET_MAXCNT_MAXCNT_Msk = 0x3fff

	// DFEPACKET.AMOUNT: Number of samples transferred in the last transaction
	// Position of AMOUNT field.
	RADIO_DFEPACKET_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	RADIO_DFEPACKET_AMOUNT_AMOUNT_Msk = 0xffff

	// POWER: Peripheral power control
	// Position of POWER field.
	RADIO_POWER_POWER_Pos = 0x0
	// Bit mask of POWER field.
	RADIO_POWER_POWER_Msk = 0x1
	// Bit POWER.
	RADIO_POWER_POWER = 0x1
	// Peripheral is powered off
	RADIO_POWER_POWER_Disabled = 0x0
	// Peripheral is powered on
	RADIO_POWER_POWER_Enabled = 0x1
)

// Constants for UART0: Universal Asynchronous Receiver/Transmitter
const (
	// TASKS_STARTRX: Start UART receiver
	// Position of TASKS_STARTRX field.
	UART_TASKS_STARTRX_TASKS_STARTRX_Pos = 0x0
	// Bit mask of TASKS_STARTRX field.
	UART_TASKS_STARTRX_TASKS_STARTRX_Msk = 0x1
	// Bit TASKS_STARTRX.
	UART_TASKS_STARTRX_TASKS_STARTRX = 0x1
	// Trigger task
	UART_TASKS_STARTRX_TASKS_STARTRX_Trigger = 0x1

	// TASKS_STOPRX: Stop UART receiver
	// Position of TASKS_STOPRX field.
	UART_TASKS_STOPRX_TASKS_STOPRX_Pos = 0x0
	// Bit mask of TASKS_STOPRX field.
	UART_TASKS_STOPRX_TASKS_STOPRX_Msk = 0x1
	// Bit TASKS_STOPRX.
	UART_TASKS_STOPRX_TASKS_STOPRX = 0x1
	// Trigger task
	UART_TASKS_STOPRX_TASKS_STOPRX_Trigger = 0x1

	// TASKS_STARTTX: Start UART transmitter
	// Position of TASKS_STARTTX field.
	UART_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	UART_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	UART_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	UART_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_STOPTX: Stop UART transmitter
	// Position of TASKS_STOPTX field.
	UART_TASKS_STOPTX_TASKS_STOPTX_Pos = 0x0
	// Bit mask of TASKS_STOPTX field.
	UART_TASKS_STOPTX_TASKS_STOPTX_Msk = 0x1
	// Bit TASKS_STOPTX.
	UART_TASKS_STOPTX_TASKS_STOPTX = 0x1
	// Trigger task
	UART_TASKS_STOPTX_TASKS_STOPTX_Trigger = 0x1

	// TASKS_SUSPEND: Suspend UART
	// Position of TASKS_SUSPEND field.
	UART_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	UART_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	UART_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	UART_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// EVENTS_CTS: CTS is activated (set low). Clear To Send.
	// Position of EVENTS_CTS field.
	UART_EVENTS_CTS_EVENTS_CTS_Pos = 0x0
	// Bit mask of EVENTS_CTS field.
	UART_EVENTS_CTS_EVENTS_CTS_Msk = 0x1
	// Bit EVENTS_CTS.
	UART_EVENTS_CTS_EVENTS_CTS = 0x1
	// Event not generated
	UART_EVENTS_CTS_EVENTS_CTS_NotGenerated = 0x0
	// Event generated
	UART_EVENTS_CTS_EVENTS_CTS_Generated = 0x1

	// EVENTS_NCTS: CTS is deactivated (set high). Not Clear To Send.
	// Position of EVENTS_NCTS field.
	UART_EVENTS_NCTS_EVENTS_NCTS_Pos = 0x0
	// Bit mask of EVENTS_NCTS field.
	UART_EVENTS_NCTS_EVENTS_NCTS_Msk = 0x1
	// Bit EVENTS_NCTS.
	UART_EVENTS_NCTS_EVENTS_NCTS = 0x1
	// Event not generated
	UART_EVENTS_NCTS_EVENTS_NCTS_NotGenerated = 0x0
	// Event generated
	UART_EVENTS_NCTS_EVENTS_NCTS_Generated = 0x1

	// EVENTS_RXDRDY: Data received in RXD
	// Position of EVENTS_RXDRDY field.
	UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos = 0x0
	// Bit mask of EVENTS_RXDRDY field.
	UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Msk = 0x1
	// Bit EVENTS_RXDRDY.
	UART_EVENTS_RXDRDY_EVENTS_RXDRDY = 0x1
	// Event not generated
	UART_EVENTS_RXDRDY_EVENTS_RXDRDY_NotGenerated = 0x0
	// Event generated
	UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Generated = 0x1

	// EVENTS_TXDRDY: Data sent from TXD
	// Position of EVENTS_TXDRDY field.
	UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos = 0x0
	// Bit mask of EVENTS_TXDRDY field.
	UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Msk = 0x1
	// Bit EVENTS_TXDRDY.
	UART_EVENTS_TXDRDY_EVENTS_TXDRDY = 0x1
	// Event not generated
	UART_EVENTS_TXDRDY_EVENTS_TXDRDY_NotGenerated = 0x0
	// Event generated
	UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Generated = 0x1

	// EVENTS_ERROR: Error detected
	// Position of EVENTS_ERROR field.
	UART_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	UART_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	UART_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	UART_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	UART_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_RXTO: Receiver timeout
	// Position of EVENTS_RXTO field.
	UART_EVENTS_RXTO_EVENTS_RXTO_Pos = 0x0
	// Bit mask of EVENTS_RXTO field.
	UART_EVENTS_RXTO_EVENTS_RXTO_Msk = 0x1
	// Bit EVENTS_RXTO.
	UART_EVENTS_RXTO_EVENTS_RXTO = 0x1
	// Event not generated
	UART_EVENTS_RXTO_EVENTS_RXTO_NotGenerated = 0x0
	// Event generated
	UART_EVENTS_RXTO_EVENTS_RXTO_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of CTS_STARTRX field.
	UART_SHORTS_CTS_STARTRX_Pos = 0x3
	// Bit mask of CTS_STARTRX field.
	UART_SHORTS_CTS_STARTRX_Msk = 0x8
	// Bit CTS_STARTRX.
	UART_SHORTS_CTS_STARTRX = 0x8
	// Disable shortcut
	UART_SHORTS_CTS_STARTRX_Disabled = 0x0
	// Enable shortcut
	UART_SHORTS_CTS_STARTRX_Enabled = 0x1
	// Position of NCTS_STOPRX field.
	UART_SHORTS_NCTS_STOPRX_Pos = 0x4
	// Bit mask of NCTS_STOPRX field.
	UART_SHORTS_NCTS_STOPRX_Msk = 0x10
	// Bit NCTS_STOPRX.
	UART_SHORTS_NCTS_STOPRX = 0x10
	// Disable shortcut
	UART_SHORTS_NCTS_STOPRX_Disabled = 0x0
	// Enable shortcut
	UART_SHORTS_NCTS_STOPRX_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of CTS field.
	UART_INTENSET_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UART_INTENSET_CTS_Msk = 0x1
	// Bit CTS.
	UART_INTENSET_CTS = 0x1
	// Read: Disabled
	UART_INTENSET_CTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_CTS_Enabled = 0x1
	// Enable
	UART_INTENSET_CTS_Set = 0x1
	// Position of NCTS field.
	UART_INTENSET_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UART_INTENSET_NCTS_Msk = 0x2
	// Bit NCTS.
	UART_INTENSET_NCTS = 0x2
	// Read: Disabled
	UART_INTENSET_NCTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_NCTS_Enabled = 0x1
	// Enable
	UART_INTENSET_NCTS_Set = 0x1
	// Position of RXDRDY field.
	UART_INTENSET_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UART_INTENSET_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UART_INTENSET_RXDRDY = 0x4
	// Read: Disabled
	UART_INTENSET_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_RXDRDY_Enabled = 0x1
	// Enable
	UART_INTENSET_RXDRDY_Set = 0x1
	// Position of TXDRDY field.
	UART_INTENSET_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UART_INTENSET_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UART_INTENSET_TXDRDY = 0x80
	// Read: Disabled
	UART_INTENSET_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_TXDRDY_Enabled = 0x1
	// Enable
	UART_INTENSET_TXDRDY_Set = 0x1
	// Position of ERROR field.
	UART_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UART_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	UART_INTENSET_ERROR = 0x200
	// Read: Disabled
	UART_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_ERROR_Enabled = 0x1
	// Enable
	UART_INTENSET_ERROR_Set = 0x1
	// Position of RXTO field.
	UART_INTENSET_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UART_INTENSET_RXTO_Msk = 0x20000
	// Bit RXTO.
	UART_INTENSET_RXTO = 0x20000
	// Read: Disabled
	UART_INTENSET_RXTO_Disabled = 0x0
	// Read: Enabled
	UART_INTENSET_RXTO_Enabled = 0x1
	// Enable
	UART_INTENSET_RXTO_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of CTS field.
	UART_INTENCLR_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UART_INTENCLR_CTS_Msk = 0x1
	// Bit CTS.
	UART_INTENCLR_CTS = 0x1
	// Read: Disabled
	UART_INTENCLR_CTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_CTS_Enabled = 0x1
	// Disable
	UART_INTENCLR_CTS_Clear = 0x1
	// Position of NCTS field.
	UART_INTENCLR_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UART_INTENCLR_NCTS_Msk = 0x2
	// Bit NCTS.
	UART_INTENCLR_NCTS = 0x2
	// Read: Disabled
	UART_INTENCLR_NCTS_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_NCTS_Enabled = 0x1
	// Disable
	UART_INTENCLR_NCTS_Clear = 0x1
	// Position of RXDRDY field.
	UART_INTENCLR_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UART_INTENCLR_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UART_INTENCLR_RXDRDY = 0x4
	// Read: Disabled
	UART_INTENCLR_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_RXDRDY_Enabled = 0x1
	// Disable
	UART_INTENCLR_RXDRDY_Clear = 0x1
	// Position of TXDRDY field.
	UART_INTENCLR_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UART_INTENCLR_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UART_INTENCLR_TXDRDY = 0x80
	// Read: Disabled
	UART_INTENCLR_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_TXDRDY_Enabled = 0x1
	// Disable
	UART_INTENCLR_TXDRDY_Clear = 0x1
	// Position of ERROR field.
	UART_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UART_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	UART_INTENCLR_ERROR = 0x200
	// Read: Disabled
	UART_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	UART_INTENCLR_ERROR_Clear = 0x1
	// Position of RXTO field.
	UART_INTENCLR_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UART_INTENCLR_RXTO_Msk = 0x20000
	// Bit RXTO.
	UART_INTENCLR_RXTO = 0x20000
	// Read: Disabled
	UART_INTENCLR_RXTO_Disabled = 0x0
	// Read: Enabled
	UART_INTENCLR_RXTO_Enabled = 0x1
	// Disable
	UART_INTENCLR_RXTO_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	UART_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	UART_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	UART_ERRORSRC_OVERRUN = 0x1
	// Read: error not present
	UART_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_OVERRUN_Present = 0x1
	// Position of PARITY field.
	UART_ERRORSRC_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UART_ERRORSRC_PARITY_Msk = 0x2
	// Bit PARITY.
	UART_ERRORSRC_PARITY = 0x2
	// Read: error not present
	UART_ERRORSRC_PARITY_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_PARITY_Present = 0x1
	// Position of FRAMING field.
	UART_ERRORSRC_FRAMING_Pos = 0x2
	// Bit mask of FRAMING field.
	UART_ERRORSRC_FRAMING_Msk = 0x4
	// Bit FRAMING.
	UART_ERRORSRC_FRAMING = 0x4
	// Read: error not present
	UART_ERRORSRC_FRAMING_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_FRAMING_Present = 0x1
	// Position of BREAK field.
	UART_ERRORSRC_BREAK_Pos = 0x3
	// Bit mask of BREAK field.
	UART_ERRORSRC_BREAK_Msk = 0x8
	// Bit BREAK.
	UART_ERRORSRC_BREAK = 0x8
	// Read: error not present
	UART_ERRORSRC_BREAK_NotPresent = 0x0
	// Read: error present
	UART_ERRORSRC_BREAK_Present = 0x1

	// ENABLE: Enable UART
	// Position of ENABLE field.
	UART_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	UART_ENABLE_ENABLE_Msk = 0xf
	// Disable UART
	UART_ENABLE_ENABLE_Disabled = 0x0
	// Enable UART
	UART_ENABLE_ENABLE_Enabled = 0x4

	// PSEL.RTS: Pin select for RTS
	// Position of PIN field.
	UART_PSEL_RTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UART_PSEL_RTS_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UART_PSEL_RTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UART_PSEL_RTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UART_PSEL_RTS_CONNECT = 0x80000000
	// Disconnect
	UART_PSEL_RTS_CONNECT_Disconnected = 0x1
	// Connect
	UART_PSEL_RTS_CONNECT_Connected = 0x0

	// PSEL.TXD: Pin select for TXD
	// Position of PIN field.
	UART_PSEL_TXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UART_PSEL_TXD_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UART_PSEL_TXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UART_PSEL_TXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UART_PSEL_TXD_CONNECT = 0x80000000
	// Disconnect
	UART_PSEL_TXD_CONNECT_Disconnected = 0x1
	// Connect
	UART_PSEL_TXD_CONNECT_Connected = 0x0

	// PSEL.CTS: Pin select for CTS
	// Position of PIN field.
	UART_PSEL_CTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UART_PSEL_CTS_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UART_PSEL_CTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UART_PSEL_CTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UART_PSEL_CTS_CONNECT = 0x80000000
	// Disconnect
	UART_PSEL_CTS_CONNECT_Disconnected = 0x1
	// Connect
	UART_PSEL_CTS_CONNECT_Connected = 0x0

	// PSEL.RXD: Pin select for RXD
	// Position of PIN field.
	UART_PSEL_RXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UART_PSEL_RXD_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UART_PSEL_RXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UART_PSEL_RXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UART_PSEL_RXD_CONNECT = 0x80000000
	// Disconnect
	UART_PSEL_RXD_CONNECT_Disconnected = 0x1
	// Connect
	UART_PSEL_RXD_CONNECT_Connected = 0x0

	// RXD: RXD register
	// Position of RXD field.
	UART_RXD_RXD_Pos = 0x0
	// Bit mask of RXD field.
	UART_RXD_RXD_Msk = 0xff

	// TXD: TXD register
	// Position of TXD field.
	UART_TXD_TXD_Pos = 0x0
	// Bit mask of TXD field.
	UART_TXD_TXD_Msk = 0xff

	// BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
	// Position of BAUDRATE field.
	UART_BAUDRATE_BAUDRATE_Pos = 0x0
	// Bit mask of BAUDRATE field.
	UART_BAUDRATE_BAUDRATE_Msk = 0xffffffff
	// 1200 baud (actual rate: 1205)
	UART_BAUDRATE_BAUDRATE_Baud1200 = 0x4f000
	// 2400 baud (actual rate: 2396)
	UART_BAUDRATE_BAUDRATE_Baud2400 = 0x9d000
	// 4800 baud (actual rate: 4808)
	UART_BAUDRATE_BAUDRATE_Baud4800 = 0x13b000
	// 9600 baud (actual rate: 9598)
	UART_BAUDRATE_BAUDRATE_Baud9600 = 0x275000
	// 14400 baud (actual rate: 14414)
	UART_BAUDRATE_BAUDRATE_Baud14400 = 0x3b0000
	// 19200 baud (actual rate: 19208)
	UART_BAUDRATE_BAUDRATE_Baud19200 = 0x4ea000
	// 28800 baud (actual rate: 28829)
	UART_BAUDRATE_BAUDRATE_Baud28800 = 0x75f000
	// 31250 baud
	UART_BAUDRATE_BAUDRATE_Baud31250 = 0x800000
	// 38400 baud (actual rate: 38462)
	UART_BAUDRATE_BAUDRATE_Baud38400 = 0x9d5000
	// 56000 baud (actual rate: 55944)
	UART_BAUDRATE_BAUDRATE_Baud56000 = 0xe50000
	// 57600 baud (actual rate: 57762)
	UART_BAUDRATE_BAUDRATE_Baud57600 = 0xebf000
	// 76800 baud (actual rate: 76923)
	UART_BAUDRATE_BAUDRATE_Baud76800 = 0x13a9000
	// 115200 baud (actual rate: 115942)
	UART_BAUDRATE_BAUDRATE_Baud115200 = 0x1d7e000
	// 230400 baud (actual rate: 231884)
	UART_BAUDRATE_BAUDRATE_Baud230400 = 0x3afb000
	// 250000 baud
	UART_BAUDRATE_BAUDRATE_Baud250000 = 0x4000000
	// 460800 baud (actual rate: 470588)
	UART_BAUDRATE_BAUDRATE_Baud460800 = 0x75f7000
	// 921600 baud (actual rate: 941176)
	UART_BAUDRATE_BAUDRATE_Baud921600 = 0xebed000
	// 1Mega baud
	UART_BAUDRATE_BAUDRATE_Baud1M = 0x10000000

	// CONFIG: Configuration of parity and hardware flow control
	// Position of HWFC field.
	UART_CONFIG_HWFC_Pos = 0x0
	// Bit mask of HWFC field.
	UART_CONFIG_HWFC_Msk = 0x1
	// Bit HWFC.
	UART_CONFIG_HWFC = 0x1
	// Disabled
	UART_CONFIG_HWFC_Disabled = 0x0
	// Enabled
	UART_CONFIG_HWFC_Enabled = 0x1
	// Position of PARITY field.
	UART_CONFIG_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UART_CONFIG_PARITY_Msk = 0xe
	// Exclude parity bit
	UART_CONFIG_PARITY_Excluded = 0x0
	// Include parity bit
	UART_CONFIG_PARITY_Included = 0x7
	// Position of STOP field.
	UART_CONFIG_STOP_Pos = 0x4
	// Bit mask of STOP field.
	UART_CONFIG_STOP_Msk = 0x10
	// Bit STOP.
	UART_CONFIG_STOP = 0x10
	// One stop bit
	UART_CONFIG_STOP_One = 0x0
	// Two stop bits
	UART_CONFIG_STOP_Two = 0x1
	// Position of PARITYTYPE field.
	UART_CONFIG_PARITYTYPE_Pos = 0x8
	// Bit mask of PARITYTYPE field.
	UART_CONFIG_PARITYTYPE_Msk = 0x100
	// Bit PARITYTYPE.
	UART_CONFIG_PARITYTYPE = 0x100
	// Even parity
	UART_CONFIG_PARITYTYPE_Even = 0x0
	// Odd parity
	UART_CONFIG_PARITYTYPE_Odd = 0x1
)

// Constants for UARTE0: UART with EasyDMA
const (
	// TASKS_STARTRX: Start UART receiver
	// Position of TASKS_STARTRX field.
	UARTE_TASKS_STARTRX_TASKS_STARTRX_Pos = 0x0
	// Bit mask of TASKS_STARTRX field.
	UARTE_TASKS_STARTRX_TASKS_STARTRX_Msk = 0x1
	// Bit TASKS_STARTRX.
	UARTE_TASKS_STARTRX_TASKS_STARTRX = 0x1
	// Trigger task
	UARTE_TASKS_STARTRX_TASKS_STARTRX_Trigger = 0x1

	// TASKS_STOPRX: Stop UART receiver
	// Position of TASKS_STOPRX field.
	UARTE_TASKS_STOPRX_TASKS_STOPRX_Pos = 0x0
	// Bit mask of TASKS_STOPRX field.
	UARTE_TASKS_STOPRX_TASKS_STOPRX_Msk = 0x1
	// Bit TASKS_STOPRX.
	UARTE_TASKS_STOPRX_TASKS_STOPRX = 0x1
	// Trigger task
	UARTE_TASKS_STOPRX_TASKS_STOPRX_Trigger = 0x1

	// TASKS_STARTTX: Start UART transmitter
	// Position of TASKS_STARTTX field.
	UARTE_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	UARTE_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	UARTE_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	UARTE_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_STOPTX: Stop UART transmitter
	// Position of TASKS_STOPTX field.
	UARTE_TASKS_STOPTX_TASKS_STOPTX_Pos = 0x0
	// Bit mask of TASKS_STOPTX field.
	UARTE_TASKS_STOPTX_TASKS_STOPTX_Msk = 0x1
	// Bit TASKS_STOPTX.
	UARTE_TASKS_STOPTX_TASKS_STOPTX = 0x1
	// Trigger task
	UARTE_TASKS_STOPTX_TASKS_STOPTX_Trigger = 0x1

	// TASKS_FLUSHRX: Flush RX FIFO into RX buffer
	// Position of TASKS_FLUSHRX field.
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Pos = 0x0
	// Bit mask of TASKS_FLUSHRX field.
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Msk = 0x1
	// Bit TASKS_FLUSHRX.
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX = 0x1
	// Trigger task
	UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Trigger = 0x1

	// EVENTS_CTS: CTS is activated (set low). Clear To Send.
	// Position of EVENTS_CTS field.
	UARTE_EVENTS_CTS_EVENTS_CTS_Pos = 0x0
	// Bit mask of EVENTS_CTS field.
	UARTE_EVENTS_CTS_EVENTS_CTS_Msk = 0x1
	// Bit EVENTS_CTS.
	UARTE_EVENTS_CTS_EVENTS_CTS = 0x1
	// Event not generated
	UARTE_EVENTS_CTS_EVENTS_CTS_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_CTS_EVENTS_CTS_Generated = 0x1

	// EVENTS_NCTS: CTS is deactivated (set high). Not Clear To Send.
	// Position of EVENTS_NCTS field.
	UARTE_EVENTS_NCTS_EVENTS_NCTS_Pos = 0x0
	// Bit mask of EVENTS_NCTS field.
	UARTE_EVENTS_NCTS_EVENTS_NCTS_Msk = 0x1
	// Bit EVENTS_NCTS.
	UARTE_EVENTS_NCTS_EVENTS_NCTS = 0x1
	// Event not generated
	UARTE_EVENTS_NCTS_EVENTS_NCTS_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_NCTS_EVENTS_NCTS_Generated = 0x1

	// EVENTS_RXDRDY: Data received in RXD (but potentially not yet transferred to Data RAM)
	// Position of EVENTS_RXDRDY field.
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos = 0x0
	// Bit mask of EVENTS_RXDRDY field.
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Msk = 0x1
	// Bit EVENTS_RXDRDY.
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY = 0x1
	// Event not generated
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Generated = 0x1

	// EVENTS_ENDRX: Receive buffer is filled up
	// Position of EVENTS_ENDRX field.
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_TXDRDY: Data sent from TXD
	// Position of EVENTS_TXDRDY field.
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos = 0x0
	// Bit mask of EVENTS_TXDRDY field.
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Msk = 0x1
	// Bit EVENTS_TXDRDY.
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY = 0x1
	// Event not generated
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Generated = 0x1

	// EVENTS_ENDTX: Last TX byte transmitted
	// Position of EVENTS_ENDTX field.
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Pos = 0x0
	// Bit mask of EVENTS_ENDTX field.
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Msk = 0x1
	// Bit EVENTS_ENDTX.
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX = 0x1
	// Event not generated
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Generated = 0x1

	// EVENTS_ERROR: Error detected
	// Position of EVENTS_ERROR field.
	UARTE_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	UARTE_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	UARTE_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	UARTE_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_RXTO: Receiver timeout
	// Position of EVENTS_RXTO field.
	UARTE_EVENTS_RXTO_EVENTS_RXTO_Pos = 0x0
	// Bit mask of EVENTS_RXTO field.
	UARTE_EVENTS_RXTO_EVENTS_RXTO_Msk = 0x1
	// Bit EVENTS_RXTO.
	UARTE_EVENTS_RXTO_EVENTS_RXTO = 0x1
	// Event not generated
	UARTE_EVENTS_RXTO_EVENTS_RXTO_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_RXTO_EVENTS_RXTO_Generated = 0x1

	// EVENTS_RXSTARTED: UART receiver has started
	// Position of EVENTS_RXSTARTED field.
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_RXSTARTED field.
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk = 0x1
	// Bit EVENTS_RXSTARTED.
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED = 0x1
	// Event not generated
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated = 0x1

	// EVENTS_TXSTARTED: UART transmitter has started
	// Position of EVENTS_TXSTARTED field.
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_TXSTARTED field.
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk = 0x1
	// Bit EVENTS_TXSTARTED.
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED = 0x1
	// Event not generated
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated = 0x1

	// EVENTS_TXSTOPPED: Transmitter stopped
	// Position of EVENTS_TXSTOPPED field.
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Pos = 0x0
	// Bit mask of EVENTS_TXSTOPPED field.
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Msk = 0x1
	// Bit EVENTS_TXSTOPPED.
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED = 0x1
	// Event not generated
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_NotGenerated = 0x0
	// Event generated
	UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of ENDRX_STARTRX field.
	UARTE_SHORTS_ENDRX_STARTRX_Pos = 0x5
	// Bit mask of ENDRX_STARTRX field.
	UARTE_SHORTS_ENDRX_STARTRX_Msk = 0x20
	// Bit ENDRX_STARTRX.
	UARTE_SHORTS_ENDRX_STARTRX = 0x20
	// Disable shortcut
	UARTE_SHORTS_ENDRX_STARTRX_Disabled = 0x0
	// Enable shortcut
	UARTE_SHORTS_ENDRX_STARTRX_Enabled = 0x1
	// Position of ENDRX_STOPRX field.
	UARTE_SHORTS_ENDRX_STOPRX_Pos = 0x6
	// Bit mask of ENDRX_STOPRX field.
	UARTE_SHORTS_ENDRX_STOPRX_Msk = 0x40
	// Bit ENDRX_STOPRX.
	UARTE_SHORTS_ENDRX_STOPRX = 0x40
	// Disable shortcut
	UARTE_SHORTS_ENDRX_STOPRX_Disabled = 0x0
	// Enable shortcut
	UARTE_SHORTS_ENDRX_STOPRX_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of CTS field.
	UARTE_INTEN_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTEN_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTEN_CTS = 0x1
	// Disable
	UARTE_INTEN_CTS_Disabled = 0x0
	// Enable
	UARTE_INTEN_CTS_Enabled = 0x1
	// Position of NCTS field.
	UARTE_INTEN_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTEN_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTEN_NCTS = 0x2
	// Disable
	UARTE_INTEN_NCTS_Disabled = 0x0
	// Enable
	UARTE_INTEN_NCTS_Enabled = 0x1
	// Position of RXDRDY field.
	UARTE_INTEN_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTEN_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTEN_RXDRDY = 0x4
	// Disable
	UARTE_INTEN_RXDRDY_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXDRDY_Enabled = 0x1
	// Position of ENDRX field.
	UARTE_INTEN_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTEN_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTEN_ENDRX = 0x10
	// Disable
	UARTE_INTEN_ENDRX_Disabled = 0x0
	// Enable
	UARTE_INTEN_ENDRX_Enabled = 0x1
	// Position of TXDRDY field.
	UARTE_INTEN_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTEN_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTEN_TXDRDY = 0x80
	// Disable
	UARTE_INTEN_TXDRDY_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXDRDY_Enabled = 0x1
	// Position of ENDTX field.
	UARTE_INTEN_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTEN_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTEN_ENDTX = 0x100
	// Disable
	UARTE_INTEN_ENDTX_Disabled = 0x0
	// Enable
	UARTE_INTEN_ENDTX_Enabled = 0x1
	// Position of ERROR field.
	UARTE_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTEN_ERROR = 0x200
	// Disable
	UARTE_INTEN_ERROR_Disabled = 0x0
	// Enable
	UARTE_INTEN_ERROR_Enabled = 0x1
	// Position of RXTO field.
	UARTE_INTEN_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTEN_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTEN_RXTO = 0x20000
	// Disable
	UARTE_INTEN_RXTO_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXTO_Enabled = 0x1
	// Position of RXSTARTED field.
	UARTE_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTEN_RXSTARTED = 0x80000
	// Disable
	UARTE_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	UARTE_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	UARTE_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTEN_TXSTARTED = 0x100000
	// Disable
	UARTE_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXSTARTED_Enabled = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTEN_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTEN_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTEN_TXSTOPPED = 0x400000
	// Disable
	UARTE_INTEN_TXSTOPPED_Disabled = 0x0
	// Enable
	UARTE_INTEN_TXSTOPPED_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of CTS field.
	UARTE_INTENSET_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTENSET_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTENSET_CTS = 0x1
	// Read: Disabled
	UARTE_INTENSET_CTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_CTS_Enabled = 0x1
	// Enable
	UARTE_INTENSET_CTS_Set = 0x1
	// Position of NCTS field.
	UARTE_INTENSET_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTENSET_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTENSET_NCTS = 0x2
	// Read: Disabled
	UARTE_INTENSET_NCTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_NCTS_Enabled = 0x1
	// Enable
	UARTE_INTENSET_NCTS_Set = 0x1
	// Position of RXDRDY field.
	UARTE_INTENSET_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTENSET_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTENSET_RXDRDY = 0x4
	// Read: Disabled
	UARTE_INTENSET_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXDRDY_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXDRDY_Set = 0x1
	// Position of ENDRX field.
	UARTE_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTENSET_ENDRX = 0x10
	// Read: Disabled
	UARTE_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ENDRX_Set = 0x1
	// Position of TXDRDY field.
	UARTE_INTENSET_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTENSET_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTENSET_TXDRDY = 0x80
	// Read: Disabled
	UARTE_INTENSET_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXDRDY_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXDRDY_Set = 0x1
	// Position of ENDTX field.
	UARTE_INTENSET_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTENSET_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTENSET_ENDTX = 0x100
	// Read: Disabled
	UARTE_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ENDTX_Set = 0x1
	// Position of ERROR field.
	UARTE_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTENSET_ERROR = 0x200
	// Read: Disabled
	UARTE_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_ERROR_Enabled = 0x1
	// Enable
	UARTE_INTENSET_ERROR_Set = 0x1
	// Position of RXTO field.
	UARTE_INTENSET_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTENSET_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTENSET_RXTO = 0x20000
	// Read: Disabled
	UARTE_INTENSET_RXTO_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXTO_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXTO_Set = 0x1
	// Position of RXSTARTED field.
	UARTE_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	UARTE_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	UARTE_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	UARTE_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXSTARTED_Set = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTENSET_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTENSET_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTENSET_TXSTOPPED = 0x400000
	// Read: Disabled
	UARTE_INTENSET_TXSTOPPED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENSET_TXSTOPPED_Enabled = 0x1
	// Enable
	UARTE_INTENSET_TXSTOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of CTS field.
	UARTE_INTENCLR_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UARTE_INTENCLR_CTS_Msk = 0x1
	// Bit CTS.
	UARTE_INTENCLR_CTS = 0x1
	// Read: Disabled
	UARTE_INTENCLR_CTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_CTS_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_CTS_Clear = 0x1
	// Position of NCTS field.
	UARTE_INTENCLR_NCTS_Pos = 0x1
	// Bit mask of NCTS field.
	UARTE_INTENCLR_NCTS_Msk = 0x2
	// Bit NCTS.
	UARTE_INTENCLR_NCTS = 0x2
	// Read: Disabled
	UARTE_INTENCLR_NCTS_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_NCTS_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_NCTS_Clear = 0x1
	// Position of RXDRDY field.
	UARTE_INTENCLR_RXDRDY_Pos = 0x2
	// Bit mask of RXDRDY field.
	UARTE_INTENCLR_RXDRDY_Msk = 0x4
	// Bit RXDRDY.
	UARTE_INTENCLR_RXDRDY = 0x4
	// Read: Disabled
	UARTE_INTENCLR_RXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXDRDY_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXDRDY_Clear = 0x1
	// Position of ENDRX field.
	UARTE_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	UARTE_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	UARTE_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	UARTE_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ENDRX_Clear = 0x1
	// Position of TXDRDY field.
	UARTE_INTENCLR_TXDRDY_Pos = 0x7
	// Bit mask of TXDRDY field.
	UARTE_INTENCLR_TXDRDY_Msk = 0x80
	// Bit TXDRDY.
	UARTE_INTENCLR_TXDRDY = 0x80
	// Read: Disabled
	UARTE_INTENCLR_TXDRDY_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXDRDY_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXDRDY_Clear = 0x1
	// Position of ENDTX field.
	UARTE_INTENCLR_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	UARTE_INTENCLR_ENDTX_Msk = 0x100
	// Bit ENDTX.
	UARTE_INTENCLR_ENDTX = 0x100
	// Read: Disabled
	UARTE_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ENDTX_Clear = 0x1
	// Position of ERROR field.
	UARTE_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	UARTE_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	UARTE_INTENCLR_ERROR = 0x200
	// Read: Disabled
	UARTE_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_ERROR_Clear = 0x1
	// Position of RXTO field.
	UARTE_INTENCLR_RXTO_Pos = 0x11
	// Bit mask of RXTO field.
	UARTE_INTENCLR_RXTO_Msk = 0x20000
	// Bit RXTO.
	UARTE_INTENCLR_RXTO = 0x20000
	// Read: Disabled
	UARTE_INTENCLR_RXTO_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXTO_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXTO_Clear = 0x1
	// Position of RXSTARTED field.
	UARTE_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	UARTE_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	UARTE_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	UARTE_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	UARTE_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	UARTE_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	UARTE_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	UARTE_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of TXSTOPPED field.
	UARTE_INTENCLR_TXSTOPPED_Pos = 0x16
	// Bit mask of TXSTOPPED field.
	UARTE_INTENCLR_TXSTOPPED_Msk = 0x400000
	// Bit TXSTOPPED.
	UARTE_INTENCLR_TXSTOPPED = 0x400000
	// Read: Disabled
	UARTE_INTENCLR_TXSTOPPED_Disabled = 0x0
	// Read: Enabled
	UARTE_INTENCLR_TXSTOPPED_Enabled = 0x1
	// Disable
	UARTE_INTENCLR_TXSTOPPED_Clear = 0x1

	// ERRORSRC: Error source Note : this register is read / write one to clear.
	// Position of OVERRUN field.
	UARTE_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	UARTE_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	UARTE_ERRORSRC_OVERRUN = 0x1
	// Read: error not present
	UARTE_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_OVERRUN_Present = 0x1
	// Position of PARITY field.
	UARTE_ERRORSRC_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UARTE_ERRORSRC_PARITY_Msk = 0x2
	// Bit PARITY.
	UARTE_ERRORSRC_PARITY = 0x2
	// Read: error not present
	UARTE_ERRORSRC_PARITY_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_PARITY_Present = 0x1
	// Position of FRAMING field.
	UARTE_ERRORSRC_FRAMING_Pos = 0x2
	// Bit mask of FRAMING field.
	UARTE_ERRORSRC_FRAMING_Msk = 0x4
	// Bit FRAMING.
	UARTE_ERRORSRC_FRAMING = 0x4
	// Read: error not present
	UARTE_ERRORSRC_FRAMING_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_FRAMING_Present = 0x1
	// Position of BREAK field.
	UARTE_ERRORSRC_BREAK_Pos = 0x3
	// Bit mask of BREAK field.
	UARTE_ERRORSRC_BREAK_Msk = 0x8
	// Bit BREAK.
	UARTE_ERRORSRC_BREAK = 0x8
	// Read: error not present
	UARTE_ERRORSRC_BREAK_NotPresent = 0x0
	// Read: error present
	UARTE_ERRORSRC_BREAK_Present = 0x1

	// ENABLE: Enable UART
	// Position of ENABLE field.
	UARTE_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	UARTE_ENABLE_ENABLE_Msk = 0xf
	// Disable UARTE
	UARTE_ENABLE_ENABLE_Disabled = 0x0
	// Enable UARTE
	UARTE_ENABLE_ENABLE_Enabled = 0x8

	// PSEL.RTS: Pin select for RTS signal
	// Position of PIN field.
	UARTE_PSEL_RTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_RTS_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_RTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_RTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_RTS_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_RTS_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_RTS_CONNECT_Connected = 0x0

	// PSEL.TXD: Pin select for TXD signal
	// Position of PIN field.
	UARTE_PSEL_TXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_TXD_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_TXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_TXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_TXD_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_TXD_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_TXD_CONNECT_Connected = 0x0

	// PSEL.CTS: Pin select for CTS signal
	// Position of PIN field.
	UARTE_PSEL_CTS_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_CTS_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_CTS_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_CTS_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_CTS_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_CTS_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_CTS_CONNECT_Connected = 0x0

	// PSEL.RXD: Pin select for RXD signal
	// Position of PIN field.
	UARTE_PSEL_RXD_PIN_Pos = 0x0
	// Bit mask of PIN field.
	UARTE_PSEL_RXD_PIN_Msk = 0x1f
	// Position of CONNECT field.
	UARTE_PSEL_RXD_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	UARTE_PSEL_RXD_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	UARTE_PSEL_RXD_CONNECT = 0x80000000
	// Disconnect
	UARTE_PSEL_RXD_CONNECT_Disconnected = 0x1
	// Connect
	UARTE_PSEL_RXD_CONNECT_Connected = 0x0

	// BAUDRATE: Baud rate. Accuracy depends on the HFCLK source selected.
	// Position of BAUDRATE field.
	UARTE_BAUDRATE_BAUDRATE_Pos = 0x0
	// Bit mask of BAUDRATE field.
	UARTE_BAUDRATE_BAUDRATE_Msk = 0xffffffff
	// 1200 baud (actual rate: 1205)
	UARTE_BAUDRATE_BAUDRATE_Baud1200 = 0x4f000
	// 2400 baud (actual rate: 2396)
	UARTE_BAUDRATE_BAUDRATE_Baud2400 = 0x9d000
	// 4800 baud (actual rate: 4808)
	UARTE_BAUDRATE_BAUDRATE_Baud4800 = 0x13b000
	// 9600 baud (actual rate: 9598)
	UARTE_BAUDRATE_BAUDRATE_Baud9600 = 0x275000
	// 14400 baud (actual rate: 14401)
	UARTE_BAUDRATE_BAUDRATE_Baud14400 = 0x3af000
	// 19200 baud (actual rate: 19208)
	UARTE_BAUDRATE_BAUDRATE_Baud19200 = 0x4ea000
	// 28800 baud (actual rate: 28777)
	UARTE_BAUDRATE_BAUDRATE_Baud28800 = 0x75c000
	// 31250 baud
	UARTE_BAUDRATE_BAUDRATE_Baud31250 = 0x800000
	// 38400 baud (actual rate: 38369)
	UARTE_BAUDRATE_BAUDRATE_Baud38400 = 0x9d0000
	// 56000 baud (actual rate: 55944)
	UARTE_BAUDRATE_BAUDRATE_Baud56000 = 0xe50000
	// 57600 baud (actual rate: 57554)
	UARTE_BAUDRATE_BAUDRATE_Baud57600 = 0xeb0000
	// 76800 baud (actual rate: 76923)
	UARTE_BAUDRATE_BAUDRATE_Baud76800 = 0x13a9000
	// 115200 baud (actual rate: 115108)
	UARTE_BAUDRATE_BAUDRATE_Baud115200 = 0x1d60000
	// 230400 baud (actual rate: 231884)
	UARTE_BAUDRATE_BAUDRATE_Baud230400 = 0x3b00000
	// 250000 baud
	UARTE_BAUDRATE_BAUDRATE_Baud250000 = 0x4000000
	// 460800 baud (actual rate: 457143)
	UARTE_BAUDRATE_BAUDRATE_Baud460800 = 0x7400000
	// 921600 baud (actual rate: 941176)
	UARTE_BAUDRATE_BAUDRATE_Baud921600 = 0xf000000
	// 1Mega baud
	UARTE_BAUDRATE_BAUDRATE_Baud1M = 0x10000000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	UARTE_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	UARTE_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	UARTE_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	UARTE_RXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	UARTE_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	UARTE_RXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// TXD.PTR: Data pointer
	// Position of PTR field.
	UARTE_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	UARTE_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	UARTE_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	UARTE_TXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	UARTE_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	UARTE_TXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// CONFIG: Configuration of parity and hardware flow control
	// Position of HWFC field.
	UARTE_CONFIG_HWFC_Pos = 0x0
	// Bit mask of HWFC field.
	UARTE_CONFIG_HWFC_Msk = 0x1
	// Bit HWFC.
	UARTE_CONFIG_HWFC = 0x1
	// Disabled
	UARTE_CONFIG_HWFC_Disabled = 0x0
	// Enabled
	UARTE_CONFIG_HWFC_Enabled = 0x1
	// Position of PARITY field.
	UARTE_CONFIG_PARITY_Pos = 0x1
	// Bit mask of PARITY field.
	UARTE_CONFIG_PARITY_Msk = 0xe
	// Exclude parity bit
	UARTE_CONFIG_PARITY_Excluded = 0x0
	// Include even parity bit
	UARTE_CONFIG_PARITY_Included = 0x7
	// Position of STOP field.
	UARTE_CONFIG_STOP_Pos = 0x4
	// Bit mask of STOP field.
	UARTE_CONFIG_STOP_Msk = 0x10
	// Bit STOP.
	UARTE_CONFIG_STOP = 0x10
	// One stop bit
	UARTE_CONFIG_STOP_One = 0x0
	// Two stop bits
	UARTE_CONFIG_STOP_Two = 0x1
	// Position of PARITYTYPE field.
	UARTE_CONFIG_PARITYTYPE_Pos = 0x8
	// Bit mask of PARITYTYPE field.
	UARTE_CONFIG_PARITYTYPE_Msk = 0x100
	// Bit PARITYTYPE.
	UARTE_CONFIG_PARITYTYPE = 0x100
	// Even parity
	UARTE_CONFIG_PARITYTYPE_Even = 0x0
	// Odd parity
	UARTE_CONFIG_PARITYTYPE_Odd = 0x1
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// EVENTS_READY: TXD byte sent and RXD byte received
	// Position of EVENTS_READY field.
	SPI_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	SPI_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	SPI_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	SPI_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	SPI_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	SPI_INTENSET_READY_Pos = 0x2
	// Bit mask of READY field.
	SPI_INTENSET_READY_Msk = 0x4
	// Bit READY.
	SPI_INTENSET_READY = 0x4
	// Read: Disabled
	SPI_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	SPI_INTENSET_READY_Enabled = 0x1
	// Enable
	SPI_INTENSET_READY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	SPI_INTENCLR_READY_Pos = 0x2
	// Bit mask of READY field.
	SPI_INTENCLR_READY_Msk = 0x4
	// Bit READY.
	SPI_INTENCLR_READY = 0x4
	// Read: Disabled
	SPI_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	SPI_INTENCLR_READY_Enabled = 0x1
	// Disable
	SPI_INTENCLR_READY_Clear = 0x1

	// ENABLE: Enable SPI
	// Position of ENABLE field.
	SPI_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPI_ENABLE_ENABLE_Msk = 0xf
	// Disable SPI
	SPI_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPI
	SPI_ENABLE_ENABLE_Enabled = 0x1

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPI_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPI_PSEL_SCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPI_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPI_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPI_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPI_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPI_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPI_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPI_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPI_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPI_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPI_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPI_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPI_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPI_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPI_PSEL_MISO_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPI_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPI_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPI_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPI_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPI_PSEL_MISO_CONNECT_Connected = 0x0

	// RXD: RXD register
	// Position of RXD field.
	SPI_RXD_RXD_Pos = 0x0
	// Bit mask of RXD field.
	SPI_RXD_RXD_Msk = 0xff

	// TXD: TXD register
	// Position of TXD field.
	SPI_TXD_TXD_Pos = 0x0
	// Bit mask of TXD field.
	SPI_TXD_TXD_Msk = 0xff

	// FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	SPI_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	SPI_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 125 kbps
	SPI_FREQUENCY_FREQUENCY_K125 = 0x2000000
	// 250 kbps
	SPI_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 500 kbps
	SPI_FREQUENCY_FREQUENCY_K500 = 0x8000000
	// 1 Mbps
	SPI_FREQUENCY_FREQUENCY_M1 = 0x10000000
	// 2 Mbps
	SPI_FREQUENCY_FREQUENCY_M2 = 0x20000000
	// 4 Mbps
	SPI_FREQUENCY_FREQUENCY_M4 = 0x40000000
	// 8 Mbps
	SPI_FREQUENCY_FREQUENCY_M8 = 0x80000000

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPI_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPI_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPI_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPI_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPI_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPI_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPI_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPI_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPI_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPI_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPI_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPI_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPI_CONFIG_CPOL = 0x4
	// Active high
	SPI_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPI_CONFIG_CPOL_ActiveLow = 0x1
)

// Constants for SPIM0: Serial Peripheral Interface Master with EasyDMA 0
const (
	// TASKS_START: Start SPI transaction
	// Position of TASKS_START field.
	SPIM_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	SPIM_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	SPIM_TASKS_START_TASKS_START = 0x1
	// Trigger task
	SPIM_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop SPI transaction
	// Position of TASKS_STOP field.
	SPIM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	SPIM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	SPIM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	SPIM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend SPI transaction
	// Position of TASKS_SUSPEND field.
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume SPI transaction
	// Position of TASKS_RESUME field.
	SPIM_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	SPIM_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	SPIM_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	SPIM_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// EVENTS_STOPPED: SPI transaction has stopped
	// Position of EVENTS_STOPPED field.
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_ENDRX: End of RXD buffer reached
	// Position of EVENTS_ENDRX field.
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_END: End of RXD buffer and TXD buffer reached
	// Position of EVENTS_END field.
	SPIM_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	SPIM_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	SPIM_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	SPIM_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_ENDTX: End of TXD buffer reached
	// Position of EVENTS_ENDTX field.
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Pos = 0x0
	// Bit mask of EVENTS_ENDTX field.
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Msk = 0x1
	// Bit EVENTS_ENDTX.
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX = 0x1
	// Event not generated
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Generated = 0x1

	// EVENTS_STARTED: Transaction started
	// Position of EVENTS_STARTED field.
	SPIM_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	SPIM_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	SPIM_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	SPIM_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	SPIM_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of END_START field.
	SPIM_SHORTS_END_START_Pos = 0x11
	// Bit mask of END_START field.
	SPIM_SHORTS_END_START_Msk = 0x20000
	// Bit END_START.
	SPIM_SHORTS_END_START = 0x20000
	// Disable shortcut
	SPIM_SHORTS_END_START_Disabled = 0x0
	// Enable shortcut
	SPIM_SHORTS_END_START_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	SPIM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	SPIM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	SPIM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	SPIM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	SPIM_INTENSET_STOPPED_Set = 0x1
	// Position of ENDRX field.
	SPIM_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIM_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIM_INTENSET_ENDRX = 0x10
	// Read: Disabled
	SPIM_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	SPIM_INTENSET_ENDRX_Set = 0x1
	// Position of END field.
	SPIM_INTENSET_END_Pos = 0x6
	// Bit mask of END field.
	SPIM_INTENSET_END_Msk = 0x40
	// Bit END.
	SPIM_INTENSET_END = 0x40
	// Read: Disabled
	SPIM_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_END_Enabled = 0x1
	// Enable
	SPIM_INTENSET_END_Set = 0x1
	// Position of ENDTX field.
	SPIM_INTENSET_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	SPIM_INTENSET_ENDTX_Msk = 0x100
	// Bit ENDTX.
	SPIM_INTENSET_ENDTX = 0x100
	// Read: Disabled
	SPIM_INTENSET_ENDTX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_ENDTX_Enabled = 0x1
	// Enable
	SPIM_INTENSET_ENDTX_Set = 0x1
	// Position of STARTED field.
	SPIM_INTENSET_STARTED_Pos = 0x13
	// Bit mask of STARTED field.
	SPIM_INTENSET_STARTED_Msk = 0x80000
	// Bit STARTED.
	SPIM_INTENSET_STARTED = 0x80000
	// Read: Disabled
	SPIM_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENSET_STARTED_Enabled = 0x1
	// Enable
	SPIM_INTENSET_STARTED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	SPIM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	SPIM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	SPIM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	SPIM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_STOPPED_Clear = 0x1
	// Position of ENDRX field.
	SPIM_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIM_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIM_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	SPIM_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_ENDRX_Clear = 0x1
	// Position of END field.
	SPIM_INTENCLR_END_Pos = 0x6
	// Bit mask of END field.
	SPIM_INTENCLR_END_Msk = 0x40
	// Bit END.
	SPIM_INTENCLR_END = 0x40
	// Read: Disabled
	SPIM_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_END_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_END_Clear = 0x1
	// Position of ENDTX field.
	SPIM_INTENCLR_ENDTX_Pos = 0x8
	// Bit mask of ENDTX field.
	SPIM_INTENCLR_ENDTX_Msk = 0x100
	// Bit ENDTX.
	SPIM_INTENCLR_ENDTX = 0x100
	// Read: Disabled
	SPIM_INTENCLR_ENDTX_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_ENDTX_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_ENDTX_Clear = 0x1
	// Position of STARTED field.
	SPIM_INTENCLR_STARTED_Pos = 0x13
	// Bit mask of STARTED field.
	SPIM_INTENCLR_STARTED_Msk = 0x80000
	// Bit STARTED.
	SPIM_INTENCLR_STARTED = 0x80000
	// Read: Disabled
	SPIM_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	SPIM_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	SPIM_INTENCLR_STARTED_Clear = 0x1

	// ENABLE: Enable SPIM
	// Position of ENABLE field.
	SPIM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPIM_ENABLE_ENABLE_Msk = 0xf
	// Disable SPIM
	SPIM_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPIM
	SPIM_ENABLE_ENABLE_Enabled = 0x7

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPIM_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_SCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIM_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPIM_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIM_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPIM_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIM_PSEL_MISO_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIM_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIM_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIM_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPIM_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPIM_PSEL_MISO_CONNECT_Connected = 0x0

	// FREQUENCY: SPI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	SPIM_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	SPIM_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 125 kbps
	SPIM_FREQUENCY_FREQUENCY_K125 = 0x2000000
	// 250 kbps
	SPIM_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 500 kbps
	SPIM_FREQUENCY_FREQUENCY_K500 = 0x8000000
	// 1 Mbps
	SPIM_FREQUENCY_FREQUENCY_M1 = 0x10000000
	// 2 Mbps
	SPIM_FREQUENCY_FREQUENCY_M2 = 0x20000000
	// 4 Mbps
	SPIM_FREQUENCY_FREQUENCY_M4 = 0x40000000
	// 8 Mbps
	SPIM_FREQUENCY_FREQUENCY_M8 = 0x80000000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	SPIM_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIM_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	SPIM_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIM_RXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	SPIM_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIM_RXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIM_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIM_RXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIM_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIM_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: Data pointer
	// Position of PTR field.
	SPIM_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIM_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Number of bytes in transmit buffer
	// Position of MAXCNT field.
	SPIM_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIM_TXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	SPIM_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIM_TXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIM_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIM_TXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIM_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIM_TXD_LIST_LIST_ArrayList = 0x1

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPIM_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPIM_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPIM_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPIM_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPIM_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPIM_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPIM_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPIM_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPIM_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPIM_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPIM_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPIM_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPIM_CONFIG_CPOL = 0x4
	// Active high
	SPIM_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPIM_CONFIG_CPOL_ActiveLow = 0x1

	// ORC: Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT
	// Position of ORC field.
	SPIM_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	SPIM_ORC_ORC_Msk = 0xff
)

// Constants for SPIS0: SPI Slave 0
const (
	// TASKS_ACQUIRE: Acquire SPI semaphore
	// Position of TASKS_ACQUIRE field.
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Pos = 0x0
	// Bit mask of TASKS_ACQUIRE field.
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Msk = 0x1
	// Bit TASKS_ACQUIRE.
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE = 0x1
	// Trigger task
	SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Trigger = 0x1

	// TASKS_RELEASE: Release SPI semaphore, enabling the SPI slave to acquire it
	// Position of TASKS_RELEASE field.
	SPIS_TASKS_RELEASE_TASKS_RELEASE_Pos = 0x0
	// Bit mask of TASKS_RELEASE field.
	SPIS_TASKS_RELEASE_TASKS_RELEASE_Msk = 0x1
	// Bit TASKS_RELEASE.
	SPIS_TASKS_RELEASE_TASKS_RELEASE = 0x1
	// Trigger task
	SPIS_TASKS_RELEASE_TASKS_RELEASE_Trigger = 0x1

	// EVENTS_END: Granted transaction completed
	// Position of EVENTS_END field.
	SPIS_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	SPIS_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	SPIS_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	SPIS_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	SPIS_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_ENDRX: End of RXD buffer reached
	// Position of EVENTS_ENDRX field.
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Pos = 0x0
	// Bit mask of EVENTS_ENDRX field.
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Msk = 0x1
	// Bit EVENTS_ENDRX.
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX = 0x1
	// Event not generated
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated = 0x0
	// Event generated
	SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Generated = 0x1

	// EVENTS_ACQUIRED: Semaphore acquired
	// Position of EVENTS_ACQUIRED field.
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Pos = 0x0
	// Bit mask of EVENTS_ACQUIRED field.
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Msk = 0x1
	// Bit EVENTS_ACQUIRED.
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED = 0x1
	// Event not generated
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_NotGenerated = 0x0
	// Event generated
	SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of END_ACQUIRE field.
	SPIS_SHORTS_END_ACQUIRE_Pos = 0x2
	// Bit mask of END_ACQUIRE field.
	SPIS_SHORTS_END_ACQUIRE_Msk = 0x4
	// Bit END_ACQUIRE.
	SPIS_SHORTS_END_ACQUIRE = 0x4
	// Disable shortcut
	SPIS_SHORTS_END_ACQUIRE_Disabled = 0x0
	// Enable shortcut
	SPIS_SHORTS_END_ACQUIRE_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of END field.
	SPIS_INTENSET_END_Pos = 0x1
	// Bit mask of END field.
	SPIS_INTENSET_END_Msk = 0x2
	// Bit END.
	SPIS_INTENSET_END = 0x2
	// Read: Disabled
	SPIS_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_END_Enabled = 0x1
	// Enable
	SPIS_INTENSET_END_Set = 0x1
	// Position of ENDRX field.
	SPIS_INTENSET_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIS_INTENSET_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIS_INTENSET_ENDRX = 0x10
	// Read: Disabled
	SPIS_INTENSET_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_ENDRX_Enabled = 0x1
	// Enable
	SPIS_INTENSET_ENDRX_Set = 0x1
	// Position of ACQUIRED field.
	SPIS_INTENSET_ACQUIRED_Pos = 0xa
	// Bit mask of ACQUIRED field.
	SPIS_INTENSET_ACQUIRED_Msk = 0x400
	// Bit ACQUIRED.
	SPIS_INTENSET_ACQUIRED = 0x400
	// Read: Disabled
	SPIS_INTENSET_ACQUIRED_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENSET_ACQUIRED_Enabled = 0x1
	// Enable
	SPIS_INTENSET_ACQUIRED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of END field.
	SPIS_INTENCLR_END_Pos = 0x1
	// Bit mask of END field.
	SPIS_INTENCLR_END_Msk = 0x2
	// Bit END.
	SPIS_INTENCLR_END = 0x2
	// Read: Disabled
	SPIS_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_END_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_END_Clear = 0x1
	// Position of ENDRX field.
	SPIS_INTENCLR_ENDRX_Pos = 0x4
	// Bit mask of ENDRX field.
	SPIS_INTENCLR_ENDRX_Msk = 0x10
	// Bit ENDRX.
	SPIS_INTENCLR_ENDRX = 0x10
	// Read: Disabled
	SPIS_INTENCLR_ENDRX_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_ENDRX_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_ENDRX_Clear = 0x1
	// Position of ACQUIRED field.
	SPIS_INTENCLR_ACQUIRED_Pos = 0xa
	// Bit mask of ACQUIRED field.
	SPIS_INTENCLR_ACQUIRED_Msk = 0x400
	// Bit ACQUIRED.
	SPIS_INTENCLR_ACQUIRED = 0x400
	// Read: Disabled
	SPIS_INTENCLR_ACQUIRED_Disabled = 0x0
	// Read: Enabled
	SPIS_INTENCLR_ACQUIRED_Enabled = 0x1
	// Disable
	SPIS_INTENCLR_ACQUIRED_Clear = 0x1

	// SEMSTAT: Semaphore status register
	// Position of SEMSTAT field.
	SPIS_SEMSTAT_SEMSTAT_Pos = 0x0
	// Bit mask of SEMSTAT field.
	SPIS_SEMSTAT_SEMSTAT_Msk = 0x3
	// Semaphore is free
	SPIS_SEMSTAT_SEMSTAT_Free = 0x0
	// Semaphore is assigned to CPU
	SPIS_SEMSTAT_SEMSTAT_CPU = 0x1
	// Semaphore is assigned to SPI slave
	SPIS_SEMSTAT_SEMSTAT_SPIS = 0x2
	// Semaphore is assigned to SPI but a handover to the CPU is pending
	SPIS_SEMSTAT_SEMSTAT_CPUPending = 0x3

	// STATUS: Status from last transaction
	// Position of OVERREAD field.
	SPIS_STATUS_OVERREAD_Pos = 0x0
	// Bit mask of OVERREAD field.
	SPIS_STATUS_OVERREAD_Msk = 0x1
	// Bit OVERREAD.
	SPIS_STATUS_OVERREAD = 0x1
	// Read: error not present
	SPIS_STATUS_OVERREAD_NotPresent = 0x0
	// Read: error present
	SPIS_STATUS_OVERREAD_Present = 0x1
	// Write: clear error on writing '1'
	SPIS_STATUS_OVERREAD_Clear = 0x1
	// Position of OVERFLOW field.
	SPIS_STATUS_OVERFLOW_Pos = 0x1
	// Bit mask of OVERFLOW field.
	SPIS_STATUS_OVERFLOW_Msk = 0x2
	// Bit OVERFLOW.
	SPIS_STATUS_OVERFLOW = 0x2
	// Read: error not present
	SPIS_STATUS_OVERFLOW_NotPresent = 0x0
	// Read: error present
	SPIS_STATUS_OVERFLOW_Present = 0x1
	// Write: clear error on writing '1'
	SPIS_STATUS_OVERFLOW_Clear = 0x1

	// ENABLE: Enable SPI slave
	// Position of ENABLE field.
	SPIS_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPIS_ENABLE_ENABLE_Msk = 0xf
	// Disable SPI slave
	SPIS_ENABLE_ENABLE_Disabled = 0x0
	// Enable SPI slave
	SPIS_ENABLE_ENABLE_Enabled = 0x2

	// PSEL.SCK: Pin select for SCK
	// Position of PIN field.
	SPIS_PSEL_SCK_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_SCK_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_SCK_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_SCK_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_SCK_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_SCK_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_SCK_CONNECT_Connected = 0x0

	// PSEL.MISO: Pin select for MISO signal
	// Position of PIN field.
	SPIS_PSEL_MISO_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_MISO_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_MISO_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_MISO_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_MISO_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_MISO_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_MISO_CONNECT_Connected = 0x0

	// PSEL.MOSI: Pin select for MOSI signal
	// Position of PIN field.
	SPIS_PSEL_MOSI_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_MOSI_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_MOSI_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_MOSI_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_MOSI_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_MOSI_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_MOSI_CONNECT_Connected = 0x0

	// PSEL.CSN: Pin select for CSN signal
	// Position of PIN field.
	SPIS_PSEL_CSN_PIN_Pos = 0x0
	// Bit mask of PIN field.
	SPIS_PSEL_CSN_PIN_Msk = 0x1f
	// Position of CONNECT field.
	SPIS_PSEL_CSN_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	SPIS_PSEL_CSN_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	SPIS_PSEL_CSN_CONNECT = 0x80000000
	// Disconnect
	SPIS_PSEL_CSN_CONNECT_Disconnected = 0x1
	// Connect
	SPIS_PSEL_CSN_CONNECT_Connected = 0x0

	// RXD.PTR: RXD data pointer
	// Position of PTR field.
	SPIS_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIS_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	SPIS_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIS_RXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// RXD.AMOUNT: Number of bytes received in last granted transaction
	// Position of AMOUNT field.
	SPIS_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIS_RXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIS_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIS_RXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIS_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIS_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: TXD data pointer
	// Position of PTR field.
	SPIS_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	SPIS_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	SPIS_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	SPIS_TXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// TXD.AMOUNT: Number of bytes transmitted in last granted transaction
	// Position of AMOUNT field.
	SPIS_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	SPIS_TXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	SPIS_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	SPIS_TXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	SPIS_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	SPIS_TXD_LIST_LIST_ArrayList = 0x1

	// CONFIG: Configuration register
	// Position of ORDER field.
	SPIS_CONFIG_ORDER_Pos = 0x0
	// Bit mask of ORDER field.
	SPIS_CONFIG_ORDER_Msk = 0x1
	// Bit ORDER.
	SPIS_CONFIG_ORDER = 0x1
	// Most significant bit shifted out first
	SPIS_CONFIG_ORDER_MsbFirst = 0x0
	// Least significant bit shifted out first
	SPIS_CONFIG_ORDER_LsbFirst = 0x1
	// Position of CPHA field.
	SPIS_CONFIG_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	SPIS_CONFIG_CPHA_Msk = 0x2
	// Bit CPHA.
	SPIS_CONFIG_CPHA = 0x2
	// Sample on leading edge of clock, shift serial data on trailing edge
	SPIS_CONFIG_CPHA_Leading = 0x0
	// Sample on trailing edge of clock, shift serial data on leading edge
	SPIS_CONFIG_CPHA_Trailing = 0x1
	// Position of CPOL field.
	SPIS_CONFIG_CPOL_Pos = 0x2
	// Bit mask of CPOL field.
	SPIS_CONFIG_CPOL_Msk = 0x4
	// Bit CPOL.
	SPIS_CONFIG_CPOL = 0x4
	// Active high
	SPIS_CONFIG_CPOL_ActiveHigh = 0x0
	// Active low
	SPIS_CONFIG_CPOL_ActiveLow = 0x1

	// DEF: Default character. Character clocked out in case of an ignored transaction.
	// Position of DEF field.
	SPIS_DEF_DEF_Pos = 0x0
	// Bit mask of DEF field.
	SPIS_DEF_DEF_Msk = 0xff

	// ORC: Over-read character
	// Position of ORC field.
	SPIS_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	SPIS_ORC_ORC_Msk = 0xff
)

// Constants for TWI0: I2C compatible Two-Wire Interface 0
const (
	// TASKS_STARTRX: Start TWI receive sequence
	// Position of TASKS_STARTRX field.
	TWI_TASKS_STARTRX_TASKS_STARTRX_Pos = 0x0
	// Bit mask of TASKS_STARTRX field.
	TWI_TASKS_STARTRX_TASKS_STARTRX_Msk = 0x1
	// Bit TASKS_STARTRX.
	TWI_TASKS_STARTRX_TASKS_STARTRX = 0x1
	// Trigger task
	TWI_TASKS_STARTRX_TASKS_STARTRX_Trigger = 0x1

	// TASKS_STARTTX: Start TWI transmit sequence
	// Position of TASKS_STARTTX field.
	TWI_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	TWI_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	TWI_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	TWI_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_STOP: Stop TWI transaction
	// Position of TASKS_STOP field.
	TWI_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TWI_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TWI_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TWI_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend TWI transaction
	// Position of TASKS_SUSPEND field.
	TWI_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	TWI_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	TWI_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	TWI_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume TWI transaction
	// Position of TASKS_RESUME field.
	TWI_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	TWI_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	TWI_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	TWI_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// EVENTS_STOPPED: TWI stopped
	// Position of EVENTS_STOPPED field.
	TWI_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	TWI_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	TWI_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	TWI_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	TWI_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_RXDREADY: TWI RXD byte received
	// Position of EVENTS_RXDREADY field.
	TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Pos = 0x0
	// Bit mask of EVENTS_RXDREADY field.
	TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Msk = 0x1
	// Bit EVENTS_RXDREADY.
	TWI_EVENTS_RXDREADY_EVENTS_RXDREADY = 0x1
	// Event not generated
	TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_NotGenerated = 0x0
	// Event generated
	TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Generated = 0x1

	// EVENTS_TXDSENT: TWI TXD byte sent
	// Position of EVENTS_TXDSENT field.
	TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Pos = 0x0
	// Bit mask of EVENTS_TXDSENT field.
	TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Msk = 0x1
	// Bit EVENTS_TXDSENT.
	TWI_EVENTS_TXDSENT_EVENTS_TXDSENT = 0x1
	// Event not generated
	TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_NotGenerated = 0x0
	// Event generated
	TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Generated = 0x1

	// EVENTS_ERROR: TWI error
	// Position of EVENTS_ERROR field.
	TWI_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	TWI_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	TWI_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	TWI_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	TWI_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_BB: TWI byte boundary, generated before each byte that is sent or received
	// Position of EVENTS_BB field.
	TWI_EVENTS_BB_EVENTS_BB_Pos = 0x0
	// Bit mask of EVENTS_BB field.
	TWI_EVENTS_BB_EVENTS_BB_Msk = 0x1
	// Bit EVENTS_BB.
	TWI_EVENTS_BB_EVENTS_BB = 0x1
	// Event not generated
	TWI_EVENTS_BB_EVENTS_BB_NotGenerated = 0x0
	// Event generated
	TWI_EVENTS_BB_EVENTS_BB_Generated = 0x1

	// EVENTS_SUSPENDED: TWI entered the suspended state
	// Position of EVENTS_SUSPENDED field.
	TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos = 0x0
	// Bit mask of EVENTS_SUSPENDED field.
	TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Msk = 0x1
	// Bit EVENTS_SUSPENDED.
	TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED = 0x1
	// Event not generated
	TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_NotGenerated = 0x0
	// Event generated
	TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of BB_SUSPEND field.
	TWI_SHORTS_BB_SUSPEND_Pos = 0x0
	// Bit mask of BB_SUSPEND field.
	TWI_SHORTS_BB_SUSPEND_Msk = 0x1
	// Bit BB_SUSPEND.
	TWI_SHORTS_BB_SUSPEND = 0x1
	// Disable shortcut
	TWI_SHORTS_BB_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWI_SHORTS_BB_SUSPEND_Enabled = 0x1
	// Position of BB_STOP field.
	TWI_SHORTS_BB_STOP_Pos = 0x1
	// Bit mask of BB_STOP field.
	TWI_SHORTS_BB_STOP_Msk = 0x2
	// Bit BB_STOP.
	TWI_SHORTS_BB_STOP = 0x2
	// Disable shortcut
	TWI_SHORTS_BB_STOP_Disabled = 0x0
	// Enable shortcut
	TWI_SHORTS_BB_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWI_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWI_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWI_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWI_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWI_INTENSET_STOPPED_Set = 0x1
	// Position of RXDREADY field.
	TWI_INTENSET_RXDREADY_Pos = 0x2
	// Bit mask of RXDREADY field.
	TWI_INTENSET_RXDREADY_Msk = 0x4
	// Bit RXDREADY.
	TWI_INTENSET_RXDREADY = 0x4
	// Read: Disabled
	TWI_INTENSET_RXDREADY_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_RXDREADY_Enabled = 0x1
	// Enable
	TWI_INTENSET_RXDREADY_Set = 0x1
	// Position of TXDSENT field.
	TWI_INTENSET_TXDSENT_Pos = 0x7
	// Bit mask of TXDSENT field.
	TWI_INTENSET_TXDSENT_Msk = 0x80
	// Bit TXDSENT.
	TWI_INTENSET_TXDSENT = 0x80
	// Read: Disabled
	TWI_INTENSET_TXDSENT_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_TXDSENT_Enabled = 0x1
	// Enable
	TWI_INTENSET_TXDSENT_Set = 0x1
	// Position of ERROR field.
	TWI_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWI_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWI_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWI_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWI_INTENSET_ERROR_Set = 0x1
	// Position of BB field.
	TWI_INTENSET_BB_Pos = 0xe
	// Bit mask of BB field.
	TWI_INTENSET_BB_Msk = 0x4000
	// Bit BB.
	TWI_INTENSET_BB = 0x4000
	// Read: Disabled
	TWI_INTENSET_BB_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_BB_Enabled = 0x1
	// Enable
	TWI_INTENSET_BB_Set = 0x1
	// Position of SUSPENDED field.
	TWI_INTENSET_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWI_INTENSET_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWI_INTENSET_SUSPENDED = 0x40000
	// Read: Disabled
	TWI_INTENSET_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENSET_SUSPENDED_Enabled = 0x1
	// Enable
	TWI_INTENSET_SUSPENDED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWI_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWI_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWI_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWI_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWI_INTENCLR_STOPPED_Clear = 0x1
	// Position of RXDREADY field.
	TWI_INTENCLR_RXDREADY_Pos = 0x2
	// Bit mask of RXDREADY field.
	TWI_INTENCLR_RXDREADY_Msk = 0x4
	// Bit RXDREADY.
	TWI_INTENCLR_RXDREADY = 0x4
	// Read: Disabled
	TWI_INTENCLR_RXDREADY_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_RXDREADY_Enabled = 0x1
	// Disable
	TWI_INTENCLR_RXDREADY_Clear = 0x1
	// Position of TXDSENT field.
	TWI_INTENCLR_TXDSENT_Pos = 0x7
	// Bit mask of TXDSENT field.
	TWI_INTENCLR_TXDSENT_Msk = 0x80
	// Bit TXDSENT.
	TWI_INTENCLR_TXDSENT = 0x80
	// Read: Disabled
	TWI_INTENCLR_TXDSENT_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_TXDSENT_Enabled = 0x1
	// Disable
	TWI_INTENCLR_TXDSENT_Clear = 0x1
	// Position of ERROR field.
	TWI_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWI_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWI_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWI_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWI_INTENCLR_ERROR_Clear = 0x1
	// Position of BB field.
	TWI_INTENCLR_BB_Pos = 0xe
	// Bit mask of BB field.
	TWI_INTENCLR_BB_Msk = 0x4000
	// Bit BB.
	TWI_INTENCLR_BB = 0x4000
	// Read: Disabled
	TWI_INTENCLR_BB_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_BB_Enabled = 0x1
	// Disable
	TWI_INTENCLR_BB_Clear = 0x1
	// Position of SUSPENDED field.
	TWI_INTENCLR_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWI_INTENCLR_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWI_INTENCLR_SUSPENDED = 0x40000
	// Read: Disabled
	TWI_INTENCLR_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWI_INTENCLR_SUSPENDED_Enabled = 0x1
	// Disable
	TWI_INTENCLR_SUSPENDED_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	TWI_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	TWI_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	TWI_ERRORSRC_OVERRUN = 0x1
	// Read: no overrun occured
	TWI_ERRORSRC_OVERRUN_NotPresent = 0x0
	// Read: overrun occured
	TWI_ERRORSRC_OVERRUN_Present = 0x1
	// Position of ANACK field.
	TWI_ERRORSRC_ANACK_Pos = 0x1
	// Bit mask of ANACK field.
	TWI_ERRORSRC_ANACK_Msk = 0x2
	// Bit ANACK.
	TWI_ERRORSRC_ANACK = 0x2
	// Read: error not present
	TWI_ERRORSRC_ANACK_NotPresent = 0x0
	// Read: error present
	TWI_ERRORSRC_ANACK_Present = 0x1
	// Position of DNACK field.
	TWI_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWI_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWI_ERRORSRC_DNACK = 0x4
	// Read: error not present
	TWI_ERRORSRC_DNACK_NotPresent = 0x0
	// Read: error present
	TWI_ERRORSRC_DNACK_Present = 0x1

	// ENABLE: Enable TWI
	// Position of ENABLE field.
	TWI_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWI_ENABLE_ENABLE_Msk = 0xf
	// Disable TWI
	TWI_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWI
	TWI_ENABLE_ENABLE_Enabled = 0x5

	// PSEL.SCL: Pin select for SCL
	// Position of PIN field.
	TWI_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWI_PSEL_SCL_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWI_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWI_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWI_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWI_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWI_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA
	// Position of PIN field.
	TWI_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWI_PSEL_SDA_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWI_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWI_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWI_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWI_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWI_PSEL_SDA_CONNECT_Connected = 0x0

	// RXD: RXD register
	// Position of RXD field.
	TWI_RXD_RXD_Pos = 0x0
	// Bit mask of RXD field.
	TWI_RXD_RXD_Msk = 0xff

	// TXD: TXD register
	// Position of TXD field.
	TWI_TXD_TXD_Pos = 0x0
	// Bit mask of TXD field.
	TWI_TXD_TXD_Msk = 0xff

	// FREQUENCY: TWI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	TWI_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	TWI_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 100 kbps
	TWI_FREQUENCY_FREQUENCY_K100 = 0x1980000
	// 250 kbps
	TWI_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 400 kbps (actual rate 410.256 kbps)
	TWI_FREQUENCY_FREQUENCY_K400 = 0x6680000

	// ADDRESS: Address used in the TWI transfer
	// Position of ADDRESS field.
	TWI_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWI_ADDRESS_ADDRESS_Msk = 0x7f
)

// Constants for TWIM0: I2C compatible Two-Wire Master Interface with EasyDMA 0
const (
	// TASKS_STARTRX: Start TWI receive sequence
	// Position of TASKS_STARTRX field.
	TWIM_TASKS_STARTRX_TASKS_STARTRX_Pos = 0x0
	// Bit mask of TASKS_STARTRX field.
	TWIM_TASKS_STARTRX_TASKS_STARTRX_Msk = 0x1
	// Bit TASKS_STARTRX.
	TWIM_TASKS_STARTRX_TASKS_STARTRX = 0x1
	// Trigger task
	TWIM_TASKS_STARTRX_TASKS_STARTRX_Trigger = 0x1

	// TASKS_STARTTX: Start TWI transmit sequence
	// Position of TASKS_STARTTX field.
	TWIM_TASKS_STARTTX_TASKS_STARTTX_Pos = 0x0
	// Bit mask of TASKS_STARTTX field.
	TWIM_TASKS_STARTTX_TASKS_STARTTX_Msk = 0x1
	// Bit TASKS_STARTTX.
	TWIM_TASKS_STARTTX_TASKS_STARTTX = 0x1
	// Trigger task
	TWIM_TASKS_STARTTX_TASKS_STARTTX_Trigger = 0x1

	// TASKS_STOP: Stop TWI transaction. Must be issued while the TWI master is not suspended.
	// Position of TASKS_STOP field.
	TWIM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TWIM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TWIM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TWIM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend TWI transaction
	// Position of TASKS_SUSPEND field.
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume TWI transaction
	// Position of TASKS_RESUME field.
	TWIM_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	TWIM_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	TWIM_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	TWIM_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// EVENTS_STOPPED: TWI stopped
	// Position of EVENTS_STOPPED field.
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_ERROR: TWI error
	// Position of EVENTS_ERROR field.
	TWIM_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	TWIM_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	TWIM_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	TWIM_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_SUSPENDED: Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended.
	// Position of EVENTS_SUSPENDED field.
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos = 0x0
	// Bit mask of EVENTS_SUSPENDED field.
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Msk = 0x1
	// Bit EVENTS_SUSPENDED.
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED = 0x1
	// Event not generated
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Generated = 0x1

	// EVENTS_RXSTARTED: Receive sequence started
	// Position of EVENTS_RXSTARTED field.
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_RXSTARTED field.
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk = 0x1
	// Bit EVENTS_RXSTARTED.
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED = 0x1
	// Event not generated
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated = 0x1

	// EVENTS_TXSTARTED: Transmit sequence started
	// Position of EVENTS_TXSTARTED field.
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_TXSTARTED field.
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk = 0x1
	// Bit EVENTS_TXSTARTED.
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED = 0x1
	// Event not generated
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated = 0x1

	// EVENTS_LASTRX: Byte boundary, starting to receive the last byte
	// Position of EVENTS_LASTRX field.
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Pos = 0x0
	// Bit mask of EVENTS_LASTRX field.
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Msk = 0x1
	// Bit EVENTS_LASTRX.
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX = 0x1
	// Event not generated
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Generated = 0x1

	// EVENTS_LASTTX: Byte boundary, starting to transmit the last byte
	// Position of EVENTS_LASTTX field.
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Pos = 0x0
	// Bit mask of EVENTS_LASTTX field.
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Msk = 0x1
	// Bit EVENTS_LASTTX.
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX = 0x1
	// Event not generated
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_NotGenerated = 0x0
	// Event generated
	TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of LASTTX_STARTRX field.
	TWIM_SHORTS_LASTTX_STARTRX_Pos = 0x7
	// Bit mask of LASTTX_STARTRX field.
	TWIM_SHORTS_LASTTX_STARTRX_Msk = 0x80
	// Bit LASTTX_STARTRX.
	TWIM_SHORTS_LASTTX_STARTRX = 0x80
	// Disable shortcut
	TWIM_SHORTS_LASTTX_STARTRX_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_STARTRX_Enabled = 0x1
	// Position of LASTTX_SUSPEND field.
	TWIM_SHORTS_LASTTX_SUSPEND_Pos = 0x8
	// Bit mask of LASTTX_SUSPEND field.
	TWIM_SHORTS_LASTTX_SUSPEND_Msk = 0x100
	// Bit LASTTX_SUSPEND.
	TWIM_SHORTS_LASTTX_SUSPEND = 0x100
	// Disable shortcut
	TWIM_SHORTS_LASTTX_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_SUSPEND_Enabled = 0x1
	// Position of LASTTX_STOP field.
	TWIM_SHORTS_LASTTX_STOP_Pos = 0x9
	// Bit mask of LASTTX_STOP field.
	TWIM_SHORTS_LASTTX_STOP_Msk = 0x200
	// Bit LASTTX_STOP.
	TWIM_SHORTS_LASTTX_STOP = 0x200
	// Disable shortcut
	TWIM_SHORTS_LASTTX_STOP_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTTX_STOP_Enabled = 0x1
	// Position of LASTRX_STARTTX field.
	TWIM_SHORTS_LASTRX_STARTTX_Pos = 0xa
	// Bit mask of LASTRX_STARTTX field.
	TWIM_SHORTS_LASTRX_STARTTX_Msk = 0x400
	// Bit LASTRX_STARTTX.
	TWIM_SHORTS_LASTRX_STARTTX = 0x400
	// Disable shortcut
	TWIM_SHORTS_LASTRX_STARTTX_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_STARTTX_Enabled = 0x1
	// Position of LASTRX_SUSPEND field.
	TWIM_SHORTS_LASTRX_SUSPEND_Pos = 0xb
	// Bit mask of LASTRX_SUSPEND field.
	TWIM_SHORTS_LASTRX_SUSPEND_Msk = 0x800
	// Bit LASTRX_SUSPEND.
	TWIM_SHORTS_LASTRX_SUSPEND = 0x800
	// Disable shortcut
	TWIM_SHORTS_LASTRX_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_SUSPEND_Enabled = 0x1
	// Position of LASTRX_STOP field.
	TWIM_SHORTS_LASTRX_STOP_Pos = 0xc
	// Bit mask of LASTRX_STOP field.
	TWIM_SHORTS_LASTRX_STOP_Msk = 0x1000
	// Bit LASTRX_STOP.
	TWIM_SHORTS_LASTRX_STOP = 0x1000
	// Disable shortcut
	TWIM_SHORTS_LASTRX_STOP_Disabled = 0x0
	// Enable shortcut
	TWIM_SHORTS_LASTRX_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	TWIM_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTEN_STOPPED = 0x2
	// Disable
	TWIM_INTEN_STOPPED_Disabled = 0x0
	// Enable
	TWIM_INTEN_STOPPED_Enabled = 0x1
	// Position of ERROR field.
	TWIM_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTEN_ERROR = 0x200
	// Disable
	TWIM_INTEN_ERROR_Disabled = 0x0
	// Enable
	TWIM_INTEN_ERROR_Enabled = 0x1
	// Position of SUSPENDED field.
	TWIM_INTEN_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTEN_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTEN_SUSPENDED = 0x40000
	// Disable
	TWIM_INTEN_SUSPENDED_Disabled = 0x0
	// Enable
	TWIM_INTEN_SUSPENDED_Enabled = 0x1
	// Position of RXSTARTED field.
	TWIM_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTEN_RXSTARTED = 0x80000
	// Disable
	TWIM_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	TWIM_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	TWIM_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTEN_TXSTARTED = 0x100000
	// Disable
	TWIM_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	TWIM_INTEN_TXSTARTED_Enabled = 0x1
	// Position of LASTRX field.
	TWIM_INTEN_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTEN_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTEN_LASTRX = 0x800000
	// Disable
	TWIM_INTEN_LASTRX_Disabled = 0x0
	// Enable
	TWIM_INTEN_LASTRX_Enabled = 0x1
	// Position of LASTTX field.
	TWIM_INTEN_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTEN_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTEN_LASTTX = 0x1000000
	// Disable
	TWIM_INTEN_LASTTX_Disabled = 0x0
	// Enable
	TWIM_INTEN_LASTTX_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWIM_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWIM_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_STOPPED_Set = 0x1
	// Position of ERROR field.
	TWIM_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWIM_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWIM_INTENSET_ERROR_Set = 0x1
	// Position of SUSPENDED field.
	TWIM_INTENSET_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTENSET_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTENSET_SUSPENDED = 0x40000
	// Read: Disabled
	TWIM_INTENSET_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_SUSPENDED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_SUSPENDED_Set = 0x1
	// Position of RXSTARTED field.
	TWIM_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	TWIM_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	TWIM_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	TWIM_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	TWIM_INTENSET_TXSTARTED_Set = 0x1
	// Position of LASTRX field.
	TWIM_INTENSET_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTENSET_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTENSET_LASTRX = 0x800000
	// Read: Disabled
	TWIM_INTENSET_LASTRX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_LASTRX_Enabled = 0x1
	// Enable
	TWIM_INTENSET_LASTRX_Set = 0x1
	// Position of LASTTX field.
	TWIM_INTENSET_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTENSET_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTENSET_LASTTX = 0x1000000
	// Read: Disabled
	TWIM_INTENSET_LASTTX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENSET_LASTTX_Enabled = 0x1
	// Enable
	TWIM_INTENSET_LASTTX_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWIM_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIM_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIM_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWIM_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_STOPPED_Clear = 0x1
	// Position of ERROR field.
	TWIM_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIM_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIM_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWIM_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_ERROR_Clear = 0x1
	// Position of SUSPENDED field.
	TWIM_INTENCLR_SUSPENDED_Pos = 0x12
	// Bit mask of SUSPENDED field.
	TWIM_INTENCLR_SUSPENDED_Msk = 0x40000
	// Bit SUSPENDED.
	TWIM_INTENCLR_SUSPENDED = 0x40000
	// Read: Disabled
	TWIM_INTENCLR_SUSPENDED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_SUSPENDED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_SUSPENDED_Clear = 0x1
	// Position of RXSTARTED field.
	TWIM_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIM_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIM_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	TWIM_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	TWIM_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIM_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIM_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	TWIM_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of LASTRX field.
	TWIM_INTENCLR_LASTRX_Pos = 0x17
	// Bit mask of LASTRX field.
	TWIM_INTENCLR_LASTRX_Msk = 0x800000
	// Bit LASTRX.
	TWIM_INTENCLR_LASTRX = 0x800000
	// Read: Disabled
	TWIM_INTENCLR_LASTRX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_LASTRX_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_LASTRX_Clear = 0x1
	// Position of LASTTX field.
	TWIM_INTENCLR_LASTTX_Pos = 0x18
	// Bit mask of LASTTX field.
	TWIM_INTENCLR_LASTTX_Msk = 0x1000000
	// Bit LASTTX.
	TWIM_INTENCLR_LASTTX = 0x1000000
	// Read: Disabled
	TWIM_INTENCLR_LASTTX_Disabled = 0x0
	// Read: Enabled
	TWIM_INTENCLR_LASTTX_Enabled = 0x1
	// Disable
	TWIM_INTENCLR_LASTTX_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERRUN field.
	TWIM_ERRORSRC_OVERRUN_Pos = 0x0
	// Bit mask of OVERRUN field.
	TWIM_ERRORSRC_OVERRUN_Msk = 0x1
	// Bit OVERRUN.
	TWIM_ERRORSRC_OVERRUN = 0x1
	// Error did not occur
	TWIM_ERRORSRC_OVERRUN_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_OVERRUN_Received = 0x1
	// Position of ANACK field.
	TWIM_ERRORSRC_ANACK_Pos = 0x1
	// Bit mask of ANACK field.
	TWIM_ERRORSRC_ANACK_Msk = 0x2
	// Bit ANACK.
	TWIM_ERRORSRC_ANACK = 0x2
	// Error did not occur
	TWIM_ERRORSRC_ANACK_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_ANACK_Received = 0x1
	// Position of DNACK field.
	TWIM_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWIM_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWIM_ERRORSRC_DNACK = 0x4
	// Error did not occur
	TWIM_ERRORSRC_DNACK_NotReceived = 0x0
	// Error occurred
	TWIM_ERRORSRC_DNACK_Received = 0x1

	// ENABLE: Enable TWIM
	// Position of ENABLE field.
	TWIM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWIM_ENABLE_ENABLE_Msk = 0xf
	// Disable TWIM
	TWIM_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWIM
	TWIM_ENABLE_ENABLE_Enabled = 0x6

	// PSEL.SCL: Pin select for SCL signal
	// Position of PIN field.
	TWIM_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIM_PSEL_SCL_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIM_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIM_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIM_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWIM_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWIM_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA signal
	// Position of PIN field.
	TWIM_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIM_PSEL_SDA_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIM_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIM_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIM_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWIM_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWIM_PSEL_SDA_CONNECT_Connected = 0x0

	// FREQUENCY: TWI frequency. Accuracy depends on the HFCLK source selected.
	// Position of FREQUENCY field.
	TWIM_FREQUENCY_FREQUENCY_Pos = 0x0
	// Bit mask of FREQUENCY field.
	TWIM_FREQUENCY_FREQUENCY_Msk = 0xffffffff
	// 100 kbps
	TWIM_FREQUENCY_FREQUENCY_K100 = 0x1980000
	// 250 kbps
	TWIM_FREQUENCY_FREQUENCY_K250 = 0x4000000
	// 400 kbps
	TWIM_FREQUENCY_FREQUENCY_K400 = 0x6400000

	// RXD.PTR: Data pointer
	// Position of PTR field.
	TWIM_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIM_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in receive buffer
	// Position of MAXCNT field.
	TWIM_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIM_RXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// RXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	TWIM_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIM_RXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIM_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIM_RXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	TWIM_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIM_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: Data pointer
	// Position of PTR field.
	TWIM_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIM_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in transmit buffer
	// Position of MAXCNT field.
	TWIM_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIM_TXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// TXD.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	TWIM_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIM_TXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIM_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIM_TXD_LIST_LIST_Msk = 0x7
	// Disable EasyDMA list
	TWIM_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIM_TXD_LIST_LIST_ArrayList = 0x1

	// ADDRESS: Address used in the TWI transfer
	// Position of ADDRESS field.
	TWIM_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWIM_ADDRESS_ADDRESS_Msk = 0x7f
)

// Constants for TWIS0: I2C compatible Two-Wire Slave Interface with EasyDMA 0
const (
	// TASKS_STOP: Stop TWI transaction
	// Position of TASKS_STOP field.
	TWIS_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TWIS_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TWIS_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TWIS_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SUSPEND: Suspend TWI transaction
	// Position of TASKS_SUSPEND field.
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Pos = 0x0
	// Bit mask of TASKS_SUSPEND field.
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Msk = 0x1
	// Bit TASKS_SUSPEND.
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND = 0x1
	// Trigger task
	TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Trigger = 0x1

	// TASKS_RESUME: Resume TWI transaction
	// Position of TASKS_RESUME field.
	TWIS_TASKS_RESUME_TASKS_RESUME_Pos = 0x0
	// Bit mask of TASKS_RESUME field.
	TWIS_TASKS_RESUME_TASKS_RESUME_Msk = 0x1
	// Bit TASKS_RESUME.
	TWIS_TASKS_RESUME_TASKS_RESUME = 0x1
	// Trigger task
	TWIS_TASKS_RESUME_TASKS_RESUME_Trigger = 0x1

	// TASKS_PREPARERX: Prepare the TWI slave to respond to a write command
	// Position of TASKS_PREPARERX field.
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Pos = 0x0
	// Bit mask of TASKS_PREPARERX field.
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Msk = 0x1
	// Bit TASKS_PREPARERX.
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX = 0x1
	// Trigger task
	TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Trigger = 0x1

	// TASKS_PREPARETX: Prepare the TWI slave to respond to a read command
	// Position of TASKS_PREPARETX field.
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Pos = 0x0
	// Bit mask of TASKS_PREPARETX field.
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Msk = 0x1
	// Bit TASKS_PREPARETX.
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX = 0x1
	// Trigger task
	TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Trigger = 0x1

	// EVENTS_STOPPED: TWI stopped
	// Position of EVENTS_STOPPED field.
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// EVENTS_ERROR: TWI error
	// Position of EVENTS_ERROR field.
	TWIS_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	TWIS_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	TWIS_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	TWIS_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// EVENTS_RXSTARTED: Receive sequence started
	// Position of EVENTS_RXSTARTED field.
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_RXSTARTED field.
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk = 0x1
	// Bit EVENTS_RXSTARTED.
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED = 0x1
	// Event not generated
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated = 0x1

	// EVENTS_TXSTARTED: Transmit sequence started
	// Position of EVENTS_TXSTARTED field.
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos = 0x0
	// Bit mask of EVENTS_TXSTARTED field.
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk = 0x1
	// Bit EVENTS_TXSTARTED.
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED = 0x1
	// Event not generated
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated = 0x1

	// EVENTS_WRITE: Write command received
	// Position of EVENTS_WRITE field.
	TWIS_EVENTS_WRITE_EVENTS_WRITE_Pos = 0x0
	// Bit mask of EVENTS_WRITE field.
	TWIS_EVENTS_WRITE_EVENTS_WRITE_Msk = 0x1
	// Bit EVENTS_WRITE.
	TWIS_EVENTS_WRITE_EVENTS_WRITE = 0x1
	// Event not generated
	TWIS_EVENTS_WRITE_EVENTS_WRITE_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_WRITE_EVENTS_WRITE_Generated = 0x1

	// EVENTS_READ: Read command received
	// Position of EVENTS_READ field.
	TWIS_EVENTS_READ_EVENTS_READ_Pos = 0x0
	// Bit mask of EVENTS_READ field.
	TWIS_EVENTS_READ_EVENTS_READ_Msk = 0x1
	// Bit EVENTS_READ.
	TWIS_EVENTS_READ_EVENTS_READ = 0x1
	// Event not generated
	TWIS_EVENTS_READ_EVENTS_READ_NotGenerated = 0x0
	// Event generated
	TWIS_EVENTS_READ_EVENTS_READ_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of WRITE_SUSPEND field.
	TWIS_SHORTS_WRITE_SUSPEND_Pos = 0xd
	// Bit mask of WRITE_SUSPEND field.
	TWIS_SHORTS_WRITE_SUSPEND_Msk = 0x2000
	// Bit WRITE_SUSPEND.
	TWIS_SHORTS_WRITE_SUSPEND = 0x2000
	// Disable shortcut
	TWIS_SHORTS_WRITE_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIS_SHORTS_WRITE_SUSPEND_Enabled = 0x1
	// Position of READ_SUSPEND field.
	TWIS_SHORTS_READ_SUSPEND_Pos = 0xe
	// Bit mask of READ_SUSPEND field.
	TWIS_SHORTS_READ_SUSPEND_Msk = 0x4000
	// Bit READ_SUSPEND.
	TWIS_SHORTS_READ_SUSPEND = 0x4000
	// Disable shortcut
	TWIS_SHORTS_READ_SUSPEND_Disabled = 0x0
	// Enable shortcut
	TWIS_SHORTS_READ_SUSPEND_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of STOPPED field.
	TWIS_INTEN_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTEN_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTEN_STOPPED = 0x2
	// Disable
	TWIS_INTEN_STOPPED_Disabled = 0x0
	// Enable
	TWIS_INTEN_STOPPED_Enabled = 0x1
	// Position of ERROR field.
	TWIS_INTEN_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTEN_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTEN_ERROR = 0x200
	// Disable
	TWIS_INTEN_ERROR_Disabled = 0x0
	// Enable
	TWIS_INTEN_ERROR_Enabled = 0x1
	// Position of RXSTARTED field.
	TWIS_INTEN_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTEN_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTEN_RXSTARTED = 0x80000
	// Disable
	TWIS_INTEN_RXSTARTED_Disabled = 0x0
	// Enable
	TWIS_INTEN_RXSTARTED_Enabled = 0x1
	// Position of TXSTARTED field.
	TWIS_INTEN_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTEN_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTEN_TXSTARTED = 0x100000
	// Disable
	TWIS_INTEN_TXSTARTED_Disabled = 0x0
	// Enable
	TWIS_INTEN_TXSTARTED_Enabled = 0x1
	// Position of WRITE field.
	TWIS_INTEN_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTEN_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTEN_WRITE = 0x2000000
	// Disable
	TWIS_INTEN_WRITE_Disabled = 0x0
	// Enable
	TWIS_INTEN_WRITE_Enabled = 0x1
	// Position of READ field.
	TWIS_INTEN_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTEN_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTEN_READ = 0x4000000
	// Disable
	TWIS_INTEN_READ_Disabled = 0x0
	// Enable
	TWIS_INTEN_READ_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of STOPPED field.
	TWIS_INTENSET_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTENSET_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTENSET_STOPPED = 0x2
	// Read: Disabled
	TWIS_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_STOPPED_Set = 0x1
	// Position of ERROR field.
	TWIS_INTENSET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTENSET_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTENSET_ERROR = 0x200
	// Read: Disabled
	TWIS_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_ERROR_Enabled = 0x1
	// Enable
	TWIS_INTENSET_ERROR_Set = 0x1
	// Position of RXSTARTED field.
	TWIS_INTENSET_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTENSET_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTENSET_RXSTARTED = 0x80000
	// Read: Disabled
	TWIS_INTENSET_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_RXSTARTED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_RXSTARTED_Set = 0x1
	// Position of TXSTARTED field.
	TWIS_INTENSET_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTENSET_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTENSET_TXSTARTED = 0x100000
	// Read: Disabled
	TWIS_INTENSET_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_TXSTARTED_Enabled = 0x1
	// Enable
	TWIS_INTENSET_TXSTARTED_Set = 0x1
	// Position of WRITE field.
	TWIS_INTENSET_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTENSET_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTENSET_WRITE = 0x2000000
	// Read: Disabled
	TWIS_INTENSET_WRITE_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_WRITE_Enabled = 0x1
	// Enable
	TWIS_INTENSET_WRITE_Set = 0x1
	// Position of READ field.
	TWIS_INTENSET_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTENSET_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTENSET_READ = 0x4000000
	// Read: Disabled
	TWIS_INTENSET_READ_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENSET_READ_Enabled = 0x1
	// Enable
	TWIS_INTENSET_READ_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of STOPPED field.
	TWIS_INTENCLR_STOPPED_Pos = 0x1
	// Bit mask of STOPPED field.
	TWIS_INTENCLR_STOPPED_Msk = 0x2
	// Bit STOPPED.
	TWIS_INTENCLR_STOPPED = 0x2
	// Read: Disabled
	TWIS_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_STOPPED_Clear = 0x1
	// Position of ERROR field.
	TWIS_INTENCLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	TWIS_INTENCLR_ERROR_Msk = 0x200
	// Bit ERROR.
	TWIS_INTENCLR_ERROR = 0x200
	// Read: Disabled
	TWIS_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_ERROR_Clear = 0x1
	// Position of RXSTARTED field.
	TWIS_INTENCLR_RXSTARTED_Pos = 0x13
	// Bit mask of RXSTARTED field.
	TWIS_INTENCLR_RXSTARTED_Msk = 0x80000
	// Bit RXSTARTED.
	TWIS_INTENCLR_RXSTARTED = 0x80000
	// Read: Disabled
	TWIS_INTENCLR_RXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_RXSTARTED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_RXSTARTED_Clear = 0x1
	// Position of TXSTARTED field.
	TWIS_INTENCLR_TXSTARTED_Pos = 0x14
	// Bit mask of TXSTARTED field.
	TWIS_INTENCLR_TXSTARTED_Msk = 0x100000
	// Bit TXSTARTED.
	TWIS_INTENCLR_TXSTARTED = 0x100000
	// Read: Disabled
	TWIS_INTENCLR_TXSTARTED_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_TXSTARTED_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_TXSTARTED_Clear = 0x1
	// Position of WRITE field.
	TWIS_INTENCLR_WRITE_Pos = 0x19
	// Bit mask of WRITE field.
	TWIS_INTENCLR_WRITE_Msk = 0x2000000
	// Bit WRITE.
	TWIS_INTENCLR_WRITE = 0x2000000
	// Read: Disabled
	TWIS_INTENCLR_WRITE_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_WRITE_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_WRITE_Clear = 0x1
	// Position of READ field.
	TWIS_INTENCLR_READ_Pos = 0x1a
	// Bit mask of READ field.
	TWIS_INTENCLR_READ_Msk = 0x4000000
	// Bit READ.
	TWIS_INTENCLR_READ = 0x4000000
	// Read: Disabled
	TWIS_INTENCLR_READ_Disabled = 0x0
	// Read: Enabled
	TWIS_INTENCLR_READ_Enabled = 0x1
	// Disable
	TWIS_INTENCLR_READ_Clear = 0x1

	// ERRORSRC: Error source
	// Position of OVERFLOW field.
	TWIS_ERRORSRC_OVERFLOW_Pos = 0x0
	// Bit mask of OVERFLOW field.
	TWIS_ERRORSRC_OVERFLOW_Msk = 0x1
	// Bit OVERFLOW.
	TWIS_ERRORSRC_OVERFLOW = 0x1
	// Error did not occur
	TWIS_ERRORSRC_OVERFLOW_NotDetected = 0x0
	// Error occurred
	TWIS_ERRORSRC_OVERFLOW_Detected = 0x1
	// Position of DNACK field.
	TWIS_ERRORSRC_DNACK_Pos = 0x2
	// Bit mask of DNACK field.
	TWIS_ERRORSRC_DNACK_Msk = 0x4
	// Bit DNACK.
	TWIS_ERRORSRC_DNACK = 0x4
	// Error did not occur
	TWIS_ERRORSRC_DNACK_NotReceived = 0x0
	// Error occurred
	TWIS_ERRORSRC_DNACK_Received = 0x1
	// Position of OVERREAD field.
	TWIS_ERRORSRC_OVERREAD_Pos = 0x3
	// Bit mask of OVERREAD field.
	TWIS_ERRORSRC_OVERREAD_Msk = 0x8
	// Bit OVERREAD.
	TWIS_ERRORSRC_OVERREAD = 0x8
	// Error did not occur
	TWIS_ERRORSRC_OVERREAD_NotDetected = 0x0
	// Error occurred
	TWIS_ERRORSRC_OVERREAD_Detected = 0x1

	// MATCH: Status register indicating which address had a match
	// Position of MATCH field.
	TWIS_MATCH_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	TWIS_MATCH_MATCH_Msk = 0x1
	// Bit MATCH.
	TWIS_MATCH_MATCH = 0x1

	// ENABLE: Enable TWIS
	// Position of ENABLE field.
	TWIS_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TWIS_ENABLE_ENABLE_Msk = 0xf
	// Disable TWIS
	TWIS_ENABLE_ENABLE_Disabled = 0x0
	// Enable TWIS
	TWIS_ENABLE_ENABLE_Enabled = 0x9

	// PSEL.SCL: Pin select for SCL signal
	// Position of PIN field.
	TWIS_PSEL_SCL_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIS_PSEL_SCL_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIS_PSEL_SCL_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIS_PSEL_SCL_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIS_PSEL_SCL_CONNECT = 0x80000000
	// Disconnect
	TWIS_PSEL_SCL_CONNECT_Disconnected = 0x1
	// Connect
	TWIS_PSEL_SCL_CONNECT_Connected = 0x0

	// PSEL.SDA: Pin select for SDA signal
	// Position of PIN field.
	TWIS_PSEL_SDA_PIN_Pos = 0x0
	// Bit mask of PIN field.
	TWIS_PSEL_SDA_PIN_Msk = 0x1f
	// Position of CONNECT field.
	TWIS_PSEL_SDA_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	TWIS_PSEL_SDA_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	TWIS_PSEL_SDA_CONNECT = 0x80000000
	// Disconnect
	TWIS_PSEL_SDA_CONNECT_Disconnected = 0x1
	// Connect
	TWIS_PSEL_SDA_CONNECT_Connected = 0x0

	// RXD.PTR: RXD Data pointer
	// Position of PTR field.
	TWIS_RXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIS_RXD_PTR_PTR_Msk = 0xffffffff

	// RXD.MAXCNT: Maximum number of bytes in RXD buffer
	// Position of MAXCNT field.
	TWIS_RXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIS_RXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// RXD.AMOUNT: Number of bytes transferred in the last RXD transaction
	// Position of AMOUNT field.
	TWIS_RXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIS_RXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// RXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIS_RXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIS_RXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	TWIS_RXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIS_RXD_LIST_LIST_ArrayList = 0x1

	// TXD.PTR: TXD Data pointer
	// Position of PTR field.
	TWIS_TXD_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	TWIS_TXD_PTR_PTR_Msk = 0xffffffff

	// TXD.MAXCNT: Maximum number of bytes in TXD buffer
	// Position of MAXCNT field.
	TWIS_TXD_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	TWIS_TXD_MAXCNT_MAXCNT_Msk = 0x7fff

	// TXD.AMOUNT: Number of bytes transferred in the last TXD transaction
	// Position of AMOUNT field.
	TWIS_TXD_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	TWIS_TXD_AMOUNT_AMOUNT_Msk = 0x7fff

	// TXD.LIST: EasyDMA list type
	// Position of LIST field.
	TWIS_TXD_LIST_LIST_Pos = 0x0
	// Bit mask of LIST field.
	TWIS_TXD_LIST_LIST_Msk = 0x3
	// Disable EasyDMA list
	TWIS_TXD_LIST_LIST_Disabled = 0x0
	// Use array list
	TWIS_TXD_LIST_LIST_ArrayList = 0x1

	// ADDRESS: Description collection: TWI slave address n
	// Position of ADDRESS field.
	TWIS_ADDRESS_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	TWIS_ADDRESS_ADDRESS_Msk = 0x7f

	// CONFIG: Configuration register for the address match mechanism
	// Position of ADDRESS0 field.
	TWIS_CONFIG_ADDRESS0_Pos = 0x0
	// Bit mask of ADDRESS0 field.
	TWIS_CONFIG_ADDRESS0_Msk = 0x1
	// Bit ADDRESS0.
	TWIS_CONFIG_ADDRESS0 = 0x1
	// Disabled
	TWIS_CONFIG_ADDRESS0_Disabled = 0x0
	// Enabled
	TWIS_CONFIG_ADDRESS0_Enabled = 0x1
	// Position of ADDRESS1 field.
	TWIS_CONFIG_ADDRESS1_Pos = 0x1
	// Bit mask of ADDRESS1 field.
	TWIS_CONFIG_ADDRESS1_Msk = 0x2
	// Bit ADDRESS1.
	TWIS_CONFIG_ADDRESS1 = 0x2
	// Disabled
	TWIS_CONFIG_ADDRESS1_Disabled = 0x0
	// Enabled
	TWIS_CONFIG_ADDRESS1_Enabled = 0x1

	// ORC: Over-read character. Character sent out in case of an over-read of the transmit buffer.
	// Position of ORC field.
	TWIS_ORC_ORC_Pos = 0x0
	// Bit mask of ORC field.
	TWIS_ORC_ORC_Msk = 0xff
)

// Constants for GPIOTE: GPIO Tasks and Events
const (
	// TASKS_OUT: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY.
	// Position of TASKS_OUT field.
	GPIOTE_TASKS_OUT_TASKS_OUT_Pos = 0x0
	// Bit mask of TASKS_OUT field.
	GPIOTE_TASKS_OUT_TASKS_OUT_Msk = 0x1
	// Bit TASKS_OUT.
	GPIOTE_TASKS_OUT_TASKS_OUT = 0x1
	// Trigger task
	GPIOTE_TASKS_OUT_TASKS_OUT_Trigger = 0x1

	// TASKS_SET: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high.
	// Position of TASKS_SET field.
	GPIOTE_TASKS_SET_TASKS_SET_Pos = 0x0
	// Bit mask of TASKS_SET field.
	GPIOTE_TASKS_SET_TASKS_SET_Msk = 0x1
	// Bit TASKS_SET.
	GPIOTE_TASKS_SET_TASKS_SET = 0x1
	// Trigger task
	GPIOTE_TASKS_SET_TASKS_SET_Trigger = 0x1

	// TASKS_CLR: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low.
	// Position of TASKS_CLR field.
	GPIOTE_TASKS_CLR_TASKS_CLR_Pos = 0x0
	// Bit mask of TASKS_CLR field.
	GPIOTE_TASKS_CLR_TASKS_CLR_Msk = 0x1
	// Bit TASKS_CLR.
	GPIOTE_TASKS_CLR_TASKS_CLR = 0x1
	// Trigger task
	GPIOTE_TASKS_CLR_TASKS_CLR_Trigger = 0x1

	// EVENTS_IN: Description collection: Event generated from pin specified in CONFIG[n].PSEL
	// Position of EVENTS_IN field.
	GPIOTE_EVENTS_IN_EVENTS_IN_Pos = 0x0
	// Bit mask of EVENTS_IN field.
	GPIOTE_EVENTS_IN_EVENTS_IN_Msk = 0x1
	// Bit EVENTS_IN.
	GPIOTE_EVENTS_IN_EVENTS_IN = 0x1
	// Event not generated
	GPIOTE_EVENTS_IN_EVENTS_IN_NotGenerated = 0x0
	// Event generated
	GPIOTE_EVENTS_IN_EVENTS_IN_Generated = 0x1

	// EVENTS_PORT: Event generated from multiple input GPIO pins with SENSE mechanism enabled
	// Position of EVENTS_PORT field.
	GPIOTE_EVENTS_PORT_EVENTS_PORT_Pos = 0x0
	// Bit mask of EVENTS_PORT field.
	GPIOTE_EVENTS_PORT_EVENTS_PORT_Msk = 0x1
	// Bit EVENTS_PORT.
	GPIOTE_EVENTS_PORT_EVENTS_PORT = 0x1
	// Event not generated
	GPIOTE_EVENTS_PORT_EVENTS_PORT_NotGenerated = 0x0
	// Event generated
	GPIOTE_EVENTS_PORT_EVENTS_PORT_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of IN0 field.
	GPIOTE_INTENSET_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	GPIOTE_INTENSET_IN0_Msk = 0x1
	// Bit IN0.
	GPIOTE_INTENSET_IN0 = 0x1
	// Read: Disabled
	GPIOTE_INTENSET_IN0_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN0_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN0_Set = 0x1
	// Position of IN1 field.
	GPIOTE_INTENSET_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	GPIOTE_INTENSET_IN1_Msk = 0x2
	// Bit IN1.
	GPIOTE_INTENSET_IN1 = 0x2
	// Read: Disabled
	GPIOTE_INTENSET_IN1_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN1_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN1_Set = 0x1
	// Position of IN2 field.
	GPIOTE_INTENSET_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	GPIOTE_INTENSET_IN2_Msk = 0x4
	// Bit IN2.
	GPIOTE_INTENSET_IN2 = 0x4
	// Read: Disabled
	GPIOTE_INTENSET_IN2_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN2_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN2_Set = 0x1
	// Position of IN3 field.
	GPIOTE_INTENSET_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	GPIOTE_INTENSET_IN3_Msk = 0x8
	// Bit IN3.
	GPIOTE_INTENSET_IN3 = 0x8
	// Read: Disabled
	GPIOTE_INTENSET_IN3_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN3_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN3_Set = 0x1
	// Position of IN4 field.
	GPIOTE_INTENSET_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	GPIOTE_INTENSET_IN4_Msk = 0x10
	// Bit IN4.
	GPIOTE_INTENSET_IN4 = 0x10
	// Read: Disabled
	GPIOTE_INTENSET_IN4_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN4_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN4_Set = 0x1
	// Position of IN5 field.
	GPIOTE_INTENSET_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	GPIOTE_INTENSET_IN5_Msk = 0x20
	// Bit IN5.
	GPIOTE_INTENSET_IN5 = 0x20
	// Read: Disabled
	GPIOTE_INTENSET_IN5_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN5_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN5_Set = 0x1
	// Position of IN6 field.
	GPIOTE_INTENSET_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	GPIOTE_INTENSET_IN6_Msk = 0x40
	// Bit IN6.
	GPIOTE_INTENSET_IN6 = 0x40
	// Read: Disabled
	GPIOTE_INTENSET_IN6_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN6_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN6_Set = 0x1
	// Position of IN7 field.
	GPIOTE_INTENSET_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	GPIOTE_INTENSET_IN7_Msk = 0x80
	// Bit IN7.
	GPIOTE_INTENSET_IN7 = 0x80
	// Read: Disabled
	GPIOTE_INTENSET_IN7_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_IN7_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_IN7_Set = 0x1
	// Position of PORT field.
	GPIOTE_INTENSET_PORT_Pos = 0x1f
	// Bit mask of PORT field.
	GPIOTE_INTENSET_PORT_Msk = 0x80000000
	// Bit PORT.
	GPIOTE_INTENSET_PORT = 0x80000000
	// Read: Disabled
	GPIOTE_INTENSET_PORT_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENSET_PORT_Enabled = 0x1
	// Enable
	GPIOTE_INTENSET_PORT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of IN0 field.
	GPIOTE_INTENCLR_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	GPIOTE_INTENCLR_IN0_Msk = 0x1
	// Bit IN0.
	GPIOTE_INTENCLR_IN0 = 0x1
	// Read: Disabled
	GPIOTE_INTENCLR_IN0_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN0_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN0_Clear = 0x1
	// Position of IN1 field.
	GPIOTE_INTENCLR_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	GPIOTE_INTENCLR_IN1_Msk = 0x2
	// Bit IN1.
	GPIOTE_INTENCLR_IN1 = 0x2
	// Read: Disabled
	GPIOTE_INTENCLR_IN1_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN1_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN1_Clear = 0x1
	// Position of IN2 field.
	GPIOTE_INTENCLR_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	GPIOTE_INTENCLR_IN2_Msk = 0x4
	// Bit IN2.
	GPIOTE_INTENCLR_IN2 = 0x4
	// Read: Disabled
	GPIOTE_INTENCLR_IN2_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN2_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN2_Clear = 0x1
	// Position of IN3 field.
	GPIOTE_INTENCLR_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	GPIOTE_INTENCLR_IN3_Msk = 0x8
	// Bit IN3.
	GPIOTE_INTENCLR_IN3 = 0x8
	// Read: Disabled
	GPIOTE_INTENCLR_IN3_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN3_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN3_Clear = 0x1
	// Position of IN4 field.
	GPIOTE_INTENCLR_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	GPIOTE_INTENCLR_IN4_Msk = 0x10
	// Bit IN4.
	GPIOTE_INTENCLR_IN4 = 0x10
	// Read: Disabled
	GPIOTE_INTENCLR_IN4_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN4_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN4_Clear = 0x1
	// Position of IN5 field.
	GPIOTE_INTENCLR_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	GPIOTE_INTENCLR_IN5_Msk = 0x20
	// Bit IN5.
	GPIOTE_INTENCLR_IN5 = 0x20
	// Read: Disabled
	GPIOTE_INTENCLR_IN5_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN5_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN5_Clear = 0x1
	// Position of IN6 field.
	GPIOTE_INTENCLR_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	GPIOTE_INTENCLR_IN6_Msk = 0x40
	// Bit IN6.
	GPIOTE_INTENCLR_IN6 = 0x40
	// Read: Disabled
	GPIOTE_INTENCLR_IN6_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN6_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN6_Clear = 0x1
	// Position of IN7 field.
	GPIOTE_INTENCLR_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	GPIOTE_INTENCLR_IN7_Msk = 0x80
	// Bit IN7.
	GPIOTE_INTENCLR_IN7 = 0x80
	// Read: Disabled
	GPIOTE_INTENCLR_IN7_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_IN7_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_IN7_Clear = 0x1
	// Position of PORT field.
	GPIOTE_INTENCLR_PORT_Pos = 0x1f
	// Bit mask of PORT field.
	GPIOTE_INTENCLR_PORT_Msk = 0x80000000
	// Bit PORT.
	GPIOTE_INTENCLR_PORT = 0x80000000
	// Read: Disabled
	GPIOTE_INTENCLR_PORT_Disabled = 0x0
	// Read: Enabled
	GPIOTE_INTENCLR_PORT_Enabled = 0x1
	// Disable
	GPIOTE_INTENCLR_PORT_Clear = 0x1

	// CONFIG: Description collection: Configuration for OUT[n], SET[n], and CLR[n] tasks and IN[n] event
	// Position of MODE field.
	GPIOTE_CONFIG_MODE_Pos = 0x0
	// Bit mask of MODE field.
	GPIOTE_CONFIG_MODE_Msk = 0x3
	// Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module.
	GPIOTE_CONFIG_MODE_Disabled = 0x0
	// Event mode
	GPIOTE_CONFIG_MODE_Event = 0x1
	// Task mode
	GPIOTE_CONFIG_MODE_Task = 0x3
	// Position of PSEL field.
	GPIOTE_CONFIG_PSEL_Pos = 0x8
	// Bit mask of PSEL field.
	GPIOTE_CONFIG_PSEL_Msk = 0x1f00
	// Position of POLARITY field.
	GPIOTE_CONFIG_POLARITY_Pos = 0x10
	// Bit mask of POLARITY field.
	GPIOTE_CONFIG_POLARITY_Msk = 0x30000
	// Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.
	GPIOTE_CONFIG_POLARITY_None = 0x0
	// Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.
	GPIOTE_CONFIG_POLARITY_LoToHi = 0x1
	// Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.
	GPIOTE_CONFIG_POLARITY_HiToLo = 0x2
	// Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.
	GPIOTE_CONFIG_POLARITY_Toggle = 0x3
	// Position of OUTINIT field.
	GPIOTE_CONFIG_OUTINIT_Pos = 0x14
	// Bit mask of OUTINIT field.
	GPIOTE_CONFIG_OUTINIT_Msk = 0x100000
	// Bit OUTINIT.
	GPIOTE_CONFIG_OUTINIT = 0x100000
	// Task mode: Initial value of pin before task triggering is low
	GPIOTE_CONFIG_OUTINIT_Low = 0x0
	// Task mode: Initial value of pin before task triggering is high
	GPIOTE_CONFIG_OUTINIT_High = 0x1
)

// Constants for TIMER0: Timer/Counter 0
const (
	// TASKS_START: Start Timer
	// Position of TASKS_START field.
	TIMER_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	TIMER_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	TIMER_TASKS_START_TASKS_START = 0x1
	// Trigger task
	TIMER_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop Timer
	// Position of TASKS_STOP field.
	TIMER_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TIMER_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TIMER_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TIMER_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_COUNT: Increment Timer (Counter mode only)
	// Position of TASKS_COUNT field.
	TIMER_TASKS_COUNT_TASKS_COUNT_Pos = 0x0
	// Bit mask of TASKS_COUNT field.
	TIMER_TASKS_COUNT_TASKS_COUNT_Msk = 0x1
	// Bit TASKS_COUNT.
	TIMER_TASKS_COUNT_TASKS_COUNT = 0x1
	// Trigger task
	TIMER_TASKS_COUNT_TASKS_COUNT_Trigger = 0x1

	// TASKS_CLEAR: Clear time
	// Position of TASKS_CLEAR field.
	TIMER_TASKS_CLEAR_TASKS_CLEAR_Pos = 0x0
	// Bit mask of TASKS_CLEAR field.
	TIMER_TASKS_CLEAR_TASKS_CLEAR_Msk = 0x1
	// Bit TASKS_CLEAR.
	TIMER_TASKS_CLEAR_TASKS_CLEAR = 0x1
	// Trigger task
	TIMER_TASKS_CLEAR_TASKS_CLEAR_Trigger = 0x1

	// TASKS_SHUTDOWN: Deprecated register - Shut down timer
	// Position of TASKS_SHUTDOWN field.
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Pos = 0x0
	// Bit mask of TASKS_SHUTDOWN field.
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Msk = 0x1
	// Bit TASKS_SHUTDOWN.
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN = 0x1
	// Trigger task
	TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Trigger = 0x1

	// TASKS_CAPTURE: Description collection: Capture Timer value to CC[n] register
	// Position of TASKS_CAPTURE field.
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Pos = 0x0
	// Bit mask of TASKS_CAPTURE field.
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Msk = 0x1
	// Bit TASKS_CAPTURE.
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE = 0x1
	// Trigger task
	TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Trigger = 0x1

	// EVENTS_COMPARE: Description collection: Compare event on CC[n] match
	// Position of EVENTS_COMPARE field.
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Pos = 0x0
	// Bit mask of EVENTS_COMPARE field.
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Msk = 0x1
	// Bit EVENTS_COMPARE.
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE = 0x1
	// Event not generated
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_NotGenerated = 0x0
	// Event generated
	TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of COMPARE0_CLEAR field.
	TIMER_SHORTS_COMPARE0_CLEAR_Pos = 0x0
	// Bit mask of COMPARE0_CLEAR field.
	TIMER_SHORTS_COMPARE0_CLEAR_Msk = 0x1
	// Bit COMPARE0_CLEAR.
	TIMER_SHORTS_COMPARE0_CLEAR = 0x1
	// Disable shortcut
	TIMER_SHORTS_COMPARE0_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE0_CLEAR_Enabled = 0x1
	// Position of COMPARE1_CLEAR field.
	TIMER_SHORTS_COMPARE1_CLEAR_Pos = 0x1
	// Bit mask of COMPARE1_CLEAR field.
	TIMER_SHORTS_COMPARE1_CLEAR_Msk = 0x2
	// Bit COMPARE1_CLEAR.
	TIMER_SHORTS_COMPARE1_CLEAR = 0x2
	// Disable shortcut
	TIMER_SHORTS_COMPARE1_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE1_CLEAR_Enabled = 0x1
	// Position of COMPARE2_CLEAR field.
	TIMER_SHORTS_COMPARE2_CLEAR_Pos = 0x2
	// Bit mask of COMPARE2_CLEAR field.
	TIMER_SHORTS_COMPARE2_CLEAR_Msk = 0x4
	// Bit COMPARE2_CLEAR.
	TIMER_SHORTS_COMPARE2_CLEAR = 0x4
	// Disable shortcut
	TIMER_SHORTS_COMPARE2_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE2_CLEAR_Enabled = 0x1
	// Position of COMPARE3_CLEAR field.
	TIMER_SHORTS_COMPARE3_CLEAR_Pos = 0x3
	// Bit mask of COMPARE3_CLEAR field.
	TIMER_SHORTS_COMPARE3_CLEAR_Msk = 0x8
	// Bit COMPARE3_CLEAR.
	TIMER_SHORTS_COMPARE3_CLEAR = 0x8
	// Disable shortcut
	TIMER_SHORTS_COMPARE3_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE3_CLEAR_Enabled = 0x1
	// Position of COMPARE4_CLEAR field.
	TIMER_SHORTS_COMPARE4_CLEAR_Pos = 0x4
	// Bit mask of COMPARE4_CLEAR field.
	TIMER_SHORTS_COMPARE4_CLEAR_Msk = 0x10
	// Bit COMPARE4_CLEAR.
	TIMER_SHORTS_COMPARE4_CLEAR = 0x10
	// Disable shortcut
	TIMER_SHORTS_COMPARE4_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE4_CLEAR_Enabled = 0x1
	// Position of COMPARE5_CLEAR field.
	TIMER_SHORTS_COMPARE5_CLEAR_Pos = 0x5
	// Bit mask of COMPARE5_CLEAR field.
	TIMER_SHORTS_COMPARE5_CLEAR_Msk = 0x20
	// Bit COMPARE5_CLEAR.
	TIMER_SHORTS_COMPARE5_CLEAR = 0x20
	// Disable shortcut
	TIMER_SHORTS_COMPARE5_CLEAR_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE5_CLEAR_Enabled = 0x1
	// Position of COMPARE0_STOP field.
	TIMER_SHORTS_COMPARE0_STOP_Pos = 0x8
	// Bit mask of COMPARE0_STOP field.
	TIMER_SHORTS_COMPARE0_STOP_Msk = 0x100
	// Bit COMPARE0_STOP.
	TIMER_SHORTS_COMPARE0_STOP = 0x100
	// Disable shortcut
	TIMER_SHORTS_COMPARE0_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE0_STOP_Enabled = 0x1
	// Position of COMPARE1_STOP field.
	TIMER_SHORTS_COMPARE1_STOP_Pos = 0x9
	// Bit mask of COMPARE1_STOP field.
	TIMER_SHORTS_COMPARE1_STOP_Msk = 0x200
	// Bit COMPARE1_STOP.
	TIMER_SHORTS_COMPARE1_STOP = 0x200
	// Disable shortcut
	TIMER_SHORTS_COMPARE1_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE1_STOP_Enabled = 0x1
	// Position of COMPARE2_STOP field.
	TIMER_SHORTS_COMPARE2_STOP_Pos = 0xa
	// Bit mask of COMPARE2_STOP field.
	TIMER_SHORTS_COMPARE2_STOP_Msk = 0x400
	// Bit COMPARE2_STOP.
	TIMER_SHORTS_COMPARE2_STOP = 0x400
	// Disable shortcut
	TIMER_SHORTS_COMPARE2_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE2_STOP_Enabled = 0x1
	// Position of COMPARE3_STOP field.
	TIMER_SHORTS_COMPARE3_STOP_Pos = 0xb
	// Bit mask of COMPARE3_STOP field.
	TIMER_SHORTS_COMPARE3_STOP_Msk = 0x800
	// Bit COMPARE3_STOP.
	TIMER_SHORTS_COMPARE3_STOP = 0x800
	// Disable shortcut
	TIMER_SHORTS_COMPARE3_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE3_STOP_Enabled = 0x1
	// Position of COMPARE4_STOP field.
	TIMER_SHORTS_COMPARE4_STOP_Pos = 0xc
	// Bit mask of COMPARE4_STOP field.
	TIMER_SHORTS_COMPARE4_STOP_Msk = 0x1000
	// Bit COMPARE4_STOP.
	TIMER_SHORTS_COMPARE4_STOP = 0x1000
	// Disable shortcut
	TIMER_SHORTS_COMPARE4_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE4_STOP_Enabled = 0x1
	// Position of COMPARE5_STOP field.
	TIMER_SHORTS_COMPARE5_STOP_Pos = 0xd
	// Bit mask of COMPARE5_STOP field.
	TIMER_SHORTS_COMPARE5_STOP_Msk = 0x2000
	// Bit COMPARE5_STOP.
	TIMER_SHORTS_COMPARE5_STOP = 0x2000
	// Disable shortcut
	TIMER_SHORTS_COMPARE5_STOP_Disabled = 0x0
	// Enable shortcut
	TIMER_SHORTS_COMPARE5_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of COMPARE0 field.
	TIMER_INTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	TIMER_INTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE0_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	TIMER_INTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	TIMER_INTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE1_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	TIMER_INTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	TIMER_INTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE2_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	TIMER_INTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	TIMER_INTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE3_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE3_Set = 0x1
	// Position of COMPARE4 field.
	TIMER_INTENSET_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTENSET_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTENSET_COMPARE4 = 0x100000
	// Read: Disabled
	TIMER_INTENSET_COMPARE4_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE4_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE4_Set = 0x1
	// Position of COMPARE5 field.
	TIMER_INTENSET_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTENSET_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTENSET_COMPARE5 = 0x200000
	// Read: Disabled
	TIMER_INTENSET_COMPARE5_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENSET_COMPARE5_Enabled = 0x1
	// Enable
	TIMER_INTENSET_COMPARE5_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of COMPARE0 field.
	TIMER_INTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	TIMER_INTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	TIMER_INTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	TIMER_INTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	TIMER_INTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	TIMER_INTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	TIMER_INTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	TIMER_INTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	TIMER_INTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	TIMER_INTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	TIMER_INTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	TIMER_INTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE3_Clear = 0x1
	// Position of COMPARE4 field.
	TIMER_INTENCLR_COMPARE4_Pos = 0x14
	// Bit mask of COMPARE4 field.
	TIMER_INTENCLR_COMPARE4_Msk = 0x100000
	// Bit COMPARE4.
	TIMER_INTENCLR_COMPARE4 = 0x100000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE4_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE4_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE4_Clear = 0x1
	// Position of COMPARE5 field.
	TIMER_INTENCLR_COMPARE5_Pos = 0x15
	// Bit mask of COMPARE5 field.
	TIMER_INTENCLR_COMPARE5_Msk = 0x200000
	// Bit COMPARE5.
	TIMER_INTENCLR_COMPARE5 = 0x200000
	// Read: Disabled
	TIMER_INTENCLR_COMPARE5_Disabled = 0x0
	// Read: Enabled
	TIMER_INTENCLR_COMPARE5_Enabled = 0x1
	// Disable
	TIMER_INTENCLR_COMPARE5_Clear = 0x1

	// MODE: Timer mode selection
	// Position of MODE field.
	TIMER_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	TIMER_MODE_MODE_Msk = 0x3
	// Select Timer mode
	TIMER_MODE_MODE_Timer = 0x0
	// Deprecated enumerator - Select Counter mode
	TIMER_MODE_MODE_Counter = 0x1
	// Select Low Power Counter mode
	TIMER_MODE_MODE_LowPowerCounter = 0x2

	// BITMODE: Configure the number of bits used by the TIMER
	// Position of BITMODE field.
	TIMER_BITMODE_BITMODE_Pos = 0x0
	// Bit mask of BITMODE field.
	TIMER_BITMODE_BITMODE_Msk = 0x3
	// 16 bit timer bit width
	TIMER_BITMODE_BITMODE_16Bit = 0x0
	// 8 bit timer bit width
	TIMER_BITMODE_BITMODE_08Bit = 0x1
	// 24 bit timer bit width
	TIMER_BITMODE_BITMODE_24Bit = 0x2
	// 32 bit timer bit width
	TIMER_BITMODE_BITMODE_32Bit = 0x3

	// PRESCALER: Timer prescaler register
	// Position of PRESCALER field.
	TIMER_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	TIMER_PRESCALER_PRESCALER_Msk = 0xf

	// CC: Description collection: Capture/Compare register n
	// Position of CC field.
	TIMER_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TIMER_CC_CC_Msk = 0xffffffff
)

// Constants for RTC0: Real time counter 0
const (
	// TASKS_START: Start RTC COUNTER
	// Position of TASKS_START field.
	RTC_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	RTC_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	RTC_TASKS_START_TASKS_START = 0x1
	// Trigger task
	RTC_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop RTC COUNTER
	// Position of TASKS_STOP field.
	RTC_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	RTC_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	RTC_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	RTC_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_CLEAR: Clear RTC COUNTER
	// Position of TASKS_CLEAR field.
	RTC_TASKS_CLEAR_TASKS_CLEAR_Pos = 0x0
	// Bit mask of TASKS_CLEAR field.
	RTC_TASKS_CLEAR_TASKS_CLEAR_Msk = 0x1
	// Bit TASKS_CLEAR.
	RTC_TASKS_CLEAR_TASKS_CLEAR = 0x1
	// Trigger task
	RTC_TASKS_CLEAR_TASKS_CLEAR_Trigger = 0x1

	// TASKS_TRIGOVRFLW: Set COUNTER to 0xFFFFF0
	// Position of TASKS_TRIGOVRFLW field.
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Pos = 0x0
	// Bit mask of TASKS_TRIGOVRFLW field.
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Msk = 0x1
	// Bit TASKS_TRIGOVRFLW.
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW = 0x1
	// Trigger task
	RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Trigger = 0x1

	// EVENTS_TICK: Event on COUNTER increment
	// Position of EVENTS_TICK field.
	RTC_EVENTS_TICK_EVENTS_TICK_Pos = 0x0
	// Bit mask of EVENTS_TICK field.
	RTC_EVENTS_TICK_EVENTS_TICK_Msk = 0x1
	// Bit EVENTS_TICK.
	RTC_EVENTS_TICK_EVENTS_TICK = 0x1
	// Event not generated
	RTC_EVENTS_TICK_EVENTS_TICK_NotGenerated = 0x0
	// Event generated
	RTC_EVENTS_TICK_EVENTS_TICK_Generated = 0x1

	// EVENTS_OVRFLW: Event on COUNTER overflow
	// Position of EVENTS_OVRFLW field.
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Pos = 0x0
	// Bit mask of EVENTS_OVRFLW field.
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Msk = 0x1
	// Bit EVENTS_OVRFLW.
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW = 0x1
	// Event not generated
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_NotGenerated = 0x0
	// Event generated
	RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Generated = 0x1

	// EVENTS_COMPARE: Description collection: Compare event on CC[n] match
	// Position of EVENTS_COMPARE field.
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_Pos = 0x0
	// Bit mask of EVENTS_COMPARE field.
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_Msk = 0x1
	// Bit EVENTS_COMPARE.
	RTC_EVENTS_COMPARE_EVENTS_COMPARE = 0x1
	// Event not generated
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_NotGenerated = 0x0
	// Event generated
	RTC_EVENTS_COMPARE_EVENTS_COMPARE_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of TICK field.
	RTC_INTENSET_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_INTENSET_TICK_Msk = 0x1
	// Bit TICK.
	RTC_INTENSET_TICK = 0x1
	// Read: Disabled
	RTC_INTENSET_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_TICK_Enabled = 0x1
	// Enable
	RTC_INTENSET_TICK_Set = 0x1
	// Position of OVRFLW field.
	RTC_INTENSET_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_INTENSET_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_INTENSET_OVRFLW = 0x2
	// Read: Disabled
	RTC_INTENSET_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_OVRFLW_Enabled = 0x1
	// Enable
	RTC_INTENSET_OVRFLW_Set = 0x1
	// Position of COMPARE0 field.
	RTC_INTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_INTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_INTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_INTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE0_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	RTC_INTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_INTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_INTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_INTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE1_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	RTC_INTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_INTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_INTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_INTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE2_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	RTC_INTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_INTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_INTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_INTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_INTENSET_COMPARE3_Enabled = 0x1
	// Enable
	RTC_INTENSET_COMPARE3_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TICK field.
	RTC_INTENCLR_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_INTENCLR_TICK_Msk = 0x1
	// Bit TICK.
	RTC_INTENCLR_TICK = 0x1
	// Read: Disabled
	RTC_INTENCLR_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_TICK_Enabled = 0x1
	// Disable
	RTC_INTENCLR_TICK_Clear = 0x1
	// Position of OVRFLW field.
	RTC_INTENCLR_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_INTENCLR_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_INTENCLR_OVRFLW = 0x2
	// Read: Disabled
	RTC_INTENCLR_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_OVRFLW_Enabled = 0x1
	// Disable
	RTC_INTENCLR_OVRFLW_Clear = 0x1
	// Position of COMPARE0 field.
	RTC_INTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_INTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_INTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_INTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	RTC_INTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_INTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_INTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_INTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	RTC_INTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_INTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_INTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_INTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	RTC_INTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_INTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_INTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_INTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_INTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	RTC_INTENCLR_COMPARE3_Clear = 0x1

	// EVTEN: Enable or disable event routing
	// Position of TICK field.
	RTC_EVTEN_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTEN_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTEN_TICK = 0x1
	// Disable
	RTC_EVTEN_TICK_Disabled = 0x0
	// Disable
	RTC_EVTEN_TICK_Enabled = 0x1
	// Position of OVRFLW field.
	RTC_EVTEN_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTEN_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTEN_OVRFLW = 0x2
	// Disable
	RTC_EVTEN_OVRFLW_Disabled = 0x0
	// Disable
	RTC_EVTEN_OVRFLW_Enabled = 0x1
	// Position of COMPARE0 field.
	RTC_EVTEN_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTEN_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTEN_COMPARE0 = 0x10000
	// Disable
	RTC_EVTEN_COMPARE0_Disabled = 0x0
	// Disable
	RTC_EVTEN_COMPARE0_Enabled = 0x1
	// Position of COMPARE1 field.
	RTC_EVTEN_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTEN_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTEN_COMPARE1 = 0x20000
	// Disable
	RTC_EVTEN_COMPARE1_Disabled = 0x0
	// Disable
	RTC_EVTEN_COMPARE1_Enabled = 0x1
	// Position of COMPARE2 field.
	RTC_EVTEN_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTEN_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTEN_COMPARE2 = 0x40000
	// Disable
	RTC_EVTEN_COMPARE2_Disabled = 0x0
	// Disable
	RTC_EVTEN_COMPARE2_Enabled = 0x1
	// Position of COMPARE3 field.
	RTC_EVTEN_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTEN_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTEN_COMPARE3 = 0x80000
	// Disable
	RTC_EVTEN_COMPARE3_Disabled = 0x0
	// Disable
	RTC_EVTEN_COMPARE3_Enabled = 0x1

	// EVTENSET: Enable event routing
	// Position of TICK field.
	RTC_EVTENSET_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTENSET_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTENSET_TICK = 0x1
	// Read: Disabled
	RTC_EVTENSET_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_TICK_Enabled = 0x1
	// Enable
	RTC_EVTENSET_TICK_Set = 0x1
	// Position of OVRFLW field.
	RTC_EVTENSET_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTENSET_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTENSET_OVRFLW = 0x2
	// Read: Disabled
	RTC_EVTENSET_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_OVRFLW_Enabled = 0x1
	// Enable
	RTC_EVTENSET_OVRFLW_Set = 0x1
	// Position of COMPARE0 field.
	RTC_EVTENSET_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTENSET_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTENSET_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_EVTENSET_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE0_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE0_Set = 0x1
	// Position of COMPARE1 field.
	RTC_EVTENSET_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTENSET_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTENSET_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_EVTENSET_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE1_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE1_Set = 0x1
	// Position of COMPARE2 field.
	RTC_EVTENSET_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTENSET_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTENSET_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_EVTENSET_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE2_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE2_Set = 0x1
	// Position of COMPARE3 field.
	RTC_EVTENSET_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTENSET_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTENSET_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_EVTENSET_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENSET_COMPARE3_Enabled = 0x1
	// Enable
	RTC_EVTENSET_COMPARE3_Set = 0x1

	// EVTENCLR: Disable event routing
	// Position of TICK field.
	RTC_EVTENCLR_TICK_Pos = 0x0
	// Bit mask of TICK field.
	RTC_EVTENCLR_TICK_Msk = 0x1
	// Bit TICK.
	RTC_EVTENCLR_TICK = 0x1
	// Read: Disabled
	RTC_EVTENCLR_TICK_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_TICK_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_TICK_Clear = 0x1
	// Position of OVRFLW field.
	RTC_EVTENCLR_OVRFLW_Pos = 0x1
	// Bit mask of OVRFLW field.
	RTC_EVTENCLR_OVRFLW_Msk = 0x2
	// Bit OVRFLW.
	RTC_EVTENCLR_OVRFLW = 0x2
	// Read: Disabled
	RTC_EVTENCLR_OVRFLW_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_OVRFLW_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_OVRFLW_Clear = 0x1
	// Position of COMPARE0 field.
	RTC_EVTENCLR_COMPARE0_Pos = 0x10
	// Bit mask of COMPARE0 field.
	RTC_EVTENCLR_COMPARE0_Msk = 0x10000
	// Bit COMPARE0.
	RTC_EVTENCLR_COMPARE0 = 0x10000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE0_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE0_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE0_Clear = 0x1
	// Position of COMPARE1 field.
	RTC_EVTENCLR_COMPARE1_Pos = 0x11
	// Bit mask of COMPARE1 field.
	RTC_EVTENCLR_COMPARE1_Msk = 0x20000
	// Bit COMPARE1.
	RTC_EVTENCLR_COMPARE1 = 0x20000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE1_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE1_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE1_Clear = 0x1
	// Position of COMPARE2 field.
	RTC_EVTENCLR_COMPARE2_Pos = 0x12
	// Bit mask of COMPARE2 field.
	RTC_EVTENCLR_COMPARE2_Msk = 0x40000
	// Bit COMPARE2.
	RTC_EVTENCLR_COMPARE2 = 0x40000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE2_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE2_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE2_Clear = 0x1
	// Position of COMPARE3 field.
	RTC_EVTENCLR_COMPARE3_Pos = 0x13
	// Bit mask of COMPARE3 field.
	RTC_EVTENCLR_COMPARE3_Msk = 0x80000
	// Bit COMPARE3.
	RTC_EVTENCLR_COMPARE3 = 0x80000
	// Read: Disabled
	RTC_EVTENCLR_COMPARE3_Disabled = 0x0
	// Read: Enabled
	RTC_EVTENCLR_COMPARE3_Enabled = 0x1
	// Disable
	RTC_EVTENCLR_COMPARE3_Clear = 0x1

	// COUNTER: Current COUNTER value
	// Position of COUNTER field.
	RTC_COUNTER_COUNTER_Pos = 0x0
	// Bit mask of COUNTER field.
	RTC_COUNTER_COUNTER_Msk = 0xffffff

	// PRESCALER: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped
	// Position of PRESCALER field.
	RTC_PRESCALER_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	RTC_PRESCALER_PRESCALER_Msk = 0xfff

	// CC: Description collection: Compare register n
	// Position of COMPARE field.
	RTC_CC_COMPARE_Pos = 0x0
	// Bit mask of COMPARE field.
	RTC_CC_COMPARE_Msk = 0xffffff
)

// Constants for TEMP: Temperature Sensor
const (
	// TASKS_START: Start temperature measurement
	// Position of TASKS_START field.
	TEMP_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	TEMP_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	TEMP_TASKS_START_TASKS_START = 0x1
	// Trigger task
	TEMP_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop temperature measurement
	// Position of TASKS_STOP field.
	TEMP_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	TEMP_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	TEMP_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	TEMP_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// EVENTS_DATARDY: Temperature measurement complete, data ready
	// Position of EVENTS_DATARDY field.
	TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Pos = 0x0
	// Bit mask of EVENTS_DATARDY field.
	TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Msk = 0x1
	// Bit EVENTS_DATARDY.
	TEMP_EVENTS_DATARDY_EVENTS_DATARDY = 0x1
	// Event not generated
	TEMP_EVENTS_DATARDY_EVENTS_DATARDY_NotGenerated = 0x0
	// Event generated
	TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of DATARDY field.
	TEMP_INTENSET_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TEMP_INTENSET_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TEMP_INTENSET_DATARDY = 0x1
	// Read: Disabled
	TEMP_INTENSET_DATARDY_Disabled = 0x0
	// Read: Enabled
	TEMP_INTENSET_DATARDY_Enabled = 0x1
	// Enable
	TEMP_INTENSET_DATARDY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of DATARDY field.
	TEMP_INTENCLR_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TEMP_INTENCLR_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TEMP_INTENCLR_DATARDY = 0x1
	// Read: Disabled
	TEMP_INTENCLR_DATARDY_Disabled = 0x0
	// Read: Enabled
	TEMP_INTENCLR_DATARDY_Enabled = 0x1
	// Disable
	TEMP_INTENCLR_DATARDY_Clear = 0x1

	// TEMP: Temperature in degC (0.25deg steps)
	// Position of TEMP field.
	TEMP_TEMP_TEMP_Pos = 0x0
	// Bit mask of TEMP field.
	TEMP_TEMP_TEMP_Msk = 0xffffffff

	// A0: Slope of 1st piece wise linear function
	// Position of A0 field.
	TEMP_A0_A0_Pos = 0x0
	// Bit mask of A0 field.
	TEMP_A0_A0_Msk = 0xfff

	// A1: Slope of 2nd piece wise linear function
	// Position of A1 field.
	TEMP_A1_A1_Pos = 0x0
	// Bit mask of A1 field.
	TEMP_A1_A1_Msk = 0xfff

	// A2: Slope of 3rd piece wise linear function
	// Position of A2 field.
	TEMP_A2_A2_Pos = 0x0
	// Bit mask of A2 field.
	TEMP_A2_A2_Msk = 0xfff

	// A3: Slope of 4th piece wise linear function
	// Position of A3 field.
	TEMP_A3_A3_Pos = 0x0
	// Bit mask of A3 field.
	TEMP_A3_A3_Msk = 0xfff

	// A4: Slope of 5th piece wise linear function
	// Position of A4 field.
	TEMP_A4_A4_Pos = 0x0
	// Bit mask of A4 field.
	TEMP_A4_A4_Msk = 0xfff

	// A5: Slope of 6th piece wise linear function
	// Position of A5 field.
	TEMP_A5_A5_Pos = 0x0
	// Bit mask of A5 field.
	TEMP_A5_A5_Msk = 0xfff

	// B0: y-intercept of 1st piece wise linear function
	// Position of B0 field.
	TEMP_B0_B0_Pos = 0x0
	// Bit mask of B0 field.
	TEMP_B0_B0_Msk = 0x3fff

	// B1: y-intercept of 2nd piece wise linear function
	// Position of B1 field.
	TEMP_B1_B1_Pos = 0x0
	// Bit mask of B1 field.
	TEMP_B1_B1_Msk = 0x3fff

	// B2: y-intercept of 3rd piece wise linear function
	// Position of B2 field.
	TEMP_B2_B2_Pos = 0x0
	// Bit mask of B2 field.
	TEMP_B2_B2_Msk = 0x3fff

	// B3: y-intercept of 4th piece wise linear function
	// Position of B3 field.
	TEMP_B3_B3_Pos = 0x0
	// Bit mask of B3 field.
	TEMP_B3_B3_Msk = 0x3fff

	// B4: y-intercept of 5th piece wise linear function
	// Position of B4 field.
	TEMP_B4_B4_Pos = 0x0
	// Bit mask of B4 field.
	TEMP_B4_B4_Msk = 0x3fff

	// B5: y-intercept of 6th piece wise linear function
	// Position of B5 field.
	TEMP_B5_B5_Pos = 0x0
	// Bit mask of B5 field.
	TEMP_B5_B5_Msk = 0x3fff

	// T0: End point of 1st piece wise linear function
	// Position of T0 field.
	TEMP_T0_T0_Pos = 0x0
	// Bit mask of T0 field.
	TEMP_T0_T0_Msk = 0xff

	// T1: End point of 2nd piece wise linear function
	// Position of T1 field.
	TEMP_T1_T1_Pos = 0x0
	// Bit mask of T1 field.
	TEMP_T1_T1_Msk = 0xff

	// T2: End point of 3rd piece wise linear function
	// Position of T2 field.
	TEMP_T2_T2_Pos = 0x0
	// Bit mask of T2 field.
	TEMP_T2_T2_Msk = 0xff

	// T3: End point of 4th piece wise linear function
	// Position of T3 field.
	TEMP_T3_T3_Pos = 0x0
	// Bit mask of T3 field.
	TEMP_T3_T3_Msk = 0xff

	// T4: End point of 5th piece wise linear function
	// Position of T4 field.
	TEMP_T4_T4_Pos = 0x0
	// Bit mask of T4 field.
	TEMP_T4_T4_Msk = 0xff
)

// Constants for RNG: Random Number Generator
const (
	// TASKS_START: Task starting the random number generator
	// Position of TASKS_START field.
	RNG_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	RNG_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	RNG_TASKS_START_TASKS_START = 0x1
	// Trigger task
	RNG_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Task stopping the random number generator
	// Position of TASKS_STOP field.
	RNG_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	RNG_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	RNG_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	RNG_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// EVENTS_VALRDY: Event being generated for every new random number written to the VALUE register
	// Position of EVENTS_VALRDY field.
	RNG_EVENTS_VALRDY_EVENTS_VALRDY_Pos = 0x0
	// Bit mask of EVENTS_VALRDY field.
	RNG_EVENTS_VALRDY_EVENTS_VALRDY_Msk = 0x1
	// Bit EVENTS_VALRDY.
	RNG_EVENTS_VALRDY_EVENTS_VALRDY = 0x1
	// Event not generated
	RNG_EVENTS_VALRDY_EVENTS_VALRDY_NotGenerated = 0x0
	// Event generated
	RNG_EVENTS_VALRDY_EVENTS_VALRDY_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of VALRDY_STOP field.
	RNG_SHORTS_VALRDY_STOP_Pos = 0x0
	// Bit mask of VALRDY_STOP field.
	RNG_SHORTS_VALRDY_STOP_Msk = 0x1
	// Bit VALRDY_STOP.
	RNG_SHORTS_VALRDY_STOP = 0x1
	// Disable shortcut
	RNG_SHORTS_VALRDY_STOP_Disabled = 0x0
	// Enable shortcut
	RNG_SHORTS_VALRDY_STOP_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of VALRDY field.
	RNG_INTENSET_VALRDY_Pos = 0x0
	// Bit mask of VALRDY field.
	RNG_INTENSET_VALRDY_Msk = 0x1
	// Bit VALRDY.
	RNG_INTENSET_VALRDY = 0x1
	// Read: Disabled
	RNG_INTENSET_VALRDY_Disabled = 0x0
	// Read: Enabled
	RNG_INTENSET_VALRDY_Enabled = 0x1
	// Enable
	RNG_INTENSET_VALRDY_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of VALRDY field.
	RNG_INTENCLR_VALRDY_Pos = 0x0
	// Bit mask of VALRDY field.
	RNG_INTENCLR_VALRDY_Msk = 0x1
	// Bit VALRDY.
	RNG_INTENCLR_VALRDY = 0x1
	// Read: Disabled
	RNG_INTENCLR_VALRDY_Disabled = 0x0
	// Read: Enabled
	RNG_INTENCLR_VALRDY_Enabled = 0x1
	// Disable
	RNG_INTENCLR_VALRDY_Clear = 0x1

	// CONFIG: Configuration register
	// Position of DERCEN field.
	RNG_CONFIG_DERCEN_Pos = 0x0
	// Bit mask of DERCEN field.
	RNG_CONFIG_DERCEN_Msk = 0x1
	// Bit DERCEN.
	RNG_CONFIG_DERCEN = 0x1
	// Disabled
	RNG_CONFIG_DERCEN_Disabled = 0x0
	// Enabled
	RNG_CONFIG_DERCEN_Enabled = 0x1

	// VALUE: Output random number
	// Position of VALUE field.
	RNG_VALUE_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	RNG_VALUE_VALUE_Msk = 0xff
)

// Constants for ECB: AES ECB Mode Encryption
const (
	// TASKS_STARTECB: Start ECB block encrypt
	// Position of TASKS_STARTECB field.
	ECB_TASKS_STARTECB_TASKS_STARTECB_Pos = 0x0
	// Bit mask of TASKS_STARTECB field.
	ECB_TASKS_STARTECB_TASKS_STARTECB_Msk = 0x1
	// Bit TASKS_STARTECB.
	ECB_TASKS_STARTECB_TASKS_STARTECB = 0x1
	// Trigger task
	ECB_TASKS_STARTECB_TASKS_STARTECB_Trigger = 0x1

	// TASKS_STOPECB: Abort a possible executing ECB operation
	// Position of TASKS_STOPECB field.
	ECB_TASKS_STOPECB_TASKS_STOPECB_Pos = 0x0
	// Bit mask of TASKS_STOPECB field.
	ECB_TASKS_STOPECB_TASKS_STOPECB_Msk = 0x1
	// Bit TASKS_STOPECB.
	ECB_TASKS_STOPECB_TASKS_STOPECB = 0x1
	// Trigger task
	ECB_TASKS_STOPECB_TASKS_STOPECB_Trigger = 0x1

	// EVENTS_ENDECB: ECB block encrypt complete
	// Position of EVENTS_ENDECB field.
	ECB_EVENTS_ENDECB_EVENTS_ENDECB_Pos = 0x0
	// Bit mask of EVENTS_ENDECB field.
	ECB_EVENTS_ENDECB_EVENTS_ENDECB_Msk = 0x1
	// Bit EVENTS_ENDECB.
	ECB_EVENTS_ENDECB_EVENTS_ENDECB = 0x1
	// Event not generated
	ECB_EVENTS_ENDECB_EVENTS_ENDECB_NotGenerated = 0x0
	// Event generated
	ECB_EVENTS_ENDECB_EVENTS_ENDECB_Generated = 0x1

	// EVENTS_ERRORECB: ECB block encrypt aborted because of a STOPECB task or due to an error
	// Position of EVENTS_ERRORECB field.
	ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Pos = 0x0
	// Bit mask of EVENTS_ERRORECB field.
	ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Msk = 0x1
	// Bit EVENTS_ERRORECB.
	ECB_EVENTS_ERRORECB_EVENTS_ERRORECB = 0x1
	// Event not generated
	ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_NotGenerated = 0x0
	// Event generated
	ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of ENDECB field.
	ECB_INTENSET_ENDECB_Pos = 0x0
	// Bit mask of ENDECB field.
	ECB_INTENSET_ENDECB_Msk = 0x1
	// Bit ENDECB.
	ECB_INTENSET_ENDECB = 0x1
	// Read: Disabled
	ECB_INTENSET_ENDECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENSET_ENDECB_Enabled = 0x1
	// Enable
	ECB_INTENSET_ENDECB_Set = 0x1
	// Position of ERRORECB field.
	ECB_INTENSET_ERRORECB_Pos = 0x1
	// Bit mask of ERRORECB field.
	ECB_INTENSET_ERRORECB_Msk = 0x2
	// Bit ERRORECB.
	ECB_INTENSET_ERRORECB = 0x2
	// Read: Disabled
	ECB_INTENSET_ERRORECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENSET_ERRORECB_Enabled = 0x1
	// Enable
	ECB_INTENSET_ERRORECB_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of ENDECB field.
	ECB_INTENCLR_ENDECB_Pos = 0x0
	// Bit mask of ENDECB field.
	ECB_INTENCLR_ENDECB_Msk = 0x1
	// Bit ENDECB.
	ECB_INTENCLR_ENDECB = 0x1
	// Read: Disabled
	ECB_INTENCLR_ENDECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENCLR_ENDECB_Enabled = 0x1
	// Disable
	ECB_INTENCLR_ENDECB_Clear = 0x1
	// Position of ERRORECB field.
	ECB_INTENCLR_ERRORECB_Pos = 0x1
	// Bit mask of ERRORECB field.
	ECB_INTENCLR_ERRORECB_Msk = 0x2
	// Bit ERRORECB.
	ECB_INTENCLR_ERRORECB = 0x2
	// Read: Disabled
	ECB_INTENCLR_ERRORECB_Disabled = 0x0
	// Read: Enabled
	ECB_INTENCLR_ERRORECB_Enabled = 0x1
	// Disable
	ECB_INTENCLR_ERRORECB_Clear = 0x1

	// ECBDATAPTR: ECB block encrypt memory pointers
	// Position of ECBDATAPTR field.
	ECB_ECBDATAPTR_ECBDATAPTR_Pos = 0x0
	// Bit mask of ECBDATAPTR field.
	ECB_ECBDATAPTR_ECBDATAPTR_Msk = 0xffffffff
)

// Constants for AAR: Accelerated Address Resolver
const (
	// TASKS_START: Start resolving addresses based on IRKs specified in the IRK data structure
	// Position of TASKS_START field.
	AAR_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	AAR_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	AAR_TASKS_START_TASKS_START = 0x1
	// Trigger task
	AAR_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop resolving addresses
	// Position of TASKS_STOP field.
	AAR_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	AAR_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	AAR_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	AAR_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// EVENTS_END: Address resolution procedure complete
	// Position of EVENTS_END field.
	AAR_EVENTS_END_EVENTS_END_Pos = 0x0
	// Bit mask of EVENTS_END field.
	AAR_EVENTS_END_EVENTS_END_Msk = 0x1
	// Bit EVENTS_END.
	AAR_EVENTS_END_EVENTS_END = 0x1
	// Event not generated
	AAR_EVENTS_END_EVENTS_END_NotGenerated = 0x0
	// Event generated
	AAR_EVENTS_END_EVENTS_END_Generated = 0x1

	// EVENTS_RESOLVED: Address resolved
	// Position of EVENTS_RESOLVED field.
	AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Pos = 0x0
	// Bit mask of EVENTS_RESOLVED field.
	AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Msk = 0x1
	// Bit EVENTS_RESOLVED.
	AAR_EVENTS_RESOLVED_EVENTS_RESOLVED = 0x1
	// Event not generated
	AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_NotGenerated = 0x0
	// Event generated
	AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Generated = 0x1

	// EVENTS_NOTRESOLVED: Address not resolved
	// Position of EVENTS_NOTRESOLVED field.
	AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Pos = 0x0
	// Bit mask of EVENTS_NOTRESOLVED field.
	AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Msk = 0x1
	// Bit EVENTS_NOTRESOLVED.
	AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED = 0x1
	// Event not generated
	AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_NotGenerated = 0x0
	// Event generated
	AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of END field.
	AAR_INTENSET_END_Pos = 0x0
	// Bit mask of END field.
	AAR_INTENSET_END_Msk = 0x1
	// Bit END.
	AAR_INTENSET_END = 0x1
	// Read: Disabled
	AAR_INTENSET_END_Disabled = 0x0
	// Read: Enabled
	AAR_INTENSET_END_Enabled = 0x1
	// Enable
	AAR_INTENSET_END_Set = 0x1
	// Position of RESOLVED field.
	AAR_INTENSET_RESOLVED_Pos = 0x1
	// Bit mask of RESOLVED field.
	AAR_INTENSET_RESOLVED_Msk = 0x2
	// Bit RESOLVED.
	AAR_INTENSET_RESOLVED = 0x2
	// Read: Disabled
	AAR_INTENSET_RESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENSET_RESOLVED_Enabled = 0x1
	// Enable
	AAR_INTENSET_RESOLVED_Set = 0x1
	// Position of NOTRESOLVED field.
	AAR_INTENSET_NOTRESOLVED_Pos = 0x2
	// Bit mask of NOTRESOLVED field.
	AAR_INTENSET_NOTRESOLVED_Msk = 0x4
	// Bit NOTRESOLVED.
	AAR_INTENSET_NOTRESOLVED = 0x4
	// Read: Disabled
	AAR_INTENSET_NOTRESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENSET_NOTRESOLVED_Enabled = 0x1
	// Enable
	AAR_INTENSET_NOTRESOLVED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of END field.
	AAR_INTENCLR_END_Pos = 0x0
	// Bit mask of END field.
	AAR_INTENCLR_END_Msk = 0x1
	// Bit END.
	AAR_INTENCLR_END = 0x1
	// Read: Disabled
	AAR_INTENCLR_END_Disabled = 0x0
	// Read: Enabled
	AAR_INTENCLR_END_Enabled = 0x1
	// Disable
	AAR_INTENCLR_END_Clear = 0x1
	// Position of RESOLVED field.
	AAR_INTENCLR_RESOLVED_Pos = 0x1
	// Bit mask of RESOLVED field.
	AAR_INTENCLR_RESOLVED_Msk = 0x2
	// Bit RESOLVED.
	AAR_INTENCLR_RESOLVED = 0x2
	// Read: Disabled
	AAR_INTENCLR_RESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENCLR_RESOLVED_Enabled = 0x1
	// Disable
	AAR_INTENCLR_RESOLVED_Clear = 0x1
	// Position of NOTRESOLVED field.
	AAR_INTENCLR_NOTRESOLVED_Pos = 0x2
	// Bit mask of NOTRESOLVED field.
	AAR_INTENCLR_NOTRESOLVED_Msk = 0x4
	// Bit NOTRESOLVED.
	AAR_INTENCLR_NOTRESOLVED = 0x4
	// Read: Disabled
	AAR_INTENCLR_NOTRESOLVED_Disabled = 0x0
	// Read: Enabled
	AAR_INTENCLR_NOTRESOLVED_Enabled = 0x1
	// Disable
	AAR_INTENCLR_NOTRESOLVED_Clear = 0x1

	// STATUS: Resolution status
	// Position of STATUS field.
	AAR_STATUS_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	AAR_STATUS_STATUS_Msk = 0xf

	// ENABLE: Enable AAR
	// Position of ENABLE field.
	AAR_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	AAR_ENABLE_ENABLE_Msk = 0x3
	// Disable
	AAR_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	AAR_ENABLE_ENABLE_Enabled = 0x3

	// NIRK: Number of IRKs
	// Position of NIRK field.
	AAR_NIRK_NIRK_Pos = 0x0
	// Bit mask of NIRK field.
	AAR_NIRK_NIRK_Msk = 0x1f

	// IRKPTR: Pointer to IRK data structure
	// Position of IRKPTR field.
	AAR_IRKPTR_IRKPTR_Pos = 0x0
	// Bit mask of IRKPTR field.
	AAR_IRKPTR_IRKPTR_Msk = 0xffffffff

	// ADDRPTR: Pointer to the resolvable address
	// Position of ADDRPTR field.
	AAR_ADDRPTR_ADDRPTR_Pos = 0x0
	// Bit mask of ADDRPTR field.
	AAR_ADDRPTR_ADDRPTR_Msk = 0xffffffff

	// SCRATCHPTR: Pointer to data area used for temporary storage
	// Position of SCRATCHPTR field.
	AAR_SCRATCHPTR_SCRATCHPTR_Pos = 0x0
	// Bit mask of SCRATCHPTR field.
	AAR_SCRATCHPTR_SCRATCHPTR_Msk = 0xffffffff
)

// Constants for CCM: AES CCM Mode Encryption
const (
	// TASKS_KSGEN: Start generation of key-stream. This operation will stop by itself when completed.
	// Position of TASKS_KSGEN field.
	CCM_TASKS_KSGEN_TASKS_KSGEN_Pos = 0x0
	// Bit mask of TASKS_KSGEN field.
	CCM_TASKS_KSGEN_TASKS_KSGEN_Msk = 0x1
	// Bit TASKS_KSGEN.
	CCM_TASKS_KSGEN_TASKS_KSGEN = 0x1
	// Trigger task
	CCM_TASKS_KSGEN_TASKS_KSGEN_Trigger = 0x1

	// TASKS_CRYPT: Start encryption/decryption. This operation will stop by itself when completed.
	// Position of TASKS_CRYPT field.
	CCM_TASKS_CRYPT_TASKS_CRYPT_Pos = 0x0
	// Bit mask of TASKS_CRYPT field.
	CCM_TASKS_CRYPT_TASKS_CRYPT_Msk = 0x1
	// Bit TASKS_CRYPT.
	CCM_TASKS_CRYPT_TASKS_CRYPT = 0x1
	// Trigger task
	CCM_TASKS_CRYPT_TASKS_CRYPT_Trigger = 0x1

	// TASKS_STOP: Stop encryption/decryption
	// Position of TASKS_STOP field.
	CCM_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	CCM_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	CCM_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	CCM_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_RATEOVERRIDE: Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption
	// Position of TASKS_RATEOVERRIDE field.
	CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Pos = 0x0
	// Bit mask of TASKS_RATEOVERRIDE field.
	CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Msk = 0x1
	// Bit TASKS_RATEOVERRIDE.
	CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE = 0x1
	// Trigger task
	CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Trigger = 0x1

	// EVENTS_ENDKSGEN: Key-stream generation complete
	// Position of EVENTS_ENDKSGEN field.
	CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Pos = 0x0
	// Bit mask of EVENTS_ENDKSGEN field.
	CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Msk = 0x1
	// Bit EVENTS_ENDKSGEN.
	CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN = 0x1
	// Event not generated
	CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_NotGenerated = 0x0
	// Event generated
	CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Generated = 0x1

	// EVENTS_ENDCRYPT: Encrypt/decrypt complete
	// Position of EVENTS_ENDCRYPT field.
	CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Pos = 0x0
	// Bit mask of EVENTS_ENDCRYPT field.
	CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Msk = 0x1
	// Bit EVENTS_ENDCRYPT.
	CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT = 0x1
	// Event not generated
	CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_NotGenerated = 0x0
	// Event generated
	CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Generated = 0x1

	// EVENTS_ERROR: Deprecated register - CCM error event
	// Position of EVENTS_ERROR field.
	CCM_EVENTS_ERROR_EVENTS_ERROR_Pos = 0x0
	// Bit mask of EVENTS_ERROR field.
	CCM_EVENTS_ERROR_EVENTS_ERROR_Msk = 0x1
	// Bit EVENTS_ERROR.
	CCM_EVENTS_ERROR_EVENTS_ERROR = 0x1
	// Event not generated
	CCM_EVENTS_ERROR_EVENTS_ERROR_NotGenerated = 0x0
	// Event generated
	CCM_EVENTS_ERROR_EVENTS_ERROR_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of ENDKSGEN_CRYPT field.
	CCM_SHORTS_ENDKSGEN_CRYPT_Pos = 0x0
	// Bit mask of ENDKSGEN_CRYPT field.
	CCM_SHORTS_ENDKSGEN_CRYPT_Msk = 0x1
	// Bit ENDKSGEN_CRYPT.
	CCM_SHORTS_ENDKSGEN_CRYPT = 0x1
	// Disable shortcut
	CCM_SHORTS_ENDKSGEN_CRYPT_Disabled = 0x0
	// Enable shortcut
	CCM_SHORTS_ENDKSGEN_CRYPT_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of ENDKSGEN field.
	CCM_INTENSET_ENDKSGEN_Pos = 0x0
	// Bit mask of ENDKSGEN field.
	CCM_INTENSET_ENDKSGEN_Msk = 0x1
	// Bit ENDKSGEN.
	CCM_INTENSET_ENDKSGEN = 0x1
	// Read: Disabled
	CCM_INTENSET_ENDKSGEN_Disabled = 0x0
	// Read: Enabled
	CCM_INTENSET_ENDKSGEN_Enabled = 0x1
	// Enable
	CCM_INTENSET_ENDKSGEN_Set = 0x1
	// Position of ENDCRYPT field.
	CCM_INTENSET_ENDCRYPT_Pos = 0x1
	// Bit mask of ENDCRYPT field.
	CCM_INTENSET_ENDCRYPT_Msk = 0x2
	// Bit ENDCRYPT.
	CCM_INTENSET_ENDCRYPT = 0x2
	// Read: Disabled
	CCM_INTENSET_ENDCRYPT_Disabled = 0x0
	// Read: Enabled
	CCM_INTENSET_ENDCRYPT_Enabled = 0x1
	// Enable
	CCM_INTENSET_ENDCRYPT_Set = 0x1
	// Position of ERROR field.
	CCM_INTENSET_ERROR_Pos = 0x2
	// Bit mask of ERROR field.
	CCM_INTENSET_ERROR_Msk = 0x4
	// Bit ERROR.
	CCM_INTENSET_ERROR = 0x4
	// Read: Disabled
	CCM_INTENSET_ERROR_Disabled = 0x0
	// Read: Enabled
	CCM_INTENSET_ERROR_Enabled = 0x1
	// Enable
	CCM_INTENSET_ERROR_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of ENDKSGEN field.
	CCM_INTENCLR_ENDKSGEN_Pos = 0x0
	// Bit mask of ENDKSGEN field.
	CCM_INTENCLR_ENDKSGEN_Msk = 0x1
	// Bit ENDKSGEN.
	CCM_INTENCLR_ENDKSGEN = 0x1
	// Read: Disabled
	CCM_INTENCLR_ENDKSGEN_Disabled = 0x0
	// Read: Enabled
	CCM_INTENCLR_ENDKSGEN_Enabled = 0x1
	// Disable
	CCM_INTENCLR_ENDKSGEN_Clear = 0x1
	// Position of ENDCRYPT field.
	CCM_INTENCLR_ENDCRYPT_Pos = 0x1
	// Bit mask of ENDCRYPT field.
	CCM_INTENCLR_ENDCRYPT_Msk = 0x2
	// Bit ENDCRYPT.
	CCM_INTENCLR_ENDCRYPT = 0x2
	// Read: Disabled
	CCM_INTENCLR_ENDCRYPT_Disabled = 0x0
	// Read: Enabled
	CCM_INTENCLR_ENDCRYPT_Enabled = 0x1
	// Disable
	CCM_INTENCLR_ENDCRYPT_Clear = 0x1
	// Position of ERROR field.
	CCM_INTENCLR_ERROR_Pos = 0x2
	// Bit mask of ERROR field.
	CCM_INTENCLR_ERROR_Msk = 0x4
	// Bit ERROR.
	CCM_INTENCLR_ERROR = 0x4
	// Read: Disabled
	CCM_INTENCLR_ERROR_Disabled = 0x0
	// Read: Enabled
	CCM_INTENCLR_ERROR_Enabled = 0x1
	// Disable
	CCM_INTENCLR_ERROR_Clear = 0x1

	// MICSTATUS: MIC check result
	// Position of MICSTATUS field.
	CCM_MICSTATUS_MICSTATUS_Pos = 0x0
	// Bit mask of MICSTATUS field.
	CCM_MICSTATUS_MICSTATUS_Msk = 0x1
	// Bit MICSTATUS.
	CCM_MICSTATUS_MICSTATUS = 0x1
	// MIC check failed
	CCM_MICSTATUS_MICSTATUS_CheckFailed = 0x0
	// MIC check passed
	CCM_MICSTATUS_MICSTATUS_CheckPassed = 0x1

	// ENABLE: Enable
	// Position of ENABLE field.
	CCM_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	CCM_ENABLE_ENABLE_Msk = 0x3
	// Disable
	CCM_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	CCM_ENABLE_ENABLE_Enabled = 0x2

	// MODE: Operation mode
	// Position of MODE field.
	CCM_MODE_MODE_Pos = 0x0
	// Bit mask of MODE field.
	CCM_MODE_MODE_Msk = 0x1
	// Bit MODE.
	CCM_MODE_MODE = 0x1
	// AES CCM packet encryption mode
	CCM_MODE_MODE_Encryption = 0x0
	// AES CCM packet decryption mode
	CCM_MODE_MODE_Decryption = 0x1
	// Position of DATARATE field.
	CCM_MODE_DATARATE_Pos = 0x10
	// Bit mask of DATARATE field.
	CCM_MODE_DATARATE_Msk = 0x30000
	// 1 Mbps
	CCM_MODE_DATARATE_1Mbit = 0x0
	// 2 Mbps
	CCM_MODE_DATARATE_2Mbit = 0x1
	// 125 Kbps
	CCM_MODE_DATARATE_125Kbps = 0x2
	// 500 Kbps
	CCM_MODE_DATARATE_500Kbps = 0x3
	// Position of LENGTH field.
	CCM_MODE_LENGTH_Pos = 0x18
	// Bit mask of LENGTH field.
	CCM_MODE_LENGTH_Msk = 0x1000000
	// Bit LENGTH.
	CCM_MODE_LENGTH = 0x1000000
	// Default length. Effective length of LENGTH field in encrypted/decrypted packet is 5 bits. A key-stream for packet payloads up to 27 bytes will be generated.
	CCM_MODE_LENGTH_Default = 0x0
	// Extended length. Effective length of LENGTH field in encrypted/decrypted packet is 8 bits. A key-stream for packet payloads up to MAXPACKETSIZE bytes will be generated.
	CCM_MODE_LENGTH_Extended = 0x1

	// CNFPTR: Pointer to data structure holding AES key and NONCE vector
	// Position of CNFPTR field.
	CCM_CNFPTR_CNFPTR_Pos = 0x0
	// Bit mask of CNFPTR field.
	CCM_CNFPTR_CNFPTR_Msk = 0xffffffff

	// INPTR: Input pointer
	// Position of INPTR field.
	CCM_INPTR_INPTR_Pos = 0x0
	// Bit mask of INPTR field.
	CCM_INPTR_INPTR_Msk = 0xffffffff

	// OUTPTR: Output pointer
	// Position of OUTPTR field.
	CCM_OUTPTR_OUTPTR_Pos = 0x0
	// Bit mask of OUTPTR field.
	CCM_OUTPTR_OUTPTR_Msk = 0xffffffff

	// SCRATCHPTR: Pointer to data area used for temporary storage
	// Position of SCRATCHPTR field.
	CCM_SCRATCHPTR_SCRATCHPTR_Pos = 0x0
	// Bit mask of SCRATCHPTR field.
	CCM_SCRATCHPTR_SCRATCHPTR_Msk = 0xffffffff

	// MAXPACKETSIZE: Length of key-stream generated when MODE.LENGTH = Extended.
	// Position of MAXPACKETSIZE field.
	CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos = 0x0
	// Bit mask of MAXPACKETSIZE field.
	CCM_MAXPACKETSIZE_MAXPACKETSIZE_Msk = 0xff

	// RATEOVERRIDE: Data rate override setting.
	// Position of RATEOVERRIDE field.
	CCM_RATEOVERRIDE_RATEOVERRIDE_Pos = 0x0
	// Bit mask of RATEOVERRIDE field.
	CCM_RATEOVERRIDE_RATEOVERRIDE_Msk = 0x3
	// 1 Mbps
	CCM_RATEOVERRIDE_RATEOVERRIDE_1Mbit = 0x0
	// 2 Mbps
	CCM_RATEOVERRIDE_RATEOVERRIDE_2Mbit = 0x1
	// 125 Kbps
	CCM_RATEOVERRIDE_RATEOVERRIDE_125Kbps = 0x2
	// 500 Kbps
	CCM_RATEOVERRIDE_RATEOVERRIDE_500Kbps = 0x3
)

// Constants for WDT: Watchdog Timer
const (
	// TASKS_START: Start the watchdog
	// Position of TASKS_START field.
	WDT_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	WDT_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	WDT_TASKS_START_TASKS_START = 0x1
	// Trigger task
	WDT_TASKS_START_TASKS_START_Trigger = 0x1

	// EVENTS_TIMEOUT: Watchdog timeout
	// Position of EVENTS_TIMEOUT field.
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Pos = 0x0
	// Bit mask of EVENTS_TIMEOUT field.
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Msk = 0x1
	// Bit EVENTS_TIMEOUT.
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT = 0x1
	// Event not generated
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_NotGenerated = 0x0
	// Event generated
	WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Generated = 0x1

	// INTENSET: Enable interrupt
	// Position of TIMEOUT field.
	WDT_INTENSET_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_INTENSET_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_INTENSET_TIMEOUT = 0x1
	// Read: Disabled
	WDT_INTENSET_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_INTENSET_TIMEOUT_Enabled = 0x1
	// Enable
	WDT_INTENSET_TIMEOUT_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TIMEOUT field.
	WDT_INTENCLR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	WDT_INTENCLR_TIMEOUT_Msk = 0x1
	// Bit TIMEOUT.
	WDT_INTENCLR_TIMEOUT = 0x1
	// Read: Disabled
	WDT_INTENCLR_TIMEOUT_Disabled = 0x0
	// Read: Enabled
	WDT_INTENCLR_TIMEOUT_Enabled = 0x1
	// Disable
	WDT_INTENCLR_TIMEOUT_Clear = 0x1

	// RUNSTATUS: Run status
	// Position of RUNSTATUS field.
	WDT_RUNSTATUS_RUNSTATUS_Pos = 0x0
	// Bit mask of RUNSTATUS field.
	WDT_RUNSTATUS_RUNSTATUS_Msk = 0x1
	// Bit RUNSTATUS.
	WDT_RUNSTATUS_RUNSTATUS = 0x1
	// Watchdog not running
	WDT_RUNSTATUS_RUNSTATUS_NotRunning = 0x0
	// Watchdog is running
	WDT_RUNSTATUS_RUNSTATUS_Running = 0x1

	// REQSTATUS: Request status
	// Position of RR0 field.
	WDT_REQSTATUS_RR0_Pos = 0x0
	// Bit mask of RR0 field.
	WDT_REQSTATUS_RR0_Msk = 0x1
	// Bit RR0.
	WDT_REQSTATUS_RR0 = 0x1
	// RR[0] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR0_DisabledOrRequested = 0x0
	// RR[0] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR0_EnabledAndUnrequested = 0x1
	// Position of RR1 field.
	WDT_REQSTATUS_RR1_Pos = 0x1
	// Bit mask of RR1 field.
	WDT_REQSTATUS_RR1_Msk = 0x2
	// Bit RR1.
	WDT_REQSTATUS_RR1 = 0x2
	// RR[1] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR1_DisabledOrRequested = 0x0
	// RR[1] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR1_EnabledAndUnrequested = 0x1
	// Position of RR2 field.
	WDT_REQSTATUS_RR2_Pos = 0x2
	// Bit mask of RR2 field.
	WDT_REQSTATUS_RR2_Msk = 0x4
	// Bit RR2.
	WDT_REQSTATUS_RR2 = 0x4
	// RR[2] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR2_DisabledOrRequested = 0x0
	// RR[2] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR2_EnabledAndUnrequested = 0x1
	// Position of RR3 field.
	WDT_REQSTATUS_RR3_Pos = 0x3
	// Bit mask of RR3 field.
	WDT_REQSTATUS_RR3_Msk = 0x8
	// Bit RR3.
	WDT_REQSTATUS_RR3 = 0x8
	// RR[3] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR3_DisabledOrRequested = 0x0
	// RR[3] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR3_EnabledAndUnrequested = 0x1
	// Position of RR4 field.
	WDT_REQSTATUS_RR4_Pos = 0x4
	// Bit mask of RR4 field.
	WDT_REQSTATUS_RR4_Msk = 0x10
	// Bit RR4.
	WDT_REQSTATUS_RR4 = 0x10
	// RR[4] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR4_DisabledOrRequested = 0x0
	// RR[4] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR4_EnabledAndUnrequested = 0x1
	// Position of RR5 field.
	WDT_REQSTATUS_RR5_Pos = 0x5
	// Bit mask of RR5 field.
	WDT_REQSTATUS_RR5_Msk = 0x20
	// Bit RR5.
	WDT_REQSTATUS_RR5 = 0x20
	// RR[5] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR5_DisabledOrRequested = 0x0
	// RR[5] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR5_EnabledAndUnrequested = 0x1
	// Position of RR6 field.
	WDT_REQSTATUS_RR6_Pos = 0x6
	// Bit mask of RR6 field.
	WDT_REQSTATUS_RR6_Msk = 0x40
	// Bit RR6.
	WDT_REQSTATUS_RR6 = 0x40
	// RR[6] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR6_DisabledOrRequested = 0x0
	// RR[6] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR6_EnabledAndUnrequested = 0x1
	// Position of RR7 field.
	WDT_REQSTATUS_RR7_Pos = 0x7
	// Bit mask of RR7 field.
	WDT_REQSTATUS_RR7_Msk = 0x80
	// Bit RR7.
	WDT_REQSTATUS_RR7 = 0x80
	// RR[7] register is not enabled, or are already requesting reload
	WDT_REQSTATUS_RR7_DisabledOrRequested = 0x0
	// RR[7] register is enabled, and are not yet requesting reload
	WDT_REQSTATUS_RR7_EnabledAndUnrequested = 0x1

	// CRV: Counter reload value
	// Position of CRV field.
	WDT_CRV_CRV_Pos = 0x0
	// Bit mask of CRV field.
	WDT_CRV_CRV_Msk = 0xffffffff

	// RREN: Enable register for reload request registers
	// Position of RR0 field.
	WDT_RREN_RR0_Pos = 0x0
	// Bit mask of RR0 field.
	WDT_RREN_RR0_Msk = 0x1
	// Bit RR0.
	WDT_RREN_RR0 = 0x1
	// Disable RR[0] register
	WDT_RREN_RR0_Disabled = 0x0
	// Enable RR[0] register
	WDT_RREN_RR0_Enabled = 0x1
	// Position of RR1 field.
	WDT_RREN_RR1_Pos = 0x1
	// Bit mask of RR1 field.
	WDT_RREN_RR1_Msk = 0x2
	// Bit RR1.
	WDT_RREN_RR1 = 0x2
	// Disable RR[1] register
	WDT_RREN_RR1_Disabled = 0x0
	// Enable RR[1] register
	WDT_RREN_RR1_Enabled = 0x1
	// Position of RR2 field.
	WDT_RREN_RR2_Pos = 0x2
	// Bit mask of RR2 field.
	WDT_RREN_RR2_Msk = 0x4
	// Bit RR2.
	WDT_RREN_RR2 = 0x4
	// Disable RR[2] register
	WDT_RREN_RR2_Disabled = 0x0
	// Enable RR[2] register
	WDT_RREN_RR2_Enabled = 0x1
	// Position of RR3 field.
	WDT_RREN_RR3_Pos = 0x3
	// Bit mask of RR3 field.
	WDT_RREN_RR3_Msk = 0x8
	// Bit RR3.
	WDT_RREN_RR3 = 0x8
	// Disable RR[3] register
	WDT_RREN_RR3_Disabled = 0x0
	// Enable RR[3] register
	WDT_RREN_RR3_Enabled = 0x1
	// Position of RR4 field.
	WDT_RREN_RR4_Pos = 0x4
	// Bit mask of RR4 field.
	WDT_RREN_RR4_Msk = 0x10
	// Bit RR4.
	WDT_RREN_RR4 = 0x10
	// Disable RR[4] register
	WDT_RREN_RR4_Disabled = 0x0
	// Enable RR[4] register
	WDT_RREN_RR4_Enabled = 0x1
	// Position of RR5 field.
	WDT_RREN_RR5_Pos = 0x5
	// Bit mask of RR5 field.
	WDT_RREN_RR5_Msk = 0x20
	// Bit RR5.
	WDT_RREN_RR5 = 0x20
	// Disable RR[5] register
	WDT_RREN_RR5_Disabled = 0x0
	// Enable RR[5] register
	WDT_RREN_RR5_Enabled = 0x1
	// Position of RR6 field.
	WDT_RREN_RR6_Pos = 0x6
	// Bit mask of RR6 field.
	WDT_RREN_RR6_Msk = 0x40
	// Bit RR6.
	WDT_RREN_RR6 = 0x40
	// Disable RR[6] register
	WDT_RREN_RR6_Disabled = 0x0
	// Enable RR[6] register
	WDT_RREN_RR6_Enabled = 0x1
	// Position of RR7 field.
	WDT_RREN_RR7_Pos = 0x7
	// Bit mask of RR7 field.
	WDT_RREN_RR7_Msk = 0x80
	// Bit RR7.
	WDT_RREN_RR7 = 0x80
	// Disable RR[7] register
	WDT_RREN_RR7_Disabled = 0x0
	// Enable RR[7] register
	WDT_RREN_RR7_Enabled = 0x1

	// CONFIG: Configuration register
	// Position of SLEEP field.
	WDT_CONFIG_SLEEP_Pos = 0x0
	// Bit mask of SLEEP field.
	WDT_CONFIG_SLEEP_Msk = 0x1
	// Bit SLEEP.
	WDT_CONFIG_SLEEP = 0x1
	// Pause watchdog while the CPU is sleeping
	WDT_CONFIG_SLEEP_Pause = 0x0
	// Keep the watchdog running while the CPU is sleeping
	WDT_CONFIG_SLEEP_Run = 0x1
	// Position of HALT field.
	WDT_CONFIG_HALT_Pos = 0x3
	// Bit mask of HALT field.
	WDT_CONFIG_HALT_Msk = 0x8
	// Bit HALT.
	WDT_CONFIG_HALT = 0x8
	// Pause watchdog while the CPU is halted by the debugger
	WDT_CONFIG_HALT_Pause = 0x0
	// Keep the watchdog running while the CPU is halted by the debugger
	WDT_CONFIG_HALT_Run = 0x1

	// RR: Description collection: Reload request n
	// Position of RR field.
	WDT_RR_RR_Pos = 0x0
	// Bit mask of RR field.
	WDT_RR_RR_Msk = 0xffffffff
	// Value to request a reload of the watchdog timer
	WDT_RR_RR_Reload = 0x6e524635
)

// Constants for QDEC: Quadrature Decoder
const (
	// TASKS_START: Task starting the quadrature decoder
	// Position of TASKS_START field.
	QDEC_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	QDEC_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	QDEC_TASKS_START_TASKS_START = 0x1
	// Trigger task
	QDEC_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Task stopping the quadrature decoder
	// Position of TASKS_STOP field.
	QDEC_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	QDEC_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	QDEC_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	QDEC_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_READCLRACC: Read and clear ACC and ACCDBL
	// Position of TASKS_READCLRACC field.
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Pos = 0x0
	// Bit mask of TASKS_READCLRACC field.
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Msk = 0x1
	// Bit TASKS_READCLRACC.
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC = 0x1
	// Trigger task
	QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Trigger = 0x1

	// TASKS_RDCLRACC: Read and clear ACC
	// Position of TASKS_RDCLRACC field.
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Pos = 0x0
	// Bit mask of TASKS_RDCLRACC field.
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Msk = 0x1
	// Bit TASKS_RDCLRACC.
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC = 0x1
	// Trigger task
	QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Trigger = 0x1

	// TASKS_RDCLRDBL: Read and clear ACCDBL
	// Position of TASKS_RDCLRDBL field.
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Pos = 0x0
	// Bit mask of TASKS_RDCLRDBL field.
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Msk = 0x1
	// Bit TASKS_RDCLRDBL.
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL = 0x1
	// Trigger task
	QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Trigger = 0x1

	// EVENTS_SAMPLERDY: Event being generated for every new sample value written to the SAMPLE register
	// Position of EVENTS_SAMPLERDY field.
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Pos = 0x0
	// Bit mask of EVENTS_SAMPLERDY field.
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Msk = 0x1
	// Bit EVENTS_SAMPLERDY.
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY = 0x1
	// Event not generated
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Generated = 0x1

	// EVENTS_REPORTRDY: Non-null report ready
	// Position of EVENTS_REPORTRDY field.
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Pos = 0x0
	// Bit mask of EVENTS_REPORTRDY field.
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Msk = 0x1
	// Bit EVENTS_REPORTRDY.
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY = 0x1
	// Event not generated
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Generated = 0x1

	// EVENTS_ACCOF: ACC or ACCDBL register overflow
	// Position of EVENTS_ACCOF field.
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Pos = 0x0
	// Bit mask of EVENTS_ACCOF field.
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Msk = 0x1
	// Bit EVENTS_ACCOF.
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF = 0x1
	// Event not generated
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Generated = 0x1

	// EVENTS_DBLRDY: Double displacement(s) detected
	// Position of EVENTS_DBLRDY field.
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Pos = 0x0
	// Bit mask of EVENTS_DBLRDY field.
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Msk = 0x1
	// Bit EVENTS_DBLRDY.
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY = 0x1
	// Event not generated
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Generated = 0x1

	// EVENTS_STOPPED: QDEC has been stopped
	// Position of EVENTS_STOPPED field.
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Pos = 0x0
	// Bit mask of EVENTS_STOPPED field.
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Msk = 0x1
	// Bit EVENTS_STOPPED.
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED = 0x1
	// Event not generated
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated = 0x0
	// Event generated
	QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of REPORTRDY_READCLRACC field.
	QDEC_SHORTS_REPORTRDY_READCLRACC_Pos = 0x0
	// Bit mask of REPORTRDY_READCLRACC field.
	QDEC_SHORTS_REPORTRDY_READCLRACC_Msk = 0x1
	// Bit REPORTRDY_READCLRACC.
	QDEC_SHORTS_REPORTRDY_READCLRACC = 0x1
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled = 0x1
	// Position of SAMPLERDY_STOP field.
	QDEC_SHORTS_SAMPLERDY_STOP_Pos = 0x1
	// Bit mask of SAMPLERDY_STOP field.
	QDEC_SHORTS_SAMPLERDY_STOP_Msk = 0x2
	// Bit SAMPLERDY_STOP.
	QDEC_SHORTS_SAMPLERDY_STOP = 0x2
	// Disable shortcut
	QDEC_SHORTS_SAMPLERDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_SAMPLERDY_STOP_Enabled = 0x1
	// Position of REPORTRDY_RDCLRACC field.
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos = 0x2
	// Bit mask of REPORTRDY_RDCLRACC field.
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Msk = 0x4
	// Bit REPORTRDY_RDCLRACC.
	QDEC_SHORTS_REPORTRDY_RDCLRACC = 0x4
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_RDCLRACC_Enabled = 0x1
	// Position of REPORTRDY_STOP field.
	QDEC_SHORTS_REPORTRDY_STOP_Pos = 0x3
	// Bit mask of REPORTRDY_STOP field.
	QDEC_SHORTS_REPORTRDY_STOP_Msk = 0x8
	// Bit REPORTRDY_STOP.
	QDEC_SHORTS_REPORTRDY_STOP = 0x8
	// Disable shortcut
	QDEC_SHORTS_REPORTRDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_REPORTRDY_STOP_Enabled = 0x1
	// Position of DBLRDY_RDCLRDBL field.
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos = 0x4
	// Bit mask of DBLRDY_RDCLRDBL field.
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Msk = 0x10
	// Bit DBLRDY_RDCLRDBL.
	QDEC_SHORTS_DBLRDY_RDCLRDBL = 0x10
	// Disable shortcut
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_DBLRDY_RDCLRDBL_Enabled = 0x1
	// Position of DBLRDY_STOP field.
	QDEC_SHORTS_DBLRDY_STOP_Pos = 0x5
	// Bit mask of DBLRDY_STOP field.
	QDEC_SHORTS_DBLRDY_STOP_Msk = 0x20
	// Bit DBLRDY_STOP.
	QDEC_SHORTS_DBLRDY_STOP = 0x20
	// Disable shortcut
	QDEC_SHORTS_DBLRDY_STOP_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_DBLRDY_STOP_Enabled = 0x1
	// Position of SAMPLERDY_READCLRACC field.
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos = 0x6
	// Bit mask of SAMPLERDY_READCLRACC field.
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Msk = 0x40
	// Bit SAMPLERDY_READCLRACC.
	QDEC_SHORTS_SAMPLERDY_READCLRACC = 0x40
	// Disable shortcut
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Disabled = 0x0
	// Enable shortcut
	QDEC_SHORTS_SAMPLERDY_READCLRACC_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of SAMPLERDY field.
	QDEC_INTENSET_SAMPLERDY_Pos = 0x0
	// Bit mask of SAMPLERDY field.
	QDEC_INTENSET_SAMPLERDY_Msk = 0x1
	// Bit SAMPLERDY.
	QDEC_INTENSET_SAMPLERDY = 0x1
	// Read: Disabled
	QDEC_INTENSET_SAMPLERDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_SAMPLERDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_SAMPLERDY_Set = 0x1
	// Position of REPORTRDY field.
	QDEC_INTENSET_REPORTRDY_Pos = 0x1
	// Bit mask of REPORTRDY field.
	QDEC_INTENSET_REPORTRDY_Msk = 0x2
	// Bit REPORTRDY.
	QDEC_INTENSET_REPORTRDY = 0x2
	// Read: Disabled
	QDEC_INTENSET_REPORTRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_REPORTRDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_REPORTRDY_Set = 0x1
	// Position of ACCOF field.
	QDEC_INTENSET_ACCOF_Pos = 0x2
	// Bit mask of ACCOF field.
	QDEC_INTENSET_ACCOF_Msk = 0x4
	// Bit ACCOF.
	QDEC_INTENSET_ACCOF = 0x4
	// Read: Disabled
	QDEC_INTENSET_ACCOF_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_ACCOF_Enabled = 0x1
	// Enable
	QDEC_INTENSET_ACCOF_Set = 0x1
	// Position of DBLRDY field.
	QDEC_INTENSET_DBLRDY_Pos = 0x3
	// Bit mask of DBLRDY field.
	QDEC_INTENSET_DBLRDY_Msk = 0x8
	// Bit DBLRDY.
	QDEC_INTENSET_DBLRDY = 0x8
	// Read: Disabled
	QDEC_INTENSET_DBLRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_DBLRDY_Enabled = 0x1
	// Enable
	QDEC_INTENSET_DBLRDY_Set = 0x1
	// Position of STOPPED field.
	QDEC_INTENSET_STOPPED_Pos = 0x4
	// Bit mask of STOPPED field.
	QDEC_INTENSET_STOPPED_Msk = 0x10
	// Bit STOPPED.
	QDEC_INTENSET_STOPPED = 0x10
	// Read: Disabled
	QDEC_INTENSET_STOPPED_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENSET_STOPPED_Enabled = 0x1
	// Enable
	QDEC_INTENSET_STOPPED_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of SAMPLERDY field.
	QDEC_INTENCLR_SAMPLERDY_Pos = 0x0
	// Bit mask of SAMPLERDY field.
	QDEC_INTENCLR_SAMPLERDY_Msk = 0x1
	// Bit SAMPLERDY.
	QDEC_INTENCLR_SAMPLERDY = 0x1
	// Read: Disabled
	QDEC_INTENCLR_SAMPLERDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_SAMPLERDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_SAMPLERDY_Clear = 0x1
	// Position of REPORTRDY field.
	QDEC_INTENCLR_REPORTRDY_Pos = 0x1
	// Bit mask of REPORTRDY field.
	QDEC_INTENCLR_REPORTRDY_Msk = 0x2
	// Bit REPORTRDY.
	QDEC_INTENCLR_REPORTRDY = 0x2
	// Read: Disabled
	QDEC_INTENCLR_REPORTRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_REPORTRDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_REPORTRDY_Clear = 0x1
	// Position of ACCOF field.
	QDEC_INTENCLR_ACCOF_Pos = 0x2
	// Bit mask of ACCOF field.
	QDEC_INTENCLR_ACCOF_Msk = 0x4
	// Bit ACCOF.
	QDEC_INTENCLR_ACCOF = 0x4
	// Read: Disabled
	QDEC_INTENCLR_ACCOF_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_ACCOF_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_ACCOF_Clear = 0x1
	// Position of DBLRDY field.
	QDEC_INTENCLR_DBLRDY_Pos = 0x3
	// Bit mask of DBLRDY field.
	QDEC_INTENCLR_DBLRDY_Msk = 0x8
	// Bit DBLRDY.
	QDEC_INTENCLR_DBLRDY = 0x8
	// Read: Disabled
	QDEC_INTENCLR_DBLRDY_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_DBLRDY_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_DBLRDY_Clear = 0x1
	// Position of STOPPED field.
	QDEC_INTENCLR_STOPPED_Pos = 0x4
	// Bit mask of STOPPED field.
	QDEC_INTENCLR_STOPPED_Msk = 0x10
	// Bit STOPPED.
	QDEC_INTENCLR_STOPPED = 0x10
	// Read: Disabled
	QDEC_INTENCLR_STOPPED_Disabled = 0x0
	// Read: Enabled
	QDEC_INTENCLR_STOPPED_Enabled = 0x1
	// Disable
	QDEC_INTENCLR_STOPPED_Clear = 0x1

	// ENABLE: Enable the quadrature decoder
	// Position of ENABLE field.
	QDEC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QDEC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QDEC_ENABLE_ENABLE = 0x1
	// Disable
	QDEC_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	QDEC_ENABLE_ENABLE_Enabled = 0x1

	// LEDPOL: LED output pin polarity
	// Position of LEDPOL field.
	QDEC_LEDPOL_LEDPOL_Pos = 0x0
	// Bit mask of LEDPOL field.
	QDEC_LEDPOL_LEDPOL_Msk = 0x1
	// Bit LEDPOL.
	QDEC_LEDPOL_LEDPOL = 0x1
	// Led active on output pin low
	QDEC_LEDPOL_LEDPOL_ActiveLow = 0x0
	// Led active on output pin high
	QDEC_LEDPOL_LEDPOL_ActiveHigh = 0x1

	// SAMPLEPER: Sample period
	// Position of SAMPLEPER field.
	QDEC_SAMPLEPER_SAMPLEPER_Pos = 0x0
	// Bit mask of SAMPLEPER field.
	QDEC_SAMPLEPER_SAMPLEPER_Msk = 0xf
	// 128 us
	QDEC_SAMPLEPER_SAMPLEPER_128us = 0x0
	// 256 us
	QDEC_SAMPLEPER_SAMPLEPER_256us = 0x1
	// 512 us
	QDEC_SAMPLEPER_SAMPLEPER_512us = 0x2
	// 1024 us
	QDEC_SAMPLEPER_SAMPLEPER_1024us = 0x3
	// 2048 us
	QDEC_SAMPLEPER_SAMPLEPER_2048us = 0x4
	// 4096 us
	QDEC_SAMPLEPER_SAMPLEPER_4096us = 0x5
	// 8192 us
	QDEC_SAMPLEPER_SAMPLEPER_8192us = 0x6
	// 16384 us
	QDEC_SAMPLEPER_SAMPLEPER_16384us = 0x7
	// 32768 us
	QDEC_SAMPLEPER_SAMPLEPER_32ms = 0x8
	// 65536 us
	QDEC_SAMPLEPER_SAMPLEPER_65ms = 0x9
	// 131072 us
	QDEC_SAMPLEPER_SAMPLEPER_131ms = 0xa

	// SAMPLE: Motion sample value
	// Position of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Pos = 0x0
	// Bit mask of SAMPLE field.
	QDEC_SAMPLE_SAMPLE_Msk = 0xffffffff

	// REPORTPER: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated
	// Position of REPORTPER field.
	QDEC_REPORTPER_REPORTPER_Pos = 0x0
	// Bit mask of REPORTPER field.
	QDEC_REPORTPER_REPORTPER_Msk = 0xf
	// 10 samples / report
	QDEC_REPORTPER_REPORTPER_10Smpl = 0x0
	// 40 samples / report
	QDEC_REPORTPER_REPORTPER_40Smpl = 0x1
	// 80 samples / report
	QDEC_REPORTPER_REPORTPER_80Smpl = 0x2
	// 120 samples / report
	QDEC_REPORTPER_REPORTPER_120Smpl = 0x3
	// 160 samples / report
	QDEC_REPORTPER_REPORTPER_160Smpl = 0x4
	// 200 samples / report
	QDEC_REPORTPER_REPORTPER_200Smpl = 0x5
	// 240 samples / report
	QDEC_REPORTPER_REPORTPER_240Smpl = 0x6
	// 280 samples / report
	QDEC_REPORTPER_REPORTPER_280Smpl = 0x7
	// 1 sample / report
	QDEC_REPORTPER_REPORTPER_1Smpl = 0x8

	// ACC: Register accumulating the valid transitions
	// Position of ACC field.
	QDEC_ACC_ACC_Pos = 0x0
	// Bit mask of ACC field.
	QDEC_ACC_ACC_Msk = 0xffffffff

	// ACCREAD: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task
	// Position of ACCREAD field.
	QDEC_ACCREAD_ACCREAD_Pos = 0x0
	// Bit mask of ACCREAD field.
	QDEC_ACCREAD_ACCREAD_Msk = 0xffffffff

	// PSEL.LED: Pin select for LED signal
	// Position of PIN field.
	QDEC_PSEL_LED_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_LED_PIN_Msk = 0x1f
	// Position of CONNECT field.
	QDEC_PSEL_LED_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_LED_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_LED_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_LED_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_LED_CONNECT_Connected = 0x0

	// PSEL.A: Pin select for A signal
	// Position of PIN field.
	QDEC_PSEL_A_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_A_PIN_Msk = 0x1f
	// Position of CONNECT field.
	QDEC_PSEL_A_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_A_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_A_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_A_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_A_CONNECT_Connected = 0x0

	// PSEL.B: Pin select for B signal
	// Position of PIN field.
	QDEC_PSEL_B_PIN_Pos = 0x0
	// Bit mask of PIN field.
	QDEC_PSEL_B_PIN_Msk = 0x1f
	// Position of CONNECT field.
	QDEC_PSEL_B_CONNECT_Pos = 0x1f
	// Bit mask of CONNECT field.
	QDEC_PSEL_B_CONNECT_Msk = 0x80000000
	// Bit CONNECT.
	QDEC_PSEL_B_CONNECT = 0x80000000
	// Disconnect
	QDEC_PSEL_B_CONNECT_Disconnected = 0x1
	// Connect
	QDEC_PSEL_B_CONNECT_Connected = 0x0

	// DBFEN: Enable input debounce filters
	// Position of DBFEN field.
	QDEC_DBFEN_DBFEN_Pos = 0x0
	// Bit mask of DBFEN field.
	QDEC_DBFEN_DBFEN_Msk = 0x1
	// Bit DBFEN.
	QDEC_DBFEN_DBFEN = 0x1
	// Debounce input filters disabled
	QDEC_DBFEN_DBFEN_Disabled = 0x0
	// Debounce input filters enabled
	QDEC_DBFEN_DBFEN_Enabled = 0x1

	// LEDPRE: Time period the LED is switched ON prior to sampling
	// Position of LEDPRE field.
	QDEC_LEDPRE_LEDPRE_Pos = 0x0
	// Bit mask of LEDPRE field.
	QDEC_LEDPRE_LEDPRE_Msk = 0x1ff

	// ACCDBL: Register accumulating the number of detected double transitions
	// Position of ACCDBL field.
	QDEC_ACCDBL_ACCDBL_Pos = 0x0
	// Bit mask of ACCDBL field.
	QDEC_ACCDBL_ACCDBL_Msk = 0xf

	// ACCDBLREAD: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task
	// Position of ACCDBLREAD field.
	QDEC_ACCDBLREAD_ACCDBLREAD_Pos = 0x0
	// Bit mask of ACCDBLREAD field.
	QDEC_ACCDBLREAD_ACCDBLREAD_Msk = 0xf
)

// Constants for COMP: Comparator
const (
	// TASKS_START: Start comparator
	// Position of TASKS_START field.
	COMP_TASKS_START_TASKS_START_Pos = 0x0
	// Bit mask of TASKS_START field.
	COMP_TASKS_START_TASKS_START_Msk = 0x1
	// Bit TASKS_START.
	COMP_TASKS_START_TASKS_START = 0x1
	// Trigger task
	COMP_TASKS_START_TASKS_START_Trigger = 0x1

	// TASKS_STOP: Stop comparator
	// Position of TASKS_STOP field.
	COMP_TASKS_STOP_TASKS_STOP_Pos = 0x0
	// Bit mask of TASKS_STOP field.
	COMP_TASKS_STOP_TASKS_STOP_Msk = 0x1
	// Bit TASKS_STOP.
	COMP_TASKS_STOP_TASKS_STOP = 0x1
	// Trigger task
	COMP_TASKS_STOP_TASKS_STOP_Trigger = 0x1

	// TASKS_SAMPLE: Sample comparator value
	// Position of TASKS_SAMPLE field.
	COMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos = 0x0
	// Bit mask of TASKS_SAMPLE field.
	COMP_TASKS_SAMPLE_TASKS_SAMPLE_Msk = 0x1
	// Bit TASKS_SAMPLE.
	COMP_TASKS_SAMPLE_TASKS_SAMPLE = 0x1
	// Trigger task
	COMP_TASKS_SAMPLE_TASKS_SAMPLE_Trigger = 0x1

	// EVENTS_READY: COMP is ready and output is valid
	// Position of EVENTS_READY field.
	COMP_EVENTS_READY_EVENTS_READY_Pos = 0x0
	// Bit mask of EVENTS_READY field.
	COMP_EVENTS_READY_EVENTS_READY_Msk = 0x1
	// Bit EVENTS_READY.
	COMP_EVENTS_READY_EVENTS_READY = 0x1
	// Event not generated
	COMP_EVENTS_READY_EVENTS_READY_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_READY_EVENTS_READY_Generated = 0x1

	// EVENTS_DOWN: Downward crossing
	// Position of EVENTS_DOWN field.
	COMP_EVENTS_DOWN_EVENTS_DOWN_Pos = 0x0
	// Bit mask of EVENTS_DOWN field.
	COMP_EVENTS_DOWN_EVENTS_DOWN_Msk = 0x1
	// Bit EVENTS_DOWN.
	COMP_EVENTS_DOWN_EVENTS_DOWN = 0x1
	// Event not generated
	COMP_EVENTS_DOWN_EVENTS_DOWN_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_DOWN_EVENTS_DOWN_Generated = 0x1

	// EVENTS_UP: Upward crossing
	// Position of EVENTS_UP field.
	COMP_EVENTS_UP_EVENTS_UP_Pos = 0x0
	// Bit mask of EVENTS_UP field.
	COMP_EVENTS_UP_EVENTS_UP_Msk = 0x1
	// Bit EVENTS_UP.
	COMP_EVENTS_UP_EVENTS_UP = 0x1
	// Event not generated
	COMP_EVENTS_UP_EVENTS_UP_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_UP_EVENTS_UP_Generated = 0x1

	// EVENTS_CROSS: Downward or upward crossing
	// Position of EVENTS_CROSS field.
	COMP_EVENTS_CROSS_EVENTS_CROSS_Pos = 0x0
	// Bit mask of EVENTS_CROSS field.
	COMP_EVENTS_CROSS_EVENTS_CROSS_Msk = 0x1
	// Bit EVENTS_CROSS.
	COMP_EVENTS_CROSS_EVENTS_CROSS = 0x1
	// Event not generated
	COMP_EVENTS_CROSS_EVENTS_CROSS_NotGenerated = 0x0
	// Event generated
	COMP_EVENTS_CROSS_EVENTS_CROSS_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of READY_SAMPLE field.
	COMP_SHORTS_READY_SAMPLE_Pos = 0x0
	// Bit mask of READY_SAMPLE field.
	COMP_SHORTS_READY_SAMPLE_Msk = 0x1
	// Bit READY_SAMPLE.
	COMP_SHORTS_READY_SAMPLE = 0x1
	// Disable shortcut
	COMP_SHORTS_READY_SAMPLE_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_READY_SAMPLE_Enabled = 0x1
	// Position of READY_STOP field.
	COMP_SHORTS_READY_STOP_Pos = 0x1
	// Bit mask of READY_STOP field.
	COMP_SHORTS_READY_STOP_Msk = 0x2
	// Bit READY_STOP.
	COMP_SHORTS_READY_STOP = 0x2
	// Disable shortcut
	COMP_SHORTS_READY_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_READY_STOP_Enabled = 0x1
	// Position of DOWN_STOP field.
	COMP_SHORTS_DOWN_STOP_Pos = 0x2
	// Bit mask of DOWN_STOP field.
	COMP_SHORTS_DOWN_STOP_Msk = 0x4
	// Bit DOWN_STOP.
	COMP_SHORTS_DOWN_STOP = 0x4
	// Disable shortcut
	COMP_SHORTS_DOWN_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_DOWN_STOP_Enabled = 0x1
	// Position of UP_STOP field.
	COMP_SHORTS_UP_STOP_Pos = 0x3
	// Bit mask of UP_STOP field.
	COMP_SHORTS_UP_STOP_Msk = 0x8
	// Bit UP_STOP.
	COMP_SHORTS_UP_STOP = 0x8
	// Disable shortcut
	COMP_SHORTS_UP_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_UP_STOP_Enabled = 0x1
	// Position of CROSS_STOP field.
	COMP_SHORTS_CROSS_STOP_Pos = 0x4
	// Bit mask of CROSS_STOP field.
	COMP_SHORTS_CROSS_STOP_Msk = 0x10
	// Bit CROSS_STOP.
	COMP_SHORTS_CROSS_STOP = 0x10
	// Disable shortcut
	COMP_SHORTS_CROSS_STOP_Disabled = 0x0
	// Enable shortcut
	COMP_SHORTS_CROSS_STOP_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of READY field.
	COMP_INTEN_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTEN_READY_Msk = 0x1
	// Bit READY.
	COMP_INTEN_READY = 0x1
	// Disable
	COMP_INTEN_READY_Disabled = 0x0
	// Enable
	COMP_INTEN_READY_Enabled = 0x1
	// Position of DOWN field.
	COMP_INTEN_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTEN_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTEN_DOWN = 0x2
	// Disable
	COMP_INTEN_DOWN_Disabled = 0x0
	// Enable
	COMP_INTEN_DOWN_Enabled = 0x1
	// Position of UP field.
	COMP_INTEN_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTEN_UP_Msk = 0x4
	// Bit UP.
	COMP_INTEN_UP = 0x4
	// Disable
	COMP_INTEN_UP_Disabled = 0x0
	// Enable
	COMP_INTEN_UP_Enabled = 0x1
	// Position of CROSS field.
	COMP_INTEN_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTEN_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTEN_CROSS = 0x8
	// Disable
	COMP_INTEN_CROSS_Disabled = 0x0
	// Enable
	COMP_INTEN_CROSS_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of READY field.
	COMP_INTENSET_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTENSET_READY_Msk = 0x1
	// Bit READY.
	COMP_INTENSET_READY = 0x1
	// Read: Disabled
	COMP_INTENSET_READY_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_READY_Enabled = 0x1
	// Enable
	COMP_INTENSET_READY_Set = 0x1
	// Position of DOWN field.
	COMP_INTENSET_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTENSET_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTENSET_DOWN = 0x2
	// Read: Disabled
	COMP_INTENSET_DOWN_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_DOWN_Enabled = 0x1
	// Enable
	COMP_INTENSET_DOWN_Set = 0x1
	// Position of UP field.
	COMP_INTENSET_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTENSET_UP_Msk = 0x4
	// Bit UP.
	COMP_INTENSET_UP = 0x4
	// Read: Disabled
	COMP_INTENSET_UP_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_UP_Enabled = 0x1
	// Enable
	COMP_INTENSET_UP_Set = 0x1
	// Position of CROSS field.
	COMP_INTENSET_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTENSET_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTENSET_CROSS = 0x8
	// Read: Disabled
	COMP_INTENSET_CROSS_Disabled = 0x0
	// Read: Enabled
	COMP_INTENSET_CROSS_Enabled = 0x1
	// Enable
	COMP_INTENSET_CROSS_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of READY field.
	COMP_INTENCLR_READY_Pos = 0x0
	// Bit mask of READY field.
	COMP_INTENCLR_READY_Msk = 0x1
	// Bit READY.
	COMP_INTENCLR_READY = 0x1
	// Read: Disabled
	COMP_INTENCLR_READY_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_READY_Enabled = 0x1
	// Disable
	COMP_INTENCLR_READY_Clear = 0x1
	// Position of DOWN field.
	COMP_INTENCLR_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	COMP_INTENCLR_DOWN_Msk = 0x2
	// Bit DOWN.
	COMP_INTENCLR_DOWN = 0x2
	// Read: Disabled
	COMP_INTENCLR_DOWN_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_DOWN_Enabled = 0x1
	// Disable
	COMP_INTENCLR_DOWN_Clear = 0x1
	// Position of UP field.
	COMP_INTENCLR_UP_Pos = 0x2
	// Bit mask of UP field.
	COMP_INTENCLR_UP_Msk = 0x4
	// Bit UP.
	COMP_INTENCLR_UP = 0x4
	// Read: Disabled
	COMP_INTENCLR_UP_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_UP_Enabled = 0x1
	// Disable
	COMP_INTENCLR_UP_Clear = 0x1
	// Position of CROSS field.
	COMP_INTENCLR_CROSS_Pos = 0x3
	// Bit mask of CROSS field.
	COMP_INTENCLR_CROSS_Msk = 0x8
	// Bit CROSS.
	COMP_INTENCLR_CROSS = 0x8
	// Read: Disabled
	COMP_INTENCLR_CROSS_Disabled = 0x0
	// Read: Enabled
	COMP_INTENCLR_CROSS_Enabled = 0x1
	// Disable
	COMP_INTENCLR_CROSS_Clear = 0x1

	// RESULT: Compare result
	// Position of RESULT field.
	COMP_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	COMP_RESULT_RESULT_Msk = 0x1
	// Bit RESULT.
	COMP_RESULT_RESULT = 0x1
	// Input voltage is below the threshold (VIN+ &lt; VIN-)
	COMP_RESULT_RESULT_Below = 0x0
	// Input voltage is above the threshold (VIN+ &gt; VIN-)
	COMP_RESULT_RESULT_Above = 0x1

	// ENABLE: COMP enable
	// Position of ENABLE field.
	COMP_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	COMP_ENABLE_ENABLE_Msk = 0x3
	// Disable
	COMP_ENABLE_ENABLE_Disabled = 0x0
	// Enable
	COMP_ENABLE_ENABLE_Enabled = 0x2

	// PSEL: Pin select
	// Position of PSEL field.
	COMP_PSEL_PSEL_Pos = 0x0
	// Bit mask of PSEL field.
	COMP_PSEL_PSEL_Msk = 0x7
	// AIN0 selected as analog input
	COMP_PSEL_PSEL_AnalogInput0 = 0x0
	// AIN1 selected as analog input
	COMP_PSEL_PSEL_AnalogInput1 = 0x1
	// AIN2 selected as analog input
	COMP_PSEL_PSEL_AnalogInput2 = 0x2
	// AIN3 selected as analog input
	COMP_PSEL_PSEL_AnalogInput3 = 0x3
	// VDDH/5 selected as analog input
	COMP_PSEL_PSEL_VddhDiv5 = 0x7

	// REFSEL: Reference source select for single-ended mode
	// Position of REFSEL field.
	COMP_REFSEL_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	COMP_REFSEL_REFSEL_Msk = 0x7
	// VREF = internal 1.2 V reference (VDD &gt;= 1.7 V)
	COMP_REFSEL_REFSEL_Int1V2 = 0x0
	// VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V)
	COMP_REFSEL_REFSEL_Int1V8 = 0x1
	// VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V)
	COMP_REFSEL_REFSEL_Int2V4 = 0x2
	// VREF = VDD
	COMP_REFSEL_REFSEL_VDD = 0x4
	// VREF = AREF
	COMP_REFSEL_REFSEL_ARef = 0x5

	// EXTREFSEL: External reference select
	// Position of EXTREFSEL field.
	COMP_EXTREFSEL_EXTREFSEL_Pos = 0x0
	// Bit mask of EXTREFSEL field.
	COMP_EXTREFSEL_EXTREFSEL_Msk = 0x7
	// Use AIN0 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 = 0x0
	// Use AIN1 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 = 0x1
	// Use AIN2 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference2 = 0x2
	// Use AIN3 as external analog reference
	COMP_EXTREFSEL_EXTREFSEL_AnalogReference3 = 0x3

	// TH: Threshold configuration for hysteresis unit
	// Position of THDOWN field.
	COMP_TH_THDOWN_Pos = 0x0
	// Bit mask of THDOWN field.
	COMP_TH_THDOWN_Msk = 0x3f
	// Position of THUP field.
	COMP_TH_THUP_Pos = 0x8
	// Bit mask of THUP field.
	COMP_TH_THUP_Msk = 0x3f00

	// MODE: Mode configuration
	// Position of SP field.
	COMP_MODE_SP_Pos = 0x0
	// Bit mask of SP field.
	COMP_MODE_SP_Msk = 0x3
	// Low-power mode
	COMP_MODE_SP_Low = 0x0
	// Normal mode
	COMP_MODE_SP_Normal = 0x1
	// High-speed mode
	COMP_MODE_SP_High = 0x2
	// Position of MAIN field.
	COMP_MODE_MAIN_Pos = 0x8
	// Bit mask of MAIN field.
	COMP_MODE_MAIN_Msk = 0x100
	// Bit MAIN.
	COMP_MODE_MAIN = 0x100
	// Single-ended mode
	COMP_MODE_MAIN_SE = 0x0
	// Differential mode
	COMP_MODE_MAIN_Diff = 0x1

	// HYST: Comparator hysteresis enable
	// Position of HYST field.
	COMP_HYST_HYST_Pos = 0x0
	// Bit mask of HYST field.
	COMP_HYST_HYST_Msk = 0x1
	// Bit HYST.
	COMP_HYST_HYST = 0x1
	// Comparator hysteresis disabled
	COMP_HYST_HYST_NoHyst = 0x0
	// Comparator hysteresis enabled
	COMP_HYST_HYST_Hyst50mV = 0x1
)

// Constants for EGU0: Event generator unit 0
const (
	// TASKS_TRIGGER: Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event
	// Position of TASKS_TRIGGER field.
	EGU_TASKS_TRIGGER_TASKS_TRIGGER_Pos = 0x0
	// Bit mask of TASKS_TRIGGER field.
	EGU_TASKS_TRIGGER_TASKS_TRIGGER_Msk = 0x1
	// Bit TASKS_TRIGGER.
	EGU_TASKS_TRIGGER_TASKS_TRIGGER = 0x1
	// Trigger task
	EGU_TASKS_TRIGGER_TASKS_TRIGGER_Trigger = 0x1

	// EVENTS_TRIGGERED: Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task
	// Position of EVENTS_TRIGGERED field.
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Pos = 0x0
	// Bit mask of EVENTS_TRIGGERED field.
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Msk = 0x1
	// Bit EVENTS_TRIGGERED.
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED = 0x1
	// Event not generated
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_NotGenerated = 0x0
	// Event generated
	EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Generated = 0x1

	// INTEN: Enable or disable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTEN_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTEN_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTEN_TRIGGERED0 = 0x1
	// Disable
	EGU_INTEN_TRIGGERED0_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED0_Enabled = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTEN_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTEN_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTEN_TRIGGERED1 = 0x2
	// Disable
	EGU_INTEN_TRIGGERED1_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED1_Enabled = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTEN_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTEN_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTEN_TRIGGERED2 = 0x4
	// Disable
	EGU_INTEN_TRIGGERED2_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED2_Enabled = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTEN_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTEN_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTEN_TRIGGERED3 = 0x8
	// Disable
	EGU_INTEN_TRIGGERED3_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED3_Enabled = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTEN_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTEN_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTEN_TRIGGERED4 = 0x10
	// Disable
	EGU_INTEN_TRIGGERED4_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED4_Enabled = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTEN_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTEN_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTEN_TRIGGERED5 = 0x20
	// Disable
	EGU_INTEN_TRIGGERED5_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED5_Enabled = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTEN_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTEN_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTEN_TRIGGERED6 = 0x40
	// Disable
	EGU_INTEN_TRIGGERED6_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED6_Enabled = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTEN_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTEN_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTEN_TRIGGERED7 = 0x80
	// Disable
	EGU_INTEN_TRIGGERED7_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED7_Enabled = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTEN_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTEN_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTEN_TRIGGERED8 = 0x100
	// Disable
	EGU_INTEN_TRIGGERED8_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED8_Enabled = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTEN_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTEN_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTEN_TRIGGERED9 = 0x200
	// Disable
	EGU_INTEN_TRIGGERED9_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED9_Enabled = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTEN_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTEN_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTEN_TRIGGERED10 = 0x400
	// Disable
	EGU_INTEN_TRIGGERED10_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED10_Enabled = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTEN_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTEN_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTEN_TRIGGERED11 = 0x800
	// Disable
	EGU_INTEN_TRIGGERED11_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED11_Enabled = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTEN_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTEN_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTEN_TRIGGERED12 = 0x1000
	// Disable
	EGU_INTEN_TRIGGERED12_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED12_Enabled = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTEN_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTEN_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTEN_TRIGGERED13 = 0x2000
	// Disable
	EGU_INTEN_TRIGGERED13_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED13_Enabled = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTEN_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTEN_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTEN_TRIGGERED14 = 0x4000
	// Disable
	EGU_INTEN_TRIGGERED14_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED14_Enabled = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTEN_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTEN_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTEN_TRIGGERED15 = 0x8000
	// Disable
	EGU_INTEN_TRIGGERED15_Disabled = 0x0
	// Enable
	EGU_INTEN_TRIGGERED15_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTENSET_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTENSET_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTENSET_TRIGGERED0 = 0x1
	// Read: Disabled
	EGU_INTENSET_TRIGGERED0_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED0_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED0_Set = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTENSET_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTENSET_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTENSET_TRIGGERED1 = 0x2
	// Read: Disabled
	EGU_INTENSET_TRIGGERED1_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED1_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED1_Set = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTENSET_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTENSET_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTENSET_TRIGGERED2 = 0x4
	// Read: Disabled
	EGU_INTENSET_TRIGGERED2_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED2_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED2_Set = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTENSET_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTENSET_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTENSET_TRIGGERED3 = 0x8
	// Read: Disabled
	EGU_INTENSET_TRIGGERED3_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED3_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED3_Set = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTENSET_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTENSET_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTENSET_TRIGGERED4 = 0x10
	// Read: Disabled
	EGU_INTENSET_TRIGGERED4_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED4_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED4_Set = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTENSET_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTENSET_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTENSET_TRIGGERED5 = 0x20
	// Read: Disabled
	EGU_INTENSET_TRIGGERED5_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED5_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED5_Set = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTENSET_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTENSET_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTENSET_TRIGGERED6 = 0x40
	// Read: Disabled
	EGU_INTENSET_TRIGGERED6_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED6_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED6_Set = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTENSET_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTENSET_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTENSET_TRIGGERED7 = 0x80
	// Read: Disabled
	EGU_INTENSET_TRIGGERED7_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED7_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED7_Set = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTENSET_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTENSET_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTENSET_TRIGGERED8 = 0x100
	// Read: Disabled
	EGU_INTENSET_TRIGGERED8_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED8_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED8_Set = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTENSET_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTENSET_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTENSET_TRIGGERED9 = 0x200
	// Read: Disabled
	EGU_INTENSET_TRIGGERED9_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED9_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED9_Set = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTENSET_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTENSET_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTENSET_TRIGGERED10 = 0x400
	// Read: Disabled
	EGU_INTENSET_TRIGGERED10_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED10_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED10_Set = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTENSET_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTENSET_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTENSET_TRIGGERED11 = 0x800
	// Read: Disabled
	EGU_INTENSET_TRIGGERED11_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED11_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED11_Set = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTENSET_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTENSET_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTENSET_TRIGGERED12 = 0x1000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED12_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED12_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED12_Set = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTENSET_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTENSET_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTENSET_TRIGGERED13 = 0x2000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED13_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED13_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED13_Set = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTENSET_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTENSET_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTENSET_TRIGGERED14 = 0x4000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED14_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED14_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED14_Set = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTENSET_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTENSET_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTENSET_TRIGGERED15 = 0x8000
	// Read: Disabled
	EGU_INTENSET_TRIGGERED15_Disabled = 0x0
	// Read: Enabled
	EGU_INTENSET_TRIGGERED15_Enabled = 0x1
	// Enable
	EGU_INTENSET_TRIGGERED15_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of TRIGGERED0 field.
	EGU_INTENCLR_TRIGGERED0_Pos = 0x0
	// Bit mask of TRIGGERED0 field.
	EGU_INTENCLR_TRIGGERED0_Msk = 0x1
	// Bit TRIGGERED0.
	EGU_INTENCLR_TRIGGERED0 = 0x1
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED0_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED0_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED0_Clear = 0x1
	// Position of TRIGGERED1 field.
	EGU_INTENCLR_TRIGGERED1_Pos = 0x1
	// Bit mask of TRIGGERED1 field.
	EGU_INTENCLR_TRIGGERED1_Msk = 0x2
	// Bit TRIGGERED1.
	EGU_INTENCLR_TRIGGERED1 = 0x2
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED1_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED1_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED1_Clear = 0x1
	// Position of TRIGGERED2 field.
	EGU_INTENCLR_TRIGGERED2_Pos = 0x2
	// Bit mask of TRIGGERED2 field.
	EGU_INTENCLR_TRIGGERED2_Msk = 0x4
	// Bit TRIGGERED2.
	EGU_INTENCLR_TRIGGERED2 = 0x4
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED2_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED2_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED2_Clear = 0x1
	// Position of TRIGGERED3 field.
	EGU_INTENCLR_TRIGGERED3_Pos = 0x3
	// Bit mask of TRIGGERED3 field.
	EGU_INTENCLR_TRIGGERED3_Msk = 0x8
	// Bit TRIGGERED3.
	EGU_INTENCLR_TRIGGERED3 = 0x8
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED3_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED3_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED3_Clear = 0x1
	// Position of TRIGGERED4 field.
	EGU_INTENCLR_TRIGGERED4_Pos = 0x4
	// Bit mask of TRIGGERED4 field.
	EGU_INTENCLR_TRIGGERED4_Msk = 0x10
	// Bit TRIGGERED4.
	EGU_INTENCLR_TRIGGERED4 = 0x10
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED4_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED4_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED4_Clear = 0x1
	// Position of TRIGGERED5 field.
	EGU_INTENCLR_TRIGGERED5_Pos = 0x5
	// Bit mask of TRIGGERED5 field.
	EGU_INTENCLR_TRIGGERED5_Msk = 0x20
	// Bit TRIGGERED5.
	EGU_INTENCLR_TRIGGERED5 = 0x20
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED5_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED5_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED5_Clear = 0x1
	// Position of TRIGGERED6 field.
	EGU_INTENCLR_TRIGGERED6_Pos = 0x6
	// Bit mask of TRIGGERED6 field.
	EGU_INTENCLR_TRIGGERED6_Msk = 0x40
	// Bit TRIGGERED6.
	EGU_INTENCLR_TRIGGERED6 = 0x40
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED6_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED6_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED6_Clear = 0x1
	// Position of TRIGGERED7 field.
	EGU_INTENCLR_TRIGGERED7_Pos = 0x7
	// Bit mask of TRIGGERED7 field.
	EGU_INTENCLR_TRIGGERED7_Msk = 0x80
	// Bit TRIGGERED7.
	EGU_INTENCLR_TRIGGERED7 = 0x80
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED7_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED7_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED7_Clear = 0x1
	// Position of TRIGGERED8 field.
	EGU_INTENCLR_TRIGGERED8_Pos = 0x8
	// Bit mask of TRIGGERED8 field.
	EGU_INTENCLR_TRIGGERED8_Msk = 0x100
	// Bit TRIGGERED8.
	EGU_INTENCLR_TRIGGERED8 = 0x100
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED8_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED8_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED8_Clear = 0x1
	// Position of TRIGGERED9 field.
	EGU_INTENCLR_TRIGGERED9_Pos = 0x9
	// Bit mask of TRIGGERED9 field.
	EGU_INTENCLR_TRIGGERED9_Msk = 0x200
	// Bit TRIGGERED9.
	EGU_INTENCLR_TRIGGERED9 = 0x200
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED9_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED9_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED9_Clear = 0x1
	// Position of TRIGGERED10 field.
	EGU_INTENCLR_TRIGGERED10_Pos = 0xa
	// Bit mask of TRIGGERED10 field.
	EGU_INTENCLR_TRIGGERED10_Msk = 0x400
	// Bit TRIGGERED10.
	EGU_INTENCLR_TRIGGERED10 = 0x400
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED10_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED10_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED10_Clear = 0x1
	// Position of TRIGGERED11 field.
	EGU_INTENCLR_TRIGGERED11_Pos = 0xb
	// Bit mask of TRIGGERED11 field.
	EGU_INTENCLR_TRIGGERED11_Msk = 0x800
	// Bit TRIGGERED11.
	EGU_INTENCLR_TRIGGERED11 = 0x800
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED11_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED11_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED11_Clear = 0x1
	// Position of TRIGGERED12 field.
	EGU_INTENCLR_TRIGGERED12_Pos = 0xc
	// Bit mask of TRIGGERED12 field.
	EGU_INTENCLR_TRIGGERED12_Msk = 0x1000
	// Bit TRIGGERED12.
	EGU_INTENCLR_TRIGGERED12 = 0x1000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED12_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED12_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED12_Clear = 0x1
	// Position of TRIGGERED13 field.
	EGU_INTENCLR_TRIGGERED13_Pos = 0xd
	// Bit mask of TRIGGERED13 field.
	EGU_INTENCLR_TRIGGERED13_Msk = 0x2000
	// Bit TRIGGERED13.
	EGU_INTENCLR_TRIGGERED13 = 0x2000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED13_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED13_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED13_Clear = 0x1
	// Position of TRIGGERED14 field.
	EGU_INTENCLR_TRIGGERED14_Pos = 0xe
	// Bit mask of TRIGGERED14 field.
	EGU_INTENCLR_TRIGGERED14_Msk = 0x4000
	// Bit TRIGGERED14.
	EGU_INTENCLR_TRIGGERED14 = 0x4000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED14_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED14_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED14_Clear = 0x1
	// Position of TRIGGERED15 field.
	EGU_INTENCLR_TRIGGERED15_Pos = 0xf
	// Bit mask of TRIGGERED15 field.
	EGU_INTENCLR_TRIGGERED15_Msk = 0x8000
	// Bit TRIGGERED15.
	EGU_INTENCLR_TRIGGERED15 = 0x8000
	// Read: Disabled
	EGU_INTENCLR_TRIGGERED15_Disabled = 0x0
	// Read: Enabled
	EGU_INTENCLR_TRIGGERED15_Enabled = 0x1
	// Disable
	EGU_INTENCLR_TRIGGERED15_Clear = 0x1
)

// Constants for SWI0: Software interrupt 0
const ()

// Constants for ACL: Access control lists
const (
	// ACL.ADDR: Description cluster: Start address of region to protect. The start address must be word-aligned.
	// Position of ADDR field.
	ACL_ACL_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ACL_ACL_ADDR_ADDR_Msk = 0xffffffff

	// ACL.SIZE: Description cluster: Size of region to protect counting from address ACL[n].ADDR. Write '0' as no effect.
	// Position of SIZE field.
	ACL_ACL_SIZE_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	ACL_ACL_SIZE_SIZE_Msk = 0xffffffff

	// ACL.PERM: Description cluster: Access permissions for region n as defined by start address ACL[n].ADDR and size ACL[n].SIZE
	// Position of WRITE field.
	ACL_ACL_PERM_WRITE_Pos = 0x1
	// Bit mask of WRITE field.
	ACL_ACL_PERM_WRITE_Msk = 0x2
	// Bit WRITE.
	ACL_ACL_PERM_WRITE = 0x2
	// Allow write and erase instructions to region n
	ACL_ACL_PERM_WRITE_Enable = 0x0
	// Block write and erase instructions to region n
	ACL_ACL_PERM_WRITE_Disable = 0x1
	// Position of READ field.
	ACL_ACL_PERM_READ_Pos = 0x2
	// Bit mask of READ field.
	ACL_ACL_PERM_READ_Msk = 0x4
	// Bit READ.
	ACL_ACL_PERM_READ = 0x4
	// Allow read instructions to region n
	ACL_ACL_PERM_READ_Enable = 0x0
	// Block read instructions to region n
	ACL_ACL_PERM_READ_Disable = 0x1
)

// Constants for NVMC: Non Volatile Memory Controller
const (
	// READY: Ready flag
	// Position of READY field.
	NVMC_READY_READY_Pos = 0x0
	// Bit mask of READY field.
	NVMC_READY_READY_Msk = 0x1
	// Bit READY.
	NVMC_READY_READY = 0x1
	// NVMC is busy (on-going write or erase operation)
	NVMC_READY_READY_Busy = 0x0
	// NVMC is ready
	NVMC_READY_READY_Ready = 0x1

	// READYNEXT: Ready flag
	// Position of READYNEXT field.
	NVMC_READYNEXT_READYNEXT_Pos = 0x0
	// Bit mask of READYNEXT field.
	NVMC_READYNEXT_READYNEXT_Msk = 0x1
	// Bit READYNEXT.
	NVMC_READYNEXT_READYNEXT = 0x1
	// NVMC cannot accept any write operation
	NVMC_READYNEXT_READYNEXT_Busy = 0x0
	// NVMC is ready
	NVMC_READYNEXT_READYNEXT_Ready = 0x1

	// CONFIG: Configuration register
	// Position of WEN field.
	NVMC_CONFIG_WEN_Pos = 0x0
	// Bit mask of WEN field.
	NVMC_CONFIG_WEN_Msk = 0x3
	// Read only access
	NVMC_CONFIG_WEN_Ren = 0x0
	// Write enabled
	NVMC_CONFIG_WEN_Wen = 0x1
	// Erase enabled
	NVMC_CONFIG_WEN_Een = 0x2

	// ERASEPAGE: Register for erasing a page in code area
	// Position of ERASEPAGE field.
	NVMC_ERASEPAGE_ERASEPAGE_Pos = 0x0
	// Bit mask of ERASEPAGE field.
	NVMC_ERASEPAGE_ERASEPAGE_Msk = 0xffffffff

	// ERASEPCR1: Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE
	// Position of ERASEPCR1 field.
	NVMC_ERASEPCR1_ERASEPCR1_Pos = 0x0
	// Bit mask of ERASEPCR1 field.
	NVMC_ERASEPCR1_ERASEPCR1_Msk = 0xffffffff

	// ERASEALL: Register for erasing all non-volatile user memory
	// Position of ERASEALL field.
	NVMC_ERASEALL_ERASEALL_Pos = 0x0
	// Bit mask of ERASEALL field.
	NVMC_ERASEALL_ERASEALL_Msk = 0x1
	// Bit ERASEALL.
	NVMC_ERASEALL_ERASEALL = 0x1
	// No operation
	NVMC_ERASEALL_ERASEALL_NoOperation = 0x0
	// Start chip erase
	NVMC_ERASEALL_ERASEALL_Erase = 0x1

	// ERASEPCR0: Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE
	// Position of ERASEPCR0 field.
	NVMC_ERASEPCR0_ERASEPCR0_Pos = 0x0
	// Bit mask of ERASEPCR0 field.
	NVMC_ERASEPCR0_ERASEPCR0_Msk = 0xffffffff

	// ERASEUICR: Register for erasing user information configuration registers
	// Position of ERASEUICR field.
	NVMC_ERASEUICR_ERASEUICR_Pos = 0x0
	// Bit mask of ERASEUICR field.
	NVMC_ERASEUICR_ERASEUICR_Msk = 0x1
	// Bit ERASEUICR.
	NVMC_ERASEUICR_ERASEUICR = 0x1
	// No operation
	NVMC_ERASEUICR_ERASEUICR_NoOperation = 0x0
	// Start erase of UICR
	NVMC_ERASEUICR_ERASEUICR_Erase = 0x1

	// ERASEPAGEPARTIAL: Register for partial erase of a page in code area
	// Position of ERASEPAGEPARTIAL field.
	NVMC_ERASEPAGEPARTIAL_ERASEPAGEPARTIAL_Pos = 0x0
	// Bit mask of ERASEPAGEPARTIAL field.
	NVMC_ERASEPAGEPARTIAL_ERASEPAGEPARTIAL_Msk = 0xffffffff

	// ERASEPAGEPARTIALCFG: Register for partial erase configuration
	// Position of DURATION field.
	NVMC_ERASEPAGEPARTIALCFG_DURATION_Pos = 0x0
	// Bit mask of DURATION field.
	NVMC_ERASEPAGEPARTIALCFG_DURATION_Msk = 0x7f
)

// Constants for PPI: Programmable Peripheral Interconnect
const (
	// TASKS_CHG.EN: Description cluster: Enable channel group n
	// Position of EN field.
	PPI_TASKS_CHG_EN_EN_Pos = 0x0
	// Bit mask of EN field.
	PPI_TASKS_CHG_EN_EN_Msk = 0x1
	// Bit EN.
	PPI_TASKS_CHG_EN_EN = 0x1
	// Trigger task
	PPI_TASKS_CHG_EN_EN_Trigger = 0x1

	// TASKS_CHG.DIS: Description cluster: Disable channel group n
	// Position of DIS field.
	PPI_TASKS_CHG_DIS_DIS_Pos = 0x0
	// Bit mask of DIS field.
	PPI_TASKS_CHG_DIS_DIS_Msk = 0x1
	// Bit DIS.
	PPI_TASKS_CHG_DIS_DIS = 0x1
	// Trigger task
	PPI_TASKS_CHG_DIS_DIS_Trigger = 0x1

	// CHEN: Channel enable register
	// Position of CH0 field.
	PPI_CHEN_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHEN_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHEN_CH0 = 0x1
	// Disable channel
	PPI_CHEN_CH0_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH0_Enabled = 0x1
	// Position of CH1 field.
	PPI_CHEN_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHEN_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHEN_CH1 = 0x2
	// Disable channel
	PPI_CHEN_CH1_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH1_Enabled = 0x1
	// Position of CH2 field.
	PPI_CHEN_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHEN_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHEN_CH2 = 0x4
	// Disable channel
	PPI_CHEN_CH2_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH2_Enabled = 0x1
	// Position of CH3 field.
	PPI_CHEN_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHEN_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHEN_CH3 = 0x8
	// Disable channel
	PPI_CHEN_CH3_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH3_Enabled = 0x1
	// Position of CH4 field.
	PPI_CHEN_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHEN_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHEN_CH4 = 0x10
	// Disable channel
	PPI_CHEN_CH4_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH4_Enabled = 0x1
	// Position of CH5 field.
	PPI_CHEN_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHEN_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHEN_CH5 = 0x20
	// Disable channel
	PPI_CHEN_CH5_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH5_Enabled = 0x1
	// Position of CH6 field.
	PPI_CHEN_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHEN_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHEN_CH6 = 0x40
	// Disable channel
	PPI_CHEN_CH6_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH6_Enabled = 0x1
	// Position of CH7 field.
	PPI_CHEN_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHEN_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHEN_CH7 = 0x80
	// Disable channel
	PPI_CHEN_CH7_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH7_Enabled = 0x1
	// Position of CH8 field.
	PPI_CHEN_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHEN_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHEN_CH8 = 0x100
	// Disable channel
	PPI_CHEN_CH8_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH8_Enabled = 0x1
	// Position of CH9 field.
	PPI_CHEN_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHEN_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHEN_CH9 = 0x200
	// Disable channel
	PPI_CHEN_CH9_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH9_Enabled = 0x1
	// Position of CH10 field.
	PPI_CHEN_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHEN_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHEN_CH10 = 0x400
	// Disable channel
	PPI_CHEN_CH10_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH10_Enabled = 0x1
	// Position of CH11 field.
	PPI_CHEN_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHEN_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHEN_CH11 = 0x800
	// Disable channel
	PPI_CHEN_CH11_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH11_Enabled = 0x1
	// Position of CH12 field.
	PPI_CHEN_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHEN_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHEN_CH12 = 0x1000
	// Disable channel
	PPI_CHEN_CH12_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH12_Enabled = 0x1
	// Position of CH13 field.
	PPI_CHEN_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHEN_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHEN_CH13 = 0x2000
	// Disable channel
	PPI_CHEN_CH13_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH13_Enabled = 0x1
	// Position of CH14 field.
	PPI_CHEN_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHEN_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHEN_CH14 = 0x4000
	// Disable channel
	PPI_CHEN_CH14_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH14_Enabled = 0x1
	// Position of CH15 field.
	PPI_CHEN_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHEN_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHEN_CH15 = 0x8000
	// Disable channel
	PPI_CHEN_CH15_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH15_Enabled = 0x1
	// Position of CH16 field.
	PPI_CHEN_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHEN_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHEN_CH16 = 0x10000
	// Disable channel
	PPI_CHEN_CH16_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH16_Enabled = 0x1
	// Position of CH17 field.
	PPI_CHEN_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHEN_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHEN_CH17 = 0x20000
	// Disable channel
	PPI_CHEN_CH17_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH17_Enabled = 0x1
	// Position of CH18 field.
	PPI_CHEN_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHEN_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHEN_CH18 = 0x40000
	// Disable channel
	PPI_CHEN_CH18_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH18_Enabled = 0x1
	// Position of CH19 field.
	PPI_CHEN_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHEN_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHEN_CH19 = 0x80000
	// Disable channel
	PPI_CHEN_CH19_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH19_Enabled = 0x1
	// Position of CH20 field.
	PPI_CHEN_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHEN_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHEN_CH20 = 0x100000
	// Disable channel
	PPI_CHEN_CH20_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH20_Enabled = 0x1
	// Position of CH21 field.
	PPI_CHEN_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHEN_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHEN_CH21 = 0x200000
	// Disable channel
	PPI_CHEN_CH21_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH21_Enabled = 0x1
	// Position of CH22 field.
	PPI_CHEN_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHEN_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHEN_CH22 = 0x400000
	// Disable channel
	PPI_CHEN_CH22_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH22_Enabled = 0x1
	// Position of CH23 field.
	PPI_CHEN_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHEN_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHEN_CH23 = 0x800000
	// Disable channel
	PPI_CHEN_CH23_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH23_Enabled = 0x1
	// Position of CH24 field.
	PPI_CHEN_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHEN_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHEN_CH24 = 0x1000000
	// Disable channel
	PPI_CHEN_CH24_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH24_Enabled = 0x1
	// Position of CH25 field.
	PPI_CHEN_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHEN_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHEN_CH25 = 0x2000000
	// Disable channel
	PPI_CHEN_CH25_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH25_Enabled = 0x1
	// Position of CH26 field.
	PPI_CHEN_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHEN_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHEN_CH26 = 0x4000000
	// Disable channel
	PPI_CHEN_CH26_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH26_Enabled = 0x1
	// Position of CH27 field.
	PPI_CHEN_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHEN_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHEN_CH27 = 0x8000000
	// Disable channel
	PPI_CHEN_CH27_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH27_Enabled = 0x1
	// Position of CH28 field.
	PPI_CHEN_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHEN_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHEN_CH28 = 0x10000000
	// Disable channel
	PPI_CHEN_CH28_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH28_Enabled = 0x1
	// Position of CH29 field.
	PPI_CHEN_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHEN_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHEN_CH29 = 0x20000000
	// Disable channel
	PPI_CHEN_CH29_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH29_Enabled = 0x1
	// Position of CH30 field.
	PPI_CHEN_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHEN_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHEN_CH30 = 0x40000000
	// Disable channel
	PPI_CHEN_CH30_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH30_Enabled = 0x1
	// Position of CH31 field.
	PPI_CHEN_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHEN_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHEN_CH31 = 0x80000000
	// Disable channel
	PPI_CHEN_CH31_Disabled = 0x0
	// Enable channel
	PPI_CHEN_CH31_Enabled = 0x1

	// CHENSET: Channel enable set register
	// Position of CH0 field.
	PPI_CHENSET_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHENSET_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHENSET_CH0 = 0x1
	// Read: channel disabled
	PPI_CHENSET_CH0_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH0_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH0_Set = 0x1
	// Position of CH1 field.
	PPI_CHENSET_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHENSET_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHENSET_CH1 = 0x2
	// Read: channel disabled
	PPI_CHENSET_CH1_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH1_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH1_Set = 0x1
	// Position of CH2 field.
	PPI_CHENSET_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHENSET_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHENSET_CH2 = 0x4
	// Read: channel disabled
	PPI_CHENSET_CH2_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH2_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH2_Set = 0x1
	// Position of CH3 field.
	PPI_CHENSET_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHENSET_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHENSET_CH3 = 0x8
	// Read: channel disabled
	PPI_CHENSET_CH3_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH3_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH3_Set = 0x1
	// Position of CH4 field.
	PPI_CHENSET_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHENSET_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHENSET_CH4 = 0x10
	// Read: channel disabled
	PPI_CHENSET_CH4_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH4_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH4_Set = 0x1
	// Position of CH5 field.
	PPI_CHENSET_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHENSET_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHENSET_CH5 = 0x20
	// Read: channel disabled
	PPI_CHENSET_CH5_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH5_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH5_Set = 0x1
	// Position of CH6 field.
	PPI_CHENSET_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHENSET_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHENSET_CH6 = 0x40
	// Read: channel disabled
	PPI_CHENSET_CH6_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH6_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH6_Set = 0x1
	// Position of CH7 field.
	PPI_CHENSET_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHENSET_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHENSET_CH7 = 0x80
	// Read: channel disabled
	PPI_CHENSET_CH7_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH7_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH7_Set = 0x1
	// Position of CH8 field.
	PPI_CHENSET_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHENSET_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHENSET_CH8 = 0x100
	// Read: channel disabled
	PPI_CHENSET_CH8_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH8_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH8_Set = 0x1
	// Position of CH9 field.
	PPI_CHENSET_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHENSET_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHENSET_CH9 = 0x200
	// Read: channel disabled
	PPI_CHENSET_CH9_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH9_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH9_Set = 0x1
	// Position of CH10 field.
	PPI_CHENSET_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHENSET_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHENSET_CH10 = 0x400
	// Read: channel disabled
	PPI_CHENSET_CH10_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH10_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH10_Set = 0x1
	// Position of CH11 field.
	PPI_CHENSET_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHENSET_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHENSET_CH11 = 0x800
	// Read: channel disabled
	PPI_CHENSET_CH11_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH11_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH11_Set = 0x1
	// Position of CH12 field.
	PPI_CHENSET_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHENSET_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHENSET_CH12 = 0x1000
	// Read: channel disabled
	PPI_CHENSET_CH12_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH12_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH12_Set = 0x1
	// Position of CH13 field.
	PPI_CHENSET_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHENSET_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHENSET_CH13 = 0x2000
	// Read: channel disabled
	PPI_CHENSET_CH13_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH13_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH13_Set = 0x1
	// Position of CH14 field.
	PPI_CHENSET_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHENSET_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHENSET_CH14 = 0x4000
	// Read: channel disabled
	PPI_CHENSET_CH14_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH14_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH14_Set = 0x1
	// Position of CH15 field.
	PPI_CHENSET_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHENSET_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHENSET_CH15 = 0x8000
	// Read: channel disabled
	PPI_CHENSET_CH15_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH15_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH15_Set = 0x1
	// Position of CH16 field.
	PPI_CHENSET_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHENSET_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHENSET_CH16 = 0x10000
	// Read: channel disabled
	PPI_CHENSET_CH16_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH16_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH16_Set = 0x1
	// Position of CH17 field.
	PPI_CHENSET_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHENSET_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHENSET_CH17 = 0x20000
	// Read: channel disabled
	PPI_CHENSET_CH17_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH17_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH17_Set = 0x1
	// Position of CH18 field.
	PPI_CHENSET_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHENSET_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHENSET_CH18 = 0x40000
	// Read: channel disabled
	PPI_CHENSET_CH18_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH18_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH18_Set = 0x1
	// Position of CH19 field.
	PPI_CHENSET_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHENSET_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHENSET_CH19 = 0x80000
	// Read: channel disabled
	PPI_CHENSET_CH19_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH19_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH19_Set = 0x1
	// Position of CH20 field.
	PPI_CHENSET_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHENSET_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHENSET_CH20 = 0x100000
	// Read: channel disabled
	PPI_CHENSET_CH20_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH20_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH20_Set = 0x1
	// Position of CH21 field.
	PPI_CHENSET_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHENSET_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHENSET_CH21 = 0x200000
	// Read: channel disabled
	PPI_CHENSET_CH21_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH21_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH21_Set = 0x1
	// Position of CH22 field.
	PPI_CHENSET_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHENSET_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHENSET_CH22 = 0x400000
	// Read: channel disabled
	PPI_CHENSET_CH22_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH22_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH22_Set = 0x1
	// Position of CH23 field.
	PPI_CHENSET_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHENSET_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHENSET_CH23 = 0x800000
	// Read: channel disabled
	PPI_CHENSET_CH23_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH23_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH23_Set = 0x1
	// Position of CH24 field.
	PPI_CHENSET_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHENSET_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHENSET_CH24 = 0x1000000
	// Read: channel disabled
	PPI_CHENSET_CH24_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH24_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH24_Set = 0x1
	// Position of CH25 field.
	PPI_CHENSET_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHENSET_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHENSET_CH25 = 0x2000000
	// Read: channel disabled
	PPI_CHENSET_CH25_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH25_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH25_Set = 0x1
	// Position of CH26 field.
	PPI_CHENSET_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHENSET_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHENSET_CH26 = 0x4000000
	// Read: channel disabled
	PPI_CHENSET_CH26_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH26_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH26_Set = 0x1
	// Position of CH27 field.
	PPI_CHENSET_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHENSET_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHENSET_CH27 = 0x8000000
	// Read: channel disabled
	PPI_CHENSET_CH27_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH27_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH27_Set = 0x1
	// Position of CH28 field.
	PPI_CHENSET_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHENSET_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHENSET_CH28 = 0x10000000
	// Read: channel disabled
	PPI_CHENSET_CH28_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH28_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH28_Set = 0x1
	// Position of CH29 field.
	PPI_CHENSET_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHENSET_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHENSET_CH29 = 0x20000000
	// Read: channel disabled
	PPI_CHENSET_CH29_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH29_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH29_Set = 0x1
	// Position of CH30 field.
	PPI_CHENSET_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHENSET_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHENSET_CH30 = 0x40000000
	// Read: channel disabled
	PPI_CHENSET_CH30_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH30_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH30_Set = 0x1
	// Position of CH31 field.
	PPI_CHENSET_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHENSET_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHENSET_CH31 = 0x80000000
	// Read: channel disabled
	PPI_CHENSET_CH31_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENSET_CH31_Enabled = 0x1
	// Write: Enable channel
	PPI_CHENSET_CH31_Set = 0x1

	// CHENCLR: Channel enable clear register
	// Position of CH0 field.
	PPI_CHENCLR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHENCLR_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHENCLR_CH0 = 0x1
	// Read: channel disabled
	PPI_CHENCLR_CH0_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH0_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH0_Clear = 0x1
	// Position of CH1 field.
	PPI_CHENCLR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHENCLR_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHENCLR_CH1 = 0x2
	// Read: channel disabled
	PPI_CHENCLR_CH1_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH1_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH1_Clear = 0x1
	// Position of CH2 field.
	PPI_CHENCLR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHENCLR_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHENCLR_CH2 = 0x4
	// Read: channel disabled
	PPI_CHENCLR_CH2_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH2_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH2_Clear = 0x1
	// Position of CH3 field.
	PPI_CHENCLR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHENCLR_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHENCLR_CH3 = 0x8
	// Read: channel disabled
	PPI_CHENCLR_CH3_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH3_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH3_Clear = 0x1
	// Position of CH4 field.
	PPI_CHENCLR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHENCLR_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHENCLR_CH4 = 0x10
	// Read: channel disabled
	PPI_CHENCLR_CH4_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH4_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH4_Clear = 0x1
	// Position of CH5 field.
	PPI_CHENCLR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHENCLR_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHENCLR_CH5 = 0x20
	// Read: channel disabled
	PPI_CHENCLR_CH5_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH5_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH5_Clear = 0x1
	// Position of CH6 field.
	PPI_CHENCLR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHENCLR_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHENCLR_CH6 = 0x40
	// Read: channel disabled
	PPI_CHENCLR_CH6_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH6_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH6_Clear = 0x1
	// Position of CH7 field.
	PPI_CHENCLR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHENCLR_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHENCLR_CH7 = 0x80
	// Read: channel disabled
	PPI_CHENCLR_CH7_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH7_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH7_Clear = 0x1
	// Position of CH8 field.
	PPI_CHENCLR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHENCLR_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHENCLR_CH8 = 0x100
	// Read: channel disabled
	PPI_CHENCLR_CH8_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH8_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH8_Clear = 0x1
	// Position of CH9 field.
	PPI_CHENCLR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHENCLR_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHENCLR_CH9 = 0x200
	// Read: channel disabled
	PPI_CHENCLR_CH9_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH9_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH9_Clear = 0x1
	// Position of CH10 field.
	PPI_CHENCLR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHENCLR_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHENCLR_CH10 = 0x400
	// Read: channel disabled
	PPI_CHENCLR_CH10_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH10_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH10_Clear = 0x1
	// Position of CH11 field.
	PPI_CHENCLR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHENCLR_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHENCLR_CH11 = 0x800
	// Read: channel disabled
	PPI_CHENCLR_CH11_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH11_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH11_Clear = 0x1
	// Position of CH12 field.
	PPI_CHENCLR_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHENCLR_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHENCLR_CH12 = 0x1000
	// Read: channel disabled
	PPI_CHENCLR_CH12_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH12_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH12_Clear = 0x1
	// Position of CH13 field.
	PPI_CHENCLR_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHENCLR_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHENCLR_CH13 = 0x2000
	// Read: channel disabled
	PPI_CHENCLR_CH13_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH13_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH13_Clear = 0x1
	// Position of CH14 field.
	PPI_CHENCLR_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHENCLR_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHENCLR_CH14 = 0x4000
	// Read: channel disabled
	PPI_CHENCLR_CH14_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH14_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH14_Clear = 0x1
	// Position of CH15 field.
	PPI_CHENCLR_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHENCLR_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHENCLR_CH15 = 0x8000
	// Read: channel disabled
	PPI_CHENCLR_CH15_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH15_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH15_Clear = 0x1
	// Position of CH16 field.
	PPI_CHENCLR_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHENCLR_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHENCLR_CH16 = 0x10000
	// Read: channel disabled
	PPI_CHENCLR_CH16_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH16_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH16_Clear = 0x1
	// Position of CH17 field.
	PPI_CHENCLR_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHENCLR_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHENCLR_CH17 = 0x20000
	// Read: channel disabled
	PPI_CHENCLR_CH17_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH17_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH17_Clear = 0x1
	// Position of CH18 field.
	PPI_CHENCLR_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHENCLR_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHENCLR_CH18 = 0x40000
	// Read: channel disabled
	PPI_CHENCLR_CH18_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH18_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH18_Clear = 0x1
	// Position of CH19 field.
	PPI_CHENCLR_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHENCLR_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHENCLR_CH19 = 0x80000
	// Read: channel disabled
	PPI_CHENCLR_CH19_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH19_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH19_Clear = 0x1
	// Position of CH20 field.
	PPI_CHENCLR_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHENCLR_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHENCLR_CH20 = 0x100000
	// Read: channel disabled
	PPI_CHENCLR_CH20_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH20_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH20_Clear = 0x1
	// Position of CH21 field.
	PPI_CHENCLR_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHENCLR_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHENCLR_CH21 = 0x200000
	// Read: channel disabled
	PPI_CHENCLR_CH21_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH21_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH21_Clear = 0x1
	// Position of CH22 field.
	PPI_CHENCLR_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHENCLR_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHENCLR_CH22 = 0x400000
	// Read: channel disabled
	PPI_CHENCLR_CH22_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH22_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH22_Clear = 0x1
	// Position of CH23 field.
	PPI_CHENCLR_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHENCLR_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHENCLR_CH23 = 0x800000
	// Read: channel disabled
	PPI_CHENCLR_CH23_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH23_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH23_Clear = 0x1
	// Position of CH24 field.
	PPI_CHENCLR_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHENCLR_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHENCLR_CH24 = 0x1000000
	// Read: channel disabled
	PPI_CHENCLR_CH24_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH24_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH24_Clear = 0x1
	// Position of CH25 field.
	PPI_CHENCLR_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHENCLR_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHENCLR_CH25 = 0x2000000
	// Read: channel disabled
	PPI_CHENCLR_CH25_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH25_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH25_Clear = 0x1
	// Position of CH26 field.
	PPI_CHENCLR_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHENCLR_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHENCLR_CH26 = 0x4000000
	// Read: channel disabled
	PPI_CHENCLR_CH26_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH26_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH26_Clear = 0x1
	// Position of CH27 field.
	PPI_CHENCLR_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHENCLR_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHENCLR_CH27 = 0x8000000
	// Read: channel disabled
	PPI_CHENCLR_CH27_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH27_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH27_Clear = 0x1
	// Position of CH28 field.
	PPI_CHENCLR_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHENCLR_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHENCLR_CH28 = 0x10000000
	// Read: channel disabled
	PPI_CHENCLR_CH28_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH28_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH28_Clear = 0x1
	// Position of CH29 field.
	PPI_CHENCLR_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHENCLR_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHENCLR_CH29 = 0x20000000
	// Read: channel disabled
	PPI_CHENCLR_CH29_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH29_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH29_Clear = 0x1
	// Position of CH30 field.
	PPI_CHENCLR_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHENCLR_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHENCLR_CH30 = 0x40000000
	// Read: channel disabled
	PPI_CHENCLR_CH30_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH30_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH30_Clear = 0x1
	// Position of CH31 field.
	PPI_CHENCLR_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHENCLR_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHENCLR_CH31 = 0x80000000
	// Read: channel disabled
	PPI_CHENCLR_CH31_Disabled = 0x0
	// Read: channel enabled
	PPI_CHENCLR_CH31_Enabled = 0x1
	// Write: disable channel
	PPI_CHENCLR_CH31_Clear = 0x1

	// CH.EEP: Description cluster: Channel n event end-point
	// Position of EEP field.
	PPI_CH_EEP_EEP_Pos = 0x0
	// Bit mask of EEP field.
	PPI_CH_EEP_EEP_Msk = 0xffffffff

	// CH.TEP: Description cluster: Channel n task end-point
	// Position of TEP field.
	PPI_CH_TEP_TEP_Pos = 0x0
	// Bit mask of TEP field.
	PPI_CH_TEP_TEP_Msk = 0xffffffff

	// CHG: Description collection: Channel group n
	// Position of CH0 field.
	PPI_CHG_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PPI_CHG_CH0_Msk = 0x1
	// Bit CH0.
	PPI_CHG_CH0 = 0x1
	// Exclude
	PPI_CHG_CH0_Excluded = 0x0
	// Include
	PPI_CHG_CH0_Included = 0x1
	// Position of CH1 field.
	PPI_CHG_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PPI_CHG_CH1_Msk = 0x2
	// Bit CH1.
	PPI_CHG_CH1 = 0x2
	// Exclude
	PPI_CHG_CH1_Excluded = 0x0
	// Include
	PPI_CHG_CH1_Included = 0x1
	// Position of CH2 field.
	PPI_CHG_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PPI_CHG_CH2_Msk = 0x4
	// Bit CH2.
	PPI_CHG_CH2 = 0x4
	// Exclude
	PPI_CHG_CH2_Excluded = 0x0
	// Include
	PPI_CHG_CH2_Included = 0x1
	// Position of CH3 field.
	PPI_CHG_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PPI_CHG_CH3_Msk = 0x8
	// Bit CH3.
	PPI_CHG_CH3 = 0x8
	// Exclude
	PPI_CHG_CH3_Excluded = 0x0
	// Include
	PPI_CHG_CH3_Included = 0x1
	// Position of CH4 field.
	PPI_CHG_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PPI_CHG_CH4_Msk = 0x10
	// Bit CH4.
	PPI_CHG_CH4 = 0x10
	// Exclude
	PPI_CHG_CH4_Excluded = 0x0
	// Include
	PPI_CHG_CH4_Included = 0x1
	// Position of CH5 field.
	PPI_CHG_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PPI_CHG_CH5_Msk = 0x20
	// Bit CH5.
	PPI_CHG_CH5 = 0x20
	// Exclude
	PPI_CHG_CH5_Excluded = 0x0
	// Include
	PPI_CHG_CH5_Included = 0x1
	// Position of CH6 field.
	PPI_CHG_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PPI_CHG_CH6_Msk = 0x40
	// Bit CH6.
	PPI_CHG_CH6 = 0x40
	// Exclude
	PPI_CHG_CH6_Excluded = 0x0
	// Include
	PPI_CHG_CH6_Included = 0x1
	// Position of CH7 field.
	PPI_CHG_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PPI_CHG_CH7_Msk = 0x80
	// Bit CH7.
	PPI_CHG_CH7 = 0x80
	// Exclude
	PPI_CHG_CH7_Excluded = 0x0
	// Include
	PPI_CHG_CH7_Included = 0x1
	// Position of CH8 field.
	PPI_CHG_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	PPI_CHG_CH8_Msk = 0x100
	// Bit CH8.
	PPI_CHG_CH8 = 0x100
	// Exclude
	PPI_CHG_CH8_Excluded = 0x0
	// Include
	PPI_CHG_CH8_Included = 0x1
	// Position of CH9 field.
	PPI_CHG_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	PPI_CHG_CH9_Msk = 0x200
	// Bit CH9.
	PPI_CHG_CH9 = 0x200
	// Exclude
	PPI_CHG_CH9_Excluded = 0x0
	// Include
	PPI_CHG_CH9_Included = 0x1
	// Position of CH10 field.
	PPI_CHG_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	PPI_CHG_CH10_Msk = 0x400
	// Bit CH10.
	PPI_CHG_CH10 = 0x400
	// Exclude
	PPI_CHG_CH10_Excluded = 0x0
	// Include
	PPI_CHG_CH10_Included = 0x1
	// Position of CH11 field.
	PPI_CHG_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	PPI_CHG_CH11_Msk = 0x800
	// Bit CH11.
	PPI_CHG_CH11 = 0x800
	// Exclude
	PPI_CHG_CH11_Excluded = 0x0
	// Include
	PPI_CHG_CH11_Included = 0x1
	// Position of CH12 field.
	PPI_CHG_CH12_Pos = 0xc
	// Bit mask of CH12 field.
	PPI_CHG_CH12_Msk = 0x1000
	// Bit CH12.
	PPI_CHG_CH12 = 0x1000
	// Exclude
	PPI_CHG_CH12_Excluded = 0x0
	// Include
	PPI_CHG_CH12_Included = 0x1
	// Position of CH13 field.
	PPI_CHG_CH13_Pos = 0xd
	// Bit mask of CH13 field.
	PPI_CHG_CH13_Msk = 0x2000
	// Bit CH13.
	PPI_CHG_CH13 = 0x2000
	// Exclude
	PPI_CHG_CH13_Excluded = 0x0
	// Include
	PPI_CHG_CH13_Included = 0x1
	// Position of CH14 field.
	PPI_CHG_CH14_Pos = 0xe
	// Bit mask of CH14 field.
	PPI_CHG_CH14_Msk = 0x4000
	// Bit CH14.
	PPI_CHG_CH14 = 0x4000
	// Exclude
	PPI_CHG_CH14_Excluded = 0x0
	// Include
	PPI_CHG_CH14_Included = 0x1
	// Position of CH15 field.
	PPI_CHG_CH15_Pos = 0xf
	// Bit mask of CH15 field.
	PPI_CHG_CH15_Msk = 0x8000
	// Bit CH15.
	PPI_CHG_CH15 = 0x8000
	// Exclude
	PPI_CHG_CH15_Excluded = 0x0
	// Include
	PPI_CHG_CH15_Included = 0x1
	// Position of CH16 field.
	PPI_CHG_CH16_Pos = 0x10
	// Bit mask of CH16 field.
	PPI_CHG_CH16_Msk = 0x10000
	// Bit CH16.
	PPI_CHG_CH16 = 0x10000
	// Exclude
	PPI_CHG_CH16_Excluded = 0x0
	// Include
	PPI_CHG_CH16_Included = 0x1
	// Position of CH17 field.
	PPI_CHG_CH17_Pos = 0x11
	// Bit mask of CH17 field.
	PPI_CHG_CH17_Msk = 0x20000
	// Bit CH17.
	PPI_CHG_CH17 = 0x20000
	// Exclude
	PPI_CHG_CH17_Excluded = 0x0
	// Include
	PPI_CHG_CH17_Included = 0x1
	// Position of CH18 field.
	PPI_CHG_CH18_Pos = 0x12
	// Bit mask of CH18 field.
	PPI_CHG_CH18_Msk = 0x40000
	// Bit CH18.
	PPI_CHG_CH18 = 0x40000
	// Exclude
	PPI_CHG_CH18_Excluded = 0x0
	// Include
	PPI_CHG_CH18_Included = 0x1
	// Position of CH19 field.
	PPI_CHG_CH19_Pos = 0x13
	// Bit mask of CH19 field.
	PPI_CHG_CH19_Msk = 0x80000
	// Bit CH19.
	PPI_CHG_CH19 = 0x80000
	// Exclude
	PPI_CHG_CH19_Excluded = 0x0
	// Include
	PPI_CHG_CH19_Included = 0x1
	// Position of CH20 field.
	PPI_CHG_CH20_Pos = 0x14
	// Bit mask of CH20 field.
	PPI_CHG_CH20_Msk = 0x100000
	// Bit CH20.
	PPI_CHG_CH20 = 0x100000
	// Exclude
	PPI_CHG_CH20_Excluded = 0x0
	// Include
	PPI_CHG_CH20_Included = 0x1
	// Position of CH21 field.
	PPI_CHG_CH21_Pos = 0x15
	// Bit mask of CH21 field.
	PPI_CHG_CH21_Msk = 0x200000
	// Bit CH21.
	PPI_CHG_CH21 = 0x200000
	// Exclude
	PPI_CHG_CH21_Excluded = 0x0
	// Include
	PPI_CHG_CH21_Included = 0x1
	// Position of CH22 field.
	PPI_CHG_CH22_Pos = 0x16
	// Bit mask of CH22 field.
	PPI_CHG_CH22_Msk = 0x400000
	// Bit CH22.
	PPI_CHG_CH22 = 0x400000
	// Exclude
	PPI_CHG_CH22_Excluded = 0x0
	// Include
	PPI_CHG_CH22_Included = 0x1
	// Position of CH23 field.
	PPI_CHG_CH23_Pos = 0x17
	// Bit mask of CH23 field.
	PPI_CHG_CH23_Msk = 0x800000
	// Bit CH23.
	PPI_CHG_CH23 = 0x800000
	// Exclude
	PPI_CHG_CH23_Excluded = 0x0
	// Include
	PPI_CHG_CH23_Included = 0x1
	// Position of CH24 field.
	PPI_CHG_CH24_Pos = 0x18
	// Bit mask of CH24 field.
	PPI_CHG_CH24_Msk = 0x1000000
	// Bit CH24.
	PPI_CHG_CH24 = 0x1000000
	// Exclude
	PPI_CHG_CH24_Excluded = 0x0
	// Include
	PPI_CHG_CH24_Included = 0x1
	// Position of CH25 field.
	PPI_CHG_CH25_Pos = 0x19
	// Bit mask of CH25 field.
	PPI_CHG_CH25_Msk = 0x2000000
	// Bit CH25.
	PPI_CHG_CH25 = 0x2000000
	// Exclude
	PPI_CHG_CH25_Excluded = 0x0
	// Include
	PPI_CHG_CH25_Included = 0x1
	// Position of CH26 field.
	PPI_CHG_CH26_Pos = 0x1a
	// Bit mask of CH26 field.
	PPI_CHG_CH26_Msk = 0x4000000
	// Bit CH26.
	PPI_CHG_CH26 = 0x4000000
	// Exclude
	PPI_CHG_CH26_Excluded = 0x0
	// Include
	PPI_CHG_CH26_Included = 0x1
	// Position of CH27 field.
	PPI_CHG_CH27_Pos = 0x1b
	// Bit mask of CH27 field.
	PPI_CHG_CH27_Msk = 0x8000000
	// Bit CH27.
	PPI_CHG_CH27 = 0x8000000
	// Exclude
	PPI_CHG_CH27_Excluded = 0x0
	// Include
	PPI_CHG_CH27_Included = 0x1
	// Position of CH28 field.
	PPI_CHG_CH28_Pos = 0x1c
	// Bit mask of CH28 field.
	PPI_CHG_CH28_Msk = 0x10000000
	// Bit CH28.
	PPI_CHG_CH28 = 0x10000000
	// Exclude
	PPI_CHG_CH28_Excluded = 0x0
	// Include
	PPI_CHG_CH28_Included = 0x1
	// Position of CH29 field.
	PPI_CHG_CH29_Pos = 0x1d
	// Bit mask of CH29 field.
	PPI_CHG_CH29_Msk = 0x20000000
	// Bit CH29.
	PPI_CHG_CH29 = 0x20000000
	// Exclude
	PPI_CHG_CH29_Excluded = 0x0
	// Include
	PPI_CHG_CH29_Included = 0x1
	// Position of CH30 field.
	PPI_CHG_CH30_Pos = 0x1e
	// Bit mask of CH30 field.
	PPI_CHG_CH30_Msk = 0x40000000
	// Bit CH30.
	PPI_CHG_CH30 = 0x40000000
	// Exclude
	PPI_CHG_CH30_Excluded = 0x0
	// Include
	PPI_CHG_CH30_Included = 0x1
	// Position of CH31 field.
	PPI_CHG_CH31_Pos = 0x1f
	// Bit mask of CH31 field.
	PPI_CHG_CH31_Msk = 0x80000000
	// Bit CH31.
	PPI_CHG_CH31 = 0x80000000
	// Exclude
	PPI_CHG_CH31_Excluded = 0x0
	// Include
	PPI_CHG_CH31_Included = 0x1

	// FORK.TEP: Description cluster: Channel n task end-point
	// Position of TEP field.
	PPI_FORK_TEP_TEP_Pos = 0x0
	// Bit mask of TEP field.
	PPI_FORK_TEP_TEP_Msk = 0xffffffff
)

// Constants for USBD: Universal serial bus device
const (
	// TASKS_STARTEPIN: Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host
	// Position of TASKS_STARTEPIN field.
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Pos = 0x0
	// Bit mask of TASKS_STARTEPIN field.
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Msk = 0x1
	// Bit TASKS_STARTEPIN.
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN = 0x1
	// Trigger task
	USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Trigger = 0x1

	// TASKS_STARTISOIN: Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint
	// Position of TASKS_STARTISOIN field.
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Pos = 0x0
	// Bit mask of TASKS_STARTISOIN field.
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Msk = 0x1
	// Bit TASKS_STARTISOIN.
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN = 0x1
	// Trigger task
	USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Trigger = 0x1

	// TASKS_STARTEPOUT: Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host
	// Position of TASKS_STARTEPOUT field.
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Pos = 0x0
	// Bit mask of TASKS_STARTEPOUT field.
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Msk = 0x1
	// Bit TASKS_STARTEPOUT.
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT = 0x1
	// Trigger task
	USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Trigger = 0x1

	// TASKS_STARTISOOUT: Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint
	// Position of TASKS_STARTISOOUT field.
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Pos = 0x0
	// Bit mask of TASKS_STARTISOOUT field.
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Msk = 0x1
	// Bit TASKS_STARTISOOUT.
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT = 0x1
	// Trigger task
	USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Trigger = 0x1

	// TASKS_EP0RCVOUT: Allows OUT data stage on control endpoint 0
	// Position of TASKS_EP0RCVOUT field.
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Pos = 0x0
	// Bit mask of TASKS_EP0RCVOUT field.
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Msk = 0x1
	// Bit TASKS_EP0RCVOUT.
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT = 0x1
	// Trigger task
	USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Trigger = 0x1

	// TASKS_EP0STATUS: Allows status stage on control endpoint 0
	// Position of TASKS_EP0STATUS field.
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Pos = 0x0
	// Bit mask of TASKS_EP0STATUS field.
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Msk = 0x1
	// Bit TASKS_EP0STATUS.
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS = 0x1
	// Trigger task
	USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Trigger = 0x1

	// TASKS_EP0STALL: Stalls data and status stage on control endpoint 0
	// Position of TASKS_EP0STALL field.
	USBD_TASKS_EP0STALL_TASKS_EP0STALL_Pos = 0x0
	// Bit mask of TASKS_EP0STALL field.
	USBD_TASKS_EP0STALL_TASKS_EP0STALL_Msk = 0x1
	// Bit TASKS_EP0STALL.
	USBD_TASKS_EP0STALL_TASKS_EP0STALL = 0x1
	// Trigger task
	USBD_TASKS_EP0STALL_TASKS_EP0STALL_Trigger = 0x1

	// TASKS_DPDMDRIVE: Forces D+ and D- lines into the state defined in the DPDMVALUE register
	// Position of TASKS_DPDMDRIVE field.
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Pos = 0x0
	// Bit mask of TASKS_DPDMDRIVE field.
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Msk = 0x1
	// Bit TASKS_DPDMDRIVE.
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE = 0x1
	// Trigger task
	USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Trigger = 0x1

	// TASKS_DPDMNODRIVE: Stops forcing D+ and D- lines into any state (USB engine takes control)
	// Position of TASKS_DPDMNODRIVE field.
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Pos = 0x0
	// Bit mask of TASKS_DPDMNODRIVE field.
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Msk = 0x1
	// Bit TASKS_DPDMNODRIVE.
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE = 0x1
	// Trigger task
	USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Trigger = 0x1

	// EVENTS_USBRESET: Signals that a USB reset condition has been detected on USB lines
	// Position of EVENTS_USBRESET field.
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_Pos = 0x0
	// Bit mask of EVENTS_USBRESET field.
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_Msk = 0x1
	// Bit EVENTS_USBRESET.
	USBD_EVENTS_USBRESET_EVENTS_USBRESET = 0x1
	// Event not generated
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_USBRESET_EVENTS_USBRESET_Generated = 0x1

	// EVENTS_STARTED: Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register
	// Position of EVENTS_STARTED field.
	USBD_EVENTS_STARTED_EVENTS_STARTED_Pos = 0x0
	// Bit mask of EVENTS_STARTED field.
	USBD_EVENTS_STARTED_EVENTS_STARTED_Msk = 0x1
	// Bit EVENTS_STARTED.
	USBD_EVENTS_STARTED_EVENTS_STARTED = 0x1
	// Event not generated
	USBD_EVENTS_STARTED_EVENTS_STARTED_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_STARTED_EVENTS_STARTED_Generated = 0x1

	// EVENTS_ENDEPIN: Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDEPIN field.
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Pos = 0x0
	// Bit mask of EVENTS_ENDEPIN field.
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Msk = 0x1
	// Bit EVENTS_ENDEPIN.
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN = 0x1
	// Event not generated
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Generated = 0x1

	// EVENTS_EP0DATADONE: An acknowledged data transfer has taken place on the control endpoint
	// Position of EVENTS_EP0DATADONE field.
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Pos = 0x0
	// Bit mask of EVENTS_EP0DATADONE field.
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Msk = 0x1
	// Bit EVENTS_EP0DATADONE.
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE = 0x1
	// Event not generated
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Generated = 0x1

	// EVENTS_ENDISOIN: The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDISOIN field.
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Pos = 0x0
	// Bit mask of EVENTS_ENDISOIN field.
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Msk = 0x1
	// Bit EVENTS_ENDISOIN.
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN = 0x1
	// Event not generated
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Generated = 0x1

	// EVENTS_ENDEPOUT: Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDEPOUT field.
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Pos = 0x0
	// Bit mask of EVENTS_ENDEPOUT field.
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Msk = 0x1
	// Bit EVENTS_ENDEPOUT.
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT = 0x1
	// Event not generated
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Generated = 0x1

	// EVENTS_ENDISOOUT: The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software.
	// Position of EVENTS_ENDISOOUT field.
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Pos = 0x0
	// Bit mask of EVENTS_ENDISOOUT field.
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Msk = 0x1
	// Bit EVENTS_ENDISOOUT.
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT = 0x1
	// Event not generated
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Generated = 0x1

	// EVENTS_SOF: Signals that a SOF (start of frame) condition has been detected on USB lines
	// Position of EVENTS_SOF field.
	USBD_EVENTS_SOF_EVENTS_SOF_Pos = 0x0
	// Bit mask of EVENTS_SOF field.
	USBD_EVENTS_SOF_EVENTS_SOF_Msk = 0x1
	// Bit EVENTS_SOF.
	USBD_EVENTS_SOF_EVENTS_SOF = 0x1
	// Event not generated
	USBD_EVENTS_SOF_EVENTS_SOF_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_SOF_EVENTS_SOF_Generated = 0x1

	// EVENTS_USBEVENT: An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause.
	// Position of EVENTS_USBEVENT field.
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Pos = 0x0
	// Bit mask of EVENTS_USBEVENT field.
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Msk = 0x1
	// Bit EVENTS_USBEVENT.
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT = 0x1
	// Event not generated
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Generated = 0x1

	// EVENTS_EP0SETUP: A valid SETUP token has been received (and acknowledged) on the control endpoint
	// Position of EVENTS_EP0SETUP field.
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Pos = 0x0
	// Bit mask of EVENTS_EP0SETUP field.
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Msk = 0x1
	// Bit EVENTS_EP0SETUP.
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP = 0x1
	// Event not generated
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Generated = 0x1

	// EVENTS_EPDATA: A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register
	// Position of EVENTS_EPDATA field.
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_Pos = 0x0
	// Bit mask of EVENTS_EPDATA field.
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_Msk = 0x1
	// Bit EVENTS_EPDATA.
	USBD_EVENTS_EPDATA_EVENTS_EPDATA = 0x1
	// Event not generated
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_NotGenerated = 0x0
	// Event generated
	USBD_EVENTS_EPDATA_EVENTS_EPDATA_Generated = 0x1

	// SHORTS: Shortcuts between local events and tasks
	// Position of EP0DATADONE_STARTEPIN0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Pos = 0x0
	// Bit mask of EP0DATADONE_STARTEPIN0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Msk = 0x1
	// Bit EP0DATADONE_STARTEPIN0.
	USBD_SHORTS_EP0DATADONE_STARTEPIN0 = 0x1
	// Disable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPIN0_Enabled = 0x1
	// Position of EP0DATADONE_STARTEPOUT0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Pos = 0x1
	// Bit mask of EP0DATADONE_STARTEPOUT0 field.
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Msk = 0x2
	// Bit EP0DATADONE_STARTEPOUT0.
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0 = 0x2
	// Disable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Enabled = 0x1
	// Position of EP0DATADONE_EP0STATUS field.
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Pos = 0x2
	// Bit mask of EP0DATADONE_EP0STATUS field.
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Msk = 0x4
	// Bit EP0DATADONE_EP0STATUS.
	USBD_SHORTS_EP0DATADONE_EP0STATUS = 0x4
	// Disable shortcut
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_EP0DATADONE_EP0STATUS_Enabled = 0x1
	// Position of ENDEPOUT0_EP0STATUS field.
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Pos = 0x3
	// Bit mask of ENDEPOUT0_EP0STATUS field.
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Msk = 0x8
	// Bit ENDEPOUT0_EP0STATUS.
	USBD_SHORTS_ENDEPOUT0_EP0STATUS = 0x8
	// Disable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0STATUS_Enabled = 0x1
	// Position of ENDEPOUT0_EP0RCVOUT field.
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Pos = 0x4
	// Bit mask of ENDEPOUT0_EP0RCVOUT field.
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Msk = 0x10
	// Bit ENDEPOUT0_EP0RCVOUT.
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT = 0x10
	// Disable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Disabled = 0x0
	// Enable shortcut
	USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Enabled = 0x1

	// INTEN: Enable or disable interrupt
	// Position of USBRESET field.
	USBD_INTEN_USBRESET_Pos = 0x0
	// Bit mask of USBRESET field.
	USBD_INTEN_USBRESET_Msk = 0x1
	// Bit USBRESET.
	USBD_INTEN_USBRESET = 0x1
	// Disable
	USBD_INTEN_USBRESET_Disabled = 0x0
	// Enable
	USBD_INTEN_USBRESET_Enabled = 0x1
	// Position of STARTED field.
	USBD_INTEN_STARTED_Pos = 0x1
	// Bit mask of STARTED field.
	USBD_INTEN_STARTED_Msk = 0x2
	// Bit STARTED.
	USBD_INTEN_STARTED = 0x2
	// Disable
	USBD_INTEN_STARTED_Disabled = 0x0
	// Enable
	USBD_INTEN_STARTED_Enabled = 0x1
	// Position of ENDEPIN0 field.
	USBD_INTEN_ENDEPIN0_Pos = 0x2
	// Bit mask of ENDEPIN0 field.
	USBD_INTEN_ENDEPIN0_Msk = 0x4
	// Bit ENDEPIN0.
	USBD_INTEN_ENDEPIN0 = 0x4
	// Disable
	USBD_INTEN_ENDEPIN0_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN0_Enabled = 0x1
	// Position of ENDEPIN1 field.
	USBD_INTEN_ENDEPIN1_Pos = 0x3
	// Bit mask of ENDEPIN1 field.
	USBD_INTEN_ENDEPIN1_Msk = 0x8
	// Bit ENDEPIN1.
	USBD_INTEN_ENDEPIN1 = 0x8
	// Disable
	USBD_INTEN_ENDEPIN1_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN1_Enabled = 0x1
	// Position of ENDEPIN2 field.
	USBD_INTEN_ENDEPIN2_Pos = 0x4
	// Bit mask of ENDEPIN2 field.
	USBD_INTEN_ENDEPIN2_Msk = 0x10
	// Bit ENDEPIN2.
	USBD_INTEN_ENDEPIN2 = 0x10
	// Disable
	USBD_INTEN_ENDEPIN2_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN2_Enabled = 0x1
	// Position of ENDEPIN3 field.
	USBD_INTEN_ENDEPIN3_Pos = 0x5
	// Bit mask of ENDEPIN3 field.
	USBD_INTEN_ENDEPIN3_Msk = 0x20
	// Bit ENDEPIN3.
	USBD_INTEN_ENDEPIN3 = 0x20
	// Disable
	USBD_INTEN_ENDEPIN3_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN3_Enabled = 0x1
	// Position of ENDEPIN4 field.
	USBD_INTEN_ENDEPIN4_Pos = 0x6
	// Bit mask of ENDEPIN4 field.
	USBD_INTEN_ENDEPIN4_Msk = 0x40
	// Bit ENDEPIN4.
	USBD_INTEN_ENDEPIN4 = 0x40
	// Disable
	USBD_INTEN_ENDEPIN4_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN4_Enabled = 0x1
	// Position of ENDEPIN5 field.
	USBD_INTEN_ENDEPIN5_Pos = 0x7
	// Bit mask of ENDEPIN5 field.
	USBD_INTEN_ENDEPIN5_Msk = 0x80
	// Bit ENDEPIN5.
	USBD_INTEN_ENDEPIN5 = 0x80
	// Disable
	USBD_INTEN_ENDEPIN5_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN5_Enabled = 0x1
	// Position of ENDEPIN6 field.
	USBD_INTEN_ENDEPIN6_Pos = 0x8
	// Bit mask of ENDEPIN6 field.
	USBD_INTEN_ENDEPIN6_Msk = 0x100
	// Bit ENDEPIN6.
	USBD_INTEN_ENDEPIN6 = 0x100
	// Disable
	USBD_INTEN_ENDEPIN6_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN6_Enabled = 0x1
	// Position of ENDEPIN7 field.
	USBD_INTEN_ENDEPIN7_Pos = 0x9
	// Bit mask of ENDEPIN7 field.
	USBD_INTEN_ENDEPIN7_Msk = 0x200
	// Bit ENDEPIN7.
	USBD_INTEN_ENDEPIN7 = 0x200
	// Disable
	USBD_INTEN_ENDEPIN7_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPIN7_Enabled = 0x1
	// Position of EP0DATADONE field.
	USBD_INTEN_EP0DATADONE_Pos = 0xa
	// Bit mask of EP0DATADONE field.
	USBD_INTEN_EP0DATADONE_Msk = 0x400
	// Bit EP0DATADONE.
	USBD_INTEN_EP0DATADONE = 0x400
	// Disable
	USBD_INTEN_EP0DATADONE_Disabled = 0x0
	// Enable
	USBD_INTEN_EP0DATADONE_Enabled = 0x1
	// Position of ENDISOIN field.
	USBD_INTEN_ENDISOIN_Pos = 0xb
	// Bit mask of ENDISOIN field.
	USBD_INTEN_ENDISOIN_Msk = 0x800
	// Bit ENDISOIN.
	USBD_INTEN_ENDISOIN = 0x800
	// Disable
	USBD_INTEN_ENDISOIN_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDISOIN_Enabled = 0x1
	// Position of ENDEPOUT0 field.
	USBD_INTEN_ENDEPOUT0_Pos = 0xc
	// Bit mask of ENDEPOUT0 field.
	USBD_INTEN_ENDEPOUT0_Msk = 0x1000
	// Bit ENDEPOUT0.
	USBD_INTEN_ENDEPOUT0 = 0x1000
	// Disable
	USBD_INTEN_ENDEPOUT0_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT0_Enabled = 0x1
	// Position of ENDEPOUT1 field.
	USBD_INTEN_ENDEPOUT1_Pos = 0xd
	// Bit mask of ENDEPOUT1 field.
	USBD_INTEN_ENDEPOUT1_Msk = 0x2000
	// Bit ENDEPOUT1.
	USBD_INTEN_ENDEPOUT1 = 0x2000
	// Disable
	USBD_INTEN_ENDEPOUT1_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT1_Enabled = 0x1
	// Position of ENDEPOUT2 field.
	USBD_INTEN_ENDEPOUT2_Pos = 0xe
	// Bit mask of ENDEPOUT2 field.
	USBD_INTEN_ENDEPOUT2_Msk = 0x4000
	// Bit ENDEPOUT2.
	USBD_INTEN_ENDEPOUT2 = 0x4000
	// Disable
	USBD_INTEN_ENDEPOUT2_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT2_Enabled = 0x1
	// Position of ENDEPOUT3 field.
	USBD_INTEN_ENDEPOUT3_Pos = 0xf
	// Bit mask of ENDEPOUT3 field.
	USBD_INTEN_ENDEPOUT3_Msk = 0x8000
	// Bit ENDEPOUT3.
	USBD_INTEN_ENDEPOUT3 = 0x8000
	// Disable
	USBD_INTEN_ENDEPOUT3_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT3_Enabled = 0x1
	// Position of ENDEPOUT4 field.
	USBD_INTEN_ENDEPOUT4_Pos = 0x10
	// Bit mask of ENDEPOUT4 field.
	USBD_INTEN_ENDEPOUT4_Msk = 0x10000
	// Bit ENDEPOUT4.
	USBD_INTEN_ENDEPOUT4 = 0x10000
	// Disable
	USBD_INTEN_ENDEPOUT4_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT4_Enabled = 0x1
	// Position of ENDEPOUT5 field.
	USBD_INTEN_ENDEPOUT5_Pos = 0x11
	// Bit mask of ENDEPOUT5 field.
	USBD_INTEN_ENDEPOUT5_Msk = 0x20000
	// Bit ENDEPOUT5.
	USBD_INTEN_ENDEPOUT5 = 0x20000
	// Disable
	USBD_INTEN_ENDEPOUT5_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT5_Enabled = 0x1
	// Position of ENDEPOUT6 field.
	USBD_INTEN_ENDEPOUT6_Pos = 0x12
	// Bit mask of ENDEPOUT6 field.
	USBD_INTEN_ENDEPOUT6_Msk = 0x40000
	// Bit ENDEPOUT6.
	USBD_INTEN_ENDEPOUT6 = 0x40000
	// Disable
	USBD_INTEN_ENDEPOUT6_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT6_Enabled = 0x1
	// Position of ENDEPOUT7 field.
	USBD_INTEN_ENDEPOUT7_Pos = 0x13
	// Bit mask of ENDEPOUT7 field.
	USBD_INTEN_ENDEPOUT7_Msk = 0x80000
	// Bit ENDEPOUT7.
	USBD_INTEN_ENDEPOUT7 = 0x80000
	// Disable
	USBD_INTEN_ENDEPOUT7_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDEPOUT7_Enabled = 0x1
	// Position of ENDISOOUT field.
	USBD_INTEN_ENDISOOUT_Pos = 0x14
	// Bit mask of ENDISOOUT field.
	USBD_INTEN_ENDISOOUT_Msk = 0x100000
	// Bit ENDISOOUT.
	USBD_INTEN_ENDISOOUT = 0x100000
	// Disable
	USBD_INTEN_ENDISOOUT_Disabled = 0x0
	// Enable
	USBD_INTEN_ENDISOOUT_Enabled = 0x1
	// Position of SOF field.
	USBD_INTEN_SOF_Pos = 0x15
	// Bit mask of SOF field.
	USBD_INTEN_SOF_Msk = 0x200000
	// Bit SOF.
	USBD_INTEN_SOF = 0x200000
	// Disable
	USBD_INTEN_SOF_Disabled = 0x0
	// Enable
	USBD_INTEN_SOF_Enabled = 0x1
	// Position of USBEVENT field.
	USBD_INTEN_USBEVENT_Pos = 0x16
	// Bit mask of USBEVENT field.
	USBD_INTEN_USBEVENT_Msk = 0x400000
	// Bit USBEVENT.
	USBD_INTEN_USBEVENT = 0x400000
	// Disable
	USBD_INTEN_USBEVENT_Disabled = 0x0
	// Enable
	USBD_INTEN_USBEVENT_Enabled = 0x1
	// Position of EP0SETUP field.
	USBD_INTEN_EP0SETUP_Pos = 0x17
	// Bit mask of EP0SETUP field.
	USBD_INTEN_EP0SETUP_Msk = 0x800000
	// Bit EP0SETUP.
	USBD_INTEN_EP0SETUP = 0x800000
	// Disable
	USBD_INTEN_EP0SETUP_Disabled = 0x0
	// Enable
	USBD_INTEN_EP0SETUP_Enabled = 0x1
	// Position of EPDATA field.
	USBD_INTEN_EPDATA_Pos = 0x18
	// Bit mask of EPDATA field.
	USBD_INTEN_EPDATA_Msk = 0x1000000
	// Bit EPDATA.
	USBD_INTEN_EPDATA = 0x1000000
	// Disable
	USBD_INTEN_EPDATA_Disabled = 0x0
	// Enable
	USBD_INTEN_EPDATA_Enabled = 0x1

	// INTENSET: Enable interrupt
	// Position of USBRESET field.
	USBD_INTENSET_USBRESET_Pos = 0x0
	// Bit mask of USBRESET field.
	USBD_INTENSET_USBRESET_Msk = 0x1
	// Bit USBRESET.
	USBD_INTENSET_USBRESET = 0x1
	// Read: Disabled
	USBD_INTENSET_USBRESET_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_USBRESET_Enabled = 0x1
	// Enable
	USBD_INTENSET_USBRESET_Set = 0x1
	// Position of STARTED field.
	USBD_INTENSET_STARTED_Pos = 0x1
	// Bit mask of STARTED field.
	USBD_INTENSET_STARTED_Msk = 0x2
	// Bit STARTED.
	USBD_INTENSET_STARTED = 0x2
	// Read: Disabled
	USBD_INTENSET_STARTED_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_STARTED_Enabled = 0x1
	// Enable
	USBD_INTENSET_STARTED_Set = 0x1
	// Position of ENDEPIN0 field.
	USBD_INTENSET_ENDEPIN0_Pos = 0x2
	// Bit mask of ENDEPIN0 field.
	USBD_INTENSET_ENDEPIN0_Msk = 0x4
	// Bit ENDEPIN0.
	USBD_INTENSET_ENDEPIN0 = 0x4
	// Read: Disabled
	USBD_INTENSET_ENDEPIN0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN0_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN0_Set = 0x1
	// Position of ENDEPIN1 field.
	USBD_INTENSET_ENDEPIN1_Pos = 0x3
	// Bit mask of ENDEPIN1 field.
	USBD_INTENSET_ENDEPIN1_Msk = 0x8
	// Bit ENDEPIN1.
	USBD_INTENSET_ENDEPIN1 = 0x8
	// Read: Disabled
	USBD_INTENSET_ENDEPIN1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN1_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN1_Set = 0x1
	// Position of ENDEPIN2 field.
	USBD_INTENSET_ENDEPIN2_Pos = 0x4
	// Bit mask of ENDEPIN2 field.
	USBD_INTENSET_ENDEPIN2_Msk = 0x10
	// Bit ENDEPIN2.
	USBD_INTENSET_ENDEPIN2 = 0x10
	// Read: Disabled
	USBD_INTENSET_ENDEPIN2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN2_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN2_Set = 0x1
	// Position of ENDEPIN3 field.
	USBD_INTENSET_ENDEPIN3_Pos = 0x5
	// Bit mask of ENDEPIN3 field.
	USBD_INTENSET_ENDEPIN3_Msk = 0x20
	// Bit ENDEPIN3.
	USBD_INTENSET_ENDEPIN3 = 0x20
	// Read: Disabled
	USBD_INTENSET_ENDEPIN3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN3_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN3_Set = 0x1
	// Position of ENDEPIN4 field.
	USBD_INTENSET_ENDEPIN4_Pos = 0x6
	// Bit mask of ENDEPIN4 field.
	USBD_INTENSET_ENDEPIN4_Msk = 0x40
	// Bit ENDEPIN4.
	USBD_INTENSET_ENDEPIN4 = 0x40
	// Read: Disabled
	USBD_INTENSET_ENDEPIN4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN4_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN4_Set = 0x1
	// Position of ENDEPIN5 field.
	USBD_INTENSET_ENDEPIN5_Pos = 0x7
	// Bit mask of ENDEPIN5 field.
	USBD_INTENSET_ENDEPIN5_Msk = 0x80
	// Bit ENDEPIN5.
	USBD_INTENSET_ENDEPIN5 = 0x80
	// Read: Disabled
	USBD_INTENSET_ENDEPIN5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN5_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN5_Set = 0x1
	// Position of ENDEPIN6 field.
	USBD_INTENSET_ENDEPIN6_Pos = 0x8
	// Bit mask of ENDEPIN6 field.
	USBD_INTENSET_ENDEPIN6_Msk = 0x100
	// Bit ENDEPIN6.
	USBD_INTENSET_ENDEPIN6 = 0x100
	// Read: Disabled
	USBD_INTENSET_ENDEPIN6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN6_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN6_Set = 0x1
	// Position of ENDEPIN7 field.
	USBD_INTENSET_ENDEPIN7_Pos = 0x9
	// Bit mask of ENDEPIN7 field.
	USBD_INTENSET_ENDEPIN7_Msk = 0x200
	// Bit ENDEPIN7.
	USBD_INTENSET_ENDEPIN7 = 0x200
	// Read: Disabled
	USBD_INTENSET_ENDEPIN7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPIN7_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPIN7_Set = 0x1
	// Position of EP0DATADONE field.
	USBD_INTENSET_EP0DATADONE_Pos = 0xa
	// Bit mask of EP0DATADONE field.
	USBD_INTENSET_EP0DATADONE_Msk = 0x400
	// Bit EP0DATADONE.
	USBD_INTENSET_EP0DATADONE = 0x400
	// Read: Disabled
	USBD_INTENSET_EP0DATADONE_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_EP0DATADONE_Enabled = 0x1
	// Enable
	USBD_INTENSET_EP0DATADONE_Set = 0x1
	// Position of ENDISOIN field.
	USBD_INTENSET_ENDISOIN_Pos = 0xb
	// Bit mask of ENDISOIN field.
	USBD_INTENSET_ENDISOIN_Msk = 0x800
	// Bit ENDISOIN.
	USBD_INTENSET_ENDISOIN = 0x800
	// Read: Disabled
	USBD_INTENSET_ENDISOIN_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDISOIN_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDISOIN_Set = 0x1
	// Position of ENDEPOUT0 field.
	USBD_INTENSET_ENDEPOUT0_Pos = 0xc
	// Bit mask of ENDEPOUT0 field.
	USBD_INTENSET_ENDEPOUT0_Msk = 0x1000
	// Bit ENDEPOUT0.
	USBD_INTENSET_ENDEPOUT0 = 0x1000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT0_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT0_Set = 0x1
	// Position of ENDEPOUT1 field.
	USBD_INTENSET_ENDEPOUT1_Pos = 0xd
	// Bit mask of ENDEPOUT1 field.
	USBD_INTENSET_ENDEPOUT1_Msk = 0x2000
	// Bit ENDEPOUT1.
	USBD_INTENSET_ENDEPOUT1 = 0x2000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT1_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT1_Set = 0x1
	// Position of ENDEPOUT2 field.
	USBD_INTENSET_ENDEPOUT2_Pos = 0xe
	// Bit mask of ENDEPOUT2 field.
	USBD_INTENSET_ENDEPOUT2_Msk = 0x4000
	// Bit ENDEPOUT2.
	USBD_INTENSET_ENDEPOUT2 = 0x4000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT2_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT2_Set = 0x1
	// Position of ENDEPOUT3 field.
	USBD_INTENSET_ENDEPOUT3_Pos = 0xf
	// Bit mask of ENDEPOUT3 field.
	USBD_INTENSET_ENDEPOUT3_Msk = 0x8000
	// Bit ENDEPOUT3.
	USBD_INTENSET_ENDEPOUT3 = 0x8000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT3_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT3_Set = 0x1
	// Position of ENDEPOUT4 field.
	USBD_INTENSET_ENDEPOUT4_Pos = 0x10
	// Bit mask of ENDEPOUT4 field.
	USBD_INTENSET_ENDEPOUT4_Msk = 0x10000
	// Bit ENDEPOUT4.
	USBD_INTENSET_ENDEPOUT4 = 0x10000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT4_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT4_Set = 0x1
	// Position of ENDEPOUT5 field.
	USBD_INTENSET_ENDEPOUT5_Pos = 0x11
	// Bit mask of ENDEPOUT5 field.
	USBD_INTENSET_ENDEPOUT5_Msk = 0x20000
	// Bit ENDEPOUT5.
	USBD_INTENSET_ENDEPOUT5 = 0x20000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT5_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT5_Set = 0x1
	// Position of ENDEPOUT6 field.
	USBD_INTENSET_ENDEPOUT6_Pos = 0x12
	// Bit mask of ENDEPOUT6 field.
	USBD_INTENSET_ENDEPOUT6_Msk = 0x40000
	// Bit ENDEPOUT6.
	USBD_INTENSET_ENDEPOUT6 = 0x40000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT6_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT6_Set = 0x1
	// Position of ENDEPOUT7 field.
	USBD_INTENSET_ENDEPOUT7_Pos = 0x13
	// Bit mask of ENDEPOUT7 field.
	USBD_INTENSET_ENDEPOUT7_Msk = 0x80000
	// Bit ENDEPOUT7.
	USBD_INTENSET_ENDEPOUT7 = 0x80000
	// Read: Disabled
	USBD_INTENSET_ENDEPOUT7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDEPOUT7_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDEPOUT7_Set = 0x1
	// Position of ENDISOOUT field.
	USBD_INTENSET_ENDISOOUT_Pos = 0x14
	// Bit mask of ENDISOOUT field.
	USBD_INTENSET_ENDISOOUT_Msk = 0x100000
	// Bit ENDISOOUT.
	USBD_INTENSET_ENDISOOUT = 0x100000
	// Read: Disabled
	USBD_INTENSET_ENDISOOUT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_ENDISOOUT_Enabled = 0x1
	// Enable
	USBD_INTENSET_ENDISOOUT_Set = 0x1
	// Position of SOF field.
	USBD_INTENSET_SOF_Pos = 0x15
	// Bit mask of SOF field.
	USBD_INTENSET_SOF_Msk = 0x200000
	// Bit SOF.
	USBD_INTENSET_SOF = 0x200000
	// Read: Disabled
	USBD_INTENSET_SOF_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_SOF_Enabled = 0x1
	// Enable
	USBD_INTENSET_SOF_Set = 0x1
	// Position of USBEVENT field.
	USBD_INTENSET_USBEVENT_Pos = 0x16
	// Bit mask of USBEVENT field.
	USBD_INTENSET_USBEVENT_Msk = 0x400000
	// Bit USBEVENT.
	USBD_INTENSET_USBEVENT = 0x400000
	// Read: Disabled
	USBD_INTENSET_USBEVENT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_USBEVENT_Enabled = 0x1
	// Enable
	USBD_INTENSET_USBEVENT_Set = 0x1
	// Position of EP0SETUP field.
	USBD_INTENSET_EP0SETUP_Pos = 0x17
	// Bit mask of EP0SETUP field.
	USBD_INTENSET_EP0SETUP_Msk = 0x800000
	// Bit EP0SETUP.
	USBD_INTENSET_EP0SETUP = 0x800000
	// Read: Disabled
	USBD_INTENSET_EP0SETUP_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_EP0SETUP_Enabled = 0x1
	// Enable
	USBD_INTENSET_EP0SETUP_Set = 0x1
	// Position of EPDATA field.
	USBD_INTENSET_EPDATA_Pos = 0x18
	// Bit mask of EPDATA field.
	USBD_INTENSET_EPDATA_Msk = 0x1000000
	// Bit EPDATA.
	USBD_INTENSET_EPDATA = 0x1000000
	// Read: Disabled
	USBD_INTENSET_EPDATA_Disabled = 0x0
	// Read: Enabled
	USBD_INTENSET_EPDATA_Enabled = 0x1
	// Enable
	USBD_INTENSET_EPDATA_Set = 0x1

	// INTENCLR: Disable interrupt
	// Position of USBRESET field.
	USBD_INTENCLR_USBRESET_Pos = 0x0
	// Bit mask of USBRESET field.
	USBD_INTENCLR_USBRESET_Msk = 0x1
	// Bit USBRESET.
	USBD_INTENCLR_USBRESET = 0x1
	// Read: Disabled
	USBD_INTENCLR_USBRESET_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_USBRESET_Enabled = 0x1
	// Disable
	USBD_INTENCLR_USBRESET_Clear = 0x1
	// Position of STARTED field.
	USBD_INTENCLR_STARTED_Pos = 0x1
	// Bit mask of STARTED field.
	USBD_INTENCLR_STARTED_Msk = 0x2
	// Bit STARTED.
	USBD_INTENCLR_STARTED = 0x2
	// Read: Disabled
	USBD_INTENCLR_STARTED_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_STARTED_Enabled = 0x1
	// Disable
	USBD_INTENCLR_STARTED_Clear = 0x1
	// Position of ENDEPIN0 field.
	USBD_INTENCLR_ENDEPIN0_Pos = 0x2
	// Bit mask of ENDEPIN0 field.
	USBD_INTENCLR_ENDEPIN0_Msk = 0x4
	// Bit ENDEPIN0.
	USBD_INTENCLR_ENDEPIN0 = 0x4
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN0_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN0_Clear = 0x1
	// Position of ENDEPIN1 field.
	USBD_INTENCLR_ENDEPIN1_Pos = 0x3
	// Bit mask of ENDEPIN1 field.
	USBD_INTENCLR_ENDEPIN1_Msk = 0x8
	// Bit ENDEPIN1.
	USBD_INTENCLR_ENDEPIN1 = 0x8
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN1_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN1_Clear = 0x1
	// Position of ENDEPIN2 field.
	USBD_INTENCLR_ENDEPIN2_Pos = 0x4
	// Bit mask of ENDEPIN2 field.
	USBD_INTENCLR_ENDEPIN2_Msk = 0x10
	// Bit ENDEPIN2.
	USBD_INTENCLR_ENDEPIN2 = 0x10
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN2_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN2_Clear = 0x1
	// Position of ENDEPIN3 field.
	USBD_INTENCLR_ENDEPIN3_Pos = 0x5
	// Bit mask of ENDEPIN3 field.
	USBD_INTENCLR_ENDEPIN3_Msk = 0x20
	// Bit ENDEPIN3.
	USBD_INTENCLR_ENDEPIN3 = 0x20
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN3_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN3_Clear = 0x1
	// Position of ENDEPIN4 field.
	USBD_INTENCLR_ENDEPIN4_Pos = 0x6
	// Bit mask of ENDEPIN4 field.
	USBD_INTENCLR_ENDEPIN4_Msk = 0x40
	// Bit ENDEPIN4.
	USBD_INTENCLR_ENDEPIN4 = 0x40
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN4_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN4_Clear = 0x1
	// Position of ENDEPIN5 field.
	USBD_INTENCLR_ENDEPIN5_Pos = 0x7
	// Bit mask of ENDEPIN5 field.
	USBD_INTENCLR_ENDEPIN5_Msk = 0x80
	// Bit ENDEPIN5.
	USBD_INTENCLR_ENDEPIN5 = 0x80
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN5_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN5_Clear = 0x1
	// Position of ENDEPIN6 field.
	USBD_INTENCLR_ENDEPIN6_Pos = 0x8
	// Bit mask of ENDEPIN6 field.
	USBD_INTENCLR_ENDEPIN6_Msk = 0x100
	// Bit ENDEPIN6.
	USBD_INTENCLR_ENDEPIN6 = 0x100
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN6_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN6_Clear = 0x1
	// Position of ENDEPIN7 field.
	USBD_INTENCLR_ENDEPIN7_Pos = 0x9
	// Bit mask of ENDEPIN7 field.
	USBD_INTENCLR_ENDEPIN7_Msk = 0x200
	// Bit ENDEPIN7.
	USBD_INTENCLR_ENDEPIN7 = 0x200
	// Read: Disabled
	USBD_INTENCLR_ENDEPIN7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPIN7_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPIN7_Clear = 0x1
	// Position of EP0DATADONE field.
	USBD_INTENCLR_EP0DATADONE_Pos = 0xa
	// Bit mask of EP0DATADONE field.
	USBD_INTENCLR_EP0DATADONE_Msk = 0x400
	// Bit EP0DATADONE.
	USBD_INTENCLR_EP0DATADONE = 0x400
	// Read: Disabled
	USBD_INTENCLR_EP0DATADONE_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_EP0DATADONE_Enabled = 0x1
	// Disable
	USBD_INTENCLR_EP0DATADONE_Clear = 0x1
	// Position of ENDISOIN field.
	USBD_INTENCLR_ENDISOIN_Pos = 0xb
	// Bit mask of ENDISOIN field.
	USBD_INTENCLR_ENDISOIN_Msk = 0x800
	// Bit ENDISOIN.
	USBD_INTENCLR_ENDISOIN = 0x800
	// Read: Disabled
	USBD_INTENCLR_ENDISOIN_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDISOIN_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDISOIN_Clear = 0x1
	// Position of ENDEPOUT0 field.
	USBD_INTENCLR_ENDEPOUT0_Pos = 0xc
	// Bit mask of ENDEPOUT0 field.
	USBD_INTENCLR_ENDEPOUT0_Msk = 0x1000
	// Bit ENDEPOUT0.
	USBD_INTENCLR_ENDEPOUT0 = 0x1000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT0_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT0_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT0_Clear = 0x1
	// Position of ENDEPOUT1 field.
	USBD_INTENCLR_ENDEPOUT1_Pos = 0xd
	// Bit mask of ENDEPOUT1 field.
	USBD_INTENCLR_ENDEPOUT1_Msk = 0x2000
	// Bit ENDEPOUT1.
	USBD_INTENCLR_ENDEPOUT1 = 0x2000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT1_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT1_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT1_Clear = 0x1
	// Position of ENDEPOUT2 field.
	USBD_INTENCLR_ENDEPOUT2_Pos = 0xe
	// Bit mask of ENDEPOUT2 field.
	USBD_INTENCLR_ENDEPOUT2_Msk = 0x4000
	// Bit ENDEPOUT2.
	USBD_INTENCLR_ENDEPOUT2 = 0x4000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT2_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT2_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT2_Clear = 0x1
	// Position of ENDEPOUT3 field.
	USBD_INTENCLR_ENDEPOUT3_Pos = 0xf
	// Bit mask of ENDEPOUT3 field.
	USBD_INTENCLR_ENDEPOUT3_Msk = 0x8000
	// Bit ENDEPOUT3.
	USBD_INTENCLR_ENDEPOUT3 = 0x8000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT3_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT3_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT3_Clear = 0x1
	// Position of ENDEPOUT4 field.
	USBD_INTENCLR_ENDEPOUT4_Pos = 0x10
	// Bit mask of ENDEPOUT4 field.
	USBD_INTENCLR_ENDEPOUT4_Msk = 0x10000
	// Bit ENDEPOUT4.
	USBD_INTENCLR_ENDEPOUT4 = 0x10000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT4_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT4_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT4_Clear = 0x1
	// Position of ENDEPOUT5 field.
	USBD_INTENCLR_ENDEPOUT5_Pos = 0x11
	// Bit mask of ENDEPOUT5 field.
	USBD_INTENCLR_ENDEPOUT5_Msk = 0x20000
	// Bit ENDEPOUT5.
	USBD_INTENCLR_ENDEPOUT5 = 0x20000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT5_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT5_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT5_Clear = 0x1
	// Position of ENDEPOUT6 field.
	USBD_INTENCLR_ENDEPOUT6_Pos = 0x12
	// Bit mask of ENDEPOUT6 field.
	USBD_INTENCLR_ENDEPOUT6_Msk = 0x40000
	// Bit ENDEPOUT6.
	USBD_INTENCLR_ENDEPOUT6 = 0x40000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT6_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT6_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT6_Clear = 0x1
	// Position of ENDEPOUT7 field.
	USBD_INTENCLR_ENDEPOUT7_Pos = 0x13
	// Bit mask of ENDEPOUT7 field.
	USBD_INTENCLR_ENDEPOUT7_Msk = 0x80000
	// Bit ENDEPOUT7.
	USBD_INTENCLR_ENDEPOUT7 = 0x80000
	// Read: Disabled
	USBD_INTENCLR_ENDEPOUT7_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDEPOUT7_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDEPOUT7_Clear = 0x1
	// Position of ENDISOOUT field.
	USBD_INTENCLR_ENDISOOUT_Pos = 0x14
	// Bit mask of ENDISOOUT field.
	USBD_INTENCLR_ENDISOOUT_Msk = 0x100000
	// Bit ENDISOOUT.
	USBD_INTENCLR_ENDISOOUT = 0x100000
	// Read: Disabled
	USBD_INTENCLR_ENDISOOUT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_ENDISOOUT_Enabled = 0x1
	// Disable
	USBD_INTENCLR_ENDISOOUT_Clear = 0x1
	// Position of SOF field.
	USBD_INTENCLR_SOF_Pos = 0x15
	// Bit mask of SOF field.
	USBD_INTENCLR_SOF_Msk = 0x200000
	// Bit SOF.
	USBD_INTENCLR_SOF = 0x200000
	// Read: Disabled
	USBD_INTENCLR_SOF_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_SOF_Enabled = 0x1
	// Disable
	USBD_INTENCLR_SOF_Clear = 0x1
	// Position of USBEVENT field.
	USBD_INTENCLR_USBEVENT_Pos = 0x16
	// Bit mask of USBEVENT field.
	USBD_INTENCLR_USBEVENT_Msk = 0x400000
	// Bit USBEVENT.
	USBD_INTENCLR_USBEVENT = 0x400000
	// Read: Disabled
	USBD_INTENCLR_USBEVENT_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_USBEVENT_Enabled = 0x1
	// Disable
	USBD_INTENCLR_USBEVENT_Clear = 0x1
	// Position of EP0SETUP field.
	USBD_INTENCLR_EP0SETUP_Pos = 0x17
	// Bit mask of EP0SETUP field.
	USBD_INTENCLR_EP0SETUP_Msk = 0x800000
	// Bit EP0SETUP.
	USBD_INTENCLR_EP0SETUP = 0x800000
	// Read: Disabled
	USBD_INTENCLR_EP0SETUP_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_EP0SETUP_Enabled = 0x1
	// Disable
	USBD_INTENCLR_EP0SETUP_Clear = 0x1
	// Position of EPDATA field.
	USBD_INTENCLR_EPDATA_Pos = 0x18
	// Bit mask of EPDATA field.
	USBD_INTENCLR_EPDATA_Msk = 0x1000000
	// Bit EPDATA.
	USBD_INTENCLR_EPDATA = 0x1000000
	// Read: Disabled
	USBD_INTENCLR_EPDATA_Disabled = 0x0
	// Read: Enabled
	USBD_INTENCLR_EPDATA_Enabled = 0x1
	// Disable
	USBD_INTENCLR_EPDATA_Clear = 0x1

	// EVENTCAUSE: Details on what caused the USBEVENT event
	// Position of ISOOUTCRC field.
	USBD_EVENTCAUSE_ISOOUTCRC_Pos = 0x0
	// Bit mask of ISOOUTCRC field.
	USBD_EVENTCAUSE_ISOOUTCRC_Msk = 0x1
	// Bit ISOOUTCRC.
	USBD_EVENTCAUSE_ISOOUTCRC = 0x1
	// No error detected
	USBD_EVENTCAUSE_ISOOUTCRC_NotDetected = 0x0
	// Error detected
	USBD_EVENTCAUSE_ISOOUTCRC_Detected = 0x1
	// Position of SUSPEND field.
	USBD_EVENTCAUSE_SUSPEND_Pos = 0x8
	// Bit mask of SUSPEND field.
	USBD_EVENTCAUSE_SUSPEND_Msk = 0x100
	// Bit SUSPEND.
	USBD_EVENTCAUSE_SUSPEND = 0x100
	// Suspend not detected
	USBD_EVENTCAUSE_SUSPEND_NotDetected = 0x0
	// Suspend detected
	USBD_EVENTCAUSE_SUSPEND_Detected = 0x1
	// Position of RESUME field.
	USBD_EVENTCAUSE_RESUME_Pos = 0x9
	// Bit mask of RESUME field.
	USBD_EVENTCAUSE_RESUME_Msk = 0x200
	// Bit RESUME.
	USBD_EVENTCAUSE_RESUME = 0x200
	// Resume not detected
	USBD_EVENTCAUSE_RESUME_NotDetected = 0x0
	// Resume detected
	USBD_EVENTCAUSE_RESUME_Detected = 0x1
	// Position of USBWUALLOWED field.
	USBD_EVENTCAUSE_USBWUALLOWED_Pos = 0xa
	// Bit mask of USBWUALLOWED field.
	USBD_EVENTCAUSE_USBWUALLOWED_Msk = 0x400
	// Bit USBWUALLOWED.
	USBD_EVENTCAUSE_USBWUALLOWED = 0x400
	// Wake up not allowed
	USBD_EVENTCAUSE_USBWUALLOWED_NotAllowed = 0x0
	// Wake up allowed
	USBD_EVENTCAUSE_USBWUALLOWED_Allowed = 0x1
	// Position of READY field.
	USBD_EVENTCAUSE_READY_Pos = 0xb
	// Bit mask of READY field.
	USBD_EVENTCAUSE_READY_Msk = 0x800
	// Bit READY.
	USBD_EVENTCAUSE_READY = 0x800
	// USBEVENT was not issued due to USBD peripheral ready
	USBD_EVENTCAUSE_READY_NotDetected = 0x0
	// USBD peripheral is ready
	USBD_EVENTCAUSE_READY_Ready = 0x1

	// HALTED.EPIN: Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint.
	// Position of GETSTATUS field.
	USBD_HALTED_EPIN_GETSTATUS_Pos = 0x0
	// Bit mask of GETSTATUS field.
	USBD_HALTED_EPIN_GETSTATUS_Msk = 0xffff
	// Endpoint is not halted
	USBD_HALTED_EPIN_GETSTATUS_NotHalted = 0x0
	// Endpoint is halted
	USBD_HALTED_EPIN_GETSTATUS_Halted = 0x1

	// HALTED.EPOUT: Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint.
	// Position of GETSTATUS field.
	USBD_HALTED_EPOUT_GETSTATUS_Pos = 0x0
	// Bit mask of GETSTATUS field.
	USBD_HALTED_EPOUT_GETSTATUS_Msk = 0xffff
	// Endpoint is not halted
	USBD_HALTED_EPOUT_GETSTATUS_NotHalted = 0x0
	// Endpoint is halted
	USBD_HALTED_EPOUT_GETSTATUS_Halted = 0x1

	// EPSTATUS: Provides information on which endpoint's EasyDMA registers have been captured
	// Position of EPIN0 field.
	USBD_EPSTATUS_EPIN0_Pos = 0x0
	// Bit mask of EPIN0 field.
	USBD_EPSTATUS_EPIN0_Msk = 0x1
	// Bit EPIN0.
	USBD_EPSTATUS_EPIN0 = 0x1
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN0_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN0_DataDone = 0x1
	// Position of EPIN1 field.
	USBD_EPSTATUS_EPIN1_Pos = 0x1
	// Bit mask of EPIN1 field.
	USBD_EPSTATUS_EPIN1_Msk = 0x2
	// Bit EPIN1.
	USBD_EPSTATUS_EPIN1 = 0x2
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN1_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN1_DataDone = 0x1
	// Position of EPIN2 field.
	USBD_EPSTATUS_EPIN2_Pos = 0x2
	// Bit mask of EPIN2 field.
	USBD_EPSTATUS_EPIN2_Msk = 0x4
	// Bit EPIN2.
	USBD_EPSTATUS_EPIN2 = 0x4
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN2_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN2_DataDone = 0x1
	// Position of EPIN3 field.
	USBD_EPSTATUS_EPIN3_Pos = 0x3
	// Bit mask of EPIN3 field.
	USBD_EPSTATUS_EPIN3_Msk = 0x8
	// Bit EPIN3.
	USBD_EPSTATUS_EPIN3 = 0x8
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN3_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN3_DataDone = 0x1
	// Position of EPIN4 field.
	USBD_EPSTATUS_EPIN4_Pos = 0x4
	// Bit mask of EPIN4 field.
	USBD_EPSTATUS_EPIN4_Msk = 0x10
	// Bit EPIN4.
	USBD_EPSTATUS_EPIN4 = 0x10
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN4_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN4_DataDone = 0x1
	// Position of EPIN5 field.
	USBD_EPSTATUS_EPIN5_Pos = 0x5
	// Bit mask of EPIN5 field.
	USBD_EPSTATUS_EPIN5_Msk = 0x20
	// Bit EPIN5.
	USBD_EPSTATUS_EPIN5 = 0x20
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN5_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN5_DataDone = 0x1
	// Position of EPIN6 field.
	USBD_EPSTATUS_EPIN6_Pos = 0x6
	// Bit mask of EPIN6 field.
	USBD_EPSTATUS_EPIN6_Msk = 0x40
	// Bit EPIN6.
	USBD_EPSTATUS_EPIN6 = 0x40
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN6_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN6_DataDone = 0x1
	// Position of EPIN7 field.
	USBD_EPSTATUS_EPIN7_Pos = 0x7
	// Bit mask of EPIN7 field.
	USBD_EPSTATUS_EPIN7_Msk = 0x80
	// Bit EPIN7.
	USBD_EPSTATUS_EPIN7 = 0x80
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN7_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN7_DataDone = 0x1
	// Position of EPIN8 field.
	USBD_EPSTATUS_EPIN8_Pos = 0x8
	// Bit mask of EPIN8 field.
	USBD_EPSTATUS_EPIN8_Msk = 0x100
	// Bit EPIN8.
	USBD_EPSTATUS_EPIN8 = 0x100
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPIN8_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPIN8_DataDone = 0x1
	// Position of EPOUT0 field.
	USBD_EPSTATUS_EPOUT0_Pos = 0x10
	// Bit mask of EPOUT0 field.
	USBD_EPSTATUS_EPOUT0_Msk = 0x10000
	// Bit EPOUT0.
	USBD_EPSTATUS_EPOUT0 = 0x10000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT0_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT0_DataDone = 0x1
	// Position of EPOUT1 field.
	USBD_EPSTATUS_EPOUT1_Pos = 0x11
	// Bit mask of EPOUT1 field.
	USBD_EPSTATUS_EPOUT1_Msk = 0x20000
	// Bit EPOUT1.
	USBD_EPSTATUS_EPOUT1 = 0x20000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT1_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT1_DataDone = 0x1
	// Position of EPOUT2 field.
	USBD_EPSTATUS_EPOUT2_Pos = 0x12
	// Bit mask of EPOUT2 field.
	USBD_EPSTATUS_EPOUT2_Msk = 0x40000
	// Bit EPOUT2.
	USBD_EPSTATUS_EPOUT2 = 0x40000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT2_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT2_DataDone = 0x1
	// Position of EPOUT3 field.
	USBD_EPSTATUS_EPOUT3_Pos = 0x13
	// Bit mask of EPOUT3 field.
	USBD_EPSTATUS_EPOUT3_Msk = 0x80000
	// Bit EPOUT3.
	USBD_EPSTATUS_EPOUT3 = 0x80000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT3_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT3_DataDone = 0x1
	// Position of EPOUT4 field.
	USBD_EPSTATUS_EPOUT4_Pos = 0x14
	// Bit mask of EPOUT4 field.
	USBD_EPSTATUS_EPOUT4_Msk = 0x100000
	// Bit EPOUT4.
	USBD_EPSTATUS_EPOUT4 = 0x100000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT4_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT4_DataDone = 0x1
	// Position of EPOUT5 field.
	USBD_EPSTATUS_EPOUT5_Pos = 0x15
	// Bit mask of EPOUT5 field.
	USBD_EPSTATUS_EPOUT5_Msk = 0x200000
	// Bit EPOUT5.
	USBD_EPSTATUS_EPOUT5 = 0x200000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT5_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT5_DataDone = 0x1
	// Position of EPOUT6 field.
	USBD_EPSTATUS_EPOUT6_Pos = 0x16
	// Bit mask of EPOUT6 field.
	USBD_EPSTATUS_EPOUT6_Msk = 0x400000
	// Bit EPOUT6.
	USBD_EPSTATUS_EPOUT6 = 0x400000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT6_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT6_DataDone = 0x1
	// Position of EPOUT7 field.
	USBD_EPSTATUS_EPOUT7_Pos = 0x17
	// Bit mask of EPOUT7 field.
	USBD_EPSTATUS_EPOUT7_Msk = 0x800000
	// Bit EPOUT7.
	USBD_EPSTATUS_EPOUT7 = 0x800000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT7_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT7_DataDone = 0x1
	// Position of EPOUT8 field.
	USBD_EPSTATUS_EPOUT8_Pos = 0x18
	// Bit mask of EPOUT8 field.
	USBD_EPSTATUS_EPOUT8_Msk = 0x1000000
	// Bit EPOUT8.
	USBD_EPSTATUS_EPOUT8 = 0x1000000
	// EasyDMA registers have not been captured for this endpoint
	USBD_EPSTATUS_EPOUT8_NoData = 0x0
	// EasyDMA registers have been captured for this endpoint
	USBD_EPSTATUS_EPOUT8_DataDone = 0x1

	// EPDATASTATUS: Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)
	// Position of EPIN1 field.
	USBD_EPDATASTATUS_EPIN1_Pos = 0x1
	// Bit mask of EPIN1 field.
	USBD_EPDATASTATUS_EPIN1_Msk = 0x2
	// Bit EPIN1.
	USBD_EPDATASTATUS_EPIN1 = 0x2
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN1_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN1_DataDone = 0x1
	// Position of EPIN2 field.
	USBD_EPDATASTATUS_EPIN2_Pos = 0x2
	// Bit mask of EPIN2 field.
	USBD_EPDATASTATUS_EPIN2_Msk = 0x4
	// Bit EPIN2.
	USBD_EPDATASTATUS_EPIN2 = 0x4
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN2_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN2_DataDone = 0x1
	// Position of EPIN3 field.
	USBD_EPDATASTATUS_EPIN3_Pos = 0x3
	// Bit mask of EPIN3 field.
	USBD_EPDATASTATUS_EPIN3_Msk = 0x8
	// Bit EPIN3.
	USBD_EPDATASTATUS_EPIN3 = 0x8
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN3_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN3_DataDone = 0x1
	// Position of EPIN4 field.
	USBD_EPDATASTATUS_EPIN4_Pos = 0x4
	// Bit mask of EPIN4 field.
	USBD_EPDATASTATUS_EPIN4_Msk = 0x10
	// Bit EPIN4.
	USBD_EPDATASTATUS_EPIN4 = 0x10
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN4_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN4_DataDone = 0x1
	// Position of EPIN5 field.
	USBD_EPDATASTATUS_EPIN5_Pos = 0x5
	// Bit mask of EPIN5 field.
	USBD_EPDATASTATUS_EPIN5_Msk = 0x20
	// Bit EPIN5.
	USBD_EPDATASTATUS_EPIN5 = 0x20
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN5_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN5_DataDone = 0x1
	// Position of EPIN6 field.
	USBD_EPDATASTATUS_EPIN6_Pos = 0x6
	// Bit mask of EPIN6 field.
	USBD_EPDATASTATUS_EPIN6_Msk = 0x40
	// Bit EPIN6.
	USBD_EPDATASTATUS_EPIN6 = 0x40
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN6_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN6_DataDone = 0x1
	// Position of EPIN7 field.
	USBD_EPDATASTATUS_EPIN7_Pos = 0x7
	// Bit mask of EPIN7 field.
	USBD_EPDATASTATUS_EPIN7_Msk = 0x80
	// Bit EPIN7.
	USBD_EPDATASTATUS_EPIN7 = 0x80
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPIN7_NotDone = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPIN7_DataDone = 0x1
	// Position of EPOUT1 field.
	USBD_EPDATASTATUS_EPOUT1_Pos = 0x11
	// Bit mask of EPOUT1 field.
	USBD_EPDATASTATUS_EPOUT1_Msk = 0x20000
	// Bit EPOUT1.
	USBD_EPDATASTATUS_EPOUT1 = 0x20000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT1_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT1_Started = 0x1
	// Position of EPOUT2 field.
	USBD_EPDATASTATUS_EPOUT2_Pos = 0x12
	// Bit mask of EPOUT2 field.
	USBD_EPDATASTATUS_EPOUT2_Msk = 0x40000
	// Bit EPOUT2.
	USBD_EPDATASTATUS_EPOUT2 = 0x40000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT2_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT2_Started = 0x1
	// Position of EPOUT3 field.
	USBD_EPDATASTATUS_EPOUT3_Pos = 0x13
	// Bit mask of EPOUT3 field.
	USBD_EPDATASTATUS_EPOUT3_Msk = 0x80000
	// Bit EPOUT3.
	USBD_EPDATASTATUS_EPOUT3 = 0x80000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT3_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT3_Started = 0x1
	// Position of EPOUT4 field.
	USBD_EPDATASTATUS_EPOUT4_Pos = 0x14
	// Bit mask of EPOUT4 field.
	USBD_EPDATASTATUS_EPOUT4_Msk = 0x100000
	// Bit EPOUT4.
	USBD_EPDATASTATUS_EPOUT4 = 0x100000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT4_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT4_Started = 0x1
	// Position of EPOUT5 field.
	USBD_EPDATASTATUS_EPOUT5_Pos = 0x15
	// Bit mask of EPOUT5 field.
	USBD_EPDATASTATUS_EPOUT5_Msk = 0x200000
	// Bit EPOUT5.
	USBD_EPDATASTATUS_EPOUT5 = 0x200000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT5_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT5_Started = 0x1
	// Position of EPOUT6 field.
	USBD_EPDATASTATUS_EPOUT6_Pos = 0x16
	// Bit mask of EPOUT6 field.
	USBD_EPDATASTATUS_EPOUT6_Msk = 0x400000
	// Bit EPOUT6.
	USBD_EPDATASTATUS_EPOUT6 = 0x400000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT6_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT6_Started = 0x1
	// Position of EPOUT7 field.
	USBD_EPDATASTATUS_EPOUT7_Pos = 0x17
	// Bit mask of EPOUT7 field.
	USBD_EPDATASTATUS_EPOUT7_Msk = 0x800000
	// Bit EPOUT7.
	USBD_EPDATASTATUS_EPOUT7 = 0x800000
	// No acknowledged data transfer on this endpoint
	USBD_EPDATASTATUS_EPOUT7_NotStarted = 0x0
	// Acknowledged data transfer on this endpoint has occurred
	USBD_EPDATASTATUS_EPOUT7_Started = 0x1

	// USBADDR: Device USB address
	// Position of ADDR field.
	USBD_USBADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	USBD_USBADDR_ADDR_Msk = 0x7f

	// BMREQUESTTYPE: SETUP data, byte 0, bmRequestType
	// Position of RECIPIENT field.
	USBD_BMREQUESTTYPE_RECIPIENT_Pos = 0x0
	// Bit mask of RECIPIENT field.
	USBD_BMREQUESTTYPE_RECIPIENT_Msk = 0x1f
	// Device
	USBD_BMREQUESTTYPE_RECIPIENT_Device = 0x0
	// Interface
	USBD_BMREQUESTTYPE_RECIPIENT_Interface = 0x1
	// Endpoint
	USBD_BMREQUESTTYPE_RECIPIENT_Endpoint = 0x2
	// Other
	USBD_BMREQUESTTYPE_RECIPIENT_Other = 0x3
	// Position of TYPE field.
	USBD_BMREQUESTTYPE_TYPE_Pos = 0x5
	// Bit mask of TYPE field.
	USBD_BMREQUESTTYPE_TYPE_Msk = 0x60
	// Standard
	USBD_BMREQUESTTYPE_TYPE_Standard = 0x0
	// Class
	USBD_BMREQUESTTYPE_TYPE_Class = 0x1
	// Vendor
	USBD_BMREQUESTTYPE_TYPE_Vendor = 0x2
	// Position of DIRECTION field.
	USBD_BMREQUESTTYPE_DIRECTION_Pos = 0x7
	// Bit mask of DIRECTION field.
	USBD_BMREQUESTTYPE_DIRECTION_Msk = 0x80
	// Bit DIRECTION.
	USBD_BMREQUESTTYPE_DIRECTION = 0x80
	// Host-to-device
	USBD_BMREQUESTTYPE_DIRECTION_HostToDevice = 0x0
	// Device-to-host
	USBD_BMREQUESTTYPE_DIRECTION_DeviceToHost = 0x1

	// BREQUEST: SETUP data, byte 1, bRequest
	// Position of BREQUEST field.
	USBD_BREQUEST_BREQUEST_Pos = 0x0
	// Bit mask of BREQUEST field.
	USBD_BREQUEST_BREQUEST_Msk = 0xff
	// Standard request GET_STATUS
	USBD_BREQUEST_BREQUEST_STD_GET_STATUS = 0x0
	// Standard request CLEAR_FEATURE
	USBD_BREQUEST_BREQUEST_STD_CLEAR_FEATURE = 0x1
	// Standard request SET_FEATURE
	USBD_BREQUEST_BREQUEST_STD_SET_FEATURE = 0x3
	// Standard request SET_ADDRESS
	USBD_BREQUEST_BREQUEST_STD_SET_ADDRESS = 0x5
	// Standard request GET_DESCRIPTOR
	USBD_BREQUEST_BREQUEST_STD_GET_DESCRIPTOR = 0x6
	// Standard request SET_DESCRIPTOR
	USBD_BREQUEST_BREQUEST_STD_SET_DESCRIPTOR = 0x7
	// Standard request GET_CONFIGURATION
	USBD_BREQUEST_BREQUEST_STD_GET_CONFIGURATION = 0x8
	// Standard request SET_CONFIGURATION
	USBD_BREQUEST_BREQUEST_STD_SET_CONFIGURATION = 0x9
	// Standard request GET_INTERFACE
	USBD_BREQUEST_BREQUEST_STD_GET_INTERFACE = 0xa
	// Standard request SET_INTERFACE
	USBD_BREQUEST_BREQUEST_STD_SET_INTERFACE = 0xb
	// Standard request SYNCH_FRAME
	USBD_BREQUEST_BREQUEST_STD_SYNCH_FRAME = 0xc

	// WVALUEL: SETUP data, byte 2, LSB of wValue
	// Position of WVALUEL field.
	USBD_WVALUEL_WVALUEL_Pos = 0x0
	// Bit mask of WVALUEL field.
	USBD_WVALUEL_WVALUEL_Msk = 0xff

	// WVALUEH: SETUP data, byte 3, MSB of wValue
	// Position of WVALUEH field.
	USBD_WVALUEH_WVALUEH_Pos = 0x0
	// Bit mask of WVALUEH field.
	USBD_WVALUEH_WVALUEH_Msk = 0xff

	// WINDEXL: SETUP data, byte 4, LSB of wIndex
	// Position of WINDEXL field.
	USBD_WINDEXL_WINDEXL_Pos = 0x0
	// Bit mask of WINDEXL field.
	USBD_WINDEXL_WINDEXL_Msk = 0xff

	// WINDEXH: SETUP data, byte 5, MSB of wIndex
	// Position of WINDEXH field.
	USBD_WINDEXH_WINDEXH_Pos = 0x0
	// Bit mask of WINDEXH field.
	USBD_WINDEXH_WINDEXH_Msk = 0xff

	// WLENGTHL: SETUP data, byte 6, LSB of wLength
	// Position of WLENGTHL field.
	USBD_WLENGTHL_WLENGTHL_Pos = 0x0
	// Bit mask of WLENGTHL field.
	USBD_WLENGTHL_WLENGTHL_Msk = 0xff

	// WLENGTHH: SETUP data, byte 7, MSB of wLength
	// Position of WLENGTHH field.
	USBD_WLENGTHH_WLENGTHH_Pos = 0x0
	// Bit mask of WLENGTHH field.
	USBD_WLENGTHH_WLENGTHH_Msk = 0xff

	// SIZE.EPOUT: Description collection: Number of bytes received last in the data stage of this OUT endpoint
	// Position of SIZE field.
	USBD_SIZE_EPOUT_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	USBD_SIZE_EPOUT_SIZE_Msk = 0x7f

	// SIZE.ISOOUT: Number of bytes received last on this ISO OUT data endpoint
	// Position of SIZE field.
	USBD_SIZE_ISOOUT_SIZE_Pos = 0x0
	// Bit mask of SIZE field.
	USBD_SIZE_ISOOUT_SIZE_Msk = 0x3ff
	// Position of ZERO field.
	USBD_SIZE_ISOOUT_ZERO_Pos = 0x10
	// Bit mask of ZERO field.
	USBD_SIZE_ISOOUT_ZERO_Msk = 0x10000
	// Bit ZERO.
	USBD_SIZE_ISOOUT_ZERO = 0x10000
	// No zero-length data received, use value in SIZE
	USBD_SIZE_ISOOUT_ZERO_Normal = 0x0
	// Zero-length data received, ignore value in SIZE
	USBD_SIZE_ISOOUT_ZERO_ZeroData = 0x1

	// ENABLE: Enable USB
	// Position of ENABLE field.
	USBD_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	USBD_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	USBD_ENABLE_ENABLE = 0x1
	// USB peripheral is disabled
	USBD_ENABLE_ENABLE_Disabled = 0x0
	// USB peripheral is enabled
	USBD_ENABLE_ENABLE_Enabled = 0x1

	// USBPULLUP: Control of the USB pull-up
	// Position of CONNECT field.
	USBD_USBPULLUP_CONNECT_Pos = 0x0
	// Bit mask of CONNECT field.
	USBD_USBPULLUP_CONNECT_Msk = 0x1
	// Bit CONNECT.
	USBD_USBPULLUP_CONNECT = 0x1
	// Pull-up is disconnected
	USBD_USBPULLUP_CONNECT_Disabled = 0x0
	// Pull-up is connected to D+
	USBD_USBPULLUP_CONNECT_Enabled = 0x1

	// DPDMVALUE: State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing).
	// Position of STATE field.
	USBD_DPDMVALUE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	USBD_DPDMVALUE_STATE_Msk = 0x1f
	// D+ forced low, D- forced high (K state) for a timing preset in hardware (50 us or 5 ms, depending on bus state)
	USBD_DPDMVALUE_STATE_Resume = 0x1
	// D+ forced high, D- forced low (J state)
	USBD_DPDMVALUE_STATE_J = 0x2
	// D+ forced low, D- forced high (K state)
	USBD_DPDMVALUE_STATE_K = 0x4

	// DTOGGLE: Data toggle control and status
	// Position of EP field.
	USBD_DTOGGLE_EP_Pos = 0x0
	// Bit mask of EP field.
	USBD_DTOGGLE_EP_Msk = 0x7
	// Position of IO field.
	USBD_DTOGGLE_IO_Pos = 0x7
	// Bit mask of IO field.
	USBD_DTOGGLE_IO_Msk = 0x80
	// Bit IO.
	USBD_DTOGGLE_IO = 0x80
	// Selects OUT endpoint
	USBD_DTOGGLE_IO_Out = 0x0
	// Selects IN endpoint
	USBD_DTOGGLE_IO_In = 0x1
	// Position of VALUE field.
	USBD_DTOGGLE_VALUE_Pos = 0x8
	// Bit mask of VALUE field.
	USBD_DTOGGLE_VALUE_Msk = 0x300
	// No action on data toggle when writing the register with this value
	USBD_DTOGGLE_VALUE_Nop = 0x0
	// Data toggle is DATA0 on endpoint set by EP and IO
	USBD_DTOGGLE_VALUE_Data0 = 0x1
	// Data toggle is DATA1 on endpoint set by EP and IO
	USBD_DTOGGLE_VALUE_Data1 = 0x2

	// EPINEN: Endpoint IN enable
	// Position of IN0 field.
	USBD_EPINEN_IN0_Pos = 0x0
	// Bit mask of IN0 field.
	USBD_EPINEN_IN0_Msk = 0x1
	// Bit IN0.
	USBD_EPINEN_IN0 = 0x1
	// Disable endpoint IN 0 (no response to IN tokens)
	USBD_EPINEN_IN0_Disable = 0x0
	// Enable endpoint IN 0 (response to IN tokens)
	USBD_EPINEN_IN0_Enable = 0x1
	// Position of IN1 field.
	USBD_EPINEN_IN1_Pos = 0x1
	// Bit mask of IN1 field.
	USBD_EPINEN_IN1_Msk = 0x2
	// Bit IN1.
	USBD_EPINEN_IN1 = 0x2
	// Disable endpoint IN 1 (no response to IN tokens)
	USBD_EPINEN_IN1_Disable = 0x0
	// Enable endpoint IN 1 (response to IN tokens)
	USBD_EPINEN_IN1_Enable = 0x1
	// Position of IN2 field.
	USBD_EPINEN_IN2_Pos = 0x2
	// Bit mask of IN2 field.
	USBD_EPINEN_IN2_Msk = 0x4
	// Bit IN2.
	USBD_EPINEN_IN2 = 0x4
	// Disable endpoint IN 2 (no response to IN tokens)
	USBD_EPINEN_IN2_Disable = 0x0
	// Enable endpoint IN 2 (response to IN tokens)
	USBD_EPINEN_IN2_Enable = 0x1
	// Position of IN3 field.
	USBD_EPINEN_IN3_Pos = 0x3
	// Bit mask of IN3 field.
	USBD_EPINEN_IN3_Msk = 0x8
	// Bit IN3.
	USBD_EPINEN_IN3 = 0x8
	// Disable endpoint IN 3 (no response to IN tokens)
	USBD_EPINEN_IN3_Disable = 0x0
	// Enable endpoint IN 3 (response to IN tokens)
	USBD_EPINEN_IN3_Enable = 0x1
	// Position of IN4 field.
	USBD_EPINEN_IN4_Pos = 0x4
	// Bit mask of IN4 field.
	USBD_EPINEN_IN4_Msk = 0x10
	// Bit IN4.
	USBD_EPINEN_IN4 = 0x10
	// Disable endpoint IN 4 (no response to IN tokens)
	USBD_EPINEN_IN4_Disable = 0x0
	// Enable endpoint IN 4 (response to IN tokens)
	USBD_EPINEN_IN4_Enable = 0x1
	// Position of IN5 field.
	USBD_EPINEN_IN5_Pos = 0x5
	// Bit mask of IN5 field.
	USBD_EPINEN_IN5_Msk = 0x20
	// Bit IN5.
	USBD_EPINEN_IN5 = 0x20
	// Disable endpoint IN 5 (no response to IN tokens)
	USBD_EPINEN_IN5_Disable = 0x0
	// Enable endpoint IN 5 (response to IN tokens)
	USBD_EPINEN_IN5_Enable = 0x1
	// Position of IN6 field.
	USBD_EPINEN_IN6_Pos = 0x6
	// Bit mask of IN6 field.
	USBD_EPINEN_IN6_Msk = 0x40
	// Bit IN6.
	USBD_EPINEN_IN6 = 0x40
	// Disable endpoint IN 6 (no response to IN tokens)
	USBD_EPINEN_IN6_Disable = 0x0
	// Enable endpoint IN 6 (response to IN tokens)
	USBD_EPINEN_IN6_Enable = 0x1
	// Position of IN7 field.
	USBD_EPINEN_IN7_Pos = 0x7
	// Bit mask of IN7 field.
	USBD_EPINEN_IN7_Msk = 0x80
	// Bit IN7.
	USBD_EPINEN_IN7 = 0x80
	// Disable endpoint IN 7 (no response to IN tokens)
	USBD_EPINEN_IN7_Disable = 0x0
	// Enable endpoint IN 7 (response to IN tokens)
	USBD_EPINEN_IN7_Enable = 0x1
	// Position of ISOIN field.
	USBD_EPINEN_ISOIN_Pos = 0x8
	// Bit mask of ISOIN field.
	USBD_EPINEN_ISOIN_Msk = 0x100
	// Bit ISOIN.
	USBD_EPINEN_ISOIN = 0x100
	// Disable ISO IN endpoint 8
	USBD_EPINEN_ISOIN_Disable = 0x0
	// Enable ISO IN endpoint 8
	USBD_EPINEN_ISOIN_Enable = 0x1

	// EPOUTEN: Endpoint OUT enable
	// Position of OUT0 field.
	USBD_EPOUTEN_OUT0_Pos = 0x0
	// Bit mask of OUT0 field.
	USBD_EPOUTEN_OUT0_Msk = 0x1
	// Bit OUT0.
	USBD_EPOUTEN_OUT0 = 0x1
	// Disable endpoint OUT 0 (no response to OUT tokens)
	USBD_EPOUTEN_OUT0_Disable = 0x0
	// Enable endpoint OUT 0 (response to OUT tokens)
	USBD_EPOUTEN_OUT0_Enable = 0x1
	// Position of OUT1 field.
	USBD_EPOUTEN_OUT1_Pos = 0x1
	// Bit mask of OUT1 field.
	USBD_EPOUTEN_OUT1_Msk = 0x2
	// Bit OUT1.
	USBD_EPOUTEN_OUT1 = 0x2
	// Disable endpoint OUT 1 (no response to OUT tokens)
	USBD_EPOUTEN_OUT1_Disable = 0x0
	// Enable endpoint OUT 1 (response to OUT tokens)
	USBD_EPOUTEN_OUT1_Enable = 0x1
	// Position of OUT2 field.
	USBD_EPOUTEN_OUT2_Pos = 0x2
	// Bit mask of OUT2 field.
	USBD_EPOUTEN_OUT2_Msk = 0x4
	// Bit OUT2.
	USBD_EPOUTEN_OUT2 = 0x4
	// Disable endpoint OUT 2 (no response to OUT tokens)
	USBD_EPOUTEN_OUT2_Disable = 0x0
	// Enable endpoint OUT 2 (response to OUT tokens)
	USBD_EPOUTEN_OUT2_Enable = 0x1
	// Position of OUT3 field.
	USBD_EPOUTEN_OUT3_Pos = 0x3
	// Bit mask of OUT3 field.
	USBD_EPOUTEN_OUT3_Msk = 0x8
	// Bit OUT3.
	USBD_EPOUTEN_OUT3 = 0x8
	// Disable endpoint OUT 3 (no response to OUT tokens)
	USBD_EPOUTEN_OUT3_Disable = 0x0
	// Enable endpoint OUT 3 (response to OUT tokens)
	USBD_EPOUTEN_OUT3_Enable = 0x1
	// Position of OUT4 field.
	USBD_EPOUTEN_OUT4_Pos = 0x4
	// Bit mask of OUT4 field.
	USBD_EPOUTEN_OUT4_Msk = 0x10
	// Bit OUT4.
	USBD_EPOUTEN_OUT4 = 0x10
	// Disable endpoint OUT 4 (no response to OUT tokens)
	USBD_EPOUTEN_OUT4_Disable = 0x0
	// Enable endpoint OUT 4 (response to OUT tokens)
	USBD_EPOUTEN_OUT4_Enable = 0x1
	// Position of OUT5 field.
	USBD_EPOUTEN_OUT5_Pos = 0x5
	// Bit mask of OUT5 field.
	USBD_EPOUTEN_OUT5_Msk = 0x20
	// Bit OUT5.
	USBD_EPOUTEN_OUT5 = 0x20
	// Disable endpoint OUT 5 (no response to OUT tokens)
	USBD_EPOUTEN_OUT5_Disable = 0x0
	// Enable endpoint OUT 5 (response to OUT tokens)
	USBD_EPOUTEN_OUT5_Enable = 0x1
	// Position of OUT6 field.
	USBD_EPOUTEN_OUT6_Pos = 0x6
	// Bit mask of OUT6 field.
	USBD_EPOUTEN_OUT6_Msk = 0x40
	// Bit OUT6.
	USBD_EPOUTEN_OUT6 = 0x40
	// Disable endpoint OUT 6 (no response to OUT tokens)
	USBD_EPOUTEN_OUT6_Disable = 0x0
	// Enable endpoint OUT 6 (response to OUT tokens)
	USBD_EPOUTEN_OUT6_Enable = 0x1
	// Position of OUT7 field.
	USBD_EPOUTEN_OUT7_Pos = 0x7
	// Bit mask of OUT7 field.
	USBD_EPOUTEN_OUT7_Msk = 0x80
	// Bit OUT7.
	USBD_EPOUTEN_OUT7 = 0x80
	// Disable endpoint OUT 7 (no response to OUT tokens)
	USBD_EPOUTEN_OUT7_Disable = 0x0
	// Enable endpoint OUT 7 (response to OUT tokens)
	USBD_EPOUTEN_OUT7_Enable = 0x1
	// Position of ISOOUT field.
	USBD_EPOUTEN_ISOOUT_Pos = 0x8
	// Bit mask of ISOOUT field.
	USBD_EPOUTEN_ISOOUT_Msk = 0x100
	// Bit ISOOUT.
	USBD_EPOUTEN_ISOOUT = 0x100
	// Disable ISO OUT endpoint 8
	USBD_EPOUTEN_ISOOUT_Disable = 0x0
	// Enable ISO OUT endpoint 8
	USBD_EPOUTEN_ISOOUT_Enable = 0x1

	// EPSTALL: STALL endpoints
	// Position of EP field.
	USBD_EPSTALL_EP_Pos = 0x0
	// Bit mask of EP field.
	USBD_EPSTALL_EP_Msk = 0x7
	// Position of IO field.
	USBD_EPSTALL_IO_Pos = 0x7
	// Bit mask of IO field.
	USBD_EPSTALL_IO_Msk = 0x80
	// Bit IO.
	USBD_EPSTALL_IO = 0x80
	// Selects OUT endpoint
	USBD_EPSTALL_IO_Out = 0x0
	// Selects IN endpoint
	USBD_EPSTALL_IO_In = 0x1
	// Position of STALL field.
	USBD_EPSTALL_STALL_Pos = 0x8
	// Bit mask of STALL field.
	USBD_EPSTALL_STALL_Msk = 0x100
	// Bit STALL.
	USBD_EPSTALL_STALL = 0x100
	// Don't stall selected endpoint
	USBD_EPSTALL_STALL_UnStall = 0x0
	// Stall selected endpoint
	USBD_EPSTALL_STALL_Stall = 0x1

	// ISOSPLIT: Controls the split of ISO buffers
	// Position of SPLIT field.
	USBD_ISOSPLIT_SPLIT_Pos = 0x0
	// Bit mask of SPLIT field.
	USBD_ISOSPLIT_SPLIT_Msk = 0xffff
	// Full buffer dedicated to either iso IN or OUT
	USBD_ISOSPLIT_SPLIT_OneDir = 0x0
	// Lower half for IN, upper half for OUT
	USBD_ISOSPLIT_SPLIT_HalfIN = 0x80

	// FRAMECNTR: Returns the current value of the start of frame counter
	// Position of FRAMECNTR field.
	USBD_FRAMECNTR_FRAMECNTR_Pos = 0x0
	// Bit mask of FRAMECNTR field.
	USBD_FRAMECNTR_FRAMECNTR_Msk = 0x7ff

	// LOWPOWER: Controls USBD peripheral low power mode during USB suspend
	// Position of LOWPOWER field.
	USBD_LOWPOWER_LOWPOWER_Pos = 0x0
	// Bit mask of LOWPOWER field.
	USBD_LOWPOWER_LOWPOWER_Msk = 0x1
	// Bit LOWPOWER.
	USBD_LOWPOWER_LOWPOWER = 0x1
	// Software must write this value to exit low power mode and before performing a remote wake-up
	USBD_LOWPOWER_LOWPOWER_ForceNormal = 0x0
	// Software must write this value to enter low power mode after DMA and software have finished interacting with the USB peripheral
	USBD_LOWPOWER_LOWPOWER_LowPower = 0x1

	// ISOINCONFIG: Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent
	// Position of RESPONSE field.
	USBD_ISOINCONFIG_RESPONSE_Pos = 0x0
	// Bit mask of RESPONSE field.
	USBD_ISOINCONFIG_RESPONSE_Msk = 0x1
	// Bit RESPONSE.
	USBD_ISOINCONFIG_RESPONSE = 0x1
	// Endpoint does not respond in that case
	USBD_ISOINCONFIG_RESPONSE_NoResp = 0x0
	// Endpoint responds with a zero-length data packet in that case
	USBD_ISOINCONFIG_RESPONSE_ZeroData = 0x1

	// EPIN.PTR: Description cluster: Data pointer
	// Position of PTR field.
	USBD_EPIN_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_EPIN_PTR_PTR_Msk = 0xffffffff

	// EPIN.MAXCNT: Description cluster: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_EPIN_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_EPIN_MAXCNT_MAXCNT_Msk = 0x7f

	// EPIN.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_EPIN_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_EPIN_AMOUNT_AMOUNT_Msk = 0x7f

	// ISOIN.PTR: Data pointer
	// Position of PTR field.
	USBD_ISOIN_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_ISOIN_PTR_PTR_Msk = 0xffffffff

	// ISOIN.MAXCNT: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_ISOIN_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_ISOIN_MAXCNT_MAXCNT_Msk = 0x3ff

	// ISOIN.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_ISOIN_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_ISOIN_AMOUNT_AMOUNT_Msk = 0x3ff

	// EPOUT.PTR: Description cluster: Data pointer
	// Position of PTR field.
	USBD_EPOUT_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_EPOUT_PTR_PTR_Msk = 0xffffffff

	// EPOUT.MAXCNT: Description cluster: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_EPOUT_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_EPOUT_MAXCNT_MAXCNT_Msk = 0x7f

	// EPOUT.AMOUNT: Description cluster: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_EPOUT_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_EPOUT_AMOUNT_AMOUNT_Msk = 0x7f

	// ISOOUT.PTR: Data pointer
	// Position of PTR field.
	USBD_ISOOUT_PTR_PTR_Pos = 0x0
	// Bit mask of PTR field.
	USBD_ISOOUT_PTR_PTR_Msk = 0xffffffff

	// ISOOUT.MAXCNT: Maximum number of bytes to transfer
	// Position of MAXCNT field.
	USBD_ISOOUT_MAXCNT_MAXCNT_Pos = 0x0
	// Bit mask of MAXCNT field.
	USBD_ISOOUT_MAXCNT_MAXCNT_Msk = 0x3ff

	// ISOOUT.AMOUNT: Number of bytes transferred in the last transaction
	// Position of AMOUNT field.
	USBD_ISOOUT_AMOUNT_AMOUNT_Pos = 0x0
	// Bit mask of AMOUNT field.
	USBD_ISOOUT_AMOUNT_AMOUNT_Msk = 0x3ff
)
