// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from stm32l4r9.svd, see https://github.com/tinygo-org/stm32-svd

//go:build stm32 && stm32l4r9

/*
// STM32L4R9
*/

package stm32

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "STM32L4R9"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// System window watchdog
	IRQ_WWDG = 0

	// External interrupt/event controller
	IRQ_PVD_PVM = 1

	// Real-time clock
	IRQ_TAMP_STAMP = 2

	// Real-time clock
	IRQ_RTC_WKUP = 3

	// Flash
	IRQ_FLASH = 4

	// Reset and clock control
	IRQ_RCC = 5

	// External interrupt/event controller
	IRQ_EXTI0 = 6

	// External interrupt/event controller
	IRQ_EXTI1 = 7

	// External interrupt/event controller
	IRQ_EXTI2 = 8

	// External interrupt/event controller
	IRQ_EXTI3 = 9

	// External interrupt/event controller
	IRQ_EXTI4 = 10

	// Direct memory access controller
	IRQ_DMA1_CH1 = 11

	// Direct memory access controller
	IRQ_DMA1_CH2 = 12

	// Direct memory access controller
	IRQ_DMA1_CH3 = 13

	// Direct memory access controller
	IRQ_DMA1_CH4 = 14

	// Direct memory access controller
	IRQ_DMA1_CH5 = 15

	// Direct memory access controller
	IRQ_DMA1_CH6 = 16

	// Direct memory access controller
	IRQ_DMA1_CH7 = 17

	// Analog-to-Digital Converter
	IRQ_ADC1 = 18

	// Controller area network
	IRQ_CAN1_TX = 19

	// Controller area network
	IRQ_CAN1_RX0 = 20

	// Controller area network
	IRQ_CAN1_RX1 = 21

	// Controller area network
	IRQ_CAN1_SCE = 22

	// External interrupt/event controller
	IRQ_EXTI9_5 = 23

	// Advanced-timers
	IRQ_TIM1_BRK_TIM15 = 24

	// Advanced-timers
	IRQ_TIM1_UP_TIM16 = 25

	// Advanced-timers
	IRQ_TIM1_TRG_COM_TIM17 = 26

	// Advanced-timers
	IRQ_TIM1_CC = 27

	// General-purpose-timers
	IRQ_TIM2 = 28

	// General-purpose-timers
	IRQ_TIM3 = 29

	IRQ_TIM4 = 30

	// Inter-integrated circuit
	IRQ_I2C1_EV = 31

	// Inter-integrated circuit
	IRQ_I2C1_ER = 32

	IRQ_I2C2_EV = 33

	IRQ_I2C2_ER = 34

	// Serial peripheral interface/Inter-IC sound
	IRQ_SPI1 = 35

	IRQ_SPI2 = 36

	// Universal synchronous asynchronous receiver transmitter
	IRQ_USART1 = 37

	IRQ_USART2 = 38

	IRQ_USART3 = 39

	// External interrupt/event controller
	IRQ_EXTI15_10 = 40

	// Real-time clock
	IRQ_RTC_ALARM = 41

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT3 = 42

	// Advanced-timers
	IRQ_TIM8_BRK = 43

	// Advanced-timers
	IRQ_TIM8_UP = 44

	// Advanced-timers
	IRQ_TIM8_TRG_COM = 45

	// Advanced-timers
	IRQ_TIM8_CC = 46

	// Analog-to-Digital Converter
	IRQ_ADC3 = 47

	// Flexible memory controller
	IRQ_FMC = 48

	// Secure digital input/output interface
	IRQ_SDMMC1 = 49

	IRQ_TIM5 = 50

	IRQ_SPI3 = 51

	IRQ_UART4 = 52

	IRQ_UART5 = 53

	// Basic-timers
	IRQ_TIM6_DACUNDER = 54

	IRQ_TIM7 = 55

	IRQ_DMA2_CH1 = 56

	IRQ_DMA2_CH2 = 57

	IRQ_DMA2_CH3 = 58

	IRQ_DMA2_CH4 = 59

	IRQ_DMA2_CH5 = 60

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT0 = 61

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT1 = 62

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT2 = 63

	// Comparator
	IRQ_COMP = 64

	// Low power timer
	IRQ_LPTIM1 = 65

	IRQ_LPTIM2 = 66

	// USB on the go full speed
	IRQ_OTG_FS = 67

	IRQ_DMA2_CH6 = 68

	IRQ_DMA2_CH7 = 69

	// Universal synchronous asynchronous receiver transmitter
	IRQ_LPUART1 = 70

	// OctoSPI
	IRQ_OCTOSPI1 = 71

	IRQ_I2C3_EV = 72

	IRQ_I2C3_ER = 73

	// Serial audio interface
	IRQ_SAI1 = 74

	IRQ_SAI2 = 75

	IRQ_OCTOSPI2 = 76

	// Touch sensing controller
	IRQ_TSC = 77

	// DSI Host
	IRQ_DSIHOST = 78

	// Advanced encryption standard hardware accelerator
	IRQ_AES = 79

	// Random number generator
	IRQ_RNG_HASH = 80

	// Flexible memory controller // Floting point unit
	IRQ_FPU = 81

	// Clock recovery system
	IRQ_CRS = 82

	IRQ_I2C4_ER = 83

	IRQ_I2C4_EV = 84

	// Digital camera interface
	IRQ_DCMI = 85

	// DMA2D controller
	IRQ_DMA2D = 90

	// Liquid crystal display controller
	IRQ_LCD_TFT = 91

	// Liquid crystal display controller
	IRQ_LCD_TFT_ER = 92

	// Graphic MMU
	IRQ_GFXMMU = 93

	// DMA request multiplexer
	IRQ_DMAMUX_OVR = 94

	// Highest interrupt number on this device.
	IRQ_max = 94
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export WWDG_IRQHandler
func interruptWWDG() {
	callHandlers(IRQ_WWDG)
}

//export PVD_PVM_IRQHandler
func interruptPVD_PVM() {
	callHandlers(IRQ_PVD_PVM)
}

//export TAMP_STAMP_IRQHandler
func interruptTAMP_STAMP() {
	callHandlers(IRQ_TAMP_STAMP)
}

//export RTC_WKUP_IRQHandler
func interruptRTC_WKUP() {
	callHandlers(IRQ_RTC_WKUP)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export RCC_IRQHandler
func interruptRCC() {
	callHandlers(IRQ_RCC)
}

//export EXTI0_IRQHandler
func interruptEXTI0() {
	callHandlers(IRQ_EXTI0)
}

//export EXTI1_IRQHandler
func interruptEXTI1() {
	callHandlers(IRQ_EXTI1)
}

//export EXTI2_IRQHandler
func interruptEXTI2() {
	callHandlers(IRQ_EXTI2)
}

//export EXTI3_IRQHandler
func interruptEXTI3() {
	callHandlers(IRQ_EXTI3)
}

//export EXTI4_IRQHandler
func interruptEXTI4() {
	callHandlers(IRQ_EXTI4)
}

//export DMA1_CH1_IRQHandler
func interruptDMA1_CH1() {
	callHandlers(IRQ_DMA1_CH1)
}

//export DMA1_CH2_IRQHandler
func interruptDMA1_CH2() {
	callHandlers(IRQ_DMA1_CH2)
}

//export DMA1_CH3_IRQHandler
func interruptDMA1_CH3() {
	callHandlers(IRQ_DMA1_CH3)
}

//export DMA1_CH4_IRQHandler
func interruptDMA1_CH4() {
	callHandlers(IRQ_DMA1_CH4)
}

//export DMA1_CH5_IRQHandler
func interruptDMA1_CH5() {
	callHandlers(IRQ_DMA1_CH5)
}

//export DMA1_CH6_IRQHandler
func interruptDMA1_CH6() {
	callHandlers(IRQ_DMA1_CH6)
}

//export DMA1_CH7_IRQHandler
func interruptDMA1_CH7() {
	callHandlers(IRQ_DMA1_CH7)
}

//export ADC1_IRQHandler
func interruptADC1() {
	callHandlers(IRQ_ADC1)
}

//export CAN1_TX_IRQHandler
func interruptCAN1_TX() {
	callHandlers(IRQ_CAN1_TX)
}

//export CAN1_RX0_IRQHandler
func interruptCAN1_RX0() {
	callHandlers(IRQ_CAN1_RX0)
}

//export CAN1_RX1_IRQHandler
func interruptCAN1_RX1() {
	callHandlers(IRQ_CAN1_RX1)
}

//export CAN1_SCE_IRQHandler
func interruptCAN1_SCE() {
	callHandlers(IRQ_CAN1_SCE)
}

//export EXTI9_5_IRQHandler
func interruptEXTI9_5() {
	callHandlers(IRQ_EXTI9_5)
}

//export TIM1_BRK_TIM15_IRQHandler
func interruptTIM1_BRK_TIM15() {
	callHandlers(IRQ_TIM1_BRK_TIM15)
}

//export TIM1_UP_TIM16_IRQHandler
func interruptTIM1_UP_TIM16() {
	callHandlers(IRQ_TIM1_UP_TIM16)
}

//export TIM1_TRG_COM_TIM17_IRQHandler
func interruptTIM1_TRG_COM_TIM17() {
	callHandlers(IRQ_TIM1_TRG_COM_TIM17)
}

//export TIM1_CC_IRQHandler
func interruptTIM1_CC() {
	callHandlers(IRQ_TIM1_CC)
}

//export TIM2_IRQHandler
func interruptTIM2() {
	callHandlers(IRQ_TIM2)
}

//export TIM3_IRQHandler
func interruptTIM3() {
	callHandlers(IRQ_TIM3)
}

//export TIM4_IRQHandler
func interruptTIM4() {
	callHandlers(IRQ_TIM4)
}

//export I2C1_EV_IRQHandler
func interruptI2C1_EV() {
	callHandlers(IRQ_I2C1_EV)
}

//export I2C1_ER_IRQHandler
func interruptI2C1_ER() {
	callHandlers(IRQ_I2C1_ER)
}

//export I2C2_EV_IRQHandler
func interruptI2C2_EV() {
	callHandlers(IRQ_I2C2_EV)
}

//export I2C2_ER_IRQHandler
func interruptI2C2_ER() {
	callHandlers(IRQ_I2C2_ER)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export SPI2_IRQHandler
func interruptSPI2() {
	callHandlers(IRQ_SPI2)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export EXTI15_10_IRQHandler
func interruptEXTI15_10() {
	callHandlers(IRQ_EXTI15_10)
}

//export RTC_ALARM_IRQHandler
func interruptRTC_ALARM() {
	callHandlers(IRQ_RTC_ALARM)
}

//export DFSDM1_FLT3_IRQHandler
func interruptDFSDM1_FLT3() {
	callHandlers(IRQ_DFSDM1_FLT3)
}

//export TIM8_BRK_IRQHandler
func interruptTIM8_BRK() {
	callHandlers(IRQ_TIM8_BRK)
}

//export TIM8_UP_IRQHandler
func interruptTIM8_UP() {
	callHandlers(IRQ_TIM8_UP)
}

//export TIM8_TRG_COM_IRQHandler
func interruptTIM8_TRG_COM() {
	callHandlers(IRQ_TIM8_TRG_COM)
}

//export TIM8_CC_IRQHandler
func interruptTIM8_CC() {
	callHandlers(IRQ_TIM8_CC)
}

//export ADC3_IRQHandler
func interruptADC3() {
	callHandlers(IRQ_ADC3)
}

//export FMC_IRQHandler
func interruptFMC() {
	callHandlers(IRQ_FMC)
}

//export SDMMC1_IRQHandler
func interruptSDMMC1() {
	callHandlers(IRQ_SDMMC1)
}

//export TIM5_IRQHandler
func interruptTIM5() {
	callHandlers(IRQ_TIM5)
}

//export SPI3_IRQHandler
func interruptSPI3() {
	callHandlers(IRQ_SPI3)
}

//export UART4_IRQHandler
func interruptUART4() {
	callHandlers(IRQ_UART4)
}

//export UART5_IRQHandler
func interruptUART5() {
	callHandlers(IRQ_UART5)
}

//export TIM6_DACUNDER_IRQHandler
func interruptTIM6_DACUNDER() {
	callHandlers(IRQ_TIM6_DACUNDER)
}

//export TIM7_IRQHandler
func interruptTIM7() {
	callHandlers(IRQ_TIM7)
}

//export DMA2_CH1_IRQHandler
func interruptDMA2_CH1() {
	callHandlers(IRQ_DMA2_CH1)
}

//export DMA2_CH2_IRQHandler
func interruptDMA2_CH2() {
	callHandlers(IRQ_DMA2_CH2)
}

//export DMA2_CH3_IRQHandler
func interruptDMA2_CH3() {
	callHandlers(IRQ_DMA2_CH3)
}

//export DMA2_CH4_IRQHandler
func interruptDMA2_CH4() {
	callHandlers(IRQ_DMA2_CH4)
}

//export DMA2_CH5_IRQHandler
func interruptDMA2_CH5() {
	callHandlers(IRQ_DMA2_CH5)
}

//export DFSDM1_FLT0_IRQHandler
func interruptDFSDM1_FLT0() {
	callHandlers(IRQ_DFSDM1_FLT0)
}

//export DFSDM1_FLT1_IRQHandler
func interruptDFSDM1_FLT1() {
	callHandlers(IRQ_DFSDM1_FLT1)
}

//export DFSDM1_FLT2_IRQHandler
func interruptDFSDM1_FLT2() {
	callHandlers(IRQ_DFSDM1_FLT2)
}

//export COMP_IRQHandler
func interruptCOMP() {
	callHandlers(IRQ_COMP)
}

//export LPTIM1_IRQHandler
func interruptLPTIM1() {
	callHandlers(IRQ_LPTIM1)
}

//export LPTIM2_IRQHandler
func interruptLPTIM2() {
	callHandlers(IRQ_LPTIM2)
}

//export OTG_FS_IRQHandler
func interruptOTG_FS() {
	callHandlers(IRQ_OTG_FS)
}

//export DMA2_CH6_IRQHandler
func interruptDMA2_CH6() {
	callHandlers(IRQ_DMA2_CH6)
}

//export DMA2_CH7_IRQHandler
func interruptDMA2_CH7() {
	callHandlers(IRQ_DMA2_CH7)
}

//export LPUART1_IRQHandler
func interruptLPUART1() {
	callHandlers(IRQ_LPUART1)
}

//export OCTOSPI1_IRQHandler
func interruptOCTOSPI1() {
	callHandlers(IRQ_OCTOSPI1)
}

//export I2C3_EV_IRQHandler
func interruptI2C3_EV() {
	callHandlers(IRQ_I2C3_EV)
}

//export I2C3_ER_IRQHandler
func interruptI2C3_ER() {
	callHandlers(IRQ_I2C3_ER)
}

//export SAI1_IRQHandler
func interruptSAI1() {
	callHandlers(IRQ_SAI1)
}

//export SAI2_IRQHandler
func interruptSAI2() {
	callHandlers(IRQ_SAI2)
}

//export OCTOSPI2_IRQHandler
func interruptOCTOSPI2() {
	callHandlers(IRQ_OCTOSPI2)
}

//export TSC_IRQHandler
func interruptTSC() {
	callHandlers(IRQ_TSC)
}

//export DSIHOST_IRQHandler
func interruptDSIHOST() {
	callHandlers(IRQ_DSIHOST)
}

//export AES_IRQHandler
func interruptAES() {
	callHandlers(IRQ_AES)
}

//export RNG_HASH_IRQHandler
func interruptRNG_HASH() {
	callHandlers(IRQ_RNG_HASH)
}

//export FPU_IRQHandler
func interruptFPU() {
	callHandlers(IRQ_FPU)
}

//export CRS_IRQHandler
func interruptCRS() {
	callHandlers(IRQ_CRS)
}

//export I2C4_ER_IRQHandler
func interruptI2C4_ER() {
	callHandlers(IRQ_I2C4_ER)
}

//export I2C4_EV_IRQHandler
func interruptI2C4_EV() {
	callHandlers(IRQ_I2C4_EV)
}

//export DCMI_IRQHandler
func interruptDCMI() {
	callHandlers(IRQ_DCMI)
}

//export DMA2D_IRQHandler
func interruptDMA2D() {
	callHandlers(IRQ_DMA2D)
}

//export LCD_TFT_IRQHandler
func interruptLCD_TFT() {
	callHandlers(IRQ_LCD_TFT)
}

//export LCD_TFT_ER_IRQHandler
func interruptLCD_TFT_ER() {
	callHandlers(IRQ_LCD_TFT_ER)
}

//export GFXMMU_IRQHandler
func interruptGFXMMU() {
	callHandlers(IRQ_GFXMMU)
}

//export DMAMUX_OVR_IRQHandler
func interruptDMAMUX_OVR() {
	callHandlers(IRQ_DMAMUX_OVR)
}

// Peripherals.
var (
	// Digital-to-analog converter
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x40007400)))

	// Direct memory access controller
	DMA1 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// DMA request multiplexer
	DMAMUX1 = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x40020800)))

	// Cyclic redundancy check calculation unit
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// Liquid crystal display controller
	LTCD = (*LCD_Type)(unsafe.Pointer(uintptr(0x40016800)))

	// Touch sensing controller
	TSC = (*TSC_Type)(unsafe.Pointer(uintptr(0x40024000)))

	// Independent watchdog
	IWDG = (*IWDG_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// System window watchdog
	WWDG = (*WWDG_Type)(unsafe.Pointer(uintptr(0x40002c00)))

	// Comparator
	COMP = (*COMP_Type)(unsafe.Pointer(uintptr(0x40010200)))

	// Firewall
	FIREWALL = (*Firewall_Type)(unsafe.Pointer(uintptr(0x40011c00)))

	// Inter-integrated circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Flash
	FLASH = (*Flash_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// Debug support
	DBGMCU = (*DBGMCU_Type)(unsafe.Pointer(uintptr(0xe0042000)))

	// OctoSPI
	OCTOSPI1 = (*OctoSPI_Type)(unsafe.Pointer(uintptr(0xa0001000)))

	// Reset and clock control
	RCC = (*RCC_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Power control
	PWR = (*PWR_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// System configuration controller
	SYSCFG = (*SYSCFG_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Digital filter for sigma delta modulators
	DFSDM1 = (*DFSDM_Type)(unsafe.Pointer(uintptr(0x40016000)))

	// Random number generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x50060800)))

	// Advanced encryption standard hardware accelerator
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x50060000)))

	// Analog-to-Digital Converter
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x50040000)))

	// Analog-to-Digital Converter
	ADC_Common = (*ADC_Type)(unsafe.Pointer(uintptr(0x50040300)))

	// General-purpose I/Os
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000000)))

	// General-purpose I/Os
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000400)))

	// General-purpose I/Os
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000800)))

	// General-purpose I/Os
	GPIOI = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48002000)))

	// Serial audio interface
	SAI1 = (*SAI_Type)(unsafe.Pointer(uintptr(0x40015400)))

	// General-purpose-timers
	TIM2 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// General purpose timers
	TIM15 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// General purpose timers
	TIM16 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014400)))

	// Advanced-timers
	TIM1 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40012c00)))

	// Advanced-timers
	TIM8 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40013400)))

	// Basic-timers
	TIM6 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// Low power timer
	LPTIM1 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40007c00)))

	// Universal synchronous asynchronous receiver transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40013800)))

	// Universal synchronous asynchronous receiver transmitter
	LPUART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// Serial peripheral interface/Inter-IC sound
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Secure digital input/output interface
	SDMMC1 = (*SDIO_Type)(unsafe.Pointer(uintptr(0x50062400)))

	// External interrupt/event controller
	EXTI = (*EXTI_Type)(unsafe.Pointer(uintptr(0x40010400)))

	// Voltage reference buffer
	VREFBUF = (*VREF_Type)(unsafe.Pointer(uintptr(0x40010030)))

	// Controller area network
	CAN1 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40006400)))

	// Real-time clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40002800)))

	// USB on the go full speed
	OTG_FS_GLOBAL = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// USB on the go full speed
	OTG_FS_HOST = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000400)))

	// USB on the go full speed
	OTG_FS_DEVICE = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000800)))

	// USB on the go full speed
	OTG_FS_PWRCLK = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000e00)))

	// Single Wire Protocol Master Interface
	SWPMI1 = (*SWPMI_Type)(unsafe.Pointer(uintptr(0x40008800)))

	// Operational amplifiers
	OPAMP = (*OPAMP_Type)(unsafe.Pointer(uintptr(0x40007800)))

	// Flexible memory controller
	FMC = (*FMC_Type)(unsafe.Pointer(uintptr(0xa0000000)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Clock recovery system
	CRS = (*CRS_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Digital camera interface
	DCMI = (*DCMI_Type)(unsafe.Pointer(uintptr(0x50050000)))

	// Hash processor
	HASH = (*HASH_Type)(unsafe.Pointer(uintptr(0x50060400)))

	// DMA2D controller
	DMA2D = (*DMA2D_Type)(unsafe.Pointer(uintptr(0x4002b000)))

	// DSI Host
	DSI = (*DSI_Type)(unsafe.Pointer(uintptr(0x40016c00)))

	// Graphic MMU
	GFXMMU = (*GFXMMU_Type)(unsafe.Pointer(uintptr(0x4002c000)))

	// OctoSPI IO Manager
	OCTOSPIM = (*OCTOSPIM_Type)(unsafe.Pointer(uintptr(0x50061c00)))

	// Floting point unit
	FPU = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ef34)))

	// Memory protection unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// SysTick timer
	STK = (*STK_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// System control block
	SCB = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000ed00)))

	// Nested vectored interrupt controller
	NVIC_STIR = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000ef00)))

	// Floating point unit CPACR
	FPU_CPACR = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ed88)))

	// System control block ACTLR
	SCB_ACTRL = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000e008)))

	// General-purpose-timers
	TIM3 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000400)))

	// Direct memory access controller
	DMA2 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020400)))

	// Inter-integrated circuit
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005800)))

	// Inter-integrated circuit
	I2C3 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005c00)))

	// Inter-integrated circuit
	I2C4 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40008400)))

	// OctoSPI
	OCTOSPI2 = (*OctoSPI_Type)(unsafe.Pointer(uintptr(0xa0001400)))

	// General-purpose I/Os
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48000c00)))

	// General-purpose I/Os
	GPIOE = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48001000)))

	// General-purpose I/Os
	GPIOF = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48001400)))

	// General-purpose I/Os
	GPIOG = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48001800)))

	// General-purpose I/Os
	GPIOH = (*GPIO_Type)(unsafe.Pointer(uintptr(0x48001c00)))

	// Serial audio interface
	SAI2 = (*SAI_Type)(unsafe.Pointer(uintptr(0x40015800)))

	// General-purpose-timers
	TIM4 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000800)))

	// General-purpose-timers
	TIM5 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// General purpose timers
	TIM17 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014800)))

	// Basic-timers
	TIM7 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001400)))

	// Low power timer
	LPTIM2 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40009400)))

	// Universal synchronous asynchronous receiver transmitter
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004400)))

	// Universal synchronous asynchronous receiver transmitter
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004800)))

	// Universal synchronous asynchronous receiver transmitter
	UART4 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004c00)))

	// Universal synchronous asynchronous receiver transmitter
	UART5 = (*USART_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Serial peripheral interface/Inter-IC sound
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Serial peripheral interface/Inter-IC sound
	SPI3 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003c00)))
)

// Digital-to-analog converter
type DAC_Type struct {
	CR      volatile.Register32 // 0x0
	SWTRIGR volatile.Register32 // 0x4
	DHR12R1 volatile.Register32 // 0x8
	DHR12L1 volatile.Register32 // 0xC
	DHR8R1  volatile.Register32 // 0x10
	DHR12R2 volatile.Register32 // 0x14
	DHR12L2 volatile.Register32 // 0x18
	DHR8R2  volatile.Register32 // 0x1C
	DHR12RD volatile.Register32 // 0x20
	DHR12LD volatile.Register32 // 0x24
	DHR8RD  volatile.Register32 // 0x28
	DOR1    volatile.Register32 // 0x2C
	DOR2    volatile.Register32 // 0x30
	SR      volatile.Register32 // 0x34
	CCR     volatile.Register32 // 0x38
	MCR     volatile.Register32 // 0x3C
	SHSR1   volatile.Register32 // 0x40
	SHSR2   volatile.Register32 // 0x44
	SHHR    volatile.Register32 // 0x48
	SHRR    volatile.Register32 // 0x4C
}

// DAC.CR: control register
func (o *DAC_Type) SetCR_EN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCR_EN1() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DAC_Type) SetCR_TEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetCR_TEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetCR_TSEL1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x38)|value<<3)
}
func (o *DAC_Type) GetCR_TSEL1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x38) >> 3
}
func (o *DAC_Type) SetCR_WAVE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DAC_Type) GetCR_WAVE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DAC_Type) SetCR_MAMP1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetCR_MAMP1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetCR_DMAEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DAC_Type) GetCR_DMAEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DAC_Type) SetCR_DMAUDRIE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetCR_DMAUDRIE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetCR_CEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetCR_CEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetCR_EN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetCR_EN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DAC_Type) SetCR_TEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DAC_Type) GetCR_TEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *DAC_Type) SetCR_TSEL2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x380000)|value<<19)
}
func (o *DAC_Type) GetCR_TSEL2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x380000) >> 19
}
func (o *DAC_Type) SetCR_WAVE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00000)|value<<22)
}
func (o *DAC_Type) GetCR_WAVE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00000) >> 22
}
func (o *DAC_Type) SetCR_MAMP2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf000000)|value<<24)
}
func (o *DAC_Type) GetCR_MAMP2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf000000) >> 24
}
func (o *DAC_Type) SetCR_DMAEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *DAC_Type) GetCR_DMAEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *DAC_Type) SetCR_DMAUDRIE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetCR_DMAUDRIE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetCR_CEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *DAC_Type) GetCR_CEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}

// DAC.SWTRIGR: software trigger register
func (o *DAC_Type) SetSWTRIGR_SWTRIG1(value uint32) {
	volatile.StoreUint32(&o.SWTRIGR.Reg, volatile.LoadUint32(&o.SWTRIGR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSWTRIGR_SWTRIG1() uint32 {
	return volatile.LoadUint32(&o.SWTRIGR.Reg) & 0x1
}
func (o *DAC_Type) SetSWTRIGR_SWTRIG2(value uint32) {
	volatile.StoreUint32(&o.SWTRIGR.Reg, volatile.LoadUint32(&o.SWTRIGR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSWTRIGR_SWTRIG2() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGR.Reg) & 0x2) >> 1
}

// DAC.DHR12R1: channel1 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R1.Reg, volatile.LoadUint32(&o.DHR12R1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R1.Reg) & 0xfff
}

// DAC.DHR12L1: channel1 12-bit left-aligned data holding register
func (o *DAC_Type) SetDHR12L1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L1.Reg, volatile.LoadUint32(&o.DHR12L1.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L1_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L1.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R1: channel1 8-bit right-aligned data holding register
func (o *DAC_Type) SetDHR8R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R1.Reg, volatile.LoadUint32(&o.DHR8R1.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R1.Reg) & 0xff
}

// DAC.DHR12R2: channel2 12-bit right aligned data holding register
func (o *DAC_Type) SetDHR12R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R2.Reg, volatile.LoadUint32(&o.DHR12R2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R2.Reg) & 0xfff
}

// DAC.DHR12L2: channel2 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L2.Reg, volatile.LoadUint32(&o.DHR12L2.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L2_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L2.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R2: channel2 8-bit right-aligned data holding register
func (o *DAC_Type) SetDHR8R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R2.Reg, volatile.LoadUint32(&o.DHR8R2.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R2.Reg) & 0xff
}

// DAC.DHR12RD: Dual DAC 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff
}
func (o *DAC_Type) SetDHR12RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff0000)|value<<16)
}
func (o *DAC_Type) GetDHR12RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff0000) >> 16
}

// DAC.DHR12LD: DUAL DAC 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12LD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12LD_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff0) >> 4
}
func (o *DAC_Type) SetDHR12LD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff00000)|value<<20)
}
func (o *DAC_Type) GetDHR12LD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff00000) >> 20
}

// DAC.DHR8RD: DUAL DAC 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff
}
func (o *DAC_Type) SetDHR8RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff00)|value<<8)
}
func (o *DAC_Type) GetDHR8RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff00) >> 8
}

// DAC.DOR1: channel1 data output register
func (o *DAC_Type) SetDOR1_DACC1DOR(value uint32) {
	volatile.StoreUint32(&o.DOR1.Reg, volatile.LoadUint32(&o.DOR1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR1_DACC1DOR() uint32 {
	return volatile.LoadUint32(&o.DOR1.Reg) & 0xfff
}

// DAC.DOR2: channel2 data output register
func (o *DAC_Type) SetDOR2_DACC2DOR(value uint32) {
	volatile.StoreUint32(&o.DOR2.Reg, volatile.LoadUint32(&o.DOR2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR2_DACC2DOR() uint32 {
	return volatile.LoadUint32(&o.DOR2.Reg) & 0xfff
}

// DAC.SR: status register
func (o *DAC_Type) SetSR_DMAUDR1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetSR_DMAUDR1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetSR_CAL_FLAG1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetSR_CAL_FLAG1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetSR_BWST1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *DAC_Type) GetSR_BWST1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *DAC_Type) SetSR_DMAUDR2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetSR_DMAUDR2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetSR_CAL_FLAG2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *DAC_Type) GetSR_CAL_FLAG2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *DAC_Type) SetSR_BWST2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *DAC_Type) GetSR_BWST2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// DAC.CCR: calibration control register
func (o *DAC_Type) SetCCR_OTRIM1(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f)|value)
}
func (o *DAC_Type) GetCCR_OTRIM1() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1f
}
func (o *DAC_Type) SetCCR_OTRIM2(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DAC_Type) GetCCR_OTRIM2() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1f0000) >> 16
}

// DAC.MCR: mode control register
func (o *DAC_Type) SetMCR_MODE1(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x7)|value)
}
func (o *DAC_Type) GetMCR_MODE1() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x7
}
func (o *DAC_Type) SetMCR_MODE2(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x70000)|value<<16)
}
func (o *DAC_Type) GetMCR_MODE2() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x70000) >> 16
}

// DAC.SHSR1: Sample and Hold sample time register 1
func (o *DAC_Type) SetSHSR1_TSAMPLE1(value uint32) {
	volatile.StoreUint32(&o.SHSR1.Reg, volatile.LoadUint32(&o.SHSR1.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR1_TSAMPLE1() uint32 {
	return volatile.LoadUint32(&o.SHSR1.Reg) & 0x3ff
}

// DAC.SHSR2: Sample and Hold sample time register 2
func (o *DAC_Type) SetSHSR2_TSAMPLE2(value uint32) {
	volatile.StoreUint32(&o.SHSR2.Reg, volatile.LoadUint32(&o.SHSR2.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR2_TSAMPLE2() uint32 {
	return volatile.LoadUint32(&o.SHSR2.Reg) & 0x3ff
}

// DAC.SHHR: Sample and Hold hold time register
func (o *DAC_Type) SetSHHR_THOLD1(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHHR_THOLD1() uint32 {
	return volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff
}
func (o *DAC_Type) SetSHHR_THOLD2(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DAC_Type) GetSHHR_THOLD2() uint32 {
	return (volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff0000) >> 16
}

// DAC.SHRR: Sample and Hold refresh time register
func (o *DAC_Type) SetSHRR_TREFRESH1(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetSHRR_TREFRESH1() uint32 {
	return volatile.LoadUint32(&o.SHRR.Reg) & 0xff
}
func (o *DAC_Type) SetSHRR_TREFRESH2(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff0000)|value<<16)
}
func (o *DAC_Type) GetSHRR_TREFRESH2() uint32 {
	return (volatile.LoadUint32(&o.SHRR.Reg) & 0xff0000) >> 16
}

// Direct memory access controller
type DMA_Type struct {
	ISR    volatile.Register32 // 0x0
	IFCR   volatile.Register32 // 0x4
	CCR1   volatile.Register32 // 0x8
	CNDTR1 volatile.Register32 // 0xC
	CPAR1  volatile.Register32 // 0x10
	CMAR1  volatile.Register32 // 0x14
	_      [4]byte
	CCR2   volatile.Register32 // 0x1C
	CNDTR2 volatile.Register32 // 0x20
	CPAR2  volatile.Register32 // 0x24
	CMAR2  volatile.Register32 // 0x28
	_      [4]byte
	CCR3   volatile.Register32 // 0x30
	CNDTR3 volatile.Register32 // 0x34
	CPAR3  volatile.Register32 // 0x38
	CMAR3  volatile.Register32 // 0x3C
	_      [4]byte
	CCR4   volatile.Register32 // 0x44
	CNDTR4 volatile.Register32 // 0x48
	CPAR4  volatile.Register32 // 0x4C
	CMAR4  volatile.Register32 // 0x50
	_      [4]byte
	CCR5   volatile.Register32 // 0x58
	CNDTR5 volatile.Register32 // 0x5C
	CPAR5  volatile.Register32 // 0x60
	CMAR5  volatile.Register32 // 0x64
	_      [4]byte
	CCR6   volatile.Register32 // 0x6C
	CNDTR6 volatile.Register32 // 0x70
	CPAR6  volatile.Register32 // 0x74
	CMAR6  volatile.Register32 // 0x78
	_      [4]byte
	CCR7   volatile.Register32 // 0x80
	CNDTR7 volatile.Register32 // 0x84
	CPAR7  volatile.Register32 // 0x88
	CMAR7  volatile.Register32 // 0x8C
}

// DMA.ISR: interrupt status register
func (o *DMA_Type) SetISR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetISR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetISR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetISR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetISR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetISR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetISR_GIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetISR_GIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetISR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetISR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetISR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetISR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetISR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetISR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetISR_GIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetISR_GIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetISR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetISR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetISR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetISR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetISR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetISR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetISR_GIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetISR_GIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetISR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetISR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetISR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetISR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetISR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetISR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetISR_GIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetISR_GIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetISR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetISR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetISR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetISR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetISR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetISR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetISR_GIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetISR_GIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetISR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetISR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetISR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetISR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetISR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetISR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetISR_GIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetISR_GIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetISR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetISR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetISR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetISR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetISR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetISR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetISR_GIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetISR_GIF1() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// DMA.IFCR: interrupt flag clear register
func (o *DMA_Type) SetIFCR_CTEIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetIFCR_CTEIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetIFCR_CHTIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetIFCR_CHTIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetIFCR_CTCIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetIFCR_CTCIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetIFCR_CGIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetIFCR_CGIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetIFCR_CTEIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetIFCR_CTEIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetIFCR_CHTIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetIFCR_CHTIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetIFCR_CTCIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetIFCR_CTCIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetIFCR_CGIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetIFCR_CGIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetIFCR_CTEIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetIFCR_CTEIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetIFCR_CHTIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetIFCR_CHTIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetIFCR_CTCIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetIFCR_CTCIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetIFCR_CGIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetIFCR_CGIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetIFCR_CTEIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetIFCR_CTEIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetIFCR_CHTIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetIFCR_CHTIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetIFCR_CTCIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetIFCR_CTCIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetIFCR_CGIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIFCR_CGIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetIFCR_CTEIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetIFCR_CTEIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetIFCR_CHTIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetIFCR_CHTIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetIFCR_CTCIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetIFCR_CTCIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetIFCR_CGIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetIFCR_CGIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetIFCR_CTEIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetIFCR_CTEIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetIFCR_CHTIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIFCR_CHTIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetIFCR_CTCIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIFCR_CTCIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIFCR_CGIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIFCR_CGIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIFCR_CTEIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIFCR_CTEIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIFCR_CHTIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIFCR_CHTIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIFCR_CTCIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIFCR_CTCIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIFCR_CGIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIFCR_CGIF1() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}

// DMA.CCR1: channel x configuration register
func (o *DMA_Type) SetCCR1_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR1_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR1_PL(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR1_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR1_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR1_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR1_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR1_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR1_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR1_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR1_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR1_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR1_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR1_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR1_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR1_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR1_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR1_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR1_EN(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR1_EN() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0x1
}

// DMA.CNDTR1: channel x number of data register
func (o *DMA_Type) SetCNDTR1_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR1.Reg, volatile.LoadUint32(&o.CNDTR1.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR1_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR1.Reg) & 0xffff
}

// DMA.CPAR1: channel x peripheral address register
func (o *DMA_Type) SetCPAR1(value uint32) {
	volatile.StoreUint32(&o.CPAR1.Reg, value)
}
func (o *DMA_Type) GetCPAR1() uint32 {
	return volatile.LoadUint32(&o.CPAR1.Reg)
}

// DMA.CMAR1: channel x memory address register
func (o *DMA_Type) SetCMAR1(value uint32) {
	volatile.StoreUint32(&o.CMAR1.Reg, value)
}
func (o *DMA_Type) GetCMAR1() uint32 {
	return volatile.LoadUint32(&o.CMAR1.Reg)
}

// DMA.CCR2: channel x configuration register
func (o *DMA_Type) SetCCR2_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR2_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR2_PL(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR2_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR2_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR2_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR2_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR2_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR2_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR2_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR2_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR2_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR2_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR2_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR2_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR2_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR2_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR2_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR2_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR2_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR2_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR2_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR2_EN(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR2_EN() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0x1
}

// DMA.CNDTR2: channel x number of data register
func (o *DMA_Type) SetCNDTR2_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR2.Reg, volatile.LoadUint32(&o.CNDTR2.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR2_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR2.Reg) & 0xffff
}

// DMA.CPAR2: channel x peripheral address register
func (o *DMA_Type) SetCPAR2(value uint32) {
	volatile.StoreUint32(&o.CPAR2.Reg, value)
}
func (o *DMA_Type) GetCPAR2() uint32 {
	return volatile.LoadUint32(&o.CPAR2.Reg)
}

// DMA.CMAR2: channel x memory address register
func (o *DMA_Type) SetCMAR2(value uint32) {
	volatile.StoreUint32(&o.CMAR2.Reg, value)
}
func (o *DMA_Type) GetCMAR2() uint32 {
	return volatile.LoadUint32(&o.CMAR2.Reg)
}

// DMA.CCR3: channel x configuration register
func (o *DMA_Type) SetCCR3_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR3_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR3_PL(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR3_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR3_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR3_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR3_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR3_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR3_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR3_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR3_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR3_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR3_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR3_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR3_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR3_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR3_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR3_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR3_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR3_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR3_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR3_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR3.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR3_EN(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR3_EN() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg) & 0x1
}

// DMA.CNDTR3: channel x number of data register
func (o *DMA_Type) SetCNDTR3_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR3.Reg, volatile.LoadUint32(&o.CNDTR3.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR3_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR3.Reg) & 0xffff
}

// DMA.CPAR3: channel x peripheral address register
func (o *DMA_Type) SetCPAR3(value uint32) {
	volatile.StoreUint32(&o.CPAR3.Reg, value)
}
func (o *DMA_Type) GetCPAR3() uint32 {
	return volatile.LoadUint32(&o.CPAR3.Reg)
}

// DMA.CMAR3: channel x memory address register
func (o *DMA_Type) SetCMAR3(value uint32) {
	volatile.StoreUint32(&o.CMAR3.Reg, value)
}
func (o *DMA_Type) GetCMAR3() uint32 {
	return volatile.LoadUint32(&o.CMAR3.Reg)
}

// DMA.CCR4: channel x configuration register
func (o *DMA_Type) SetCCR4_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR4_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR4_PL(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR4_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR4_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR4_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR4_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR4_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR4_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR4_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR4_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR4_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR4_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR4_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR4_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR4_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR4_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR4_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR4_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR4_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR4_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR4_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR4.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR4_EN(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR4_EN() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg) & 0x1
}

// DMA.CNDTR4: channel x number of data register
func (o *DMA_Type) SetCNDTR4_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR4.Reg, volatile.LoadUint32(&o.CNDTR4.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR4_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR4.Reg) & 0xffff
}

// DMA.CPAR4: channel x peripheral address register
func (o *DMA_Type) SetCPAR4(value uint32) {
	volatile.StoreUint32(&o.CPAR4.Reg, value)
}
func (o *DMA_Type) GetCPAR4() uint32 {
	return volatile.LoadUint32(&o.CPAR4.Reg)
}

// DMA.CMAR4: channel x memory address register
func (o *DMA_Type) SetCMAR4(value uint32) {
	volatile.StoreUint32(&o.CMAR4.Reg, value)
}
func (o *DMA_Type) GetCMAR4() uint32 {
	return volatile.LoadUint32(&o.CMAR4.Reg)
}

// DMA.CCR5: channel x configuration register
func (o *DMA_Type) SetCCR5_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR5_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR5_PL(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR5_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR5_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR5_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR5_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR5_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR5_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR5_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR5_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR5_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR5_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR5_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR5_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR5_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR5_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR5_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR5_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR5_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR5_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR5_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR5_EN(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR5_EN() uint32 {
	return volatile.LoadUint32(&o.CCR5.Reg) & 0x1
}

// DMA.CNDTR5: channel x number of data register
func (o *DMA_Type) SetCNDTR5_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR5.Reg, volatile.LoadUint32(&o.CNDTR5.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR5_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR5.Reg) & 0xffff
}

// DMA.CPAR5: channel x peripheral address register
func (o *DMA_Type) SetCPAR5(value uint32) {
	volatile.StoreUint32(&o.CPAR5.Reg, value)
}
func (o *DMA_Type) GetCPAR5() uint32 {
	return volatile.LoadUint32(&o.CPAR5.Reg)
}

// DMA.CMAR5: channel x memory address register
func (o *DMA_Type) SetCMAR5(value uint32) {
	volatile.StoreUint32(&o.CMAR5.Reg, value)
}
func (o *DMA_Type) GetCMAR5() uint32 {
	return volatile.LoadUint32(&o.CMAR5.Reg)
}

// DMA.CCR6: channel x configuration register
func (o *DMA_Type) SetCCR6_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR6_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR6_PL(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR6_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR6_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR6_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR6_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR6_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR6_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR6_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR6_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR6_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR6_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR6_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR6_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR6_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR6_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR6_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR6_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR6_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR6_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR6_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR6.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR6_EN(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR6_EN() uint32 {
	return volatile.LoadUint32(&o.CCR6.Reg) & 0x1
}

// DMA.CNDTR6: channel x number of data register
func (o *DMA_Type) SetCNDTR6_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR6.Reg, volatile.LoadUint32(&o.CNDTR6.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR6_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR6.Reg) & 0xffff
}

// DMA.CPAR6: channel x peripheral address register
func (o *DMA_Type) SetCPAR6(value uint32) {
	volatile.StoreUint32(&o.CPAR6.Reg, value)
}
func (o *DMA_Type) GetCPAR6() uint32 {
	return volatile.LoadUint32(&o.CPAR6.Reg)
}

// DMA.CMAR6: channel x memory address register
func (o *DMA_Type) SetCMAR6(value uint32) {
	volatile.StoreUint32(&o.CMAR6.Reg, value)
}
func (o *DMA_Type) GetCMAR6() uint32 {
	return volatile.LoadUint32(&o.CMAR6.Reg)
}

// DMA.CCR7: channel x configuration register
func (o *DMA_Type) SetCCR7_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetCCR7_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetCCR7_PL(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_Type) GetCCR7_PL() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x3000) >> 12
}
func (o *DMA_Type) SetCCR7_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_Type) GetCCR7_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0xc00) >> 10
}
func (o *DMA_Type) SetCCR7_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x300)|value<<8)
}
func (o *DMA_Type) GetCCR7_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x300) >> 8
}
func (o *DMA_Type) SetCCR7_MINC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCCR7_MINC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCCR7_PINC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCCR7_PINC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCCR7_CIRC(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCCR7_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCCR7_DIR(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCCR7_DIR() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCCR7_TEIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetCCR7_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetCCR7_HTIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCCR7_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCCR7_TCIE(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCCR7_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CCR7.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCCR7_EN(value uint32) {
	volatile.StoreUint32(&o.CCR7.Reg, volatile.LoadUint32(&o.CCR7.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCCR7_EN() uint32 {
	return volatile.LoadUint32(&o.CCR7.Reg) & 0x1
}

// DMA.CNDTR7: channel x number of data register
func (o *DMA_Type) SetCNDTR7_NDT(value uint32) {
	volatile.StoreUint32(&o.CNDTR7.Reg, volatile.LoadUint32(&o.CNDTR7.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCNDTR7_NDT() uint32 {
	return volatile.LoadUint32(&o.CNDTR7.Reg) & 0xffff
}

// DMA.CPAR7: channel x peripheral address register
func (o *DMA_Type) SetCPAR7(value uint32) {
	volatile.StoreUint32(&o.CPAR7.Reg, value)
}
func (o *DMA_Type) GetCPAR7() uint32 {
	return volatile.LoadUint32(&o.CPAR7.Reg)
}

// DMA.CMAR7: channel x memory address register
func (o *DMA_Type) SetCMAR7(value uint32) {
	volatile.StoreUint32(&o.CMAR7.Reg, value)
}
func (o *DMA_Type) GetCMAR7() uint32 {
	return volatile.LoadUint32(&o.CMAR7.Reg)
}

// DMA request multiplexer
type DMAMUX_Type struct {
	C0CR  volatile.Register32 // 0x0
	C1CR  volatile.Register32 // 0x4
	C2CR  volatile.Register32 // 0x8
	C3CR  volatile.Register32 // 0xC
	C4CR  volatile.Register32 // 0x10
	C5CR  volatile.Register32 // 0x14
	C6CR  volatile.Register32 // 0x18
	C7CR  volatile.Register32 // 0x1C
	C8CR  volatile.Register32 // 0x20
	C9CR  volatile.Register32 // 0x24
	C10CR volatile.Register32 // 0x28
	C11CR volatile.Register32 // 0x2C
	C12CR volatile.Register32 // 0x30
	C13CR volatile.Register32 // 0x34
	_     [72]byte
	CSR   volatile.Register32 // 0x80
	CFR   volatile.Register32 // 0x84
	_     [120]byte
	RG0CR volatile.Register32 // 0x100
	RG1CR volatile.Register32 // 0x104
	RG2CR volatile.Register32 // 0x108
	RG3CR volatile.Register32 // 0x10C
	_     [48]byte
	RGSR  volatile.Register32 // 0x140
	RGCFR volatile.Register32 // 0x144
}

// DMAMUX.C0CR: channel 0 configuration register
func (o *DMAMUX_Type) SetC0CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC0CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC0CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC0CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC0CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC0CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC0CR_SE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC0CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC0CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC0CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC0CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC0CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC0CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC0CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C0CR.Reg) & 0x7f
}

// DMAMUX.C1CR: channel 1 configuration register
func (o *DMAMUX_Type) SetC1CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC1CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC1CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC1CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC1CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC1CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC1CR_SE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC1CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC1CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC1CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC1CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC1CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC1CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC1CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C1CR.Reg) & 0x7f
}

// DMAMUX.C2CR: channel 2 configuration register
func (o *DMAMUX_Type) SetC2CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC2CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC2CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC2CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC2CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC2CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC2CR_SE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC2CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC2CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC2CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC2CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC2CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC2CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC2CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C2CR.Reg) & 0x7f
}

// DMAMUX.C3CR: channel 3 configuration register
func (o *DMAMUX_Type) SetC3CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC3CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC3CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC3CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC3CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC3CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC3CR_SE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC3CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC3CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC3CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC3CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC3CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC3CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC3CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C3CR.Reg) & 0x7f
}

// DMAMUX.C4CR: channel 4 configuration register
func (o *DMAMUX_Type) SetC4CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC4CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC4CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC4CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC4CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC4CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC4CR_SE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC4CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC4CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC4CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC4CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC4CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC4CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC4CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C4CR.Reg) & 0x7f
}

// DMAMUX.C5CR: channel 5 configuration register
func (o *DMAMUX_Type) SetC5CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC5CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC5CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC5CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC5CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC5CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC5CR_SE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC5CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC5CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC5CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC5CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC5CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC5CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC5CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C5CR.Reg) & 0x7f
}

// DMAMUX.C6CR: channel 6 configuration register
func (o *DMAMUX_Type) SetC6CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC6CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC6CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC6CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC6CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC6CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC6CR_SE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC6CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC6CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC6CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC6CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC6CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC6CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC6CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C6CR.Reg) & 0x7f
}

// DMAMUX.C7CR: channel 7 configuration register
func (o *DMAMUX_Type) SetC7CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC7CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC7CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC7CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC7CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC7CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC7CR_SE(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC7CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC7CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC7CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC7CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC7CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C7CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC7CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C7CR.Reg, volatile.LoadUint32(&o.C7CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC7CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C7CR.Reg) & 0x7f
}

// DMAMUX.C8CR: channel 8 configuration register
func (o *DMAMUX_Type) SetC8CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC8CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC8CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC8CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC8CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC8CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC8CR_SE(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC8CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC8CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC8CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC8CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC8CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C8CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC8CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C8CR.Reg, volatile.LoadUint32(&o.C8CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC8CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C8CR.Reg) & 0x7f
}

// DMAMUX.C9CR: channel 9 configuration register
func (o *DMAMUX_Type) SetC9CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC9CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC9CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC9CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC9CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC9CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC9CR_SE(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC9CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC9CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC9CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC9CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC9CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C9CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC9CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C9CR.Reg, volatile.LoadUint32(&o.C9CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC9CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C9CR.Reg) & 0x7f
}

// DMAMUX.C10CR: channel 10 configuration register
func (o *DMAMUX_Type) SetC10CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC10CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC10CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC10CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC10CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC10CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC10CR_SE(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC10CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC10CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC10CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC10CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC10CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C10CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC10CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C10CR.Reg, volatile.LoadUint32(&o.C10CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC10CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C10CR.Reg) & 0x7f
}

// DMAMUX.C11CR: channel 11 configuration register
func (o *DMAMUX_Type) SetC11CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC11CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC11CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC11CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC11CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC11CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC11CR_SE(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC11CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC11CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC11CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC11CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC11CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C11CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC11CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C11CR.Reg, volatile.LoadUint32(&o.C11CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC11CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C11CR.Reg) & 0x7f
}

// DMAMUX.C12CR: channel 12 configuration register
func (o *DMAMUX_Type) SetC12CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC12CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC12CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC12CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC12CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC12CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC12CR_SE(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC12CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC12CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC12CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC12CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC12CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C12CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC12CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C12CR.Reg, volatile.LoadUint32(&o.C12CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC12CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C12CR.Reg) & 0x7f
}

// DMAMUX.C13CR: channel 13 configuration register
func (o *DMAMUX_Type) SetC13CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC13CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x1f000000) >> 24
}
func (o *DMAMUX_Type) SetC13CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC13CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC13CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC13CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC13CR_SE(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC13CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC13CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC13CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC13CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC13CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C13CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC13CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C13CR.Reg, volatile.LoadUint32(&o.C13CR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetC13CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C13CR.Reg) & 0x7f
}

// DMAMUX.CSR: channel status register
func (o *DMAMUX_Type) SetCSR_SOF0(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetCSR_SOF0() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *DMAMUX_Type) SetCSR_SOF1(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetCSR_SOF1() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetCSR_SOF2(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetCSR_SOF2() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetCSR_SOF3(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetCSR_SOF3() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetCSR_SOF4(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetCSR_SOF4() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetCSR_SOF5(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetCSR_SOF5() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetCSR_SOF6(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCSR_SOF6() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCSR_SOF7(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCSR_SOF7() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}
func (o *DMAMUX_Type) SetCSR_SOF8(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCSR_SOF8() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCSR_SOF9(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCSR_SOF9() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCSR_SOF10(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x400)|value<<10)
}
func (o *DMAMUX_Type) GetCSR_SOF10() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x400) >> 10
}
func (o *DMAMUX_Type) SetCSR_SOF11(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800)|value<<11)
}
func (o *DMAMUX_Type) GetCSR_SOF11() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800) >> 11
}
func (o *DMAMUX_Type) SetCSR_SOF12(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAMUX_Type) GetCSR_SOF12() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000) >> 12
}
func (o *DMAMUX_Type) SetCSR_SOF13(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAMUX_Type) GetCSR_SOF13() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000) >> 13
}

// DMAMUX.CFR: clear flag register
func (o *DMAMUX_Type) SetCFR_CSOF0(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetCFR_CSOF0() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x1
}
func (o *DMAMUX_Type) SetCFR_CSOF1(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetCFR_CSOF1() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetCFR_CSOF2(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetCFR_CSOF2() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetCFR_CSOF3(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetCFR_CSOF3() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetCFR_CSOF4(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x10)|value<<4)
}
func (o *DMAMUX_Type) GetCFR_CSOF4() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x10) >> 4
}
func (o *DMAMUX_Type) SetCFR_CSOF5(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x20)|value<<5)
}
func (o *DMAMUX_Type) GetCFR_CSOF5() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x20) >> 5
}
func (o *DMAMUX_Type) SetCFR_CSOF6(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x40)|value<<6)
}
func (o *DMAMUX_Type) GetCFR_CSOF6() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x40) >> 6
}
func (o *DMAMUX_Type) SetCFR_CSOF7(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x80)|value<<7)
}
func (o *DMAMUX_Type) GetCFR_CSOF7() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x80) >> 7
}
func (o *DMAMUX_Type) SetCFR_CSOF8(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetCFR_CSOF8() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetCFR_CSOF9(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetCFR_CSOF9() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetCFR_CSOF10(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x400)|value<<10)
}
func (o *DMAMUX_Type) GetCFR_CSOF10() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x400) >> 10
}
func (o *DMAMUX_Type) SetCFR_CSOF11(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x800)|value<<11)
}
func (o *DMAMUX_Type) GetCFR_CSOF11() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x800) >> 11
}
func (o *DMAMUX_Type) SetCFR_CSOF12(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAMUX_Type) GetCFR_CSOF12() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x1000) >> 12
}
func (o *DMAMUX_Type) SetCFR_CSOF13(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAMUX_Type) GetCFR_CSOF13() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x2000) >> 13
}

// DMAMUX.RG0CR: request generator channel 0 configuration register
func (o *DMAMUX_Type) SetRG0CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG0CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG0CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG0CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG0CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG0CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG0CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG0CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG0CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG0CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG0CR.Reg) & 0x1f
}

// DMAMUX.RG1CR: request generator channel 1 configuration register
func (o *DMAMUX_Type) SetRG1CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG1CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG1CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG1CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG1CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG1CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG1CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG1CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG1CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG1CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG1CR.Reg) & 0x1f
}

// DMAMUX.RG2CR: request generator channel 2 configuration register
func (o *DMAMUX_Type) SetRG2CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG2CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG2CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG2CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG2CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG2CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG2CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG2CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG2CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG2CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG2CR.Reg) & 0x1f
}

// DMAMUX.RG3CR: request generator channel 3 configuration register
func (o *DMAMUX_Type) SetRG3CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG3CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetRG3CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG3CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG3CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG3CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG3CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG3CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG3CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG3CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG3CR.Reg) & 0x1f
}

// DMAMUX.RGSR: request generator interrupt status register
func (o *DMAMUX_Type) SetRGSR_OF3(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetRGSR_OF3() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetRGSR_OF2(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetRGSR_OF2() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetRGSR_OF1(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetRGSR_OF1() uint32 {
	return (volatile.LoadUint32(&o.RGSR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetRGSR_OF0(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetRGSR_OF0() uint32 {
	return volatile.LoadUint32(&o.RGSR.Reg) & 0x1
}

// DMAMUX.RGCFR: request generator interrupt clear flag register
func (o *DMAMUX_Type) SetRGCFR_COF3(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x8)|value<<3)
}
func (o *DMAMUX_Type) GetRGCFR_COF3() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x8) >> 3
}
func (o *DMAMUX_Type) SetRGCFR_COF2(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x4)|value<<2)
}
func (o *DMAMUX_Type) GetRGCFR_COF2() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x4) >> 2
}
func (o *DMAMUX_Type) SetRGCFR_COF1(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x2)|value<<1)
}
func (o *DMAMUX_Type) GetRGCFR_COF1() uint32 {
	return (volatile.LoadUint32(&o.RGCFR.Reg) & 0x2) >> 1
}
func (o *DMAMUX_Type) SetRGCFR_COF0(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0x1)|value)
}
func (o *DMAMUX_Type) GetRGCFR_COF0() uint32 {
	return volatile.LoadUint32(&o.RGCFR.Reg) & 0x1
}

// Cyclic redundancy check calculation unit
type CRC_Type struct {
	DR   volatile.Register32 // 0x0
	IDR  volatile.Register32 // 0x4
	CR   volatile.Register32 // 0x8
	_    [4]byte
	INIT volatile.Register32 // 0x10
	POL  volatile.Register32 // 0x14
}

// CRC.DR: Data register
func (o *CRC_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *CRC_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// CRC.IDR: Independent data register
func (o *CRC_Type) SetIDR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xff)|value)
}
func (o *CRC_Type) GetIDR() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0xff
}

// CRC.CR: Control register
func (o *CRC_Type) SetCR_REV_OUT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCR_REV_OUT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCR_REV_IN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *CRC_Type) GetCR_REV_IN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *CRC_Type) SetCR_POLYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *CRC_Type) GetCR_POLYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *CRC_Type) SetCR_RESET(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRC_Type) GetCR_RESET() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// CRC.INIT: Initial CRC value
func (o *CRC_Type) SetINIT(value uint32) {
	volatile.StoreUint32(&o.INIT.Reg, value)
}
func (o *CRC_Type) GetINIT() uint32 {
	return volatile.LoadUint32(&o.INIT.Reg)
}

// CRC.POL: polynomial
func (o *CRC_Type) SetPOL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, value)
}
func (o *CRC_Type) GetPOL() uint32 {
	return volatile.LoadUint32(&o.POL.Reg)
}

// Liquid crystal display controller
type LCD_Type struct {
	_        [8]byte
	SSCR     volatile.Register32 // 0x8
	BPCR     volatile.Register32 // 0xC
	AWCR     volatile.Register32 // 0x10
	TWCR     volatile.Register32 // 0x14
	GCR      volatile.Register32 // 0x18
	_        [8]byte
	SRCR     volatile.Register32 // 0x24
	_        [4]byte
	BCCR     volatile.Register32 // 0x2C
	_        [4]byte
	IER      volatile.Register32 // 0x34
	ISR      volatile.Register32 // 0x38
	ICR      volatile.Register32 // 0x3C
	LIPCR    volatile.Register32 // 0x40
	CPSR     volatile.Register32 // 0x44
	CDSR     volatile.Register32 // 0x48
	_        [56]byte
	L1CR     volatile.Register32 // 0x84
	L1WHPCR  volatile.Register32 // 0x88
	L1WVPCR  volatile.Register32 // 0x8C
	L1CKCR   volatile.Register32 // 0x90
	L1PFCR   volatile.Register32 // 0x94
	L1CACR   volatile.Register32 // 0x98
	L1DCCR   volatile.Register32 // 0x9C
	L1BFCR   volatile.Register32 // 0xA0
	_        [8]byte
	L1CFBAR  volatile.Register32 // 0xAC
	L1CFBLR  volatile.Register32 // 0xB0
	L1CFBLNR volatile.Register32 // 0xB4
	_        [12]byte
	L1CLUTWR volatile.Register32 // 0xC4
	_        [60]byte
	L2CR     volatile.Register32 // 0x104
	L2WHPCR  volatile.Register32 // 0x108
	L2WVPCR  volatile.Register32 // 0x10C
	L2CKCR   volatile.Register32 // 0x110
	L2PFCR   volatile.Register32 // 0x114
	L2CACR   volatile.Register32 // 0x118
	L2DCCR   volatile.Register32 // 0x11C
	_        [4]byte
	L2BFCR   volatile.Register32 // 0x124
	_        [4]byte
	L2CFBAR  volatile.Register32 // 0x12C
	L2CFBLR  volatile.Register32 // 0x130
	L2CFBLNR volatile.Register32 // 0x134
	_        [12]byte
	L2CLUTWR volatile.Register32 // 0x144
}

// LCD.SSCR: LTDC Synchronization Size Configuration Register
func (o *LCD_Type) SetSSCR_VSH(value uint32) {
	volatile.StoreUint32(&o.SSCR.Reg, volatile.LoadUint32(&o.SSCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetSSCR_VSH() uint32 {
	return volatile.LoadUint32(&o.SSCR.Reg) & 0x7ff
}
func (o *LCD_Type) SetSSCR_HSW(value uint32) {
	volatile.StoreUint32(&o.SSCR.Reg, volatile.LoadUint32(&o.SSCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LCD_Type) GetSSCR_HSW() uint32 {
	return (volatile.LoadUint32(&o.SSCR.Reg) & 0xfff0000) >> 16
}

// LCD.BPCR: LTDC Back Porch Configuration Register
func (o *LCD_Type) SetBPCR_AVBP(value uint32) {
	volatile.StoreUint32(&o.BPCR.Reg, volatile.LoadUint32(&o.BPCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetBPCR_AVBP() uint32 {
	return volatile.LoadUint32(&o.BPCR.Reg) & 0x7ff
}
func (o *LCD_Type) SetBPCR_AHBP(value uint32) {
	volatile.StoreUint32(&o.BPCR.Reg, volatile.LoadUint32(&o.BPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LCD_Type) GetBPCR_AHBP() uint32 {
	return (volatile.LoadUint32(&o.BPCR.Reg) & 0xfff0000) >> 16
}

// LCD.AWCR: LTDC Active Width Configuration Register
func (o *LCD_Type) SetAWCR_AAH(value uint32) {
	volatile.StoreUint32(&o.AWCR.Reg, volatile.LoadUint32(&o.AWCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetAWCR_AAH() uint32 {
	return volatile.LoadUint32(&o.AWCR.Reg) & 0x7ff
}
func (o *LCD_Type) SetAWCR_AAW(value uint32) {
	volatile.StoreUint32(&o.AWCR.Reg, volatile.LoadUint32(&o.AWCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LCD_Type) GetAWCR_AAW() uint32 {
	return (volatile.LoadUint32(&o.AWCR.Reg) & 0xfff0000) >> 16
}

// LCD.TWCR: LTDC Total Width Configuration Register
func (o *LCD_Type) SetTWCR_TOTALH(value uint32) {
	volatile.StoreUint32(&o.TWCR.Reg, volatile.LoadUint32(&o.TWCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetTWCR_TOTALH() uint32 {
	return volatile.LoadUint32(&o.TWCR.Reg) & 0x7ff
}
func (o *LCD_Type) SetTWCR_TOTALW(value uint32) {
	volatile.StoreUint32(&o.TWCR.Reg, volatile.LoadUint32(&o.TWCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LCD_Type) GetTWCR_TOTALW() uint32 {
	return (volatile.LoadUint32(&o.TWCR.Reg) & 0xfff0000) >> 16
}

// LCD.GCR: LTDC Global Control Register
func (o *LCD_Type) SetGCR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetGCR_LTDCEN() uint32 {
	return volatile.LoadUint32(&o.GCR.Reg) & 0x1
}
func (o *LCD_Type) SetGCR_DBW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x70)|value<<4)
}
func (o *LCD_Type) GetGCR_DBW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x70) >> 4
}
func (o *LCD_Type) SetGCR_DGW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x700)|value<<8)
}
func (o *LCD_Type) GetGCR_DGW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x700) >> 8
}
func (o *LCD_Type) SetGCR_DRW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x7000)|value<<12)
}
func (o *LCD_Type) GetGCR_DRW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x7000) >> 12
}
func (o *LCD_Type) SetGCR_DEN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x10000)|value<<16)
}
func (o *LCD_Type) GetGCR_DEN() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x10000) >> 16
}
func (o *LCD_Type) SetGCR_PCPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x10000000)|value<<28)
}
func (o *LCD_Type) GetGCR_PCPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x10000000) >> 28
}
func (o *LCD_Type) SetGCR_DEPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x20000000)|value<<29)
}
func (o *LCD_Type) GetGCR_DEPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x20000000) >> 29
}
func (o *LCD_Type) SetGCR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x40000000)|value<<30)
}
func (o *LCD_Type) GetGCR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x40000000) >> 30
}
func (o *LCD_Type) SetGCR_HSPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x80000000)|value<<31)
}
func (o *LCD_Type) GetGCR_HSPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x80000000) >> 31
}

// LCD.SRCR: LTDC Shadow Reload Configuration Register
func (o *LCD_Type) SetSRCR_IMR(value uint32) {
	volatile.StoreUint32(&o.SRCR.Reg, volatile.LoadUint32(&o.SRCR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetSRCR_IMR() uint32 {
	return volatile.LoadUint32(&o.SRCR.Reg) & 0x1
}
func (o *LCD_Type) SetSRCR_VBR(value uint32) {
	volatile.StoreUint32(&o.SRCR.Reg, volatile.LoadUint32(&o.SRCR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetSRCR_VBR() uint32 {
	return (volatile.LoadUint32(&o.SRCR.Reg) & 0x2) >> 1
}

// LCD.BCCR: LTDC Background Color Configuration Register
func (o *LCD_Type) SetBCCR_BCBLUE(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetBCCR_BCBLUE() uint32 {
	return volatile.LoadUint32(&o.BCCR.Reg) & 0xff
}
func (o *LCD_Type) SetBCCR_BCGREEN(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetBCCR_BCGREEN() uint32 {
	return (volatile.LoadUint32(&o.BCCR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetBCCR_BCRED(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetBCCR_BCRED() uint32 {
	return (volatile.LoadUint32(&o.BCCR.Reg) & 0xff0000) >> 16
}

// LCD.IER: LTDC Interrupt Enable Register
func (o *LCD_Type) SetIER_LIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetIER_LIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *LCD_Type) SetIER_FUIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetIER_FUIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetIER_TERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetIER_TERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetIER_RRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetIER_RRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}

// LCD.ISR: LTDC Interrupt Status Register
func (o *LCD_Type) SetISR_LIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetISR_LIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *LCD_Type) SetISR_FUIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetISR_FUIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetISR_TERRIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetISR_TERRIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetISR_RRIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetISR_RRIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}

// LCD.ICR: LTDC Interrupt Clear Register
func (o *LCD_Type) SetICR_CLIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetICR_CLIF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *LCD_Type) SetICR_CFUIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetICR_CFUIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetICR_CTERRIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetICR_CTERRIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetICR_CRRIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetICR_CRRIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}

// LCD.LIPCR: LTDC Line Interrupt Position Configuration Register
func (o *LCD_Type) SetLIPCR_LIPOS(value uint32) {
	volatile.StoreUint32(&o.LIPCR.Reg, volatile.LoadUint32(&o.LIPCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetLIPCR_LIPOS() uint32 {
	return volatile.LoadUint32(&o.LIPCR.Reg) & 0x7ff
}

// LCD.CPSR: LTDC Current Position Status Register
func (o *LCD_Type) SetCPSR_CYPOS(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffff)|value)
}
func (o *LCD_Type) GetCPSR_CYPOS() uint32 {
	return volatile.LoadUint32(&o.CPSR.Reg) & 0xffff
}
func (o *LCD_Type) SetCPSR_CXPOS(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *LCD_Type) GetCPSR_CXPOS() uint32 {
	return (volatile.LoadUint32(&o.CPSR.Reg) & 0xffff0000) >> 16
}

// LCD.CDSR: LTDC Current Display Status Register
func (o *LCD_Type) SetCDSR_VDES(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCDSR_VDES() uint32 {
	return volatile.LoadUint32(&o.CDSR.Reg) & 0x1
}
func (o *LCD_Type) SetCDSR_HDES(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetCDSR_HDES() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetCDSR_VSYNCS(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetCDSR_VSYNCS() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetCDSR_HSYNCS(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetCDSR_HSYNCS() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x8) >> 3
}

// LCD.L1CR: LTDC Layer Control Register
func (o *LCD_Type) SetL1CR_LEN(value uint32) {
	volatile.StoreUint32(&o.L1CR.Reg, volatile.LoadUint32(&o.L1CR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetL1CR_LEN() uint32 {
	return volatile.LoadUint32(&o.L1CR.Reg) & 0x1
}
func (o *LCD_Type) SetL1CR_COLKEN(value uint32) {
	volatile.StoreUint32(&o.L1CR.Reg, volatile.LoadUint32(&o.L1CR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetL1CR_COLKEN() uint32 {
	return (volatile.LoadUint32(&o.L1CR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetL1CR_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.L1CR.Reg, volatile.LoadUint32(&o.L1CR.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetL1CR_CLUTEN() uint32 {
	return (volatile.LoadUint32(&o.L1CR.Reg) & 0x10) >> 4
}

// LCD.L1WHPCR: LTDC Layer Window Horizontal Position Configuration Register
func (o *LCD_Type) SetL1WHPCR_WHSTPOS(value uint32) {
	volatile.StoreUint32(&o.L1WHPCR.Reg, volatile.LoadUint32(&o.L1WHPCR.Reg)&^(0xfff)|value)
}
func (o *LCD_Type) GetL1WHPCR_WHSTPOS() uint32 {
	return volatile.LoadUint32(&o.L1WHPCR.Reg) & 0xfff
}
func (o *LCD_Type) SetL1WHPCR_WHSPPOS(value uint32) {
	volatile.StoreUint32(&o.L1WHPCR.Reg, volatile.LoadUint32(&o.L1WHPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LCD_Type) GetL1WHPCR_WHSPPOS() uint32 {
	return (volatile.LoadUint32(&o.L1WHPCR.Reg) & 0xfff0000) >> 16
}

// LCD.L1WVPCR: LTDC Layer Window Vertical Position Configuration Register
func (o *LCD_Type) SetL1WVPCR_WVSTPOS(value uint32) {
	volatile.StoreUint32(&o.L1WVPCR.Reg, volatile.LoadUint32(&o.L1WVPCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetL1WVPCR_WVSTPOS() uint32 {
	return volatile.LoadUint32(&o.L1WVPCR.Reg) & 0x7ff
}
func (o *LCD_Type) SetL1WVPCR_WVSPPOS(value uint32) {
	volatile.StoreUint32(&o.L1WVPCR.Reg, volatile.LoadUint32(&o.L1WVPCR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCD_Type) GetL1WVPCR_WVSPPOS() uint32 {
	return (volatile.LoadUint32(&o.L1WVPCR.Reg) & 0x7ff0000) >> 16
}

// LCD.L1CKCR: LTDC Layer Color Keying Configuration Register
func (o *LCD_Type) SetL1CKCR_CKBLUE(value uint32) {
	volatile.StoreUint32(&o.L1CKCR.Reg, volatile.LoadUint32(&o.L1CKCR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL1CKCR_CKBLUE() uint32 {
	return volatile.LoadUint32(&o.L1CKCR.Reg) & 0xff
}
func (o *LCD_Type) SetL1CKCR_CKGREEN(value uint32) {
	volatile.StoreUint32(&o.L1CKCR.Reg, volatile.LoadUint32(&o.L1CKCR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetL1CKCR_CKGREEN() uint32 {
	return (volatile.LoadUint32(&o.L1CKCR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetL1CKCR_CKRED(value uint32) {
	volatile.StoreUint32(&o.L1CKCR.Reg, volatile.LoadUint32(&o.L1CKCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetL1CKCR_CKRED() uint32 {
	return (volatile.LoadUint32(&o.L1CKCR.Reg) & 0xff0000) >> 16
}

// LCD.L1PFCR: LTDC Layer Pixel Format Configuration Register
func (o *LCD_Type) SetL1PFCR_PF(value uint32) {
	volatile.StoreUint32(&o.L1PFCR.Reg, volatile.LoadUint32(&o.L1PFCR.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetL1PFCR_PF() uint32 {
	return volatile.LoadUint32(&o.L1PFCR.Reg) & 0x7
}

// LCD.L1CACR: LTDC Layer Constant Alpha Configuration Register
func (o *LCD_Type) SetL1CACR_CONSTA(value uint32) {
	volatile.StoreUint32(&o.L1CACR.Reg, volatile.LoadUint32(&o.L1CACR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL1CACR_CONSTA() uint32 {
	return volatile.LoadUint32(&o.L1CACR.Reg) & 0xff
}

// LCD.L1DCCR: LTDC Layer Default Color Configuration Register
func (o *LCD_Type) SetL1DCCR_DCBLUE(value uint32) {
	volatile.StoreUint32(&o.L1DCCR.Reg, volatile.LoadUint32(&o.L1DCCR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL1DCCR_DCBLUE() uint32 {
	return volatile.LoadUint32(&o.L1DCCR.Reg) & 0xff
}
func (o *LCD_Type) SetL1DCCR_DCGREEN(value uint32) {
	volatile.StoreUint32(&o.L1DCCR.Reg, volatile.LoadUint32(&o.L1DCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetL1DCCR_DCGREEN() uint32 {
	return (volatile.LoadUint32(&o.L1DCCR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetL1DCCR_DCRED(value uint32) {
	volatile.StoreUint32(&o.L1DCCR.Reg, volatile.LoadUint32(&o.L1DCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetL1DCCR_DCRED() uint32 {
	return (volatile.LoadUint32(&o.L1DCCR.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetL1DCCR_DCALPHA(value uint32) {
	volatile.StoreUint32(&o.L1DCCR.Reg, volatile.LoadUint32(&o.L1DCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetL1DCCR_DCALPHA() uint32 {
	return (volatile.LoadUint32(&o.L1DCCR.Reg) & 0xff000000) >> 24
}

// LCD.L1BFCR: LTDC Layer Blending Factors Configuration Register
func (o *LCD_Type) SetL1BFCR_BF2(value uint32) {
	volatile.StoreUint32(&o.L1BFCR.Reg, volatile.LoadUint32(&o.L1BFCR.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetL1BFCR_BF2() uint32 {
	return volatile.LoadUint32(&o.L1BFCR.Reg) & 0x7
}
func (o *LCD_Type) SetL1BFCR_BF1(value uint32) {
	volatile.StoreUint32(&o.L1BFCR.Reg, volatile.LoadUint32(&o.L1BFCR.Reg)&^(0x700)|value<<8)
}
func (o *LCD_Type) GetL1BFCR_BF1() uint32 {
	return (volatile.LoadUint32(&o.L1BFCR.Reg) & 0x700) >> 8
}

// LCD.L1CFBAR: LTDC Layer Color Frame Buffer Address Register
func (o *LCD_Type) SetL1CFBAR(value uint32) {
	volatile.StoreUint32(&o.L1CFBAR.Reg, value)
}
func (o *LCD_Type) GetL1CFBAR() uint32 {
	return volatile.LoadUint32(&o.L1CFBAR.Reg)
}

// LCD.L1CFBLR: LTDC Layer Color Frame Buffer Length Register
func (o *LCD_Type) SetL1CFBLR_CFBLL(value uint32) {
	volatile.StoreUint32(&o.L1CFBLR.Reg, volatile.LoadUint32(&o.L1CFBLR.Reg)&^(0x1fff)|value)
}
func (o *LCD_Type) GetL1CFBLR_CFBLL() uint32 {
	return volatile.LoadUint32(&o.L1CFBLR.Reg) & 0x1fff
}
func (o *LCD_Type) SetL1CFBLR_CFBP(value uint32) {
	volatile.StoreUint32(&o.L1CFBLR.Reg, volatile.LoadUint32(&o.L1CFBLR.Reg)&^(0x1fff0000)|value<<16)
}
func (o *LCD_Type) GetL1CFBLR_CFBP() uint32 {
	return (volatile.LoadUint32(&o.L1CFBLR.Reg) & 0x1fff0000) >> 16
}

// LCD.L1CFBLNR: LTDC Layer ColorFrame Buffer Line Number Register
func (o *LCD_Type) SetL1CFBLNR_CFBLNBR(value uint32) {
	volatile.StoreUint32(&o.L1CFBLNR.Reg, volatile.LoadUint32(&o.L1CFBLNR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetL1CFBLNR_CFBLNBR() uint32 {
	return volatile.LoadUint32(&o.L1CFBLNR.Reg) & 0x7ff
}

// LCD.L1CLUTWR: LTDC Layerx CLUT Write Register
func (o *LCD_Type) SetL1CLUTWR_BLUE(value uint32) {
	volatile.StoreUint32(&o.L1CLUTWR.Reg, volatile.LoadUint32(&o.L1CLUTWR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL1CLUTWR_BLUE() uint32 {
	return volatile.LoadUint32(&o.L1CLUTWR.Reg) & 0xff
}
func (o *LCD_Type) SetL1CLUTWR_GREEN(value uint32) {
	volatile.StoreUint32(&o.L1CLUTWR.Reg, volatile.LoadUint32(&o.L1CLUTWR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetL1CLUTWR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.L1CLUTWR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetL1CLUTWR_RED(value uint32) {
	volatile.StoreUint32(&o.L1CLUTWR.Reg, volatile.LoadUint32(&o.L1CLUTWR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetL1CLUTWR_RED() uint32 {
	return (volatile.LoadUint32(&o.L1CLUTWR.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetL1CLUTWR_CLUTADD(value uint32) {
	volatile.StoreUint32(&o.L1CLUTWR.Reg, volatile.LoadUint32(&o.L1CLUTWR.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetL1CLUTWR_CLUTADD() uint32 {
	return (volatile.LoadUint32(&o.L1CLUTWR.Reg) & 0xff000000) >> 24
}

// LCD.L2CR: LTDC Layer Control Register
func (o *LCD_Type) SetL2CR_LEN(value uint32) {
	volatile.StoreUint32(&o.L2CR.Reg, volatile.LoadUint32(&o.L2CR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetL2CR_LEN() uint32 {
	return volatile.LoadUint32(&o.L2CR.Reg) & 0x1
}
func (o *LCD_Type) SetL2CR_COLKEN(value uint32) {
	volatile.StoreUint32(&o.L2CR.Reg, volatile.LoadUint32(&o.L2CR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetL2CR_COLKEN() uint32 {
	return (volatile.LoadUint32(&o.L2CR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetL2CR_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.L2CR.Reg, volatile.LoadUint32(&o.L2CR.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetL2CR_CLUTEN() uint32 {
	return (volatile.LoadUint32(&o.L2CR.Reg) & 0x10) >> 4
}

// LCD.L2WHPCR: LTDC Layerx Window Horizontal Position Configuration Register
func (o *LCD_Type) SetL2WHPCR_WHSTPOS(value uint32) {
	volatile.StoreUint32(&o.L2WHPCR.Reg, volatile.LoadUint32(&o.L2WHPCR.Reg)&^(0xfff)|value)
}
func (o *LCD_Type) GetL2WHPCR_WHSTPOS() uint32 {
	return volatile.LoadUint32(&o.L2WHPCR.Reg) & 0xfff
}
func (o *LCD_Type) SetL2WHPCR_WHSPPOS(value uint32) {
	volatile.StoreUint32(&o.L2WHPCR.Reg, volatile.LoadUint32(&o.L2WHPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LCD_Type) GetL2WHPCR_WHSPPOS() uint32 {
	return (volatile.LoadUint32(&o.L2WHPCR.Reg) & 0xfff0000) >> 16
}

// LCD.L2WVPCR: LTDC Layer Window Vertical Position Configuration Register
func (o *LCD_Type) SetL2WVPCR_WVSTPOS(value uint32) {
	volatile.StoreUint32(&o.L2WVPCR.Reg, volatile.LoadUint32(&o.L2WVPCR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetL2WVPCR_WVSTPOS() uint32 {
	return volatile.LoadUint32(&o.L2WVPCR.Reg) & 0x7ff
}
func (o *LCD_Type) SetL2WVPCR_WVSPPOS(value uint32) {
	volatile.StoreUint32(&o.L2WVPCR.Reg, volatile.LoadUint32(&o.L2WVPCR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LCD_Type) GetL2WVPCR_WVSPPOS() uint32 {
	return (volatile.LoadUint32(&o.L2WVPCR.Reg) & 0x7ff0000) >> 16
}

// LCD.L2CKCR: LTDC Layer Color Keying Configuration Register
func (o *LCD_Type) SetL2CKCR_CKBLUE(value uint32) {
	volatile.StoreUint32(&o.L2CKCR.Reg, volatile.LoadUint32(&o.L2CKCR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL2CKCR_CKBLUE() uint32 {
	return volatile.LoadUint32(&o.L2CKCR.Reg) & 0xff
}
func (o *LCD_Type) SetL2CKCR_CKGREEN(value uint32) {
	volatile.StoreUint32(&o.L2CKCR.Reg, volatile.LoadUint32(&o.L2CKCR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetL2CKCR_CKGREEN() uint32 {
	return (volatile.LoadUint32(&o.L2CKCR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetL2CKCR_CKRED(value uint32) {
	volatile.StoreUint32(&o.L2CKCR.Reg, volatile.LoadUint32(&o.L2CKCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetL2CKCR_CKRED() uint32 {
	return (volatile.LoadUint32(&o.L2CKCR.Reg) & 0xff0000) >> 16
}

// LCD.L2PFCR: LTDC Layer Pixel Format Configuration Register
func (o *LCD_Type) SetL2PFCR_PF(value uint32) {
	volatile.StoreUint32(&o.L2PFCR.Reg, volatile.LoadUint32(&o.L2PFCR.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetL2PFCR_PF() uint32 {
	return volatile.LoadUint32(&o.L2PFCR.Reg) & 0x7
}

// LCD.L2CACR: LTDC Layer Constant Alpha Configuration Register
func (o *LCD_Type) SetL2CACR_CONSTA(value uint32) {
	volatile.StoreUint32(&o.L2CACR.Reg, volatile.LoadUint32(&o.L2CACR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL2CACR_CONSTA() uint32 {
	return volatile.LoadUint32(&o.L2CACR.Reg) & 0xff
}

// LCD.L2DCCR: LTDC Layer Default Color Configuration Register
func (o *LCD_Type) SetL2DCCR_DCBLUE(value uint32) {
	volatile.StoreUint32(&o.L2DCCR.Reg, volatile.LoadUint32(&o.L2DCCR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL2DCCR_DCBLUE() uint32 {
	return volatile.LoadUint32(&o.L2DCCR.Reg) & 0xff
}
func (o *LCD_Type) SetL2DCCR_DCGREEN(value uint32) {
	volatile.StoreUint32(&o.L2DCCR.Reg, volatile.LoadUint32(&o.L2DCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetL2DCCR_DCGREEN() uint32 {
	return (volatile.LoadUint32(&o.L2DCCR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetL2DCCR_DCRED(value uint32) {
	volatile.StoreUint32(&o.L2DCCR.Reg, volatile.LoadUint32(&o.L2DCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetL2DCCR_DCRED() uint32 {
	return (volatile.LoadUint32(&o.L2DCCR.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetL2DCCR_DCALPHA(value uint32) {
	volatile.StoreUint32(&o.L2DCCR.Reg, volatile.LoadUint32(&o.L2DCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetL2DCCR_DCALPHA() uint32 {
	return (volatile.LoadUint32(&o.L2DCCR.Reg) & 0xff000000) >> 24
}

// LCD.L2BFCR: LTDC Layer Blending Factors Configuration Register
func (o *LCD_Type) SetL2BFCR_BF2(value uint32) {
	volatile.StoreUint32(&o.L2BFCR.Reg, volatile.LoadUint32(&o.L2BFCR.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetL2BFCR_BF2() uint32 {
	return volatile.LoadUint32(&o.L2BFCR.Reg) & 0x7
}
func (o *LCD_Type) SetL2BFCR_BF1(value uint32) {
	volatile.StoreUint32(&o.L2BFCR.Reg, volatile.LoadUint32(&o.L2BFCR.Reg)&^(0x700)|value<<8)
}
func (o *LCD_Type) GetL2BFCR_BF1() uint32 {
	return (volatile.LoadUint32(&o.L2BFCR.Reg) & 0x700) >> 8
}

// LCD.L2CFBAR: LTDC Layer Color Frame Buffer Address Register
func (o *LCD_Type) SetL2CFBAR(value uint32) {
	volatile.StoreUint32(&o.L2CFBAR.Reg, value)
}
func (o *LCD_Type) GetL2CFBAR() uint32 {
	return volatile.LoadUint32(&o.L2CFBAR.Reg)
}

// LCD.L2CFBLR: LTDC Layer Color Frame Buffer Length Register
func (o *LCD_Type) SetL2CFBLR_CFBLL(value uint32) {
	volatile.StoreUint32(&o.L2CFBLR.Reg, volatile.LoadUint32(&o.L2CFBLR.Reg)&^(0x1fff)|value)
}
func (o *LCD_Type) GetL2CFBLR_CFBLL() uint32 {
	return volatile.LoadUint32(&o.L2CFBLR.Reg) & 0x1fff
}
func (o *LCD_Type) SetL2CFBLR_CFBP(value uint32) {
	volatile.StoreUint32(&o.L2CFBLR.Reg, volatile.LoadUint32(&o.L2CFBLR.Reg)&^(0x1fff0000)|value<<16)
}
func (o *LCD_Type) GetL2CFBLR_CFBP() uint32 {
	return (volatile.LoadUint32(&o.L2CFBLR.Reg) & 0x1fff0000) >> 16
}

// LCD.L2CFBLNR: LTDC Layer ColorFrame Buffer Line Number Register
func (o *LCD_Type) SetL2CFBLNR_CFBLNBR(value uint32) {
	volatile.StoreUint32(&o.L2CFBLNR.Reg, volatile.LoadUint32(&o.L2CFBLNR.Reg)&^(0x7ff)|value)
}
func (o *LCD_Type) GetL2CFBLNR_CFBLNBR() uint32 {
	return volatile.LoadUint32(&o.L2CFBLNR.Reg) & 0x7ff
}

// LCD.L2CLUTWR: LTDC Layerx CLUT Write Register
func (o *LCD_Type) SetL2CLUTWR_BLUE(value uint32) {
	volatile.StoreUint32(&o.L2CLUTWR.Reg, volatile.LoadUint32(&o.L2CLUTWR.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetL2CLUTWR_BLUE() uint32 {
	return volatile.LoadUint32(&o.L2CLUTWR.Reg) & 0xff
}
func (o *LCD_Type) SetL2CLUTWR_GREEN(value uint32) {
	volatile.StoreUint32(&o.L2CLUTWR.Reg, volatile.LoadUint32(&o.L2CLUTWR.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetL2CLUTWR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.L2CLUTWR.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetL2CLUTWR_RED(value uint32) {
	volatile.StoreUint32(&o.L2CLUTWR.Reg, volatile.LoadUint32(&o.L2CLUTWR.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetL2CLUTWR_RED() uint32 {
	return (volatile.LoadUint32(&o.L2CLUTWR.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetL2CLUTWR_CLUTADD(value uint32) {
	volatile.StoreUint32(&o.L2CLUTWR.Reg, volatile.LoadUint32(&o.L2CLUTWR.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetL2CLUTWR_CLUTADD() uint32 {
	return (volatile.LoadUint32(&o.L2CLUTWR.Reg) & 0xff000000) >> 24
}

// Touch sensing controller
type TSC_Type struct {
	CR     volatile.Register32 // 0x0
	IER    volatile.Register32 // 0x4
	ICR    volatile.Register32 // 0x8
	ISR    volatile.Register32 // 0xC
	IOHCR  volatile.Register32 // 0x10
	_      [4]byte
	IOASCR volatile.Register32 // 0x18
	_      [4]byte
	IOSCR  volatile.Register32 // 0x20
	_      [4]byte
	IOCCR  volatile.Register32 // 0x28
	_      [4]byte
	IOGCSR volatile.Register32 // 0x30
	IOG1CR volatile.Register32 // 0x34
	IOG2CR volatile.Register32 // 0x38
	IOG3CR volatile.Register32 // 0x3C
	IOG4CR volatile.Register32 // 0x40
	IOG5CR volatile.Register32 // 0x44
	IOG6CR volatile.Register32 // 0x48
	IOG7CR volatile.Register32 // 0x4C
	IOG8CR volatile.Register32 // 0x50
}

// TSC.CR: control register
func (o *TSC_Type) SetCR_CTPH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *TSC_Type) GetCR_CTPH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0000000) >> 28
}
func (o *TSC_Type) SetCR_CTPL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf000000)|value<<24)
}
func (o *TSC_Type) GetCR_CTPL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf000000) >> 24
}
func (o *TSC_Type) SetCR_SSD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xfe0000)|value<<17)
}
func (o *TSC_Type) GetCR_SSD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xfe0000) >> 17
}
func (o *TSC_Type) SetCR_SSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *TSC_Type) GetCR_SSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *TSC_Type) SetCR_SSPSC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *TSC_Type) GetCR_SSPSC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *TSC_Type) SetCR_PGPSC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000)|value<<12)
}
func (o *TSC_Type) GetCR_PGPSC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000) >> 12
}
func (o *TSC_Type) SetCR_MCV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xe0)|value<<5)
}
func (o *TSC_Type) GetCR_MCV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xe0) >> 5
}
func (o *TSC_Type) SetCR_IODEF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *TSC_Type) GetCR_IODEF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *TSC_Type) SetCR_SYNCPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *TSC_Type) GetCR_SYNCPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *TSC_Type) SetCR_AM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *TSC_Type) GetCR_AM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *TSC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetCR_TSCE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetCR_TSCE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// TSC.IER: interrupt enable register
func (o *TSC_Type) SetIER_MCEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetIER_MCEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetIER_EOAIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetIER_EOAIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// TSC.ICR: interrupt clear register
func (o *TSC_Type) SetICR_MCEIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetICR_MCEIC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetICR_EOAIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetICR_EOAIC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// TSC.ISR: interrupt status register
func (o *TSC_Type) SetISR_MCEF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetISR_MCEF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetISR_EOAF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetISR_EOAF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// TSC.IOHCR: I/O hysteresis control register
func (o *TSC_Type) SetIOHCR_G8_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x80000000)|value<<31)
}
func (o *TSC_Type) GetIOHCR_G8_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x80000000) >> 31
}
func (o *TSC_Type) SetIOHCR_G8_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSC_Type) GetIOHCR_G8_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x40000000) >> 30
}
func (o *TSC_Type) SetIOHCR_G8_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSC_Type) GetIOHCR_G8_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x20000000) >> 29
}
func (o *TSC_Type) SetIOHCR_G8_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSC_Type) GetIOHCR_G8_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x10000000) >> 28
}
func (o *TSC_Type) SetIOHCR_G7_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x8000000)|value<<27)
}
func (o *TSC_Type) GetIOHCR_G7_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x8000000) >> 27
}
func (o *TSC_Type) SetIOHCR_G7_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSC_Type) GetIOHCR_G7_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x4000000) >> 26
}
func (o *TSC_Type) SetIOHCR_G7_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSC_Type) GetIOHCR_G7_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x2000000) >> 25
}
func (o *TSC_Type) SetIOHCR_G7_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSC_Type) GetIOHCR_G7_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x1000000) >> 24
}
func (o *TSC_Type) SetIOHCR_G6_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x800000)|value<<23)
}
func (o *TSC_Type) GetIOHCR_G6_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x800000) >> 23
}
func (o *TSC_Type) SetIOHCR_G6_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x400000)|value<<22)
}
func (o *TSC_Type) GetIOHCR_G6_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x400000) >> 22
}
func (o *TSC_Type) SetIOHCR_G6_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x200000)|value<<21)
}
func (o *TSC_Type) GetIOHCR_G6_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x200000) >> 21
}
func (o *TSC_Type) SetIOHCR_G6_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x100000)|value<<20)
}
func (o *TSC_Type) GetIOHCR_G6_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x100000) >> 20
}
func (o *TSC_Type) SetIOHCR_G5_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x80000)|value<<19)
}
func (o *TSC_Type) GetIOHCR_G5_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x80000) >> 19
}
func (o *TSC_Type) SetIOHCR_G5_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x40000)|value<<18)
}
func (o *TSC_Type) GetIOHCR_G5_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x40000) >> 18
}
func (o *TSC_Type) SetIOHCR_G5_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x20000)|value<<17)
}
func (o *TSC_Type) GetIOHCR_G5_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x20000) >> 17
}
func (o *TSC_Type) SetIOHCR_G5_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x10000)|value<<16)
}
func (o *TSC_Type) GetIOHCR_G5_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x10000) >> 16
}
func (o *TSC_Type) SetIOHCR_G4_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x8000)|value<<15)
}
func (o *TSC_Type) GetIOHCR_G4_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x8000) >> 15
}
func (o *TSC_Type) SetIOHCR_G4_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x4000)|value<<14)
}
func (o *TSC_Type) GetIOHCR_G4_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x4000) >> 14
}
func (o *TSC_Type) SetIOHCR_G4_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x2000)|value<<13)
}
func (o *TSC_Type) GetIOHCR_G4_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x2000) >> 13
}
func (o *TSC_Type) SetIOHCR_G4_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x1000)|value<<12)
}
func (o *TSC_Type) GetIOHCR_G4_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x1000) >> 12
}
func (o *TSC_Type) SetIOHCR_G3_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x800)|value<<11)
}
func (o *TSC_Type) GetIOHCR_G3_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x800) >> 11
}
func (o *TSC_Type) SetIOHCR_G3_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x400)|value<<10)
}
func (o *TSC_Type) GetIOHCR_G3_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x400) >> 10
}
func (o *TSC_Type) SetIOHCR_G3_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x200)|value<<9)
}
func (o *TSC_Type) GetIOHCR_G3_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x200) >> 9
}
func (o *TSC_Type) SetIOHCR_G3_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x100)|value<<8)
}
func (o *TSC_Type) GetIOHCR_G3_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x100) >> 8
}
func (o *TSC_Type) SetIOHCR_G2_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x80)|value<<7)
}
func (o *TSC_Type) GetIOHCR_G2_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x80) >> 7
}
func (o *TSC_Type) SetIOHCR_G2_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x40)|value<<6)
}
func (o *TSC_Type) GetIOHCR_G2_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x40) >> 6
}
func (o *TSC_Type) SetIOHCR_G2_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x20)|value<<5)
}
func (o *TSC_Type) GetIOHCR_G2_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x20) >> 5
}
func (o *TSC_Type) SetIOHCR_G2_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x10)|value<<4)
}
func (o *TSC_Type) GetIOHCR_G2_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x10) >> 4
}
func (o *TSC_Type) SetIOHCR_G1_IO4(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x8)|value<<3)
}
func (o *TSC_Type) GetIOHCR_G1_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x8) >> 3
}
func (o *TSC_Type) SetIOHCR_G1_IO3(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x4)|value<<2)
}
func (o *TSC_Type) GetIOHCR_G1_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x4) >> 2
}
func (o *TSC_Type) SetIOHCR_G1_IO2(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetIOHCR_G1_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOHCR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetIOHCR_G1_IO1(value uint32) {
	volatile.StoreUint32(&o.IOHCR.Reg, volatile.LoadUint32(&o.IOHCR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetIOHCR_G1_IO1() uint32 {
	return volatile.LoadUint32(&o.IOHCR.Reg) & 0x1
}

// TSC.IOASCR: I/O analog switch control register
func (o *TSC_Type) SetIOASCR_G8_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x80000000)|value<<31)
}
func (o *TSC_Type) GetIOASCR_G8_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x80000000) >> 31
}
func (o *TSC_Type) SetIOASCR_G8_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSC_Type) GetIOASCR_G8_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x40000000) >> 30
}
func (o *TSC_Type) SetIOASCR_G8_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSC_Type) GetIOASCR_G8_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x20000000) >> 29
}
func (o *TSC_Type) SetIOASCR_G8_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSC_Type) GetIOASCR_G8_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x10000000) >> 28
}
func (o *TSC_Type) SetIOASCR_G7_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x8000000)|value<<27)
}
func (o *TSC_Type) GetIOASCR_G7_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x8000000) >> 27
}
func (o *TSC_Type) SetIOASCR_G7_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSC_Type) GetIOASCR_G7_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x4000000) >> 26
}
func (o *TSC_Type) SetIOASCR_G7_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSC_Type) GetIOASCR_G7_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x2000000) >> 25
}
func (o *TSC_Type) SetIOASCR_G7_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSC_Type) GetIOASCR_G7_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x1000000) >> 24
}
func (o *TSC_Type) SetIOASCR_G6_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x800000)|value<<23)
}
func (o *TSC_Type) GetIOASCR_G6_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x800000) >> 23
}
func (o *TSC_Type) SetIOASCR_G6_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x400000)|value<<22)
}
func (o *TSC_Type) GetIOASCR_G6_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x400000) >> 22
}
func (o *TSC_Type) SetIOASCR_G6_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x200000)|value<<21)
}
func (o *TSC_Type) GetIOASCR_G6_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x200000) >> 21
}
func (o *TSC_Type) SetIOASCR_G6_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x100000)|value<<20)
}
func (o *TSC_Type) GetIOASCR_G6_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x100000) >> 20
}
func (o *TSC_Type) SetIOASCR_G5_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x80000)|value<<19)
}
func (o *TSC_Type) GetIOASCR_G5_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x80000) >> 19
}
func (o *TSC_Type) SetIOASCR_G5_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x40000)|value<<18)
}
func (o *TSC_Type) GetIOASCR_G5_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x40000) >> 18
}
func (o *TSC_Type) SetIOASCR_G5_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x20000)|value<<17)
}
func (o *TSC_Type) GetIOASCR_G5_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x20000) >> 17
}
func (o *TSC_Type) SetIOASCR_G5_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x10000)|value<<16)
}
func (o *TSC_Type) GetIOASCR_G5_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x10000) >> 16
}
func (o *TSC_Type) SetIOASCR_G4_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x8000)|value<<15)
}
func (o *TSC_Type) GetIOASCR_G4_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x8000) >> 15
}
func (o *TSC_Type) SetIOASCR_G4_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x4000)|value<<14)
}
func (o *TSC_Type) GetIOASCR_G4_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x4000) >> 14
}
func (o *TSC_Type) SetIOASCR_G4_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x2000)|value<<13)
}
func (o *TSC_Type) GetIOASCR_G4_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x2000) >> 13
}
func (o *TSC_Type) SetIOASCR_G4_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x1000)|value<<12)
}
func (o *TSC_Type) GetIOASCR_G4_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x1000) >> 12
}
func (o *TSC_Type) SetIOASCR_G3_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x800)|value<<11)
}
func (o *TSC_Type) GetIOASCR_G3_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x800) >> 11
}
func (o *TSC_Type) SetIOASCR_G3_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x400)|value<<10)
}
func (o *TSC_Type) GetIOASCR_G3_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x400) >> 10
}
func (o *TSC_Type) SetIOASCR_G3_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x200)|value<<9)
}
func (o *TSC_Type) GetIOASCR_G3_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x200) >> 9
}
func (o *TSC_Type) SetIOASCR_G3_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x100)|value<<8)
}
func (o *TSC_Type) GetIOASCR_G3_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x100) >> 8
}
func (o *TSC_Type) SetIOASCR_G2_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x80)|value<<7)
}
func (o *TSC_Type) GetIOASCR_G2_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x80) >> 7
}
func (o *TSC_Type) SetIOASCR_G2_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x40)|value<<6)
}
func (o *TSC_Type) GetIOASCR_G2_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x40) >> 6
}
func (o *TSC_Type) SetIOASCR_G2_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x20)|value<<5)
}
func (o *TSC_Type) GetIOASCR_G2_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x20) >> 5
}
func (o *TSC_Type) SetIOASCR_G2_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x10)|value<<4)
}
func (o *TSC_Type) GetIOASCR_G2_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x10) >> 4
}
func (o *TSC_Type) SetIOASCR_G1_IO4(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x8)|value<<3)
}
func (o *TSC_Type) GetIOASCR_G1_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x8) >> 3
}
func (o *TSC_Type) SetIOASCR_G1_IO3(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x4)|value<<2)
}
func (o *TSC_Type) GetIOASCR_G1_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x4) >> 2
}
func (o *TSC_Type) SetIOASCR_G1_IO2(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetIOASCR_G1_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOASCR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetIOASCR_G1_IO1(value uint32) {
	volatile.StoreUint32(&o.IOASCR.Reg, volatile.LoadUint32(&o.IOASCR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetIOASCR_G1_IO1() uint32 {
	return volatile.LoadUint32(&o.IOASCR.Reg) & 0x1
}

// TSC.IOSCR: I/O sampling control register
func (o *TSC_Type) SetIOSCR_G8_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x80000000)|value<<31)
}
func (o *TSC_Type) GetIOSCR_G8_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x80000000) >> 31
}
func (o *TSC_Type) SetIOSCR_G8_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSC_Type) GetIOSCR_G8_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x40000000) >> 30
}
func (o *TSC_Type) SetIOSCR_G8_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSC_Type) GetIOSCR_G8_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x20000000) >> 29
}
func (o *TSC_Type) SetIOSCR_G8_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSC_Type) GetIOSCR_G8_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x10000000) >> 28
}
func (o *TSC_Type) SetIOSCR_G7_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x8000000)|value<<27)
}
func (o *TSC_Type) GetIOSCR_G7_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x8000000) >> 27
}
func (o *TSC_Type) SetIOSCR_G7_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSC_Type) GetIOSCR_G7_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x4000000) >> 26
}
func (o *TSC_Type) SetIOSCR_G7_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSC_Type) GetIOSCR_G7_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x2000000) >> 25
}
func (o *TSC_Type) SetIOSCR_G7_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSC_Type) GetIOSCR_G7_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x1000000) >> 24
}
func (o *TSC_Type) SetIOSCR_G6_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x800000)|value<<23)
}
func (o *TSC_Type) GetIOSCR_G6_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x800000) >> 23
}
func (o *TSC_Type) SetIOSCR_G6_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x400000)|value<<22)
}
func (o *TSC_Type) GetIOSCR_G6_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x400000) >> 22
}
func (o *TSC_Type) SetIOSCR_G6_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x200000)|value<<21)
}
func (o *TSC_Type) GetIOSCR_G6_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x200000) >> 21
}
func (o *TSC_Type) SetIOSCR_G6_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x100000)|value<<20)
}
func (o *TSC_Type) GetIOSCR_G6_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x100000) >> 20
}
func (o *TSC_Type) SetIOSCR_G5_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x80000)|value<<19)
}
func (o *TSC_Type) GetIOSCR_G5_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x80000) >> 19
}
func (o *TSC_Type) SetIOSCR_G5_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x40000)|value<<18)
}
func (o *TSC_Type) GetIOSCR_G5_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x40000) >> 18
}
func (o *TSC_Type) SetIOSCR_G5_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x20000)|value<<17)
}
func (o *TSC_Type) GetIOSCR_G5_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x20000) >> 17
}
func (o *TSC_Type) SetIOSCR_G5_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x10000)|value<<16)
}
func (o *TSC_Type) GetIOSCR_G5_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x10000) >> 16
}
func (o *TSC_Type) SetIOSCR_G4_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x8000)|value<<15)
}
func (o *TSC_Type) GetIOSCR_G4_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x8000) >> 15
}
func (o *TSC_Type) SetIOSCR_G4_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x4000)|value<<14)
}
func (o *TSC_Type) GetIOSCR_G4_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x4000) >> 14
}
func (o *TSC_Type) SetIOSCR_G4_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x2000)|value<<13)
}
func (o *TSC_Type) GetIOSCR_G4_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x2000) >> 13
}
func (o *TSC_Type) SetIOSCR_G4_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x1000)|value<<12)
}
func (o *TSC_Type) GetIOSCR_G4_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x1000) >> 12
}
func (o *TSC_Type) SetIOSCR_G3_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x800)|value<<11)
}
func (o *TSC_Type) GetIOSCR_G3_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x800) >> 11
}
func (o *TSC_Type) SetIOSCR_G3_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x400)|value<<10)
}
func (o *TSC_Type) GetIOSCR_G3_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x400) >> 10
}
func (o *TSC_Type) SetIOSCR_G3_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x200)|value<<9)
}
func (o *TSC_Type) GetIOSCR_G3_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x200) >> 9
}
func (o *TSC_Type) SetIOSCR_G3_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x100)|value<<8)
}
func (o *TSC_Type) GetIOSCR_G3_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x100) >> 8
}
func (o *TSC_Type) SetIOSCR_G2_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x80)|value<<7)
}
func (o *TSC_Type) GetIOSCR_G2_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x80) >> 7
}
func (o *TSC_Type) SetIOSCR_G2_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x40)|value<<6)
}
func (o *TSC_Type) GetIOSCR_G2_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x40) >> 6
}
func (o *TSC_Type) SetIOSCR_G2_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x20)|value<<5)
}
func (o *TSC_Type) GetIOSCR_G2_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x20) >> 5
}
func (o *TSC_Type) SetIOSCR_G2_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x10)|value<<4)
}
func (o *TSC_Type) GetIOSCR_G2_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x10) >> 4
}
func (o *TSC_Type) SetIOSCR_G1_IO4(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x8)|value<<3)
}
func (o *TSC_Type) GetIOSCR_G1_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x8) >> 3
}
func (o *TSC_Type) SetIOSCR_G1_IO3(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x4)|value<<2)
}
func (o *TSC_Type) GetIOSCR_G1_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x4) >> 2
}
func (o *TSC_Type) SetIOSCR_G1_IO2(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetIOSCR_G1_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOSCR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetIOSCR_G1_IO1(value uint32) {
	volatile.StoreUint32(&o.IOSCR.Reg, volatile.LoadUint32(&o.IOSCR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetIOSCR_G1_IO1() uint32 {
	return volatile.LoadUint32(&o.IOSCR.Reg) & 0x1
}

// TSC.IOCCR: I/O channel control register
func (o *TSC_Type) SetIOCCR_G8_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *TSC_Type) GetIOCCR_G8_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x80000000) >> 31
}
func (o *TSC_Type) SetIOCCR_G8_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *TSC_Type) GetIOCCR_G8_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x40000000) >> 30
}
func (o *TSC_Type) SetIOCCR_G8_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x20000000)|value<<29)
}
func (o *TSC_Type) GetIOCCR_G8_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x20000000) >> 29
}
func (o *TSC_Type) SetIOCCR_G8_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x10000000)|value<<28)
}
func (o *TSC_Type) GetIOCCR_G8_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x10000000) >> 28
}
func (o *TSC_Type) SetIOCCR_G7_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x8000000)|value<<27)
}
func (o *TSC_Type) GetIOCCR_G7_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x8000000) >> 27
}
func (o *TSC_Type) SetIOCCR_G7_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x4000000)|value<<26)
}
func (o *TSC_Type) GetIOCCR_G7_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x4000000) >> 26
}
func (o *TSC_Type) SetIOCCR_G7_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x2000000)|value<<25)
}
func (o *TSC_Type) GetIOCCR_G7_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x2000000) >> 25
}
func (o *TSC_Type) SetIOCCR_G7_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x1000000)|value<<24)
}
func (o *TSC_Type) GetIOCCR_G7_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x1000000) >> 24
}
func (o *TSC_Type) SetIOCCR_G6_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x800000)|value<<23)
}
func (o *TSC_Type) GetIOCCR_G6_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x800000) >> 23
}
func (o *TSC_Type) SetIOCCR_G6_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x400000)|value<<22)
}
func (o *TSC_Type) GetIOCCR_G6_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x400000) >> 22
}
func (o *TSC_Type) SetIOCCR_G6_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x200000)|value<<21)
}
func (o *TSC_Type) GetIOCCR_G6_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x200000) >> 21
}
func (o *TSC_Type) SetIOCCR_G6_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x100000)|value<<20)
}
func (o *TSC_Type) GetIOCCR_G6_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x100000) >> 20
}
func (o *TSC_Type) SetIOCCR_G5_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x80000)|value<<19)
}
func (o *TSC_Type) GetIOCCR_G5_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x80000) >> 19
}
func (o *TSC_Type) SetIOCCR_G5_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x40000)|value<<18)
}
func (o *TSC_Type) GetIOCCR_G5_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x40000) >> 18
}
func (o *TSC_Type) SetIOCCR_G5_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x20000)|value<<17)
}
func (o *TSC_Type) GetIOCCR_G5_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x20000) >> 17
}
func (o *TSC_Type) SetIOCCR_G5_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x10000)|value<<16)
}
func (o *TSC_Type) GetIOCCR_G5_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x10000) >> 16
}
func (o *TSC_Type) SetIOCCR_G4_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x8000)|value<<15)
}
func (o *TSC_Type) GetIOCCR_G4_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x8000) >> 15
}
func (o *TSC_Type) SetIOCCR_G4_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x4000)|value<<14)
}
func (o *TSC_Type) GetIOCCR_G4_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x4000) >> 14
}
func (o *TSC_Type) SetIOCCR_G4_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x2000)|value<<13)
}
func (o *TSC_Type) GetIOCCR_G4_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x2000) >> 13
}
func (o *TSC_Type) SetIOCCR_G4_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x1000)|value<<12)
}
func (o *TSC_Type) GetIOCCR_G4_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x1000) >> 12
}
func (o *TSC_Type) SetIOCCR_G3_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x800)|value<<11)
}
func (o *TSC_Type) GetIOCCR_G3_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x800) >> 11
}
func (o *TSC_Type) SetIOCCR_G3_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x400)|value<<10)
}
func (o *TSC_Type) GetIOCCR_G3_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x400) >> 10
}
func (o *TSC_Type) SetIOCCR_G3_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x200)|value<<9)
}
func (o *TSC_Type) GetIOCCR_G3_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x200) >> 9
}
func (o *TSC_Type) SetIOCCR_G3_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x100)|value<<8)
}
func (o *TSC_Type) GetIOCCR_G3_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x100) >> 8
}
func (o *TSC_Type) SetIOCCR_G2_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x80)|value<<7)
}
func (o *TSC_Type) GetIOCCR_G2_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x80) >> 7
}
func (o *TSC_Type) SetIOCCR_G2_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x40)|value<<6)
}
func (o *TSC_Type) GetIOCCR_G2_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x40) >> 6
}
func (o *TSC_Type) SetIOCCR_G2_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x20)|value<<5)
}
func (o *TSC_Type) GetIOCCR_G2_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x20) >> 5
}
func (o *TSC_Type) SetIOCCR_G2_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x10)|value<<4)
}
func (o *TSC_Type) GetIOCCR_G2_IO1() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x10) >> 4
}
func (o *TSC_Type) SetIOCCR_G1_IO4(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x8)|value<<3)
}
func (o *TSC_Type) GetIOCCR_G1_IO4() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x8) >> 3
}
func (o *TSC_Type) SetIOCCR_G1_IO3(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x4)|value<<2)
}
func (o *TSC_Type) GetIOCCR_G1_IO3() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x4) >> 2
}
func (o *TSC_Type) SetIOCCR_G1_IO2(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetIOCCR_G1_IO2() uint32 {
	return (volatile.LoadUint32(&o.IOCCR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetIOCCR_G1_IO1(value uint32) {
	volatile.StoreUint32(&o.IOCCR.Reg, volatile.LoadUint32(&o.IOCCR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetIOCCR_G1_IO1() uint32 {
	return volatile.LoadUint32(&o.IOCCR.Reg) & 0x1
}

// TSC.IOGCSR: I/O group control status register
func (o *TSC_Type) SetIOGCSR_G8S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x800000)|value<<23)
}
func (o *TSC_Type) GetIOGCSR_G8S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x800000) >> 23
}
func (o *TSC_Type) SetIOGCSR_G7S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x400000)|value<<22)
}
func (o *TSC_Type) GetIOGCSR_G7S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x400000) >> 22
}
func (o *TSC_Type) SetIOGCSR_G6S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x200000)|value<<21)
}
func (o *TSC_Type) GetIOGCSR_G6S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x200000) >> 21
}
func (o *TSC_Type) SetIOGCSR_G5S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x100000)|value<<20)
}
func (o *TSC_Type) GetIOGCSR_G5S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x100000) >> 20
}
func (o *TSC_Type) SetIOGCSR_G4S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x80000)|value<<19)
}
func (o *TSC_Type) GetIOGCSR_G4S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x80000) >> 19
}
func (o *TSC_Type) SetIOGCSR_G3S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x40000)|value<<18)
}
func (o *TSC_Type) GetIOGCSR_G3S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x40000) >> 18
}
func (o *TSC_Type) SetIOGCSR_G2S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x20000)|value<<17)
}
func (o *TSC_Type) GetIOGCSR_G2S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x20000) >> 17
}
func (o *TSC_Type) SetIOGCSR_G1S(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x10000)|value<<16)
}
func (o *TSC_Type) GetIOGCSR_G1S() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x10000) >> 16
}
func (o *TSC_Type) SetIOGCSR_G8E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x80)|value<<7)
}
func (o *TSC_Type) GetIOGCSR_G8E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x80) >> 7
}
func (o *TSC_Type) SetIOGCSR_G7E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x40)|value<<6)
}
func (o *TSC_Type) GetIOGCSR_G7E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x40) >> 6
}
func (o *TSC_Type) SetIOGCSR_G6E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x20)|value<<5)
}
func (o *TSC_Type) GetIOGCSR_G6E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x20) >> 5
}
func (o *TSC_Type) SetIOGCSR_G5E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x10)|value<<4)
}
func (o *TSC_Type) GetIOGCSR_G5E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x10) >> 4
}
func (o *TSC_Type) SetIOGCSR_G4E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x8)|value<<3)
}
func (o *TSC_Type) GetIOGCSR_G4E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x8) >> 3
}
func (o *TSC_Type) SetIOGCSR_G3E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x4)|value<<2)
}
func (o *TSC_Type) GetIOGCSR_G3E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x4) >> 2
}
func (o *TSC_Type) SetIOGCSR_G2E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x2)|value<<1)
}
func (o *TSC_Type) GetIOGCSR_G2E() uint32 {
	return (volatile.LoadUint32(&o.IOGCSR.Reg) & 0x2) >> 1
}
func (o *TSC_Type) SetIOGCSR_G1E(value uint32) {
	volatile.StoreUint32(&o.IOGCSR.Reg, volatile.LoadUint32(&o.IOGCSR.Reg)&^(0x1)|value)
}
func (o *TSC_Type) GetIOGCSR_G1E() uint32 {
	return volatile.LoadUint32(&o.IOGCSR.Reg) & 0x1
}

// TSC.IOG1CR: I/O group x counter register
func (o *TSC_Type) SetIOG1CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG1CR.Reg, volatile.LoadUint32(&o.IOG1CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG1CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG1CR.Reg) & 0x3fff
}

// TSC.IOG2CR: I/O group x counter register
func (o *TSC_Type) SetIOG2CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG2CR.Reg, volatile.LoadUint32(&o.IOG2CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG2CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG2CR.Reg) & 0x3fff
}

// TSC.IOG3CR: I/O group x counter register
func (o *TSC_Type) SetIOG3CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG3CR.Reg, volatile.LoadUint32(&o.IOG3CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG3CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG3CR.Reg) & 0x3fff
}

// TSC.IOG4CR: I/O group x counter register
func (o *TSC_Type) SetIOG4CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG4CR.Reg, volatile.LoadUint32(&o.IOG4CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG4CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG4CR.Reg) & 0x3fff
}

// TSC.IOG5CR: I/O group x counter register
func (o *TSC_Type) SetIOG5CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG5CR.Reg, volatile.LoadUint32(&o.IOG5CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG5CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG5CR.Reg) & 0x3fff
}

// TSC.IOG6CR: I/O group x counter register
func (o *TSC_Type) SetIOG6CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG6CR.Reg, volatile.LoadUint32(&o.IOG6CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG6CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG6CR.Reg) & 0x3fff
}

// TSC.IOG7CR: I/O group x counter register
func (o *TSC_Type) SetIOG7CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG7CR.Reg, volatile.LoadUint32(&o.IOG7CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG7CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG7CR.Reg) & 0x3fff
}

// TSC.IOG8CR: I/O group x counter register
func (o *TSC_Type) SetIOG8CR_CNT(value uint32) {
	volatile.StoreUint32(&o.IOG8CR.Reg, volatile.LoadUint32(&o.IOG8CR.Reg)&^(0x3fff)|value)
}
func (o *TSC_Type) GetIOG8CR_CNT() uint32 {
	return volatile.LoadUint32(&o.IOG8CR.Reg) & 0x3fff
}

// Independent watchdog
type IWDG_Type struct {
	KR   volatile.Register32 // 0x0
	PR   volatile.Register32 // 0x4
	RLR  volatile.Register32 // 0x8
	SR   volatile.Register32 // 0xC
	WINR volatile.Register32 // 0x10
}

// IWDG.KR: Key register
func (o *IWDG_Type) SetKR_KEY(value uint32) {
	volatile.StoreUint32(&o.KR.Reg, volatile.LoadUint32(&o.KR.Reg)&^(0xffff)|value)
}
func (o *IWDG_Type) GetKR_KEY() uint32 {
	return volatile.LoadUint32(&o.KR.Reg) & 0xffff
}

// IWDG.PR: Prescaler register
func (o *IWDG_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x7)|value)
}
func (o *IWDG_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0x7
}

// IWDG.RLR: Reload register
func (o *IWDG_Type) SetRLR_RL(value uint32) {
	volatile.StoreUint32(&o.RLR.Reg, volatile.LoadUint32(&o.RLR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetRLR_RL() uint32 {
	return volatile.LoadUint32(&o.RLR.Reg) & 0xfff
}

// IWDG.SR: Status register
func (o *IWDG_Type) SetSR_WVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *IWDG_Type) GetSR_WVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *IWDG_Type) SetSR_RVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *IWDG_Type) GetSR_RVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *IWDG_Type) SetSR_PVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *IWDG_Type) GetSR_PVU() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// IWDG.WINR: Window register
func (o *IWDG_Type) SetWINR_WIN(value uint32) {
	volatile.StoreUint32(&o.WINR.Reg, volatile.LoadUint32(&o.WINR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetWINR_WIN() uint32 {
	return volatile.LoadUint32(&o.WINR.Reg) & 0xfff
}

// System window watchdog
type WWDG_Type struct {
	CR  volatile.Register32 // 0x0
	CFR volatile.Register32 // 0x4
	SR  volatile.Register32 // 0x8
}

// WWDG.CR: Control register
func (o *WWDG_Type) SetCR_WDGA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *WWDG_Type) GetCR_WDGA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *WWDG_Type) SetCR_T(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCR_T() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7f
}

// WWDG.CFR: Configuration register
func (o *WWDG_Type) SetCFR_EWI(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *WWDG_Type) GetCFR_EWI() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *WWDG_Type) SetCFR_W(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCFR_W() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCFR_WDGTB(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x180)|value<<7)
}
func (o *WWDG_Type) GetCFR_WDGTB() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x180) >> 7
}

// WWDG.SR: Status register
func (o *WWDG_Type) SetSR_EWIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *WWDG_Type) GetSR_EWIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Comparator
type COMP_Type struct {
	COMP1_CSR volatile.Register32 // 0x0
	COMP2_CSR volatile.Register32 // 0x4
}

// COMP.COMP1_CSR: Comparator 1 control and status register
func (o *COMP_Type) SetCOMP1_CSR_COMP1_EN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_EN() uint32 {
	return volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x1
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0xc)|value<<2)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0xc) >> 2
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_INMSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x70)|value<<4)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x70) >> 4
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_INPSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x80)|value<<7)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x80) >> 7
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_POLARITY(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x8000) >> 15
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_HYST(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x30000)|value<<16)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_HYST() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x30000) >> 16
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_BLANKING(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x1c0000)|value<<18)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_BLANKING() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x1c0000) >> 18
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_BRGEN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x400000)|value<<22)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_BRGEN() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x400000) >> 22
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_SCALEN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x800000)|value<<23)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x800000) >> 23
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_VALUE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_VALUE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x40000000) >> 30
}
func (o *COMP_Type) SetCOMP1_CSR_COMP1_LOCK(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetCOMP1_CSR_COMP1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x80000000) >> 31
}

// COMP.COMP2_CSR: Comparator 2 control and status register
func (o *COMP_Type) SetCOMP2_CSR_COMP2_EN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x1)|value)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_EN() uint32 {
	return volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x1
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0xc)|value<<2)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0xc) >> 2
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_INMSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x70)|value<<4)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x70) >> 4
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_INPSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x80)|value<<7)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x80) >> 7
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_WINMODE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x200)|value<<9)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_WINMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x200) >> 9
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_POLARITY(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x8000) >> 15
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_HYST(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x30000)|value<<16)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_HYST() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x30000) >> 16
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_BLANKING(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x1c0000)|value<<18)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_BLANKING() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x1c0000) >> 18
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_BRGEN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x400000)|value<<22)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_BRGEN() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x400000) >> 22
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_SCALEN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x800000)|value<<23)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_SCALEN() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x800000) >> 23
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_VALUE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_VALUE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x40000000) >> 30
}
func (o *COMP_Type) SetCOMP2_CSR_COMP2_LOCK(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP_Type) GetCOMP2_CSR_COMP2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x80000000) >> 31
}

// Firewall
type Firewall_Type struct {
	CSSA   volatile.Register32 // 0x0
	CSL    volatile.Register32 // 0x4
	NVDSSA volatile.Register32 // 0x8
	NVDSL  volatile.Register32 // 0xC
	VDSSA  volatile.Register32 // 0x10
	VDSL   volatile.Register32 // 0x14
	_      [8]byte
	CR     volatile.Register32 // 0x20
}

// Firewall.CSSA: Code segment start address
func (o *Firewall_Type) SetCSSA_ADD(value uint32) {
	volatile.StoreUint32(&o.CSSA.Reg, volatile.LoadUint32(&o.CSSA.Reg)&^(0xffff00)|value<<8)
}
func (o *Firewall_Type) GetCSSA_ADD() uint32 {
	return (volatile.LoadUint32(&o.CSSA.Reg) & 0xffff00) >> 8
}

// Firewall.CSL: Code segment length
func (o *Firewall_Type) SetCSL_LENG(value uint32) {
	volatile.StoreUint32(&o.CSL.Reg, volatile.LoadUint32(&o.CSL.Reg)&^(0x3fff00)|value<<8)
}
func (o *Firewall_Type) GetCSL_LENG() uint32 {
	return (volatile.LoadUint32(&o.CSL.Reg) & 0x3fff00) >> 8
}

// Firewall.NVDSSA: Non-volatile data segment start address
func (o *Firewall_Type) SetNVDSSA_ADD(value uint32) {
	volatile.StoreUint32(&o.NVDSSA.Reg, volatile.LoadUint32(&o.NVDSSA.Reg)&^(0xffff00)|value<<8)
}
func (o *Firewall_Type) GetNVDSSA_ADD() uint32 {
	return (volatile.LoadUint32(&o.NVDSSA.Reg) & 0xffff00) >> 8
}

// Firewall.NVDSL: Non-volatile data segment length
func (o *Firewall_Type) SetNVDSL_LENG(value uint32) {
	volatile.StoreUint32(&o.NVDSL.Reg, volatile.LoadUint32(&o.NVDSL.Reg)&^(0x3fff00)|value<<8)
}
func (o *Firewall_Type) GetNVDSL_LENG() uint32 {
	return (volatile.LoadUint32(&o.NVDSL.Reg) & 0x3fff00) >> 8
}

// Firewall.VDSSA: Volatile data segment start address
func (o *Firewall_Type) SetVDSSA_ADD(value uint32) {
	volatile.StoreUint32(&o.VDSSA.Reg, volatile.LoadUint32(&o.VDSSA.Reg)&^(0xffc0)|value<<6)
}
func (o *Firewall_Type) GetVDSSA_ADD() uint32 {
	return (volatile.LoadUint32(&o.VDSSA.Reg) & 0xffc0) >> 6
}

// Firewall.VDSL: Volatile data segment length
func (o *Firewall_Type) SetVDSL_LENG(value uint32) {
	volatile.StoreUint32(&o.VDSL.Reg, volatile.LoadUint32(&o.VDSL.Reg)&^(0xffc0)|value<<6)
}
func (o *Firewall_Type) GetVDSL_LENG() uint32 {
	return (volatile.LoadUint32(&o.VDSL.Reg) & 0xffc0) >> 6
}

// Firewall.CR: Configuration register
func (o *Firewall_Type) SetCR_VDE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *Firewall_Type) GetCR_VDE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *Firewall_Type) SetCR_VDS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *Firewall_Type) GetCR_VDS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *Firewall_Type) SetCR_FPA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *Firewall_Type) GetCR_FPA() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// Inter-integrated circuit
type I2C_Type struct {
	CR1      volatile.Register32 // 0x0
	CR2      volatile.Register32 // 0x4
	OAR1     volatile.Register32 // 0x8
	OAR2     volatile.Register32 // 0xC
	TIMINGR  volatile.Register32 // 0x10
	TIMEOUTR volatile.Register32 // 0x14
	ISR      volatile.Register32 // 0x18
	ICR      volatile.Register32 // 0x1C
	PECR     volatile.Register32 // 0x20
	RXDR     volatile.Register32 // 0x24
	TXDR     volatile.Register32 // 0x28
}

// I2C.CR1: Control register 1
func (o *I2C_Type) SetCR1_PE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCR1_PE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *I2C_Type) SetCR1_TXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCR1_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCR1_RXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCR1_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCR1_ADDRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCR1_ADDRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCR1_NACKIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCR1_NACKIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCR1_STOPIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCR1_STOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCR1_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCR1_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCR1_DNF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00)|value<<8)
}
func (o *I2C_Type) GetCR1_DNF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00) >> 8
}
func (o *I2C_Type) SetCR1_ANFOFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR1_ANFOFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR1_SBC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetCR1_SBC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetCR1_NOSTRETCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetCR1_NOSTRETCH() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetCR1_WUPEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetCR1_WUPEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *I2C_Type) SetCR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetCR1_GCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetCR1_SMBHEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetCR1_SMBHEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetCR1_SMBDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetCR1_SMBDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *I2C_Type) SetCR1_ALERTEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400000)|value<<22)
}
func (o *I2C_Type) GetCR1_ALERTEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400000) >> 22
}
func (o *I2C_Type) SetCR1_PECEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *I2C_Type) GetCR1_PECEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}

// I2C.CR2: Control register 2
func (o *I2C_Type) SetCR2_PECBYTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C_Type) GetCR2_PECBYTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000000) >> 26
}
func (o *I2C_Type) SetCR2_AUTOEND(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetCR2_AUTOEND() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}
func (o *I2C_Type) SetCR2_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetCR2_RELOAD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetCR2_NBYTES(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C_Type) GetCR2_NBYTES() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff0000) >> 16
}
func (o *I2C_Type) SetCR2_NACK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR2_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR2_START(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetCR2_START() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetCR2_HEAD10R(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR2_HEAD10R() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR2_ADD10(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCR2_ADD10() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCR2_RD_WRN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCR2_RD_WRN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCR2_SADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetCR2_SADD() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x3ff
}

// I2C.OAR1: Own address register 1
func (o *I2C_Type) SetOAR1_OA1(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetOAR1_OA1() uint32 {
	return volatile.LoadUint32(&o.OAR1.Reg) & 0x3ff
}
func (o *I2C_Type) SetOAR1_OA1MODE(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetOAR1_OA1MODE() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetOAR1_OA1EN(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR1_OA1EN() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x8000) >> 15
}

// I2C.OAR2: Own address register 2
func (o *I2C_Type) SetOAR2_OA2(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOAR2_OA2() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOAR2_OA2MSK(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x700)|value<<8)
}
func (o *I2C_Type) GetOAR2_OA2MSK() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x700) >> 8
}
func (o *I2C_Type) SetOAR2_OA2EN(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR2_OA2EN() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x8000) >> 15
}

// I2C.TIMINGR: Timing register
func (o *I2C_Type) SetTIMINGR_SCLL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTIMINGR_SCLL() uint32 {
	return volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff
}
func (o *I2C_Type) SetTIMINGR_SCLH(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff00)|value<<8)
}
func (o *I2C_Type) GetTIMINGR_SCLH() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff00) >> 8
}
func (o *I2C_Type) SetTIMINGR_SDADEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000)|value<<16)
}
func (o *I2C_Type) GetTIMINGR_SDADEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000) >> 16
}
func (o *I2C_Type) SetTIMINGR_SCLDEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf00000)|value<<20)
}
func (o *I2C_Type) GetTIMINGR_SCLDEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf00000) >> 20
}
func (o *I2C_Type) SetTIMINGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000000)|value<<28)
}
func (o *I2C_Type) GetTIMINGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000000) >> 28
}

// I2C.TIMEOUTR: Status register 1
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTA(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff)|value)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTA() uint32 {
	return volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff
}
func (o *I2C_Type) SetTIMEOUTR_TIDLE(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetTIMEOUTR_TIDLE() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetTIMEOUTR_TIMOUTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetTIMEOUTR_TIMOUTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTB(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff0000)|value<<16)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTB() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff0000) >> 16
}
func (o *I2C_Type) SetTIMEOUTR_TEXTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetTIMEOUTR_TEXTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x80000000) >> 31
}

// I2C.ISR: Interrupt and Status register
func (o *I2C_Type) SetISR_ADDCODE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xfe0000)|value<<17)
}
func (o *I2C_Type) GetISR_ADDCODE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xfe0000) >> 17
}
func (o *I2C_Type) SetISR_DIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetISR_ALERT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetISR_ALERT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetISR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetISR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetISR_PECERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetISR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetISR_ARLO(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetISR_ARLO() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetISR_BERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetISR_BERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetISR_TCR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetISR_TCR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetISR_STOPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetISR_STOPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetISR_NACKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetISR_NACKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetISR_ADDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetISR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetISR_TXIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetISR_TXIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetISR_TXE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// I2C.ICR: Interrupt clear register
func (o *I2C_Type) SetICR_ALERTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetICR_ALERTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetICR_TIMOUTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetICR_TIMOUTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetICR_PECCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetICR_PECCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetICR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetICR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetICR_ARLOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetICR_ARLOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetICR_BERRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetICR_BERRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetICR_STOPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetICR_STOPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetICR_NACKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetICR_NACKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetICR_ADDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetICR_ADDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}

// I2C.PECR: PEC register
func (o *I2C_Type) SetPECR_PEC(value uint32) {
	volatile.StoreUint32(&o.PECR.Reg, volatile.LoadUint32(&o.PECR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetPECR_PEC() uint32 {
	return volatile.LoadUint32(&o.PECR.Reg) & 0xff
}

// I2C.RXDR: Receive data register
func (o *I2C_Type) SetRXDR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetRXDR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// I2C.TXDR: Transmit data register
func (o *I2C_Type) SetTXDR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTXDR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// Flash
type Flash_Type struct {
	ACR      volatile.Register32 // 0x0
	PDKEYR   volatile.Register32 // 0x4
	KEYR     volatile.Register32 // 0x8
	OPTKEYR  volatile.Register32 // 0xC
	SR       volatile.Register32 // 0x10
	CR       volatile.Register32 // 0x14
	ECCR     volatile.Register32 // 0x18
	_        [4]byte
	OPTR     volatile.Register32 // 0x20
	PCROP1SR volatile.Register32 // 0x24
	PCROP1ER volatile.Register32 // 0x28
	WRP1AR   volatile.Register32 // 0x2C
	WRP1BR   volatile.Register32 // 0x30
	_        [16]byte
	PCROP2SR volatile.Register32 // 0x44
	PCROP2ER volatile.Register32 // 0x48
	WRP2AR   volatile.Register32 // 0x4C
	WRP2BR   volatile.Register32 // 0x50
}

// Flash.ACR: Access control register
func (o *Flash_Type) SetACR_LATENCY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x7)|value)
}
func (o *Flash_Type) GetACR_LATENCY() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x7
}
func (o *Flash_Type) SetACR_PRFTEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetACR_PRFTEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetACR_ICEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *Flash_Type) GetACR_ICEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *Flash_Type) SetACR_DCEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x400)|value<<10)
}
func (o *Flash_Type) GetACR_DCEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x400) >> 10
}
func (o *Flash_Type) SetACR_ICRST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x800)|value<<11)
}
func (o *Flash_Type) GetACR_ICRST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x800) >> 11
}
func (o *Flash_Type) SetACR_DCRST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1000)|value<<12)
}
func (o *Flash_Type) GetACR_DCRST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x1000) >> 12
}
func (o *Flash_Type) SetACR_RUN_PD(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2000)|value<<13)
}
func (o *Flash_Type) GetACR_RUN_PD() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2000) >> 13
}
func (o *Flash_Type) SetACR_SLEEP_PD(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4000)|value<<14)
}
func (o *Flash_Type) GetACR_SLEEP_PD() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4000) >> 14
}

// Flash.PDKEYR: Power down key register
func (o *Flash_Type) SetPDKEYR(value uint32) {
	volatile.StoreUint32(&o.PDKEYR.Reg, value)
}
func (o *Flash_Type) GetPDKEYR() uint32 {
	return volatile.LoadUint32(&o.PDKEYR.Reg)
}

// Flash.KEYR: Flash key register
func (o *Flash_Type) SetKEYR(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, value)
}
func (o *Flash_Type) GetKEYR() uint32 {
	return volatile.LoadUint32(&o.KEYR.Reg)
}

// Flash.OPTKEYR: Option byte key register
func (o *Flash_Type) SetOPTKEYR(value uint32) {
	volatile.StoreUint32(&o.OPTKEYR.Reg, value)
}
func (o *Flash_Type) GetOPTKEYR() uint32 {
	return volatile.LoadUint32(&o.OPTKEYR.Reg)
}

// Flash.SR: Status register
func (o *Flash_Type) SetSR_EOP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *Flash_Type) GetSR_EOP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *Flash_Type) SetSR_OPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *Flash_Type) GetSR_OPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *Flash_Type) SetSR_PROGERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *Flash_Type) GetSR_PROGERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *Flash_Type) SetSR_WRPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *Flash_Type) GetSR_WRPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *Flash_Type) SetSR_PGAERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *Flash_Type) GetSR_PGAERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *Flash_Type) SetSR_SIZERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *Flash_Type) GetSR_SIZERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *Flash_Type) SetSR_PGSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *Flash_Type) GetSR_PGSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *Flash_Type) SetSR_MISERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetSR_MISERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetSR_FASTERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *Flash_Type) GetSR_FASTERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *Flash_Type) SetSR_RDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *Flash_Type) GetSR_RDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *Flash_Type) SetSR_OPTVERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *Flash_Type) GetSR_OPTVERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *Flash_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}

// Flash.CR: Flash control register
func (o *Flash_Type) SetCR_PG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *Flash_Type) GetCR_PG() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *Flash_Type) SetCR_PER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *Flash_Type) GetCR_PER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *Flash_Type) SetCR_MER1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *Flash_Type) GetCR_MER1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *Flash_Type) SetCR_PNB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7f8)|value<<3)
}
func (o *Flash_Type) GetCR_PNB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7f8) >> 3
}
func (o *Flash_Type) SetCR_BKER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *Flash_Type) GetCR_BKER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *Flash_Type) SetCR_MER2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *Flash_Type) GetCR_MER2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *Flash_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetCR_OPTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *Flash_Type) GetCR_OPTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *Flash_Type) SetCR_FSTPG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetCR_FSTPG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetCR_EOPIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetCR_EOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *Flash_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *Flash_Type) SetCR_RDERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *Flash_Type) GetCR_RDERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *Flash_Type) SetCR_OBL_LAUNCH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *Flash_Type) GetCR_OBL_LAUNCH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *Flash_Type) SetCR_OPTLOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetCR_OPTLOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *Flash_Type) SetCR_LOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetCR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// Flash.ECCR: Flash ECC register
func (o *Flash_Type) SetECCR_ADDR_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x7ffff)|value)
}
func (o *Flash_Type) GetECCR_ADDR_ECC() uint32 {
	return volatile.LoadUint32(&o.ECCR.Reg) & 0x7ffff
}
func (o *Flash_Type) SetECCR_BK_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x80000)|value<<19)
}
func (o *Flash_Type) GetECCR_BK_ECC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x80000) >> 19
}
func (o *Flash_Type) SetECCR_SYSF_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x100000)|value<<20)
}
func (o *Flash_Type) GetECCR_SYSF_ECC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x100000) >> 20
}
func (o *Flash_Type) SetECCR_ECCIE(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetECCR_ECCIE() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetECCR_ECCC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetECCR_ECCC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x40000000) >> 30
}
func (o *Flash_Type) SetECCR_ECCD(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetECCR_ECCD() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x80000000) >> 31
}

// Flash.OPTR: Flash option register
func (o *Flash_Type) SetOPTR_RDP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetOPTR_RDP() uint32 {
	return volatile.LoadUint32(&o.OPTR.Reg) & 0xff
}
func (o *Flash_Type) SetOPTR_BOR_LEV(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x700)|value<<8)
}
func (o *Flash_Type) GetOPTR_BOR_LEV() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x700) >> 8
}
func (o *Flash_Type) SetOPTR_NRST_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x1000)|value<<12)
}
func (o *Flash_Type) GetOPTR_NRST_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x1000) >> 12
}
func (o *Flash_Type) SetOPTR_NRST_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x2000)|value<<13)
}
func (o *Flash_Type) GetOPTR_NRST_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x2000) >> 13
}
func (o *Flash_Type) SetOPTR_IDWG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetOPTR_IDWG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetOPTR_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x20000)|value<<17)
}
func (o *Flash_Type) GetOPTR_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x20000) >> 17
}
func (o *Flash_Type) SetOPTR_IWDG_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetOPTR_IWDG_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetOPTR_WWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x80000)|value<<19)
}
func (o *Flash_Type) GetOPTR_WWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x80000) >> 19
}
func (o *Flash_Type) SetOPTR_BFB2(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x100000)|value<<20)
}
func (o *Flash_Type) GetOPTR_BFB2() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x100000) >> 20
}
func (o *Flash_Type) SetOPTR_DUALBANK(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x200000)|value<<21)
}
func (o *Flash_Type) GetOPTR_DUALBANK() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x200000) >> 21
}
func (o *Flash_Type) SetOPTR_NBOOT1(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x800000)|value<<23)
}
func (o *Flash_Type) GetOPTR_NBOOT1() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x800000) >> 23
}
func (o *Flash_Type) SetOPTR_SRAM2_PE(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetOPTR_SRAM2_PE() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetOPTR_SRAM2_RST(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x2000000)|value<<25)
}
func (o *Flash_Type) GetOPTR_SRAM2_RST() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x2000000) >> 25
}
func (o *Flash_Type) SetOPTR_NSWBOOT0(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x4000000)|value<<26)
}
func (o *Flash_Type) GetOPTR_NSWBOOT0() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x4000000) >> 26
}
func (o *Flash_Type) SetOPTR_NBOOT0(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x8000000)|value<<27)
}
func (o *Flash_Type) GetOPTR_NBOOT0() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x8000000) >> 27
}

// Flash.PCROP1SR: Flash Bank 1 PCROP Start address register
func (o *Flash_Type) SetPCROP1SR_PCROP1_STRT(value uint32) {
	volatile.StoreUint32(&o.PCROP1SR.Reg, volatile.LoadUint32(&o.PCROP1SR.Reg)&^(0xffff)|value)
}
func (o *Flash_Type) GetPCROP1SR_PCROP1_STRT() uint32 {
	return volatile.LoadUint32(&o.PCROP1SR.Reg) & 0xffff
}

// Flash.PCROP1ER: Flash Bank 1 PCROP End address register
func (o *Flash_Type) SetPCROP1ER_PCROP1_END(value uint32) {
	volatile.StoreUint32(&o.PCROP1ER.Reg, volatile.LoadUint32(&o.PCROP1ER.Reg)&^(0xffff)|value)
}
func (o *Flash_Type) GetPCROP1ER_PCROP1_END() uint32 {
	return volatile.LoadUint32(&o.PCROP1ER.Reg) & 0xffff
}
func (o *Flash_Type) SetPCROP1ER_PCROP_RDP(value uint32) {
	volatile.StoreUint32(&o.PCROP1ER.Reg, volatile.LoadUint32(&o.PCROP1ER.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetPCROP1ER_PCROP_RDP() uint32 {
	return (volatile.LoadUint32(&o.PCROP1ER.Reg) & 0x80000000) >> 31
}

// Flash.WRP1AR: Flash Bank 1 WRP area A address register
func (o *Flash_Type) SetWRP1AR_WRP1A_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP1AR.Reg, volatile.LoadUint32(&o.WRP1AR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetWRP1AR_WRP1A_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP1AR.Reg) & 0xff
}
func (o *Flash_Type) SetWRP1AR_WRP1A_END(value uint32) {
	volatile.StoreUint32(&o.WRP1AR.Reg, volatile.LoadUint32(&o.WRP1AR.Reg)&^(0xff0000)|value<<16)
}
func (o *Flash_Type) GetWRP1AR_WRP1A_END() uint32 {
	return (volatile.LoadUint32(&o.WRP1AR.Reg) & 0xff0000) >> 16
}

// Flash.WRP1BR: Flash Bank 1 WRP area B address register
func (o *Flash_Type) SetWRP1BR_WRP1B_END(value uint32) {
	volatile.StoreUint32(&o.WRP1BR.Reg, volatile.LoadUint32(&o.WRP1BR.Reg)&^(0xff0000)|value<<16)
}
func (o *Flash_Type) GetWRP1BR_WRP1B_END() uint32 {
	return (volatile.LoadUint32(&o.WRP1BR.Reg) & 0xff0000) >> 16
}
func (o *Flash_Type) SetWRP1BR_WRP1B_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP1BR.Reg, volatile.LoadUint32(&o.WRP1BR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetWRP1BR_WRP1B_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP1BR.Reg) & 0xff
}

// Flash.PCROP2SR: Flash Bank 2 PCROP Start address register
func (o *Flash_Type) SetPCROP2SR_PCROP2_STRT(value uint32) {
	volatile.StoreUint32(&o.PCROP2SR.Reg, volatile.LoadUint32(&o.PCROP2SR.Reg)&^(0xffff)|value)
}
func (o *Flash_Type) GetPCROP2SR_PCROP2_STRT() uint32 {
	return volatile.LoadUint32(&o.PCROP2SR.Reg) & 0xffff
}

// Flash.PCROP2ER: Flash Bank 2 PCROP End address register
func (o *Flash_Type) SetPCROP2ER_PCROP2_END(value uint32) {
	volatile.StoreUint32(&o.PCROP2ER.Reg, volatile.LoadUint32(&o.PCROP2ER.Reg)&^(0xffff)|value)
}
func (o *Flash_Type) GetPCROP2ER_PCROP2_END() uint32 {
	return volatile.LoadUint32(&o.PCROP2ER.Reg) & 0xffff
}

// Flash.WRP2AR: Flash Bank 2 WRP area A address register
func (o *Flash_Type) SetWRP2AR_WRP2A_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP2AR.Reg, volatile.LoadUint32(&o.WRP2AR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetWRP2AR_WRP2A_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP2AR.Reg) & 0xff
}
func (o *Flash_Type) SetWRP2AR_WRP2A_END(value uint32) {
	volatile.StoreUint32(&o.WRP2AR.Reg, volatile.LoadUint32(&o.WRP2AR.Reg)&^(0xff0000)|value<<16)
}
func (o *Flash_Type) GetWRP2AR_WRP2A_END() uint32 {
	return (volatile.LoadUint32(&o.WRP2AR.Reg) & 0xff0000) >> 16
}

// Flash.WRP2BR: Flash Bank 2 WRP area B address register
func (o *Flash_Type) SetWRP2BR_WRP2B_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP2BR.Reg, volatile.LoadUint32(&o.WRP2BR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetWRP2BR_WRP2B_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP2BR.Reg) & 0xff
}
func (o *Flash_Type) SetWRP2BR_WRP2B_END(value uint32) {
	volatile.StoreUint32(&o.WRP2BR.Reg, volatile.LoadUint32(&o.WRP2BR.Reg)&^(0xff0000)|value<<16)
}
func (o *Flash_Type) GetWRP2BR_WRP2B_END() uint32 {
	return (volatile.LoadUint32(&o.WRP2BR.Reg) & 0xff0000) >> 16
}

// Debug support
type DBGMCU_Type struct {
	IDCODE    volatile.Register32 // 0x0
	CR        volatile.Register32 // 0x4
	APB1_FZR1 volatile.Register32 // 0x8
	APB1_FZR2 volatile.Register32 // 0xC
	APB2_FZR  volatile.Register32 // 0x10
}

// DBGMCU.IDCODE: MCU Device ID Code Register
func (o *DBGMCU_Type) SetIDCODE_DEV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODE.Reg, volatile.LoadUint32(&o.IDCODE.Reg)&^(0xffff)|value)
}
func (o *DBGMCU_Type) GetIDCODE_DEV_ID() uint32 {
	return volatile.LoadUint32(&o.IDCODE.Reg) & 0xffff
}
func (o *DBGMCU_Type) SetIDCODE_REV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODE.Reg, volatile.LoadUint32(&o.IDCODE.Reg)&^(0xffff0000)|value<<16)
}
func (o *DBGMCU_Type) GetIDCODE_REV_ID() uint32 {
	return (volatile.LoadUint32(&o.IDCODE.Reg) & 0xffff0000) >> 16
}

// DBGMCU.CR: Debug MCU Configuration Register
func (o *DBGMCU_Type) SetCR_DBG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetCR_DBG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DBGMCU_Type) SetCR_DBG_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetCR_DBG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetCR_DBG_STANDBY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetCR_DBG_STANDBY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetCR_TRACE_IOEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetCR_TRACE_IOEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetCR_TRACE_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DBGMCU_Type) GetCR_TRACE_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}

// DBGMCU.APB1_FZR1: APB Low Freeze Register 1
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_TIMER2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_TIMER2_STOP() uint32 {
	return volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_TIM3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_TIM3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_TIM4_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_TIM4_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_TIM5_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x8)|value<<3)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_TIM5_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x8) >> 3
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_TIMER6_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x10)|value<<4)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_TIMER6_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x10) >> 4
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_TIM7_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_TIM7_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_RTC_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x400)|value<<10)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_RTC_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x400) >> 10
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_WWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_WWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x1000)|value<<12)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x1000) >> 12
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_I2C1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x200000)|value<<21)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_I2C1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x200000) >> 21
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_I2C2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x400000)|value<<22)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_I2C2_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x400000) >> 22
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_I2C3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x800000)|value<<23)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_I2C3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x800000) >> 23
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_CAN_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x2000000)|value<<25)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_CAN_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x2000000) >> 25
}
func (o *DBGMCU_Type) SetAPB1_FZR1_DBG_LPTIMER_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR1.Reg, volatile.LoadUint32(&o.APB1_FZR1.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGMCU_Type) GetAPB1_FZR1_DBG_LPTIMER_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR1.Reg) & 0x80000000) >> 31
}

// DBGMCU.APB1_FZR2: APB Low Freeze Register 2
func (o *DBGMCU_Type) SetAPB1_FZR2_DBG_LPTIM2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZR2.Reg, volatile.LoadUint32(&o.APB1_FZR2.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetAPB1_FZR2_DBG_LPTIM2_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZR2.Reg) & 0x20) >> 5
}

// DBGMCU.APB2_FZR: APB High Freeze Register
func (o *DBGMCU_Type) SetAPB2_FZR_DBG_TIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZR.Reg, volatile.LoadUint32(&o.APB2_FZR.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB2_FZR_DBG_TIM1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZR.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB2_FZR_DBG_TIM8_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZR.Reg, volatile.LoadUint32(&o.APB2_FZR.Reg)&^(0x2000)|value<<13)
}
func (o *DBGMCU_Type) GetAPB2_FZR_DBG_TIM8_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZR.Reg) & 0x2000) >> 13
}
func (o *DBGMCU_Type) SetAPB2_FZR_DBG_TIM15_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZR.Reg, volatile.LoadUint32(&o.APB2_FZR.Reg)&^(0x10000)|value<<16)
}
func (o *DBGMCU_Type) GetAPB2_FZR_DBG_TIM15_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZR.Reg) & 0x10000) >> 16
}
func (o *DBGMCU_Type) SetAPB2_FZR_DBG_TIM16_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZR.Reg, volatile.LoadUint32(&o.APB2_FZR.Reg)&^(0x20000)|value<<17)
}
func (o *DBGMCU_Type) GetAPB2_FZR_DBG_TIM16_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZR.Reg) & 0x20000) >> 17
}
func (o *DBGMCU_Type) SetAPB2_FZR_DBG_TIM17_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZR.Reg, volatile.LoadUint32(&o.APB2_FZR.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB2_FZR_DBG_TIM17_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZR.Reg) & 0x40000) >> 18
}

// OctoSPI
type OctoSPI_Type struct {
	CR     volatile.Register32 // 0x0
	_      [4]byte
	DCR1   volatile.Register32 // 0x8
	DCR2   volatile.Register32 // 0xC
	DCR3   volatile.Register32 // 0x10
	_      [12]byte
	SR     volatile.Register32 // 0x20
	FCR    volatile.Register32 // 0x24
	_      [24]byte
	DLR    volatile.Register32 // 0x40
	_      [4]byte
	AR     volatile.Register32 // 0x48
	_      [4]byte
	DR     volatile.Register32 // 0x50
	_      [44]byte
	PSMKR  volatile.Register32 // 0x80
	_      [4]byte
	PSMAR  volatile.Register32 // 0x88
	_      [4]byte
	PIR    volatile.Register32 // 0x90
	_      [108]byte
	CCR    volatile.Register32 // 0x100
	_      [4]byte
	TCR    volatile.Register32 // 0x108
	_      [4]byte
	IR     volatile.Register32 // 0x110
	_      [12]byte
	ABR    volatile.Register32 // 0x120
	_      [12]byte
	LPTR   volatile.Register32 // 0x130
	_      [76]byte
	WCCR   volatile.Register32 // 0x180
	_      [4]byte
	WTCR   volatile.Register32 // 0x188
	_      [4]byte
	WIR    volatile.Register32 // 0x190
	_      [12]byte
	WABR   volatile.Register32 // 0x1A0
	_      [92]byte
	HLCR   volatile.Register32 // 0x200
	_      [492]byte
	HWCFGR volatile.Register32 // 0x3F0
	VER    volatile.Register32 // 0x3F4
	ID     volatile.Register32 // 0x3F8
	MID    volatile.Register32 // 0x3FC
}

// OctoSPI.CR: control register
func (o *OctoSPI_Type) SetCR_FMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000000)|value<<28)
}
func (o *OctoSPI_Type) GetCR_FMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000000) >> 28
}
func (o *OctoSPI_Type) SetCR_PMM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *OctoSPI_Type) GetCR_PMM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *OctoSPI_Type) SetCR_APMS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *OctoSPI_Type) GetCR_APMS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *OctoSPI_Type) SetCR_TOIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *OctoSPI_Type) GetCR_TOIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *OctoSPI_Type) SetCR_SMIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetCR_SMIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetCR_FTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *OctoSPI_Type) GetCR_FTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *OctoSPI_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *OctoSPI_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *OctoSPI_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *OctoSPI_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *OctoSPI_Type) SetCR_FTHRES(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1f00)|value<<8)
}
func (o *OctoSPI_Type) GetCR_FTHRES() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1f00) >> 8
}
func (o *OctoSPI_Type) SetCR_FSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *OctoSPI_Type) GetCR_FSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *OctoSPI_Type) SetCR_DQM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *OctoSPI_Type) GetCR_DQM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *OctoSPI_Type) SetCR_TCEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetCR_TCEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetCR_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *OctoSPI_Type) GetCR_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *OctoSPI_Type) SetCR_ABORT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetCR_ABORT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// OctoSPI.DCR1: device configuration register
func (o *OctoSPI_Type) SetDCR1_CKMODE(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetDCR1_CKMODE() uint32 {
	return volatile.LoadUint32(&o.DCR1.Reg) & 0x1
}
func (o *OctoSPI_Type) SetDCR1_FRCK(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetDCR1_FRCK() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetDCR1_CSHT(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x700)|value<<8)
}
func (o *OctoSPI_Type) GetDCR1_CSHT() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x700) >> 8
}
func (o *OctoSPI_Type) SetDCR1_DEVSIZE(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *OctoSPI_Type) GetDCR1_DEVSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x1f0000) >> 16
}
func (o *OctoSPI_Type) SetDCR1_MTYP(value uint32) {
	volatile.StoreUint32(&o.DCR1.Reg, volatile.LoadUint32(&o.DCR1.Reg)&^(0x3000000)|value<<24)
}
func (o *OctoSPI_Type) GetDCR1_MTYP() uint32 {
	return (volatile.LoadUint32(&o.DCR1.Reg) & 0x3000000) >> 24
}

// OctoSPI.DCR2: device configuration register 2
func (o *OctoSPI_Type) SetDCR2_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.DCR2.Reg, volatile.LoadUint32(&o.DCR2.Reg)&^(0xff)|value)
}
func (o *OctoSPI_Type) GetDCR2_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.DCR2.Reg) & 0xff
}
func (o *OctoSPI_Type) SetDCR2_WRAPSIZE(value uint32) {
	volatile.StoreUint32(&o.DCR2.Reg, volatile.LoadUint32(&o.DCR2.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetDCR2_WRAPSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCR2.Reg) & 0x70000) >> 16
}

// OctoSPI.DCR3: device configuration register 3
func (o *OctoSPI_Type) SetDCR3_CSBOUND(value uint32) {
	volatile.StoreUint32(&o.DCR3.Reg, volatile.LoadUint32(&o.DCR3.Reg)&^(0x1f0000)|value<<16)
}
func (o *OctoSPI_Type) GetDCR3_CSBOUND() uint32 {
	return (volatile.LoadUint32(&o.DCR3.Reg) & 0x1f0000) >> 16
}

// OctoSPI.SR: status register
func (o *OctoSPI_Type) SetSR_TEF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetSR_TEF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *OctoSPI_Type) SetSR_TCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetSR_FTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *OctoSPI_Type) GetSR_FTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *OctoSPI_Type) SetSR_SMF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetSR_SMF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetSR_TOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *OctoSPI_Type) GetSR_TOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *OctoSPI_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *OctoSPI_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *OctoSPI_Type) SetSR_FLEVEL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x3f00)|value<<8)
}
func (o *OctoSPI_Type) GetSR_FLEVEL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x3f00) >> 8
}

// OctoSPI.FCR: flag clear register
func (o *OctoSPI_Type) SetFCR_CTEF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetFCR_CTEF() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0x1
}
func (o *OctoSPI_Type) SetFCR_CTCF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetFCR_CTCF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetFCR_CSMF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetFCR_CSMF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetFCR_CTOF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x10)|value<<4)
}
func (o *OctoSPI_Type) GetFCR_CTOF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x10) >> 4
}

// OctoSPI.DLR: data length register
func (o *OctoSPI_Type) SetDLR(value uint32) {
	volatile.StoreUint32(&o.DLR.Reg, value)
}
func (o *OctoSPI_Type) GetDLR() uint32 {
	return volatile.LoadUint32(&o.DLR.Reg)
}

// OctoSPI.AR: address register
func (o *OctoSPI_Type) SetAR(value uint32) {
	volatile.StoreUint32(&o.AR.Reg, value)
}
func (o *OctoSPI_Type) GetAR() uint32 {
	return volatile.LoadUint32(&o.AR.Reg)
}

// OctoSPI.DR: data register
func (o *OctoSPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *OctoSPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// OctoSPI.PSMKR: polling status mask register
func (o *OctoSPI_Type) SetPSMKR(value uint32) {
	volatile.StoreUint32(&o.PSMKR.Reg, value)
}
func (o *OctoSPI_Type) GetPSMKR() uint32 {
	return volatile.LoadUint32(&o.PSMKR.Reg)
}

// OctoSPI.PSMAR: polling status match register
func (o *OctoSPI_Type) SetPSMAR(value uint32) {
	volatile.StoreUint32(&o.PSMAR.Reg, value)
}
func (o *OctoSPI_Type) GetPSMAR() uint32 {
	return volatile.LoadUint32(&o.PSMAR.Reg)
}

// OctoSPI.PIR: polling interval register
func (o *OctoSPI_Type) SetPIR_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0xffff)|value)
}
func (o *OctoSPI_Type) GetPIR_INTERVAL() uint32 {
	return volatile.LoadUint32(&o.PIR.Reg) & 0xffff
}

// OctoSPI.CCR: communication configuration register
func (o *OctoSPI_Type) SetCCR_IMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x7)|value)
}
func (o *OctoSPI_Type) GetCCR_IMODE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x7
}
func (o *OctoSPI_Type) SetCCR_IDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetCCR_IDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetCCR_ISIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x30)|value<<4)
}
func (o *OctoSPI_Type) GetCCR_ISIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x30) >> 4
}
func (o *OctoSPI_Type) SetCCR_ADMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x700)|value<<8)
}
func (o *OctoSPI_Type) GetCCR_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x700) >> 8
}
func (o *OctoSPI_Type) SetCCR_ADDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x800)|value<<11)
}
func (o *OctoSPI_Type) GetCCR_ADDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x800) >> 11
}
func (o *OctoSPI_Type) SetCCR_ADSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3000)|value<<12)
}
func (o *OctoSPI_Type) GetCCR_ADSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x3000) >> 12
}
func (o *OctoSPI_Type) SetCCR_ABMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetCCR_ABMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x70000) >> 16
}
func (o *OctoSPI_Type) SetCCR_ABDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetCCR_ABDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetCCR_ABSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x300000)|value<<20)
}
func (o *OctoSPI_Type) GetCCR_ABSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x300000) >> 20
}
func (o *OctoSPI_Type) SetCCR_DMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x7000000)|value<<24)
}
func (o *OctoSPI_Type) GetCCR_DMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x7000000) >> 24
}
func (o *OctoSPI_Type) SetCCR_DDTR(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8000000)|value<<27)
}
func (o *OctoSPI_Type) GetCCR_DDTR() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8000000) >> 27
}
func (o *OctoSPI_Type) SetCCR_DQSE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20000000)|value<<29)
}
func (o *OctoSPI_Type) GetCCR_DQSE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20000000) >> 29
}
func (o *OctoSPI_Type) SetCCR_SIOO(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80000000)|value<<31)
}
func (o *OctoSPI_Type) GetCCR_SIOO() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80000000) >> 31
}

// OctoSPI.TCR: timing configuration register
func (o *OctoSPI_Type) SetTCR_DCYC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1f)|value)
}
func (o *OctoSPI_Type) GetTCR_DCYC() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1f
}
func (o *OctoSPI_Type) SetTCR_DHQC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10000000)|value<<28)
}
func (o *OctoSPI_Type) GetTCR_DHQC() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10000000) >> 28
}
func (o *OctoSPI_Type) SetTCR_SSHIFT(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x40000000)|value<<30)
}
func (o *OctoSPI_Type) GetTCR_SSHIFT() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x40000000) >> 30
}

// OctoSPI.IR: instruction register
func (o *OctoSPI_Type) SetIR(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, value)
}
func (o *OctoSPI_Type) GetIR() uint32 {
	return volatile.LoadUint32(&o.IR.Reg)
}

// OctoSPI.ABR: alternate bytes register
func (o *OctoSPI_Type) SetABR(value uint32) {
	volatile.StoreUint32(&o.ABR.Reg, value)
}
func (o *OctoSPI_Type) GetABR() uint32 {
	return volatile.LoadUint32(&o.ABR.Reg)
}

// OctoSPI.LPTR: low-power timeout register
func (o *OctoSPI_Type) SetLPTR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPTR.Reg, volatile.LoadUint32(&o.LPTR.Reg)&^(0xffff)|value)
}
func (o *OctoSPI_Type) GetLPTR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.LPTR.Reg) & 0xffff
}

// OctoSPI.WCCR: write communication configuration register
func (o *OctoSPI_Type) SetWCCR_IMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x7)|value)
}
func (o *OctoSPI_Type) GetWCCR_IMODE() uint32 {
	return volatile.LoadUint32(&o.WCCR.Reg) & 0x7
}
func (o *OctoSPI_Type) SetWCCR_IDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x8)|value<<3)
}
func (o *OctoSPI_Type) GetWCCR_IDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x8) >> 3
}
func (o *OctoSPI_Type) SetWCCR_ISIZE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x30)|value<<4)
}
func (o *OctoSPI_Type) GetWCCR_ISIZE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x30) >> 4
}
func (o *OctoSPI_Type) SetWCCR_ADMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x700)|value<<8)
}
func (o *OctoSPI_Type) GetWCCR_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x700) >> 8
}
func (o *OctoSPI_Type) SetWCCR_ADDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x800)|value<<11)
}
func (o *OctoSPI_Type) GetWCCR_ADDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x800) >> 11
}
func (o *OctoSPI_Type) SetWCCR_ADSIZE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x3000)|value<<12)
}
func (o *OctoSPI_Type) GetWCCR_ADSIZE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x3000) >> 12
}
func (o *OctoSPI_Type) SetWCCR_ABMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x70000)|value<<16)
}
func (o *OctoSPI_Type) GetWCCR_ABMODE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x70000) >> 16
}
func (o *OctoSPI_Type) SetWCCR_ABDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x80000)|value<<19)
}
func (o *OctoSPI_Type) GetWCCR_ABDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x80000) >> 19
}
func (o *OctoSPI_Type) SetWCCR_ABSIZE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x300000)|value<<20)
}
func (o *OctoSPI_Type) GetWCCR_ABSIZE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x300000) >> 20
}
func (o *OctoSPI_Type) SetWCCR_DMODE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x7000000)|value<<24)
}
func (o *OctoSPI_Type) GetWCCR_DMODE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x7000000) >> 24
}
func (o *OctoSPI_Type) SetWCCR_DDTR(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x8000000)|value<<27)
}
func (o *OctoSPI_Type) GetWCCR_DDTR() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x8000000) >> 27
}
func (o *OctoSPI_Type) SetWCCR_DQSE(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x20000000)|value<<29)
}
func (o *OctoSPI_Type) GetWCCR_DQSE() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x20000000) >> 29
}
func (o *OctoSPI_Type) SetWCCR_SIOO(value uint32) {
	volatile.StoreUint32(&o.WCCR.Reg, volatile.LoadUint32(&o.WCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *OctoSPI_Type) GetWCCR_SIOO() uint32 {
	return (volatile.LoadUint32(&o.WCCR.Reg) & 0x80000000) >> 31
}

// OctoSPI.WTCR: write timing configuration register
func (o *OctoSPI_Type) SetWTCR_DCYC(value uint32) {
	volatile.StoreUint32(&o.WTCR.Reg, volatile.LoadUint32(&o.WTCR.Reg)&^(0x1f)|value)
}
func (o *OctoSPI_Type) GetWTCR_DCYC() uint32 {
	return volatile.LoadUint32(&o.WTCR.Reg) & 0x1f
}

// OctoSPI.WIR: write instruction register
func (o *OctoSPI_Type) SetWIR(value uint32) {
	volatile.StoreUint32(&o.WIR.Reg, value)
}
func (o *OctoSPI_Type) GetWIR() uint32 {
	return volatile.LoadUint32(&o.WIR.Reg)
}

// OctoSPI.WABR: write alternate bytes register
func (o *OctoSPI_Type) SetWABR(value uint32) {
	volatile.StoreUint32(&o.WABR.Reg, value)
}
func (o *OctoSPI_Type) GetWABR() uint32 {
	return volatile.LoadUint32(&o.WABR.Reg)
}

// OctoSPI.HLCR: HyperBusTM latency configuration register
func (o *OctoSPI_Type) SetHLCR_LM(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0x1)|value)
}
func (o *OctoSPI_Type) GetHLCR_LM() uint32 {
	return volatile.LoadUint32(&o.HLCR.Reg) & 0x1
}
func (o *OctoSPI_Type) SetHLCR_WZL(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0x2)|value<<1)
}
func (o *OctoSPI_Type) GetHLCR_WZL() uint32 {
	return (volatile.LoadUint32(&o.HLCR.Reg) & 0x2) >> 1
}
func (o *OctoSPI_Type) SetHLCR_TACC(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0xff00)|value<<8)
}
func (o *OctoSPI_Type) GetHLCR_TACC() uint32 {
	return (volatile.LoadUint32(&o.HLCR.Reg) & 0xff00) >> 8
}
func (o *OctoSPI_Type) SetHLCR_TRWR(value uint32) {
	volatile.StoreUint32(&o.HLCR.Reg, volatile.LoadUint32(&o.HLCR.Reg)&^(0xff0000)|value<<16)
}
func (o *OctoSPI_Type) GetHLCR_TRWR() uint32 {
	return (volatile.LoadUint32(&o.HLCR.Reg) & 0xff0000) >> 16
}

// OctoSPI.HWCFGR: HW configuration register
func (o *OctoSPI_Type) SetHWCFGR_AXI(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf)|value)
}
func (o *OctoSPI_Type) GetHWCFGR_AXI() uint32 {
	return volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf
}
func (o *OctoSPI_Type) SetHWCFGR_FIFO(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xff0)|value<<4)
}
func (o *OctoSPI_Type) GetHWCFGR_FIFO() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xff0) >> 4
}
func (o *OctoSPI_Type) SetHWCFGR_PRES(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xff000)|value<<12)
}
func (o *OctoSPI_Type) GetHWCFGR_PRES() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xff000) >> 12
}
func (o *OctoSPI_Type) SetHWCFGR_IDL(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf00000)|value<<20)
}
func (o *OctoSPI_Type) GetHWCFGR_IDL() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf00000) >> 20
}
func (o *OctoSPI_Type) SetHWCFGR_MMW(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf000000)|value<<24)
}
func (o *OctoSPI_Type) GetHWCFGR_MMW() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf000000) >> 24
}
func (o *OctoSPI_Type) SetHWCFGR_MST(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf0000000)|value<<28)
}
func (o *OctoSPI_Type) GetHWCFGR_MST() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf0000000) >> 28
}

// OctoSPI.VER: version register
func (o *OctoSPI_Type) SetVER(value uint32) {
	volatile.StoreUint32(&o.VER.Reg, volatile.LoadUint32(&o.VER.Reg)&^(0xff)|value)
}
func (o *OctoSPI_Type) GetVER() uint32 {
	return volatile.LoadUint32(&o.VER.Reg) & 0xff
}

// OctoSPI.ID: identification
func (o *OctoSPI_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, value)
}
func (o *OctoSPI_Type) GetID() uint32 {
	return volatile.LoadUint32(&o.ID.Reg)
}

// OctoSPI.MID: magic ID
func (o *OctoSPI_Type) SetMID(value uint32) {
	volatile.StoreUint32(&o.MID.Reg, value)
}
func (o *OctoSPI_Type) GetMID() uint32 {
	return volatile.LoadUint32(&o.MID.Reg)
}

// Reset and clock control
type RCC_Type struct {
	CR          volatile.Register32 // 0x0
	ICSCR       volatile.Register32 // 0x4
	CFGR        volatile.Register32 // 0x8
	PLLCFGR     volatile.Register32 // 0xC
	PLLSAI1CFGR volatile.Register32 // 0x10
	PLLSAI2CFGR volatile.Register32 // 0x14
	CIER        volatile.Register32 // 0x18
	CIFR        volatile.Register32 // 0x1C
	CICR        volatile.Register32 // 0x20
	_           [4]byte
	AHB1RSTR    volatile.Register32 // 0x28
	AHB2RSTR    volatile.Register32 // 0x2C
	AHB3RSTR    volatile.Register32 // 0x30
	_           [4]byte
	APB1RSTR1   volatile.Register32 // 0x38
	APB1RSTR2   volatile.Register32 // 0x3C
	APB2RSTR    volatile.Register32 // 0x40
	_           [4]byte
	AHB1ENR     volatile.Register32 // 0x48
	AHB2ENR     volatile.Register32 // 0x4C
	AHB3ENR     volatile.Register32 // 0x50
	_           [4]byte
	APB1ENR1    volatile.Register32 // 0x58
	APB1ENR2    volatile.Register32 // 0x5C
	APB2ENR     volatile.Register32 // 0x60
	_           [4]byte
	AHB1SMENR   volatile.Register32 // 0x68
	AHB2SMENR   volatile.Register32 // 0x6C
	AHB3SMENR   volatile.Register32 // 0x70
	_           [4]byte
	APB1SMENR1  volatile.Register32 // 0x78
	APB1SMENR2  volatile.Register32 // 0x7C
	APB2SMENR   volatile.Register32 // 0x80
	_           [4]byte
	CCIPR       volatile.Register32 // 0x88
	_           [4]byte
	BDCR        volatile.Register32 // 0x90
	CSR         volatile.Register32 // 0x94
	CRRCR       volatile.Register32 // 0x98
	CCIPR2      volatile.Register32 // 0x9C
}

// RCC.CR: Clock control register
func (o *RCC_Type) SetCR_PLLSAI2RDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCR_PLLSAI2RDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetCR_PLLSAI2ON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCR_PLLSAI2ON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetCR_PLLSAI1RDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCR_PLLSAI1RDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCR_PLLSAI1ON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCR_PLLSAI1ON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCR_PLLRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCR_PLLRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCR_PLLON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCR_PLLON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCR_CSSON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCR_CSSON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCR_HSEBYP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCR_HSEBYP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCR_HSERDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCR_HSERDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCR_HSEON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCR_HSEON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCR_HSIASFS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetCR_HSIASFS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetCR_HSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCR_HSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetCR_HSIKERON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCR_HSIKERON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCR_HSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCR_HSION() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCR_MSIRANGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetCR_MSIRANGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetCR_MSIRGSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCR_MSIRGSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCR_MSIPLLEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCR_MSIPLLEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCR_MSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCR_MSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCR_MSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCR_MSION() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// RCC.ICSCR: Internal clock sources calibration register
func (o *RCC_Type) SetICSCR_HSITRIM(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0x7f000000)|value<<24)
}
func (o *RCC_Type) GetICSCR_HSITRIM() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0x7f000000) >> 24
}
func (o *RCC_Type) SetICSCR_HSICAL(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff0000)|value<<16)
}
func (o *RCC_Type) GetICSCR_HSICAL() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0xff0000) >> 16
}
func (o *RCC_Type) SetICSCR_MSITRIM(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff00)|value<<8)
}
func (o *RCC_Type) GetICSCR_MSITRIM() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0xff00) >> 8
}
func (o *RCC_Type) SetICSCR_MSICAL(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff)|value)
}
func (o *RCC_Type) GetICSCR_MSICAL() uint32 {
	return volatile.LoadUint32(&o.ICSCR.Reg) & 0xff
}

// RCC.CFGR: Clock configuration register
func (o *RCC_Type) SetCFGR_MCOPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetCFGR_MCOPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x70000000) >> 28
}
func (o *RCC_Type) SetCFGR_MCOSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7000000)|value<<24)
}
func (o *RCC_Type) GetCFGR_MCOSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7000000) >> 24
}
func (o *RCC_Type) SetCFGR_STOPWUCK(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetCFGR_STOPWUCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetCFGR_PPRE2(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3800)|value<<11)
}
func (o *RCC_Type) GetCFGR_PPRE2() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x3800) >> 11
}
func (o *RCC_Type) SetCFGR_PPRE1(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x700)|value<<8)
}
func (o *RCC_Type) GetCFGR_PPRE1() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x700) >> 8
}
func (o *RCC_Type) SetCFGR_HPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetCFGR_HPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetCFGR_SWS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCFGR_SWS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetCFGR_SW(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCFGR_SW() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x3
}

// RCC.PLLCFGR: PLL configuration register
func (o *RCC_Type) SetPLLCFGR_PLLPDIV(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xf8000000)|value<<27)
}
func (o *RCC_Type) GetPLLCFGR_PLLPDIV() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xf8000000) >> 27
}
func (o *RCC_Type) SetPLLCFGR_PLLR(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x6000000)|value<<25)
}
func (o *RCC_Type) GetPLLCFGR_PLLR() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x6000000) >> 25
}
func (o *RCC_Type) SetPLLCFGR_PLLREN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetPLLCFGR_PLLREN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetPLLCFGR_PLLQ(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x600000)|value<<21)
}
func (o *RCC_Type) GetPLLCFGR_PLLQ() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x600000) >> 21
}
func (o *RCC_Type) SetPLLCFGR_PLLQEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetPLLCFGR_PLLQEN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetPLLCFGR_PLLP(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetPLLCFGR_PLLP() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetPLLCFGR_PLLPEN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetPLLCFGR_PLLPEN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetPLLCFGR_PLLN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x7f00)|value<<8)
}
func (o *RCC_Type) GetPLLCFGR_PLLN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x7f00) >> 8
}
func (o *RCC_Type) SetPLLCFGR_PLLM(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetPLLCFGR_PLLM() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetPLLCFGR_PLLSRC(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetPLLCFGR_PLLSRC() uint32 {
	return volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x3
}

// RCC.PLLSAI1CFGR: PLLSAI1 configuration register
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1PDIV(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0xf8000000)|value<<27)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1PDIV() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0xf8000000) >> 27
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1R(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x6000000)|value<<25)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1R() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x6000000) >> 25
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1REN(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1REN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1Q(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x600000)|value<<21)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1Q() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x600000) >> 21
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1QEN(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1QEN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1P(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1P() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1PEN(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1PEN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1N(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0x7f00)|value<<8)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1N() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0x7f00) >> 8
}
func (o *RCC_Type) SetPLLSAI1CFGR_PLLSAI1M(value uint32) {
	volatile.StoreUint32(&o.PLLSAI1CFGR.Reg, volatile.LoadUint32(&o.PLLSAI1CFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetPLLSAI1CFGR_PLLSAI1M() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI1CFGR.Reg) & 0xf0) >> 4
}

// RCC.PLLSAI2CFGR: PLLSAI2 configuration register
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2PDIV(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0xf8000000)|value<<27)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2PDIV() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0xf8000000) >> 27
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2R(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x6000000)|value<<25)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2R() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x6000000) >> 25
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2REN(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2REN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2Q(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x600000)|value<<21)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2Q() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x600000) >> 21
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2QEN(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2QEN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2P(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2P() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2PEN(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2PEN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2N(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0x7f00)|value<<8)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2N() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0x7f00) >> 8
}
func (o *RCC_Type) SetPLLSAI2CFGR_PLLSAI2M(value uint32) {
	volatile.StoreUint32(&o.PLLSAI2CFGR.Reg, volatile.LoadUint32(&o.PLLSAI2CFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetPLLSAI2CFGR_PLLSAI2M() uint32 {
	return (volatile.LoadUint32(&o.PLLSAI2CFGR.Reg) & 0xf0) >> 4
}

// RCC.CIER: Clock interrupt enable register
func (o *RCC_Type) SetCIER_LSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIER_LSIRDYIE() uint32 {
	return volatile.LoadUint32(&o.CIER.Reg) & 0x1
}
func (o *RCC_Type) SetCIER_LSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIER_LSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIER_MSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIER_MSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIER_HSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIER_HSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIER_HSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIER_HSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIER_PLLRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIER_PLLRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIER_PLLSAI1RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCIER_PLLSAI1RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCIER_PLLSAI2RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCIER_PLLSAI2RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCIER_LSECSSIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIER_LSECSSIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCIER_HSI48RDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCIER_HSI48RDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x400) >> 10
}

// RCC.CIFR: Clock interrupt flag register
func (o *RCC_Type) SetCIFR_LSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIFR_LSIRDYF() uint32 {
	return volatile.LoadUint32(&o.CIFR.Reg) & 0x1
}
func (o *RCC_Type) SetCIFR_LSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIFR_LSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIFR_MSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIFR_MSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIFR_HSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIFR_HSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIFR_HSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIFR_HSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIFR_PLLRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIFR_PLLRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIFR_PLLSAI1RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCIFR_PLLSAI1RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCIFR_PLLSAI2RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCIFR_PLLSAI2RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCIFR_CSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCIFR_CSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCIFR_LSECSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIFR_LSECSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCIFR_HSI48RDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCIFR_HSI48RDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x400) >> 10
}

// RCC.CICR: Clock interrupt clear register
func (o *RCC_Type) SetCICR_LSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCICR_LSIRDYC() uint32 {
	return volatile.LoadUint32(&o.CICR.Reg) & 0x1
}
func (o *RCC_Type) SetCICR_LSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCICR_LSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCICR_MSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCICR_MSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCICR_HSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCICR_HSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCICR_HSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCICR_HSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCICR_PLLRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCICR_PLLRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCICR_PLLSAI1RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCICR_PLLSAI1RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCICR_PLLSAI2RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCICR_PLLSAI2RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCICR_CSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCICR_CSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCICR_LSECSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCICR_LSECSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCICR_HSI48RDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCICR_HSI48RDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x400) >> 10
}

// RCC.AHB1RSTR: AHB1 peripheral reset register
func (o *RCC_Type) SetAHB1RSTR_DMA1RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1RSTR_DMA1RST() uint32 {
	return volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1RSTR_DMA2RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1RSTR_DMA2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1RSTR_DMAMUX1RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1RSTR_DMAMUX1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1RSTR_FLASHRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB1RSTR_FLASHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB1RSTR_CRCRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1RSTR_CRCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1RSTR_TSCRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB1RSTR_TSCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB1RSTR_DMA2DRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB1RSTR_DMA2DRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB1RSTR_GFXMMURST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB1RSTR_GFXMMURST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x40000) >> 18
}

// RCC.AHB2RSTR: AHB2 peripheral reset register
func (o *RCC_Type) SetAHB2RSTR_GPIOARST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOARST() uint32 {
	return volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2RSTR_GPIOBRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOBRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB2RSTR_GPIOCRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB2RSTR_GPIODRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB2RSTR_GPIODRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB2RSTR_GPIOERST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOERST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2RSTR_GPIOFRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOFRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2RSTR_GPIOGRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2RSTR_GPIOHRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2RSTR_GPIOIRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB2RSTR_GPIOIRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB2RSTR_OTGFSRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB2RSTR_OTGFSRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB2RSTR_ADCRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAHB2RSTR_ADCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAHB2RSTR_DCMIRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAHB2RSTR_DCMIRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAHB2RSTR_AESRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB2RSTR_AESRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB2RSTR_HASHRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB2RSTR_HASHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB2RSTR_RNGRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB2RSTR_RNGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB2RSTR_OSPIMRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAHB2RSTR_OSPIMRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAHB2RSTR_SDMMC1RST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB2RSTR_SDMMC1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x400000) >> 22
}

// RCC.AHB3RSTR: AHB3 peripheral reset register
func (o *RCC_Type) SetAHB3RSTR_FMCRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3RSTR_FMCRST() uint32 {
	return volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3RSTR_OSPI2RST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB3RSTR_OSPI2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x200) >> 9
}

// RCC.APB1RSTR1: APB1 peripheral reset register 1
func (o *RCC_Type) SetAPB1RSTR1_LPTIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1RSTR1_LPTIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1RSTR1_OPAMPRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1RSTR1_OPAMPRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1RSTR1_DAC1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1RSTR1_DAC1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1RSTR1_PWRRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1RSTR1_PWRRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPB1RSTR1_CAN1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1RSTR1_CAN1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPB1RSTR1_CRSRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1RSTR1_CRSRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1RSTR1_I2C3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1RSTR1_I2C3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1RSTR1_I2C2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1RSTR1_I2C2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1RSTR1_I2C1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1RSTR1_I2C1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1RSTR1_UART5RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1RSTR1_UART5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1RSTR1_UART4RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1RSTR1_UART4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1RSTR1_USART3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1RSTR1_USART3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1RSTR1_USART2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1RSTR1_USART2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1RSTR1_SPI3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1RSTR1_SPI3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1RSTR1_SPI2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1RSTR1_SPI2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1RSTR1_TIM7RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM7RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1RSTR1_TIM6RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM6RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1RSTR1_TIM5RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1RSTR1_TIM4RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1RSTR1_TIM3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1RSTR1_TIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR1.Reg, volatile.LoadUint32(&o.APB1RSTR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1RSTR1_TIM2RST() uint32 {
	return volatile.LoadUint32(&o.APB1RSTR1.Reg) & 0x1
}

// RCC.APB1RSTR2: APB1 peripheral reset register 2
func (o *RCC_Type) SetAPB1RSTR2_LPUART1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR2.Reg, volatile.LoadUint32(&o.APB1RSTR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1RSTR2_LPUART1RST() uint32 {
	return volatile.LoadUint32(&o.APB1RSTR2.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1RSTR2_I2C4RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR2.Reg, volatile.LoadUint32(&o.APB1RSTR2.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1RSTR2_I2C4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR2.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1RSTR2_LPTIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR2.Reg, volatile.LoadUint32(&o.APB1RSTR2.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1RSTR2_LPTIM2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR2.Reg) & 0x20) >> 5
}

// RCC.APB2RSTR: APB2 peripheral reset register
func (o *RCC_Type) SetAPB2RSTR_SYSCFGRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2RSTR_SYSCFGRST() uint32 {
	return volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2RSTR_TIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2RSTR_TIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2RSTR_SPI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2RSTR_SPI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2RSTR_TIM8RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2RSTR_TIM8RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2RSTR_USART1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2RSTR_USART1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2RSTR_TIM15RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2RSTR_TIM15RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2RSTR_TIM16RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2RSTR_TIM16RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2RSTR_TIM17RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2RSTR_TIM17RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2RSTR_SAI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB2RSTR_SAI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB2RSTR_SAI2RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2RSTR_SAI2RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2RSTR_DFSDM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB2RSTR_DFSDM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB2RSTR_LTDCRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB2RSTR_LTDCRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB2RSTR_DSIRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB2RSTR_DSIRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x8000000) >> 27
}

// RCC.AHB1ENR: AHB1 peripheral clock enable register
func (o *RCC_Type) SetAHB1ENR_DMA1EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1ENR_DMA1EN() uint32 {
	return volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1ENR_DMA2EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1ENR_DMA2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1ENR_DMAMUX1EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1ENR_DMAMUX1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1ENR_FLASHEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB1ENR_FLASHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB1ENR_CRCEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1ENR_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1ENR_TSCEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB1ENR_TSCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB1ENR_DMA2DEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB1ENR_DMA2DEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB1ENR_GFXMMUEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB1ENR_GFXMMUEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x40000) >> 18
}

// RCC.AHB2ENR: AHB2 peripheral clock enable register
func (o *RCC_Type) SetAHB2ENR_GPIOAEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2ENR_GPIOAEN() uint32 {
	return volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2ENR_GPIOBEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2ENR_GPIOBEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB2ENR_GPIOCEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB2ENR_GPIOCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB2ENR_GPIODEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB2ENR_GPIODEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB2ENR_GPIOEEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2ENR_GPIOEEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2ENR_GPIOFEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2ENR_GPIOFEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2ENR_GPIOGEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2ENR_GPIOGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2ENR_GPIOHEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2ENR_GPIOHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2ENR_GPIOIEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB2ENR_GPIOIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB2ENR_OTGFSEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB2ENR_OTGFSEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB2ENR_ADCEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAHB2ENR_ADCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAHB2ENR_DCMIEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAHB2ENR_DCMIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAHB2ENR_AESEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB2ENR_AESEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB2ENR_HASHEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB2ENR_HASHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB2ENR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB2ENR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB2ENR_OSPIMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAHB2ENR_OSPIMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAHB2ENR_SDMMC1EN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB2ENR_SDMMC1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x400000) >> 22
}

// RCC.AHB3ENR: AHB3 peripheral clock enable register
func (o *RCC_Type) SetAHB3ENR_FMCEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3ENR_FMCEN() uint32 {
	return volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3ENR_OSPI2EN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB3ENR_OSPI2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x200) >> 9
}

// RCC.APB1ENR1: APB1ENR1
func (o *RCC_Type) SetAPB1ENR1_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1ENR1_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1ENR1_TIM3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1ENR1_TIM3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1ENR1_TIM4EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1ENR1_TIM4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1ENR1_TIM5EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1ENR1_TIM5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1ENR1_TIM6EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1ENR1_TIM6EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1ENR1_TIM7EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1ENR1_TIM7EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1ENR1_RTCAPBEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB1ENR1_RTCAPBEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB1ENR1_WWDGEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1ENR1_WWDGEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1ENR1_SPI2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1ENR1_SPI2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1ENR1_SPI3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1ENR1_SPI3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1ENR1_USART2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1ENR1_USART2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1ENR1_USART3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1ENR1_USART3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1ENR1_UART4EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1ENR1_UART4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1ENR1_UART5EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1ENR1_UART5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1ENR1_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1ENR1_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1ENR1_I2C2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1ENR1_I2C2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1ENR1_I2C3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1ENR1_I2C3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1ENR1_CRSEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1ENR1_CRSEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1ENR1_CAN1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1ENR1_CAN1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPB1ENR1_PWREN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1ENR1_PWREN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPB1ENR1_DAC1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1ENR1_DAC1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1ENR1_OPAMPEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1ENR1_OPAMPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1ENR1_LPTIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR1.Reg, volatile.LoadUint32(&o.APB1ENR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1ENR1_LPTIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR1.Reg) & 0x80000000) >> 31
}

// RCC.APB1ENR2: APB1 peripheral clock enable register 2
func (o *RCC_Type) SetAPB1ENR2_LPUART1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR2.Reg, volatile.LoadUint32(&o.APB1ENR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1ENR2_LPUART1EN() uint32 {
	return volatile.LoadUint32(&o.APB1ENR2.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1ENR2_I2C4EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR2.Reg, volatile.LoadUint32(&o.APB1ENR2.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1ENR2_I2C4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR2.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1ENR2_LPTIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR2.Reg, volatile.LoadUint32(&o.APB1ENR2.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1ENR2_LPTIM2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR2.Reg) & 0x20) >> 5
}

// RCC.APB2ENR: APB2ENR
func (o *RCC_Type) SetAPB2ENR_SYSCFGEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2ENR_SYSCFGEN() uint32 {
	return volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2ENR_FWEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB2ENR_FWEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB2ENR_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2ENR_TIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2ENR_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2ENR_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2ENR_TIM8EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2ENR_TIM8EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2ENR_USART1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2ENR_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2ENR_TIM15EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2ENR_TIM15EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2ENR_TIM16EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2ENR_TIM16EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2ENR_TIM17EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2ENR_TIM17EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2ENR_SAI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB2ENR_SAI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB2ENR_SAI2EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2ENR_SAI2EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2ENR_DFSDM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB2ENR_DFSDM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB2ENR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB2ENR_LTDCEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB2ENR_DSIEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB2ENR_DSIEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x8000000) >> 27
}

// RCC.AHB1SMENR: AHB1 peripheral clocks enable in Sleep and Stop modes register
func (o *RCC_Type) SetAHB1SMENR_DMA1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1SMENR_DMA1SMEN() uint32 {
	return volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1SMENR_DMA2SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1SMENR_DMA2SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1SMENR_DMAMUX1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1SMENR_DMAMUX1SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1SMENR_FLASHSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB1SMENR_FLASHSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB1SMENR_SRAM1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB1SMENR_SRAM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB1SMENR_CRCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1SMENR_CRCSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1SMENR_TSCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB1SMENR_TSCSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB1SMENR_DMA2DSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB1SMENR_DMA2DSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB1SMENR_GFXMMUSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1SMENR.Reg, volatile.LoadUint32(&o.AHB1SMENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB1SMENR_GFXMMUSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1SMENR.Reg) & 0x40000) >> 18
}

// RCC.AHB2SMENR: AHB2 peripheral clocks enable in Sleep and Stop modes register
func (o *RCC_Type) SetAHB2SMENR_GPIOASMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOASMEN() uint32 {
	return volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2SMENR_GPIOBSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOBSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB2SMENR_GPIOCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOCSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB2SMENR_GPIODSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB2SMENR_GPIODSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB2SMENR_GPIOESMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOESMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2SMENR_GPIOFSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOFSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2SMENR_GPIOGSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOGSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2SMENR_GPIOHSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOHSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2SMENR_GPIOISMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB2SMENR_GPIOISMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB2SMENR_SRAM2SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB2SMENR_SRAM2SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB2SMENR_SRAM3SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB2SMENR_SRAM3SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB2SMENR_OTGFSSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB2SMENR_OTGFSSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB2SMENR_ADCFSSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAHB2SMENR_ADCFSSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAHB2SMENR_DCMISMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAHB2SMENR_DCMISMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAHB2SMENR_AESSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB2SMENR_AESSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB2SMENR_HASHSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB2SMENR_HASHSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB2SMENR_RNGSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB2SMENR_RNGSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB2SMENR_OSPIMSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAHB2SMENR_OSPIMSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAHB2SMENR_SDMMC1SMEN(value uint32) {
	volatile.StoreUint32(&o.AHB2SMENR.Reg, volatile.LoadUint32(&o.AHB2SMENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB2SMENR_SDMMC1SMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2SMENR.Reg) & 0x400000) >> 22
}

// RCC.AHB3SMENR: AHB3 peripheral clocks enable in Sleep and Stop modes register
func (o *RCC_Type) SetAHB3SMENR_FMCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3SMENR_FMCSMEN() uint32 {
	return volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3SMENR_OCTOSPI2(value uint32) {
	volatile.StoreUint32(&o.AHB3SMENR.Reg, volatile.LoadUint32(&o.AHB3SMENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB3SMENR_OCTOSPI2() uint32 {
	return (volatile.LoadUint32(&o.AHB3SMENR.Reg) & 0x200) >> 9
}

// RCC.APB1SMENR1: APB1SMENR1
func (o *RCC_Type) SetAPB1SMENR1_TIM2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM2SMEN() uint32 {
	return volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1SMENR1_TIM3SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1SMENR1_TIM4SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM4SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1SMENR1_TIM5SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM5SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1SMENR1_TIM6SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM6SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1SMENR1_TIM7SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1SMENR1_TIM7SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1SMENR1_RTCAPBSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB1SMENR1_RTCAPBSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB1SMENR1_WWDGSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1SMENR1_WWDGSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1SMENR1_SPI2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1SMENR1_SPI2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1SMENR1_SP3SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1SMENR1_SP3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1SMENR1_USART2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1SMENR1_USART2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1SMENR1_USART3SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1SMENR1_USART3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1SMENR1_UART4SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1SMENR1_UART4SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1SMENR1_UART5SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1SMENR1_UART5SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1SMENR1_I2C1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1SMENR1_I2C1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1SMENR1_I2C2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1SMENR1_I2C2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1SMENR1_I2C3SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1SMENR1_I2C3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1SMENR1_CRSSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1SMENR1_CRSSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1SMENR1_CAN1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1SMENR1_CAN1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPB1SMENR1_PWRSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1SMENR1_PWRSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPB1SMENR1_DAC1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1SMENR1_DAC1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1SMENR1_OPAMPSMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1SMENR1_OPAMPSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1SMENR1_LPTIM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR1.Reg, volatile.LoadUint32(&o.APB1SMENR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1SMENR1_LPTIM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR1.Reg) & 0x80000000) >> 31
}

// RCC.APB1SMENR2: APB1 peripheral clocks enable in Sleep and Stop modes register 2
func (o *RCC_Type) SetAPB1SMENR2_LPUART1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR2.Reg, volatile.LoadUint32(&o.APB1SMENR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1SMENR2_LPUART1SMEN() uint32 {
	return volatile.LoadUint32(&o.APB1SMENR2.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1SMENR2_I2C4SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR2.Reg, volatile.LoadUint32(&o.APB1SMENR2.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1SMENR2_I2C4SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR2.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1SMENR2_LPTIM2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB1SMENR2.Reg, volatile.LoadUint32(&o.APB1SMENR2.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1SMENR2_LPTIM2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB1SMENR2.Reg) & 0x20) >> 5
}

// RCC.APB2SMENR: APB2SMENR
func (o *RCC_Type) SetAPB2SMENR_SYSCFGSMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2SMENR_SYSCFGSMEN() uint32 {
	return volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2SMENR_TIM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2SMENR_TIM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2SMENR_SPI1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2SMENR_SPI1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2SMENR_TIM8SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2SMENR_TIM8SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2SMENR_USART1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2SMENR_USART1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2SMENR_TIM15SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2SMENR_TIM15SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2SMENR_TIM16SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2SMENR_TIM16SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2SMENR_TIM17SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2SMENR_TIM17SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2SMENR_SAI1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB2SMENR_SAI1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB2SMENR_SAI2SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2SMENR_SAI2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2SMENR_DFSDM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB2SMENR_DFSDM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB2SMENR_LTDCSMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB2SMENR_LTDCSMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB2SMENR_DSISMEN(value uint32) {
	volatile.StoreUint32(&o.APB2SMENR.Reg, volatile.LoadUint32(&o.APB2SMENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB2SMENR_DSISMEN() uint32 {
	return (volatile.LoadUint32(&o.APB2SMENR.Reg) & 0x8000000) >> 27
}

// RCC.CCIPR: CCIPR
func (o *RCC_Type) SetCCIPR_ADCSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x30000000)|value<<28)
}
func (o *RCC_Type) GetCCIPR_ADCSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x30000000) >> 28
}
func (o *RCC_Type) SetCCIPR_CLK48SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc000000)|value<<26)
}
func (o *RCC_Type) GetCCIPR_CLK48SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc000000) >> 26
}
func (o *RCC_Type) SetCCIPR_SAI2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3000000)|value<<24)
}
func (o *RCC_Type) GetCCIPR_SAI2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x3000000) >> 24
}
func (o *RCC_Type) SetCCIPR_SAI1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc00000)|value<<22)
}
func (o *RCC_Type) GetCCIPR_SAI1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc00000) >> 22
}
func (o *RCC_Type) SetCCIPR_LPTIM2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetCCIPR_LPTIM2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetCCIPR_LPTIM1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc0000)|value<<18)
}
func (o *RCC_Type) GetCCIPR_LPTIM1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc0000) >> 18
}
func (o *RCC_Type) SetCCIPR_I2C3SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetCCIPR_I2C3SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetCCIPR_I2C2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc000)|value<<14)
}
func (o *RCC_Type) GetCCIPR_I2C2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc000) >> 14
}
func (o *RCC_Type) SetCCIPR_I2C1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3000)|value<<12)
}
func (o *RCC_Type) GetCCIPR_I2C1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x3000) >> 12
}
func (o *RCC_Type) SetCCIPR_LPUART1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc00)|value<<10)
}
func (o *RCC_Type) GetCCIPR_LPUART1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc00) >> 10
}
func (o *RCC_Type) SetCCIPR_UART5SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetCCIPR_UART5SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetCCIPR_UART4SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc0)|value<<6)
}
func (o *RCC_Type) GetCCIPR_UART4SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc0) >> 6
}
func (o *RCC_Type) SetCCIPR_USART3SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x30)|value<<4)
}
func (o *RCC_Type) GetCCIPR_USART3SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x30) >> 4
}
func (o *RCC_Type) SetCCIPR_USART2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCCIPR_USART2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetCCIPR_USART1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCCIPR_USART1SEL() uint32 {
	return volatile.LoadUint32(&o.CCIPR.Reg) & 0x3
}

// RCC.BDCR: BDCR
func (o *RCC_Type) SetBDCR_LSCOSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetBDCR_LSCOSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetBDCR_LSCOEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetBDCR_LSCOEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetBDCR_BDRST(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetBDCR_BDRST() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetBDCR_RTCEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetBDCR_RTCEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetBDCR_RTCSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetBDCR_RTCSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetBDCR_LSECSSD(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetBDCR_LSECSSD() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetBDCR_LSECSSON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetBDCR_LSECSSON() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetBDCR_LSEDRV(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetBDCR_LSEDRV() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetBDCR_LSEBYP(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetBDCR_LSEBYP() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetBDCR_LSERDY(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetBDCR_LSERDY() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetBDCR_LSEON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetBDCR_LSEON() uint32 {
	return volatile.LoadUint32(&o.BDCR.Reg) & 0x1
}

// RCC.CSR: CSR
func (o *RCC_Type) SetCSR_LPWRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetCSR_LPWRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetCSR_WWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetCSR_WWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetCSR_IWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCSR_IWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetCSR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCSR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetCSR_BORRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCSR_BORRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCSR_PINRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCSR_PINRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCSR_OBLRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCSR_OBLRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCSR_FWRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCSR_FWRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCSR_RMVF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetCSR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetCSR_MSISRANGE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0xf00)|value<<8)
}
func (o *RCC_Type) GetCSR_MSISRANGE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0xf00) >> 8
}
func (o *RCC_Type) SetCSR_LSIRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCSR_LSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCSR_LSION(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCSR_LSION() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}

// RCC.CRRCR: Clock recovery RC register
func (o *RCC_Type) SetCRRCR_HSI48ON(value uint32) {
	volatile.StoreUint32(&o.CRRCR.Reg, volatile.LoadUint32(&o.CRRCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCRRCR_HSI48ON() uint32 {
	return volatile.LoadUint32(&o.CRRCR.Reg) & 0x1
}
func (o *RCC_Type) SetCRRCR_HSI48RDY(value uint32) {
	volatile.StoreUint32(&o.CRRCR.Reg, volatile.LoadUint32(&o.CRRCR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCRRCR_HSI48RDY() uint32 {
	return (volatile.LoadUint32(&o.CRRCR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCRRCR_HSI48CAL(value uint32) {
	volatile.StoreUint32(&o.CRRCR.Reg, volatile.LoadUint32(&o.CRRCR.Reg)&^(0xff80)|value<<7)
}
func (o *RCC_Type) GetCRRCR_HSI48CAL() uint32 {
	return (volatile.LoadUint32(&o.CRRCR.Reg) & 0xff80) >> 7
}

// RCC.CCIPR2: Peripherals independent clock configuration register
func (o *RCC_Type) SetCCIPR2_I2C4SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCCIPR2_I2C4SEL() uint32 {
	return volatile.LoadUint32(&o.CCIPR2.Reg) & 0x3
}
func (o *RCC_Type) SetCCIPR2_DFSDMSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCCIPR2_DFSDMSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCCIPR2_ADFSDMSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetCCIPR2_ADFSDMSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetCCIPR2_SAI1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0xe0)|value<<5)
}
func (o *RCC_Type) GetCCIPR2_SAI1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0xe0) >> 5
}
func (o *RCC_Type) SetCCIPR2_SAI2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x700)|value<<8)
}
func (o *RCC_Type) GetCCIPR2_SAI2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x700) >> 8
}
func (o *RCC_Type) SetCCIPR2_DSISEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetCCIPR2_DSISEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetCCIPR2_SDMMCSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetCCIPR2_SDMMCSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetCCIPR2_PLLSAI2DIVR(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetCCIPR2_PLLSAI2DIVR() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetCCIPR2_OSPISEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR2.Reg, volatile.LoadUint32(&o.CCIPR2.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetCCIPR2_OSPISEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR2.Reg) & 0x300000) >> 20
}

// Power control
type PWR_Type struct {
	CR1   volatile.Register32 // 0x0
	CR2   volatile.Register32 // 0x4
	CR3   volatile.Register32 // 0x8
	CR4   volatile.Register32 // 0xC
	SR1   volatile.Register32 // 0x10
	SR2   volatile.Register32 // 0x14
	SCR   volatile.Register32 // 0x18
	_     [4]byte
	PUCRA volatile.Register32 // 0x20
	PDCRA volatile.Register32 // 0x24
	PUCRB volatile.Register32 // 0x28
	PDCRB volatile.Register32 // 0x2C
	PUCRC volatile.Register32 // 0x30
	PDCRC volatile.Register32 // 0x34
	PUCRD volatile.Register32 // 0x38
	PDCRD volatile.Register32 // 0x3C
	PUCRE volatile.Register32 // 0x40
	PDCRE volatile.Register32 // 0x44
	PUCRF volatile.Register32 // 0x48
	PDCRF volatile.Register32 // 0x4C
	PUCRG volatile.Register32 // 0x50
	PDCRG volatile.Register32 // 0x54
	PUCRH volatile.Register32 // 0x58
	PDCRH volatile.Register32 // 0x5C
}

// PWR.CR1: Power control register 1
func (o *PWR_Type) SetCR1_LPR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetCR1_LPR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetCR1_VOS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x600)|value<<9)
}
func (o *PWR_Type) GetCR1_VOS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x600) >> 9
}
func (o *PWR_Type) SetCR1_DBP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR1_DBP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR1_LPMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x7)|value)
}
func (o *PWR_Type) GetCR1_LPMS() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x7
}

// PWR.CR2: Power control register 2
func (o *PWR_Type) SetCR2_USV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCR2_USV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCR2_IOSV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR2_IOSV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR2_PVME4(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetCR2_PVME4() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetCR2_PVME3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetCR2_PVME3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetCR2_PVME2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCR2_PVME2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCR2_PVME1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR2_PVME1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR2_PLS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xe)|value<<1)
}
func (o *PWR_Type) GetCR2_PLS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xe) >> 1
}
func (o *PWR_Type) SetCR2_PVDE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR2_PVDE() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// PWR.CR3: Power control register 3
func (o *PWR_Type) SetCR3_EWF(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetCR3_EWF() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetCR3_APC(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCR3_APC() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCR3_RRS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR3_RRS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR3_EWUP5(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR3_EWUP5() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR3_EWUP4(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR3_EWUP4() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR3_EWUP3(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCR3_EWUP3() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCR3_EWUP2(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR3_EWUP2() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR3_EWUP1(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR3_EWUP1() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// PWR.CR4: Power control register 4
func (o *PWR_Type) SetCR4_VBRS(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR4_VBRS() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR4_VBE(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR4_VBE() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR4_WP5(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR4_WP5() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR4_WP4(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR4_WP4() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR4_WP3(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCR4_WP3() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCR4_WP2(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR4_WP2() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR4_WP1(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR4_WP1() uint32 {
	return volatile.LoadUint32(&o.CR4.Reg) & 0x1
}

// PWR.SR1: Power status register 1
func (o *PWR_Type) SetSR1_WUFI(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetSR1_WUFI() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetSR1_CSBF(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSR1_CSBF() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSR1_CWUF5(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetSR1_CWUF5() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetSR1_CWUF4(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetSR1_CWUF4() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetSR1_CWUF3(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetSR1_CWUF3() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetSR1_CWUF2(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSR1_CWUF2() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetSR1_CWUF1(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetSR1_CWUF1() uint32 {
	return volatile.LoadUint32(&o.SR1.Reg) & 0x1
}

// PWR.SR2: Power status register 2
func (o *PWR_Type) SetSR2_PVMO4(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetSR2_PVMO4() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetSR2_PVMO3(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetSR2_PVMO3() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetSR2_PVMO2(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetSR2_PVMO2() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetSR2_PVMO1(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetSR2_PVMO1() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetSR2_PVDO(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetSR2_PVDO() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetSR2_VOSF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetSR2_VOSF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetSR2_REGLPF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetSR2_REGLPF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetSR2_REGLPS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSR2_REGLPS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x100) >> 8
}

// PWR.SCR: Power status clear register
func (o *PWR_Type) SetSCR_SBF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSCR_SBF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSCR_WUF5(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetSCR_WUF5() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetSCR_WUF4(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetSCR_WUF4() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetSCR_WUF3(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetSCR_WUF3() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetSCR_WUF2(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSCR_WUF2() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetSCR_WUF1(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetSCR_WUF1() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}

// PWR.PUCRA: Power Port A pull-up control register
func (o *PWR_Type) SetPUCRA_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRA_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRA_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRA_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRA_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRA_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRA_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRA_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRA_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRA_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRA_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRA_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRA_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRA_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRA_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRA_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRA_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRA_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRA_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRA_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRA_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRA_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRA_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRA_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRA_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRA_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRA_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRA_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRA_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRA_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRA_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRA_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRA.Reg) & 0x1
}

// PWR.PDCRA: Power Port A pull-down control register
func (o *PWR_Type) SetPDCRA_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRA_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRA_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRA_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRA_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRA_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRA_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRA_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRA_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRA_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRA_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRA_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRA_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRA_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRA_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRA_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRA_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRA_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRA_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRA_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRA_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRA_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRA_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRA_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRA_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRA_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRA_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRA_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRA_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRA_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRA_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRA_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRA.Reg) & 0x1
}

// PWR.PUCRB: Power Port B pull-up control register
func (o *PWR_Type) SetPUCRB_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRB_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRB_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRB_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRB_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRB_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRB_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRB_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRB_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRB_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRB_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRB_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRB_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRB_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRB_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRB_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRB_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRB_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRB_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRB_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRB_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRB_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRB_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRB_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRB_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRB_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRB_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRB_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRB_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRB_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRB_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRB_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRB.Reg) & 0x1
}

// PWR.PDCRB: Power Port B pull-down control register
func (o *PWR_Type) SetPDCRB_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRB_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRB_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRB_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRB_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRB_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRB_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRB_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRB_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRB_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRB_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRB_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRB_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRB_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRB_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRB_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRB_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRB_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRB_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRB_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRB_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRB_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRB_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRB_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRB_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRB_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRB_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRB_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRB_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRB_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRB_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRB_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRB.Reg) & 0x1
}

// PWR.PUCRC: Power Port C pull-up control register
func (o *PWR_Type) SetPUCRC_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRC_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRC_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRC_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRC_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRC_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRC_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRC_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRC_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRC_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRC_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRC_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRC_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRC_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRC_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRC_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRC_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRC_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRC_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRC_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRC_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRC_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRC_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRC_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRC_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRC_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRC_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRC_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRC_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRC_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRC_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRC_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRC.Reg) & 0x1
}

// PWR.PDCRC: Power Port C pull-down control register
func (o *PWR_Type) SetPDCRC_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRC_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRC_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRC_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRC_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRC_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRC_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRC_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRC_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRC_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRC_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRC_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRC_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRC_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRC_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRC_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRC_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRC_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRC_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRC_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRC_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRC_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRC_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRC_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRC_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRC_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRC_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRC_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRC_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRC_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRC_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRC_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRC.Reg) & 0x1
}

// PWR.PUCRD: Power Port D pull-up control register
func (o *PWR_Type) SetPUCRD_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRD_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRD_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRD_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRD_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRD_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRD_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRD_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRD_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRD_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRD_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRD_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRD_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRD_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRD_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRD_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRD_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRD_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRD_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRD_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRD_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRD_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRD_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRD_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRD_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRD_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRD_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRD_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRD_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRD_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRD_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRD_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRD.Reg) & 0x1
}

// PWR.PDCRD: Power Port D pull-down control register
func (o *PWR_Type) SetPDCRD_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRD_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRD_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRD_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRD_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRD_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRD_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRD_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRD_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRD_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRD_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRD_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRD_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRD_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRD_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRD_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRD_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRD_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRD_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRD_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRD_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRD_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRD_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRD_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRD_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRD_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRD_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRD_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRD_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRD_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRD_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRD_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRD.Reg) & 0x1
}

// PWR.PUCRE: Power Port E pull-up control register
func (o *PWR_Type) SetPUCRE_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRE_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRE_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRE_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRE_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRE_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRE_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRE_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRE_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRE_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRE_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRE_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRE_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRE_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRE_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRE_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRE_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRE_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRE_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRE_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRE_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRE_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRE_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRE_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRE_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRE_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRE_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRE_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRE_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRE_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRE.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRE_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRE.Reg, volatile.LoadUint32(&o.PUCRE.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRE_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRE.Reg) & 0x1
}

// PWR.PDCRE: Power Port E pull-down control register
func (o *PWR_Type) SetPDCRE_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRE_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRE_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRE_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRE_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRE_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRE_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRE_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRE_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRE_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRE_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRE_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRE_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRE_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRE_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRE_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRE_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRE_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRE_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRE_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRE_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRE_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRE_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRE_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRE_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRE_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRE_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRE_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRE_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRE_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRE.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRE_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRE.Reg, volatile.LoadUint32(&o.PDCRE.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRE_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRE.Reg) & 0x1
}

// PWR.PUCRF: Power Port F pull-up control register
func (o *PWR_Type) SetPUCRF_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRF_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRF_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRF_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRF_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRF_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRF_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRF_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRF_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRF_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRF_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRF_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRF_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRF_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRF_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRF_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRF_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRF_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRF_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRF_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRF_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRF_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRF_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRF_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRF_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRF_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRF_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRF_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRF_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRF_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRF_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRF_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRF.Reg) & 0x1
}

// PWR.PDCRF: Power Port F pull-down control register
func (o *PWR_Type) SetPDCRF_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRF_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRF_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRF_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRF_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRF_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRF_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRF_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRF_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRF_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRF_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRF_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRF_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRF_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRF_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRF_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRF_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRF_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRF_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRF_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRF_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRF_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRF_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRF_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRF_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRF_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRF_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRF_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRF_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRF_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRF_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRF_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRF.Reg) & 0x1
}

// PWR.PUCRG: Power Port G pull-up control register
func (o *PWR_Type) SetPUCRG_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRG_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRG_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRG_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRG_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRG_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRG_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRG_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRG_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRG_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRG_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRG_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRG_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRG_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRG_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRG_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRG_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRG_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRG_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRG_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRG_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRG_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRG_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRG_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRG_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRG_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRG_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRG_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRG_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRG_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRG.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRG_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRG.Reg, volatile.LoadUint32(&o.PUCRG.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRG_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRG.Reg) & 0x1
}

// PWR.PDCRG: Power Port G pull-down control register
func (o *PWR_Type) SetPDCRG_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRG_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRG_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRG_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRG_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRG_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRG_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRG_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRG_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRG_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRG_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRG_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRG_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRG_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRG_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRG_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRG_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRG_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRG_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRG_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRG_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRG_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRG_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRG_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRG_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRG_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRG_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRG_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRG_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRG_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRG.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRG_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRG.Reg, volatile.LoadUint32(&o.PDCRG.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRG_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRG.Reg) & 0x1
}

// PWR.PUCRH: Power Port H pull-up control register
func (o *PWR_Type) SetPUCRH_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRH.Reg, volatile.LoadUint32(&o.PUCRH.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRH_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRH.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRH_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRH.Reg, volatile.LoadUint32(&o.PUCRH.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRH_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRH.Reg) & 0x1
}

// PWR.PDCRH: Power Port H pull-down control register
func (o *PWR_Type) SetPDCRH_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRH.Reg, volatile.LoadUint32(&o.PDCRH.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRH_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRH.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRH_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRH.Reg, volatile.LoadUint32(&o.PDCRH.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRH_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRH.Reg) & 0x1
}

// System configuration controller
type SYSCFG_Type struct {
	MEMRMP  volatile.Register32 // 0x0
	CFGR1   volatile.Register32 // 0x4
	EXTICR1 volatile.Register32 // 0x8
	EXTICR2 volatile.Register32 // 0xC
	EXTICR3 volatile.Register32 // 0x10
	EXTICR4 volatile.Register32 // 0x14
	SCSR    volatile.Register32 // 0x18
	CFGR2   volatile.Register32 // 0x1C
	SWPR    volatile.Register32 // 0x20
	SKR     volatile.Register32 // 0x24
}

// SYSCFG.MEMRMP: memory remap register
func (o *SYSCFG_Type) SetMEMRMP_FB_MODE(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetMEMRMP_FB_MODE() uint32 {
	return (volatile.LoadUint32(&o.MEMRMP.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetMEMRMP_QFS(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetMEMRMP_QFS() uint32 {
	return (volatile.LoadUint32(&o.MEMRMP.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetMEMRMP_MEM_MODE(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetMEMRMP_MEM_MODE() uint32 {
	return volatile.LoadUint32(&o.MEMRMP.Reg) & 0x7
}

// SYSCFG.CFGR1: configuration register 1
func (o *SYSCFG_Type) SetCFGR1_FPU_IE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xfc000000)|value<<26)
}
func (o *SYSCFG_Type) GetCFGR1_FPU_IE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xfc000000) >> 26
}
func (o *SYSCFG_Type) SetCFGR1_I2C3_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCFG_Type) GetCFGR1_I2C3_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x400000) >> 22
}
func (o *SYSCFG_Type) SetCFGR1_I2C2_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCFG_Type) GetCFGR1_I2C2_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x200000) >> 21
}
func (o *SYSCFG_Type) SetCFGR1_I2C1_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCFG_Type) GetCFGR1_I2C1_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100000) >> 20
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB9_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB9_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x80000) >> 19
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB8_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB8_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x40000) >> 18
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB7_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB7_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20000) >> 17
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PB6_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PB6_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10000) >> 16
}
func (o *SYSCFG_Type) SetCFGR1_BOOSTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCFGR1_BOOSTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetCFGR1_FWDIS(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetCFGR1_FWDIS() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}

// SYSCFG.EXTICR1: external interrupt configuration register 1
func (o *SYSCFG_Type) SetEXTICR1_EXTI3(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI3() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI2(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI2() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI1(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI1() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI0(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI0() uint32 {
	return volatile.LoadUint32(&o.EXTICR1.Reg) & 0x7
}

// SYSCFG.EXTICR2: external interrupt configuration register 2
func (o *SYSCFG_Type) SetEXTICR2_EXTI7(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI7() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI6(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI6() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI5(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI5() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI4(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI4() uint32 {
	return volatile.LoadUint32(&o.EXTICR2.Reg) & 0x7
}

// SYSCFG.EXTICR3: external interrupt configuration register 3
func (o *SYSCFG_Type) SetEXTICR3_EXTI11(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI11() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI10(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI10() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI9(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI9() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI8(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI8() uint32 {
	return volatile.LoadUint32(&o.EXTICR3.Reg) & 0x7
}

// SYSCFG.EXTICR4: external interrupt configuration register 4
func (o *SYSCFG_Type) SetEXTICR4_EXTI15(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x7000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0x7000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI14(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x700)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI14() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0x700) >> 8
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI13(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI13() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0x70) >> 4
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI12(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0x7)|value)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI12() uint32 {
	return volatile.LoadUint32(&o.EXTICR4.Reg) & 0x7
}

// SYSCFG.SCSR: SCSR
func (o *SYSCFG_Type) SetSCSR_SRAM2BSY(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetSCSR_SRAM2BSY() uint32 {
	return (volatile.LoadUint32(&o.SCSR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetSCSR_SRAM2ER(value uint32) {
	volatile.StoreUint32(&o.SCSR.Reg, volatile.LoadUint32(&o.SCSR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetSCSR_SRAM2ER() uint32 {
	return volatile.LoadUint32(&o.SCSR.Reg) & 0x1
}

// SYSCFG.CFGR2: CFGR2
func (o *SYSCFG_Type) SetCFGR2_SPF(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCFGR2_SPF() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetCFGR2_ECCL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetCFGR2_ECCL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetCFGR2_PVDL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetCFGR2_PVDL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetCFGR2_SPL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetCFGR2_SPL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetCFGR2_CLL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetCFGR2_CLL() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}

// SYSCFG.SWPR: SWPR
func (o *SYSCFG_Type) SetSWPR_P31WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCFG_Type) GetSWPR_P31WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x80000000) >> 31
}
func (o *SYSCFG_Type) SetSWPR_P30WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCFG_Type) GetSWPR_P30WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x40000000) >> 30
}
func (o *SYSCFG_Type) SetSWPR_P29WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCFG_Type) GetSWPR_P29WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x20000000) >> 29
}
func (o *SYSCFG_Type) SetSWPR_P28WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCFG_Type) GetSWPR_P28WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x10000000) >> 28
}
func (o *SYSCFG_Type) SetSWPR_P27WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCFG_Type) GetSWPR_P27WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x8000000) >> 27
}
func (o *SYSCFG_Type) SetSWPR_P26WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCFG_Type) GetSWPR_P26WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x4000000) >> 26
}
func (o *SYSCFG_Type) SetSWPR_P25WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCFG_Type) GetSWPR_P25WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x2000000) >> 25
}
func (o *SYSCFG_Type) SetSWPR_P24WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCFG_Type) GetSWPR_P24WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x1000000) >> 24
}
func (o *SYSCFG_Type) SetSWPR_P23WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCFG_Type) GetSWPR_P23WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x800000) >> 23
}
func (o *SYSCFG_Type) SetSWPR_P22WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCFG_Type) GetSWPR_P22WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x400000) >> 22
}
func (o *SYSCFG_Type) SetSWPR_P21WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCFG_Type) GetSWPR_P21WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x200000) >> 21
}
func (o *SYSCFG_Type) SetSWPR_P20WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCFG_Type) GetSWPR_P20WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x100000) >> 20
}
func (o *SYSCFG_Type) SetSWPR_P19WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCFG_Type) GetSWPR_P19WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x80000) >> 19
}
func (o *SYSCFG_Type) SetSWPR_P18WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCFG_Type) GetSWPR_P18WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x40000) >> 18
}
func (o *SYSCFG_Type) SetSWPR_P17WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCFG_Type) GetSWPR_P17WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x20000) >> 17
}
func (o *SYSCFG_Type) SetSWPR_P16WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetSWPR_P16WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x10000) >> 16
}
func (o *SYSCFG_Type) SetSWPR_P15WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCFG_Type) GetSWPR_P15WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x8000) >> 15
}
func (o *SYSCFG_Type) SetSWPR_P14WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCFG_Type) GetSWPR_P14WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x4000) >> 14
}
func (o *SYSCFG_Type) SetSWPR_P13WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCFG_Type) GetSWPR_P13WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x2000) >> 13
}
func (o *SYSCFG_Type) SetSWPR_P12WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCFG_Type) GetSWPR_P12WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x1000) >> 12
}
func (o *SYSCFG_Type) SetSWPR_P11WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x800)|value<<11)
}
func (o *SYSCFG_Type) GetSWPR_P11WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x800) >> 11
}
func (o *SYSCFG_Type) SetSWPR_P10WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x400)|value<<10)
}
func (o *SYSCFG_Type) GetSWPR_P10WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x400) >> 10
}
func (o *SYSCFG_Type) SetSWPR_P9WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x200)|value<<9)
}
func (o *SYSCFG_Type) GetSWPR_P9WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x200) >> 9
}
func (o *SYSCFG_Type) SetSWPR_P8WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetSWPR_P8WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetSWPR_P7WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetSWPR_P7WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetSWPR_P6WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetSWPR_P6WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetSWPR_P5WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetSWPR_P5WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetSWPR_P4WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetSWPR_P4WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetSWPR_P3WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetSWPR_P3WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetSWPR_P2WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetSWPR_P2WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetSWPR_P1WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetSWPR_P1WP() uint32 {
	return (volatile.LoadUint32(&o.SWPR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetSWPR_P0WP(value uint32) {
	volatile.StoreUint32(&o.SWPR.Reg, volatile.LoadUint32(&o.SWPR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetSWPR_P0WP() uint32 {
	return volatile.LoadUint32(&o.SWPR.Reg) & 0x1
}

// SYSCFG.SKR: SKR
func (o *SYSCFG_Type) SetSKR_KEY(value uint32) {
	volatile.StoreUint32(&o.SKR.Reg, volatile.LoadUint32(&o.SKR.Reg)&^(0xff)|value)
}
func (o *SYSCFG_Type) GetSKR_KEY() uint32 {
	return volatile.LoadUint32(&o.SKR.Reg) & 0xff
}

// Digital filter for sigma delta modulators
type DFSDM_Type struct {
	CH0CFGR1          volatile.Register32 // 0x0
	CH0CFGR2          volatile.Register32 // 0x4
	CH0AWSCDR         volatile.Register32 // 0x8
	CH0WDATR          volatile.Register32 // 0xC
	CH0DATINR         volatile.Register32 // 0x10
	CH0DLYR           volatile.Register32 // 0x14
	_                 [8]byte
	CH1CFGR1          volatile.Register32 // 0x20
	CH1CFGR2          volatile.Register32 // 0x24
	CH1AWSCDR         volatile.Register32 // 0x28
	CH1WDATR          volatile.Register32 // 0x2C
	CH1DATINR         volatile.Register32 // 0x30
	CH1DLYR           volatile.Register32 // 0x34
	_                 [8]byte
	CH2CFGR1          volatile.Register32 // 0x40
	CH2CFGR2          volatile.Register32 // 0x44
	CH2AWSCDR         volatile.Register32 // 0x48
	CH2WDATR          volatile.Register32 // 0x4C
	CH2DATINR         volatile.Register32 // 0x50
	CH2DLYR           volatile.Register32 // 0x54
	_                 [8]byte
	CH3CFGR1          volatile.Register32 // 0x60
	CH3CFGR2          volatile.Register32 // 0x64
	CH3AWSCDR         volatile.Register32 // 0x68
	CH3WDATR          volatile.Register32 // 0x6C
	CH3DATINR         volatile.Register32 // 0x70
	CH3DLYR           volatile.Register32 // 0x74
	_                 [8]byte
	CH4CFGR1          volatile.Register32 // 0x80
	CH4CFGR2          volatile.Register32 // 0x84
	CH4AWSCDR         volatile.Register32 // 0x88
	CH4WDATR          volatile.Register32 // 0x8C
	CH4DATINR         volatile.Register32 // 0x90
	CH4DLYR           volatile.Register32 // 0x94
	_                 [8]byte
	CH5CFGR1          volatile.Register32 // 0xA0
	CH5CFGR2          volatile.Register32 // 0xA4
	CH5AWSCDR         volatile.Register32 // 0xA8
	CH5WDATR          volatile.Register32 // 0xAC
	CH5DATINR         volatile.Register32 // 0xB0
	CH5DLYR           volatile.Register32 // 0xB4
	_                 [8]byte
	CH6CFGR1          volatile.Register32 // 0xC0
	CH6CFGR2          volatile.Register32 // 0xC4
	CH6AWSCDR         volatile.Register32 // 0xC8
	CH6WDATR          volatile.Register32 // 0xCC
	CH6DATINR         volatile.Register32 // 0xD0
	CH6DLYR           volatile.Register32 // 0xD4
	_                 [8]byte
	CH7CFGR1          volatile.Register32 // 0xE0
	CH7CFGR2          volatile.Register32 // 0xE4
	CH7AWSCDR         volatile.Register32 // 0xE8
	CH7WDATR          volatile.Register32 // 0xEC
	CH7DATINR         volatile.Register32 // 0xF0
	CH7DLYR           volatile.Register32 // 0xF4
	_                 [8]byte
	DFSDM_FLT0CR1     volatile.Register32 // 0x100
	DFSDM_FLT0CR2     volatile.Register32 // 0x104
	DFSDM_FLT0ISR     volatile.Register32 // 0x108
	DFSDM_FLT0ICR     volatile.Register32 // 0x10C
	DFSDM_FLT0JCHGR   volatile.Register32 // 0x110
	DFSDM_FLT0FCR     volatile.Register32 // 0x114
	DFSDM_FLT0JDATAR  volatile.Register32 // 0x118
	DFSDM_FLT0RDATAR  volatile.Register32 // 0x11C
	DFSDM_FLT0AWHTR   volatile.Register32 // 0x120
	DFSDM_FLT0AWLTR   volatile.Register32 // 0x124
	DFSDM_FLT0AWSR    volatile.Register32 // 0x128
	DFSDM_FLT0AWCFR   volatile.Register32 // 0x12C
	DFSDM_FLT0EXMAX   volatile.Register32 // 0x130
	DFSDM_FLT0EXMIN   volatile.Register32 // 0x134
	DFSDM_FLT0CNVTIMR volatile.Register32 // 0x138
	_                 [68]byte
	DFSDM_FLT1CR1     volatile.Register32 // 0x180
	DFSDM_FLT1CR2     volatile.Register32 // 0x184
	DFSDM_FLT1ISR     volatile.Register32 // 0x188
	DFSDM_FLT1ICR     volatile.Register32 // 0x18C
	DFSDM_FLT1CHGR    volatile.Register32 // 0x190
	DFSDM_FLT1FCR     volatile.Register32 // 0x194
	DFSDM_FLT1JDATAR  volatile.Register32 // 0x198
	DFSDM_FLT1RDATAR  volatile.Register32 // 0x19C
	DFSDM_FLT1AWHTR   volatile.Register32 // 0x1A0
	DFSDM_FLT1AWLTR   volatile.Register32 // 0x1A4
	DFSDM_FLT1AWSR    volatile.Register32 // 0x1A8
	DFSDM_FLT1AWCFR   volatile.Register32 // 0x1AC
	DFSDM_FLT1EXMAX   volatile.Register32 // 0x1B0
	DFSDM_FLT1EXMIN   volatile.Register32 // 0x1B4
	DFSDM_FLT1CNVTIMR volatile.Register32 // 0x1B8
	_                 [68]byte
	DFSDM_FLT2CR1     volatile.Register32 // 0x200
	DFSDM_FLT2CR2     volatile.Register32 // 0x204
	DFSDM_FLT2ISR     volatile.Register32 // 0x208
	DFSDM_FLT2ICR     volatile.Register32 // 0x20C
	DFSDM_FLT2JCHGR   volatile.Register32 // 0x210
	DFSDM_FLT2FCR     volatile.Register32 // 0x214
	DFSDM_FLT2JDATAR  volatile.Register32 // 0x218
	DFSDM_FLT2RDATAR  volatile.Register32 // 0x21C
	DFSDM_FLT2AWHTR   volatile.Register32 // 0x220
	DFSDM_FLT2AWLTR   volatile.Register32 // 0x224
	DFSDM_FLT2AWSR    volatile.Register32 // 0x228
	DFSDM_FLT2AWCFR   volatile.Register32 // 0x22C
	DFSDM_FLT2EXMAX   volatile.Register32 // 0x230
	DFSDM_FLT2EXMIN   volatile.Register32 // 0x234
	DFSDM_FLT2CNVTIMR volatile.Register32 // 0x238
	_                 [68]byte
	DFSDM_FLT3CR1     volatile.Register32 // 0x280
	DFSDM_FLT3CR2     volatile.Register32 // 0x284
	DFSDM_FLT3ISR     volatile.Register32 // 0x288
	DFSDM_FLT3ICR     volatile.Register32 // 0x28C
	DFSDM_FLT3JCHGR   volatile.Register32 // 0x290
	DFSDM_FLT3FCR     volatile.Register32 // 0x294
	DFSDM_FLT3JDATAR  volatile.Register32 // 0x298
	DFSDM_FLT3RDATAR  volatile.Register32 // 0x29C
	DFSDM_FLT3AWHTR   volatile.Register32 // 0x2A0
	DFSDM_FLT3AWLTR   volatile.Register32 // 0x2A4
	DFSDM_FLT3AWSR    volatile.Register32 // 0x2A8
	DFSDM_FLT3AWCFR   volatile.Register32 // 0x2AC
	DFSDM_FLT3EXMAX   volatile.Register32 // 0x2B0
	DFSDM_FLT3EXMIN   volatile.Register32 // 0x2B4
	DFSDM_FLT3CNVTIMR volatile.Register32 // 0x2B8
}

// DFSDM.CH0CFGR1: channel configuration y register
func (o *DFSDM_Type) SetCH0CFGR1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCH0CFGR1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x80000000) >> 31
}
func (o *DFSDM_Type) SetCH0CFGR1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCH0CFGR1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCH0CFGR1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH0CFGR1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCH0CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH0CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH0CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH0CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH0CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH0CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH0CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH0CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH0CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH0CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH0CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH0CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH0CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH0CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH0CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR1.Reg, volatile.LoadUint32(&o.CH0CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH0CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH0CFGR1.Reg) & 0x3
}

// DFSDM.CH0CFGR2: channel configuration y register
func (o *DFSDM_Type) SetCH0CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR2.Reg, volatile.LoadUint32(&o.CH0CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH0CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH0CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH0CFGR2.Reg, volatile.LoadUint32(&o.CH0CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH0CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH0CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH0AWSCDR: analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetCH0AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH0AWSCDR.Reg, volatile.LoadUint32(&o.CH0AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH0AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH0AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH0AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH0AWSCDR.Reg, volatile.LoadUint32(&o.CH0AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH0AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH0AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH0AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH0AWSCDR.Reg, volatile.LoadUint32(&o.CH0AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH0AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH0AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH0AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH0AWSCDR.Reg, volatile.LoadUint32(&o.CH0AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH0AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH0AWSCDR.Reg) & 0xff
}

// DFSDM.CH0WDATR: channel watchdog filter data register
func (o *DFSDM_Type) SetCH0WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH0WDATR.Reg, volatile.LoadUint32(&o.CH0WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH0WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH0WDATR.Reg) & 0xffff
}

// DFSDM.CH0DATINR: channel data input register
func (o *DFSDM_Type) SetCH0DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH0DATINR.Reg, volatile.LoadUint32(&o.CH0DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH0DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH0DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH0DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH0DATINR.Reg, volatile.LoadUint32(&o.CH0DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH0DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH0DATINR.Reg) & 0xffff
}

// DFSDM.CH0DLYR: channel y delay register
func (o *DFSDM_Type) SetCH0DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH0DLYR.Reg, volatile.LoadUint32(&o.CH0DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH0DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH0DLYR.Reg) & 0x3f
}

// DFSDM.CH1CFGR1: CH1CFGR1
func (o *DFSDM_Type) SetCH1CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH1CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH1CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH1CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH1CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH1CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH1CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH1CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH1CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH1CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH1CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH1CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH1CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH1CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH1CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR1.Reg, volatile.LoadUint32(&o.CH1CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH1CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH1CFGR1.Reg) & 0x3
}

// DFSDM.CH1CFGR2: CH1CFGR2
func (o *DFSDM_Type) SetCH1CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR2.Reg, volatile.LoadUint32(&o.CH1CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH1CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH1CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH1CFGR2.Reg, volatile.LoadUint32(&o.CH1CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH1CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH1CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH1AWSCDR: CH1AWSCDR
func (o *DFSDM_Type) SetCH1AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH1AWSCDR.Reg, volatile.LoadUint32(&o.CH1AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH1AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH1AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH1AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH1AWSCDR.Reg, volatile.LoadUint32(&o.CH1AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH1AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH1AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH1AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH1AWSCDR.Reg, volatile.LoadUint32(&o.CH1AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH1AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH1AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH1AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH1AWSCDR.Reg, volatile.LoadUint32(&o.CH1AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH1AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH1AWSCDR.Reg) & 0xff
}

// DFSDM.CH1WDATR: CH1WDATR
func (o *DFSDM_Type) SetCH1WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH1WDATR.Reg, volatile.LoadUint32(&o.CH1WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH1WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH1WDATR.Reg) & 0xffff
}

// DFSDM.CH1DATINR: CH1DATINR
func (o *DFSDM_Type) SetCH1DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH1DATINR.Reg, volatile.LoadUint32(&o.CH1DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH1DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH1DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH1DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH1DATINR.Reg, volatile.LoadUint32(&o.CH1DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH1DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH1DATINR.Reg) & 0xffff
}

// DFSDM.CH1DLYR: channel y delay register
func (o *DFSDM_Type) SetCH1DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH1DLYR.Reg, volatile.LoadUint32(&o.CH1DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH1DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH1DLYR.Reg) & 0x3f
}

// DFSDM.CH2CFGR1: CH2CFGR1
func (o *DFSDM_Type) SetCH2CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH2CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH2CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH2CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH2CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH2CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH2CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH2CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH2CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH2CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH2CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH2CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH2CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH2CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH2CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR1.Reg, volatile.LoadUint32(&o.CH2CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH2CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH2CFGR1.Reg) & 0x3
}

// DFSDM.CH2CFGR2: CH2CFGR2
func (o *DFSDM_Type) SetCH2CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR2.Reg, volatile.LoadUint32(&o.CH2CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH2CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH2CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH2CFGR2.Reg, volatile.LoadUint32(&o.CH2CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH2CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH2CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH2AWSCDR: CH2AWSCDR
func (o *DFSDM_Type) SetCH2AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH2AWSCDR.Reg, volatile.LoadUint32(&o.CH2AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH2AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH2AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH2AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH2AWSCDR.Reg, volatile.LoadUint32(&o.CH2AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH2AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH2AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH2AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH2AWSCDR.Reg, volatile.LoadUint32(&o.CH2AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH2AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH2AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH2AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH2AWSCDR.Reg, volatile.LoadUint32(&o.CH2AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH2AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH2AWSCDR.Reg) & 0xff
}

// DFSDM.CH2WDATR: CH2WDATR
func (o *DFSDM_Type) SetCH2WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH2WDATR.Reg, volatile.LoadUint32(&o.CH2WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH2WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH2WDATR.Reg) & 0xffff
}

// DFSDM.CH2DATINR: CH2DATINR
func (o *DFSDM_Type) SetCH2DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH2DATINR.Reg, volatile.LoadUint32(&o.CH2DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH2DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH2DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH2DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH2DATINR.Reg, volatile.LoadUint32(&o.CH2DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH2DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH2DATINR.Reg) & 0xffff
}

// DFSDM.CH2DLYR: channel y delay register
func (o *DFSDM_Type) SetCH2DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH2DLYR.Reg, volatile.LoadUint32(&o.CH2DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH2DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH2DLYR.Reg) & 0x3f
}

// DFSDM.CH3CFGR1: CH3CFGR1
func (o *DFSDM_Type) SetCH3CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH3CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH3CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH3CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH3CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH3CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH3CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH3CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH3CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH3CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH3CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH3CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH3CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH3CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH3CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR1.Reg, volatile.LoadUint32(&o.CH3CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH3CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH3CFGR1.Reg) & 0x3
}

// DFSDM.CH3CFGR2: CH3CFGR2
func (o *DFSDM_Type) SetCH3CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR2.Reg, volatile.LoadUint32(&o.CH3CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH3CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH3CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH3CFGR2.Reg, volatile.LoadUint32(&o.CH3CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH3CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH3CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH3AWSCDR: CH3AWSCDR
func (o *DFSDM_Type) SetCH3AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH3AWSCDR.Reg, volatile.LoadUint32(&o.CH3AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH3AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH3AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH3AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH3AWSCDR.Reg, volatile.LoadUint32(&o.CH3AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH3AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH3AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH3AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH3AWSCDR.Reg, volatile.LoadUint32(&o.CH3AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH3AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH3AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH3AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH3AWSCDR.Reg, volatile.LoadUint32(&o.CH3AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH3AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH3AWSCDR.Reg) & 0xff
}

// DFSDM.CH3WDATR: CH3WDATR
func (o *DFSDM_Type) SetCH3WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH3WDATR.Reg, volatile.LoadUint32(&o.CH3WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH3WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH3WDATR.Reg) & 0xffff
}

// DFSDM.CH3DATINR: CH3DATINR
func (o *DFSDM_Type) SetCH3DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH3DATINR.Reg, volatile.LoadUint32(&o.CH3DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH3DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH3DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH3DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH3DATINR.Reg, volatile.LoadUint32(&o.CH3DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH3DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH3DATINR.Reg) & 0xffff
}

// DFSDM.CH3DLYR: channel y delay register
func (o *DFSDM_Type) SetCH3DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH3DLYR.Reg, volatile.LoadUint32(&o.CH3DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH3DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH3DLYR.Reg) & 0x3f
}

// DFSDM.CH4CFGR1: CH4CFGR1
func (o *DFSDM_Type) SetCH4CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH4CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH4CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH4CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH4CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH4CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH4CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH4CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH4CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH4CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH4CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH4CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH4CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH4CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH4CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR1.Reg, volatile.LoadUint32(&o.CH4CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH4CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH4CFGR1.Reg) & 0x3
}

// DFSDM.CH4CFGR2: CH4CFGR2
func (o *DFSDM_Type) SetCH4CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR2.Reg, volatile.LoadUint32(&o.CH4CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH4CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH4CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH4CFGR2.Reg, volatile.LoadUint32(&o.CH4CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH4CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH4CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH4AWSCDR: CH4AWSCDR
func (o *DFSDM_Type) SetCH4AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH4AWSCDR.Reg, volatile.LoadUint32(&o.CH4AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH4AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH4AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH4AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH4AWSCDR.Reg, volatile.LoadUint32(&o.CH4AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH4AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH4AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH4AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH4AWSCDR.Reg, volatile.LoadUint32(&o.CH4AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH4AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH4AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH4AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH4AWSCDR.Reg, volatile.LoadUint32(&o.CH4AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH4AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH4AWSCDR.Reg) & 0xff
}

// DFSDM.CH4WDATR: CH4WDATR
func (o *DFSDM_Type) SetCH4WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH4WDATR.Reg, volatile.LoadUint32(&o.CH4WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH4WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH4WDATR.Reg) & 0xffff
}

// DFSDM.CH4DATINR: CH4DATINR
func (o *DFSDM_Type) SetCH4DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH4DATINR.Reg, volatile.LoadUint32(&o.CH4DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH4DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH4DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH4DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH4DATINR.Reg, volatile.LoadUint32(&o.CH4DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH4DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH4DATINR.Reg) & 0xffff
}

// DFSDM.CH4DLYR: channel y delay register
func (o *DFSDM_Type) SetCH4DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH4DLYR.Reg, volatile.LoadUint32(&o.CH4DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH4DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH4DLYR.Reg) & 0x3f
}

// DFSDM.CH5CFGR1: CH5CFGR1
func (o *DFSDM_Type) SetCH5CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH5CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH5CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH5CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH5CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH5CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH5CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH5CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH5CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH5CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH5CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH5CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH5CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH5CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH5CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR1.Reg, volatile.LoadUint32(&o.CH5CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH5CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH5CFGR1.Reg) & 0x3
}

// DFSDM.CH5CFGR2: CH5CFGR2
func (o *DFSDM_Type) SetCH5CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR2.Reg, volatile.LoadUint32(&o.CH5CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH5CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH5CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH5CFGR2.Reg, volatile.LoadUint32(&o.CH5CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH5CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH5CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH5AWSCDR: CH5AWSCDR
func (o *DFSDM_Type) SetCH5AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH5AWSCDR.Reg, volatile.LoadUint32(&o.CH5AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH5AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH5AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH5AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH5AWSCDR.Reg, volatile.LoadUint32(&o.CH5AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH5AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH5AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH5AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH5AWSCDR.Reg, volatile.LoadUint32(&o.CH5AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH5AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH5AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH5AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH5AWSCDR.Reg, volatile.LoadUint32(&o.CH5AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH5AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH5AWSCDR.Reg) & 0xff
}

// DFSDM.CH5WDATR: CH5WDATR
func (o *DFSDM_Type) SetCH5WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH5WDATR.Reg, volatile.LoadUint32(&o.CH5WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH5WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH5WDATR.Reg) & 0xffff
}

// DFSDM.CH5DATINR: CH5DATINR
func (o *DFSDM_Type) SetCH5DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH5DATINR.Reg, volatile.LoadUint32(&o.CH5DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH5DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH5DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH5DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH5DATINR.Reg, volatile.LoadUint32(&o.CH5DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH5DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH5DATINR.Reg) & 0xffff
}

// DFSDM.CH5DLYR: channel y delay register
func (o *DFSDM_Type) SetCH5DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH5DLYR.Reg, volatile.LoadUint32(&o.CH5DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH5DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH5DLYR.Reg) & 0x3f
}

// DFSDM.CH6CFGR1: CH6CFGR1
func (o *DFSDM_Type) SetCH6CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH6CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH6CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH6CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH6CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH6CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH6CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH6CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH6CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH6CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH6CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH6CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH6CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH6CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH6CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR1.Reg, volatile.LoadUint32(&o.CH6CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH6CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH6CFGR1.Reg) & 0x3
}

// DFSDM.CH6CFGR2: CH6CFGR2
func (o *DFSDM_Type) SetCH6CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR2.Reg, volatile.LoadUint32(&o.CH6CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH6CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH6CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH6CFGR2.Reg, volatile.LoadUint32(&o.CH6CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH6CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH6CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH6AWSCDR: CH6AWSCDR
func (o *DFSDM_Type) SetCH6AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH6AWSCDR.Reg, volatile.LoadUint32(&o.CH6AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH6AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH6AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH6AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH6AWSCDR.Reg, volatile.LoadUint32(&o.CH6AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH6AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH6AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH6AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH6AWSCDR.Reg, volatile.LoadUint32(&o.CH6AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH6AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH6AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH6AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH6AWSCDR.Reg, volatile.LoadUint32(&o.CH6AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH6AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH6AWSCDR.Reg) & 0xff
}

// DFSDM.CH6WDATR: CH6WDATR
func (o *DFSDM_Type) SetCH6WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH6WDATR.Reg, volatile.LoadUint32(&o.CH6WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH6WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH6WDATR.Reg) & 0xffff
}

// DFSDM.CH6DATINR: CH6DATINR
func (o *DFSDM_Type) SetCH6DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH6DATINR.Reg, volatile.LoadUint32(&o.CH6DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH6DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH6DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH6DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH6DATINR.Reg, volatile.LoadUint32(&o.CH6DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH6DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH6DATINR.Reg) & 0xffff
}

// DFSDM.CH6DLYR: channel y delay register
func (o *DFSDM_Type) SetCH6DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH6DLYR.Reg, volatile.LoadUint32(&o.CH6DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH6DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH6DLYR.Reg) & 0x3f
}

// DFSDM.CH7CFGR1: CH7CFGR1
func (o *DFSDM_Type) SetCH7CFGR1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCH7CFGR1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCH7CFGR1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCH7CFGR1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCH7CFGR1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCH7CFGR1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCH7CFGR1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCH7CFGR1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCH7CFGR1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCH7CFGR1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCH7CFGR1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCH7CFGR1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCH7CFGR1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCH7CFGR1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCH7CFGR1_SITP(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR1.Reg, volatile.LoadUint32(&o.CH7CFGR1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCH7CFGR1_SITP() uint32 {
	return volatile.LoadUint32(&o.CH7CFGR1.Reg) & 0x3
}

// DFSDM.CH7CFGR2: CH7CFGR2
func (o *DFSDM_Type) SetCH7CFGR2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR2.Reg, volatile.LoadUint32(&o.CH7CFGR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCH7CFGR2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR2.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetCH7CFGR2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CH7CFGR2.Reg, volatile.LoadUint32(&o.CH7CFGR2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCH7CFGR2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CH7CFGR2.Reg) & 0xf8) >> 3
}

// DFSDM.CH7AWSCDR: CH7AWSCDR
func (o *DFSDM_Type) SetCH7AWSCDR_AWFORD(value uint32) {
	volatile.StoreUint32(&o.CH7AWSCDR.Reg, volatile.LoadUint32(&o.CH7AWSCDR.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetCH7AWSCDR_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.CH7AWSCDR.Reg) & 0xc00000) >> 22
}
func (o *DFSDM_Type) SetCH7AWSCDR_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.CH7AWSCDR.Reg, volatile.LoadUint32(&o.CH7AWSCDR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetCH7AWSCDR_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.CH7AWSCDR.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetCH7AWSCDR_BKSCD(value uint32) {
	volatile.StoreUint32(&o.CH7AWSCDR.Reg, volatile.LoadUint32(&o.CH7AWSCDR.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetCH7AWSCDR_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.CH7AWSCDR.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetCH7AWSCDR_SCDT(value uint32) {
	volatile.StoreUint32(&o.CH7AWSCDR.Reg, volatile.LoadUint32(&o.CH7AWSCDR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetCH7AWSCDR_SCDT() uint32 {
	return volatile.LoadUint32(&o.CH7AWSCDR.Reg) & 0xff
}

// DFSDM.CH7WDATR: CH7WDATR
func (o *DFSDM_Type) SetCH7WDATR_WDATA(value uint32) {
	volatile.StoreUint32(&o.CH7WDATR.Reg, volatile.LoadUint32(&o.CH7WDATR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH7WDATR_WDATA() uint32 {
	return volatile.LoadUint32(&o.CH7WDATR.Reg) & 0xffff
}

// DFSDM.CH7DATINR: CH7DATINR
func (o *DFSDM_Type) SetCH7DATINR_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CH7DATINR.Reg, volatile.LoadUint32(&o.CH7DATINR.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCH7DATINR_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CH7DATINR.Reg) & 0xffff0000) >> 16
}
func (o *DFSDM_Type) SetCH7DATINR_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CH7DATINR.Reg, volatile.LoadUint32(&o.CH7DATINR.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCH7DATINR_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CH7DATINR.Reg) & 0xffff
}

// DFSDM.CH7DLYR: channel y delay register
func (o *DFSDM_Type) SetCH7DLYR_PLSSKP(value uint32) {
	volatile.StoreUint32(&o.CH7DLYR.Reg, volatile.LoadUint32(&o.CH7DLYR.Reg)&^(0x3f)|value)
}
func (o *DFSDM_Type) GetCH7DLYR_PLSSKP() uint32 {
	return volatile.LoadUint32(&o.CH7DLYR.Reg) & 0x3f
}

// DFSDM.DFSDM_FLT0CR1: control register 1
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x700)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x700) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0CR1.Reg) & 0x1
}

// DFSDM.DFSDM_FLT0CR2: control register 2
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT0CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0CR2.Reg) & 0x1
}

// DFSDM.DFSDM_FLT0ISR: interrupt and status register
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT0ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0ISR.Reg) & 0x1
}

// DFSDM.DFSDM_FLT0ICR: interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM_FLT0ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT0ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT0ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT0ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT0ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0ICR.Reg) & 0x4) >> 2
}

// DFSDM.DFSDM_FLT0JCHGR: injected channel group selection register
func (o *DFSDM_Type) SetDFSDM_FLT0JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0JCHGR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT0FCR: filter control register
func (o *DFSDM_Type) SetDFSDM_FLT0FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT0FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0FCR.Reg) & 0xe0000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT0FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT0FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT0FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0FCR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT0JDATAR: data register for injected group
func (o *DFSDM_Type) SetDFSDM_FLT0JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0JDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0JDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT0RDATAR: data register for the regular channel
func (o *DFSDM_Type) SetDFSDM_FLT0RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0RDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT0RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT0RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0RDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT0AWHTR: analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM_FLT0AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0AWHTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0AWHTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT0AWLTR: analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM_FLT0AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0AWLTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0AWLTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT0AWSR: analog watchdog status register
func (o *DFSDM_Type) SetDFSDM_FLT0AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0AWSR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0AWSR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT0AWCFR: analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM_FLT0AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0AWCFR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0AWCFR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT0EXMAX: Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM_FLT0EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT0EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0EXMAX.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT0EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0EXMAX.Reg) & 0x7
}

// DFSDM.DFSDM_FLT0EXMIN: Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM_FLT0EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT0EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT0EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0EXMIN.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT0EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT0EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT0EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT0EXMIN.Reg) & 0x7
}

// DFSDM.DFSDM_FLT0CNVTIMR: conversion timer register
func (o *DFSDM_Type) SetDFSDM_FLT0CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT0CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM_FLT0CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT0CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT0CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DFSDM.DFSDM_FLT1CR1: control register 1
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x700)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x700) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1CR1.Reg) & 0x1
}

// DFSDM.DFSDM_FLT1CR2: control register 2
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT1CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1CR2.Reg) & 0x1
}

// DFSDM.DFSDM_FLT1ISR: interrupt and status register
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT1ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1ISR.Reg) & 0x1
}

// DFSDM.DFSDM_FLT1ICR: interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM_FLT1ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT1ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT1ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT1ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT1ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1ICR.Reg) & 0x4) >> 2
}

// DFSDM.DFSDM_FLT1CHGR: injected channel group selection register
func (o *DFSDM_Type) SetDFSDM_FLT1CHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CHGR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1CHGR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT1FCR: filter control register
func (o *DFSDM_Type) SetDFSDM_FLT1FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT1FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1FCR.Reg) & 0xe0000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT1FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT1FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT1FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1FCR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT1JDATAR: data register for injected group
func (o *DFSDM_Type) SetDFSDM_FLT1JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1JDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1JDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT1RDATAR: data register for the regular channel
func (o *DFSDM_Type) SetDFSDM_FLT1RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1RDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT1RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT1RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1RDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT1AWHTR: analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM_FLT1AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1AWHTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1AWHTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT1AWLTR: analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM_FLT1AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1AWLTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1AWLTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT1AWSR: analog watchdog status register
func (o *DFSDM_Type) SetDFSDM_FLT1AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1AWSR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1AWSR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT1AWCFR: analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM_FLT1AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1AWCFR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1AWCFR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT1EXMAX: Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM_FLT1EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT1EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1EXMAX.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT1EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1EXMAX.Reg) & 0x7
}

// DFSDM.DFSDM_FLT1EXMIN: Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM_FLT1EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT1EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT1EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1EXMIN.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT1EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT1EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT1EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT1EXMIN.Reg) & 0x7
}

// DFSDM.DFSDM_FLT1CNVTIMR: conversion timer register
func (o *DFSDM_Type) SetDFSDM_FLT1CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT1CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM_FLT1CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT1CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT1CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DFSDM.DFSDM_FLT2CR1: control register 1
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x700)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x700) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2CR1.Reg) & 0x1
}

// DFSDM.DFSDM_FLT2CR2: control register 2
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT2CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2CR2.Reg) & 0x1
}

// DFSDM.DFSDM_FLT2ISR: interrupt and status register
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT2ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2ISR.Reg) & 0x1
}

// DFSDM.DFSDM_FLT2ICR: interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM_FLT2ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT2ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT2ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT2ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT2ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2ICR.Reg) & 0x4) >> 2
}

// DFSDM.DFSDM_FLT2JCHGR: injected channel group selection register
func (o *DFSDM_Type) SetDFSDM_FLT2JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2JCHGR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT2FCR: filter control register
func (o *DFSDM_Type) SetDFSDM_FLT2FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT2FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2FCR.Reg) & 0xe0000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT2FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT2FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT2FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2FCR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT2JDATAR: data register for injected group
func (o *DFSDM_Type) SetDFSDM_FLT2JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2JDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2JDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT2RDATAR: data register for the regular channel
func (o *DFSDM_Type) SetDFSDM_FLT2RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2RDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT2RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT2RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2RDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT2AWHTR: analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM_FLT2AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2AWHTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2AWHTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT2AWLTR: analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM_FLT2AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2AWLTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2AWLTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT2AWSR: analog watchdog status register
func (o *DFSDM_Type) SetDFSDM_FLT2AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2AWSR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2AWSR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT2AWCFR: analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM_FLT2AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2AWCFR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2AWCFR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT2EXMAX: Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM_FLT2EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT2EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2EXMAX.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT2EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2EXMAX.Reg) & 0x7
}

// DFSDM.DFSDM_FLT2EXMIN: Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM_FLT2EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT2EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT2EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2EXMIN.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT2EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT2EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT2EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT2EXMIN.Reg) & 0x7
}

// DFSDM.DFSDM_FLT2CNVTIMR: conversion timer register
func (o *DFSDM_Type) SetDFSDM_FLT2CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT2CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM_FLT2CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT2CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT2CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DFSDM.DFSDM_FLT3CR1: control register 1
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x700)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x700) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR1.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3CR1.Reg) & 0x1
}

// DFSDM.DFSDM_FLT3CR2: control register 2
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT3CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CR2.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3CR2.Reg) & 0x1
}

// DFSDM.DFSDM_FLT3ISR: interrupt and status register
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM_FLT3ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ISR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3ISR.Reg) & 0x1
}

// DFSDM.DFSDM_FLT3ICR: interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM_FLT3ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg) & 0xff000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM_FLT3ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT3ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM_FLT3ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3ICR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM_FLT3ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3ICR.Reg) & 0x4) >> 2
}

// DFSDM.DFSDM_FLT3JCHGR: injected channel group selection register
func (o *DFSDM_Type) SetDFSDM_FLT3JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3JCHGR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT3FCR: filter control register
func (o *DFSDM_Type) SetDFSDM_FLT3FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM_FLT3FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3FCR.Reg) & 0xe0000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM_FLT3FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM_FLT3FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM_FLT3FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3FCR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3FCR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT3JDATAR: data register for injected group
func (o *DFSDM_Type) SetDFSDM_FLT3JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3JDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3JDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3JDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT3RDATAR: data register for the regular channel
func (o *DFSDM_Type) SetDFSDM_FLT3RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3RDATAR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT3RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM_FLT3RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3RDATAR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3RDATAR.Reg) & 0x7
}

// DFSDM.DFSDM_FLT3AWHTR: analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM_FLT3AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3AWHTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWHTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3AWHTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT3AWLTR: analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM_FLT3AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3AWLTR.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWLTR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3AWLTR.Reg) & 0xf
}

// DFSDM.DFSDM_FLT3AWSR: analog watchdog status register
func (o *DFSDM_Type) SetDFSDM_FLT3AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3AWSR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWSR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3AWSR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT3AWCFR: analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM_FLT3AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3AWCFR.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3AWCFR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3AWCFR.Reg) & 0xff
}

// DFSDM.DFSDM_FLT3EXMAX: Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM_FLT3EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT3EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3EXMAX.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3EXMAX.Reg, volatile.LoadUint32(&o.DFSDM_FLT3EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3EXMAX.Reg) & 0x7
}

// DFSDM.DFSDM_FLT3EXMIN: Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM_FLT3EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT3EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM_FLT3EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3EXMIN.Reg) & 0xffffff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM_FLT3EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3EXMIN.Reg, volatile.LoadUint32(&o.DFSDM_FLT3EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM_FLT3EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM_FLT3EXMIN.Reg) & 0x7
}

// DFSDM.DFSDM_FLT3CNVTIMR: conversion timer register
func (o *DFSDM_Type) SetDFSDM_FLT3CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM_FLT3CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM_FLT3CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM_FLT3CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM_FLT3CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// Random number generator
type RNG_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	DR volatile.Register32 // 0x8
}

// RNG.CR: control register
func (o *RNG_Type) SetCR_IE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetCR_IE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetCR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetCR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}

// RNG.SR: status register
func (o *RNG_Type) SetSR_SEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *RNG_Type) GetSR_SEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *RNG_Type) SetSR_CEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RNG_Type) GetSR_CEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *RNG_Type) SetSR_SECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetSR_SECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetSR_CECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetSR_CECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetSR_DRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSR_DRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// RNG.DR: data register
func (o *RNG_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *RNG_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// Advanced encryption standard hardware accelerator
type AES_Type struct {
	CR    volatile.Register32 // 0x0
	SR    volatile.Register32 // 0x4
	DINR  volatile.Register32 // 0x8
	DOUTR volatile.Register32 // 0xC
	KEYR0 volatile.Register32 // 0x10
	KEYR1 volatile.Register32 // 0x14
	KEYR2 volatile.Register32 // 0x18
	KEYR3 volatile.Register32 // 0x1C
	IVR0  volatile.Register32 // 0x20
	IVR1  volatile.Register32 // 0x24
	IVR2  volatile.Register32 // 0x28
	IVR3  volatile.Register32 // 0x2C
}

// AES.CR: control register
func (o *AES_Type) SetCR_DMAOUTEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *AES_Type) GetCR_DMAOUTEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *AES_Type) SetCR_DMAINEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *AES_Type) GetCR_DMAINEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *AES_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *AES_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *AES_Type) SetCR_CCFIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *AES_Type) GetCR_CCFIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *AES_Type) SetCR_ERRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *AES_Type) GetCR_ERRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *AES_Type) SetCR_CCFC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *AES_Type) GetCR_CCFC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *AES_Type) SetCR_CHMOD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *AES_Type) GetCR_CHMOD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *AES_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *AES_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *AES_Type) SetCR_DATATYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x6)|value<<1)
}
func (o *AES_Type) GetCR_DATATYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x6) >> 1
}
func (o *AES_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// AES.SR: status register
func (o *AES_Type) SetSR_WRERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *AES_Type) GetSR_WRERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *AES_Type) SetSR_RDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetSR_RDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *AES_Type) SetSR_CCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetSR_CCF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// AES.DINR: data input register
func (o *AES_Type) SetDINR(value uint32) {
	volatile.StoreUint32(&o.DINR.Reg, value)
}
func (o *AES_Type) GetDINR() uint32 {
	return volatile.LoadUint32(&o.DINR.Reg)
}

// AES.DOUTR: data output register
func (o *AES_Type) SetDOUTR(value uint32) {
	volatile.StoreUint32(&o.DOUTR.Reg, value)
}
func (o *AES_Type) GetDOUTR() uint32 {
	return volatile.LoadUint32(&o.DOUTR.Reg)
}

// AES.KEYR0: key register 0
func (o *AES_Type) SetKEYR0(value uint32) {
	volatile.StoreUint32(&o.KEYR0.Reg, value)
}
func (o *AES_Type) GetKEYR0() uint32 {
	return volatile.LoadUint32(&o.KEYR0.Reg)
}

// AES.KEYR1: key register 1
func (o *AES_Type) SetKEYR1(value uint32) {
	volatile.StoreUint32(&o.KEYR1.Reg, value)
}
func (o *AES_Type) GetKEYR1() uint32 {
	return volatile.LoadUint32(&o.KEYR1.Reg)
}

// AES.KEYR2: key register 2
func (o *AES_Type) SetKEYR2(value uint32) {
	volatile.StoreUint32(&o.KEYR2.Reg, value)
}
func (o *AES_Type) GetKEYR2() uint32 {
	return volatile.LoadUint32(&o.KEYR2.Reg)
}

// AES.KEYR3: key register 3
func (o *AES_Type) SetKEYR3(value uint32) {
	volatile.StoreUint32(&o.KEYR3.Reg, value)
}
func (o *AES_Type) GetKEYR3() uint32 {
	return volatile.LoadUint32(&o.KEYR3.Reg)
}

// AES.IVR0: initialization vector register 0
func (o *AES_Type) SetIVR0(value uint32) {
	volatile.StoreUint32(&o.IVR0.Reg, value)
}
func (o *AES_Type) GetIVR0() uint32 {
	return volatile.LoadUint32(&o.IVR0.Reg)
}

// AES.IVR1: initialization vector register 1
func (o *AES_Type) SetIVR1(value uint32) {
	volatile.StoreUint32(&o.IVR1.Reg, value)
}
func (o *AES_Type) GetIVR1() uint32 {
	return volatile.LoadUint32(&o.IVR1.Reg)
}

// AES.IVR2: initialization vector register 2
func (o *AES_Type) SetIVR2(value uint32) {
	volatile.StoreUint32(&o.IVR2.Reg, value)
}
func (o *AES_Type) GetIVR2() uint32 {
	return volatile.LoadUint32(&o.IVR2.Reg)
}

// AES.IVR3: initialization vector register 3
func (o *AES_Type) SetIVR3(value uint32) {
	volatile.StoreUint32(&o.IVR3.Reg, value)
}
func (o *AES_Type) GetIVR3() uint32 {
	return volatile.LoadUint32(&o.IVR3.Reg)
}

// Analog-to-Digital Converter
type ADC_Type struct {
	ISR     volatile.Register32 // 0x0
	IER     volatile.Register32 // 0x4
	CR      volatile.Register32 // 0x8
	CFGR    volatile.Register32 // 0xC
	CFGR2   volatile.Register32 // 0x10
	SMPR1   volatile.Register32 // 0x14
	SMPR2   volatile.Register32 // 0x18
	_       [4]byte
	TR1     volatile.Register32 // 0x20
	TR2     volatile.Register32 // 0x24
	TR3     volatile.Register32 // 0x28
	_       [4]byte
	SQR1    volatile.Register32 // 0x30
	SQR2    volatile.Register32 // 0x34
	SQR3    volatile.Register32 // 0x38
	SQR4    volatile.Register32 // 0x3C
	DR      volatile.Register32 // 0x40
	_       [8]byte
	JSQR    volatile.Register32 // 0x4C
	_       [16]byte
	OFR1    volatile.Register32 // 0x60
	OFR2    volatile.Register32 // 0x64
	OFR3    volatile.Register32 // 0x68
	OFR4    volatile.Register32 // 0x6C
	_       [16]byte
	JDR1    volatile.Register32 // 0x80
	JDR2    volatile.Register32 // 0x84
	JDR3    volatile.Register32 // 0x88
	JDR4    volatile.Register32 // 0x8C
	_       [16]byte
	AWD2CR  volatile.Register32 // 0xA0
	AWD3CR  volatile.Register32 // 0xA4
	_       [8]byte
	DIFSEL  volatile.Register32 // 0xB0
	CALFACT volatile.Register32 // 0xB4
}

// ADC.ISR: interrupt and status register
func (o *ADC_Type) SetISR_JQOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetISR_JQOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetISR_AWD3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetISR_AWD3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetISR_AWD2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetISR_AWD2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetISR_AWD1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetISR_AWD1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetISR_JEOS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetISR_JEOS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetISR_JEOC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetISR_JEOC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetISR_EOS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetISR_EOS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetISR_EOC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetISR_EOC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetISR_EOSMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetISR_EOSMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetISR_ADRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetISR_ADRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// ADC.IER: interrupt enable register
func (o *ADC_Type) SetIER_JQOVFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIER_JQOVFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIER_AWD3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIER_AWD3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIER_AWD2IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIER_AWD2IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIER_AWD1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIER_AWD1IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIER_JEOSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIER_JEOSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIER_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIER_JEOCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIER_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIER_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIER_EOSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIER_EOSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIER_EOCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIER_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIER_EOSMPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIER_EOSMPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIER_ADRDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIER_ADRDYIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// ADC.CR: control register
func (o *ADC_Type) SetCR_ADCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetCR_ADCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetCR_ADCALDIF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetCR_ADCALDIF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetCR_DEEPPWD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetCR_DEEPPWD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetCR_ADVREGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_Type) GetCR_ADVREGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *ADC_Type) SetCR_JADSTP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCR_JADSTP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCR_ADSTP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCR_ADSTP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCR_JADSTART(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCR_JADSTART() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCR_ADSTART(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCR_ADSTART() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCR_ADDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR_ADDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR_ADEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR_ADEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// ADC.CFGR: configuration register
func (o *ADC_Type) SetCFGR_AWDCH1CH(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetCFGR_AWDCH1CH() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetCFGR_JAUTO(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetCFGR_JAUTO() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetCFGR_JAWD1EN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCFGR_JAWD1EN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetCFGR_AWD1EN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCFGR_AWD1EN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCFGR_AWD1SGL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCFGR_AWD1SGL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCFGR_JQM(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCFGR_JQM() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCFGR_JDISCEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetCFGR_JDISCEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetCFGR_DISCNUM(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe0000)|value<<17)
}
func (o *ADC_Type) GetCFGR_DISCNUM() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe0000) >> 17
}
func (o *ADC_Type) SetCFGR_DISCEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCFGR_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCFGR_AUTDLY(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetCFGR_AUTDLY() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetCFGR_CONT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFGR_CONT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFGR_OVRMOD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCFGR_OVRMOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCFGR_EXTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc00)|value<<10)
}
func (o *ADC_Type) GetCFGR_EXTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc00) >> 10
}
func (o *ADC_Type) SetCFGR_EXTSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3c0)|value<<6)
}
func (o *ADC_Type) GetCFGR_EXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x3c0) >> 6
}
func (o *ADC_Type) SetCFGR_ALIGN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCFGR_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCFGR_RES(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x18)|value<<3)
}
func (o *ADC_Type) GetCFGR_RES() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x18) >> 3
}
func (o *ADC_Type) SetCFGR_DMACFG(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCFGR_DMACFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCFGR_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR_DMAEN() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x1
}
func (o *ADC_Type) SetCFGR_JQDIS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetCFGR_JQDIS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}

// ADC.CFGR2: configuration register
func (o *ADC_Type) SetCFGR2_ROVSM(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCFGR2_ROVSM() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCFGR2_TROVS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCFGR2_TROVS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCFGR2_OVSS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1e0)|value<<5)
}
func (o *ADC_Type) GetCFGR2_OVSS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1e0) >> 5
}
func (o *ADC_Type) SetCFGR2_OVSR(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1c)|value<<2)
}
func (o *ADC_Type) GetCFGR2_OVSR() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1c) >> 2
}
func (o *ADC_Type) SetCFGR2_JOVSE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCFGR2_JOVSE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCFGR2_ROVSE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR2_ROVSE() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}

// ADC.SMPR1: sample time register 1
func (o *ADC_Type) SetSMPR1_SMP9(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC_Type) GetSMPR1_SMP9() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x38000000) >> 27
}
func (o *ADC_Type) SetSMPR1_SMP8(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetSMPR1_SMP8() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetSMPR1_SMP7(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0xe00000)|value<<21)
}
func (o *ADC_Type) GetSMPR1_SMP7() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0xe00000) >> 21
}
func (o *ADC_Type) SetSMPR1_SMP6(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x1c0000)|value<<18)
}
func (o *ADC_Type) GetSMPR1_SMP6() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x1c0000) >> 18
}
func (o *ADC_Type) SetSMPR1_SMP5(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x38000)|value<<15)
}
func (o *ADC_Type) GetSMPR1_SMP5() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x38000) >> 15
}
func (o *ADC_Type) SetSMPR1_SMP4(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_Type) GetSMPR1_SMP4() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x7000) >> 12
}
func (o *ADC_Type) SetSMPR1_SMP3(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0xe00)|value<<9)
}
func (o *ADC_Type) GetSMPR1_SMP3() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0xe00) >> 9
}
func (o *ADC_Type) SetSMPR1_SMP2(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC_Type) GetSMPR1_SMP2() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x1c0) >> 6
}
func (o *ADC_Type) SetSMPR1_SMP1(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x38)|value<<3)
}
func (o *ADC_Type) GetSMPR1_SMP1() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x38) >> 3
}
func (o *ADC_Type) SetSMPR1_SMPPLUS(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetSMPR1_SMPPLUS() uint32 {
	return (volatile.LoadUint32(&o.SMPR1.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetSMPR1_SMP0(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, volatile.LoadUint32(&o.SMPR1.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetSMPR1_SMP0() uint32 {
	return volatile.LoadUint32(&o.SMPR1.Reg) & 0x7
}

// ADC.SMPR2: sample time register 2
func (o *ADC_Type) SetSMPR2_SMP18(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetSMPR2_SMP18() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetSMPR2_SMP17(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0xe00000)|value<<21)
}
func (o *ADC_Type) GetSMPR2_SMP17() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0xe00000) >> 21
}
func (o *ADC_Type) SetSMPR2_SMP16(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x1c0000)|value<<18)
}
func (o *ADC_Type) GetSMPR2_SMP16() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x1c0000) >> 18
}
func (o *ADC_Type) SetSMPR2_SMP15(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x38000)|value<<15)
}
func (o *ADC_Type) GetSMPR2_SMP15() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x38000) >> 15
}
func (o *ADC_Type) SetSMPR2_SMP14(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_Type) GetSMPR2_SMP14() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x7000) >> 12
}
func (o *ADC_Type) SetSMPR2_SMP13(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0xe00)|value<<9)
}
func (o *ADC_Type) GetSMPR2_SMP13() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0xe00) >> 9
}
func (o *ADC_Type) SetSMPR2_SMP12(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC_Type) GetSMPR2_SMP12() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x1c0) >> 6
}
func (o *ADC_Type) SetSMPR2_SMP11(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x38)|value<<3)
}
func (o *ADC_Type) GetSMPR2_SMP11() uint32 {
	return (volatile.LoadUint32(&o.SMPR2.Reg) & 0x38) >> 3
}
func (o *ADC_Type) SetSMPR2_SMP10(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, volatile.LoadUint32(&o.SMPR2.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetSMPR2_SMP10() uint32 {
	return volatile.LoadUint32(&o.SMPR2.Reg) & 0x7
}

// ADC.TR1: watchdog threshold register 1
func (o *ADC_Type) SetTR1_HT1(value uint32) {
	volatile.StoreUint32(&o.TR1.Reg, volatile.LoadUint32(&o.TR1.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetTR1_HT1() uint32 {
	return (volatile.LoadUint32(&o.TR1.Reg) & 0xfff0000) >> 16
}
func (o *ADC_Type) SetTR1_LT1(value uint32) {
	volatile.StoreUint32(&o.TR1.Reg, volatile.LoadUint32(&o.TR1.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetTR1_LT1() uint32 {
	return volatile.LoadUint32(&o.TR1.Reg) & 0xfff
}

// ADC.TR2: watchdog threshold register
func (o *ADC_Type) SetTR2_HT2(value uint32) {
	volatile.StoreUint32(&o.TR2.Reg, volatile.LoadUint32(&o.TR2.Reg)&^(0xff0000)|value<<16)
}
func (o *ADC_Type) GetTR2_HT2() uint32 {
	return (volatile.LoadUint32(&o.TR2.Reg) & 0xff0000) >> 16
}
func (o *ADC_Type) SetTR2_LT2(value uint32) {
	volatile.StoreUint32(&o.TR2.Reg, volatile.LoadUint32(&o.TR2.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetTR2_LT2() uint32 {
	return volatile.LoadUint32(&o.TR2.Reg) & 0xff
}

// ADC.TR3: watchdog threshold register 3
func (o *ADC_Type) SetTR3_HT3(value uint32) {
	volatile.StoreUint32(&o.TR3.Reg, volatile.LoadUint32(&o.TR3.Reg)&^(0xff0000)|value<<16)
}
func (o *ADC_Type) GetTR3_HT3() uint32 {
	return (volatile.LoadUint32(&o.TR3.Reg) & 0xff0000) >> 16
}
func (o *ADC_Type) SetTR3_LT3(value uint32) {
	volatile.StoreUint32(&o.TR3.Reg, volatile.LoadUint32(&o.TR3.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetTR3_LT3() uint32 {
	return volatile.LoadUint32(&o.TR3.Reg) & 0xff
}

// ADC.SQR1: regular sequence register 1
func (o *ADC_Type) SetSQR1_SQ4(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetSQR1_SQ4() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x1f000000) >> 24
}
func (o *ADC_Type) SetSQR1_SQ3(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x7c0000)|value<<18)
}
func (o *ADC_Type) GetSQR1_SQ3() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x7c0000) >> 18
}
func (o *ADC_Type) SetSQR1_SQ2(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x1f000)|value<<12)
}
func (o *ADC_Type) GetSQR1_SQ2() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x1f000) >> 12
}
func (o *ADC_Type) SetSQR1_SQ1(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR1_SQ1() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR1_L(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetSQR1_L() uint32 {
	return volatile.LoadUint32(&o.SQR1.Reg) & 0xf
}

// ADC.SQR2: regular sequence register 2
func (o *ADC_Type) SetSQR2_SQ9(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetSQR2_SQ9() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x1f000000) >> 24
}
func (o *ADC_Type) SetSQR2_SQ8(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x7c0000)|value<<18)
}
func (o *ADC_Type) GetSQR2_SQ8() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x7c0000) >> 18
}
func (o *ADC_Type) SetSQR2_SQ7(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f000)|value<<12)
}
func (o *ADC_Type) GetSQR2_SQ7() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x1f000) >> 12
}
func (o *ADC_Type) SetSQR2_SQ6(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR2_SQ6() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR2_SQ5(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR2_SQ5() uint32 {
	return volatile.LoadUint32(&o.SQR2.Reg) & 0x1f
}

// ADC.SQR3: regular sequence register 3
func (o *ADC_Type) SetSQR3_SQ14(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetSQR3_SQ14() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x1f000000) >> 24
}
func (o *ADC_Type) SetSQR3_SQ13(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x7c0000)|value<<18)
}
func (o *ADC_Type) GetSQR3_SQ13() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x7c0000) >> 18
}
func (o *ADC_Type) SetSQR3_SQ12(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f000)|value<<12)
}
func (o *ADC_Type) GetSQR3_SQ12() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x1f000) >> 12
}
func (o *ADC_Type) SetSQR3_SQ11(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR3_SQ11() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR3_SQ10(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR3_SQ10() uint32 {
	return volatile.LoadUint32(&o.SQR3.Reg) & 0x1f
}

// ADC.SQR4: regular sequence register 4
func (o *ADC_Type) SetSQR4_SQ16(value uint32) {
	volatile.StoreUint32(&o.SQR4.Reg, volatile.LoadUint32(&o.SQR4.Reg)&^(0x7c0)|value<<6)
}
func (o *ADC_Type) GetSQR4_SQ16() uint32 {
	return (volatile.LoadUint32(&o.SQR4.Reg) & 0x7c0) >> 6
}
func (o *ADC_Type) SetSQR4_SQ15(value uint32) {
	volatile.StoreUint32(&o.SQR4.Reg, volatile.LoadUint32(&o.SQR4.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR4_SQ15() uint32 {
	return volatile.LoadUint32(&o.SQR4.Reg) & 0x1f
}

// ADC.DR: regular Data Register
func (o *ADC_Type) SetDR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetDR_RDATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// ADC.JSQR: injected sequence register
func (o *ADC_Type) SetJSQR_JSQ4(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetJSQR_JSQ4() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetJSQR_JSQ3(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x1f00000)|value<<20)
}
func (o *ADC_Type) GetJSQR_JSQ3() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x1f00000) >> 20
}
func (o *ADC_Type) SetJSQR_JSQ2(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x7c000)|value<<14)
}
func (o *ADC_Type) GetJSQR_JSQ2() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x7c000) >> 14
}
func (o *ADC_Type) SetJSQR_JSQ1(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetJSQR_JSQ1() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetJSQR_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0xc0)|value<<6)
}
func (o *ADC_Type) GetJSQR_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0xc0) >> 6
}
func (o *ADC_Type) SetJSQR_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x3c)|value<<2)
}
func (o *ADC_Type) GetJSQR_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x3c) >> 2
}
func (o *ADC_Type) SetJSQR_JL(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetJSQR_JL() uint32 {
	return volatile.LoadUint32(&o.JSQR.Reg) & 0x3
}

// ADC.OFR1: offset register 1
func (o *ADC_Type) SetOFR1_OFFSET1_EN(value uint32) {
	volatile.StoreUint32(&o.OFR1.Reg, volatile.LoadUint32(&o.OFR1.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR1_OFFSET1_EN() uint32 {
	return (volatile.LoadUint32(&o.OFR1.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR1_OFFSET1_CH(value uint32) {
	volatile.StoreUint32(&o.OFR1.Reg, volatile.LoadUint32(&o.OFR1.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR1_OFFSET1_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR1.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR1_OFFSET1(value uint32) {
	volatile.StoreUint32(&o.OFR1.Reg, volatile.LoadUint32(&o.OFR1.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetOFR1_OFFSET1() uint32 {
	return volatile.LoadUint32(&o.OFR1.Reg) & 0xfff
}

// ADC.OFR2: offset register 2
func (o *ADC_Type) SetOFR2_OFFSET2_EN(value uint32) {
	volatile.StoreUint32(&o.OFR2.Reg, volatile.LoadUint32(&o.OFR2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR2_OFFSET2_EN() uint32 {
	return (volatile.LoadUint32(&o.OFR2.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR2_OFFSET2_CH(value uint32) {
	volatile.StoreUint32(&o.OFR2.Reg, volatile.LoadUint32(&o.OFR2.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR2_OFFSET2_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR2.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR2_OFFSET2(value uint32) {
	volatile.StoreUint32(&o.OFR2.Reg, volatile.LoadUint32(&o.OFR2.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetOFR2_OFFSET2() uint32 {
	return volatile.LoadUint32(&o.OFR2.Reg) & 0xfff
}

// ADC.OFR3: offset register 3
func (o *ADC_Type) SetOFR3_OFFSET3_EN(value uint32) {
	volatile.StoreUint32(&o.OFR3.Reg, volatile.LoadUint32(&o.OFR3.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR3_OFFSET3_EN() uint32 {
	return (volatile.LoadUint32(&o.OFR3.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR3_OFFSET3_CH(value uint32) {
	volatile.StoreUint32(&o.OFR3.Reg, volatile.LoadUint32(&o.OFR3.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR3_OFFSET3_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR3.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR3_OFFSET3(value uint32) {
	volatile.StoreUint32(&o.OFR3.Reg, volatile.LoadUint32(&o.OFR3.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetOFR3_OFFSET3() uint32 {
	return volatile.LoadUint32(&o.OFR3.Reg) & 0xfff
}

// ADC.OFR4: offset register 4
func (o *ADC_Type) SetOFR4_OFFSET4_EN(value uint32) {
	volatile.StoreUint32(&o.OFR4.Reg, volatile.LoadUint32(&o.OFR4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetOFR4_OFFSET4_EN() uint32 {
	return (volatile.LoadUint32(&o.OFR4.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetOFR4_OFFSET4_CH(value uint32) {
	volatile.StoreUint32(&o.OFR4.Reg, volatile.LoadUint32(&o.OFR4.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetOFR4_OFFSET4_CH() uint32 {
	return (volatile.LoadUint32(&o.OFR4.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetOFR4_OFFSET4(value uint32) {
	volatile.StoreUint32(&o.OFR4.Reg, volatile.LoadUint32(&o.OFR4.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetOFR4_OFFSET4() uint32 {
	return volatile.LoadUint32(&o.OFR4.Reg) & 0xfff
}

// ADC.JDR1: injected data register 1
func (o *ADC_Type) SetJDR1_JDATA1(value uint32) {
	volatile.StoreUint32(&o.JDR1.Reg, volatile.LoadUint32(&o.JDR1.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR1_JDATA1() uint32 {
	return volatile.LoadUint32(&o.JDR1.Reg) & 0xffff
}

// ADC.JDR2: injected data register 2
func (o *ADC_Type) SetJDR2_JDATA2(value uint32) {
	volatile.StoreUint32(&o.JDR2.Reg, volatile.LoadUint32(&o.JDR2.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR2_JDATA2() uint32 {
	return volatile.LoadUint32(&o.JDR2.Reg) & 0xffff
}

// ADC.JDR3: injected data register 3
func (o *ADC_Type) SetJDR3_JDATA3(value uint32) {
	volatile.StoreUint32(&o.JDR3.Reg, volatile.LoadUint32(&o.JDR3.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR3_JDATA3() uint32 {
	return volatile.LoadUint32(&o.JDR3.Reg) & 0xffff
}

// ADC.JDR4: injected data register 4
func (o *ADC_Type) SetJDR4_JDATA4(value uint32) {
	volatile.StoreUint32(&o.JDR4.Reg, volatile.LoadUint32(&o.JDR4.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR4_JDATA4() uint32 {
	return volatile.LoadUint32(&o.JDR4.Reg) & 0xffff
}

// ADC.AWD2CR: Analog Watchdog 2 Configuration Register
func (o *ADC_Type) SetAWD2CR_AWD2CH(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x3ffff)|value)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH() uint32 {
	return volatile.LoadUint32(&o.AWD2CR.Reg) & 0x3ffff
}

// ADC.AWD3CR: Analog Watchdog 3 Configuration Register
func (o *ADC_Type) SetAWD3CR_AWD3CH(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x3ffff)|value)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH() uint32 {
	return volatile.LoadUint32(&o.AWD3CR.Reg) & 0x3ffff
}

// ADC.DIFSEL: Differential Mode Selection Register 2
func (o *ADC_Type) SetDIFSEL_DIFSEL_1_15(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0xfffe)|value<<1)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL_1_15() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0xfffe) >> 1
}
func (o *ADC_Type) SetDIFSEL_DIFSEL_16_18(value uint32) {
	volatile.StoreUint32(&o.DIFSEL.Reg, volatile.LoadUint32(&o.DIFSEL.Reg)&^(0x70000)|value<<16)
}
func (o *ADC_Type) GetDIFSEL_DIFSEL_16_18() uint32 {
	return (volatile.LoadUint32(&o.DIFSEL.Reg) & 0x70000) >> 16
}

// ADC.CALFACT: Calibration Factors
func (o *ADC_Type) SetCALFACT_CALFACT_D(value uint32) {
	volatile.StoreUint32(&o.CALFACT.Reg, volatile.LoadUint32(&o.CALFACT.Reg)&^(0x7f0000)|value<<16)
}
func (o *ADC_Type) GetCALFACT_CALFACT_D() uint32 {
	return (volatile.LoadUint32(&o.CALFACT.Reg) & 0x7f0000) >> 16
}
func (o *ADC_Type) SetCALFACT_CALFACT_S(value uint32) {
	volatile.StoreUint32(&o.CALFACT.Reg, volatile.LoadUint32(&o.CALFACT.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCALFACT_CALFACT_S() uint32 {
	return volatile.LoadUint32(&o.CALFACT.Reg) & 0x7f
}

// General-purpose I/Os
type GPIO_Type struct {
	MODER   volatile.Register32 // 0x0
	OTYPER  volatile.Register32 // 0x4
	OSPEEDR volatile.Register32 // 0x8
	PUPDR   volatile.Register32 // 0xC
	IDR     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	BSRR    volatile.Register32 // 0x18
	LCKR    volatile.Register32 // 0x1C
	AFRL    volatile.Register32 // 0x20
	AFRH    volatile.Register32 // 0x24
	BRR     volatile.Register32 // 0x28
	ASCR    volatile.Register32 // 0x2C
}

// GPIO.MODER: GPIO port mode register
func (o *GPIO_Type) SetMODER_MODER15(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetMODER_MODER15() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetMODER_MODER14(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetMODER_MODER14() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetMODER_MODER13(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetMODER_MODER13() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetMODER_MODER12(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetMODER_MODER12() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetMODER_MODER11(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetMODER_MODER11() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetMODER_MODER10(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetMODER_MODER10() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetMODER_MODER9(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetMODER_MODER9() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetMODER_MODER8(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetMODER_MODER8() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetMODER_MODER7(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetMODER_MODER7() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetMODER_MODER6(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetMODER_MODER6() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetMODER_MODER5(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetMODER_MODER5() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetMODER_MODER4(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetMODER_MODER4() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetMODER_MODER3(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetMODER_MODER3() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetMODER_MODER2(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetMODER_MODER2() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetMODER_MODER1(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetMODER_MODER1() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetMODER_MODER0(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetMODER_MODER0() uint32 {
	return volatile.LoadUint32(&o.MODER.Reg) & 0x3
}

// GPIO.OTYPER: GPIO port output type register
func (o *GPIO_Type) SetOTYPER_OT15(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOTYPER_OT15() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOTYPER_OT14(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOTYPER_OT14() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOTYPER_OT13(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOTYPER_OT13() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOTYPER_OT12(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOTYPER_OT12() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOTYPER_OT11(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOTYPER_OT11() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOTYPER_OT10(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOTYPER_OT10() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOTYPER_OT9(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOTYPER_OT9() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOTYPER_OT8(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOTYPER_OT8() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOTYPER_OT7(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOTYPER_OT7() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOTYPER_OT6(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOTYPER_OT6() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOTYPER_OT5(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOTYPER_OT5() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOTYPER_OT4(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOTYPER_OT4() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOTYPER_OT3(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOTYPER_OT3() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOTYPER_OT2(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOTYPER_OT2() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOTYPER_OT1(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOTYPER_OT1() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOTYPER_OT0(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOTYPER_OT0() uint32 {
	return volatile.LoadUint32(&o.OTYPER.Reg) & 0x1
}

// GPIO.OSPEEDR: GPIO port output speed register
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR15(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR15() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR14(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR14() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR13(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR13() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR12(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR12() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR11(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR11() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR10(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR10() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR9(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR9() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR8(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR8() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR7(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR7() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR6(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR6() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR5(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR5() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR4(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR4() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR3(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR3() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR2(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR2() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR1(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR1() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR0(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR0() uint32 {
	return volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3
}

// GPIO.PUPDR: GPIO port pull-up/pull-down register
func (o *GPIO_Type) SetPUPDR_PUPDR15(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetPUPDR_PUPDR15() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetPUPDR_PUPDR14(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetPUPDR_PUPDR14() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetPUPDR_PUPDR13(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetPUPDR_PUPDR13() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetPUPDR_PUPDR12(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetPUPDR_PUPDR12() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetPUPDR_PUPDR11(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetPUPDR_PUPDR11() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetPUPDR_PUPDR10(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetPUPDR_PUPDR10() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetPUPDR_PUPDR9(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetPUPDR_PUPDR9() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetPUPDR_PUPDR8(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPUPDR_PUPDR8() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetPUPDR_PUPDR7(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetPUPDR_PUPDR7() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetPUPDR_PUPDR6(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetPUPDR_PUPDR6() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetPUPDR_PUPDR5(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetPUPDR_PUPDR5() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetPUPDR_PUPDR4(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetPUPDR_PUPDR4() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetPUPDR_PUPDR3(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetPUPDR_PUPDR3() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetPUPDR_PUPDR2(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetPUPDR_PUPDR2() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetPUPDR_PUPDR1(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPUPDR_PUPDR1() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPUPDR_PUPDR0(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPUPDR_PUPDR0() uint32 {
	return volatile.LoadUint32(&o.PUPDR.Reg) & 0x3
}

// GPIO.IDR: GPIO port input data register
func (o *GPIO_Type) SetIDR_IDR15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIDR_IDR15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIDR_IDR14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIDR_IDR14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIDR_IDR13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIDR_IDR13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIDR_IDR12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIDR_IDR12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIDR_IDR11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIDR_IDR11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIDR_IDR10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIDR_IDR10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIDR_IDR9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIDR_IDR9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIDR_IDR8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIDR_IDR8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIDR_IDR7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIDR_IDR7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIDR_IDR6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIDR_IDR6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIDR_IDR5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIDR_IDR5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIDR_IDR4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIDR_IDR4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIDR_IDR3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIDR_IDR3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIDR_IDR2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIDR_IDR2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIDR_IDR1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIDR_IDR1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIDR_IDR0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIDR_IDR0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// GPIO.ODR: GPIO port output data register
func (o *GPIO_Type) SetODR_ODR15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetODR_ODR15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetODR_ODR14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetODR_ODR14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetODR_ODR13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetODR_ODR13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetODR_ODR12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetODR_ODR12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetODR_ODR11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetODR_ODR11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetODR_ODR10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetODR_ODR10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetODR_ODR9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetODR_ODR9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetODR_ODR8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetODR_ODR8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetODR_ODR7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetODR_ODR7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetODR_ODR6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetODR_ODR6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetODR_ODR5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetODR_ODR5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetODR_ODR4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetODR_ODR4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetODR_ODR3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetODR_ODR3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetODR_ODR2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetODR_ODR2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetODR_ODR1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetODR_ODR1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetODR_ODR0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetODR_ODR0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}

// GPIO.BSRR: GPIO port bit set/reset register
func (o *GPIO_Type) SetBSRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetBSRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000000) >> 31
}
func (o *GPIO_Type) SetBSRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetBSRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetBSRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetBSRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetBSRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetBSRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetBSRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetBSRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetBSRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetBSRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetBSRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetBSRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetBSRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetBSRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetBSRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetBSRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetBSRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetBSRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetBSRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetBSRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetBSRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetBSRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetBSRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetBSRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetBSRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetBSRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetBSRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetBSRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetBSRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetBSRR_BR0() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetBSRR_BS15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBSRR_BS15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetBSRR_BS14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBSRR_BS14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBSRR_BS13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBSRR_BS13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBSRR_BS12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBSRR_BS12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBSRR_BS11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBSRR_BS11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBSRR_BS10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBSRR_BS10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBSRR_BS9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBSRR_BS9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBSRR_BS8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBSRR_BS8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBSRR_BS7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBSRR_BS7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBSRR_BS6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBSRR_BS6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBSRR_BS5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBSRR_BS5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBSRR_BS4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBSRR_BS4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBSRR_BS3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBSRR_BS3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBSRR_BS2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBSRR_BS2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBSRR_BS1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBSRR_BS1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBSRR_BS0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBSRR_BS0() uint32 {
	return volatile.LoadUint32(&o.BSRR.Reg) & 0x1
}

// GPIO.LCKR: GPIO port configuration lock register
func (o *GPIO_Type) SetLCKR_LCKK(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLCKR_LCKK() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLCKR_LCK15(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLCKR_LCK15() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLCKR_LCK14(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLCKR_LCK14() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLCKR_LCK13(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLCKR_LCK13() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLCKR_LCK12(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLCKR_LCK12() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLCKR_LCK11(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLCKR_LCK11() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLCKR_LCK10(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLCKR_LCK10() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLCKR_LCK9(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLCKR_LCK9() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLCKR_LCK8(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLCKR_LCK8() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLCKR_LCK7(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLCKR_LCK7() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLCKR_LCK6(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLCKR_LCK6() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLCKR_LCK5(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLCKR_LCK5() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLCKR_LCK4(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLCKR_LCK4() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLCKR_LCK3(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLCKR_LCK3() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLCKR_LCK2(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLCKR_LCK2() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLCKR_LCK1(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLCKR_LCK1() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLCKR_LCK0(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLCKR_LCK0() uint32 {
	return volatile.LoadUint32(&o.LCKR.Reg) & 0x1
}

// GPIO.AFRL: GPIO alternate function low register
func (o *GPIO_Type) SetAFRL_AFRL7(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRL_AFRL7() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRL_AFRL6(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRL_AFRL6() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRL_AFRL5(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRL_AFRL5() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRL_AFRL4(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRL_AFRL4() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRL_AFRL3(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRL_AFRL3() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRL_AFRL2(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRL_AFRL2() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRL_AFRL1(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRL_AFRL1() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRL_AFRL0(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRL_AFRL0() uint32 {
	return volatile.LoadUint32(&o.AFRL.Reg) & 0xf
}

// GPIO.AFRH: GPIO alternate function high register
func (o *GPIO_Type) SetAFRH_AFRH15(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRH_AFRH15() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRH_AFRH14(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRH_AFRH14() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRH_AFRH13(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRH_AFRH13() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRH_AFRH12(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRH_AFRH12() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRH_AFRH11(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRH_AFRH11() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRH_AFRH10(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRH_AFRH10() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRH_AFRH9(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRH_AFRH9() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRH_AFRH8(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRH_AFRH8() uint32 {
	return volatile.LoadUint32(&o.AFRH.Reg) & 0xf
}

// GPIO.BRR: GPIO port bit reset register
func (o *GPIO_Type) SetBRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBRR_BR0() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0x1
}
func (o *GPIO_Type) SetBRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8000) >> 15
}

// GPIO.ASCR: GPIO port analog switch control register
func (o *GPIO_Type) SetASCR_ASC0(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetASCR_ASC0() uint32 {
	return volatile.LoadUint32(&o.ASCR.Reg) & 0x1
}
func (o *GPIO_Type) SetASCR_ASC1(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetASCR_ASC1() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetASCR_ASC2(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetASCR_ASC2() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetASCR_ASC3(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetASCR_ASC3() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetASCR_ASC4(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetASCR_ASC4() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetASCR_ASC5(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetASCR_ASC5() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetASCR_ASC6(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetASCR_ASC6() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetASCR_ASC7(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetASCR_ASC7() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetASCR_ASC8(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetASCR_ASC8() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetASCR_ASC9(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetASCR_ASC9() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetASCR_ASC10(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetASCR_ASC10() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetASCR_ASC11(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetASCR_ASC11() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetASCR_ASC12(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetASCR_ASC12() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetASCR_ASC13(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetASCR_ASC13() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetASCR_ASC14(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetASCR_ASC14() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetASCR_ASC15(value uint32) {
	volatile.StoreUint32(&o.ASCR.Reg, volatile.LoadUint32(&o.ASCR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetASCR_ASC15() uint32 {
	return (volatile.LoadUint32(&o.ASCR.Reg) & 0x8000) >> 15
}

// Serial audio interface
type SAI_Type struct {
	_  [4]byte
	CH [2]SAI_CH_Type // 0x4
}

// Cluster CH%s, containing ?CR1, ?CR2, ?FRCR, ?SLOTR, ?IM, ?SR, ?CLRFR, ?DR
type SAI_CH_Type struct {
	CR1   volatile.Register32 // 0x4
	CR2   volatile.Register32 // 0x8
	FRCR  volatile.Register32 // 0xC
	SLOTR volatile.Register32 // 0x10
	IM    volatile.Register32 // 0x14
	SR    volatile.Register32 // 0x18
	CLRFR volatile.Register32 // 0x1C
	DR    volatile.Register32 // 0x20
}

// SAI_CH.CR1: AConfiguration register 1
func (o *SAI_CH_Type) SetCR1_MCKDIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00000)|value<<20)
}
func (o *SAI_CH_Type) GetCR1_MCKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00000) >> 20
}
func (o *SAI_CH_Type) SetCR1_NODIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *SAI_CH_Type) GetCR1_NODIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *SAI_CH_Type) SetCR1_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *SAI_CH_Type) GetCR1_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *SAI_CH_Type) SetCR1_SAIEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *SAI_CH_Type) GetCR1_SAIEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *SAI_CH_Type) SetCR1_OUTDRIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SAI_CH_Type) GetCR1_OUTDRIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SAI_CH_Type) SetCR1_MONO(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SAI_CH_Type) GetCR1_MONO() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SAI_CH_Type) SetCR1_SYNCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc00)|value<<10)
}
func (o *SAI_CH_Type) GetCR1_SYNCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc00) >> 10
}
func (o *SAI_CH_Type) SetCR1_CKSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SAI_CH_Type) GetCR1_CKSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SAI_CH_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SAI_CH_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SAI_CH_Type) SetCR1_DS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xe0)|value<<5)
}
func (o *SAI_CH_Type) GetCR1_DS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xe0) >> 5
}
func (o *SAI_CH_Type) SetCR1_PRTCFG(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc)|value<<2)
}
func (o *SAI_CH_Type) GetCR1_PRTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc) >> 2
}
func (o *SAI_CH_Type) SetCR1_MODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3)|value)
}
func (o *SAI_CH_Type) GetCR1_MODE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x3
}

// SAI_CH.CR2: AConfiguration register 2
func (o *SAI_CH_Type) SetCR2_COMP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xc000)|value<<14)
}
func (o *SAI_CH_Type) GetCR2_COMP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xc000) >> 14
}
func (o *SAI_CH_Type) SetCR2_CPL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SAI_CH_Type) GetCR2_CPL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SAI_CH_Type) SetCR2_MUTECN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1f80)|value<<7)
}
func (o *SAI_CH_Type) GetCR2_MUTECN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1f80) >> 7
}
func (o *SAI_CH_Type) SetCR2_MUTEVAL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetCR2_MUTEVAL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetCR2_MUTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetCR2_MUTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetCR2_TRIS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetCR2_TRIS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetCR2_FFLUSH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetCR2_FFLUSH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetCR2_FTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x7)|value)
}
func (o *SAI_CH_Type) GetCR2_FTH() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x7
}

// SAI_CH.FRCR: AFRCR
func (o *SAI_CH_Type) SetFRCR_FSOFF(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x40000)|value<<18)
}
func (o *SAI_CH_Type) GetFRCR_FSOFF() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x40000) >> 18
}
func (o *SAI_CH_Type) SetFRCR_FSPOL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x20000)|value<<17)
}
func (o *SAI_CH_Type) GetFRCR_FSPOL() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x20000) >> 17
}
func (o *SAI_CH_Type) SetFRCR_FSDEF(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x10000)|value<<16)
}
func (o *SAI_CH_Type) GetFRCR_FSDEF() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x10000) >> 16
}
func (o *SAI_CH_Type) SetFRCR_FSALL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x7f00)|value<<8)
}
func (o *SAI_CH_Type) GetFRCR_FSALL() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x7f00) >> 8
}
func (o *SAI_CH_Type) SetFRCR_FRL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0xff)|value)
}
func (o *SAI_CH_Type) GetFRCR_FRL() uint32 {
	return volatile.LoadUint32(&o.FRCR.Reg) & 0xff
}

// SAI_CH.SLOTR: ASlot register
func (o *SAI_CH_Type) SetSLOTR_SLOTEN(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SAI_CH_Type) GetSLOTR_SLOTEN() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xffff0000) >> 16
}
func (o *SAI_CH_Type) SetSLOTR_NBSLOT(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xf00)|value<<8)
}
func (o *SAI_CH_Type) GetSLOTR_NBSLOT() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xf00) >> 8
}
func (o *SAI_CH_Type) SetSLOTR_SLOTSZ(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xc0)|value<<6)
}
func (o *SAI_CH_Type) GetSLOTR_SLOTSZ() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xc0) >> 6
}
func (o *SAI_CH_Type) SetSLOTR_FBOFF(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0x1f)|value)
}
func (o *SAI_CH_Type) GetSLOTR_FBOFF() uint32 {
	return volatile.LoadUint32(&o.SLOTR.Reg) & 0x1f
}

// SAI_CH.IM: AInterrupt mask register2
func (o *SAI_CH_Type) SetIM_LFSDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetIM_LFSDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetIM_AFSDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetIM_AFSDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetIM_CNRDYIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetIM_CNRDYIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetIM_FREQIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetIM_FREQIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetIM_WCKCFGIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetIM_WCKCFGIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetIM_MUTEDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetIM_MUTEDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetIM_OVRUDRIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetIM_OVRUDRIE() uint32 {
	return volatile.LoadUint32(&o.IM.Reg) & 0x1
}

// SAI_CH.SR: AStatus register
func (o *SAI_CH_Type) SetSR_FLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x70000)|value<<16)
}
func (o *SAI_CH_Type) GetSR_FLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x70000) >> 16
}
func (o *SAI_CH_Type) SetSR_LFSDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetSR_LFSDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetSR_AFSDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetSR_AFSDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetSR_CNRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetSR_CNRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetSR_FREQ(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetSR_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetSR_WCKCFG(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetSR_WCKCFG() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetSR_MUTEDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetSR_MUTEDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetSR_OVRUDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetSR_OVRUDR() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// SAI_CH.CLRFR: AClear flag register
func (o *SAI_CH_Type) SetCLRFR_CLFSDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetCLRFR_CLFSDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetCLRFR_CAFSDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetCLRFR_CAFSDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetCLRFR_CCNRDY(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetCLRFR_CCNRDY() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetCLRFR_CWCKCFG(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetCLRFR_CWCKCFG() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetCLRFR_CMUTEDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetCLRFR_CMUTEDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetCLRFR_COVRUDR(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetCLRFR_COVRUDR() uint32 {
	return volatile.LoadUint32(&o.CLRFR.Reg) & 0x1
}

// SAI_CH.DR: AData register
func (o *SAI_CH_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *SAI_CH_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// General-purpose-timers
type TIM_Type struct {
	CR1          volatile.Register32 // 0x0
	CR2          volatile.Register32 // 0x4
	SMCR         volatile.Register32 // 0x8
	DIER         volatile.Register32 // 0xC
	SR           volatile.Register32 // 0x10
	EGR          volatile.Register32 // 0x14
	CCMR1_Output volatile.Register32 // 0x18
	CCMR2_Output volatile.Register32 // 0x1C
	CCER         volatile.Register32 // 0x20
	CNT          volatile.Register32 // 0x24
	PSC          volatile.Register32 // 0x28
	ARR          volatile.Register32 // 0x2C
	_            [4]byte
	CCR1         volatile.Register32 // 0x34
	CCR2         volatile.Register32 // 0x38
	CCR3         volatile.Register32 // 0x3C
	CCR4         volatile.Register32 // 0x40
	_            [4]byte
	DCR          volatile.Register32 // 0x48
	DMAR         volatile.Register32 // 0x4C
	OR           volatile.Register32 // 0x50
}

// TIM.CR1: control register 1
func (o *TIM_Type) SetCR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR1_CMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x60)|value<<5)
}
func (o *TIM_Type) GetCR1_CMS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x60) >> 5
}
func (o *TIM_Type) SetCR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR1_URS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// TIM.CR2: control register 2
func (o *TIM_Type) SetCR2_TI1S(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR2_TI1S() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR2_MMS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCR2_MMS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}

// TIM.SMCR: slave mode control register
func (o *TIM_Type) SetSMCR_ETP(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetSMCR_ETP() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetSMCR_ECE(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetSMCR_ECE() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetSMCR_ETPS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x3000)|value<<12)
}
func (o *TIM_Type) GetSMCR_ETPS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x3000) >> 12
}
func (o *TIM_Type) SetSMCR_ETF(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetSMCR_ETF() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetSMCR_MSM(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSMCR_MSM() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSMCR_TS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetSMCR_TS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetSMCR_SMS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x7)|value)
}
func (o *TIM_Type) GetSMCR_SMS() uint32 {
	return volatile.LoadUint32(&o.SMCR.Reg) & 0x7
}

// TIM.DIER: DMA/Interrupt enable register
func (o *TIM_Type) SetDIER_TDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetDIER_TDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetDIER_COMDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetDIER_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetDIER_CC4DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetDIER_CC4DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetDIER_CC3DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetDIER_CC3DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetDIER_CC2DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetDIER_CC2DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetDIER_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetDIER_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetDIER_UDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetDIER_UDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetDIER_TIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetDIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetDIER_CC4IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetDIER_CC4IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetDIER_CC3IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetDIER_CC3IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetDIER_CC2IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetDIER_CC2IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetDIER_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetDIER_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetDIER_UIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetDIER_UIE() uint32 {
	return volatile.LoadUint32(&o.DIER.Reg) & 0x1
}

// TIM.SR: status register
func (o *TIM_Type) SetSR_CC4OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetSR_CC4OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetSR_CC3OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetSR_CC3OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetSR_CC2OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetSR_CC2OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetSR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetSR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetSR_TIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetSR_CC4IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetSR_CC4IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetSR_CC3IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetSR_CC3IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetSR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetSR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetSR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetSR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetSR_UIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetSR_UIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// TIM.EGR: event generation register
func (o *TIM_Type) SetEGR_TG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetEGR_TG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetEGR_CC4G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetEGR_CC4G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetEGR_CC3G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetEGR_CC3G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetEGR_CC2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetEGR_CC2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetEGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetEGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetEGR_UG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetEGR_UG() uint32 {
	return volatile.LoadUint32(&o.EGR.Reg) & 0x1
}

// TIM.CCMR1_Output: capture/compare mode register 1 (output mode)
func (o *TIM_Type) SetCCMR1_Output_OC2CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR1_Output_OC2CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR1_Output_OC2M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR1_Output_OC2PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR1_Output_OC2PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR1_Output_OC2FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR1_Output_OC2FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR1_Output_CC2S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR1_Output_CC2S() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR1_Output_OC1CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR1_Output_OC1CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x3
}
func (o *TIM_Type) SetCCMR1_Output_OC1M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR1_Output_OC2M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCMR2_Output: capture/compare mode register 2 (output mode)
func (o *TIM_Type) SetCCMR2_Output_OC4CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR2_Output_OC4CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR2_Output_OC4M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR2_Output_OC4PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR2_Output_OC4PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR2_Output_OC4FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR2_Output_OC4FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR2_Output_CC4S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR2_Output_CC4S() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR2_Output_OC3CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR2_Output_OC3CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR2_Output_OC3M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR2_Output_OC3PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR2_Output_OC3PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR2_Output_OC3FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR2_Output_OC3FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR2_Output_CC3S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR2_Output_CC3S() uint32 {
	return volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x3
}
func (o *TIM_Type) SetCCMR2_Output_OC3M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR2_Output_OC4M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCER: capture/compare enable register
func (o *TIM_Type) SetCCER_CC4NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCER_CC4NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCER_CC4P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCCER_CC4P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCCER_CC4E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCCER_CC4E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCCER_CC3NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCER_CC3NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCER_CC3P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCCER_CC3P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCCER_CC3E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCCER_CC3E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCCER_CC2NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCER_CC2NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCER_CC2P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetCCER_CC2P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetCCER_CC2E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCCER_CC2E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}

// TIM.CNT: counter
func (o *TIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, value)
}
func (o *TIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg)
}

// TIM.PSC: prescaler
func (o *TIM_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIM.ARR: auto-reload register
func (o *TIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, value)
}
func (o *TIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg)
}

// TIM.CCR1: capture/compare register
func (o *TIM_Type) SetCCR1(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, value)
}
func (o *TIM_Type) GetCCR1() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg)
}

// TIM.CCR2: capture/compare register
func (o *TIM_Type) SetCCR2(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, value)
}
func (o *TIM_Type) GetCCR2() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg)
}

// TIM.CCR3: capture/compare register
func (o *TIM_Type) SetCCR3(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, value)
}
func (o *TIM_Type) GetCCR3() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg)
}

// TIM.CCR4: capture/compare register
func (o *TIM_Type) SetCCR4(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, value)
}
func (o *TIM_Type) GetCCR4() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg)
}

// TIM.DCR: DMA control register
func (o *TIM_Type) SetDCR_DBL(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIM_Type) GetDCR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f00) >> 8
}
func (o *TIM_Type) SetDCR_DBA(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f)|value)
}
func (o *TIM_Type) GetDCR_DBA() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1f
}

// TIM.DMAR: DMA address for full transfer
func (o *TIM_Type) SetDMAR_DMAB(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, volatile.LoadUint32(&o.DMAR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetDMAR_DMAB() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg) & 0xffff
}

// TIM.OR: TIM2 option register
func (o *TIM_Type) SetOR_ETR_RMP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x7)|value)
}
func (o *TIM_Type) GetOR_ETR_RMP() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x7
}
func (o *TIM_Type) SetOR_TI4_RMP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x18)|value<<3)
}
func (o *TIM_Type) GetOR_TI4_RMP() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0x18) >> 3
}

// Low power timer
type LPTIM_Type struct {
	ISR  volatile.Register32 // 0x0
	ICR  volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	CFGR volatile.Register32 // 0xC
	CR   volatile.Register32 // 0x10
	CMP  volatile.Register32 // 0x14
	ARR  volatile.Register32 // 0x18
	CNT  volatile.Register32 // 0x1C
}

// LPTIM.ISR: Interrupt and Status Register
func (o *LPTIM_Type) SetISR_DOWN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetISR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetISR_UP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetISR_UP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetISR_ARROK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetISR_ARROK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetISR_CMPOK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetISR_CMPOK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetISR_EXTTRIG(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetISR_EXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetISR_ARRM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetISR_ARRM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetISR_CMPM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetISR_CMPM() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LPTIM.ICR: Interrupt Clear Register
func (o *LPTIM_Type) SetICR_DOWNCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetICR_DOWNCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetICR_UPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetICR_UPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetICR_ARROKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetICR_ARROKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetICR_CMPOKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetICR_CMPOKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetICR_EXTTRIGCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetICR_EXTTRIGCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetICR_ARRMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetICR_ARRMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetICR_CMPMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetICR_CMPMCF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LPTIM.IER: Interrupt Enable Register
func (o *LPTIM_Type) SetIER_DOWNIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetIER_DOWNIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetIER_UPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetIER_UPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetIER_ARROKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetIER_ARROKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetIER_CMPOKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetIER_CMPOKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetIER_EXTTRIGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetIER_EXTTRIGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetIER_ARRMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetIER_ARRMIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetIER_CMPMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetIER_CMPMIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LPTIM.CFGR: Configuration Register
func (o *LPTIM_Type) SetCFGR_ENC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPTIM_Type) GetCFGR_ENC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *LPTIM_Type) SetCFGR_COUNTMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *LPTIM_Type) GetCFGR_COUNTMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *LPTIM_Type) SetCFGR_PRELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *LPTIM_Type) GetCFGR_PRELOAD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *LPTIM_Type) SetCFGR_WAVPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *LPTIM_Type) GetCFGR_WAVPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *LPTIM_Type) SetCFGR_WAVE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *LPTIM_Type) GetCFGR_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *LPTIM_Type) SetCFGR_TIMOUT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000)|value<<19)
}
func (o *LPTIM_Type) GetCFGR_TIMOUT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000) >> 19
}
func (o *LPTIM_Type) SetCFGR_TRIGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x60000)|value<<17)
}
func (o *LPTIM_Type) GetCFGR_TRIGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x60000) >> 17
}
func (o *LPTIM_Type) SetCFGR_TRIGSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe000)|value<<13)
}
func (o *LPTIM_Type) GetCFGR_TRIGSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe000) >> 13
}
func (o *LPTIM_Type) SetCFGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe00)|value<<9)
}
func (o *LPTIM_Type) GetCFGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe00) >> 9
}
func (o *LPTIM_Type) SetCFGR_TRGFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc0)|value<<6)
}
func (o *LPTIM_Type) GetCFGR_TRGFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc0) >> 6
}
func (o *LPTIM_Type) SetCFGR_CKFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x18)|value<<3)
}
func (o *LPTIM_Type) GetCFGR_CKFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x18) >> 3
}
func (o *LPTIM_Type) SetCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x6)|value<<1)
}
func (o *LPTIM_Type) GetCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x6) >> 1
}
func (o *LPTIM_Type) SetCFGR_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCFGR_CKSEL() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x1
}

// LPTIM.CR: Control Register
func (o *LPTIM_Type) SetCR_CNTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetCR_CNTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetCR_SNGSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetCR_SNGSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// LPTIM.CMP: Compare Register
func (o *LPTIM_Type) SetCMP(value uint32) {
	volatile.StoreUint32(&o.CMP.Reg, volatile.LoadUint32(&o.CMP.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCMP() uint32 {
	return volatile.LoadUint32(&o.CMP.Reg) & 0xffff
}

// LPTIM.ARR: Autoreload Register
func (o *LPTIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// LPTIM.CNT: Counter Register
func (o *LPTIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// Universal synchronous asynchronous receiver transmitter
type USART_Type struct {
	CR1  volatile.Register32 // 0x0
	CR2  volatile.Register32 // 0x4
	CR3  volatile.Register32 // 0x8
	BRR  volatile.Register32 // 0xC
	GTPR volatile.Register32 // 0x10
	RTOR volatile.Register32 // 0x14
	RQR  volatile.Register32 // 0x18
	ISR  volatile.Register32 // 0x1C
	ICR  volatile.Register32 // 0x20
	RDR  volatile.Register32 // 0x24
	TDR  volatile.Register32 // 0x28
}

// USART.CR1: Control register 1
func (o *USART_Type) SetCR1_M1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR1_M1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR1_EOBIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetCR1_EOBIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetCR1_RTOIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetCR1_RTOIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetCR1_OVER8(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR1_OVER8() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR1_CMIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR1_CMIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR1_MME(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR1_MME() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR1_M0(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR1_M0() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR1_TE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR1_RE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR1_UESM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR1_UESM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR1_UE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR1_UE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *USART_Type) SetCR1_DEDT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *USART_Type) GetCR1_DEDT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1f0000) >> 16
}
func (o *USART_Type) SetCR1_DEAT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3e00000)|value<<21)
}
func (o *USART_Type) GetCR1_DEAT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3e00000) >> 21
}

// USART.CR2: Control register 2
func (o *USART_Type) SetCR2_RTOEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR2_RTOEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR2_ABREN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetCR2_ABREN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetCR2_MSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR2_MSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCR2_DATAINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR2_DATAINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR2_TXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetCR2_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetCR2_RXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetCR2_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetCR2_SWAP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR2_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR2_LINEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR2_LINEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR2_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR2_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR2_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR2_LBCL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR2_LBCL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR2_LBDIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR2_LBDIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR2_LBDL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR2_LBDL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR2_ADDM7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR2_ADDM7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR2_ADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetCR2_ADD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff000000) >> 24
}
func (o *USART_Type) SetCR2_ABRMOD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x600000)|value<<21)
}
func (o *USART_Type) GetCR2_ABRMOD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x600000) >> 21
}

// USART.CR3: Control register 3
func (o *USART_Type) SetCR3_WUFIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetCR3_WUFIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetCR3_WUS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x300000)|value<<20)
}
func (o *USART_Type) GetCR3_WUS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x300000) >> 20
}
func (o *USART_Type) SetCR3_SCARCNT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000)|value<<17)
}
func (o *USART_Type) GetCR3_SCARCNT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000) >> 17
}
func (o *USART_Type) SetCR3_DEP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR3_DEP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR3_DEM(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR3_DEM() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR3_DDRE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR3_DDRE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR3_OVRDIS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR3_OVRDIS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR3_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR3_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR3_SCEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR3_SCEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR3_NACK(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR3_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR3_IRLP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR3_IRLP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR3_IREN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR3_IREN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// USART.BRR: Baud rate register
func (o *USART_Type) SetBRR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xffff
}

// USART.GTPR: Guard time and prescaler register
func (o *USART_Type) SetGTPR_GT(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetGTPR_GT() uint32 {
	return (volatile.LoadUint32(&o.GTPR.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetGTPR_PSC(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetGTPR_PSC() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg) & 0xff
}

// USART.RTOR: Receiver timeout register
func (o *USART_Type) SetRTOR_BLEN(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetRTOR_BLEN() uint32 {
	return (volatile.LoadUint32(&o.RTOR.Reg) & 0xff000000) >> 24
}
func (o *USART_Type) SetRTOR_RTO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetRTOR_RTO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffffff
}

// USART.RQR: Request register
func (o *USART_Type) SetRQR_TXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetRQR_TXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetRQR_RXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetRQR_RXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetRQR_MMRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetRQR_MMRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetRQR_SBKRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetRQR_SBKRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetRQR_ABRRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetRQR_ABRRQ() uint32 {
	return volatile.LoadUint32(&o.RQR.Reg) & 0x1
}

// USART.ISR: Interrupt & status register
func (o *USART_Type) SetISR_REACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetISR_REACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetISR_TEACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetISR_TEACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetISR_WUF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetISR_WUF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetISR_RWU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetISR_RWU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetISR_SBKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetISR_SBKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetISR_CMF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetISR_CMF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetISR_ABRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetISR_ABRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetISR_ABRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetISR_ABRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetISR_EOBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetISR_EOBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetISR_RTOF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetISR_RTOF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetISR_CTS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetISR_CTS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetISR_CTSIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetISR_CTSIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetISR_LBDF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetISR_LBDF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetISR_IDLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetISR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetISR_ORE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetISR_ORE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetISR_NF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetISR_NF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetISR_FE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetISR_FE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetISR_PE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetISR_PE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// USART.ICR: Interrupt flag clear register
func (o *USART_Type) SetICR_WUCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetICR_WUCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetICR_CMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetICR_CMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetICR_EOBCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetICR_EOBCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetICR_RTOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetICR_RTOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetICR_CTSCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetICR_CTSCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetICR_LBDCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetICR_LBDCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetICR_TCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetICR_TCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetICR_IDLECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetICR_IDLECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetICR_ORECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetICR_ORECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetICR_NCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetICR_NCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetICR_FECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetICR_FECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetICR_PECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetICR_PECF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// USART.RDR: Receive data register
func (o *USART_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0x1ff
}

// USART.TDR: Transmit data register
func (o *USART_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0x1ff
}

// Serial peripheral interface/Inter-IC sound
type SPI_Type struct {
	CR1    volatile.Register32 // 0x0
	CR2    volatile.Register32 // 0x4
	SR     volatile.Register32 // 0x8
	DR     volatile.Register32 // 0xC
	CRCPR  volatile.Register32 // 0x10
	RXCRCR volatile.Register32 // 0x14
	TXCRCR volatile.Register32 // 0x18
}

// SPI.CR1: control register 1
func (o *SPI_Type) SetCR1_BIDIMODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCR1_BIDIMODE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCR1_BIDIOE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR1_BIDIOE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCR1_CRCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR1_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR1_CRCNEXT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR1_CRCNEXT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR1_DFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCR1_DFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetCR1_RXONLY(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCR1_RXONLY() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCR1_SSM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCR1_SSM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCR1_SSI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCR1_SSI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR1_SPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR1_SPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR1_BR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetCR1_BR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetCR1_MSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR1_MSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR1_CPHA() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// SPI.CR2: control register 2
func (o *SPI_Type) SetCR2_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR2_RXDMAEN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *SPI_Type) SetCR2_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR2_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR2_SSOE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR2_SSOE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR2_NSSP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCR2_NSSP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCR2_FRF(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetCR2_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetCR2_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCR2_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCR2_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR2_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR2_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR2_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR2_DS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCR2_DS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCR2_FRXTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR2_FRXTH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR2_LDMA_RX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR2_LDMA_RX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR2_LDMA_TX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR2_LDMA_TX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}

// SPI.SR: status register
func (o *SPI_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RXNE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TXE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TXE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_CRCERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSR_TIFRFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_TIFRFE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_FRLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x600)|value<<9)
}
func (o *SPI_Type) GetSR_FRLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x600) >> 9
}
func (o *SPI_Type) SetSR_FTLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1800)|value<<11)
}
func (o *SPI_Type) GetSR_FTLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1800) >> 11
}

// SPI.DR: data register
func (o *SPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// SPI.CRCPR: CRC polynomial register
func (o *SPI_Type) SetCRCPR_CRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPR.Reg, volatile.LoadUint32(&o.CRCPR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetCRCPR_CRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPR.Reg) & 0xffff
}

// SPI.RXCRCR: RX CRC register
func (o *SPI_Type) SetRXCRCR_RxCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRCR.Reg, volatile.LoadUint32(&o.RXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRXCRCR_RxCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRCR.Reg) & 0xffff
}

// SPI.TXCRCR: TX CRC register
func (o *SPI_Type) SetTXCRCR_TxCRC(value uint32) {
	volatile.StoreUint32(&o.TXCRCR.Reg, volatile.LoadUint32(&o.TXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXCRCR_TxCRC() uint32 {
	return volatile.LoadUint32(&o.TXCRCR.Reg) & 0xffff
}

// Secure digital input/output interface
type SDIO_Type struct {
	POWER   volatile.Register32 // 0x0
	CLKCR   volatile.Register32 // 0x4
	ARG     volatile.Register32 // 0x8
	CMD     volatile.Register32 // 0xC
	RESPCMD volatile.Register32 // 0x10
	RESP1   volatile.Register32 // 0x14
	RESP2   volatile.Register32 // 0x18
	RESP3   volatile.Register32 // 0x1C
	RESP4   volatile.Register32 // 0x20
	DTIMER  volatile.Register32 // 0x24
	DLEN    volatile.Register32 // 0x28
	DCTRL   volatile.Register32 // 0x2C
	DCOUNT  volatile.Register32 // 0x30
	STA     volatile.Register32 // 0x34
	ICR     volatile.Register32 // 0x38
	MASK    volatile.Register32 // 0x3C
	_       [8]byte
	FIFOCNT volatile.Register32 // 0x48
	_       [52]byte
	FIFO    volatile.Register32 // 0x80
}

// SDIO.POWER: power control register
func (o *SDIO_Type) SetPOWER_PWRCTRL(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x3)|value)
}
func (o *SDIO_Type) GetPOWER_PWRCTRL() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x3
}

// SDIO.CLKCR: SDI clock control register
func (o *SDIO_Type) SetCLKCR_HWFC_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x4000)|value<<14)
}
func (o *SDIO_Type) GetCLKCR_HWFC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x4000) >> 14
}
func (o *SDIO_Type) SetCLKCR_NEGEDGE(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x2000)|value<<13)
}
func (o *SDIO_Type) GetCLKCR_NEGEDGE() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x2000) >> 13
}
func (o *SDIO_Type) SetCLKCR_WIDBUS(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x1800)|value<<11)
}
func (o *SDIO_Type) GetCLKCR_WIDBUS() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x1800) >> 11
}
func (o *SDIO_Type) SetCLKCR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x400)|value<<10)
}
func (o *SDIO_Type) GetCLKCR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x400) >> 10
}
func (o *SDIO_Type) SetCLKCR_PWRSAV(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x200)|value<<9)
}
func (o *SDIO_Type) GetCLKCR_PWRSAV() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x200) >> 9
}
func (o *SDIO_Type) SetCLKCR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x100)|value<<8)
}
func (o *SDIO_Type) GetCLKCR_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x100) >> 8
}
func (o *SDIO_Type) SetCLKCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0xff)|value)
}
func (o *SDIO_Type) GetCLKCR_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKCR.Reg) & 0xff
}

// SDIO.ARG: argument register
func (o *SDIO_Type) SetARG(value uint32) {
	volatile.StoreUint32(&o.ARG.Reg, value)
}
func (o *SDIO_Type) GetARG() uint32 {
	return volatile.LoadUint32(&o.ARG.Reg)
}

// SDIO.CMD: command register
func (o *SDIO_Type) SetCMD_CE_ATACMD(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x4000)|value<<14)
}
func (o *SDIO_Type) GetCMD_CE_ATACMD() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x4000) >> 14
}
func (o *SDIO_Type) SetCMD_NIEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x2000)|value<<13)
}
func (o *SDIO_Type) GetCMD_NIEN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x2000) >> 13
}
func (o *SDIO_Type) SetCMD_ENCMDcompl(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x1000)|value<<12)
}
func (o *SDIO_Type) GetCMD_ENCMDcompl() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x1000) >> 12
}
func (o *SDIO_Type) SetCMD_SDIOSuspend(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x800)|value<<11)
}
func (o *SDIO_Type) GetCMD_SDIOSuspend() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x800) >> 11
}
func (o *SDIO_Type) SetCMD_CPSMEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x400)|value<<10)
}
func (o *SDIO_Type) GetCMD_CPSMEN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x400) >> 10
}
func (o *SDIO_Type) SetCMD_WAITPEND(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x200)|value<<9)
}
func (o *SDIO_Type) GetCMD_WAITPEND() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x200) >> 9
}
func (o *SDIO_Type) SetCMD_WAITINT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x100)|value<<8)
}
func (o *SDIO_Type) GetCMD_WAITINT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x100) >> 8
}
func (o *SDIO_Type) SetCMD_WAITRESP(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xc0)|value<<6)
}
func (o *SDIO_Type) GetCMD_WAITRESP() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xc0) >> 6
}
func (o *SDIO_Type) SetCMD_CMDINDEX(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3f)|value)
}
func (o *SDIO_Type) GetCMD_CMDINDEX() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x3f
}

// SDIO.RESPCMD: command response register
func (o *SDIO_Type) SetRESPCMD(value uint32) {
	volatile.StoreUint32(&o.RESPCMD.Reg, volatile.LoadUint32(&o.RESPCMD.Reg)&^(0x3f)|value)
}
func (o *SDIO_Type) GetRESPCMD() uint32 {
	return volatile.LoadUint32(&o.RESPCMD.Reg) & 0x3f
}

// SDIO.RESP1: response 1..4 register
func (o *SDIO_Type) SetRESP1(value uint32) {
	volatile.StoreUint32(&o.RESP1.Reg, value)
}
func (o *SDIO_Type) GetRESP1() uint32 {
	return volatile.LoadUint32(&o.RESP1.Reg)
}

// SDIO.RESP2: response 1..4 register
func (o *SDIO_Type) SetRESP2(value uint32) {
	volatile.StoreUint32(&o.RESP2.Reg, value)
}
func (o *SDIO_Type) GetRESP2() uint32 {
	return volatile.LoadUint32(&o.RESP2.Reg)
}

// SDIO.RESP3: response 1..4 register
func (o *SDIO_Type) SetRESP3(value uint32) {
	volatile.StoreUint32(&o.RESP3.Reg, value)
}
func (o *SDIO_Type) GetRESP3() uint32 {
	return volatile.LoadUint32(&o.RESP3.Reg)
}

// SDIO.RESP4: response 1..4 register
func (o *SDIO_Type) SetRESP4(value uint32) {
	volatile.StoreUint32(&o.RESP4.Reg, value)
}
func (o *SDIO_Type) GetRESP4() uint32 {
	return volatile.LoadUint32(&o.RESP4.Reg)
}

// SDIO.DTIMER: data timer register
func (o *SDIO_Type) SetDTIMER(value uint32) {
	volatile.StoreUint32(&o.DTIMER.Reg, value)
}
func (o *SDIO_Type) GetDTIMER() uint32 {
	return volatile.LoadUint32(&o.DTIMER.Reg)
}

// SDIO.DLEN: data length register
func (o *SDIO_Type) SetDLEN_DATALENGTH(value uint32) {
	volatile.StoreUint32(&o.DLEN.Reg, volatile.LoadUint32(&o.DLEN.Reg)&^(0x1ffffff)|value)
}
func (o *SDIO_Type) GetDLEN_DATALENGTH() uint32 {
	return volatile.LoadUint32(&o.DLEN.Reg) & 0x1ffffff
}

// SDIO.DCTRL: data control register
func (o *SDIO_Type) SetDCTRL_SDIOEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x800)|value<<11)
}
func (o *SDIO_Type) GetDCTRL_SDIOEN() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x800) >> 11
}
func (o *SDIO_Type) SetDCTRL_RWMOD(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x400)|value<<10)
}
func (o *SDIO_Type) GetDCTRL_RWMOD() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x400) >> 10
}
func (o *SDIO_Type) SetDCTRL_RWSTOP(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SDIO_Type) GetDCTRL_RWSTOP() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x200) >> 9
}
func (o *SDIO_Type) SetDCTRL_RWSTART(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SDIO_Type) GetDCTRL_RWSTART() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x100) >> 8
}
func (o *SDIO_Type) SetDCTRL_DBLOCKSIZE(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0xf0)|value<<4)
}
func (o *SDIO_Type) GetDCTRL_DBLOCKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0xf0) >> 4
}
func (o *SDIO_Type) SetDCTRL_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SDIO_Type) GetDCTRL_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x8) >> 3
}
func (o *SDIO_Type) SetDCTRL_DTMODE(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x4)|value<<2)
}
func (o *SDIO_Type) GetDCTRL_DTMODE() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x4) >> 2
}
func (o *SDIO_Type) SetDCTRL_DTDIR(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SDIO_Type) GetDCTRL_DTDIR() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x2) >> 1
}
func (o *SDIO_Type) SetDCTRL_DTEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x1)|value)
}
func (o *SDIO_Type) GetDCTRL_DTEN() uint32 {
	return volatile.LoadUint32(&o.DCTRL.Reg) & 0x1
}

// SDIO.DCOUNT: data counter register
func (o *SDIO_Type) SetDCOUNT_DATACOUNT(value uint32) {
	volatile.StoreUint32(&o.DCOUNT.Reg, volatile.LoadUint32(&o.DCOUNT.Reg)&^(0x1ffffff)|value)
}
func (o *SDIO_Type) GetDCOUNT_DATACOUNT() uint32 {
	return volatile.LoadUint32(&o.DCOUNT.Reg) & 0x1ffffff
}

// SDIO.STA: status register
func (o *SDIO_Type) SetSTA_CEATAEND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x800000)|value<<23)
}
func (o *SDIO_Type) GetSTA_CEATAEND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x800000) >> 23
}
func (o *SDIO_Type) SetSTA_SDIOIT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x400000)|value<<22)
}
func (o *SDIO_Type) GetSTA_SDIOIT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x400000) >> 22
}
func (o *SDIO_Type) SetSTA_RXDAVL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x200000)|value<<21)
}
func (o *SDIO_Type) GetSTA_RXDAVL() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x200000) >> 21
}
func (o *SDIO_Type) SetSTA_TXDAVL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x100000)|value<<20)
}
func (o *SDIO_Type) GetSTA_TXDAVL() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x100000) >> 20
}
func (o *SDIO_Type) SetSTA_RXFIFOE(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x80000)|value<<19)
}
func (o *SDIO_Type) GetSTA_RXFIFOE() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x80000) >> 19
}
func (o *SDIO_Type) SetSTA_TXFIFOE(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x40000)|value<<18)
}
func (o *SDIO_Type) GetSTA_TXFIFOE() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x40000) >> 18
}
func (o *SDIO_Type) SetSTA_RXFIFOF(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x20000)|value<<17)
}
func (o *SDIO_Type) GetSTA_RXFIFOF() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x20000) >> 17
}
func (o *SDIO_Type) SetSTA_TXFIFOF(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x10000)|value<<16)
}
func (o *SDIO_Type) GetSTA_TXFIFOF() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x10000) >> 16
}
func (o *SDIO_Type) SetSTA_RXFIFOHF(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x8000)|value<<15)
}
func (o *SDIO_Type) GetSTA_RXFIFOHF() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x8000) >> 15
}
func (o *SDIO_Type) SetSTA_TXFIFOHE(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x4000)|value<<14)
}
func (o *SDIO_Type) GetSTA_TXFIFOHE() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x4000) >> 14
}
func (o *SDIO_Type) SetSTA_RXACT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x2000)|value<<13)
}
func (o *SDIO_Type) GetSTA_RXACT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x2000) >> 13
}
func (o *SDIO_Type) SetSTA_TXACT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x1000)|value<<12)
}
func (o *SDIO_Type) GetSTA_TXACT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x1000) >> 12
}
func (o *SDIO_Type) SetSTA_CMDACT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x800)|value<<11)
}
func (o *SDIO_Type) GetSTA_CMDACT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x800) >> 11
}
func (o *SDIO_Type) SetSTA_DBCKEND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x400)|value<<10)
}
func (o *SDIO_Type) GetSTA_DBCKEND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x400) >> 10
}
func (o *SDIO_Type) SetSTA_STBITERR(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x200)|value<<9)
}
func (o *SDIO_Type) GetSTA_STBITERR() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x200) >> 9
}
func (o *SDIO_Type) SetSTA_DATAEND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x100)|value<<8)
}
func (o *SDIO_Type) GetSTA_DATAEND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x100) >> 8
}
func (o *SDIO_Type) SetSTA_CMDSENT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x80)|value<<7)
}
func (o *SDIO_Type) GetSTA_CMDSENT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x80) >> 7
}
func (o *SDIO_Type) SetSTA_CMDREND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x40)|value<<6)
}
func (o *SDIO_Type) GetSTA_CMDREND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x40) >> 6
}
func (o *SDIO_Type) SetSTA_RXOVERR(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x20)|value<<5)
}
func (o *SDIO_Type) GetSTA_RXOVERR() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x20) >> 5
}
func (o *SDIO_Type) SetSTA_TXUNDERR(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x10)|value<<4)
}
func (o *SDIO_Type) GetSTA_TXUNDERR() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x10) >> 4
}
func (o *SDIO_Type) SetSTA_DTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x8)|value<<3)
}
func (o *SDIO_Type) GetSTA_DTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x8) >> 3
}
func (o *SDIO_Type) SetSTA_CTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x4)|value<<2)
}
func (o *SDIO_Type) GetSTA_CTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x4) >> 2
}
func (o *SDIO_Type) SetSTA_DCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x2)|value<<1)
}
func (o *SDIO_Type) GetSTA_DCRCFAIL() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x2) >> 1
}
func (o *SDIO_Type) SetSTA_CCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x1)|value)
}
func (o *SDIO_Type) GetSTA_CCRCFAIL() uint32 {
	return volatile.LoadUint32(&o.STA.Reg) & 0x1
}

// SDIO.ICR: interrupt clear register
func (o *SDIO_Type) SetICR_CEATAENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800000)|value<<23)
}
func (o *SDIO_Type) GetICR_CEATAENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800000) >> 23
}
func (o *SDIO_Type) SetICR_SDIOITC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400000)|value<<22)
}
func (o *SDIO_Type) GetICR_SDIOITC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400000) >> 22
}
func (o *SDIO_Type) SetICR_DBCKENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *SDIO_Type) GetICR_DBCKENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *SDIO_Type) SetICR_STBITERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *SDIO_Type) GetICR_STBITERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *SDIO_Type) SetICR_DATAENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *SDIO_Type) GetICR_DATAENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *SDIO_Type) SetICR_CMDSENTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *SDIO_Type) GetICR_CMDSENTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *SDIO_Type) SetICR_CMDRENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *SDIO_Type) GetICR_CMDRENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *SDIO_Type) SetICR_RXOVERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *SDIO_Type) GetICR_RXOVERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *SDIO_Type) SetICR_TXUNDERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *SDIO_Type) GetICR_TXUNDERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *SDIO_Type) SetICR_DTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *SDIO_Type) GetICR_DTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *SDIO_Type) SetICR_CTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *SDIO_Type) GetICR_CTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *SDIO_Type) SetICR_DCRCFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SDIO_Type) GetICR_DCRCFAILC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SDIO_Type) SetICR_CCRCFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SDIO_Type) GetICR_CCRCFAILC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// SDIO.MASK: mask register
func (o *SDIO_Type) SetMASK_CEATAENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x800000)|value<<23)
}
func (o *SDIO_Type) GetMASK_CEATAENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x800000) >> 23
}
func (o *SDIO_Type) SetMASK_SDIOITIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x400000)|value<<22)
}
func (o *SDIO_Type) GetMASK_SDIOITIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x400000) >> 22
}
func (o *SDIO_Type) SetMASK_RXDAVLIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x200000)|value<<21)
}
func (o *SDIO_Type) GetMASK_RXDAVLIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x200000) >> 21
}
func (o *SDIO_Type) SetMASK_TXDAVLIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x100000)|value<<20)
}
func (o *SDIO_Type) GetMASK_TXDAVLIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x100000) >> 20
}
func (o *SDIO_Type) SetMASK_RXFIFOEIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x80000)|value<<19)
}
func (o *SDIO_Type) GetMASK_RXFIFOEIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x80000) >> 19
}
func (o *SDIO_Type) SetMASK_TXFIFOEIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x40000)|value<<18)
}
func (o *SDIO_Type) GetMASK_TXFIFOEIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x40000) >> 18
}
func (o *SDIO_Type) SetMASK_RXFIFOFIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x20000)|value<<17)
}
func (o *SDIO_Type) GetMASK_RXFIFOFIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x20000) >> 17
}
func (o *SDIO_Type) SetMASK_TXFIFOFIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x10000)|value<<16)
}
func (o *SDIO_Type) GetMASK_TXFIFOFIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x10000) >> 16
}
func (o *SDIO_Type) SetMASK_RXFIFOHFIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDIO_Type) GetMASK_RXFIFOHFIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x8000) >> 15
}
func (o *SDIO_Type) SetMASK_TXFIFOHEIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x4000)|value<<14)
}
func (o *SDIO_Type) GetMASK_TXFIFOHEIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x4000) >> 14
}
func (o *SDIO_Type) SetMASK_RXACTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x2000)|value<<13)
}
func (o *SDIO_Type) GetMASK_RXACTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x2000) >> 13
}
func (o *SDIO_Type) SetMASK_TXACTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x1000)|value<<12)
}
func (o *SDIO_Type) GetMASK_TXACTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x1000) >> 12
}
func (o *SDIO_Type) SetMASK_CMDACTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x800)|value<<11)
}
func (o *SDIO_Type) GetMASK_CMDACTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x800) >> 11
}
func (o *SDIO_Type) SetMASK_DBCKENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x400)|value<<10)
}
func (o *SDIO_Type) GetMASK_DBCKENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x400) >> 10
}
func (o *SDIO_Type) SetMASK_STBITERRIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x200)|value<<9)
}
func (o *SDIO_Type) GetMASK_STBITERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x200) >> 9
}
func (o *SDIO_Type) SetMASK_DATAENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x100)|value<<8)
}
func (o *SDIO_Type) GetMASK_DATAENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x100) >> 8
}
func (o *SDIO_Type) SetMASK_CMDSENTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x80)|value<<7)
}
func (o *SDIO_Type) GetMASK_CMDSENTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x80) >> 7
}
func (o *SDIO_Type) SetMASK_CMDRENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x40)|value<<6)
}
func (o *SDIO_Type) GetMASK_CMDRENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x40) >> 6
}
func (o *SDIO_Type) SetMASK_RXOVERRIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x20)|value<<5)
}
func (o *SDIO_Type) GetMASK_RXOVERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x20) >> 5
}
func (o *SDIO_Type) SetMASK_TXUNDERRIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x10)|value<<4)
}
func (o *SDIO_Type) GetMASK_TXUNDERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x10) >> 4
}
func (o *SDIO_Type) SetMASK_DTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x8)|value<<3)
}
func (o *SDIO_Type) GetMASK_DTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x8) >> 3
}
func (o *SDIO_Type) SetMASK_CTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x4)|value<<2)
}
func (o *SDIO_Type) GetMASK_CTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x4) >> 2
}
func (o *SDIO_Type) SetMASK_DCRCFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x2)|value<<1)
}
func (o *SDIO_Type) GetMASK_DCRCFAILIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x2) >> 1
}
func (o *SDIO_Type) SetMASK_CCRCFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x1)|value)
}
func (o *SDIO_Type) GetMASK_CCRCFAILIE() uint32 {
	return volatile.LoadUint32(&o.MASK.Reg) & 0x1
}

// SDIO.FIFOCNT: FIFO counter register
func (o *SDIO_Type) SetFIFOCNT_FIFOCOUNT(value uint32) {
	volatile.StoreUint32(&o.FIFOCNT.Reg, volatile.LoadUint32(&o.FIFOCNT.Reg)&^(0xffffff)|value)
}
func (o *SDIO_Type) GetFIFOCNT_FIFOCOUNT() uint32 {
	return volatile.LoadUint32(&o.FIFOCNT.Reg) & 0xffffff
}

// SDIO.FIFO: data FIFO register
func (o *SDIO_Type) SetFIFO(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, value)
}
func (o *SDIO_Type) GetFIFO() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg)
}

// External interrupt/event controller
type EXTI_Type struct {
	IMR1   volatile.Register32 // 0x0
	EMR1   volatile.Register32 // 0x4
	RTSR1  volatile.Register32 // 0x8
	FTSR1  volatile.Register32 // 0xC
	SWIER1 volatile.Register32 // 0x10
	PR1    volatile.Register32 // 0x14
	_      [8]byte
	IMR2   volatile.Register32 // 0x20
	EMR2   volatile.Register32 // 0x24
	RTSR2  volatile.Register32 // 0x28
	FTSR2  volatile.Register32 // 0x2C
	SWIER2 volatile.Register32 // 0x30
	PR2    volatile.Register32 // 0x34
}

// EXTI.IMR1: Interrupt mask register
func (o *EXTI_Type) SetIMR1_MR0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetIMR1_MR0() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetIMR1_MR1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetIMR1_MR1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetIMR1_MR2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetIMR1_MR2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetIMR1_MR3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetIMR1_MR3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetIMR1_MR4(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetIMR1_MR4() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetIMR1_MR5(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetIMR1_MR5() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetIMR1_MR6(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetIMR1_MR6() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetIMR1_MR7(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetIMR1_MR7() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetIMR1_MR8(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetIMR1_MR8() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetIMR1_MR9(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetIMR1_MR9() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetIMR1_MR10(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetIMR1_MR10() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetIMR1_MR11(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetIMR1_MR11() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetIMR1_MR12(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetIMR1_MR12() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetIMR1_MR13(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetIMR1_MR13() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetIMR1_MR14(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetIMR1_MR14() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetIMR1_MR15(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetIMR1_MR15() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetIMR1_MR16(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetIMR1_MR16() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetIMR1_MR17(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetIMR1_MR17() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetIMR1_MR18(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetIMR1_MR18() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetIMR1_MR19(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetIMR1_MR19() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetIMR1_MR20(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetIMR1_MR20() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetIMR1_MR21(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetIMR1_MR21() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetIMR1_MR22(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetIMR1_MR22() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetIMR1_MR23(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetIMR1_MR23() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetIMR1_MR24(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetIMR1_MR24() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetIMR1_MR25(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetIMR1_MR25() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetIMR1_MR26(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetIMR1_MR26() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetIMR1_MR27(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetIMR1_MR27() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetIMR1_MR28(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetIMR1_MR28() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetIMR1_MR29(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetIMR1_MR29() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetIMR1_MR30(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetIMR1_MR30() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetIMR1_MR31(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetIMR1_MR31() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000000) >> 31
}

// EXTI.EMR1: Event mask register
func (o *EXTI_Type) SetEMR1_MR0(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEMR1_MR0() uint32 {
	return volatile.LoadUint32(&o.EMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetEMR1_MR1(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEMR1_MR1() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetEMR1_MR2(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetEMR1_MR2() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetEMR1_MR3(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetEMR1_MR3() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetEMR1_MR4(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetEMR1_MR4() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetEMR1_MR5(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetEMR1_MR5() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetEMR1_MR6(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetEMR1_MR6() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetEMR1_MR7(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetEMR1_MR7() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetEMR1_MR8(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetEMR1_MR8() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetEMR1_MR9(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetEMR1_MR9() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetEMR1_MR10(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetEMR1_MR10() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetEMR1_MR11(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetEMR1_MR11() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetEMR1_MR12(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetEMR1_MR12() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetEMR1_MR13(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetEMR1_MR13() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetEMR1_MR14(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetEMR1_MR14() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetEMR1_MR15(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetEMR1_MR15() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetEMR1_MR16(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetEMR1_MR16() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetEMR1_MR17(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetEMR1_MR17() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetEMR1_MR18(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetEMR1_MR18() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetEMR1_MR19(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetEMR1_MR19() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetEMR1_MR20(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetEMR1_MR20() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetEMR1_MR21(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetEMR1_MR21() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetEMR1_MR22(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetEMR1_MR22() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetEMR1_MR23(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetEMR1_MR23() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetEMR1_MR24(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetEMR1_MR24() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetEMR1_MR25(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetEMR1_MR25() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetEMR1_MR26(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetEMR1_MR26() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetEMR1_MR27(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetEMR1_MR27() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetEMR1_MR28(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetEMR1_MR28() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetEMR1_MR29(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetEMR1_MR29() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetEMR1_MR30(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetEMR1_MR30() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetEMR1_MR31(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetEMR1_MR31() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80000000) >> 31
}

// EXTI.RTSR1: Rising Trigger selection register
func (o *EXTI_Type) SetRTSR1_TR0(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRTSR1_TR0() uint32 {
	return volatile.LoadUint32(&o.RTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetRTSR1_TR1(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRTSR1_TR1() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRTSR1_TR2(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTSR1_TR2() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTSR1_TR3(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTSR1_TR3() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTSR1_TR4(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTSR1_TR4() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTSR1_TR5(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTSR1_TR5() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTSR1_TR6(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTSR1_TR6() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRTSR1_TR7(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRTSR1_TR7() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRTSR1_TR8(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRTSR1_TR8() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRTSR1_TR9(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRTSR1_TR9() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetRTSR1_TR10(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetRTSR1_TR10() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetRTSR1_TR11(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetRTSR1_TR11() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetRTSR1_TR12(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetRTSR1_TR12() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetRTSR1_TR13(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRTSR1_TR13() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetRTSR1_TR14(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetRTSR1_TR14() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetRTSR1_TR15(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetRTSR1_TR15() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetRTSR1_TR16(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetRTSR1_TR16() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetRTSR1_TR18(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetRTSR1_TR18() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetRTSR1_TR19(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetRTSR1_TR19() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetRTSR1_TR20(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetRTSR1_TR20() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetRTSR1_TR21(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetRTSR1_TR21() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetRTSR1_TR22(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetRTSR1_TR22() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x400000) >> 22
}

// EXTI.FTSR1: Falling Trigger selection register
func (o *EXTI_Type) SetFTSR1_TR0(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFTSR1_TR0() uint32 {
	return volatile.LoadUint32(&o.FTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetFTSR1_TR1(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFTSR1_TR1() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFTSR1_TR2(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTSR1_TR2() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTSR1_TR3(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTSR1_TR3() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTSR1_TR4(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTSR1_TR4() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTSR1_TR5(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTSR1_TR5() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTSR1_TR6(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTSR1_TR6() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFTSR1_TR7(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFTSR1_TR7() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFTSR1_TR8(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFTSR1_TR8() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFTSR1_TR9(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFTSR1_TR9() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetFTSR1_TR10(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetFTSR1_TR10() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetFTSR1_TR11(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetFTSR1_TR11() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetFTSR1_TR12(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetFTSR1_TR12() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetFTSR1_TR13(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFTSR1_TR13() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetFTSR1_TR14(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetFTSR1_TR14() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetFTSR1_TR15(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetFTSR1_TR15() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetFTSR1_TR16(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetFTSR1_TR16() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetFTSR1_TR18(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetFTSR1_TR18() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetFTSR1_TR19(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetFTSR1_TR19() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetFTSR1_TR20(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetFTSR1_TR20() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetFTSR1_TR21(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetFTSR1_TR21() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetFTSR1_TR22(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetFTSR1_TR22() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x400000) >> 22
}

// EXTI.SWIER1: Software interrupt event register
func (o *EXTI_Type) SetSWIER1_SWIER0(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetSWIER1_SWIER0() uint32 {
	return volatile.LoadUint32(&o.SWIER1.Reg) & 0x1
}
func (o *EXTI_Type) SetSWIER1(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetSWIER1() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetSWIER1_SWIER2(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIER1_SWIER2() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIER1_SWIER3(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIER1_SWIER3() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIER1_SWIER4(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIER1_SWIER4() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIER1_SWIER5(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIER1_SWIER5() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIER1_SWIER6(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIER1_SWIER6() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetSWIER1_SWIER7(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetSWIER1_SWIER7() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetSWIER1_SWIER8(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetSWIER1_SWIER8() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetSWIER1_SWIER9(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetSWIER1_SWIER9() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetSWIER1_SWIER10(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetSWIER1_SWIER10() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetSWIER1_SWIER11(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetSWIER1_SWIER11() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetSWIER1_SWIER12(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetSWIER1_SWIER12() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetSWIER1_SWIER13(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetSWIER1_SWIER13() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetSWIER1_SWIER14(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetSWIER1_SWIER14() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetSWIER1_SWIER15(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetSWIER1_SWIER15() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetSWIER1_SWIER16(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetSWIER1_SWIER16() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetSWIER1_SWIER18(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetSWIER1_SWIER18() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetSWIER1_SWIER19(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetSWIER1_SWIER19() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetSWIER1_SWIER20(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetSWIER1_SWIER20() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetSWIER1_SWIER21(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetSWIER1_SWIER21() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetSWIER1_SWIER22(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetSWIER1_SWIER22() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x400000) >> 22
}

// EXTI.PR1: Pending register
func (o *EXTI_Type) SetPR1_PR0(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetPR1_PR0() uint32 {
	return volatile.LoadUint32(&o.PR1.Reg) & 0x1
}
func (o *EXTI_Type) SetPR1(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetPR1() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetPR1_PR2(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetPR1_PR2() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetPR1_PR3(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetPR1_PR3() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetPR1_PR4(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetPR1_PR4() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetPR1_PR5(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetPR1_PR5() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetPR1_PR6(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetPR1_PR6() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetPR1_PR7(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetPR1_PR7() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetPR1_PR8(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetPR1_PR8() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetPR1_PR9(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetPR1_PR9() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetPR1_PR10(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetPR1_PR10() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetPR1_PR11(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetPR1_PR11() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetPR1_PR12(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetPR1_PR12() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetPR1_PR13(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetPR1_PR13() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetPR1_PR14(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetPR1_PR14() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetPR1_PR15(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetPR1_PR15() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetPR1_PR16(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetPR1_PR16() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetPR1_PR18(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetPR1_PR18() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetPR1_PR19(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetPR1_PR19() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetPR1_PR20(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetPR1_PR20() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetPR1_PR21(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetPR1_PR21() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetPR1_PR22(value uint32) {
	volatile.StoreUint32(&o.PR1.Reg, volatile.LoadUint32(&o.PR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetPR1_PR22() uint32 {
	return (volatile.LoadUint32(&o.PR1.Reg) & 0x400000) >> 22
}

// EXTI.IMR2: Interrupt mask register
func (o *EXTI_Type) SetIMR2_MR32(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetIMR2_MR32() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *EXTI_Type) SetIMR2_MR33(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetIMR2_MR33() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetIMR2_MR34(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetIMR2_MR34() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetIMR2_MR35(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetIMR2_MR35() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetIMR2_MR36(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetIMR2_MR36() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetIMR2_MR37(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetIMR2_MR37() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetIMR2_MR38(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetIMR2_MR38() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetIMR2_MR39(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetIMR2_MR39() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80) >> 7
}

// EXTI.EMR2: Event mask register
func (o *EXTI_Type) SetEMR2_MR32(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEMR2_MR32() uint32 {
	return volatile.LoadUint32(&o.EMR2.Reg) & 0x1
}
func (o *EXTI_Type) SetEMR2_MR33(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEMR2_MR33() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetEMR2_MR34(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetEMR2_MR34() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetEMR2_MR35(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetEMR2_MR35() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetEMR2_MR36(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetEMR2_MR36() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetEMR2_MR37(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetEMR2_MR37() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetEMR2_MR38(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetEMR2_MR38() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetEMR2_MR39(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetEMR2_MR39() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x80) >> 7
}

// EXTI.RTSR2: Rising Trigger selection register
func (o *EXTI_Type) SetRTSR2_RT35(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTSR2_RT35() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTSR2_RT36(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTSR2_RT36() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTSR2_RT37(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTSR2_RT37() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTSR2_RT38(value uint32) {
	volatile.StoreUint32(&o.RTSR2.Reg, volatile.LoadUint32(&o.RTSR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTSR2_RT38() uint32 {
	return (volatile.LoadUint32(&o.RTSR2.Reg) & 0x40) >> 6
}

// EXTI.FTSR2: Falling Trigger selection register
func (o *EXTI_Type) SetFTSR2_FT35(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTSR2_FT35() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTSR2_FT36(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTSR2_FT36() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTSR2_FT37(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTSR2_FT37() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTSR2_FT38(value uint32) {
	volatile.StoreUint32(&o.FTSR2.Reg, volatile.LoadUint32(&o.FTSR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTSR2_FT38() uint32 {
	return (volatile.LoadUint32(&o.FTSR2.Reg) & 0x40) >> 6
}

// EXTI.SWIER2: Software interrupt event register
func (o *EXTI_Type) SetSWIER2_SWI35(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIER2_SWI35() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIER2_SWI36(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIER2_SWI36() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIER2_SWI37(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIER2_SWI37() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIER2_SWI38(value uint32) {
	volatile.StoreUint32(&o.SWIER2.Reg, volatile.LoadUint32(&o.SWIER2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIER2_SWI38() uint32 {
	return (volatile.LoadUint32(&o.SWIER2.Reg) & 0x40) >> 6
}

// EXTI.PR2: Pending register
func (o *EXTI_Type) SetPR2_PIF35(value uint32) {
	volatile.StoreUint32(&o.PR2.Reg, volatile.LoadUint32(&o.PR2.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetPR2_PIF35() uint32 {
	return (volatile.LoadUint32(&o.PR2.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetPR2_PIF36(value uint32) {
	volatile.StoreUint32(&o.PR2.Reg, volatile.LoadUint32(&o.PR2.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetPR2_PIF36() uint32 {
	return (volatile.LoadUint32(&o.PR2.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetPR2_PIF37(value uint32) {
	volatile.StoreUint32(&o.PR2.Reg, volatile.LoadUint32(&o.PR2.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetPR2_PIF37() uint32 {
	return (volatile.LoadUint32(&o.PR2.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetPR2_PIF38(value uint32) {
	volatile.StoreUint32(&o.PR2.Reg, volatile.LoadUint32(&o.PR2.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetPR2_PIF38() uint32 {
	return (volatile.LoadUint32(&o.PR2.Reg) & 0x40) >> 6
}

// Voltage reference buffer
type VREF_Type struct {
	CSR volatile.Register32 // 0x0
	CCR volatile.Register32 // 0x4
}

// VREF.CSR: VREF control and status register
func (o *VREF_Type) SetCSR_ENVR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *VREF_Type) GetCSR_ENVR() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *VREF_Type) SetCSR_HIZ(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *VREF_Type) GetCSR_HIZ() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *VREF_Type) SetCSR_VRS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *VREF_Type) GetCSR_VRS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *VREF_Type) SetCSR_VRR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *VREF_Type) GetCSR_VRR() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}

// VREF.CCR: calibration control register
func (o *VREF_Type) SetCCR_TRIM(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3f)|value)
}
func (o *VREF_Type) GetCCR_TRIM() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x3f
}

// Controller area network
type CAN_Type struct {
	MCR   volatile.Register32 // 0x0
	MSR   volatile.Register32 // 0x4
	TSR   volatile.Register32 // 0x8
	RF0R  volatile.Register32 // 0xC
	RF1R  volatile.Register32 // 0x10
	IER   volatile.Register32 // 0x14
	ESR   volatile.Register32 // 0x18
	BTR   volatile.Register32 // 0x1C
	_     [352]byte
	TX    [3]CAN_TX_Type // 0x180
	RX    [2]CAN_RX_Type // 0x1B0
	_     [48]byte
	FMR   volatile.Register32 // 0x200
	FM1R  volatile.Register32 // 0x204
	_     [4]byte
	FS1R  volatile.Register32 // 0x20C
	_     [4]byte
	FFA1R volatile.Register32 // 0x214
	_     [4]byte
	FA1R  volatile.Register32 // 0x21C
	_     [32]byte
	FB    [28]CAN_FB_Type // 0x240
}

// CAN.MCR: master control register
func (o *CAN_Type) SetMCR_DBF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetMCR_DBF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetMCR_RESET(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetMCR_RESET() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetMCR_TTCM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetMCR_TTCM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetMCR_ABOM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetMCR_ABOM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetMCR_AWUM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetMCR_AWUM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetMCR_NART(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetMCR_NART() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetMCR_RFLM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetMCR_RFLM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetMCR_TXFP(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetMCR_TXFP() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetMCR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetMCR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetMCR_INRQ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetMCR_INRQ() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}

// CAN.MSR: master status register
func (o *CAN_Type) SetMSR_RX(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetMSR_RX() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetMSR_SAMP(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetMSR_SAMP() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetMSR_RXM(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetMSR_RXM() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetMSR_TXM(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetMSR_TXM() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetMSR_SLAKI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetMSR_SLAKI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetMSR_WKUI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetMSR_WKUI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetMSR_ERRI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetMSR_ERRI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetMSR_SLAK(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetMSR_SLAK() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetMSR_INAK(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetMSR_INAK() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}

// CAN.TSR: transmit status register
func (o *CAN_Type) SetTSR_LOW2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetTSR_LOW2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80000000) >> 31
}
func (o *CAN_Type) SetTSR_LOW1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetTSR_LOW1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetTSR_LOW0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetTSR_LOW0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetTSR_TME2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetTSR_TME2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetTSR_TME1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetTSR_TME1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetTSR_TME0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetTSR_TME0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetTSR_CODE(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x3000000)|value<<24)
}
func (o *CAN_Type) GetTSR_CODE() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x3000000) >> 24
}
func (o *CAN_Type) SetTSR_ABRQ2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetTSR_ABRQ2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetTSR_TERR2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetTSR_TERR2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetTSR_ALST2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetTSR_ALST2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetTSR_TXOK2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetTSR_TXOK2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetTSR_RQCP2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetTSR_RQCP2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetTSR_ABRQ1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetTSR_ABRQ1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetTSR_TERR1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetTSR_TERR1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetTSR_ALST1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetTSR_ALST1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetTSR_TXOK1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetTSR_TXOK1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetTSR_RQCP1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetTSR_RQCP1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetTSR_ABRQ0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetTSR_ABRQ0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetTSR_TERR0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetTSR_TERR0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetTSR_ALST0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetTSR_ALST0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetTSR_TXOK0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetTSR_TXOK0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetTSR_RQCP0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetTSR_RQCP0() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}

// CAN.RF0R: receive FIFO %s register
func (o *CAN_Type) SetRF0R_RFOM(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRF0R_RFOM() uint32 {
	return (volatile.LoadUint32(&o.RF0R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRF0R_FOVR(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRF0R_FOVR() uint32 {
	return (volatile.LoadUint32(&o.RF0R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRF0R_FULL(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRF0R_FULL() uint32 {
	return (volatile.LoadUint32(&o.RF0R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRF0R_FMP(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x3)|value)
}
func (o *CAN_Type) GetRF0R_FMP() uint32 {
	return volatile.LoadUint32(&o.RF0R.Reg) & 0x3
}

// CAN.RF1R: receive FIFO %s register
func (o *CAN_Type) SetRF1R_RFOM(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRF1R_RFOM() uint32 {
	return (volatile.LoadUint32(&o.RF1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRF1R_FOVR(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRF1R_FOVR() uint32 {
	return (volatile.LoadUint32(&o.RF1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRF1R_FULL(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRF1R_FULL() uint32 {
	return (volatile.LoadUint32(&o.RF1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRF1R_FMP(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x3)|value)
}
func (o *CAN_Type) GetRF1R_FMP() uint32 {
	return volatile.LoadUint32(&o.RF1R.Reg) & 0x3
}

// CAN.IER: interrupt enable register
func (o *CAN_Type) SetIER_SLKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIER_SLKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIER_WKUIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIER_WKUIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIER_ERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetIER_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetIER_LECIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetIER_LECIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetIER_BOFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetIER_BOFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetIER_EPVIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetIER_EPVIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetIER_EWGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetIER_EWGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetIER_FOVIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIER_FOVIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIER_FFIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIER_FFIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIER_FMPIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIER_FMPIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIER_FOVIE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIER_FOVIE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIER_FFIE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIER_FFIE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIER_FMPIE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIER_FMPIE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIER_TMEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIER_TMEIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// CAN.ESR: interrupt enable register
func (o *CAN_Type) SetESR_REC(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetESR_REC() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0xff000000) >> 24
}
func (o *CAN_Type) SetESR_TEC(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetESR_TEC() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetESR_LEC(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x70)|value<<4)
}
func (o *CAN_Type) GetESR_LEC() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x70) >> 4
}
func (o *CAN_Type) SetESR_BOFF(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetESR_BOFF() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetESR_EPVF(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetESR_EPVF() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetESR_EWGF(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetESR_EWGF() uint32 {
	return volatile.LoadUint32(&o.ESR.Reg) & 0x1
}

// CAN.BTR: bit timing register
func (o *CAN_Type) SetBTR_SILM(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetBTR_SILM() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x80000000) >> 31
}
func (o *CAN_Type) SetBTR_LBKM(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetBTR_LBKM() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetBTR_SJW(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x3000000)|value<<24)
}
func (o *CAN_Type) GetBTR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x3000000) >> 24
}
func (o *CAN_Type) SetBTR_TS2(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x700000)|value<<20)
}
func (o *CAN_Type) GetBTR_TS2() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x700000) >> 20
}
func (o *CAN_Type) SetBTR_TS1(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetBTR_TS1() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetBTR_BRP(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x3ff)|value)
}
func (o *CAN_Type) GetBTR_BRP() uint32 {
	return volatile.LoadUint32(&o.BTR.Reg) & 0x3ff
}

// CAN.FMR: filter master register
func (o *CAN_Type) SetFMR_FINIT(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFMR_FINIT() uint32 {
	return volatile.LoadUint32(&o.FMR.Reg) & 0x1
}
func (o *CAN_Type) SetFMR_CANSB(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0x3f00)|value<<8)
}
func (o *CAN_Type) GetFMR_CANSB() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0x3f00) >> 8
}

// CAN.FM1R: filter mode register
func (o *CAN_Type) SetFM1R_FBM0(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFM1R_FBM0() uint32 {
	return volatile.LoadUint32(&o.FM1R.Reg) & 0x1
}
func (o *CAN_Type) SetFM1R_FBM1(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFM1R_FBM1() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFM1R_FBM2(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFM1R_FBM2() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFM1R_FBM3(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFM1R_FBM3() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFM1R_FBM4(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFM1R_FBM4() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFM1R_FBM5(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFM1R_FBM5() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFM1R_FBM6(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFM1R_FBM6() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFM1R_FBM7(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFM1R_FBM7() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFM1R_FBM8(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFM1R_FBM8() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFM1R_FBM9(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFM1R_FBM9() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFM1R_FBM10(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFM1R_FBM10() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFM1R_FBM11(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFM1R_FBM11() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFM1R_FBM12(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFM1R_FBM12() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFM1R_FBM13(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFM1R_FBM13() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFM1R_FBM14(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFM1R_FBM14() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFM1R_FBM15(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFM1R_FBM15() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFM1R_FBM16(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFM1R_FBM16() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFM1R_FBM17(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFM1R_FBM17() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFM1R_FBM18(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFM1R_FBM18() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFM1R_FBM19(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFM1R_FBM19() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFM1R_FBM20(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFM1R_FBM20() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFM1R_FBM21(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFM1R_FBM21() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFM1R_FBM22(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFM1R_FBM22() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFM1R_FBM23(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFM1R_FBM23() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFM1R_FBM24(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFM1R_FBM24() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFM1R_FBM25(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFM1R_FBM25() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFM1R_FBM26(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFM1R_FBM26() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFM1R_FBM27(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFM1R_FBM27() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x8000000) >> 27
}

// CAN.FS1R: filter scale register
func (o *CAN_Type) SetFS1R_FSC0(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFS1R_FSC0() uint32 {
	return volatile.LoadUint32(&o.FS1R.Reg) & 0x1
}
func (o *CAN_Type) SetFS1R_FSC1(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFS1R_FSC1() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFS1R_FSC2(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFS1R_FSC2() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFS1R_FSC3(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFS1R_FSC3() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFS1R_FSC4(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFS1R_FSC4() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFS1R_FSC5(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFS1R_FSC5() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFS1R_FSC6(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFS1R_FSC6() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFS1R_FSC7(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFS1R_FSC7() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFS1R_FSC8(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFS1R_FSC8() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFS1R_FSC9(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFS1R_FSC9() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFS1R_FSC10(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFS1R_FSC10() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFS1R_FSC11(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFS1R_FSC11() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFS1R_FSC12(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFS1R_FSC12() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFS1R_FSC13(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFS1R_FSC13() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFS1R_FSC14(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFS1R_FSC14() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFS1R_FSC15(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFS1R_FSC15() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFS1R_FSC16(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFS1R_FSC16() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFS1R_FSC17(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFS1R_FSC17() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFS1R_FSC18(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFS1R_FSC18() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFS1R_FSC19(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFS1R_FSC19() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFS1R_FSC20(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFS1R_FSC20() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFS1R_FSC21(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFS1R_FSC21() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFS1R_FSC22(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFS1R_FSC22() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFS1R_FSC23(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFS1R_FSC23() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFS1R_FSC24(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFS1R_FSC24() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFS1R_FSC25(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFS1R_FSC25() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFS1R_FSC26(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFS1R_FSC26() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFS1R_FSC27(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFS1R_FSC27() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x8000000) >> 27
}

// CAN.FFA1R: filter FIFO assignment register
func (o *CAN_Type) SetFFA1R_FFA0(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFFA1R_FFA0() uint32 {
	return volatile.LoadUint32(&o.FFA1R.Reg) & 0x1
}
func (o *CAN_Type) SetFFA1R_FFA1(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFFA1R_FFA1() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFFA1R_FFA2(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFFA1R_FFA2() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFFA1R_FFA3(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFFA1R_FFA3() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFFA1R_FFA4(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFFA1R_FFA4() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFFA1R_FFA5(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFFA1R_FFA5() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFFA1R_FFA6(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFFA1R_FFA6() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFFA1R_FFA7(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFFA1R_FFA7() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFFA1R_FFA8(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFFA1R_FFA8() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFFA1R_FFA9(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFFA1R_FFA9() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFFA1R_FFA10(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFFA1R_FFA10() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFFA1R_FFA11(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFFA1R_FFA11() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFFA1R_FFA12(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFFA1R_FFA12() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFFA1R_FFA13(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFFA1R_FFA13() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFFA1R_FFA14(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFFA1R_FFA14() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFFA1R_FFA15(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFFA1R_FFA15() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFFA1R_FFA16(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFFA1R_FFA16() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFFA1R_FFA17(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFFA1R_FFA17() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFFA1R_FFA18(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFFA1R_FFA18() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFFA1R_FFA19(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFFA1R_FFA19() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFFA1R_FFA20(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFFA1R_FFA20() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFFA1R_FFA21(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFFA1R_FFA21() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFFA1R_FFA22(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFFA1R_FFA22() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFFA1R_FFA23(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFFA1R_FFA23() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFFA1R_FFA24(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFFA1R_FFA24() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFFA1R_FFA25(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFFA1R_FFA25() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFFA1R_FFA26(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFFA1R_FFA26() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFFA1R_FFA27(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFFA1R_FFA27() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x8000000) >> 27
}

// CAN.FA1R: filter activation register
func (o *CAN_Type) SetFA1R_FACT0(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFA1R_FACT0() uint32 {
	return volatile.LoadUint32(&o.FA1R.Reg) & 0x1
}
func (o *CAN_Type) SetFA1R_FACT1(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFA1R_FACT1() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFA1R_FACT2(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFA1R_FACT2() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFA1R_FACT3(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFA1R_FACT3() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFA1R_FACT4(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFA1R_FACT4() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFA1R_FACT5(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFA1R_FACT5() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFA1R_FACT6(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFA1R_FACT6() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFA1R_FACT7(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFA1R_FACT7() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFA1R_FACT8(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFA1R_FACT8() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFA1R_FACT9(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFA1R_FACT9() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFA1R_FACT10(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFA1R_FACT10() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFA1R_FACT11(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFA1R_FACT11() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFA1R_FACT12(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFA1R_FACT12() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFA1R_FACT13(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFA1R_FACT13() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFA1R_FACT14(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFA1R_FACT14() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFA1R_FACT15(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFA1R_FACT15() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFA1R_FACT16(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFA1R_FACT16() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFA1R_FACT17(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFA1R_FACT17() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFA1R_FACT18(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFA1R_FACT18() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFA1R_FACT19(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFA1R_FACT19() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFA1R_FACT20(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFA1R_FACT20() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFA1R_FACT21(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFA1R_FACT21() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFA1R_FACT22(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFA1R_FACT22() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFA1R_FACT23(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFA1R_FACT23() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFA1R_FACT24(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFA1R_FACT24() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFA1R_FACT25(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFA1R_FACT25() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFA1R_FACT26(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFA1R_FACT26() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFA1R_FACT27(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFA1R_FACT27() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x8000000) >> 27
}

// CAN Transmit cluster
type CAN_TX_Type struct {
	TIR  volatile.Register32 // 0x180
	TDTR volatile.Register32 // 0x184
	TDLR volatile.Register32 // 0x188
	TDHR volatile.Register32 // 0x18C
}

// CAN_TX.TIR: TX mailbox identifier register
func (o *CAN_TX_Type) SetTIR_STID(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0xffe00000)|value<<21)
}
func (o *CAN_TX_Type) GetTIR_STID() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0xffe00000) >> 21
}
func (o *CAN_TX_Type) SetTIR_EXID(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x1ffff8)|value<<3)
}
func (o *CAN_TX_Type) GetTIR_EXID() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0x1ffff8) >> 3
}
func (o *CAN_TX_Type) SetTIR_IDE(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_TX_Type) GetTIR_IDE() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0x4) >> 2
}
func (o *CAN_TX_Type) SetTIR_RTR(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_TX_Type) GetTIR_RTR() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0x2) >> 1
}
func (o *CAN_TX_Type) SetTIR_TXRQ(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x1)|value)
}
func (o *CAN_TX_Type) GetTIR_TXRQ() uint32 {
	return volatile.LoadUint32(&o.TIR.Reg) & 0x1
}

// CAN_TX.TDTR: mailbox data length control and time stamp register
func (o *CAN_TX_Type) SetTDTR_TIME(value uint32) {
	volatile.StoreUint32(&o.TDTR.Reg, volatile.LoadUint32(&o.TDTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CAN_TX_Type) GetTDTR_TIME() uint32 {
	return (volatile.LoadUint32(&o.TDTR.Reg) & 0xffff0000) >> 16
}
func (o *CAN_TX_Type) SetTDTR_TGT(value uint32) {
	volatile.StoreUint32(&o.TDTR.Reg, volatile.LoadUint32(&o.TDTR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_TX_Type) GetTDTR_TGT() uint32 {
	return (volatile.LoadUint32(&o.TDTR.Reg) & 0x100) >> 8
}
func (o *CAN_TX_Type) SetTDTR_DLC(value uint32) {
	volatile.StoreUint32(&o.TDTR.Reg, volatile.LoadUint32(&o.TDTR.Reg)&^(0xf)|value)
}
func (o *CAN_TX_Type) GetTDTR_DLC() uint32 {
	return volatile.LoadUint32(&o.TDTR.Reg) & 0xf
}

// CAN_TX.TDLR: mailbox data low register
func (o *CAN_TX_Type) SetTDLR_DATA3(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_TX_Type) GetTDLR_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TDLR.Reg) & 0xff000000) >> 24
}
func (o *CAN_TX_Type) SetTDLR_DATA2(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_TX_Type) GetTDLR_DATA2() uint32 {
	return (volatile.LoadUint32(&o.TDLR.Reg) & 0xff0000) >> 16
}
func (o *CAN_TX_Type) SetTDLR_DATA1(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_TX_Type) GetTDLR_DATA1() uint32 {
	return (volatile.LoadUint32(&o.TDLR.Reg) & 0xff00) >> 8
}
func (o *CAN_TX_Type) SetTDLR_DATA0(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff)|value)
}
func (o *CAN_TX_Type) GetTDLR_DATA0() uint32 {
	return volatile.LoadUint32(&o.TDLR.Reg) & 0xff
}

// CAN_TX.TDHR: mailbox data high register
func (o *CAN_TX_Type) SetTDHR_DATA7(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_TX_Type) GetTDHR_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TDHR.Reg) & 0xff000000) >> 24
}
func (o *CAN_TX_Type) SetTDHR_DATA6(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_TX_Type) GetTDHR_DATA6() uint32 {
	return (volatile.LoadUint32(&o.TDHR.Reg) & 0xff0000) >> 16
}
func (o *CAN_TX_Type) SetTDHR_DATA5(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_TX_Type) GetTDHR_DATA5() uint32 {
	return (volatile.LoadUint32(&o.TDHR.Reg) & 0xff00) >> 8
}
func (o *CAN_TX_Type) SetTDHR_DATA4(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff)|value)
}
func (o *CAN_TX_Type) GetTDHR_DATA4() uint32 {
	return volatile.LoadUint32(&o.TDHR.Reg) & 0xff
}

// CAN Receive cluster
type CAN_RX_Type struct {
	RIR  volatile.Register32 // 0x1B0
	RDTR volatile.Register32 // 0x1B4
	RDLR volatile.Register32 // 0x1B8
	RDHR volatile.Register32 // 0x1BC
}

// CAN_RX.RIR: receive FIFO mailbox identifier register
func (o *CAN_RX_Type) SetRIR_STID(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0xffe00000)|value<<21)
}
func (o *CAN_RX_Type) GetRIR_STID() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0xffe00000) >> 21
}
func (o *CAN_RX_Type) SetRIR_EXID(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0x1ffff8)|value<<3)
}
func (o *CAN_RX_Type) GetRIR_EXID() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0x1ffff8) >> 3
}
func (o *CAN_RX_Type) SetRIR_IDE(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_RX_Type) GetRIR_IDE() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0x4) >> 2
}
func (o *CAN_RX_Type) SetRIR_RTR(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_RX_Type) GetRIR_RTR() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0x2) >> 1
}

// CAN_RX.RDTR: mailbox data high register
func (o *CAN_RX_Type) SetRDTR_TIME(value uint32) {
	volatile.StoreUint32(&o.RDTR.Reg, volatile.LoadUint32(&o.RDTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CAN_RX_Type) GetRDTR_TIME() uint32 {
	return (volatile.LoadUint32(&o.RDTR.Reg) & 0xffff0000) >> 16
}
func (o *CAN_RX_Type) SetRDTR_FMI(value uint32) {
	volatile.StoreUint32(&o.RDTR.Reg, volatile.LoadUint32(&o.RDTR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_RX_Type) GetRDTR_FMI() uint32 {
	return (volatile.LoadUint32(&o.RDTR.Reg) & 0xff00) >> 8
}
func (o *CAN_RX_Type) SetRDTR_DLC(value uint32) {
	volatile.StoreUint32(&o.RDTR.Reg, volatile.LoadUint32(&o.RDTR.Reg)&^(0xf)|value)
}
func (o *CAN_RX_Type) GetRDTR_DLC() uint32 {
	return volatile.LoadUint32(&o.RDTR.Reg) & 0xf
}

// CAN_RX.RDLR: mailbox data high register
func (o *CAN_RX_Type) SetRDLR_DATA3(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_RX_Type) GetRDLR_DATA3() uint32 {
	return (volatile.LoadUint32(&o.RDLR.Reg) & 0xff000000) >> 24
}
func (o *CAN_RX_Type) SetRDLR_DATA2(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_RX_Type) GetRDLR_DATA2() uint32 {
	return (volatile.LoadUint32(&o.RDLR.Reg) & 0xff0000) >> 16
}
func (o *CAN_RX_Type) SetRDLR_DATA1(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_RX_Type) GetRDLR_DATA1() uint32 {
	return (volatile.LoadUint32(&o.RDLR.Reg) & 0xff00) >> 8
}
func (o *CAN_RX_Type) SetRDLR_DATA0(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff)|value)
}
func (o *CAN_RX_Type) GetRDLR_DATA0() uint32 {
	return volatile.LoadUint32(&o.RDLR.Reg) & 0xff
}

// CAN_RX.RDHR: receive FIFO mailbox data high register
func (o *CAN_RX_Type) SetRDHR_DATA7(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_RX_Type) GetRDHR_DATA7() uint32 {
	return (volatile.LoadUint32(&o.RDHR.Reg) & 0xff000000) >> 24
}
func (o *CAN_RX_Type) SetRDHR_DATA6(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_RX_Type) GetRDHR_DATA6() uint32 {
	return (volatile.LoadUint32(&o.RDHR.Reg) & 0xff0000) >> 16
}
func (o *CAN_RX_Type) SetRDHR_DATA5(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_RX_Type) GetRDHR_DATA5() uint32 {
	return (volatile.LoadUint32(&o.RDHR.Reg) & 0xff00) >> 8
}
func (o *CAN_RX_Type) SetRDHR_DATA4(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff)|value)
}
func (o *CAN_RX_Type) GetRDHR_DATA4() uint32 {
	return volatile.LoadUint32(&o.RDHR.Reg) & 0xff
}

// CAN Filter Bank cluster
type CAN_FB_Type struct {
	FR1 volatile.Register32 // 0x240
	FR2 volatile.Register32 // 0x244
}

// CAN_FB.FR1: Filter bank 0 register 1
func (o *CAN_FB_Type) SetFR1(value uint32) {
	volatile.StoreUint32(&o.FR1.Reg, value)
}
func (o *CAN_FB_Type) GetFR1() uint32 {
	return volatile.LoadUint32(&o.FR1.Reg)
}

// CAN_FB.FR2: Filter bank 0 register 2
func (o *CAN_FB_Type) SetFR2(value uint32) {
	volatile.StoreUint32(&o.FR2.Reg, value)
}
func (o *CAN_FB_Type) GetFR2() uint32 {
	return volatile.LoadUint32(&o.FR2.Reg)
}

// Real-time clock
type RTC_Type struct {
	TR       volatile.Register32 // 0x0
	DR       volatile.Register32 // 0x4
	CR       volatile.Register32 // 0x8
	ISR      volatile.Register32 // 0xC
	PRER     volatile.Register32 // 0x10
	WUTR     volatile.Register32 // 0x14
	_        [4]byte
	ALRMAR   volatile.Register32 // 0x1C
	ALRMBR   volatile.Register32 // 0x20
	WPR      volatile.Register32 // 0x24
	SSR      volatile.Register32 // 0x28
	SHIFTR   volatile.Register32 // 0x2C
	TSTR     volatile.Register32 // 0x30
	TSDR     volatile.Register32 // 0x34
	TSSSR    volatile.Register32 // 0x38
	CALR     volatile.Register32 // 0x3C
	TAMPCR   volatile.Register32 // 0x40
	ALRMASSR volatile.Register32 // 0x44
	ALRMBSSR volatile.Register32 // 0x48
	OR       volatile.Register32 // 0x4C
	BKP0R    volatile.Register32 // 0x50
	BKP1R    volatile.Register32 // 0x54
	BKP2R    volatile.Register32 // 0x58
	BKP3R    volatile.Register32 // 0x5C
	BKP4R    volatile.Register32 // 0x60
	BKP5R    volatile.Register32 // 0x64
	BKP6R    volatile.Register32 // 0x68
	BKP7R    volatile.Register32 // 0x6C
	BKP8R    volatile.Register32 // 0x70
	BKP9R    volatile.Register32 // 0x74
	BKP10R   volatile.Register32 // 0x78
	BKP11R   volatile.Register32 // 0x7C
	BKP12R   volatile.Register32 // 0x80
	BKP13R   volatile.Register32 // 0x84
	BKP14R   volatile.Register32 // 0x88
	BKP15R   volatile.Register32 // 0x8C
	BKP16R   volatile.Register32 // 0x90
	BKP17R   volatile.Register32 // 0x94
	BKP18R   volatile.Register32 // 0x98
	BKP19R   volatile.Register32 // 0x9C
	BKP20R   volatile.Register32 // 0xA0
	BKP21R   volatile.Register32 // 0xA4
	BKP22R   volatile.Register32 // 0xA8
	BKP23R   volatile.Register32 // 0xAC
	BKP24R   volatile.Register32 // 0xB0
	BKP25R   volatile.Register32 // 0xB4
	BKP26R   volatile.Register32 // 0xB8
	BKP27R   volatile.Register32 // 0xBC
	BKP28R   volatile.Register32 // 0xC0
	BKP29R   volatile.Register32 // 0xC4
	BKP30R   volatile.Register32 // 0xC8
	BKP31R   volatile.Register32 // 0xCC
}

// RTC.TR: time register
func (o *RTC_Type) SetTR_PM(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTR_HT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTR_HU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTR_ST(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTR_SU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTR_SU() uint32 {
	return volatile.LoadUint32(&o.TR.Reg) & 0xf
}

// RTC.DR: date register
func (o *RTC_Type) SetDR_YT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00000)|value<<20)
}
func (o *RTC_Type) GetDR_YT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00000) >> 20
}
func (o *RTC_Type) SetDR_YU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetDR_YU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetDR_WDU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetDR_MT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetDR_MT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetDR_MU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetDR_MU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetDR_DT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetDR_DT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetDR_DU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetDR_DU() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xf
}

// RTC.CR: control register
func (o *RTC_Type) SetCR_WUCKSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetCR_WUCKSEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7
}
func (o *RTC_Type) SetCR_TSEDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_TSEDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_REFCKON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_REFCKON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_BYPSHAD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCR_BYPSHAD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCR_FMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCR_FMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCR_ALRAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_ALRAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_ALRBE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_ALRBE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_WUTE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_WUTE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_TSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_TSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_ALRAIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_ALRAIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_ALRBIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_ALRBIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCR_WUTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCR_WUTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCR_TSIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCR_TSIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCR_ADD1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetCR_ADD1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetCR_SUB1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCR_SUB1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetCR_BKP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetCR_BKP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetCR_COSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetCR_COSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetCR_POL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetCR_POL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetCR_OSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_Type) GetCR_OSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *RTC_Type) SetCR_COE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCR_COE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCR_ITSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetCR_ITSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// RTC.ISR: initialization and status register
func (o *RTC_Type) SetISR_ALRAWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetISR_ALRAWF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *RTC_Type) SetISR_ALRBWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetISR_ALRBWF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetISR_WUTWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetISR_WUTWF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetISR_SHPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetISR_SHPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetISR_INITS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetISR_INITS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetISR_RSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetISR_RSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetISR_INITF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetISR_INITF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetISR_INIT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetISR_INIT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetISR_ALRAF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetISR_ALRAF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetISR_ALRBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetISR_ALRBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetISR_WUTF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetISR_WUTF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetISR_TSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetISR_TSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetISR_TSOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetISR_TSOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetISR_TAMP1F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetISR_TAMP1F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetISR_TAMP2F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetISR_TAMP2F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetISR_TAMP3F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetISR_TAMP3F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetISR_RECALPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetISR_RECALPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}

// RTC.PRER: prescaler register
func (o *RTC_Type) SetPRER_PREDIV_A(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7f0000)|value<<16)
}
func (o *RTC_Type) GetPRER_PREDIV_A() uint32 {
	return (volatile.LoadUint32(&o.PRER.Reg) & 0x7f0000) >> 16
}
func (o *RTC_Type) SetPRER_PREDIV_S(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetPRER_PREDIV_S() uint32 {
	return volatile.LoadUint32(&o.PRER.Reg) & 0x7fff
}

// RTC.WUTR: wakeup timer register
func (o *RTC_Type) SetWUTR_WUT(value uint32) {
	volatile.StoreUint32(&o.WUTR.Reg, volatile.LoadUint32(&o.WUTR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetWUTR_WUT() uint32 {
	return volatile.LoadUint32(&o.WUTR.Reg) & 0xffff
}

// RTC.ALRMAR: alarm A register
func (o *RTC_Type) SetALRMAR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMAR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMAR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMAR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMAR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMAR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMAR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMAR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMAR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMAR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMAR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMAR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMAR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMAR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMAR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMAR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMAR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMAR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMAR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMAR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMAR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMAR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMAR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMAR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMAR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMAR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMAR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMAR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf
}

// RTC.ALRMBR: alarm B register
func (o *RTC_Type) SetALRMBR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMBR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMBR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMBR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMBR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMBR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMBR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMBR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMBR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMBR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMBR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMBR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMBR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMBR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMBR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMBR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMBR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMBR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMBR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMBR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMBR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMBR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMBR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMBR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMBR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMBR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf
}

// RTC.WPR: write protection register
func (o *RTC_Type) SetWPR_KEY(value uint32) {
	volatile.StoreUint32(&o.WPR.Reg, volatile.LoadUint32(&o.WPR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetWPR_KEY() uint32 {
	return volatile.LoadUint32(&o.WPR.Reg) & 0xff
}

// RTC.SSR: sub second register
func (o *RTC_Type) SetSSR_SS(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetSSR_SS() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0xffff
}

// RTC.SHIFTR: shift control register
func (o *RTC_Type) SetSHIFTR_ADD1S(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSHIFTR_ADD1S() uint32 {
	return (volatile.LoadUint32(&o.SHIFTR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetSHIFTR_SUBFS(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetSHIFTR_SUBFS() uint32 {
	return volatile.LoadUint32(&o.SHIFTR.Reg) & 0x7fff
}

// RTC.TSTR: time stamp time register
func (o *RTC_Type) SetTSTR_SU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSTR_SU() uint32 {
	return volatile.LoadUint32(&o.TSTR.Reg) & 0xf
}
func (o *RTC_Type) SetTSTR_ST(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTSTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTSTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTSTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTSTR_HU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTSTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTSTR_HT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTSTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTSTR_PM(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTSTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x400000) >> 22
}

// RTC.TSDR: time stamp date register
func (o *RTC_Type) SetTSDR_WDU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetTSDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetTSDR_MT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetTSDR_MT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetTSDR_MU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSDR_MU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSDR_DT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetTSDR_DT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetTSDR_DU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSDR_DU() uint32 {
	return volatile.LoadUint32(&o.TSDR.Reg) & 0xf
}

// RTC.TSSSR: timestamp sub second register
func (o *RTC_Type) SetTSSSR_SS(value uint32) {
	volatile.StoreUint32(&o.TSSSR.Reg, volatile.LoadUint32(&o.TSSSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetTSSSR_SS() uint32 {
	return volatile.LoadUint32(&o.TSSSR.Reg) & 0xffff
}

// RTC.CALR: calibration register
func (o *RTC_Type) SetCALR_CALP(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCALR_CALP() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCALR_CALW8(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCALR_CALW8() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCALR_CALW16(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCALR_CALW16() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCALR_CALM(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetCALR_CALM() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x1ff
}

// RTC.TAMPCR: tamper configuration register
func (o *RTC_Type) SetTAMPCR_TAMP1E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTAMPCR_TAMP1E() uint32 {
	return volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1
}
func (o *RTC_Type) SetTAMPCR_TAMP1TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetTAMPCR_TAMP1TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetTAMPCR_TAMPIE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetTAMPCR_TAMPIE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetTAMPCR_TAMP2E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetTAMPCR_TAMP2E() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetTAMPCR_TAMP2TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetTAMPCR_TAMP2TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetTAMPCR_TAMP3E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetTAMPCR_TAMP3E() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetTAMPCR_TAMP3TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetTAMPCR_TAMP3TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetTAMPCR_TAMPTS(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetTAMPCR_TAMPTS() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetTAMPCR_TAMPFREQ(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x700)|value<<8)
}
func (o *RTC_Type) GetTAMPCR_TAMPFREQ() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x700) >> 8
}
func (o *RTC_Type) SetTAMPCR_TAMPFLT(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1800)|value<<11)
}
func (o *RTC_Type) GetTAMPCR_TAMPFLT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1800) >> 11
}
func (o *RTC_Type) SetTAMPCR_TAMPPRCH(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x6000)|value<<13)
}
func (o *RTC_Type) GetTAMPCR_TAMPPRCH() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x6000) >> 13
}
func (o *RTC_Type) SetTAMPCR_TAMPPUDIS(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetTAMPCR_TAMPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetTAMPCR_TAMP1IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetTAMPCR_TAMP1IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetTAMPCR_TAMP1NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetTAMPCR_TAMP1NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetTAMPCR_TAMP1MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetTAMPCR_TAMP1MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetTAMPCR_TAMP2IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetTAMPCR_TAMP2IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetTAMPCR_TAMP2NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetTAMPCR_TAMP2NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetTAMPCR_TAMP2MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_Type) GetTAMPCR_TAMP2MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x200000) >> 21
}
func (o *RTC_Type) SetTAMPCR_TAMP3IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTAMPCR_TAMP3IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTAMPCR_TAMP3NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetTAMPCR_TAMP3NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetTAMPCR_TAMP3MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetTAMPCR_TAMP3MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1000000) >> 24
}

// RTC.ALRMASSR: alarm A sub second register
func (o *RTC_Type) SetALRMASSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMASSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMASSR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMASSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMASSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x7fff
}

// RTC.ALRMBSSR: alarm B sub second register
func (o *RTC_Type) SetALRMBSSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBSSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBSSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMBSSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x7fff
}

// RTC.OR: option register
func (o *RTC_Type) SetOR_RTC_ALARM_TYPE(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetOR_RTC_ALARM_TYPE() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x1
}
func (o *RTC_Type) SetOR_RTC_OUT_RMP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetOR_RTC_OUT_RMP() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0x2) >> 1
}

// RTC.BKP0R: backup register
func (o *RTC_Type) SetBKP0R(value uint32) {
	volatile.StoreUint32(&o.BKP0R.Reg, value)
}
func (o *RTC_Type) GetBKP0R() uint32 {
	return volatile.LoadUint32(&o.BKP0R.Reg)
}

// RTC.BKP1R: backup register
func (o *RTC_Type) SetBKP1R(value uint32) {
	volatile.StoreUint32(&o.BKP1R.Reg, value)
}
func (o *RTC_Type) GetBKP1R() uint32 {
	return volatile.LoadUint32(&o.BKP1R.Reg)
}

// RTC.BKP2R: backup register
func (o *RTC_Type) SetBKP2R(value uint32) {
	volatile.StoreUint32(&o.BKP2R.Reg, value)
}
func (o *RTC_Type) GetBKP2R() uint32 {
	return volatile.LoadUint32(&o.BKP2R.Reg)
}

// RTC.BKP3R: backup register
func (o *RTC_Type) SetBKP3R(value uint32) {
	volatile.StoreUint32(&o.BKP3R.Reg, value)
}
func (o *RTC_Type) GetBKP3R() uint32 {
	return volatile.LoadUint32(&o.BKP3R.Reg)
}

// RTC.BKP4R: backup register
func (o *RTC_Type) SetBKP4R(value uint32) {
	volatile.StoreUint32(&o.BKP4R.Reg, value)
}
func (o *RTC_Type) GetBKP4R() uint32 {
	return volatile.LoadUint32(&o.BKP4R.Reg)
}

// RTC.BKP5R: backup register
func (o *RTC_Type) SetBKP5R(value uint32) {
	volatile.StoreUint32(&o.BKP5R.Reg, value)
}
func (o *RTC_Type) GetBKP5R() uint32 {
	return volatile.LoadUint32(&o.BKP5R.Reg)
}

// RTC.BKP6R: backup register
func (o *RTC_Type) SetBKP6R(value uint32) {
	volatile.StoreUint32(&o.BKP6R.Reg, value)
}
func (o *RTC_Type) GetBKP6R() uint32 {
	return volatile.LoadUint32(&o.BKP6R.Reg)
}

// RTC.BKP7R: backup register
func (o *RTC_Type) SetBKP7R(value uint32) {
	volatile.StoreUint32(&o.BKP7R.Reg, value)
}
func (o *RTC_Type) GetBKP7R() uint32 {
	return volatile.LoadUint32(&o.BKP7R.Reg)
}

// RTC.BKP8R: backup register
func (o *RTC_Type) SetBKP8R(value uint32) {
	volatile.StoreUint32(&o.BKP8R.Reg, value)
}
func (o *RTC_Type) GetBKP8R() uint32 {
	return volatile.LoadUint32(&o.BKP8R.Reg)
}

// RTC.BKP9R: backup register
func (o *RTC_Type) SetBKP9R(value uint32) {
	volatile.StoreUint32(&o.BKP9R.Reg, value)
}
func (o *RTC_Type) GetBKP9R() uint32 {
	return volatile.LoadUint32(&o.BKP9R.Reg)
}

// RTC.BKP10R: backup register
func (o *RTC_Type) SetBKP10R(value uint32) {
	volatile.StoreUint32(&o.BKP10R.Reg, value)
}
func (o *RTC_Type) GetBKP10R() uint32 {
	return volatile.LoadUint32(&o.BKP10R.Reg)
}

// RTC.BKP11R: backup register
func (o *RTC_Type) SetBKP11R(value uint32) {
	volatile.StoreUint32(&o.BKP11R.Reg, value)
}
func (o *RTC_Type) GetBKP11R() uint32 {
	return volatile.LoadUint32(&o.BKP11R.Reg)
}

// RTC.BKP12R: backup register
func (o *RTC_Type) SetBKP12R(value uint32) {
	volatile.StoreUint32(&o.BKP12R.Reg, value)
}
func (o *RTC_Type) GetBKP12R() uint32 {
	return volatile.LoadUint32(&o.BKP12R.Reg)
}

// RTC.BKP13R: backup register
func (o *RTC_Type) SetBKP13R(value uint32) {
	volatile.StoreUint32(&o.BKP13R.Reg, value)
}
func (o *RTC_Type) GetBKP13R() uint32 {
	return volatile.LoadUint32(&o.BKP13R.Reg)
}

// RTC.BKP14R: backup register
func (o *RTC_Type) SetBKP14R(value uint32) {
	volatile.StoreUint32(&o.BKP14R.Reg, value)
}
func (o *RTC_Type) GetBKP14R() uint32 {
	return volatile.LoadUint32(&o.BKP14R.Reg)
}

// RTC.BKP15R: backup register
func (o *RTC_Type) SetBKP15R(value uint32) {
	volatile.StoreUint32(&o.BKP15R.Reg, value)
}
func (o *RTC_Type) GetBKP15R() uint32 {
	return volatile.LoadUint32(&o.BKP15R.Reg)
}

// RTC.BKP16R: backup register
func (o *RTC_Type) SetBKP16R(value uint32) {
	volatile.StoreUint32(&o.BKP16R.Reg, value)
}
func (o *RTC_Type) GetBKP16R() uint32 {
	return volatile.LoadUint32(&o.BKP16R.Reg)
}

// RTC.BKP17R: backup register
func (o *RTC_Type) SetBKP17R(value uint32) {
	volatile.StoreUint32(&o.BKP17R.Reg, value)
}
func (o *RTC_Type) GetBKP17R() uint32 {
	return volatile.LoadUint32(&o.BKP17R.Reg)
}

// RTC.BKP18R: backup register
func (o *RTC_Type) SetBKP18R(value uint32) {
	volatile.StoreUint32(&o.BKP18R.Reg, value)
}
func (o *RTC_Type) GetBKP18R() uint32 {
	return volatile.LoadUint32(&o.BKP18R.Reg)
}

// RTC.BKP19R: backup register
func (o *RTC_Type) SetBKP19R(value uint32) {
	volatile.StoreUint32(&o.BKP19R.Reg, value)
}
func (o *RTC_Type) GetBKP19R() uint32 {
	return volatile.LoadUint32(&o.BKP19R.Reg)
}

// RTC.BKP20R: backup register
func (o *RTC_Type) SetBKP20R(value uint32) {
	volatile.StoreUint32(&o.BKP20R.Reg, value)
}
func (o *RTC_Type) GetBKP20R() uint32 {
	return volatile.LoadUint32(&o.BKP20R.Reg)
}

// RTC.BKP21R: backup register
func (o *RTC_Type) SetBKP21R(value uint32) {
	volatile.StoreUint32(&o.BKP21R.Reg, value)
}
func (o *RTC_Type) GetBKP21R() uint32 {
	return volatile.LoadUint32(&o.BKP21R.Reg)
}

// RTC.BKP22R: backup register
func (o *RTC_Type) SetBKP22R(value uint32) {
	volatile.StoreUint32(&o.BKP22R.Reg, value)
}
func (o *RTC_Type) GetBKP22R() uint32 {
	return volatile.LoadUint32(&o.BKP22R.Reg)
}

// RTC.BKP23R: backup register
func (o *RTC_Type) SetBKP23R(value uint32) {
	volatile.StoreUint32(&o.BKP23R.Reg, value)
}
func (o *RTC_Type) GetBKP23R() uint32 {
	return volatile.LoadUint32(&o.BKP23R.Reg)
}

// RTC.BKP24R: backup register
func (o *RTC_Type) SetBKP24R(value uint32) {
	volatile.StoreUint32(&o.BKP24R.Reg, value)
}
func (o *RTC_Type) GetBKP24R() uint32 {
	return volatile.LoadUint32(&o.BKP24R.Reg)
}

// RTC.BKP25R: backup register
func (o *RTC_Type) SetBKP25R(value uint32) {
	volatile.StoreUint32(&o.BKP25R.Reg, value)
}
func (o *RTC_Type) GetBKP25R() uint32 {
	return volatile.LoadUint32(&o.BKP25R.Reg)
}

// RTC.BKP26R: backup register
func (o *RTC_Type) SetBKP26R(value uint32) {
	volatile.StoreUint32(&o.BKP26R.Reg, value)
}
func (o *RTC_Type) GetBKP26R() uint32 {
	return volatile.LoadUint32(&o.BKP26R.Reg)
}

// RTC.BKP27R: backup register
func (o *RTC_Type) SetBKP27R(value uint32) {
	volatile.StoreUint32(&o.BKP27R.Reg, value)
}
func (o *RTC_Type) GetBKP27R() uint32 {
	return volatile.LoadUint32(&o.BKP27R.Reg)
}

// RTC.BKP28R: backup register
func (o *RTC_Type) SetBKP28R(value uint32) {
	volatile.StoreUint32(&o.BKP28R.Reg, value)
}
func (o *RTC_Type) GetBKP28R() uint32 {
	return volatile.LoadUint32(&o.BKP28R.Reg)
}

// RTC.BKP29R: backup register
func (o *RTC_Type) SetBKP29R(value uint32) {
	volatile.StoreUint32(&o.BKP29R.Reg, value)
}
func (o *RTC_Type) GetBKP29R() uint32 {
	return volatile.LoadUint32(&o.BKP29R.Reg)
}

// RTC.BKP30R: backup register
func (o *RTC_Type) SetBKP30R(value uint32) {
	volatile.StoreUint32(&o.BKP30R.Reg, value)
}
func (o *RTC_Type) GetBKP30R() uint32 {
	return volatile.LoadUint32(&o.BKP30R.Reg)
}

// RTC.BKP31R: backup register
func (o *RTC_Type) SetBKP31R(value uint32) {
	volatile.StoreUint32(&o.BKP31R.Reg, value)
}
func (o *RTC_Type) GetBKP31R() uint32 {
	return volatile.LoadUint32(&o.BKP31R.Reg)
}

// USB on the go full speed
type USB_OTG_FS_Type struct {
	GOTGCTL        volatile.Register32 // 0x0
	GOTGINT        volatile.Register32 // 0x4
	GAHBCFG        volatile.Register32 // 0x8
	GUSBCFG        volatile.Register32 // 0xC
	GRSTCTL        volatile.Register32 // 0x10
	GINTSTS        volatile.Register32 // 0x14
	GINTMSK        volatile.Register32 // 0x18
	GRXSTSR_Device volatile.Register32 // 0x1C
	GRXSTSP_Device volatile.Register32 // 0x20
	GRXFSIZ        volatile.Register32 // 0x24
	DIEPTXF0       volatile.Register32 // 0x28
	GNPTXSTS       volatile.Register32 // 0x2C
	_              [8]byte
	GCCFG          volatile.Register32 // 0x38
	CID            volatile.Register32 // 0x3C
	_              [192]byte
	HPTXFSIZ       volatile.Register32 // 0x100
	DIEPTXF1       volatile.Register32 // 0x104
	DIEPTXF2       volatile.Register32 // 0x108
	DIEPTXF3       volatile.Register32 // 0x10C
}

// USB_OTG_FS.GOTGCTL: OTG_FS control and status register (OTG_FS_GOTGCTL)
func (o *USB_OTG_FS_Type) SetGOTGCTL_SRQSCS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_SRQSCS() uint32 {
	return volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_SRQ(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_SRQ() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_HNGSCS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_HNGSCS() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x100) >> 8
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_HNPRQ(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_HNPRQ() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x200) >> 9
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_HSHNPEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_HSHNPEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x400) >> 10
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_DHNPEN(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_DHNPEN() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x800) >> 11
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_CIDSTS(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_CIDSTS() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_DBCT(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_DBCT() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_ASVLD(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_ASVLD() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetGOTGCTL_BSVLD(value uint32) {
	volatile.StoreUint32(&o.GOTGCTL.Reg, volatile.LoadUint32(&o.GOTGCTL.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetGOTGCTL_BSVLD() uint32 {
	return (volatile.LoadUint32(&o.GOTGCTL.Reg) & 0x80000) >> 19
}

// USB_OTG_FS.GOTGINT: OTG_FS interrupt register (OTG_FS_GOTGINT)
func (o *USB_OTG_FS_Type) SetGOTGINT_SEDET(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetGOTGINT_SEDET() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetGOTGINT_SRSSCHG(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetGOTGINT_SRSSCHG() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x100) >> 8
}
func (o *USB_OTG_FS_Type) SetGOTGINT_HNSSCHG(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_FS_Type) GetGOTGINT_HNSSCHG() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x200) >> 9
}
func (o *USB_OTG_FS_Type) SetGOTGINT_HNGDET(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetGOTGINT_HNGDET() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetGOTGINT_ADTOCHG(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetGOTGINT_ADTOCHG() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetGOTGINT_DBCDNE(value uint32) {
	volatile.StoreUint32(&o.GOTGINT.Reg, volatile.LoadUint32(&o.GOTGINT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetGOTGINT_DBCDNE() uint32 {
	return (volatile.LoadUint32(&o.GOTGINT.Reg) & 0x80000) >> 19
}

// USB_OTG_FS.GAHBCFG: OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
func (o *USB_OTG_FS_Type) SetGAHBCFG_GINT(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetGAHBCFG_GINT() uint32 {
	return volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetGAHBCFG_TXFELVL(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetGAHBCFG_TXFELVL() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetGAHBCFG_PTXFELVL(value uint32) {
	volatile.StoreUint32(&o.GAHBCFG.Reg, volatile.LoadUint32(&o.GAHBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetGAHBCFG_PTXFELVL() uint32 {
	return (volatile.LoadUint32(&o.GAHBCFG.Reg) & 0x100) >> 8
}

// USB_OTG_FS.GUSBCFG: OTG_FS USB configuration register (OTG_FS_GUSBCFG)
func (o *USB_OTG_FS_Type) SetGUSBCFG_TOCAL(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x7)|value)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_TOCAL() uint32 {
	return volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x7
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_PHYSEL(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_PHYSEL() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_SRPCAP(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_SRPCAP() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x100) >> 8
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_HNPCAP(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_HNPCAP() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x200) >> 9
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_TRDT(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x3c00)|value<<10)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_TRDT() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x3c00) >> 10
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_FHMOD(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_FHMOD() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_FDMOD(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_FDMOD() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_FS_Type) SetGUSBCFG_CTXPKT(value uint32) {
	volatile.StoreUint32(&o.GUSBCFG.Reg, volatile.LoadUint32(&o.GUSBCFG.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetGUSBCFG_CTXPKT() uint32 {
	return (volatile.LoadUint32(&o.GUSBCFG.Reg) & 0x80000000) >> 31
}

// USB_OTG_FS.GRSTCTL: OTG_FS reset register (OTG_FS_GRSTCTL)
func (o *USB_OTG_FS_Type) SetGRSTCTL_CSRST(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_CSRST() uint32 {
	return volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetGRSTCTL_HSRST(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_HSRST() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetGRSTCTL_FCRST(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_FCRST() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetGRSTCTL_RXFFLSH(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_RXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetGRSTCTL_TXFFLSH(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_TXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetGRSTCTL_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x7c0)|value<<6)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x7c0) >> 6
}
func (o *USB_OTG_FS_Type) SetGRSTCTL_AHBIDL(value uint32) {
	volatile.StoreUint32(&o.GRSTCTL.Reg, volatile.LoadUint32(&o.GRSTCTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetGRSTCTL_AHBIDL() uint32 {
	return (volatile.LoadUint32(&o.GRSTCTL.Reg) & 0x80000000) >> 31
}

// USB_OTG_FS.GINTSTS: OTG_FS core interrupt register (OTG_FS_GINTSTS)
func (o *USB_OTG_FS_Type) SetGINTSTS_CMOD(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_CMOD() uint32 {
	return volatile.LoadUint32(&o.GINTSTS.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetGINTSTS_MMIS(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_MMIS() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetGINTSTS_OTGINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetGINTSTS_SOF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_SOF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x8) >> 3
}
func (o *USB_OTG_FS_Type) SetGINTSTS_RXFLVL(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_RXFLVL() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetGINTSTS_NPTXFE(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_NPTXFE() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetGINTSTS_GINAKEFF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_GINAKEFF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetGINTSTS_GOUTNAKEFF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_GOUTNAKEFF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetGINTSTS_ESUSP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_ESUSP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x400) >> 10
}
func (o *USB_OTG_FS_Type) SetGINTSTS_USBSUSP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_USBSUSP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x800) >> 11
}
func (o *USB_OTG_FS_Type) SetGINTSTS_USBRST(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_USBRST() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_FS_Type) SetGINTSTS_ENUMDNE(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_ENUMDNE() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x2000) >> 13
}
func (o *USB_OTG_FS_Type) SetGINTSTS_ISOODRP(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_ISOODRP() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x4000) >> 14
}
func (o *USB_OTG_FS_Type) SetGINTSTS_EOPF(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_EOPF() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_FS_Type) SetGINTSTS_IEPINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetGINTSTS_OEPINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetGINTSTS_IISOIXFR(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_IISOIXFR() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_FS_Type) SetGINTSTS_IPXFR_INCOMPISOOUT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_IPXFR_INCOMPISOOUT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_FS_Type) SetGINTSTS_HPRTINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_HPRTINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetGINTSTS_HCINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_HCINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_FS_Type) SetGINTSTS_PTXFE(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_PTXFE() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_FS_Type) SetGINTSTS_CIDSCHG(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_CIDSCHG() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_FS_Type) SetGINTSTS_DISCINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_DISCINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_FS_Type) SetGINTSTS_SRQINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_SRQINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_FS_Type) SetGINTSTS_WKUPINT(value uint32) {
	volatile.StoreUint32(&o.GINTSTS.Reg, volatile.LoadUint32(&o.GINTSTS.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetGINTSTS_WKUPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTSTS.Reg) & 0x80000000) >> 31
}

// USB_OTG_FS.GINTMSK: OTG_FS interrupt mask register (OTG_FS_GINTMSK)
func (o *USB_OTG_FS_Type) SetGINTMSK_MMISM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_MMISM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetGINTMSK_OTGINT(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetGINTMSK_SOFM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_SOFM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x8) >> 3
}
func (o *USB_OTG_FS_Type) SetGINTMSK_RXFLVLM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_RXFLVLM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetGINTMSK_NPTXFEM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_NPTXFEM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetGINTMSK_GINAKEFFM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_GINAKEFFM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetGINTMSK_GONAKEFFM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_GONAKEFFM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetGINTMSK_ESUSPM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_ESUSPM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x400) >> 10
}
func (o *USB_OTG_FS_Type) SetGINTMSK_USBSUSPM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_USBSUSPM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x800) >> 11
}
func (o *USB_OTG_FS_Type) SetGINTMSK_USBRST(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_USBRST() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_FS_Type) SetGINTMSK_ENUMDNEM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_ENUMDNEM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x2000) >> 13
}
func (o *USB_OTG_FS_Type) SetGINTMSK_ISOODRPM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_ISOODRPM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x4000) >> 14
}
func (o *USB_OTG_FS_Type) SetGINTMSK_EOPFM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_EOPFM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_FS_Type) SetGINTMSK_EPMISM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_EPMISM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetGINTMSK_IEPINT(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetGINTMSK_OEPINT(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetGINTMSK_IISOIXFRM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_IISOIXFRM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_FS_Type) SetGINTMSK_IPXFRM_IISOOXFRM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_IPXFRM_IISOOXFRM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_FS_Type) SetGINTMSK_PRTIM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_PRTIM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetGINTMSK_HCIM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_HCIM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_FS_Type) SetGINTMSK_PTXFEM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_PTXFEM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_FS_Type) SetGINTMSK_CIDSCHGM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_CIDSCHGM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_FS_Type) SetGINTMSK_DISCINT(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_DISCINT() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_FS_Type) SetGINTMSK_SRQIM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_SRQIM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_FS_Type) SetGINTMSK_WUIM(value uint32) {
	volatile.StoreUint32(&o.GINTMSK.Reg, volatile.LoadUint32(&o.GINTMSK.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetGINTMSK_WUIM() uint32 {
	return (volatile.LoadUint32(&o.GINTMSK.Reg) & 0x80000000) >> 31
}

// USB_OTG_FS.GRXSTSR_Device: OTG_FS Receive status debug read(Device mode)
func (o *USB_OTG_FS_Type) SetGRXSTSR_Device_EPNUM(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR_Device.Reg, volatile.LoadUint32(&o.GRXSTSR_Device.Reg)&^(0xf)|value)
}
func (o *USB_OTG_FS_Type) GetGRXSTSR_Device_EPNUM() uint32 {
	return volatile.LoadUint32(&o.GRXSTSR_Device.Reg) & 0xf
}
func (o *USB_OTG_FS_Type) SetGRXSTSR_Device_BCNT(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR_Device.Reg, volatile.LoadUint32(&o.GRXSTSR_Device.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_OTG_FS_Type) GetGRXSTSR_Device_BCNT() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR_Device.Reg) & 0x7ff0) >> 4
}
func (o *USB_OTG_FS_Type) SetGRXSTSR_Device_DPID(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR_Device.Reg, volatile.LoadUint32(&o.GRXSTSR_Device.Reg)&^(0x18000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetGRXSTSR_Device_DPID() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR_Device.Reg) & 0x18000) >> 15
}
func (o *USB_OTG_FS_Type) SetGRXSTSR_Device_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR_Device.Reg, volatile.LoadUint32(&o.GRXSTSR_Device.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetGRXSTSR_Device_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR_Device.Reg) & 0x1e0000) >> 17
}
func (o *USB_OTG_FS_Type) SetGRXSTSR_Device_FRMNUM(value uint32) {
	volatile.StoreUint32(&o.GRXSTSR_Device.Reg, volatile.LoadUint32(&o.GRXSTSR_Device.Reg)&^(0x1e00000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetGRXSTSR_Device_FRMNUM() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSR_Device.Reg) & 0x1e00000) >> 21
}

// USB_OTG_FS.GRXSTSP_Device: OTG status read and pop (device mode)
func (o *USB_OTG_FS_Type) SetGRXSTSP_Device_STSPHST(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP_Device.Reg, volatile.LoadUint32(&o.GRXSTSP_Device.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_FS_Type) GetGRXSTSP_Device_STSPHST() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP_Device.Reg) & 0x8000000) >> 27
}
func (o *USB_OTG_FS_Type) SetGRXSTSP_Device_FRMNUM(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP_Device.Reg, volatile.LoadUint32(&o.GRXSTSP_Device.Reg)&^(0x1e00000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetGRXSTSP_Device_FRMNUM() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP_Device.Reg) & 0x1e00000) >> 21
}
func (o *USB_OTG_FS_Type) SetGRXSTSP_Device_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP_Device.Reg, volatile.LoadUint32(&o.GRXSTSP_Device.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetGRXSTSP_Device_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP_Device.Reg) & 0x1e0000) >> 17
}
func (o *USB_OTG_FS_Type) SetGRXSTSP_Device_DPID(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP_Device.Reg, volatile.LoadUint32(&o.GRXSTSP_Device.Reg)&^(0x18000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetGRXSTSP_Device_DPID() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP_Device.Reg) & 0x18000) >> 15
}
func (o *USB_OTG_FS_Type) SetGRXSTSP_Device_BCNT(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP_Device.Reg, volatile.LoadUint32(&o.GRXSTSP_Device.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_OTG_FS_Type) GetGRXSTSP_Device_BCNT() uint32 {
	return (volatile.LoadUint32(&o.GRXSTSP_Device.Reg) & 0x7ff0) >> 4
}
func (o *USB_OTG_FS_Type) SetGRXSTSP_Device_EPNUM(value uint32) {
	volatile.StoreUint32(&o.GRXSTSP_Device.Reg, volatile.LoadUint32(&o.GRXSTSP_Device.Reg)&^(0xf)|value)
}
func (o *USB_OTG_FS_Type) GetGRXSTSP_Device_EPNUM() uint32 {
	return volatile.LoadUint32(&o.GRXSTSP_Device.Reg) & 0xf
}

// USB_OTG_FS.GRXFSIZ: OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
func (o *USB_OTG_FS_Type) SetGRXFSIZ_RXFD(value uint32) {
	volatile.StoreUint32(&o.GRXFSIZ.Reg, volatile.LoadUint32(&o.GRXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetGRXFSIZ_RXFD() uint32 {
	return volatile.LoadUint32(&o.GRXFSIZ.Reg) & 0xffff
}

// USB_OTG_FS.DIEPTXF0: OTG_FS non-periodic transmit FIFO size register (Device mode)
func (o *USB_OTG_FS_Type) SetDIEPTXF0_TX0FSA(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF0.Reg, volatile.LoadUint32(&o.DIEPTXF0.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF0_TX0FSA() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF0.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetDIEPTXF0_TX0FD(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF0.Reg, volatile.LoadUint32(&o.DIEPTXF0.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF0_TX0FD() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF0.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.GNPTXSTS: OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
func (o *USB_OTG_FS_Type) SetGNPTXSTS_NPTXFSAV(value uint32) {
	volatile.StoreUint32(&o.GNPTXSTS.Reg, volatile.LoadUint32(&o.GNPTXSTS.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetGNPTXSTS_NPTXFSAV() uint32 {
	return volatile.LoadUint32(&o.GNPTXSTS.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetGNPTXSTS_NPTQXSAV(value uint32) {
	volatile.StoreUint32(&o.GNPTXSTS.Reg, volatile.LoadUint32(&o.GNPTXSTS.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetGNPTXSTS_NPTQXSAV() uint32 {
	return (volatile.LoadUint32(&o.GNPTXSTS.Reg) & 0xff0000) >> 16
}
func (o *USB_OTG_FS_Type) SetGNPTXSTS_NPTXQTOP(value uint32) {
	volatile.StoreUint32(&o.GNPTXSTS.Reg, volatile.LoadUint32(&o.GNPTXSTS.Reg)&^(0x7f000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetGNPTXSTS_NPTXQTOP() uint32 {
	return (volatile.LoadUint32(&o.GNPTXSTS.Reg) & 0x7f000000) >> 24
}

// USB_OTG_FS.GCCFG: OTG_FS general core configuration register (OTG_FS_GCCFG)
func (o *USB_OTG_FS_Type) SetGCCFG_PWRDWN(value uint32) {
	volatile.StoreUint32(&o.GCCFG.Reg, volatile.LoadUint32(&o.GCCFG.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetGCCFG_PWRDWN() uint32 {
	return (volatile.LoadUint32(&o.GCCFG.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_FS_Type) SetGCCFG_VBUSASEN(value uint32) {
	volatile.StoreUint32(&o.GCCFG.Reg, volatile.LoadUint32(&o.GCCFG.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetGCCFG_VBUSASEN() uint32 {
	return (volatile.LoadUint32(&o.GCCFG.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetGCCFG_VBUSBSEN(value uint32) {
	volatile.StoreUint32(&o.GCCFG.Reg, volatile.LoadUint32(&o.GCCFG.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetGCCFG_VBUSBSEN() uint32 {
	return (volatile.LoadUint32(&o.GCCFG.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetGCCFG_SOFOUTEN(value uint32) {
	volatile.StoreUint32(&o.GCCFG.Reg, volatile.LoadUint32(&o.GCCFG.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetGCCFG_SOFOUTEN() uint32 {
	return (volatile.LoadUint32(&o.GCCFG.Reg) & 0x100000) >> 20
}

// USB_OTG_FS.CID: core ID register
func (o *USB_OTG_FS_Type) SetCID(value uint32) {
	volatile.StoreUint32(&o.CID.Reg, value)
}
func (o *USB_OTG_FS_Type) GetCID() uint32 {
	return volatile.LoadUint32(&o.CID.Reg)
}

// USB_OTG_FS.HPTXFSIZ: OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
func (o *USB_OTG_FS_Type) SetHPTXFSIZ_PTXSA(value uint32) {
	volatile.StoreUint32(&o.HPTXFSIZ.Reg, volatile.LoadUint32(&o.HPTXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetHPTXFSIZ_PTXSA() uint32 {
	return volatile.LoadUint32(&o.HPTXFSIZ.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetHPTXFSIZ_PTXFSIZ(value uint32) {
	volatile.StoreUint32(&o.HPTXFSIZ.Reg, volatile.LoadUint32(&o.HPTXFSIZ.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetHPTXFSIZ_PTXFSIZ() uint32 {
	return (volatile.LoadUint32(&o.HPTXFSIZ.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.DIEPTXF1: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
func (o *USB_OTG_FS_Type) SetDIEPTXF1_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF1.Reg, volatile.LoadUint32(&o.DIEPTXF1.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF1_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF1.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetDIEPTXF1_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF1.Reg, volatile.LoadUint32(&o.DIEPTXF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF1_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF1.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.DIEPTXF2: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
func (o *USB_OTG_FS_Type) SetDIEPTXF2_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF2.Reg, volatile.LoadUint32(&o.DIEPTXF2.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF2_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF2.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetDIEPTXF2_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF2.Reg, volatile.LoadUint32(&o.DIEPTXF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF2_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF2.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.DIEPTXF3: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
func (o *USB_OTG_FS_Type) SetDIEPTXF3_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF3.Reg, volatile.LoadUint32(&o.DIEPTXF3.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF3_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.DIEPTXF3.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetDIEPTXF3_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.DIEPTXF3.Reg, volatile.LoadUint32(&o.DIEPTXF3.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetDIEPTXF3_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.DIEPTXF3.Reg) & 0xffff0000) >> 16
}

// Single Wire Protocol Master Interface
type SWPMI_Type struct {
	CR  volatile.Register32 // 0x0
	BRR volatile.Register32 // 0x4
	_   [4]byte
	ISR volatile.Register32 // 0xC
	ICR volatile.Register32 // 0x10
	IER volatile.Register32 // 0x14
	RFL volatile.Register32 // 0x18
	TDR volatile.Register32 // 0x1C
	RDR volatile.Register32 // 0x20
}

// SWPMI.CR: SWPMI Configuration/Control register
func (o *SWPMI_Type) SetCR_RXDMA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetCR_RXDMA() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SWPMI_Type) SetCR_TXDMA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetCR_TXDMA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetCR_RXMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetCR_RXMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetCR_TXMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetCR_TXMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetCR_LPBK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetCR_LPBK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetCR_SWPME(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *SWPMI_Type) GetCR_SWPME() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *SWPMI_Type) SetCR_DEACT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *SWPMI_Type) GetCR_DEACT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}

// SWPMI.BRR: SWPMI Bitrate register
func (o *SWPMI_Type) SetBRR_BR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x3f)|value)
}
func (o *SWPMI_Type) GetBRR_BR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0x3f
}

// SWPMI.ISR: SWPMI Interrupt and Status register
func (o *SWPMI_Type) SetISR_RXBFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetISR_RXBFF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *SWPMI_Type) SetISR_TXBEF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetISR_TXBEF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetISR_RXBERF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetISR_RXBERF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetISR_RXOVRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetISR_RXOVRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetISR_TXUNRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetISR_TXUNRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *SWPMI_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *SWPMI_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *SWPMI_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *SWPMI_Type) SetISR_TCF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *SWPMI_Type) GetISR_TCF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *SWPMI_Type) SetISR_SRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *SWPMI_Type) GetISR_SRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *SWPMI_Type) SetISR_SUSP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *SWPMI_Type) GetISR_SUSP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *SWPMI_Type) SetISR_DEACTF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *SWPMI_Type) GetISR_DEACTF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}

// SWPMI.ICR: SWPMI Interrupt Flag Clear register
func (o *SWPMI_Type) SetICR_CRXBFF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetICR_CRXBFF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *SWPMI_Type) SetICR_CTXBEF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetICR_CTXBEF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetICR_CRXBERF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetICR_CRXBERF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetICR_CRXOVRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetICR_CRXOVRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetICR_CTXUNRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetICR_CTXUNRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetICR_CTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *SWPMI_Type) GetICR_CTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *SWPMI_Type) SetICR_CSRF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *SWPMI_Type) GetICR_CSRF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}

// SWPMI.IER: SWPMI Interrupt Enable register
func (o *SWPMI_Type) SetIER_RXBFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SWPMI_Type) GetIER_RXBFIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SWPMI_Type) SetIER_TXBEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SWPMI_Type) GetIER_TXBEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SWPMI_Type) SetIER_RXBERIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SWPMI_Type) GetIER_RXBERIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SWPMI_Type) SetIER_RXOVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SWPMI_Type) GetIER_RXOVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SWPMI_Type) SetIER_TXUNRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SWPMI_Type) GetIER_TXUNRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SWPMI_Type) SetIER_RIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SWPMI_Type) GetIER_RIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SWPMI_Type) SetIER_TIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *SWPMI_Type) GetIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *SWPMI_Type) SetIER_TCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *SWPMI_Type) GetIER_TCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *SWPMI_Type) SetIER_SRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SWPMI_Type) GetIER_SRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}

// SWPMI.RFL: SWPMI Receive Frame Length register
func (o *SWPMI_Type) SetRFL(value uint32) {
	volatile.StoreUint32(&o.RFL.Reg, volatile.LoadUint32(&o.RFL.Reg)&^(0x1f)|value)
}
func (o *SWPMI_Type) GetRFL() uint32 {
	return volatile.LoadUint32(&o.RFL.Reg) & 0x1f
}

// SWPMI.TDR: SWPMI Transmit data register
func (o *SWPMI_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, value)
}
func (o *SWPMI_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg)
}

// SWPMI.RDR: SWPMI Receive data register
func (o *SWPMI_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, value)
}
func (o *SWPMI_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg)
}

// Operational amplifiers
type OPAMP_Type struct {
	OPAMP1_CSR   volatile.Register32 // 0x0
	OPAMP1_OTR   volatile.Register32 // 0x4
	OPAMP1_LPOTR volatile.Register32 // 0x8
	_            [4]byte
	OPAMP2_CSR   volatile.Register32 // 0x10
	OPAMP2_OTR   volatile.Register32 // 0x14
	OPAMP2_LPOTR volatile.Register32 // 0x18
}

// OPAMP.OPAMP1_CSR: OPAMP1 control/status register
func (o *OPAMP_Type) SetOPAMP1_CSR_OPAEN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_OPAEN() uint32 {
	return volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x1
}
func (o *OPAMP_Type) SetOPAMP1_CSR_OPALPM(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_OPALPM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetOPAMP1_CSR_OPAMODE(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0xc)|value<<2)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_OPAMODE() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0xc) >> 2
}
func (o *OPAMP_Type) SetOPAMP1_CSR_PGA_GAIN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x30)|value<<4)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_PGA_GAIN() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x30) >> 4
}
func (o *OPAMP_Type) SetOPAMP1_CSR_VM_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x300)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_VM_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x300) >> 8
}
func (o *OPAMP_Type) SetOPAMP1_CSR_VP_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x400)|value<<10)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_VP_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x400) >> 10
}
func (o *OPAMP_Type) SetOPAMP1_CSR_CALON(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x1000)|value<<12)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_CALON() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x1000) >> 12
}
func (o *OPAMP_Type) SetOPAMP1_CSR_CALSEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x2000)|value<<13)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_CALSEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x2000) >> 13
}
func (o *OPAMP_Type) SetOPAMP1_CSR_USERTRIM(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x4000)|value<<14)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_USERTRIM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x4000) >> 14
}
func (o *OPAMP_Type) SetOPAMP1_CSR_CALOUT(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_CALOUT() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x8000) >> 15
}
func (o *OPAMP_Type) SetOPAMP1_CSR_OPA_RANGE(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_CSR.Reg, volatile.LoadUint32(&o.OPAMP1_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *OPAMP_Type) GetOPAMP1_CSR_OPA_RANGE() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_CSR.Reg) & 0x80000000) >> 31
}

// OPAMP.OPAMP1_OTR: OPAMP1 offset trimming register in normal mode
func (o *OPAMP_Type) SetOPAMP1_OTR_TRIMOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_OTR.Reg, volatile.LoadUint32(&o.OPAMP1_OTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP1_OTR_TRIMOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP1_OTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP1_OTR_TRIMOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_OTR.Reg, volatile.LoadUint32(&o.OPAMP1_OTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP1_OTR_TRIMOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_OTR.Reg) & 0x1f00) >> 8
}

// OPAMP.OPAMP1_LPOTR: OPAMP1 offset trimming register in low-power mode
func (o *OPAMP_Type) SetOPAMP1_LPOTR_TRIMLPOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_LPOTR.Reg, volatile.LoadUint32(&o.OPAMP1_LPOTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP1_LPOTR_TRIMLPOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP1_LPOTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP1_LPOTR_TRIMLPOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP1_LPOTR.Reg, volatile.LoadUint32(&o.OPAMP1_LPOTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP1_LPOTR_TRIMLPOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP1_LPOTR.Reg) & 0x1f00) >> 8
}

// OPAMP.OPAMP2_CSR: OPAMP2 control/status register
func (o *OPAMP_Type) SetOPAMP2_CSR_OPAEN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_OPAEN() uint32 {
	return volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x1
}
func (o *OPAMP_Type) SetOPAMP2_CSR_OPALPM(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_OPALPM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetOPAMP2_CSR_OPAMODE(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0xc)|value<<2)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_OPAMODE() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0xc) >> 2
}
func (o *OPAMP_Type) SetOPAMP2_CSR_PGA_GAIN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x30)|value<<4)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_PGA_GAIN() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x30) >> 4
}
func (o *OPAMP_Type) SetOPAMP2_CSR_VM_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x300)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_VM_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x300) >> 8
}
func (o *OPAMP_Type) SetOPAMP2_CSR_VP_SEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x400)|value<<10)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_VP_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x400) >> 10
}
func (o *OPAMP_Type) SetOPAMP2_CSR_CALON(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x1000)|value<<12)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_CALON() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x1000) >> 12
}
func (o *OPAMP_Type) SetOPAMP2_CSR_CALSEL(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x2000)|value<<13)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_CALSEL() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x2000) >> 13
}
func (o *OPAMP_Type) SetOPAMP2_CSR_USERTRIM(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x4000)|value<<14)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_USERTRIM() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x4000) >> 14
}
func (o *OPAMP_Type) SetOPAMP2_CSR_CALOUT(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_CSR.Reg, volatile.LoadUint32(&o.OPAMP2_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *OPAMP_Type) GetOPAMP2_CSR_CALOUT() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_CSR.Reg) & 0x8000) >> 15
}

// OPAMP.OPAMP2_OTR: OPAMP2 offset trimming register in normal mode
func (o *OPAMP_Type) SetOPAMP2_OTR_TRIMOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_OTR.Reg, volatile.LoadUint32(&o.OPAMP2_OTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP2_OTR_TRIMOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP2_OTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP2_OTR_TRIMOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_OTR.Reg, volatile.LoadUint32(&o.OPAMP2_OTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP2_OTR_TRIMOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_OTR.Reg) & 0x1f00) >> 8
}

// OPAMP.OPAMP2_LPOTR: OPAMP2 offset trimming register in low-power mode
func (o *OPAMP_Type) SetOPAMP2_LPOTR_TRIMLPOFFSETN(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_LPOTR.Reg, volatile.LoadUint32(&o.OPAMP2_LPOTR.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetOPAMP2_LPOTR_TRIMLPOFFSETN() uint32 {
	return volatile.LoadUint32(&o.OPAMP2_LPOTR.Reg) & 0x1f
}
func (o *OPAMP_Type) SetOPAMP2_LPOTR_TRIMLPOFFSETP(value uint32) {
	volatile.StoreUint32(&o.OPAMP2_LPOTR.Reg, volatile.LoadUint32(&o.OPAMP2_LPOTR.Reg)&^(0x1f00)|value<<8)
}
func (o *OPAMP_Type) GetOPAMP2_LPOTR_TRIMLPOFFSETP() uint32 {
	return (volatile.LoadUint32(&o.OPAMP2_LPOTR.Reg) & 0x1f00) >> 8
}

// Flexible memory controller
type FMC_Type struct {
	BCR1  volatile.Register32 // 0x0
	BTR1  volatile.Register32 // 0x4
	BCR2  volatile.Register32 // 0x8
	BTR2  volatile.Register32 // 0xC
	BCR3  volatile.Register32 // 0x10
	BTR3  volatile.Register32 // 0x14
	BCR4  volatile.Register32 // 0x18
	BTR4  volatile.Register32 // 0x1C
	_     [96]byte
	PCR   volatile.Register32 // 0x80
	SR    volatile.Register32 // 0x84
	PMEM  volatile.Register32 // 0x88
	PATT  volatile.Register32 // 0x8C
	_     [4]byte
	ECCR  volatile.Register32 // 0x94
	_     [108]byte
	BWTR1 volatile.Register32 // 0x104
	_     [4]byte
	BWTR2 volatile.Register32 // 0x10C
	_     [4]byte
	BWTR3 volatile.Register32 // 0x114
	_     [4]byte
	BWTR4 volatile.Register32 // 0x11C
}

// FMC.BCR1: SRAM/NOR-Flash chip-select control register 1
func (o *FMC_Type) SetBCR1_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR1_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR1.Reg) & 0x1
}
func (o *FMC_Type) SetBCR1_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR1_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR1_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR1_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR1_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR1_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR1_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR1_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR1_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR1_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR1_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR1_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR1_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR1_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR1_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR1_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR1_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR1_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR1_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR1_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR1_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR1_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR1_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR1_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR1_CCLKEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x100000)|value<<20)
}
func (o *FMC_Type) GetBCR1_CCLKEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x100000) >> 20
}
func (o *FMC_Type) SetBCR1_WFDIS(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x200000)|value<<21)
}
func (o *FMC_Type) GetBCR1_WFDIS() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x200000) >> 21
}

// FMC.BTR1: SRAM/NOR-Flash chip-select timing register 1
func (o *FMC_Type) SetBTR1_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR1_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBTR1_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR1_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR1_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR1_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR1_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR1_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR1_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR1_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR1_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR1_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR1_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR1_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR1.Reg) & 0xf
}

// FMC.BCR2: SRAM/NOR-Flash chip-select control register 2
func (o *FMC_Type) SetBCR2_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR2_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR2_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR2_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR2_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR2_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR2_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR2_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR2_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR2_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR2_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR2_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR2_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x400)|value<<10)
}
func (o *FMC_Type) GetBCR2_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x400) >> 10
}
func (o *FMC_Type) SetBCR2_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR2_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR2_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR2_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR2_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR2_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR2_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR2_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR2_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR2_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR2_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR2_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR2_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR2_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR2.Reg) & 0x1
}

// FMC.BTR2: SRAM/NOR-Flash chip-select timing register 2
func (o *FMC_Type) SetBTR2_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR2_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBTR2_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR2_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR2_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR2_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR2_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR2_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR2_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR2_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR2_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR2_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR2_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR2_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR2.Reg) & 0xf
}

// FMC.BCR3: SRAM/NOR-Flash chip-select control register 3
func (o *FMC_Type) SetBCR3_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR3_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR3_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR3_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR3_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR3_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR3_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR3_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR3_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR3_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR3_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR3_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR3_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x400)|value<<10)
}
func (o *FMC_Type) GetBCR3_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x400) >> 10
}
func (o *FMC_Type) SetBCR3_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR3_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR3_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR3_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR3_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR3_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR3_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR3_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR3_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR3_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR3_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR3_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR3_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR3_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR3.Reg) & 0x1
}

// FMC.BTR3: SRAM/NOR-Flash chip-select timing register 3
func (o *FMC_Type) SetBTR3_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR3_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBTR3_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR3_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR3_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR3_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR3_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR3_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR3_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR3_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR3_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR3_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR3_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR3_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR3.Reg) & 0xf
}

// FMC.BCR4: SRAM/NOR-Flash chip-select control register 4
func (o *FMC_Type) SetBCR4_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x80000)|value<<19)
}
func (o *FMC_Type) GetBCR4_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x80000) >> 19
}
func (o *FMC_Type) SetBCR4_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x8000)|value<<15)
}
func (o *FMC_Type) GetBCR4_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x8000) >> 15
}
func (o *FMC_Type) SetBCR4_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x4000)|value<<14)
}
func (o *FMC_Type) GetBCR4_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x4000) >> 14
}
func (o *FMC_Type) SetBCR4_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x2000)|value<<13)
}
func (o *FMC_Type) GetBCR4_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x2000) >> 13
}
func (o *FMC_Type) SetBCR4_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x1000)|value<<12)
}
func (o *FMC_Type) GetBCR4_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x1000) >> 12
}
func (o *FMC_Type) SetBCR4_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x800)|value<<11)
}
func (o *FMC_Type) GetBCR4_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x800) >> 11
}
func (o *FMC_Type) SetBCR4_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x400)|value<<10)
}
func (o *FMC_Type) GetBCR4_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x400) >> 10
}
func (o *FMC_Type) SetBCR4_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x200)|value<<9)
}
func (o *FMC_Type) GetBCR4_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x200) >> 9
}
func (o *FMC_Type) SetBCR4_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x100)|value<<8)
}
func (o *FMC_Type) GetBCR4_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x100) >> 8
}
func (o *FMC_Type) SetBCR4_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetBCR4_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetBCR4_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetBCR4_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetBCR4_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0xc)|value<<2)
}
func (o *FMC_Type) GetBCR4_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0xc) >> 2
}
func (o *FMC_Type) SetBCR4_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetBCR4_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetBCR4_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetBCR4_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR4.Reg) & 0x1
}

// FMC.BTR4: SRAM/NOR-Flash chip-select timing register 4
func (o *FMC_Type) SetBTR4_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBTR4_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBTR4_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBTR4_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBTR4_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBTR4_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBTR4_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf0000)|value<<16)
}
func (o *FMC_Type) GetBTR4_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf0000) >> 16
}
func (o *FMC_Type) SetBTR4_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBTR4_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBTR4_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBTR4_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBTR4_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBTR4_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR4.Reg) & 0xf
}

// FMC.PCR: PC Card/NAND Flash control register 3
func (o *FMC_Type) SetPCR_ECCPS(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0xe0000)|value<<17)
}
func (o *FMC_Type) GetPCR_ECCPS() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0xe0000) >> 17
}
func (o *FMC_Type) SetPCR_TAR(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1e000)|value<<13)
}
func (o *FMC_Type) GetPCR_TAR() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1e000) >> 13
}
func (o *FMC_Type) SetPCR_TCLR(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1e00)|value<<9)
}
func (o *FMC_Type) GetPCR_TCLR() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1e00) >> 9
}
func (o *FMC_Type) SetPCR_ECCEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetPCR_ECCEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetPCR_PWID(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x30)|value<<4)
}
func (o *FMC_Type) GetPCR_PWID() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x30) >> 4
}
func (o *FMC_Type) SetPCR_PTYP(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetPCR_PTYP() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetPCR_PBKEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetPCR_PBKEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetPCR_PWAITEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetPCR_PWAITEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x2) >> 1
}

// FMC.SR: FIFO status and interrupt register 3
func (o *FMC_Type) SetSR_FEMPT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *FMC_Type) GetSR_FEMPT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *FMC_Type) SetSR_IFEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *FMC_Type) GetSR_IFEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *FMC_Type) SetSR_ILEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *FMC_Type) GetSR_ILEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *FMC_Type) SetSR_IREN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *FMC_Type) GetSR_IREN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *FMC_Type) SetSR_IFS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *FMC_Type) GetSR_IFS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *FMC_Type) SetSR_ILS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *FMC_Type) GetSR_ILS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *FMC_Type) SetSR_IRS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *FMC_Type) GetSR_IRS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// FMC.PMEM: Common memory space timing register 3
func (o *FMC_Type) SetPMEM_MEMHIZx(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff000000)|value<<24)
}
func (o *FMC_Type) GetPMEM_MEMHIZx() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff000000) >> 24
}
func (o *FMC_Type) SetPMEM_MEMHOLDx(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff0000)|value<<16)
}
func (o *FMC_Type) GetPMEM_MEMHOLDx() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff0000) >> 16
}
func (o *FMC_Type) SetPMEM_MEMWAITx(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetPMEM_MEMWAITx() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetPMEM_MEMSETx(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff)|value)
}
func (o *FMC_Type) GetPMEM_MEMSETx() uint32 {
	return volatile.LoadUint32(&o.PMEM.Reg) & 0xff
}

// FMC.PATT: Attribute memory space timing register 3
func (o *FMC_Type) SetPATT_ATTHIZx(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff000000)|value<<24)
}
func (o *FMC_Type) GetPATT_ATTHIZx() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff000000) >> 24
}
func (o *FMC_Type) SetPATT_ATTHOLDx(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff0000)|value<<16)
}
func (o *FMC_Type) GetPATT_ATTHOLDx() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff0000) >> 16
}
func (o *FMC_Type) SetPATT_ATTWAITx(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetPATT_ATTWAITx() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetPATT_ATTSETx(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff)|value)
}
func (o *FMC_Type) GetPATT_ATTSETx() uint32 {
	return volatile.LoadUint32(&o.PATT.Reg) & 0xff
}

// FMC.ECCR: ECC result register 3
func (o *FMC_Type) SetECCR(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, value)
}
func (o *FMC_Type) GetECCR() uint32 {
	return volatile.LoadUint32(&o.ECCR.Reg)
}

// FMC.BWTR1: SRAM/NOR-Flash write timing registers 1
func (o *FMC_Type) SetBWTR1_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR1_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBWTR1_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBWTR1_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBWTR1_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBWTR1_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBWTR1_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR1_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR1_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR1_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR1_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR1_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR1.Reg) & 0xf
}

// FMC.BWTR2: SRAM/NOR-Flash write timing registers 2
func (o *FMC_Type) SetBWTR2_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR2_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBWTR2_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBWTR2_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBWTR2_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBWTR2_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBWTR2_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR2_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR2_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR2_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR2_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR2_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR2.Reg) & 0xf
}

// FMC.BWTR3: SRAM/NOR-Flash write timing registers 3
func (o *FMC_Type) SetBWTR3_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR3_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBWTR3_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBWTR3_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBWTR3_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBWTR3_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBWTR3_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR3_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR3_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR3_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR3_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR3_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR3.Reg) & 0xf
}

// FMC.BWTR4: SRAM/NOR-Flash write timing registers 4
func (o *FMC_Type) SetBWTR4_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0x30000000)|value<<28)
}
func (o *FMC_Type) GetBWTR4_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0x30000000) >> 28
}
func (o *FMC_Type) SetBWTR4_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf000000)|value<<24)
}
func (o *FMC_Type) GetBWTR4_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf000000) >> 24
}
func (o *FMC_Type) SetBWTR4_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf00000)|value<<20)
}
func (o *FMC_Type) GetBWTR4_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf00000) >> 20
}
func (o *FMC_Type) SetBWTR4_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xff00)|value<<8)
}
func (o *FMC_Type) GetBWTR4_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xff00) >> 8
}
func (o *FMC_Type) SetBWTR4_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf0)|value<<4)
}
func (o *FMC_Type) GetBWTR4_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf0) >> 4
}
func (o *FMC_Type) SetBWTR4_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf)|value)
}
func (o *FMC_Type) GetBWTR4_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR4.Reg) & 0xf
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER0 volatile.Register32 // 0x0
	ISER1 volatile.Register32 // 0x4
	ISER2 volatile.Register32 // 0x8
	_     [116]byte
	ICER0 volatile.Register32 // 0x80
	ICER1 volatile.Register32 // 0x84
	ICER2 volatile.Register32 // 0x88
	_     [116]byte
	ISPR0 volatile.Register32 // 0x100
	ISPR1 volatile.Register32 // 0x104
	ISPR2 volatile.Register32 // 0x108
	_     [116]byte
	ICPR0 volatile.Register32 // 0x180
	ICPR1 volatile.Register32 // 0x184
	ICPR2 volatile.Register32 // 0x188
	_     [116]byte
	IABR0 volatile.Register32 // 0x200
	IABR1 volatile.Register32 // 0x204
	IABR2 volatile.Register32 // 0x208
	_     [244]byte
	IPR0  volatile.Register32 // 0x300
	IPR1  volatile.Register32 // 0x304
	IPR2  volatile.Register32 // 0x308
	IPR3  volatile.Register32 // 0x30C
	IPR4  volatile.Register32 // 0x310
	IPR5  volatile.Register32 // 0x314
	IPR6  volatile.Register32 // 0x318
	IPR7  volatile.Register32 // 0x31C
	IPR8  volatile.Register32 // 0x320
	IPR9  volatile.Register32 // 0x324
	IPR10 volatile.Register32 // 0x328
	IPR11 volatile.Register32 // 0x32C
	IPR12 volatile.Register32 // 0x330
	IPR13 volatile.Register32 // 0x334
	IPR14 volatile.Register32 // 0x338
	IPR15 volatile.Register32 // 0x33C
	IPR16 volatile.Register32 // 0x340
	IPR17 volatile.Register32 // 0x344
	IPR18 volatile.Register32 // 0x348
	IPR19 volatile.Register32 // 0x34C
	IPR20 volatile.Register32 // 0x350
}

// NVIC.ISER0: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER0(value uint32) {
	volatile.StoreUint32(&o.ISER0.Reg, value)
}
func (o *NVIC_Type) GetISER0() uint32 {
	return volatile.LoadUint32(&o.ISER0.Reg)
}

// NVIC.ISER1: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER1(value uint32) {
	volatile.StoreUint32(&o.ISER1.Reg, value)
}
func (o *NVIC_Type) GetISER1() uint32 {
	return volatile.LoadUint32(&o.ISER1.Reg)
}

// NVIC.ISER2: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER2(value uint32) {
	volatile.StoreUint32(&o.ISER2.Reg, value)
}
func (o *NVIC_Type) GetISER2() uint32 {
	return volatile.LoadUint32(&o.ISER2.Reg)
}

// NVIC.ICER0: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER0(value uint32) {
	volatile.StoreUint32(&o.ICER0.Reg, value)
}
func (o *NVIC_Type) GetICER0() uint32 {
	return volatile.LoadUint32(&o.ICER0.Reg)
}

// NVIC.ICER1: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER1(value uint32) {
	volatile.StoreUint32(&o.ICER1.Reg, value)
}
func (o *NVIC_Type) GetICER1() uint32 {
	return volatile.LoadUint32(&o.ICER1.Reg)
}

// NVIC.ICER2: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER2(value uint32) {
	volatile.StoreUint32(&o.ICER2.Reg, value)
}
func (o *NVIC_Type) GetICER2() uint32 {
	return volatile.LoadUint32(&o.ICER2.Reg)
}

// NVIC.ISPR0: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR0(value uint32) {
	volatile.StoreUint32(&o.ISPR0.Reg, value)
}
func (o *NVIC_Type) GetISPR0() uint32 {
	return volatile.LoadUint32(&o.ISPR0.Reg)
}

// NVIC.ISPR1: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR1(value uint32) {
	volatile.StoreUint32(&o.ISPR1.Reg, value)
}
func (o *NVIC_Type) GetISPR1() uint32 {
	return volatile.LoadUint32(&o.ISPR1.Reg)
}

// NVIC.ISPR2: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR2(value uint32) {
	volatile.StoreUint32(&o.ISPR2.Reg, value)
}
func (o *NVIC_Type) GetISPR2() uint32 {
	return volatile.LoadUint32(&o.ISPR2.Reg)
}

// NVIC.ICPR0: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR0(value uint32) {
	volatile.StoreUint32(&o.ICPR0.Reg, value)
}
func (o *NVIC_Type) GetICPR0() uint32 {
	return volatile.LoadUint32(&o.ICPR0.Reg)
}

// NVIC.ICPR1: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR1(value uint32) {
	volatile.StoreUint32(&o.ICPR1.Reg, value)
}
func (o *NVIC_Type) GetICPR1() uint32 {
	return volatile.LoadUint32(&o.ICPR1.Reg)
}

// NVIC.ICPR2: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR2(value uint32) {
	volatile.StoreUint32(&o.ICPR2.Reg, value)
}
func (o *NVIC_Type) GetICPR2() uint32 {
	return volatile.LoadUint32(&o.ICPR2.Reg)
}

// NVIC.IABR0: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR0(value uint32) {
	volatile.StoreUint32(&o.IABR0.Reg, value)
}
func (o *NVIC_Type) GetIABR0() uint32 {
	return volatile.LoadUint32(&o.IABR0.Reg)
}

// NVIC.IABR1: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR1(value uint32) {
	volatile.StoreUint32(&o.IABR1.Reg, value)
}
func (o *NVIC_Type) GetIABR1() uint32 {
	return volatile.LoadUint32(&o.IABR1.Reg)
}

// NVIC.IABR2: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR2(value uint32) {
	volatile.StoreUint32(&o.IABR2.Reg, value)
}
func (o *NVIC_Type) GetIABR2() uint32 {
	return volatile.LoadUint32(&o.IABR2.Reg)
}

// NVIC.IPR0: Interrupt Priority Register
func (o *NVIC_Type) SetIPR0_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR0_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR0_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR0_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR0_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR0_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR0_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR0_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff000000) >> 24
}

// NVIC.IPR1: Interrupt Priority Register
func (o *NVIC_Type) SetIPR1_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR1_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR1_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR1_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR1_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR1_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR1_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR1_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff000000) >> 24
}

// NVIC.IPR2: Interrupt Priority Register
func (o *NVIC_Type) SetIPR2_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR2_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR2_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR2_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR2_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR2_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR2_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR2_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff000000) >> 24
}

// NVIC.IPR3: Interrupt Priority Register
func (o *NVIC_Type) SetIPR3_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR3_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR3_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR3_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR3_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR3_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR3_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR3_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff000000) >> 24
}

// NVIC.IPR4: Interrupt Priority Register
func (o *NVIC_Type) SetIPR4_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR4_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR4.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR4_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR4_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR4_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR4_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR4_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR4_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff000000) >> 24
}

// NVIC.IPR5: Interrupt Priority Register
func (o *NVIC_Type) SetIPR5_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR5_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR5.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR5_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR5_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR5_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR5_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR5_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR5_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff000000) >> 24
}

// NVIC.IPR6: Interrupt Priority Register
func (o *NVIC_Type) SetIPR6_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR6_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR6.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR6_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR6_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR6_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR6_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR6_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR6_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff000000) >> 24
}

// NVIC.IPR7: Interrupt Priority Register
func (o *NVIC_Type) SetIPR7_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR7_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR7.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR7_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR7_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR7_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR7_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR7_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR7_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff000000) >> 24
}

// NVIC.IPR8: Interrupt Priority Register
func (o *NVIC_Type) SetIPR8_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR8_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR8.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR8_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR8_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR8_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR8_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR8_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR8_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff000000) >> 24
}

// NVIC.IPR9: Interrupt Priority Register
func (o *NVIC_Type) SetIPR9_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR9_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR9.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR9_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR9_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR9_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR9_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR9_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR9_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff000000) >> 24
}

// NVIC.IPR10: Interrupt Priority Register
func (o *NVIC_Type) SetIPR10_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR10_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR10.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR10_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR10_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR10_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR10_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR10_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR10_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff000000) >> 24
}

// NVIC.IPR11: Interrupt Priority Register
func (o *NVIC_Type) SetIPR11_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR11_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR11.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR11_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR11_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR11_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR11_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR11_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR11_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff000000) >> 24
}

// NVIC.IPR12: Interrupt Priority Register
func (o *NVIC_Type) SetIPR12_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR12_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR12.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR12_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR12_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR12_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR12_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR12_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR12_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff000000) >> 24
}

// NVIC.IPR13: Interrupt Priority Register
func (o *NVIC_Type) SetIPR13_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR13_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR13.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR13_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR13_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR13_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR13_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR13_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR13_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff000000) >> 24
}

// NVIC.IPR14: Interrupt Priority Register
func (o *NVIC_Type) SetIPR14_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR14_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR14.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR14_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR14_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR14_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR14_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR14_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR14_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff000000) >> 24
}

// NVIC.IPR15: Interrupt Priority Register
func (o *NVIC_Type) SetIPR15_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR15_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR15.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR15_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR15_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR15_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR15_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR15_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR15_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff000000) >> 24
}

// NVIC.IPR16: Interrupt Priority Register
func (o *NVIC_Type) SetIPR16_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR16_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR16.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR16_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR16_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR16_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR16_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR16_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR16_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff000000) >> 24
}

// NVIC.IPR17: Interrupt Priority Register
func (o *NVIC_Type) SetIPR17_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR17_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR17.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR17_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR17_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR17_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR17_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR17_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR17_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff000000) >> 24
}

// NVIC.IPR18: Interrupt Priority Register
func (o *NVIC_Type) SetIPR18_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR18_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR18.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR18_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR18_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR18_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR18_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR18_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR18_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff000000) >> 24
}

// NVIC.IPR19: Interrupt Priority Register
func (o *NVIC_Type) SetIPR19_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR19_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR19.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR19_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR19_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR19_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR19_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR19_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR19_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff000000) >> 24
}

// NVIC.IPR20: Interrupt Priority Register
func (o *NVIC_Type) SetIPR20_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR20_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR20.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR20_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR20_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR20_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR20_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR20_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR20_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff000000) >> 24
}

// Clock recovery system
type CRS_Type struct {
	CR   volatile.Register32 // 0x0
	CFGR volatile.Register32 // 0x4
	ISR  volatile.Register32 // 0x8
	ICR  volatile.Register32 // 0xC
}

// CRS.CR: control register
func (o *CRS_Type) SetCR_TRIM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f00)|value<<8)
}
func (o *CRS_Type) GetCR_TRIM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3f00) >> 8
}
func (o *CRS_Type) SetCR_SWSYNC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRS_Type) GetCR_SWSYNC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *CRS_Type) SetCR_AUTOTRIMEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *CRS_Type) GetCR_AUTOTRIMEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *CRS_Type) SetCR_CEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *CRS_Type) GetCR_CEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *CRS_Type) SetCR_ESYNCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *CRS_Type) GetCR_ESYNCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *CRS_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *CRS_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *CRS_Type) SetCR_SYNCWARNIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *CRS_Type) GetCR_SYNCWARNIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *CRS_Type) SetCR_SYNCOKIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRS_Type) GetCR_SYNCOKIE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// CRS.CFGR: configuration register
func (o *CRS_Type) SetCFGR_SYNCPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *CRS_Type) GetCFGR_SYNCPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}
func (o *CRS_Type) SetCFGR_SYNCSRC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x30000000)|value<<28)
}
func (o *CRS_Type) GetCFGR_SYNCSRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x30000000) >> 28
}
func (o *CRS_Type) SetCFGR_SYNCDIV(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7000000)|value<<24)
}
func (o *CRS_Type) GetCFGR_SYNCDIV() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7000000) >> 24
}
func (o *CRS_Type) SetCFGR_FELIM(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *CRS_Type) GetCFGR_FELIM() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xff0000) >> 16
}
func (o *CRS_Type) SetCFGR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xffff)|value)
}
func (o *CRS_Type) GetCFGR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0xffff
}

// CRS.ISR: interrupt and status register
func (o *CRS_Type) SetISR_FECAP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CRS_Type) GetISR_FECAP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xffff0000) >> 16
}
func (o *CRS_Type) SetISR_FEDIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *CRS_Type) GetISR_FEDIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *CRS_Type) SetISR_TRIMOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *CRS_Type) GetISR_TRIMOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *CRS_Type) SetISR_SYNCMISS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *CRS_Type) GetISR_SYNCMISS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *CRS_Type) SetISR_SYNCERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *CRS_Type) GetISR_SYNCERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *CRS_Type) SetISR_ESYNCF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *CRS_Type) GetISR_ESYNCF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *CRS_Type) SetISR_ERRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *CRS_Type) GetISR_ERRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *CRS_Type) SetISR_SYNCWARNF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *CRS_Type) GetISR_SYNCWARNF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *CRS_Type) SetISR_SYNCOKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *CRS_Type) GetISR_SYNCOKF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// CRS.ICR: interrupt flag clear register
func (o *CRS_Type) SetICR_ESYNCC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *CRS_Type) GetICR_ESYNCC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *CRS_Type) SetICR_ERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *CRS_Type) GetICR_ERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *CRS_Type) SetICR_SYNCWARNC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *CRS_Type) GetICR_SYNCWARNC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *CRS_Type) SetICR_SYNCOKC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *CRS_Type) GetICR_SYNCOKC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// Digital camera interface
type DCMI_Type struct {
	CR     volatile.Register32 // 0x0
	SR     volatile.Register32 // 0x4
	RIS    volatile.Register32 // 0x8
	IER    volatile.Register32 // 0xC
	MIS    volatile.Register32 // 0x10
	ICR    volatile.Register32 // 0x14
	ESCR   volatile.Register32 // 0x18
	ESUR   volatile.Register32 // 0x1C
	CWSTRT volatile.Register32 // 0x20
	CWSIZE volatile.Register32 // 0x24
	DR     volatile.Register32 // 0x28
}

// DCMI.CR: control register 1
func (o *DCMI_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DCMI_Type) GetCR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DCMI_Type) SetCR_EDM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *DCMI_Type) GetCR_EDM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *DCMI_Type) SetCR_FCRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *DCMI_Type) GetCR_FCRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *DCMI_Type) SetCR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DCMI_Type) GetCR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DCMI_Type) SetCR_HSPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DCMI_Type) GetCR_HSPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DCMI_Type) SetCR_PCKPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DCMI_Type) GetCR_PCKPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DCMI_Type) SetCR_ESS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetCR_ESS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetCR_JPEG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetCR_JPEG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetCR_CROP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetCR_CROP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetCR_CM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetCR_CM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetCR_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetCR_CAPTURE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DCMI_Type) SetCR_OELS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *DCMI_Type) GetCR_OELS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *DCMI_Type) SetCR_LSM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *DCMI_Type) GetCR_LSM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *DCMI_Type) SetCR_OEBS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DCMI_Type) GetCR_OEBS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *DCMI_Type) SetCR_BSM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DCMI_Type) GetCR_BSM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}

// DCMI.SR: status register
func (o *DCMI_Type) SetSR_FNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetSR_FNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetSR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetSR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetSR_HSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetSR_HSYNC() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// DCMI.RIS: raw interrupt status register
func (o *DCMI_Type) SetRIS_LINE_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetRIS_LINE_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetRIS_VSYNC_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetRIS_VSYNC_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetRIS_ERR_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetRIS_ERR_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetRIS_OVR_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetRIS_OVR_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetRIS_FRAME_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetRIS_FRAME_RIS() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}

// DCMI.IER: interrupt enable register
func (o *DCMI_Type) SetIER_LINE_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetIER_LINE_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetIER_VSYNC_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetIER_VSYNC_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetIER_ERR_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetIER_ERR_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetIER_OVR_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetIER_OVR_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetIER_FRAME_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetIER_FRAME_IE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// DCMI.MIS: masked interrupt status register
func (o *DCMI_Type) SetMIS_LINE_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetMIS_LINE_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetMIS_VSYNC_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetMIS_VSYNC_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetMIS_ERR_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetMIS_ERR_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetMIS_OVR_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetMIS_OVR_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetMIS_FRAME_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetMIS_FRAME_MIS() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}

// DCMI.ICR: interrupt clear register
func (o *DCMI_Type) SetICR_LINE_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetICR_LINE_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetICR_VSYNC_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetICR_VSYNC_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetICR_ERR_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetICR_ERR_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetICR_OVR_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetICR_OVR_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetICR_FRAME_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetICR_FRAME_ISC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// DCMI.ESCR: embedded synchronization code register
func (o *DCMI_Type) SetESCR_FEC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetESCR_FEC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetESCR_LEC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetESCR_LEC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetESCR_LSC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetESCR_LSC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetESCR_FSC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetESCR_FSC() uint32 {
	return volatile.LoadUint32(&o.ESCR.Reg) & 0xff
}

// DCMI.ESUR: embedded synchronization unmask register
func (o *DCMI_Type) SetESUR_FEU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetESUR_FEU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetESUR_LEU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetESUR_LEU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetESUR_LSU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetESUR_LSU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetESUR_FSU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetESUR_FSU() uint32 {
	return volatile.LoadUint32(&o.ESUR.Reg) & 0xff
}

// DCMI.CWSTRT: crop window start
func (o *DCMI_Type) SetCWSTRT_VST(value uint32) {
	volatile.StoreUint32(&o.CWSTRT.Reg, volatile.LoadUint32(&o.CWSTRT.Reg)&^(0x1fff0000)|value<<16)
}
func (o *DCMI_Type) GetCWSTRT_VST() uint32 {
	return (volatile.LoadUint32(&o.CWSTRT.Reg) & 0x1fff0000) >> 16
}
func (o *DCMI_Type) SetCWSTRT_HOFFCNT(value uint32) {
	volatile.StoreUint32(&o.CWSTRT.Reg, volatile.LoadUint32(&o.CWSTRT.Reg)&^(0x3fff)|value)
}
func (o *DCMI_Type) GetCWSTRT_HOFFCNT() uint32 {
	return volatile.LoadUint32(&o.CWSTRT.Reg) & 0x3fff
}

// DCMI.CWSIZE: crop window size
func (o *DCMI_Type) SetCWSIZE_VLINE(value uint32) {
	volatile.StoreUint32(&o.CWSIZE.Reg, volatile.LoadUint32(&o.CWSIZE.Reg)&^(0x3fff0000)|value<<16)
}
func (o *DCMI_Type) GetCWSIZE_VLINE() uint32 {
	return (volatile.LoadUint32(&o.CWSIZE.Reg) & 0x3fff0000) >> 16
}
func (o *DCMI_Type) SetCWSIZE_CAPCNT(value uint32) {
	volatile.StoreUint32(&o.CWSIZE.Reg, volatile.LoadUint32(&o.CWSIZE.Reg)&^(0x3fff)|value)
}
func (o *DCMI_Type) GetCWSIZE_CAPCNT() uint32 {
	return volatile.LoadUint32(&o.CWSIZE.Reg) & 0x3fff
}

// DCMI.DR: data register
func (o *DCMI_Type) SetDR_Byte3(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetDR_Byte3() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetDR_Byte2(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetDR_Byte2() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetDR_Byte1(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetDR_Byte1() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetDR_Byte0(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetDR_Byte0() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xff
}

// Hash processor
type HASH_Type struct {
	CR       volatile.Register32 // 0x0
	DIN      volatile.Register32 // 0x4
	STR      volatile.Register32 // 0x8
	HR0      volatile.Register32 // 0xC
	_        [16]byte
	IMR      volatile.Register32 // 0x20
	SR       volatile.Register32 // 0x24
	_        [208]byte
	CSR0     volatile.Register32 // 0xF8
	CSR1     volatile.Register32 // 0xFC
	CSR2     volatile.Register32 // 0x100
	CSR3     volatile.Register32 // 0x104
	CSR4     volatile.Register32 // 0x108
	CSR5     volatile.Register32 // 0x10C
	CSR6     volatile.Register32 // 0x110
	CSR7     volatile.Register32 // 0x114
	CSR8     volatile.Register32 // 0x118
	CSR9     volatile.Register32 // 0x11C
	CSR10    volatile.Register32 // 0x120
	CSR11    volatile.Register32 // 0x124
	CSR12    volatile.Register32 // 0x128
	CSR13    volatile.Register32 // 0x12C
	CSR14    volatile.Register32 // 0x130
	CSR15    volatile.Register32 // 0x134
	CSR16    volatile.Register32 // 0x138
	CSR17    volatile.Register32 // 0x13C
	CSR18    volatile.Register32 // 0x140
	CSR19    volatile.Register32 // 0x144
	CSR20    volatile.Register32 // 0x148
	CSR21    volatile.Register32 // 0x14C
	CSR22    volatile.Register32 // 0x150
	CSR23    volatile.Register32 // 0x154
	CSR24    volatile.Register32 // 0x158
	CSR25    volatile.Register32 // 0x15C
	CSR26    volatile.Register32 // 0x160
	CSR27    volatile.Register32 // 0x164
	CSR28    volatile.Register32 // 0x168
	CSR29    volatile.Register32 // 0x16C
	CSR30    volatile.Register32 // 0x170
	CSR31    volatile.Register32 // 0x174
	CSR32    volatile.Register32 // 0x178
	CSR33    volatile.Register32 // 0x17C
	CSR34    volatile.Register32 // 0x180
	CSR35    volatile.Register32 // 0x184
	CSR36    volatile.Register32 // 0x188
	CSR37    volatile.Register32 // 0x18C
	CSR38    volatile.Register32 // 0x190
	CSR39    volatile.Register32 // 0x194
	CSR40    volatile.Register32 // 0x198
	CSR41    volatile.Register32 // 0x19C
	CSR42    volatile.Register32 // 0x1A0
	CSR43    volatile.Register32 // 0x1A4
	CSR44    volatile.Register32 // 0x1A8
	CSR45    volatile.Register32 // 0x1AC
	CSR46    volatile.Register32 // 0x1B0
	CSR47    volatile.Register32 // 0x1B4
	CSR48    volatile.Register32 // 0x1B8
	CSR49    volatile.Register32 // 0x1BC
	CSR50    volatile.Register32 // 0x1C0
	CSR51    volatile.Register32 // 0x1C4
	CSR52    volatile.Register32 // 0x1C8
	CSR53    volatile.Register32 // 0x1CC
	_        [320]byte
	HASH_HR0 volatile.Register32 // 0x310
	HASH_HR1 volatile.Register32 // 0x314
	HASH_HR2 volatile.Register32 // 0x318
	HASH_HR3 volatile.Register32 // 0x31C
	HASH_HR4 volatile.Register32 // 0x320
	HASH_HR5 volatile.Register32 // 0x324
	HASH_HR6 volatile.Register32 // 0x328
	HASH_HR7 volatile.Register32 // 0x32C
}

// HASH.CR: control register
func (o *HASH_Type) SetCR_INIT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *HASH_Type) GetCR_INIT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *HASH_Type) SetCR_DMAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *HASH_Type) GetCR_DMAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *HASH_Type) SetCR_DATATYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30)|value<<4)
}
func (o *HASH_Type) GetCR_DATATYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30) >> 4
}
func (o *HASH_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *HASH_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *HASH_Type) SetCR_ALGO0(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *HASH_Type) GetCR_ALGO0() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *HASH_Type) SetCR_NBW(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *HASH_Type) GetCR_NBW() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *HASH_Type) SetCR_DINNE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *HASH_Type) GetCR_DINNE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *HASH_Type) SetCR_MDMAT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *HASH_Type) GetCR_MDMAT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *HASH_Type) SetCR_LKEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *HASH_Type) GetCR_LKEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *HASH_Type) SetCR_ALGO1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *HASH_Type) GetCR_ALGO1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}

// HASH.DIN: data input register
func (o *HASH_Type) SetDIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, value)
}
func (o *HASH_Type) GetDIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg)
}

// HASH.STR: start register
func (o *HASH_Type) SetSTR_DCAL(value uint32) {
	volatile.StoreUint32(&o.STR.Reg, volatile.LoadUint32(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *HASH_Type) GetSTR_DCAL() uint32 {
	return (volatile.LoadUint32(&o.STR.Reg) & 0x100) >> 8
}
func (o *HASH_Type) SetSTR_NBLW(value uint32) {
	volatile.StoreUint32(&o.STR.Reg, volatile.LoadUint32(&o.STR.Reg)&^(0x1f)|value)
}
func (o *HASH_Type) GetSTR_NBLW() uint32 {
	return volatile.LoadUint32(&o.STR.Reg) & 0x1f
}

// HASH.HR0: digest registers
func (o *HASH_Type) SetHR0(value uint32) {
	volatile.StoreUint32(&o.HR0.Reg, value)
}
func (o *HASH_Type) GetHR0() uint32 {
	return volatile.LoadUint32(&o.HR0.Reg)
}

// HASH.IMR: interrupt enable register
func (o *HASH_Type) SetIMR_DCIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *HASH_Type) GetIMR_DCIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *HASH_Type) SetIMR_DINIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *HASH_Type) GetIMR_DINIE() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// HASH.SR: status register
func (o *HASH_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *HASH_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *HASH_Type) SetSR_DMAS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *HASH_Type) GetSR_DMAS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *HASH_Type) SetSR_DCIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *HASH_Type) GetSR_DCIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *HASH_Type) SetSR_DINIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *HASH_Type) GetSR_DINIS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// HASH.CSR0: context swap registers
func (o *HASH_Type) SetCSR0(value uint32) {
	volatile.StoreUint32(&o.CSR0.Reg, value)
}
func (o *HASH_Type) GetCSR0() uint32 {
	return volatile.LoadUint32(&o.CSR0.Reg)
}

// HASH.CSR1: context swap registers
func (o *HASH_Type) SetCSR1(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, value)
}
func (o *HASH_Type) GetCSR1() uint32 {
	return volatile.LoadUint32(&o.CSR1.Reg)
}

// HASH.CSR2: context swap registers
func (o *HASH_Type) SetCSR2(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, value)
}
func (o *HASH_Type) GetCSR2() uint32 {
	return volatile.LoadUint32(&o.CSR2.Reg)
}

// HASH.CSR3: context swap registers
func (o *HASH_Type) SetCSR3(value uint32) {
	volatile.StoreUint32(&o.CSR3.Reg, value)
}
func (o *HASH_Type) GetCSR3() uint32 {
	return volatile.LoadUint32(&o.CSR3.Reg)
}

// HASH.CSR4: context swap registers
func (o *HASH_Type) SetCSR4(value uint32) {
	volatile.StoreUint32(&o.CSR4.Reg, value)
}
func (o *HASH_Type) GetCSR4() uint32 {
	return volatile.LoadUint32(&o.CSR4.Reg)
}

// HASH.CSR5: context swap registers
func (o *HASH_Type) SetCSR5(value uint32) {
	volatile.StoreUint32(&o.CSR5.Reg, value)
}
func (o *HASH_Type) GetCSR5() uint32 {
	return volatile.LoadUint32(&o.CSR5.Reg)
}

// HASH.CSR6: context swap registers
func (o *HASH_Type) SetCSR6(value uint32) {
	volatile.StoreUint32(&o.CSR6.Reg, value)
}
func (o *HASH_Type) GetCSR6() uint32 {
	return volatile.LoadUint32(&o.CSR6.Reg)
}

// HASH.CSR7: context swap registers
func (o *HASH_Type) SetCSR7(value uint32) {
	volatile.StoreUint32(&o.CSR7.Reg, value)
}
func (o *HASH_Type) GetCSR7() uint32 {
	return volatile.LoadUint32(&o.CSR7.Reg)
}

// HASH.CSR8: context swap registers
func (o *HASH_Type) SetCSR8(value uint32) {
	volatile.StoreUint32(&o.CSR8.Reg, value)
}
func (o *HASH_Type) GetCSR8() uint32 {
	return volatile.LoadUint32(&o.CSR8.Reg)
}

// HASH.CSR9: context swap registers
func (o *HASH_Type) SetCSR9(value uint32) {
	volatile.StoreUint32(&o.CSR9.Reg, value)
}
func (o *HASH_Type) GetCSR9() uint32 {
	return volatile.LoadUint32(&o.CSR9.Reg)
}

// HASH.CSR10: context swap registers
func (o *HASH_Type) SetCSR10(value uint32) {
	volatile.StoreUint32(&o.CSR10.Reg, value)
}
func (o *HASH_Type) GetCSR10() uint32 {
	return volatile.LoadUint32(&o.CSR10.Reg)
}

// HASH.CSR11: context swap registers
func (o *HASH_Type) SetCSR11(value uint32) {
	volatile.StoreUint32(&o.CSR11.Reg, value)
}
func (o *HASH_Type) GetCSR11() uint32 {
	return volatile.LoadUint32(&o.CSR11.Reg)
}

// HASH.CSR12: context swap registers
func (o *HASH_Type) SetCSR12(value uint32) {
	volatile.StoreUint32(&o.CSR12.Reg, value)
}
func (o *HASH_Type) GetCSR12() uint32 {
	return volatile.LoadUint32(&o.CSR12.Reg)
}

// HASH.CSR13: context swap registers
func (o *HASH_Type) SetCSR13(value uint32) {
	volatile.StoreUint32(&o.CSR13.Reg, value)
}
func (o *HASH_Type) GetCSR13() uint32 {
	return volatile.LoadUint32(&o.CSR13.Reg)
}

// HASH.CSR14: context swap registers
func (o *HASH_Type) SetCSR14(value uint32) {
	volatile.StoreUint32(&o.CSR14.Reg, value)
}
func (o *HASH_Type) GetCSR14() uint32 {
	return volatile.LoadUint32(&o.CSR14.Reg)
}

// HASH.CSR15: context swap registers
func (o *HASH_Type) SetCSR15(value uint32) {
	volatile.StoreUint32(&o.CSR15.Reg, value)
}
func (o *HASH_Type) GetCSR15() uint32 {
	return volatile.LoadUint32(&o.CSR15.Reg)
}

// HASH.CSR16: context swap registers
func (o *HASH_Type) SetCSR16(value uint32) {
	volatile.StoreUint32(&o.CSR16.Reg, value)
}
func (o *HASH_Type) GetCSR16() uint32 {
	return volatile.LoadUint32(&o.CSR16.Reg)
}

// HASH.CSR17: context swap registers
func (o *HASH_Type) SetCSR17(value uint32) {
	volatile.StoreUint32(&o.CSR17.Reg, value)
}
func (o *HASH_Type) GetCSR17() uint32 {
	return volatile.LoadUint32(&o.CSR17.Reg)
}

// HASH.CSR18: context swap registers
func (o *HASH_Type) SetCSR18(value uint32) {
	volatile.StoreUint32(&o.CSR18.Reg, value)
}
func (o *HASH_Type) GetCSR18() uint32 {
	return volatile.LoadUint32(&o.CSR18.Reg)
}

// HASH.CSR19: context swap registers
func (o *HASH_Type) SetCSR19(value uint32) {
	volatile.StoreUint32(&o.CSR19.Reg, value)
}
func (o *HASH_Type) GetCSR19() uint32 {
	return volatile.LoadUint32(&o.CSR19.Reg)
}

// HASH.CSR20: context swap registers
func (o *HASH_Type) SetCSR20(value uint32) {
	volatile.StoreUint32(&o.CSR20.Reg, value)
}
func (o *HASH_Type) GetCSR20() uint32 {
	return volatile.LoadUint32(&o.CSR20.Reg)
}

// HASH.CSR21: context swap registers
func (o *HASH_Type) SetCSR21(value uint32) {
	volatile.StoreUint32(&o.CSR21.Reg, value)
}
func (o *HASH_Type) GetCSR21() uint32 {
	return volatile.LoadUint32(&o.CSR21.Reg)
}

// HASH.CSR22: context swap registers
func (o *HASH_Type) SetCSR22(value uint32) {
	volatile.StoreUint32(&o.CSR22.Reg, value)
}
func (o *HASH_Type) GetCSR22() uint32 {
	return volatile.LoadUint32(&o.CSR22.Reg)
}

// HASH.CSR23: context swap registers
func (o *HASH_Type) SetCSR23(value uint32) {
	volatile.StoreUint32(&o.CSR23.Reg, value)
}
func (o *HASH_Type) GetCSR23() uint32 {
	return volatile.LoadUint32(&o.CSR23.Reg)
}

// HASH.CSR24: context swap registers
func (o *HASH_Type) SetCSR24(value uint32) {
	volatile.StoreUint32(&o.CSR24.Reg, value)
}
func (o *HASH_Type) GetCSR24() uint32 {
	return volatile.LoadUint32(&o.CSR24.Reg)
}

// HASH.CSR25: context swap registers
func (o *HASH_Type) SetCSR25(value uint32) {
	volatile.StoreUint32(&o.CSR25.Reg, value)
}
func (o *HASH_Type) GetCSR25() uint32 {
	return volatile.LoadUint32(&o.CSR25.Reg)
}

// HASH.CSR26: context swap registers
func (o *HASH_Type) SetCSR26(value uint32) {
	volatile.StoreUint32(&o.CSR26.Reg, value)
}
func (o *HASH_Type) GetCSR26() uint32 {
	return volatile.LoadUint32(&o.CSR26.Reg)
}

// HASH.CSR27: context swap registers
func (o *HASH_Type) SetCSR27(value uint32) {
	volatile.StoreUint32(&o.CSR27.Reg, value)
}
func (o *HASH_Type) GetCSR27() uint32 {
	return volatile.LoadUint32(&o.CSR27.Reg)
}

// HASH.CSR28: context swap registers
func (o *HASH_Type) SetCSR28(value uint32) {
	volatile.StoreUint32(&o.CSR28.Reg, value)
}
func (o *HASH_Type) GetCSR28() uint32 {
	return volatile.LoadUint32(&o.CSR28.Reg)
}

// HASH.CSR29: context swap registers
func (o *HASH_Type) SetCSR29(value uint32) {
	volatile.StoreUint32(&o.CSR29.Reg, value)
}
func (o *HASH_Type) GetCSR29() uint32 {
	return volatile.LoadUint32(&o.CSR29.Reg)
}

// HASH.CSR30: context swap registers
func (o *HASH_Type) SetCSR30(value uint32) {
	volatile.StoreUint32(&o.CSR30.Reg, value)
}
func (o *HASH_Type) GetCSR30() uint32 {
	return volatile.LoadUint32(&o.CSR30.Reg)
}

// HASH.CSR31: context swap registers
func (o *HASH_Type) SetCSR31(value uint32) {
	volatile.StoreUint32(&o.CSR31.Reg, value)
}
func (o *HASH_Type) GetCSR31() uint32 {
	return volatile.LoadUint32(&o.CSR31.Reg)
}

// HASH.CSR32: context swap registers
func (o *HASH_Type) SetCSR32(value uint32) {
	volatile.StoreUint32(&o.CSR32.Reg, value)
}
func (o *HASH_Type) GetCSR32() uint32 {
	return volatile.LoadUint32(&o.CSR32.Reg)
}

// HASH.CSR33: context swap registers
func (o *HASH_Type) SetCSR33(value uint32) {
	volatile.StoreUint32(&o.CSR33.Reg, value)
}
func (o *HASH_Type) GetCSR33() uint32 {
	return volatile.LoadUint32(&o.CSR33.Reg)
}

// HASH.CSR34: context swap registers
func (o *HASH_Type) SetCSR34(value uint32) {
	volatile.StoreUint32(&o.CSR34.Reg, value)
}
func (o *HASH_Type) GetCSR34() uint32 {
	return volatile.LoadUint32(&o.CSR34.Reg)
}

// HASH.CSR35: context swap registers
func (o *HASH_Type) SetCSR35(value uint32) {
	volatile.StoreUint32(&o.CSR35.Reg, value)
}
func (o *HASH_Type) GetCSR35() uint32 {
	return volatile.LoadUint32(&o.CSR35.Reg)
}

// HASH.CSR36: context swap registers
func (o *HASH_Type) SetCSR36(value uint32) {
	volatile.StoreUint32(&o.CSR36.Reg, value)
}
func (o *HASH_Type) GetCSR36() uint32 {
	return volatile.LoadUint32(&o.CSR36.Reg)
}

// HASH.CSR37: context swap registers
func (o *HASH_Type) SetCSR37(value uint32) {
	volatile.StoreUint32(&o.CSR37.Reg, value)
}
func (o *HASH_Type) GetCSR37() uint32 {
	return volatile.LoadUint32(&o.CSR37.Reg)
}

// HASH.CSR38: context swap registers
func (o *HASH_Type) SetCSR38(value uint32) {
	volatile.StoreUint32(&o.CSR38.Reg, value)
}
func (o *HASH_Type) GetCSR38() uint32 {
	return volatile.LoadUint32(&o.CSR38.Reg)
}

// HASH.CSR39: context swap registers
func (o *HASH_Type) SetCSR39(value uint32) {
	volatile.StoreUint32(&o.CSR39.Reg, value)
}
func (o *HASH_Type) GetCSR39() uint32 {
	return volatile.LoadUint32(&o.CSR39.Reg)
}

// HASH.CSR40: context swap registers
func (o *HASH_Type) SetCSR40(value uint32) {
	volatile.StoreUint32(&o.CSR40.Reg, value)
}
func (o *HASH_Type) GetCSR40() uint32 {
	return volatile.LoadUint32(&o.CSR40.Reg)
}

// HASH.CSR41: context swap registers
func (o *HASH_Type) SetCSR41(value uint32) {
	volatile.StoreUint32(&o.CSR41.Reg, value)
}
func (o *HASH_Type) GetCSR41() uint32 {
	return volatile.LoadUint32(&o.CSR41.Reg)
}

// HASH.CSR42: context swap registers
func (o *HASH_Type) SetCSR42(value uint32) {
	volatile.StoreUint32(&o.CSR42.Reg, value)
}
func (o *HASH_Type) GetCSR42() uint32 {
	return volatile.LoadUint32(&o.CSR42.Reg)
}

// HASH.CSR43: context swap registers
func (o *HASH_Type) SetCSR43(value uint32) {
	volatile.StoreUint32(&o.CSR43.Reg, value)
}
func (o *HASH_Type) GetCSR43() uint32 {
	return volatile.LoadUint32(&o.CSR43.Reg)
}

// HASH.CSR44: context swap registers
func (o *HASH_Type) SetCSR44(value uint32) {
	volatile.StoreUint32(&o.CSR44.Reg, value)
}
func (o *HASH_Type) GetCSR44() uint32 {
	return volatile.LoadUint32(&o.CSR44.Reg)
}

// HASH.CSR45: context swap registers
func (o *HASH_Type) SetCSR45(value uint32) {
	volatile.StoreUint32(&o.CSR45.Reg, value)
}
func (o *HASH_Type) GetCSR45() uint32 {
	return volatile.LoadUint32(&o.CSR45.Reg)
}

// HASH.CSR46: context swap registers
func (o *HASH_Type) SetCSR46(value uint32) {
	volatile.StoreUint32(&o.CSR46.Reg, value)
}
func (o *HASH_Type) GetCSR46() uint32 {
	return volatile.LoadUint32(&o.CSR46.Reg)
}

// HASH.CSR47: context swap registers
func (o *HASH_Type) SetCSR47(value uint32) {
	volatile.StoreUint32(&o.CSR47.Reg, value)
}
func (o *HASH_Type) GetCSR47() uint32 {
	return volatile.LoadUint32(&o.CSR47.Reg)
}

// HASH.CSR48: context swap registers
func (o *HASH_Type) SetCSR48(value uint32) {
	volatile.StoreUint32(&o.CSR48.Reg, value)
}
func (o *HASH_Type) GetCSR48() uint32 {
	return volatile.LoadUint32(&o.CSR48.Reg)
}

// HASH.CSR49: context swap registers
func (o *HASH_Type) SetCSR49(value uint32) {
	volatile.StoreUint32(&o.CSR49.Reg, value)
}
func (o *HASH_Type) GetCSR49() uint32 {
	return volatile.LoadUint32(&o.CSR49.Reg)
}

// HASH.CSR50: context swap registers
func (o *HASH_Type) SetCSR50(value uint32) {
	volatile.StoreUint32(&o.CSR50.Reg, value)
}
func (o *HASH_Type) GetCSR50() uint32 {
	return volatile.LoadUint32(&o.CSR50.Reg)
}

// HASH.CSR51: context swap registers
func (o *HASH_Type) SetCSR51(value uint32) {
	volatile.StoreUint32(&o.CSR51.Reg, value)
}
func (o *HASH_Type) GetCSR51() uint32 {
	return volatile.LoadUint32(&o.CSR51.Reg)
}

// HASH.CSR52: context swap registers
func (o *HASH_Type) SetCSR52(value uint32) {
	volatile.StoreUint32(&o.CSR52.Reg, value)
}
func (o *HASH_Type) GetCSR52() uint32 {
	return volatile.LoadUint32(&o.CSR52.Reg)
}

// HASH.CSR53: context swap registers
func (o *HASH_Type) SetCSR53(value uint32) {
	volatile.StoreUint32(&o.CSR53.Reg, value)
}
func (o *HASH_Type) GetCSR53() uint32 {
	return volatile.LoadUint32(&o.CSR53.Reg)
}

// HASH.HASH_HR0: HASH digest register
func (o *HASH_Type) SetHASH_HR0(value uint32) {
	volatile.StoreUint32(&o.HASH_HR0.Reg, value)
}
func (o *HASH_Type) GetHASH_HR0() uint32 {
	return volatile.LoadUint32(&o.HASH_HR0.Reg)
}

// HASH.HASH_HR1: HASH digest register
func (o *HASH_Type) SetHASH_HR1(value uint32) {
	volatile.StoreUint32(&o.HASH_HR1.Reg, value)
}
func (o *HASH_Type) GetHASH_HR1() uint32 {
	return volatile.LoadUint32(&o.HASH_HR1.Reg)
}

// HASH.HASH_HR2: HASH digest register
func (o *HASH_Type) SetHASH_HR2(value uint32) {
	volatile.StoreUint32(&o.HASH_HR2.Reg, value)
}
func (o *HASH_Type) GetHASH_HR2() uint32 {
	return volatile.LoadUint32(&o.HASH_HR2.Reg)
}

// HASH.HASH_HR3: HASH digest register
func (o *HASH_Type) SetHASH_HR3(value uint32) {
	volatile.StoreUint32(&o.HASH_HR3.Reg, value)
}
func (o *HASH_Type) GetHASH_HR3() uint32 {
	return volatile.LoadUint32(&o.HASH_HR3.Reg)
}

// HASH.HASH_HR4: HASH digest register
func (o *HASH_Type) SetHASH_HR4(value uint32) {
	volatile.StoreUint32(&o.HASH_HR4.Reg, value)
}
func (o *HASH_Type) GetHASH_HR4() uint32 {
	return volatile.LoadUint32(&o.HASH_HR4.Reg)
}

// HASH.HASH_HR5: HASH digest register
func (o *HASH_Type) SetHASH_HR5(value uint32) {
	volatile.StoreUint32(&o.HASH_HR5.Reg, value)
}
func (o *HASH_Type) GetHASH_HR5() uint32 {
	return volatile.LoadUint32(&o.HASH_HR5.Reg)
}

// HASH.HASH_HR6: HASH digest register
func (o *HASH_Type) SetHASH_HR6(value uint32) {
	volatile.StoreUint32(&o.HASH_HR6.Reg, value)
}
func (o *HASH_Type) GetHASH_HR6() uint32 {
	return volatile.LoadUint32(&o.HASH_HR6.Reg)
}

// HASH.HASH_HR7: HASH digest register
func (o *HASH_Type) SetHASH_HR7(value uint32) {
	volatile.StoreUint32(&o.HASH_HR7.Reg, value)
}
func (o *HASH_Type) GetHASH_HR7() uint32 {
	return volatile.LoadUint32(&o.HASH_HR7.Reg)
}

// DMA2D controller
type DMA2D_Type struct {
	CR      volatile.Register32 // 0x0
	ISR     volatile.Register32 // 0x4
	IFCR    volatile.Register32 // 0x8
	FGMAR   volatile.Register32 // 0xC
	FGOR    volatile.Register32 // 0x10
	BGMAR   volatile.Register32 // 0x14
	BGOR    volatile.Register32 // 0x18
	FGPFCCR volatile.Register32 // 0x1C
	FGCOLR  volatile.Register32 // 0x20
	BGPFCCR volatile.Register32 // 0x24
	BGCOLR  volatile.Register32 // 0x28
	FGCMAR  volatile.Register32 // 0x2C
	BGCMAR  volatile.Register32 // 0x30
	OPFCCR  volatile.Register32 // 0x34
	OCOLR   volatile.Register32 // 0x38
	OMAR    volatile.Register32 // 0x3C
	OOR     volatile.Register32 // 0x40
	NLR     volatile.Register32 // 0x44
	LWR     volatile.Register32 // 0x48
	AMTCR   volatile.Register32 // 0x4C
	_       [944]byte
	FGCLUT  volatile.Register32 // 0x400
	_       [1020]byte
	BGCLUT  volatile.Register32 // 0x800
}

// DMA2D.CR: control register
func (o *DMA2D_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetCR_CEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA2D_Type) GetCR_CEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DMA2D_Type) SetCR_CTCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA2D_Type) GetCR_CTCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DMA2D_Type) SetCR_CAEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *DMA2D_Type) GetCR_CAEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *DMA2D_Type) SetCR_TWIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *DMA2D_Type) GetCR_TWIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *DMA2D_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *DMA2D_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *DMA2D_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DMA2D_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DMA2D_Type) SetCR_ABORT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetCR_ABORT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetCR_SUSP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetCR_SUSP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DMA2D.ISR: Interrupt Status Register
func (o *DMA2D_Type) SetISR_CEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetISR_CEIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetISR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetISR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetISR_CAEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA2D_Type) GetISR_CAEIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DMA2D_Type) SetISR_TWIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetISR_TWIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetISR_TCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetISR_TCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetISR_TEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetISR_TEIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// DMA2D.IFCR: interrupt flag clear register
func (o *DMA2D_Type) SetIFCR_CCEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetIFCR_CCEIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetIFCR_CCTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetIFCR_CCTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetIFCR_CAECIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA2D_Type) GetIFCR_CAECIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *DMA2D_Type) SetIFCR_CTWIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetIFCR_CTWIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetIFCR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetIFCR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetIFCR_CTEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetIFCR_CTEIF() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}

// DMA2D.FGMAR: foreground memory address register
func (o *DMA2D_Type) SetFGMAR(value uint32) {
	volatile.StoreUint32(&o.FGMAR.Reg, value)
}
func (o *DMA2D_Type) GetFGMAR() uint32 {
	return volatile.LoadUint32(&o.FGMAR.Reg)
}

// DMA2D.FGOR: foreground offset register
func (o *DMA2D_Type) SetFGOR_LO(value uint32) {
	volatile.StoreUint32(&o.FGOR.Reg, volatile.LoadUint32(&o.FGOR.Reg)&^(0x3fff)|value)
}
func (o *DMA2D_Type) GetFGOR_LO() uint32 {
	return volatile.LoadUint32(&o.FGOR.Reg) & 0x3fff
}

// DMA2D.BGMAR: background memory address register
func (o *DMA2D_Type) SetBGMAR(value uint32) {
	volatile.StoreUint32(&o.BGMAR.Reg, value)
}
func (o *DMA2D_Type) GetBGMAR() uint32 {
	return volatile.LoadUint32(&o.BGMAR.Reg)
}

// DMA2D.BGOR: background offset register
func (o *DMA2D_Type) SetBGOR_LO(value uint32) {
	volatile.StoreUint32(&o.BGOR.Reg, volatile.LoadUint32(&o.BGOR.Reg)&^(0x3fff)|value)
}
func (o *DMA2D_Type) GetBGOR_LO() uint32 {
	return volatile.LoadUint32(&o.BGOR.Reg) & 0x3fff
}

// DMA2D.FGPFCCR: foreground PFC control register
func (o *DMA2D_Type) SetFGPFCCR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetFGPFCCR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetFGPFCCR_AM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetFGPFCCR_AM() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetFGPFCCR_CS(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGPFCCR_CS() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGPFCCR_START(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetFGPFCCR_START() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetFGPFCCR_CCM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetFGPFCCR_CCM() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetFGPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xf)|value)
}
func (o *DMA2D_Type) GetFGPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xf
}
func (o *DMA2D_Type) SetFGPFCCR_RBS(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA2D_Type) GetFGPFCCR_RBS() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x200000) >> 21
}
func (o *DMA2D_Type) SetFGPFCCR_AI(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA2D_Type) GetFGPFCCR_AI() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x100000) >> 20
}

// DMA2D.FGCOLR: foreground color register
func (o *DMA2D_Type) SetFGCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetFGCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetFGCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetFGCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff
}

// DMA2D.BGPFCCR: background PFC control register
func (o *DMA2D_Type) SetBGPFCCR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetBGPFCCR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetBGPFCCR_AM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetBGPFCCR_AM() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetBGPFCCR_CS(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGPFCCR_CS() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGPFCCR_START(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetBGPFCCR_START() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetBGPFCCR_CCM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetBGPFCCR_CCM() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetBGPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xf)|value)
}
func (o *DMA2D_Type) GetBGPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xf
}
func (o *DMA2D_Type) SetBGPFCCR_RBS(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA2D_Type) GetBGPFCCR_RBS() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x200000) >> 21
}
func (o *DMA2D_Type) SetBGPFCCR_AI(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA2D_Type) GetBGPFCCR_AI() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x100000) >> 20
}

// DMA2D.BGCOLR: background color register
func (o *DMA2D_Type) SetBGCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetBGCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetBGCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetBGCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff
}

// DMA2D.FGCMAR: foreground CLUT memory address register
func (o *DMA2D_Type) SetFGCMAR(value uint32) {
	volatile.StoreUint32(&o.FGCMAR.Reg, value)
}
func (o *DMA2D_Type) GetFGCMAR() uint32 {
	return volatile.LoadUint32(&o.FGCMAR.Reg)
}

// DMA2D.BGCMAR: background CLUT memory address register
func (o *DMA2D_Type) SetBGCMAR(value uint32) {
	volatile.StoreUint32(&o.BGCMAR.Reg, value)
}
func (o *DMA2D_Type) GetBGCMAR() uint32 {
	return volatile.LoadUint32(&o.BGCMAR.Reg)
}

// DMA2D.OPFCCR: output PFC control register
func (o *DMA2D_Type) SetOPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x7)|value)
}
func (o *DMA2D_Type) GetOPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.OPFCCR.Reg) & 0x7
}
func (o *DMA2D_Type) SetOPFCCR_RBS(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA2D_Type) GetOPFCCR_RBS() uint32 {
	return (volatile.LoadUint32(&o.OPFCCR.Reg) & 0x200000) >> 21
}
func (o *DMA2D_Type) SetOPFCCR_AI(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA2D_Type) GetOPFCCR_AI() uint32 {
	return (volatile.LoadUint32(&o.OPFCCR.Reg) & 0x100000) >> 20
}

// DMA2D.OCOLR: output color register
func (o *DMA2D_Type) SetOCOLR_APLHA(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetOCOLR_APLHA() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetOCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetOCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetOCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetOCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetOCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetOCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.OCOLR.Reg) & 0xff
}

// DMA2D.OMAR: output memory address register
func (o *DMA2D_Type) SetOMAR(value uint32) {
	volatile.StoreUint32(&o.OMAR.Reg, value)
}
func (o *DMA2D_Type) GetOMAR() uint32 {
	return volatile.LoadUint32(&o.OMAR.Reg)
}

// DMA2D.OOR: output offset register
func (o *DMA2D_Type) SetOOR_LO(value uint32) {
	volatile.StoreUint32(&o.OOR.Reg, volatile.LoadUint32(&o.OOR.Reg)&^(0x3fff)|value)
}
func (o *DMA2D_Type) GetOOR_LO() uint32 {
	return volatile.LoadUint32(&o.OOR.Reg) & 0x3fff
}

// DMA2D.NLR: number of line register
func (o *DMA2D_Type) SetNLR_PL(value uint32) {
	volatile.StoreUint32(&o.NLR.Reg, volatile.LoadUint32(&o.NLR.Reg)&^(0x3fff0000)|value<<16)
}
func (o *DMA2D_Type) GetNLR_PL() uint32 {
	return (volatile.LoadUint32(&o.NLR.Reg) & 0x3fff0000) >> 16
}
func (o *DMA2D_Type) SetNLR_NL(value uint32) {
	volatile.StoreUint32(&o.NLR.Reg, volatile.LoadUint32(&o.NLR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetNLR_NL() uint32 {
	return volatile.LoadUint32(&o.NLR.Reg) & 0xffff
}

// DMA2D.LWR: line watermark register
func (o *DMA2D_Type) SetLWR_LW(value uint32) {
	volatile.StoreUint32(&o.LWR.Reg, volatile.LoadUint32(&o.LWR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetLWR_LW() uint32 {
	return volatile.LoadUint32(&o.LWR.Reg) & 0xffff
}

// DMA2D.AMTCR: AHB master timer configuration register
func (o *DMA2D_Type) SetAMTCR_DT(value uint32) {
	volatile.StoreUint32(&o.AMTCR.Reg, volatile.LoadUint32(&o.AMTCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetAMTCR_DT() uint32 {
	return (volatile.LoadUint32(&o.AMTCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetAMTCR_EN(value uint32) {
	volatile.StoreUint32(&o.AMTCR.Reg, volatile.LoadUint32(&o.AMTCR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetAMTCR_EN() uint32 {
	return volatile.LoadUint32(&o.AMTCR.Reg) & 0x1
}

// DMA2D.FGCLUT: FGCLUT
func (o *DMA2D_Type) SetFGCLUT_APLHA(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetFGCLUT_APLHA() uint32 {
	return (volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetFGCLUT_RED(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetFGCLUT_RED() uint32 {
	return (volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetFGCLUT_GREEN(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGCLUT_GREEN() uint32 {
	return (volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGCLUT_BLUE(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetFGCLUT_BLUE() uint32 {
	return volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff
}

// DMA2D.BGCLUT: BGCLUT
func (o *DMA2D_Type) SetBGCLUT_APLHA(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetBGCLUT_APLHA() uint32 {
	return (volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetBGCLUT_RED(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetBGCLUT_RED() uint32 {
	return (volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetBGCLUT_GREEN(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGCLUT_GREEN() uint32 {
	return (volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGCLUT_BLUE(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetBGCLUT_BLUE() uint32 {
	return volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff
}

// DSI Host
type DSI_Type struct {
	VR      volatile.Register32 // 0x0
	CR      volatile.Register32 // 0x4
	CCR     volatile.Register32 // 0x8
	LVCIDR  volatile.Register32 // 0xC
	LCOLCR  volatile.Register32 // 0x10
	LPCR    volatile.Register32 // 0x14
	LPMCR   volatile.Register32 // 0x18
	_       [16]byte
	PCR     volatile.Register32 // 0x2C
	GVCIDR  volatile.Register32 // 0x30
	MCR     volatile.Register32 // 0x34
	VMCR    volatile.Register32 // 0x38
	VPCR    volatile.Register32 // 0x3C
	VCCR    volatile.Register32 // 0x40
	VNPCR   volatile.Register32 // 0x44
	VHSACR  volatile.Register32 // 0x48
	VHBPCR  volatile.Register32 // 0x4C
	VLCR    volatile.Register32 // 0x50
	VVSACR  volatile.Register32 // 0x54
	VVBPCR  volatile.Register32 // 0x58
	VVFPCR  volatile.Register32 // 0x5C
	VVACR   volatile.Register32 // 0x60
	LCCR    volatile.Register32 // 0x64
	CMCR    volatile.Register32 // 0x68
	GHCR    volatile.Register32 // 0x6C
	GPDR    volatile.Register32 // 0x70
	GPSR    volatile.Register32 // 0x74
	TCCR0   volatile.Register32 // 0x78
	TCCR1   volatile.Register32 // 0x7C
	TCCR2   volatile.Register32 // 0x80
	TCCR3   volatile.Register32 // 0x84
	TCCR4   volatile.Register32 // 0x88
	TCCR5   volatile.Register32 // 0x8C
	_       [4]byte
	CLCR    volatile.Register32 // 0x94
	CLTCR   volatile.Register32 // 0x98
	DLTRC   volatile.Register32 // 0x9C
	PCTLR   volatile.Register32 // 0xA0
	PCONFR  volatile.Register32 // 0xA4
	PUCR    volatile.Register32 // 0xA8
	PTTCR   volatile.Register32 // 0xAC
	PSR     volatile.Register32 // 0xB0
	_       [8]byte
	ISR0    volatile.Register32 // 0xBC
	ISR1    volatile.Register32 // 0xC0
	IER0    volatile.Register32 // 0xC4
	IER1    volatile.Register32 // 0xC8
	_       [12]byte
	FIR0    volatile.Register32 // 0xD8
	FIR1    volatile.Register32 // 0xDC
	_       [32]byte
	VSCR    volatile.Register32 // 0x100
	_       [8]byte
	LCVCIDR volatile.Register32 // 0x10C
	LCCCR   volatile.Register32 // 0x110
	_       [4]byte
	LPMCCR  volatile.Register32 // 0x118
	_       [28]byte
	VMCCR   volatile.Register32 // 0x138
	VPCCR   volatile.Register32 // 0x13C
	VCCCR   volatile.Register32 // 0x140
	VNPCCR  volatile.Register32 // 0x144
	VHSACCR volatile.Register32 // 0x148
	VHBPCCR volatile.Register32 // 0x14C
	VLCCR   volatile.Register32 // 0x150
	VVSACCR volatile.Register32 // 0x154
	VVBPCCR volatile.Register32 // 0x158
	VVFPCCR volatile.Register32 // 0x15C
	VVACCR  volatile.Register32 // 0x160
	_       [668]byte
	WCFGR   volatile.Register32 // 0x400
	WCR     volatile.Register32 // 0x404
	WIER    volatile.Register32 // 0x408
	WISR    volatile.Register32 // 0x40C
	WIFCR   volatile.Register32 // 0x410
	_       [4]byte
	WPCR0   volatile.Register32 // 0x418
	WPCR1   volatile.Register32 // 0x41C
	WPCR2   volatile.Register32 // 0x420
	WPCR3   volatile.Register32 // 0x424
	WPCR4   volatile.Register32 // 0x428
	_       [4]byte
	WRPCR   volatile.Register32 // 0x430
}

// DSI.VR: DSI Host Version Register
func (o *DSI_Type) SetVR(value uint32) {
	volatile.StoreUint32(&o.VR.Reg, value)
}
func (o *DSI_Type) GetVR() uint32 {
	return volatile.LoadUint32(&o.VR.Reg)
}

// DSI.CR: DSI Host Control Register
func (o *DSI_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DSI.CCR: DSI HOST Clock Control Register
func (o *DSI_Type) SetCCR_TXECKDIV(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetCCR_TXECKDIV() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0xff
}
func (o *DSI_Type) SetCCR_TOCKDIV(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetCCR_TOCKDIV() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xff00) >> 8
}

// DSI.LVCIDR: DSI Host LTDC VCID Register
func (o *DSI_Type) SetLVCIDR_VCID(value uint32) {
	volatile.StoreUint32(&o.LVCIDR.Reg, volatile.LoadUint32(&o.LVCIDR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetLVCIDR_VCID() uint32 {
	return volatile.LoadUint32(&o.LVCIDR.Reg) & 0x3
}

// DSI.LCOLCR: DSI Host LTDC Color Coding Register
func (o *DSI_Type) SetLCOLCR_COLC(value uint32) {
	volatile.StoreUint32(&o.LCOLCR.Reg, volatile.LoadUint32(&o.LCOLCR.Reg)&^(0xf)|value)
}
func (o *DSI_Type) GetLCOLCR_COLC() uint32 {
	return volatile.LoadUint32(&o.LCOLCR.Reg) & 0xf
}
func (o *DSI_Type) SetLCOLCR_LPE(value uint32) {
	volatile.StoreUint32(&o.LCOLCR.Reg, volatile.LoadUint32(&o.LCOLCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetLCOLCR_LPE() uint32 {
	return (volatile.LoadUint32(&o.LCOLCR.Reg) & 0x100) >> 8
}

// DSI.LPCR: DSI Host LTDC Polarity Configuration Register
func (o *DSI_Type) SetLPCR_DEP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetLPCR_DEP() uint32 {
	return volatile.LoadUint32(&o.LPCR.Reg) & 0x1
}
func (o *DSI_Type) SetLPCR_VSP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetLPCR_VSP() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetLPCR_HSP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetLPCR_HSP() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x4) >> 2
}

// DSI.LPMCR: DSI Host Low-Power mode Configuration Register
func (o *DSI_Type) SetLPMCR_VLPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCR.Reg, volatile.LoadUint32(&o.LPMCR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetLPMCR_VLPSIZE() uint32 {
	return volatile.LoadUint32(&o.LPMCR.Reg) & 0xff
}
func (o *DSI_Type) SetLPMCR_LPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCR.Reg, volatile.LoadUint32(&o.LPMCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetLPMCR_LPSIZE() uint32 {
	return (volatile.LoadUint32(&o.LPMCR.Reg) & 0xff0000) >> 16
}

// DSI.PCR: DSI Host Protocol Configuration Register
func (o *DSI_Type) SetPCR_ETTXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetPCR_ETTXE() uint32 {
	return volatile.LoadUint32(&o.PCR.Reg) & 0x1
}
func (o *DSI_Type) SetPCR_ETRXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPCR_ETRXE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPCR_BTAE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPCR_BTAE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetPCR_ECCRXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetPCR_ECCRXE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetPCR_CRCRXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetPCR_CRCRXE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x10) >> 4
}

// DSI.GVCIDR: DSI Host Generic VCID Register
func (o *DSI_Type) SetGVCIDR_VCID(value uint32) {
	volatile.StoreUint32(&o.GVCIDR.Reg, volatile.LoadUint32(&o.GVCIDR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetGVCIDR_VCID() uint32 {
	return volatile.LoadUint32(&o.GVCIDR.Reg) & 0x3
}

// DSI.MCR: DSI Host mode Configuration Register
func (o *DSI_Type) SetMCR_CMDM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetMCR_CMDM() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}

// DSI.VMCR: DSI Host Video mode Configuration Register
func (o *DSI_Type) SetVMCR_VMT(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetVMCR_VMT() uint32 {
	return volatile.LoadUint32(&o.VMCR.Reg) & 0x3
}
func (o *DSI_Type) SetVMCR_LPVSAE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetVMCR_LPVSAE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetVMCR_LPVBPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetVMCR_LPVBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetVMCR_LPVFPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetVMCR_LPVFPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetVMCR_LPVAE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetVMCR_LPVAE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetVMCR_LPHBPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetVMCR_LPHBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetVMCR_LPHFPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetVMCR_LPHFPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetVMCR_FBTAAE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetVMCR_FBTAAE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetVMCR_LPCE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetVMCR_LPCE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetVMCR_PGE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetVMCR_PGE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetVMCR_PGM(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetVMCR_PGM() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x100000) >> 20
}
func (o *DSI_Type) SetVMCR_PGO(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetVMCR_PGO() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x1000000) >> 24
}

// DSI.VPCR: DSI Host Video Packet Configuration Register
func (o *DSI_Type) SetVPCR_VPSIZE(value uint32) {
	volatile.StoreUint32(&o.VPCR.Reg, volatile.LoadUint32(&o.VPCR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVPCR_VPSIZE() uint32 {
	return volatile.LoadUint32(&o.VPCR.Reg) & 0x3fff
}

// DSI.VCCR: DSI Host Video Chunks Configuration Register
func (o *DSI_Type) SetVCCR_NUMC(value uint32) {
	volatile.StoreUint32(&o.VCCR.Reg, volatile.LoadUint32(&o.VCCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVCCR_NUMC() uint32 {
	return volatile.LoadUint32(&o.VCCR.Reg) & 0x1fff
}

// DSI.VNPCR: DSI Host Video Null Packet Configuration Register
func (o *DSI_Type) SetVNPCR_NPSIZE(value uint32) {
	volatile.StoreUint32(&o.VNPCR.Reg, volatile.LoadUint32(&o.VNPCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVNPCR_NPSIZE() uint32 {
	return volatile.LoadUint32(&o.VNPCR.Reg) & 0x1fff
}

// DSI.VHSACR: DSI Host Video HSA Configuration Register
func (o *DSI_Type) SetVHSACR_HSA(value uint32) {
	volatile.StoreUint32(&o.VHSACR.Reg, volatile.LoadUint32(&o.VHSACR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHSACR_HSA() uint32 {
	return volatile.LoadUint32(&o.VHSACR.Reg) & 0xfff
}

// DSI.VHBPCR: DSI Host Video HBP Configuration Register
func (o *DSI_Type) SetVHBPCR_HBP(value uint32) {
	volatile.StoreUint32(&o.VHBPCR.Reg, volatile.LoadUint32(&o.VHBPCR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHBPCR_HBP() uint32 {
	return volatile.LoadUint32(&o.VHBPCR.Reg) & 0xfff
}

// DSI.VLCR: DSI Host Video Line Configuration Register
func (o *DSI_Type) SetVLCR_HLINE(value uint32) {
	volatile.StoreUint32(&o.VLCR.Reg, volatile.LoadUint32(&o.VLCR.Reg)&^(0x7fff)|value)
}
func (o *DSI_Type) GetVLCR_HLINE() uint32 {
	return volatile.LoadUint32(&o.VLCR.Reg) & 0x7fff
}

// DSI.VVSACR: DSI Host Video VSA Configuration Register
func (o *DSI_Type) SetVVSACR_VSA(value uint32) {
	volatile.StoreUint32(&o.VVSACR.Reg, volatile.LoadUint32(&o.VVSACR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVSACR_VSA() uint32 {
	return volatile.LoadUint32(&o.VVSACR.Reg) & 0x3ff
}

// DSI.VVBPCR: DSI Host Video VBP Configuration Register
func (o *DSI_Type) SetVVBPCR_VBP(value uint32) {
	volatile.StoreUint32(&o.VVBPCR.Reg, volatile.LoadUint32(&o.VVBPCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVBPCR_VBP() uint32 {
	return volatile.LoadUint32(&o.VVBPCR.Reg) & 0x3ff
}

// DSI.VVFPCR: DSI Host Video VFP Configuration Register
func (o *DSI_Type) SetVVFPCR_VFP(value uint32) {
	volatile.StoreUint32(&o.VVFPCR.Reg, volatile.LoadUint32(&o.VVFPCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVFPCR_VFP() uint32 {
	return volatile.LoadUint32(&o.VVFPCR.Reg) & 0x3ff
}

// DSI.VVACR: DSI Host Video VA Configuration Register
func (o *DSI_Type) SetVVACR_VA(value uint32) {
	volatile.StoreUint32(&o.VVACR.Reg, volatile.LoadUint32(&o.VVACR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVVACR_VA() uint32 {
	return volatile.LoadUint32(&o.VVACR.Reg) & 0x3fff
}

// DSI.LCCR: DSI Host LTDC Command Configuration Register
func (o *DSI_Type) SetLCCR_CMDSIZE(value uint32) {
	volatile.StoreUint32(&o.LCCR.Reg, volatile.LoadUint32(&o.LCCR.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetLCCR_CMDSIZE() uint32 {
	return volatile.LoadUint32(&o.LCCR.Reg) & 0xffff
}

// DSI.CMCR: DSI Host Command mode Configuration Register
func (o *DSI_Type) SetCMCR_TEARE(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetCMCR_TEARE() uint32 {
	return volatile.LoadUint32(&o.CMCR.Reg) & 0x1
}
func (o *DSI_Type) SetCMCR_ARE(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetCMCR_ARE() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetCMCR_GSW0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetCMCR_GSW0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetCMCR_GSW1TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetCMCR_GSW1TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetCMCR_GSW2TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetCMCR_GSW2TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetCMCR_GSR0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetCMCR_GSR0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetCMCR_GSR1TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetCMCR_GSR1TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetCMCR_GSR2TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetCMCR_GSR2TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetCMCR_GLWTX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetCMCR_GLWTX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetCMCR_DSW0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetCMCR_DSW0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetCMCR_DSW1TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetCMCR_DSW1TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetCMCR_DSR0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetCMCR_DSR0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetCMCR_DLWTX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetCMCR_DLWTX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetCMCR_MRDPS(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetCMCR_MRDPS() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x1000000) >> 24
}

// DSI.GHCR: DSI Host Generic Header Configuration Register
func (o *DSI_Type) SetGHCR_DT(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0x3f)|value)
}
func (o *DSI_Type) GetGHCR_DT() uint32 {
	return volatile.LoadUint32(&o.GHCR.Reg) & 0x3f
}
func (o *DSI_Type) SetGHCR_VCID(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0xc0)|value<<6)
}
func (o *DSI_Type) GetGHCR_VCID() uint32 {
	return (volatile.LoadUint32(&o.GHCR.Reg) & 0xc0) >> 6
}
func (o *DSI_Type) SetGHCR_WCLSB(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetGHCR_WCLSB() uint32 {
	return (volatile.LoadUint32(&o.GHCR.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetGHCR_WCMSB(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetGHCR_WCMSB() uint32 {
	return (volatile.LoadUint32(&o.GHCR.Reg) & 0xff0000) >> 16
}

// DSI.GPDR: DSI Host Generic Payload Data Register
func (o *DSI_Type) SetGPDR_DATA1(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetGPDR_DATA1() uint32 {
	return volatile.LoadUint32(&o.GPDR.Reg) & 0xff
}
func (o *DSI_Type) SetGPDR_DATA2(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetGPDR_DATA2() uint32 {
	return (volatile.LoadUint32(&o.GPDR.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetGPDR_DATA3(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetGPDR_DATA3() uint32 {
	return (volatile.LoadUint32(&o.GPDR.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetGPDR_DATA4(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetGPDR_DATA4() uint32 {
	return (volatile.LoadUint32(&o.GPDR.Reg) & 0xff000000) >> 24
}

// DSI.GPSR: DSI Host Generic Packet Status Register
func (o *DSI_Type) SetGPSR_CMDFE(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetGPSR_CMDFE() uint32 {
	return volatile.LoadUint32(&o.GPSR.Reg) & 0x1
}
func (o *DSI_Type) SetGPSR_CMDFF(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetGPSR_CMDFF() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetGPSR_PWRFE(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetGPSR_PWRFE() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetGPSR_PWRFF(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetGPSR_PWRFF() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetGPSR_PRDFE(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetGPSR_PRDFE() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetGPSR_PRDFF(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetGPSR_PRDFF() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetGPSR_RCB(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetGPSR_RCB() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x40) >> 6
}

// DSI.TCCR0: DSI Host Timeout Counter Configuration Register 0
func (o *DSI_Type) SetTCCR0_LPRX_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR0.Reg, volatile.LoadUint32(&o.TCCR0.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR0_LPRX_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR0.Reg) & 0xffff
}
func (o *DSI_Type) SetTCCR0_HSTX_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR0.Reg, volatile.LoadUint32(&o.TCCR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *DSI_Type) GetTCCR0_HSTX_TOCNT() uint32 {
	return (volatile.LoadUint32(&o.TCCR0.Reg) & 0xffff0000) >> 16
}

// DSI.TCCR1: DSI Host Timeout Counter Configuration Register 1
func (o *DSI_Type) SetTCCR1_HSRD_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR1.Reg, volatile.LoadUint32(&o.TCCR1.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR1_HSRD_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR1.Reg) & 0xffff
}

// DSI.TCCR2: DSI Host Timeout Counter Configuration Register 2
func (o *DSI_Type) SetTCCR2_LPRD_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR2.Reg, volatile.LoadUint32(&o.TCCR2.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR2_LPRD_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR2.Reg) & 0xffff
}

// DSI.TCCR3: DSI Host Timeout Counter Configuration Register 3
func (o *DSI_Type) SetTCCR3_HSWR_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR3.Reg, volatile.LoadUint32(&o.TCCR3.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR3_HSWR_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR3.Reg) & 0xffff
}
func (o *DSI_Type) SetTCCR3_PM(value uint32) {
	volatile.StoreUint32(&o.TCCR3.Reg, volatile.LoadUint32(&o.TCCR3.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetTCCR3_PM() uint32 {
	return (volatile.LoadUint32(&o.TCCR3.Reg) & 0x1000000) >> 24
}

// DSI.TCCR4: DSI Host Timeout Counter Configuration Register 4
func (o *DSI_Type) SetTCCR4_LSWR_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR4.Reg, volatile.LoadUint32(&o.TCCR4.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR4_LSWR_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR4.Reg) & 0xffff
}

// DSI.TCCR5: DSI Host Timeout Counter Configuration Register 5
func (o *DSI_Type) SetTCCR5_BTA_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR5.Reg, volatile.LoadUint32(&o.TCCR5.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR5_BTA_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR5.Reg) & 0xffff
}

// DSI.CLCR: DSI Host Clock Lane Configuration Register
func (o *DSI_Type) SetCLCR_DPCC(value uint32) {
	volatile.StoreUint32(&o.CLCR.Reg, volatile.LoadUint32(&o.CLCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetCLCR_DPCC() uint32 {
	return volatile.LoadUint32(&o.CLCR.Reg) & 0x1
}
func (o *DSI_Type) SetCLCR_ACR(value uint32) {
	volatile.StoreUint32(&o.CLCR.Reg, volatile.LoadUint32(&o.CLCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetCLCR_ACR() uint32 {
	return (volatile.LoadUint32(&o.CLCR.Reg) & 0x2) >> 1
}

// DSI.CLTCR: DSI Host Clock Lane Timer Configuration Register
func (o *DSI_Type) SetCLTCR_LP2HS_TIME(value uint32) {
	volatile.StoreUint32(&o.CLTCR.Reg, volatile.LoadUint32(&o.CLTCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetCLTCR_LP2HS_TIME() uint32 {
	return volatile.LoadUint32(&o.CLTCR.Reg) & 0x3ff
}
func (o *DSI_Type) SetCLTCR_HS2LP_TIME(value uint32) {
	volatile.StoreUint32(&o.CLTCR.Reg, volatile.LoadUint32(&o.CLTCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DSI_Type) GetCLTCR_HS2LP_TIME() uint32 {
	return (volatile.LoadUint32(&o.CLTCR.Reg) & 0x3ff0000) >> 16
}

// DSI.DLTRC: DSI Host Data Lane Timer Configuration Register
func (o *DSI_Type) SetDLTRC_MRD_TIME(value uint32) {
	volatile.StoreUint32(&o.DLTRC.Reg, volatile.LoadUint32(&o.DLTRC.Reg)&^(0x7fff)|value)
}
func (o *DSI_Type) GetDLTRC_MRD_TIME() uint32 {
	return volatile.LoadUint32(&o.DLTRC.Reg) & 0x7fff
}
func (o *DSI_Type) SetDLTRC_LP2HS_TIME(value uint32) {
	volatile.StoreUint32(&o.DLTRC.Reg, volatile.LoadUint32(&o.DLTRC.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetDLTRC_LP2HS_TIME() uint32 {
	return (volatile.LoadUint32(&o.DLTRC.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetDLTRC_HS2LP_TIME(value uint32) {
	volatile.StoreUint32(&o.DLTRC.Reg, volatile.LoadUint32(&o.DLTRC.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetDLTRC_HS2LP_TIME() uint32 {
	return (volatile.LoadUint32(&o.DLTRC.Reg) & 0xff000000) >> 24
}

// DSI.PCTLR: DSI Host PHY Control Register
func (o *DSI_Type) SetPCTLR_DEN(value uint32) {
	volatile.StoreUint32(&o.PCTLR.Reg, volatile.LoadUint32(&o.PCTLR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPCTLR_DEN() uint32 {
	return (volatile.LoadUint32(&o.PCTLR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPCTLR_CKE(value uint32) {
	volatile.StoreUint32(&o.PCTLR.Reg, volatile.LoadUint32(&o.PCTLR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPCTLR_CKE() uint32 {
	return (volatile.LoadUint32(&o.PCTLR.Reg) & 0x4) >> 2
}

// DSI.PCONFR: DSI Host PHY Configuration Register
func (o *DSI_Type) SetPCONFR_NL(value uint32) {
	volatile.StoreUint32(&o.PCONFR.Reg, volatile.LoadUint32(&o.PCONFR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetPCONFR_NL() uint32 {
	return volatile.LoadUint32(&o.PCONFR.Reg) & 0x3
}
func (o *DSI_Type) SetPCONFR_SW_TIME(value uint32) {
	volatile.StoreUint32(&o.PCONFR.Reg, volatile.LoadUint32(&o.PCONFR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetPCONFR_SW_TIME() uint32 {
	return (volatile.LoadUint32(&o.PCONFR.Reg) & 0xff00) >> 8
}

// DSI.PUCR: DSI Host PHY ULPS Control Register
func (o *DSI_Type) SetPUCR_URCL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetPUCR_URCL() uint32 {
	return volatile.LoadUint32(&o.PUCR.Reg) & 0x1
}
func (o *DSI_Type) SetPUCR_UECL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPUCR_UECL() uint32 {
	return (volatile.LoadUint32(&o.PUCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPUCR_URDL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPUCR_URDL() uint32 {
	return (volatile.LoadUint32(&o.PUCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetPUCR_UEDL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetPUCR_UEDL() uint32 {
	return (volatile.LoadUint32(&o.PUCR.Reg) & 0x8) >> 3
}

// DSI.PTTCR: DSI Host PHY TX Triggers Configuration Register
func (o *DSI_Type) SetPTTCR_TX_TRIG(value uint32) {
	volatile.StoreUint32(&o.PTTCR.Reg, volatile.LoadUint32(&o.PTTCR.Reg)&^(0xf)|value)
}
func (o *DSI_Type) GetPTTCR_TX_TRIG() uint32 {
	return volatile.LoadUint32(&o.PTTCR.Reg) & 0xf
}

// DSI.PSR: DSI Host PHY Status Register
func (o *DSI_Type) SetPSR_PD(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPSR_PD() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPSR_PSSC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPSR_PSSC() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetPSR_UANC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetPSR_UANC() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetPSR_PSS0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetPSR_PSS0() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetPSR_UAN0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetPSR_UAN0() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetPSR_RUE0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetPSR_RUE0() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetPSR_PSS1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetPSR_PSS1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetPSR_UAN1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetPSR_UAN1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}

// DSI.ISR0: DSI Host Interrupt & Status Register 0
func (o *DSI_Type) SetISR0_AE0(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetISR0_AE0() uint32 {
	return volatile.LoadUint32(&o.ISR0.Reg) & 0x1
}
func (o *DSI_Type) SetISR0_AE1(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetISR0_AE1() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetISR0_AE2(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetISR0_AE2() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetISR0_AE3(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetISR0_AE3() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetISR0_AE4(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetISR0_AE4() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetISR0_AE5(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetISR0_AE5() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetISR0_AE6(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetISR0_AE6() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetISR0_AE7(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetISR0_AE7() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetISR0_AE8(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetISR0_AE8() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetISR0_AE9(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetISR0_AE9() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetISR0_AE10(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetISR0_AE10() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetISR0_AE11(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetISR0_AE11() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetISR0_AE12(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetISR0_AE12() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetISR0_AE13(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetISR0_AE13() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetISR0_AE14(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetISR0_AE14() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetISR0_AE15(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetISR0_AE15() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetISR0_PE0(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetISR0_PE0() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetISR0_PE1(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetISR0_PE1() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetISR0_PE2(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetISR0_PE2() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetISR0_PE3(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetISR0_PE3() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetISR0_PE4(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetISR0_PE4() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x100000) >> 20
}

// DSI.ISR1: DSI Host Interrupt & Status Register 1
func (o *DSI_Type) SetISR1_TOHSTX(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetISR1_TOHSTX() uint32 {
	return volatile.LoadUint32(&o.ISR1.Reg) & 0x1
}
func (o *DSI_Type) SetISR1_TOLPRX(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetISR1_TOLPRX() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetISR1_ECCSE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetISR1_ECCSE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetISR1_ECCME(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetISR1_ECCME() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetISR1_CRCE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetISR1_CRCE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetISR1_PSE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetISR1_PSE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetISR1_EOTPE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetISR1_EOTPE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetISR1_LPWRE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetISR1_LPWRE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetISR1_GCWRE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetISR1_GCWRE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetISR1_GPWRE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetISR1_GPWRE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetISR1_GPTXE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetISR1_GPTXE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetISR1_GPRDE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetISR1_GPRDE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetISR1_GPRXE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetISR1_GPRXE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x1000) >> 12
}

// DSI.IER0: DSI Host Interrupt Enable Register 0
func (o *DSI_Type) SetIER0_AE0IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetIER0_AE0IE() uint32 {
	return volatile.LoadUint32(&o.IER0.Reg) & 0x1
}
func (o *DSI_Type) SetIER0_AE1IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetIER0_AE1IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetIER0_AE2IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetIER0_AE2IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetIER0_AE3IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetIER0_AE3IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetIER0_AE4IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetIER0_AE4IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetIER0_AE5IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetIER0_AE5IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetIER0_AE6IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetIER0_AE6IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetIER0_AE7IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetIER0_AE7IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetIER0_AE8IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetIER0_AE8IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetIER0_AE9IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetIER0_AE9IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetIER0_AE10IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetIER0_AE10IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetIER0_AE11IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetIER0_AE11IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetIER0_AE12IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetIER0_AE12IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetIER0_AE13IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetIER0_AE13IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetIER0_AE14IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetIER0_AE14IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetIER0_AE15IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetIER0_AE15IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetIER0_PE0IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetIER0_PE0IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetIER0_PE1IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetIER0_PE1IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetIER0_PE2IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetIER0_PE2IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetIER0_PE3IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetIER0_PE3IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetIER0_PE4IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetIER0_PE4IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x100000) >> 20
}

// DSI.IER1: DSI Host Interrupt Enable Register 1
func (o *DSI_Type) SetIER1_TOHSTXIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetIER1_TOHSTXIE() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *DSI_Type) SetIER1_TOLPRXIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetIER1_TOLPRXIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetIER1_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetIER1_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetIER1_ECCMEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetIER1_ECCMEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetIER1_CRCEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetIER1_CRCEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetIER1_PSEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetIER1_PSEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetIER1_EOTPEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetIER1_EOTPEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetIER1_LPWREIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetIER1_LPWREIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetIER1_GCWREIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetIER1_GCWREIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetIER1_GPWREIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetIER1_GPWREIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetIER1_GPTXEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetIER1_GPTXEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetIER1_GPRDEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetIER1_GPRDEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetIER1_GPRXEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetIER1_GPRXEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x1000) >> 12
}

// DSI.FIR0: DSI Host Force Interrupt Register 0
func (o *DSI_Type) SetFIR0_FAE0(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetFIR0_FAE0() uint32 {
	return volatile.LoadUint32(&o.FIR0.Reg) & 0x1
}
func (o *DSI_Type) SetFIR0_FAE1(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetFIR0_FAE1() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetFIR0_FAE2(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetFIR0_FAE2() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetFIR0_FAE3(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetFIR0_FAE3() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetFIR0_FAE4(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetFIR0_FAE4() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetFIR0_FAE5(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetFIR0_FAE5() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetFIR0_FAE6(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetFIR0_FAE6() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetFIR0_FAE7(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetFIR0_FAE7() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetFIR0_FAE8(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetFIR0_FAE8() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetFIR0_FAE9(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetFIR0_FAE9() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetFIR0_FAE10(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetFIR0_FAE10() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetFIR0_FAE11(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetFIR0_FAE11() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetFIR0_FAE12(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetFIR0_FAE12() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetFIR0_FAE13(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetFIR0_FAE13() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetFIR0_FAE14(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetFIR0_FAE14() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetFIR0_FAE15(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetFIR0_FAE15() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetFIR0_FPE0(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetFIR0_FPE0() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetFIR0_FPE1(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetFIR0_FPE1() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetFIR0_FPE2(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetFIR0_FPE2() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetFIR0_FPE3(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetFIR0_FPE3() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetFIR0_FPE4(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetFIR0_FPE4() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x100000) >> 20
}

// DSI.FIR1: DSI Host Force Interrupt Register 1
func (o *DSI_Type) SetFIR1_FTOHSTX(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetFIR1_FTOHSTX() uint32 {
	return volatile.LoadUint32(&o.FIR1.Reg) & 0x1
}
func (o *DSI_Type) SetFIR1_FTOLPRX(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetFIR1_FTOLPRX() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetFIR1_FECCSE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetFIR1_FECCSE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetFIR1_FECCME(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetFIR1_FECCME() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetFIR1_FCRCE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetFIR1_FCRCE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetFIR1_FPSE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetFIR1_FPSE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetFIR1_FEOTPE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetFIR1_FEOTPE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetFIR1_FLPWRE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetFIR1_FLPWRE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetFIR1_FGCWRE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetFIR1_FGCWRE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetFIR1_FGPWRE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetFIR1_FGPWRE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetFIR1_FGPTXE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetFIR1_FGPTXE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetFIR1_FGPRDE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetFIR1_FGPRDE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetFIR1_FGPRXE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetFIR1_FGPRXE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x1000) >> 12
}

// DSI.VSCR: DSI Host Video Shadow Control Register
func (o *DSI_Type) SetVSCR_EN(value uint32) {
	volatile.StoreUint32(&o.VSCR.Reg, volatile.LoadUint32(&o.VSCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetVSCR_EN() uint32 {
	return volatile.LoadUint32(&o.VSCR.Reg) & 0x1
}
func (o *DSI_Type) SetVSCR_UR(value uint32) {
	volatile.StoreUint32(&o.VSCR.Reg, volatile.LoadUint32(&o.VSCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetVSCR_UR() uint32 {
	return (volatile.LoadUint32(&o.VSCR.Reg) & 0x100) >> 8
}

// DSI.LCVCIDR: DSI Host LTDC Current VCID Register
func (o *DSI_Type) SetLCVCIDR_VCID(value uint32) {
	volatile.StoreUint32(&o.LCVCIDR.Reg, volatile.LoadUint32(&o.LCVCIDR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetLCVCIDR_VCID() uint32 {
	return volatile.LoadUint32(&o.LCVCIDR.Reg) & 0x3
}

// DSI.LCCCR: DSI Host LTDC Current Color Coding Register
func (o *DSI_Type) SetLCCCR_COLC(value uint32) {
	volatile.StoreUint32(&o.LCCCR.Reg, volatile.LoadUint32(&o.LCCCR.Reg)&^(0xf)|value)
}
func (o *DSI_Type) GetLCCCR_COLC() uint32 {
	return volatile.LoadUint32(&o.LCCCR.Reg) & 0xf
}
func (o *DSI_Type) SetLCCCR_LPE(value uint32) {
	volatile.StoreUint32(&o.LCCCR.Reg, volatile.LoadUint32(&o.LCCCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetLCCCR_LPE() uint32 {
	return (volatile.LoadUint32(&o.LCCCR.Reg) & 0x100) >> 8
}

// DSI.LPMCCR: DSI Host Low-Power mode Current Configuration Register
func (o *DSI_Type) SetLPMCCR_VLPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCCR.Reg, volatile.LoadUint32(&o.LPMCCR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetLPMCCR_VLPSIZE() uint32 {
	return volatile.LoadUint32(&o.LPMCCR.Reg) & 0xff
}
func (o *DSI_Type) SetLPMCCR_LPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCCR.Reg, volatile.LoadUint32(&o.LPMCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetLPMCCR_LPSIZE() uint32 {
	return (volatile.LoadUint32(&o.LPMCCR.Reg) & 0xff0000) >> 16
}

// DSI.VMCCR: DSI Host Video mode Current Configuration Register
func (o *DSI_Type) SetVMCCR_VMT(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetVMCCR_VMT() uint32 {
	return volatile.LoadUint32(&o.VMCCR.Reg) & 0x3
}
func (o *DSI_Type) SetVMCCR_LPVSAE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetVMCCR_LPVSAE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetVMCCR_LPVBPE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetVMCCR_LPVBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetVMCCR_LPVFPE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetVMCCR_LPVFPE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetVMCCR_LPVAE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetVMCCR_LPVAE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetVMCCR_LPHBPE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetVMCCR_LPHBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetVMCCR_LPHFE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetVMCCR_LPHFE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetVMCCR_FBTAAE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetVMCCR_FBTAAE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetVMCCR_LPCE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetVMCCR_LPCE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x200) >> 9
}

// DSI.VPCCR: DSI Host Video Packet Current Configuration Register
func (o *DSI_Type) SetVPCCR_VPSIZE(value uint32) {
	volatile.StoreUint32(&o.VPCCR.Reg, volatile.LoadUint32(&o.VPCCR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVPCCR_VPSIZE() uint32 {
	return volatile.LoadUint32(&o.VPCCR.Reg) & 0x3fff
}

// DSI.VCCCR: DSI Host Video Chunks Current Configuration Register
func (o *DSI_Type) SetVCCCR_NUMC(value uint32) {
	volatile.StoreUint32(&o.VCCCR.Reg, volatile.LoadUint32(&o.VCCCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVCCCR_NUMC() uint32 {
	return volatile.LoadUint32(&o.VCCCR.Reg) & 0x1fff
}

// DSI.VNPCCR: DSI Host Video Null Packet Current Configuration Register
func (o *DSI_Type) SetVNPCCR_NPSIZE(value uint32) {
	volatile.StoreUint32(&o.VNPCCR.Reg, volatile.LoadUint32(&o.VNPCCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVNPCCR_NPSIZE() uint32 {
	return volatile.LoadUint32(&o.VNPCCR.Reg) & 0x1fff
}

// DSI.VHSACCR: DSI Host Video HSA Current Configuration Register
func (o *DSI_Type) SetVHSACCR_HSA(value uint32) {
	volatile.StoreUint32(&o.VHSACCR.Reg, volatile.LoadUint32(&o.VHSACCR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHSACCR_HSA() uint32 {
	return volatile.LoadUint32(&o.VHSACCR.Reg) & 0xfff
}

// DSI.VHBPCCR: DSI Host Video HBP Current Configuration Register
func (o *DSI_Type) SetVHBPCCR_HBP(value uint32) {
	volatile.StoreUint32(&o.VHBPCCR.Reg, volatile.LoadUint32(&o.VHBPCCR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHBPCCR_HBP() uint32 {
	return volatile.LoadUint32(&o.VHBPCCR.Reg) & 0xfff
}

// DSI.VLCCR: DSI Host Video Line Current Configuration Register
func (o *DSI_Type) SetVLCCR_HLINE(value uint32) {
	volatile.StoreUint32(&o.VLCCR.Reg, volatile.LoadUint32(&o.VLCCR.Reg)&^(0x7fff)|value)
}
func (o *DSI_Type) GetVLCCR_HLINE() uint32 {
	return volatile.LoadUint32(&o.VLCCR.Reg) & 0x7fff
}

// DSI.VVSACCR: DSI Host Video VSA Current Configuration Register
func (o *DSI_Type) SetVVSACCR_VSA(value uint32) {
	volatile.StoreUint32(&o.VVSACCR.Reg, volatile.LoadUint32(&o.VVSACCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVSACCR_VSA() uint32 {
	return volatile.LoadUint32(&o.VVSACCR.Reg) & 0x3ff
}

// DSI.VVBPCCR: DSI Host Video VBP Current Configuration Register
func (o *DSI_Type) SetVVBPCCR_VBP(value uint32) {
	volatile.StoreUint32(&o.VVBPCCR.Reg, volatile.LoadUint32(&o.VVBPCCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVBPCCR_VBP() uint32 {
	return volatile.LoadUint32(&o.VVBPCCR.Reg) & 0x3ff
}

// DSI.VVFPCCR: DSI Host Video VFP Current Configuration Register
func (o *DSI_Type) SetVVFPCCR_VFP(value uint32) {
	volatile.StoreUint32(&o.VVFPCCR.Reg, volatile.LoadUint32(&o.VVFPCCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVFPCCR_VFP() uint32 {
	return volatile.LoadUint32(&o.VVFPCCR.Reg) & 0x3ff
}

// DSI.VVACCR: DSI Host Video VA Current Configuration Register
func (o *DSI_Type) SetVVACCR_VA(value uint32) {
	volatile.StoreUint32(&o.VVACCR.Reg, volatile.LoadUint32(&o.VVACCR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVVACCR_VA() uint32 {
	return volatile.LoadUint32(&o.VVACCR.Reg) & 0x3fff
}

// DSI.WCFGR: DSI Wrapper Configuration Register
func (o *DSI_Type) SetWCFGR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetWCFGR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetWCFGR_AR(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetWCFGR_AR() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetWCFGR_TEPOL(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetWCFGR_TEPOL() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetWCFGR_TESRC(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetWCFGR_TESRC() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetWCFGR_COLMUX(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0xe)|value<<1)
}
func (o *DSI_Type) GetWCFGR_COLMUX() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0xe) >> 1
}
func (o *DSI_Type) SetWCFGR_DSIM(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWCFGR_DSIM() uint32 {
	return volatile.LoadUint32(&o.WCFGR.Reg) & 0x1
}

// DSI.WCR: DSI Wrapper Control Register
func (o *DSI_Type) SetWCR_DSIEN(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetWCR_DSIEN() uint32 {
	return (volatile.LoadUint32(&o.WCR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetWCR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetWCR_LTDCEN() uint32 {
	return (volatile.LoadUint32(&o.WCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetWCR_SHTDN(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWCR_SHTDN() uint32 {
	return (volatile.LoadUint32(&o.WCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWCR_COLM(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWCR_COLM() uint32 {
	return volatile.LoadUint32(&o.WCR.Reg) & 0x1
}

// DSI.WIER: DSI Wrapper Interrupt Enable Register
func (o *DSI_Type) SetWIER_RRIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWIER_RRIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWIER_PLLUIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWIER_PLLUIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWIER_PLLLIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWIER_PLLLIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWIER_ERIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWIER_ERIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWIER_TEIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWIER_TEIE() uint32 {
	return volatile.LoadUint32(&o.WIER.Reg) & 0x1
}

// DSI.WISR: DSI Wrapper Interrupt & Status Register
func (o *DSI_Type) SetWISR_RRIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWISR_RRIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWISR_RRS(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetWISR_RRS() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetWISR_PLLUIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWISR_PLLUIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWISR_PLLLIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWISR_PLLLIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWISR_PLLLS(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetWISR_PLLLS() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetWISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetWISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetWISR_ERIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWISR_ERIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWISR_TEIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWISR_TEIF() uint32 {
	return volatile.LoadUint32(&o.WISR.Reg) & 0x1
}

// DSI.WIFCR: DSI Wrapper Interrupt Flag Clear Register
func (o *DSI_Type) SetWIFCR_CRRIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWIFCR_CRRIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWIFCR_CPLLUIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWIFCR_CPLLUIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWIFCR_CPLLLIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWIFCR_CPLLLIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWIFCR_CERIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWIFCR_CERIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWIFCR_CTEIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWIFCR_CTEIF() uint32 {
	return volatile.LoadUint32(&o.WIFCR.Reg) & 0x1
}

// DSI.WPCR0: DSI Wrapper PHY Configuration Register 0
func (o *DSI_Type) SetWPCR0_TCLKPOSTEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x8000000)|value<<27)
}
func (o *DSI_Type) GetWPCR0_TCLKPOSTEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x8000000) >> 27
}
func (o *DSI_Type) SetWPCR0_TLPXCEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x4000000)|value<<26)
}
func (o *DSI_Type) GetWPCR0_TLPXCEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x4000000) >> 26
}
func (o *DSI_Type) SetWPCR0_THSEXITEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x2000000)|value<<25)
}
func (o *DSI_Type) GetWPCR0_THSEXITEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x2000000) >> 25
}
func (o *DSI_Type) SetWPCR0_TLPXDEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetWPCR0_TLPXDEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x1000000) >> 24
}
func (o *DSI_Type) SetWPCR0_THSZEROEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x800000)|value<<23)
}
func (o *DSI_Type) GetWPCR0_THSZEROEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x800000) >> 23
}
func (o *DSI_Type) SetWPCR0_THSTRAILEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x400000)|value<<22)
}
func (o *DSI_Type) GetWPCR0_THSTRAILEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x400000) >> 22
}
func (o *DSI_Type) SetWPCR0_THSPREPEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x200000)|value<<21)
}
func (o *DSI_Type) GetWPCR0_THSPREPEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x200000) >> 21
}
func (o *DSI_Type) SetWPCR0_TCLKZEROEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetWPCR0_TCLKZEROEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x100000) >> 20
}
func (o *DSI_Type) SetWPCR0_TCLKPREPEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetWPCR0_TCLKPREPEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetWPCR0_PDEN(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetWPCR0_PDEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetWPCR0_TDDL(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetWPCR0_TDDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetWPCR0_CDOFFDL(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetWPCR0_CDOFFDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetWPCR0_FTXSMDL(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWPCR0_FTXSMDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWPCR0_FTXSMCL(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetWPCR0_FTXSMCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetWPCR0_HSIDL1(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetWPCR0_HSIDL1() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetWPCR0_HSIDL0(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWPCR0_HSIDL0() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWPCR0_HSICL(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWPCR0_HSICL() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWPCR0_SWDL1(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetWPCR0_SWDL1() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetWPCR0_SWDL0(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetWPCR0_SWDL0() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetWPCR0_SWCL(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetWPCR0_SWCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetWPCR0_UIX4(value uint32) {
	volatile.StoreUint32(&o.WPCR0.Reg, volatile.LoadUint32(&o.WPCR0.Reg)&^(0x3f)|value)
}
func (o *DSI_Type) GetWPCR0_UIX4() uint32 {
	return volatile.LoadUint32(&o.WPCR0.Reg) & 0x3f
}

// DSI.WPCR1: DSI Wrapper PHY Configuration Register 1
func (o *DSI_Type) SetWPCR1_LPRXFT(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x6000000)|value<<25)
}
func (o *DSI_Type) GetWPCR1_LPRXFT() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x6000000) >> 25
}
func (o *DSI_Type) SetWPCR1_FLPRXLPM(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x400000)|value<<22)
}
func (o *DSI_Type) GetWPCR1_FLPRXLPM() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x400000) >> 22
}
func (o *DSI_Type) SetWPCR1_HSTXSRCDL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0xc0000)|value<<18)
}
func (o *DSI_Type) GetWPCR1_HSTXSRCDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0xc0000) >> 18
}
func (o *DSI_Type) SetWPCR1_HSTXSRCCL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x30000)|value<<16)
}
func (o *DSI_Type) GetWPCR1_HSTXSRCCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x30000) >> 16
}
func (o *DSI_Type) SetWPCR1_SDCC(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetWPCR1_SDCC() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetWPCR1_LPSRDL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x300)|value<<8)
}
func (o *DSI_Type) GetWPCR1_LPSRDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x300) >> 8
}
func (o *DSI_Type) SetWPCR1_LPSRCL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0xc0)|value<<6)
}
func (o *DSI_Type) GetWPCR1_LPSRCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0xc0) >> 6
}
func (o *DSI_Type) SetWPCR1_HSTXDLL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0xc)|value<<2)
}
func (o *DSI_Type) GetWPCR1_HSTXDLL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0xc) >> 2
}
func (o *DSI_Type) SetWPCR1_HSTXDCL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetWPCR1_HSTXDCL() uint32 {
	return volatile.LoadUint32(&o.WPCR1.Reg) & 0x3
}

// DSI.WPCR2: DSI Wrapper PHY Configuration Register 2
func (o *DSI_Type) SetWPCR2_THSTRAIL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetWPCR2_THSTRAIL() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0xff000000) >> 24
}
func (o *DSI_Type) SetWPCR2_THSPREP(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetWPCR2_THSPREP() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetWPCR2_TCLKZEO(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetWPCR2_TCLKZEO() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetWPCR2_TCLKPREP(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetWPCR2_TCLKPREP() uint32 {
	return volatile.LoadUint32(&o.WPCR2.Reg) & 0xff
}

// DSI.WPCR3: DSI_WPCR3
func (o *DSI_Type) SetWPCR3_TLPXC(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetWPCR3_TLPXC() uint32 {
	return (volatile.LoadUint32(&o.WPCR3.Reg) & 0xff000000) >> 24
}
func (o *DSI_Type) SetWPCR3_THSEXIT(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetWPCR3_THSEXIT() uint32 {
	return (volatile.LoadUint32(&o.WPCR3.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetWPCR3_TLPXD(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetWPCR3_TLPXD() uint32 {
	return (volatile.LoadUint32(&o.WPCR3.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetWPCR3_THSZERO(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetWPCR3_THSZERO() uint32 {
	return volatile.LoadUint32(&o.WPCR3.Reg) & 0xff
}

// DSI.WPCR4: DSI Wrapper PHY Configuration Register 4
func (o *DSI_Type) SetWPCR4_THSZERO(value uint32) {
	volatile.StoreUint32(&o.WPCR4.Reg, volatile.LoadUint32(&o.WPCR4.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetWPCR4_THSZERO() uint32 {
	return volatile.LoadUint32(&o.WPCR4.Reg) & 0xff
}

// DSI.WRPCR: DSI Wrapper Regulator and PLL Control Register
func (o *DSI_Type) SetWRPCR_REGEN(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetWRPCR_REGEN() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x1000000) >> 24
}
func (o *DSI_Type) SetWRPCR_ODF(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x30000)|value<<16)
}
func (o *DSI_Type) GetWRPCR_ODF() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x30000) >> 16
}
func (o *DSI_Type) SetWRPCR_IDF(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x7800)|value<<11)
}
func (o *DSI_Type) GetWRPCR_IDF() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x7800) >> 11
}
func (o *DSI_Type) SetWRPCR_NDIV(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x1fc)|value<<2)
}
func (o *DSI_Type) GetWRPCR_NDIV() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x1fc) >> 2
}
func (o *DSI_Type) SetWRPCR_PLLEN(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWRPCR_PLLEN() uint32 {
	return volatile.LoadUint32(&o.WRPCR.Reg) & 0x1
}

// Graphic MMU
type GFXMMU_Type struct {
	CR       volatile.Register32 // 0x0
	SR       volatile.Register32 // 0x4
	FCR      volatile.Register32 // 0x8
	_        [4]byte
	DVR      volatile.Register32 // 0x10
	_        [12]byte
	B0CR     volatile.Register32 // 0x20
	B1CR     volatile.Register32 // 0x24
	B2CR     volatile.Register32 // 0x28
	B3CR     volatile.Register32 // 0x2C
	_        [4036]byte
	VERR     volatile.Register32 // 0xFF4
	IPIDR    volatile.Register32 // 0xFF8
	SIDR     volatile.Register32 // 0xFFC
	LUT0L    volatile.Register32 // 0x1000
	LUT0H    volatile.Register32 // 0x1004
	LUT1L    volatile.Register32 // 0x1008
	LUT1H    volatile.Register32 // 0x100C
	LUT2L    volatile.Register32 // 0x1010
	LUT2H    volatile.Register32 // 0x1014
	LUT3L    volatile.Register32 // 0x1018
	LUT3H    volatile.Register32 // 0x101C
	LUT4L    volatile.Register32 // 0x1020
	LUT4H    volatile.Register32 // 0x1024
	LUT5L    volatile.Register32 // 0x1028
	LUT5H    volatile.Register32 // 0x102C
	LUT6L    volatile.Register32 // 0x1030
	LUT6H    volatile.Register32 // 0x1034
	LUT7L    volatile.Register32 // 0x1038
	LUT7H    volatile.Register32 // 0x103C
	LUT8L    volatile.Register32 // 0x1040
	LUT8H    volatile.Register32 // 0x1044
	LUT9L    volatile.Register32 // 0x1048
	LUT9H    volatile.Register32 // 0x104C
	LUT10L   volatile.Register32 // 0x1050
	LUT10H   volatile.Register32 // 0x1054
	LUT11L   volatile.Register32 // 0x1058
	LUT11H   volatile.Register32 // 0x105C
	LUT12L   volatile.Register32 // 0x1060
	LUT12H   volatile.Register32 // 0x1064
	LUT13L   volatile.Register32 // 0x1068
	LUT13H   volatile.Register32 // 0x106C
	LUT14L   volatile.Register32 // 0x1070
	LUT14H   volatile.Register32 // 0x1074
	LUT15L   volatile.Register32 // 0x1078
	LUT15H   volatile.Register32 // 0x107C
	LUT16L   volatile.Register32 // 0x1080
	LUT16H   volatile.Register32 // 0x1084
	LUT17L   volatile.Register32 // 0x1088
	LUT17H   volatile.Register32 // 0x108C
	LUT18L   volatile.Register32 // 0x1090
	LUT18H   volatile.Register32 // 0x1094
	LUT19L   volatile.Register32 // 0x1098
	LUT19H   volatile.Register32 // 0x109C
	LUT20L   volatile.Register32 // 0x10A0
	LUT20H   volatile.Register32 // 0x10A4
	LUT21L   volatile.Register32 // 0x10A8
	LUT21H   volatile.Register32 // 0x10AC
	LUT22L   volatile.Register32 // 0x10B0
	LUT22H   volatile.Register32 // 0x10B4
	LUT23L   volatile.Register32 // 0x10B8
	LUT23H   volatile.Register32 // 0x10BC
	LUT24L   volatile.Register32 // 0x10C0
	LUT24H   volatile.Register32 // 0x10C4
	LUT25L   volatile.Register32 // 0x10C8
	LUT25H   volatile.Register32 // 0x10CC
	LUT26L   volatile.Register32 // 0x10D0
	LUT26H   volatile.Register32 // 0x10D4
	LUT27L   volatile.Register32 // 0x10D8
	LUT27H   volatile.Register32 // 0x10DC
	LUT28L   volatile.Register32 // 0x10E0
	LUT28H   volatile.Register32 // 0x10E4
	LUT29L   volatile.Register32 // 0x10E8
	LUT29H   volatile.Register32 // 0x10EC
	LUT30L   volatile.Register32 // 0x10F0
	LUT30H   volatile.Register32 // 0x10F4
	LUT31L   volatile.Register32 // 0x10F8
	LUT31H   volatile.Register32 // 0x10FC
	LUT32L   volatile.Register32 // 0x1100
	LUT32H   volatile.Register32 // 0x1104
	LUT33L   volatile.Register32 // 0x1108
	LUT33H   volatile.Register32 // 0x110C
	LUT34L   volatile.Register32 // 0x1110
	LUT34H   volatile.Register32 // 0x1114
	LUT35L   volatile.Register32 // 0x1118
	LUT35H   volatile.Register32 // 0x111C
	LUT36L   volatile.Register32 // 0x1120
	LUT36H   volatile.Register32 // 0x1124
	LUT37L   volatile.Register32 // 0x1128
	LUT37H   volatile.Register32 // 0x112C
	LUT38L   volatile.Register32 // 0x1130
	LUT38H   volatile.Register32 // 0x1134
	LUT39L   volatile.Register32 // 0x1138
	LUT39H   volatile.Register32 // 0x113C
	LUT40L   volatile.Register32 // 0x1140
	LUT40H   volatile.Register32 // 0x1144
	LUT41L   volatile.Register32 // 0x1148
	LUT41H   volatile.Register32 // 0x114C
	LUT42L   volatile.Register32 // 0x1150
	LUT42H   volatile.Register32 // 0x1154
	LUT43L   volatile.Register32 // 0x1158
	LUT43H   volatile.Register32 // 0x115C
	LUT44L   volatile.Register32 // 0x1160
	LUT44H   volatile.Register32 // 0x1164
	LUT45L   volatile.Register32 // 0x1168
	LUT45H   volatile.Register32 // 0x116C
	LUT46L   volatile.Register32 // 0x1170
	LUT46H   volatile.Register32 // 0x1174
	LUT47L   volatile.Register32 // 0x1178
	LUT47H   volatile.Register32 // 0x117C
	LUT48L   volatile.Register32 // 0x1180
	LUT48H   volatile.Register32 // 0x1184
	LUT49L   volatile.Register32 // 0x1188
	LUT49H   volatile.Register32 // 0x118C
	LUT50L   volatile.Register32 // 0x1190
	LUT50H   volatile.Register32 // 0x1194
	LUT51L   volatile.Register32 // 0x1198
	LUT51H   volatile.Register32 // 0x119C
	LUT52L   volatile.Register32 // 0x11A0
	LUT52H   volatile.Register32 // 0x11A4
	LUT53L   volatile.Register32 // 0x11A8
	LUT53H   volatile.Register32 // 0x11AC
	LUT54L   volatile.Register32 // 0x11B0
	LUT54H   volatile.Register32 // 0x11B4
	LUT55L   volatile.Register32 // 0x11B8
	LUT55H   volatile.Register32 // 0x11BC
	LUT56L   volatile.Register32 // 0x11C0
	LUT56H   volatile.Register32 // 0x11C4
	LUT57L   volatile.Register32 // 0x11C8
	LUT57H   volatile.Register32 // 0x11CC
	LUT58L   volatile.Register32 // 0x11D0
	LUT58H   volatile.Register32 // 0x11D4
	LUT59L   volatile.Register32 // 0x11D8
	LUT59H   volatile.Register32 // 0x11DC
	LUT60L   volatile.Register32 // 0x11E0
	LUT60H   volatile.Register32 // 0x11E4
	LUT61L   volatile.Register32 // 0x11E8
	LUT61H   volatile.Register32 // 0x11EC
	LUT62L   volatile.Register32 // 0x11F0
	LUT62H   volatile.Register32 // 0x11F4
	LUT63L   volatile.Register32 // 0x11F8
	LUT63H   volatile.Register32 // 0x11FC
	LUT64L   volatile.Register32 // 0x1200
	LUT64H   volatile.Register32 // 0x1204
	LUT65L   volatile.Register32 // 0x1208
	LUT65H   volatile.Register32 // 0x120C
	LUT66L   volatile.Register32 // 0x1210
	LUT66H   volatile.Register32 // 0x1214
	LUT67L   volatile.Register32 // 0x1218
	LUT67H   volatile.Register32 // 0x121C
	LUT68L   volatile.Register32 // 0x1220
	LUT68H   volatile.Register32 // 0x1224
	LUT69L   volatile.Register32 // 0x1228
	LUT69H   volatile.Register32 // 0x122C
	LUT70L   volatile.Register32 // 0x1230
	LUT70H   volatile.Register32 // 0x1234
	LUT71L   volatile.Register32 // 0x1238
	LUT71H   volatile.Register32 // 0x123C
	LUT72L   volatile.Register32 // 0x1240
	LUT72H   volatile.Register32 // 0x1244
	LUT73L   volatile.Register32 // 0x1248
	LUT73H   volatile.Register32 // 0x124C
	LUT74L   volatile.Register32 // 0x1250
	LUT74H   volatile.Register32 // 0x1254
	LUT75L   volatile.Register32 // 0x1258
	LUT75H   volatile.Register32 // 0x125C
	LUT76L   volatile.Register32 // 0x1260
	LUT76H   volatile.Register32 // 0x1264
	LUT77L   volatile.Register32 // 0x1268
	LUT77H   volatile.Register32 // 0x126C
	LUT78L   volatile.Register32 // 0x1270
	LUT78H   volatile.Register32 // 0x1274
	LUT79L   volatile.Register32 // 0x1278
	LUT79H   volatile.Register32 // 0x127C
	LUT80L   volatile.Register32 // 0x1280
	LUT80H   volatile.Register32 // 0x1284
	LUT81L   volatile.Register32 // 0x1288
	LUT81H   volatile.Register32 // 0x128C
	LUT82L   volatile.Register32 // 0x1290
	LUT82H   volatile.Register32 // 0x1294
	LUT83L   volatile.Register32 // 0x1298
	LUT83H   volatile.Register32 // 0x129C
	LUT84L   volatile.Register32 // 0x12A0
	LUT84H   volatile.Register32 // 0x12A4
	LUT85L   volatile.Register32 // 0x12A8
	LUT85H   volatile.Register32 // 0x12AC
	LUT86L   volatile.Register32 // 0x12B0
	LUT86H   volatile.Register32 // 0x12B4
	LUT87L   volatile.Register32 // 0x12B8
	LUT87H   volatile.Register32 // 0x12BC
	LUT88L   volatile.Register32 // 0x12C0
	LUT88H   volatile.Register32 // 0x12C4
	LUT89L   volatile.Register32 // 0x12C8
	LUT89H   volatile.Register32 // 0x12CC
	LUT90L   volatile.Register32 // 0x12D0
	LUT90H   volatile.Register32 // 0x12D4
	LUT91L   volatile.Register32 // 0x12D8
	LUT91H   volatile.Register32 // 0x12DC
	LUT92L   volatile.Register32 // 0x12E0
	LUT92H   volatile.Register32 // 0x12E4
	LUT93L   volatile.Register32 // 0x12E8
	LUT93H   volatile.Register32 // 0x12EC
	LUT94L   volatile.Register32 // 0x12F0
	LUT94H   volatile.Register32 // 0x12F4
	LUT95L   volatile.Register32 // 0x12F8
	LUT95H   volatile.Register32 // 0x12FC
	LUT96L   volatile.Register32 // 0x1300
	LUT96H   volatile.Register32 // 0x1304
	LUT97L   volatile.Register32 // 0x1308
	LUT97H   volatile.Register32 // 0x130C
	LUT98L   volatile.Register32 // 0x1310
	LUT98H   volatile.Register32 // 0x1314
	LUT99L   volatile.Register32 // 0x1318
	LUT99H   volatile.Register32 // 0x131C
	LUT100L  volatile.Register32 // 0x1320
	LUT100H  volatile.Register32 // 0x1324
	LUT101L  volatile.Register32 // 0x1328
	LUT101H  volatile.Register32 // 0x132C
	LUT102L  volatile.Register32 // 0x1330
	LUT102H  volatile.Register32 // 0x1334
	LUT103L  volatile.Register32 // 0x1338
	LUT103H  volatile.Register32 // 0x133C
	LUT104L  volatile.Register32 // 0x1340
	LUT104H  volatile.Register32 // 0x1344
	LUT105L  volatile.Register32 // 0x1348
	LUT105H  volatile.Register32 // 0x134C
	LUT106L  volatile.Register32 // 0x1350
	LUT106H  volatile.Register32 // 0x1354
	LUT107L  volatile.Register32 // 0x1358
	LUT107H  volatile.Register32 // 0x135C
	LUT108L  volatile.Register32 // 0x1360
	LUT108H  volatile.Register32 // 0x1364
	LUT109L  volatile.Register32 // 0x1368
	LUT109H  volatile.Register32 // 0x136C
	LUT110L  volatile.Register32 // 0x1370
	LUT110H  volatile.Register32 // 0x1374
	LUT111L  volatile.Register32 // 0x1378
	LUT111H  volatile.Register32 // 0x137C
	LUT112L  volatile.Register32 // 0x1380
	LUT112H  volatile.Register32 // 0x1384
	LUT113L  volatile.Register32 // 0x1388
	LUT113H  volatile.Register32 // 0x138C
	LUT114L  volatile.Register32 // 0x1390
	LUT114H  volatile.Register32 // 0x1394
	LUT115L  volatile.Register32 // 0x1398
	LUT115H  volatile.Register32 // 0x139C
	LUT116L  volatile.Register32 // 0x13A0
	LUT116H  volatile.Register32 // 0x13A4
	LUT117L  volatile.Register32 // 0x13A8
	LUT117H  volatile.Register32 // 0x13AC
	LUT118L  volatile.Register32 // 0x13B0
	LUT118H  volatile.Register32 // 0x13B4
	LUT119L  volatile.Register32 // 0x13B8
	LUT119H  volatile.Register32 // 0x13BC
	LUT120L  volatile.Register32 // 0x13C0
	LUT120H  volatile.Register32 // 0x13C4
	LUT121L  volatile.Register32 // 0x13C8
	LUT121H  volatile.Register32 // 0x13CC
	LUT122L  volatile.Register32 // 0x13D0
	LUT122H  volatile.Register32 // 0x13D4
	LUT123L  volatile.Register32 // 0x13D8
	LUT123H  volatile.Register32 // 0x13DC
	LUT124L  volatile.Register32 // 0x13E0
	LUT124H  volatile.Register32 // 0x13E4
	LUT125L  volatile.Register32 // 0x13E8
	LUT125H  volatile.Register32 // 0x13EC
	LUT126L  volatile.Register32 // 0x13F0
	LUT126H  volatile.Register32 // 0x13F4
	LUT127L  volatile.Register32 // 0x13F8
	LUT127H  volatile.Register32 // 0x13FC
	LUT128L  volatile.Register32 // 0x1400
	LUT128H  volatile.Register32 // 0x1404
	LUT129L  volatile.Register32 // 0x1408
	LUT129H  volatile.Register32 // 0x140C
	LUT130L  volatile.Register32 // 0x1410
	LUT130H  volatile.Register32 // 0x1414
	LUT131L  volatile.Register32 // 0x1418
	LUT131H  volatile.Register32 // 0x141C
	LUT132L  volatile.Register32 // 0x1420
	LUT132H  volatile.Register32 // 0x1424
	LUT133L  volatile.Register32 // 0x1428
	LUT133H  volatile.Register32 // 0x142C
	LUT134L  volatile.Register32 // 0x1430
	LUT134H  volatile.Register32 // 0x1434
	LUT135L  volatile.Register32 // 0x1438
	LUT135H  volatile.Register32 // 0x143C
	LUT136L  volatile.Register32 // 0x1440
	LUT136H  volatile.Register32 // 0x1444
	LUT137L  volatile.Register32 // 0x1448
	LUT137H  volatile.Register32 // 0x144C
	LUT138L  volatile.Register32 // 0x1450
	LUT138H  volatile.Register32 // 0x1454
	LUT139L  volatile.Register32 // 0x1458
	LUT139H  volatile.Register32 // 0x145C
	LUT140L  volatile.Register32 // 0x1460
	LUT140H  volatile.Register32 // 0x1464
	LUT141L  volatile.Register32 // 0x1468
	LUT141H  volatile.Register32 // 0x146C
	LUT142L  volatile.Register32 // 0x1470
	LUT142H  volatile.Register32 // 0x1474
	LUT143L  volatile.Register32 // 0x1478
	LUT143H  volatile.Register32 // 0x147C
	LUT144L  volatile.Register32 // 0x1480
	LUT144H  volatile.Register32 // 0x1484
	LUT145L  volatile.Register32 // 0x1488
	LUT145H  volatile.Register32 // 0x148C
	LUT146L  volatile.Register32 // 0x1490
	LUT146H  volatile.Register32 // 0x1494
	LUT147L  volatile.Register32 // 0x1498
	LUT147H  volatile.Register32 // 0x149C
	LUT148L  volatile.Register32 // 0x14A0
	LUT148H  volatile.Register32 // 0x14A4
	LUT149L  volatile.Register32 // 0x14A8
	LUT149H  volatile.Register32 // 0x14AC
	LUT150L  volatile.Register32 // 0x14B0
	LUT150H  volatile.Register32 // 0x14B4
	LUT151L  volatile.Register32 // 0x14B8
	LUT151H  volatile.Register32 // 0x14BC
	LUT152L  volatile.Register32 // 0x14C0
	LUT152H  volatile.Register32 // 0x14C4
	LUT153L  volatile.Register32 // 0x14C8
	LUT153H  volatile.Register32 // 0x14CC
	LUT154L  volatile.Register32 // 0x14D0
	LUT154H  volatile.Register32 // 0x14D4
	LUT155L  volatile.Register32 // 0x14D8
	LUT155H  volatile.Register32 // 0x14DC
	LUT156L  volatile.Register32 // 0x14E0
	LUT156H  volatile.Register32 // 0x14E4
	LUT157L  volatile.Register32 // 0x14E8
	LUT157H  volatile.Register32 // 0x14EC
	LUT158L  volatile.Register32 // 0x14F0
	LUT158H  volatile.Register32 // 0x14F4
	LUT159L  volatile.Register32 // 0x14F8
	LUT159H  volatile.Register32 // 0x14FC
	LUT160L  volatile.Register32 // 0x1500
	LUT160H  volatile.Register32 // 0x1504
	LUT161L  volatile.Register32 // 0x1508
	LUT161H  volatile.Register32 // 0x150C
	LUT162L  volatile.Register32 // 0x1510
	LUT162H  volatile.Register32 // 0x1514
	LUT163L  volatile.Register32 // 0x1518
	LUT163H  volatile.Register32 // 0x151C
	LUT164L  volatile.Register32 // 0x1520
	LUT164H  volatile.Register32 // 0x1524
	LUT165L  volatile.Register32 // 0x1528
	LUT165H  volatile.Register32 // 0x152C
	LUT166L  volatile.Register32 // 0x1530
	LUT166H  volatile.Register32 // 0x1534
	LUT167L  volatile.Register32 // 0x1538
	LUT167H  volatile.Register32 // 0x153C
	LUT168L  volatile.Register32 // 0x1540
	LUT168H  volatile.Register32 // 0x1544
	LUT169L  volatile.Register32 // 0x1548
	LUT169H  volatile.Register32 // 0x154C
	LUT170L  volatile.Register32 // 0x1550
	LUT170H  volatile.Register32 // 0x1554
	LUT171L  volatile.Register32 // 0x1558
	LUT171H  volatile.Register32 // 0x155C
	LUT172L  volatile.Register32 // 0x1560
	LUT172H  volatile.Register32 // 0x1564
	LUT173L  volatile.Register32 // 0x1568
	LUT173H  volatile.Register32 // 0x156C
	LUT174L  volatile.Register32 // 0x1570
	LUT174H  volatile.Register32 // 0x1574
	LUT175L  volatile.Register32 // 0x1578
	LUT175H  volatile.Register32 // 0x157C
	LUT176L  volatile.Register32 // 0x1580
	LUT176H  volatile.Register32 // 0x1584
	LUT177L  volatile.Register32 // 0x1588
	LUT177H  volatile.Register32 // 0x158C
	LUT178L  volatile.Register32 // 0x1590
	LUT178H  volatile.Register32 // 0x1594
	LUT179L  volatile.Register32 // 0x1598
	LUT179H  volatile.Register32 // 0x159C
	LUT180L  volatile.Register32 // 0x15A0
	LUT180H  volatile.Register32 // 0x15A4
	LUT181L  volatile.Register32 // 0x15A8
	LUT181H  volatile.Register32 // 0x15AC
	LUT182L  volatile.Register32 // 0x15B0
	LUT182H  volatile.Register32 // 0x15B4
	LUT183L  volatile.Register32 // 0x15B8
	LUT183H  volatile.Register32 // 0x15BC
	LUT184L  volatile.Register32 // 0x15C0
	LUT184H  volatile.Register32 // 0x15C4
	LUT185L  volatile.Register32 // 0x15C8
	LUT185H  volatile.Register32 // 0x15CC
	LUT186L  volatile.Register32 // 0x15D0
	LUT186H  volatile.Register32 // 0x15D4
	LUT187L  volatile.Register32 // 0x15D8
	LUT187H  volatile.Register32 // 0x15DC
	LUT188L  volatile.Register32 // 0x15E0
	LUT188H  volatile.Register32 // 0x15E4
	LUT189L  volatile.Register32 // 0x15E8
	LUT189H  volatile.Register32 // 0x15EC
	LUT190L  volatile.Register32 // 0x15F0
	LUT190H  volatile.Register32 // 0x15F4
	LUT191L  volatile.Register32 // 0x15F8
	LUT191H  volatile.Register32 // 0x15FC
	LUT192L  volatile.Register32 // 0x1600
	LUT192H  volatile.Register32 // 0x1604
	LUT193L  volatile.Register32 // 0x1608
	LUT193H  volatile.Register32 // 0x160C
	LUT194L  volatile.Register32 // 0x1610
	LUT194H  volatile.Register32 // 0x1614
	LUT195L  volatile.Register32 // 0x1618
	LUT195H  volatile.Register32 // 0x161C
	LUT196L  volatile.Register32 // 0x1620
	LUT196H  volatile.Register32 // 0x1624
	LUT197L  volatile.Register32 // 0x1628
	LUT197H  volatile.Register32 // 0x162C
	LUT198L  volatile.Register32 // 0x1630
	LUT198H  volatile.Register32 // 0x1634
	LUT199L  volatile.Register32 // 0x1638
	LUT199H  volatile.Register32 // 0x163C
	LUT200L  volatile.Register32 // 0x1640
	LUT200H  volatile.Register32 // 0x1644
	LUT201L  volatile.Register32 // 0x1648
	LUT201H  volatile.Register32 // 0x164C
	LUT202L  volatile.Register32 // 0x1650
	LUT202H  volatile.Register32 // 0x1654
	LUT203L  volatile.Register32 // 0x1658
	LUT203H  volatile.Register32 // 0x165C
	LUT204L  volatile.Register32 // 0x1660
	LUT204H  volatile.Register32 // 0x1664
	LUT205L  volatile.Register32 // 0x1668
	LUT205H  volatile.Register32 // 0x166C
	LUT206L  volatile.Register32 // 0x1670
	LUT206H  volatile.Register32 // 0x1674
	LUT207L  volatile.Register32 // 0x1678
	LUT207H  volatile.Register32 // 0x167C
	LUT208L  volatile.Register32 // 0x1680
	LUT208H  volatile.Register32 // 0x1684
	LUT209L  volatile.Register32 // 0x1688
	LUT209H  volatile.Register32 // 0x168C
	LUT210L  volatile.Register32 // 0x1690
	LUT210H  volatile.Register32 // 0x1694
	LUT211L  volatile.Register32 // 0x1698
	LUT211H  volatile.Register32 // 0x169C
	LUT212L  volatile.Register32 // 0x16A0
	LUT212H  volatile.Register32 // 0x16A4
	LUT213L  volatile.Register32 // 0x16A8
	LUT213H  volatile.Register32 // 0x16AC
	LUT214L  volatile.Register32 // 0x16B0
	LUT214H  volatile.Register32 // 0x16B4
	LUT215L  volatile.Register32 // 0x16B8
	LUT215H  volatile.Register32 // 0x16BC
	LUT216L  volatile.Register32 // 0x16C0
	LUT216H  volatile.Register32 // 0x16C4
	LUT217L  volatile.Register32 // 0x16C8
	LUT217H  volatile.Register32 // 0x16CC
	LUT218L  volatile.Register32 // 0x16D0
	LUT218H  volatile.Register32 // 0x16D4
	LUT219L  volatile.Register32 // 0x16D8
	LUT219H  volatile.Register32 // 0x16DC
	LUT220L  volatile.Register32 // 0x16E0
	LUT220H  volatile.Register32 // 0x16E4
	LUT221L  volatile.Register32 // 0x16E8
	LUT221H  volatile.Register32 // 0x16EC
	LUT222L  volatile.Register32 // 0x16F0
	LUT222H  volatile.Register32 // 0x16F4
	LUT223L  volatile.Register32 // 0x16F8
	LUT223H  volatile.Register32 // 0x16FC
	LUT224L  volatile.Register32 // 0x1700
	LUT224H  volatile.Register32 // 0x1704
	LUT225L  volatile.Register32 // 0x1708
	LUT225H  volatile.Register32 // 0x170C
	LUT226L  volatile.Register32 // 0x1710
	LUT226H  volatile.Register32 // 0x1714
	LUT227L  volatile.Register32 // 0x1718
	LUT227H  volatile.Register32 // 0x171C
	LUT228L  volatile.Register32 // 0x1720
	LUT228H  volatile.Register32 // 0x1724
	LUT229L  volatile.Register32 // 0x1728
	LUT229H  volatile.Register32 // 0x172C
	LUT230L  volatile.Register32 // 0x1730
	LUT230H  volatile.Register32 // 0x1734
	LUT231L  volatile.Register32 // 0x1738
	LUT231H  volatile.Register32 // 0x173C
	LUT232L  volatile.Register32 // 0x1740
	LUT232H  volatile.Register32 // 0x1744
	LUT233L  volatile.Register32 // 0x1748
	LUT233H  volatile.Register32 // 0x174C
	LUT234L  volatile.Register32 // 0x1750
	LUT234H  volatile.Register32 // 0x1754
	LUT235L  volatile.Register32 // 0x1758
	LUT235H  volatile.Register32 // 0x175C
	LUT236L  volatile.Register32 // 0x1760
	LUT236H  volatile.Register32 // 0x1764
	LUT237L  volatile.Register32 // 0x1768
	LUT237H  volatile.Register32 // 0x176C
	LUT238L  volatile.Register32 // 0x1770
	LUT238H  volatile.Register32 // 0x1774
	LUT239L  volatile.Register32 // 0x1778
	LUT239H  volatile.Register32 // 0x177C
	LUT240L  volatile.Register32 // 0x1780
	LUT240H  volatile.Register32 // 0x1784
	LUT241L  volatile.Register32 // 0x1788
	LUT241H  volatile.Register32 // 0x178C
	LUT242L  volatile.Register32 // 0x1790
	LUT242H  volatile.Register32 // 0x1794
	LUT243L  volatile.Register32 // 0x1798
	LUT243H  volatile.Register32 // 0x179C
	LUT244L  volatile.Register32 // 0x17A0
	LUT244H  volatile.Register32 // 0x17A4
	LUT245L  volatile.Register32 // 0x17A8
	LUT245H  volatile.Register32 // 0x17AC
	LUT246L  volatile.Register32 // 0x17B0
	LUT246H  volatile.Register32 // 0x17B4
	LUT247L  volatile.Register32 // 0x17B8
	LUT247H  volatile.Register32 // 0x17BC
	LUT248L  volatile.Register32 // 0x17C0
	LUT248H  volatile.Register32 // 0x17C4
	LUT249L  volatile.Register32 // 0x17C8
	LUT249H  volatile.Register32 // 0x17CC
	LUT250L  volatile.Register32 // 0x17D0
	LUT250H  volatile.Register32 // 0x17D4
	LUT251L  volatile.Register32 // 0x17D8
	LUT251H  volatile.Register32 // 0x17DC
	LUT252L  volatile.Register32 // 0x17E0
	LUT252H  volatile.Register32 // 0x17E4
	LUT253L  volatile.Register32 // 0x17E8
	LUT253H  volatile.Register32 // 0x17EC
	LUT254L  volatile.Register32 // 0x17F0
	LUT254H  volatile.Register32 // 0x17F4
	LUT255L  volatile.Register32 // 0x17F8
	LUT255H  volatile.Register32 // 0x17FC
	LUT256L  volatile.Register32 // 0x1800
	LUT256H  volatile.Register32 // 0x1804
	LUT257L  volatile.Register32 // 0x1808
	LUT257H  volatile.Register32 // 0x180C
	LUT258L  volatile.Register32 // 0x1810
	LUT258H  volatile.Register32 // 0x1814
	LUT259L  volatile.Register32 // 0x1818
	LUT259H  volatile.Register32 // 0x181C
	LUT260L  volatile.Register32 // 0x1820
	LUT260H  volatile.Register32 // 0x1824
	LUT261L  volatile.Register32 // 0x1828
	LUT261H  volatile.Register32 // 0x182C
	LUT262L  volatile.Register32 // 0x1830
	LUT262H  volatile.Register32 // 0x1834
	LUT263L  volatile.Register32 // 0x1838
	LUT263H  volatile.Register32 // 0x183C
	LUT264L  volatile.Register32 // 0x1840
	LUT264H  volatile.Register32 // 0x1844
	LUT265L  volatile.Register32 // 0x1848
	LUT265H  volatile.Register32 // 0x184C
	LUT266L  volatile.Register32 // 0x1850
	LUT266H  volatile.Register32 // 0x1854
	LUT267L  volatile.Register32 // 0x1858
	LUT267H  volatile.Register32 // 0x185C
	LUT268L  volatile.Register32 // 0x1860
	LUT268H  volatile.Register32 // 0x1864
	LUT269L  volatile.Register32 // 0x1868
	LUT269H  volatile.Register32 // 0x186C
	LUT270L  volatile.Register32 // 0x1870
	LUT270H  volatile.Register32 // 0x1874
	LUT271L  volatile.Register32 // 0x1878
	LUT271H  volatile.Register32 // 0x187C
	LUT272L  volatile.Register32 // 0x1880
	LUT272H  volatile.Register32 // 0x1884
	LUT273L  volatile.Register32 // 0x1888
	LUT273H  volatile.Register32 // 0x188C
	LUT274L  volatile.Register32 // 0x1890
	LUT274H  volatile.Register32 // 0x1894
	LUT275L  volatile.Register32 // 0x1898
	LUT275H  volatile.Register32 // 0x189C
	LUT276L  volatile.Register32 // 0x18A0
	LUT276H  volatile.Register32 // 0x18A4
	LUT277L  volatile.Register32 // 0x18A8
	LUT277H  volatile.Register32 // 0x18AC
	LUT278L  volatile.Register32 // 0x18B0
	LUT278H  volatile.Register32 // 0x18B4
	LUT279L  volatile.Register32 // 0x18B8
	LUT279H  volatile.Register32 // 0x18BC
	LUT280L  volatile.Register32 // 0x18C0
	LUT280H  volatile.Register32 // 0x18C4
	LUT281L  volatile.Register32 // 0x18C8
	LUT281H  volatile.Register32 // 0x18CC
	LUT282L  volatile.Register32 // 0x18D0
	LUT282H  volatile.Register32 // 0x18D4
	LUT283L  volatile.Register32 // 0x18D8
	LUT283H  volatile.Register32 // 0x18DC
	LUT284L  volatile.Register32 // 0x18E0
	LUT284H  volatile.Register32 // 0x18E4
	LUT285L  volatile.Register32 // 0x18E8
	LUT285H  volatile.Register32 // 0x18EC
	LUT286L  volatile.Register32 // 0x18F0
	LUT286H  volatile.Register32 // 0x18F4
	LUT287L  volatile.Register32 // 0x18F8
	LUT287H  volatile.Register32 // 0x18FC
	LUT288L  volatile.Register32 // 0x1900
	LUT288H  volatile.Register32 // 0x1904
	LUT289L  volatile.Register32 // 0x1908
	LUT289H  volatile.Register32 // 0x190C
	LUT290L  volatile.Register32 // 0x1910
	LUT290H  volatile.Register32 // 0x1914
	LUT291L  volatile.Register32 // 0x1918
	LUT291H  volatile.Register32 // 0x191C
	LUT292L  volatile.Register32 // 0x1920
	LUT292H  volatile.Register32 // 0x1924
	LUT293L  volatile.Register32 // 0x1928
	LUT293H  volatile.Register32 // 0x192C
	LUT294L  volatile.Register32 // 0x1930
	LUT294H  volatile.Register32 // 0x1934
	LUT295L  volatile.Register32 // 0x1938
	LUT295H  volatile.Register32 // 0x193C
	LUT296L  volatile.Register32 // 0x1940
	LUT296H  volatile.Register32 // 0x1944
	LUT297L  volatile.Register32 // 0x1948
	LUT297H  volatile.Register32 // 0x194C
	LUT298L  volatile.Register32 // 0x1950
	LUT298H  volatile.Register32 // 0x1954
	LUT299L  volatile.Register32 // 0x1958
	LUT299H  volatile.Register32 // 0x195C
	LUT300L  volatile.Register32 // 0x1960
	LUT300H  volatile.Register32 // 0x1964
	LUT301L  volatile.Register32 // 0x1968
	LUT301H  volatile.Register32 // 0x196C
	LUT302L  volatile.Register32 // 0x1970
	LUT302H  volatile.Register32 // 0x1974
	LUT303L  volatile.Register32 // 0x1978
	LUT303H  volatile.Register32 // 0x197C
	LUT304L  volatile.Register32 // 0x1980
	LUT304H  volatile.Register32 // 0x1984
	LUT305L  volatile.Register32 // 0x1988
	LUT305H  volatile.Register32 // 0x198C
	LUT306L  volatile.Register32 // 0x1990
	LUT306H  volatile.Register32 // 0x1994
	LUT307L  volatile.Register32 // 0x1998
	LUT307H  volatile.Register32 // 0x199C
	LUT308L  volatile.Register32 // 0x19A0
	LUT308H  volatile.Register32 // 0x19A4
	LUT309L  volatile.Register32 // 0x19A8
	LUT309H  volatile.Register32 // 0x19AC
	LUT310L  volatile.Register32 // 0x19B0
	LUT310H  volatile.Register32 // 0x19B4
	LUT311L  volatile.Register32 // 0x19B8
	LUT311H  volatile.Register32 // 0x19BC
	LUT312L  volatile.Register32 // 0x19C0
	LUT312H  volatile.Register32 // 0x19C4
	LUT313L  volatile.Register32 // 0x19C8
	LUT313H  volatile.Register32 // 0x19CC
	LUT314L  volatile.Register32 // 0x19D0
	LUT314H  volatile.Register32 // 0x19D4
	LUT315L  volatile.Register32 // 0x19D8
	LUT315H  volatile.Register32 // 0x19DC
	LUT316L  volatile.Register32 // 0x19E0
	LUT316H  volatile.Register32 // 0x19E4
	LUT317L  volatile.Register32 // 0x19E8
	LUT317H  volatile.Register32 // 0x19EC
	LUT318L  volatile.Register32 // 0x19F0
	LUT318H  volatile.Register32 // 0x19F4
	LUT319L  volatile.Register32 // 0x19F8
	LUT319H  volatile.Register32 // 0x19FC
	LUT320L  volatile.Register32 // 0x1A00
	LUT320H  volatile.Register32 // 0x1A04
	LUT321L  volatile.Register32 // 0x1A08
	LUT321H  volatile.Register32 // 0x1A0C
	LUT322L  volatile.Register32 // 0x1A10
	LUT322H  volatile.Register32 // 0x1A14
	LUT323L  volatile.Register32 // 0x1A18
	LUT323H  volatile.Register32 // 0x1A1C
	LUT324L  volatile.Register32 // 0x1A20
	LUT324H  volatile.Register32 // 0x1A24
	LUT325L  volatile.Register32 // 0x1A28
	LUT325H  volatile.Register32 // 0x1A2C
	LUT326L  volatile.Register32 // 0x1A30
	LUT326H  volatile.Register32 // 0x1A34
	LUT327L  volatile.Register32 // 0x1A38
	LUT327H  volatile.Register32 // 0x1A3C
	LUT328L  volatile.Register32 // 0x1A40
	LUT328H  volatile.Register32 // 0x1A44
	LUT329L  volatile.Register32 // 0x1A48
	LUT329H  volatile.Register32 // 0x1A4C
	LUT330L  volatile.Register32 // 0x1A50
	LUT330H  volatile.Register32 // 0x1A54
	LUT331L  volatile.Register32 // 0x1A58
	LUT331H  volatile.Register32 // 0x1A5C
	LUT332L  volatile.Register32 // 0x1A60
	LUT332H  volatile.Register32 // 0x1A64
	LUT333L  volatile.Register32 // 0x1A68
	LUT333H  volatile.Register32 // 0x1A6C
	LUT334L  volatile.Register32 // 0x1A70
	LUT334H  volatile.Register32 // 0x1A74
	LUT335L  volatile.Register32 // 0x1A78
	LUT335H  volatile.Register32 // 0x1A7C
	LUT336L  volatile.Register32 // 0x1A80
	LUT336H  volatile.Register32 // 0x1A84
	LUT337L  volatile.Register32 // 0x1A88
	LUT337H  volatile.Register32 // 0x1A8C
	LUT338L  volatile.Register32 // 0x1A90
	LUT338H  volatile.Register32 // 0x1A94
	LUT339L  volatile.Register32 // 0x1A98
	LUT339H  volatile.Register32 // 0x1A9C
	LUT340L  volatile.Register32 // 0x1AA0
	LUT340H  volatile.Register32 // 0x1AA4
	LUT341L  volatile.Register32 // 0x1AA8
	LUT341H  volatile.Register32 // 0x1AAC
	LUT342L  volatile.Register32 // 0x1AB0
	LUT342H  volatile.Register32 // 0x1AB4
	LUT343L  volatile.Register32 // 0x1AB8
	LUT343H  volatile.Register32 // 0x1ABC
	LUT344L  volatile.Register32 // 0x1AC0
	LUT344H  volatile.Register32 // 0x1AC4
	LUT345L  volatile.Register32 // 0x1AC8
	LUT345H  volatile.Register32 // 0x1ACC
	LUT346L  volatile.Register32 // 0x1AD0
	LUT346H  volatile.Register32 // 0x1AD4
	LUT347L  volatile.Register32 // 0x1AD8
	LUT347H  volatile.Register32 // 0x1ADC
	LUT348L  volatile.Register32 // 0x1AE0
	LUT348H  volatile.Register32 // 0x1AE4
	LUT349L  volatile.Register32 // 0x1AE8
	LUT349H  volatile.Register32 // 0x1AEC
	LUT350L  volatile.Register32 // 0x1AF0
	LUT350H  volatile.Register32 // 0x1AF4
	LUT351L  volatile.Register32 // 0x1AF8
	LUT351H  volatile.Register32 // 0x1AFC
	LUT352L  volatile.Register32 // 0x1B00
	LUT352H  volatile.Register32 // 0x1B04
	LUT353L  volatile.Register32 // 0x1B08
	LUT353H  volatile.Register32 // 0x1B0C
	LUT354L  volatile.Register32 // 0x1B10
	LUT354H  volatile.Register32 // 0x1B14
	LUT355L  volatile.Register32 // 0x1B18
	LUT355H  volatile.Register32 // 0x1B1C
	LUT356L  volatile.Register32 // 0x1B20
	LUT356H  volatile.Register32 // 0x1B24
	LUT357L  volatile.Register32 // 0x1B28
	LUT357H  volatile.Register32 // 0x1B2C
	LUT358L  volatile.Register32 // 0x1B30
	LUT358H  volatile.Register32 // 0x1B34
	LUT359L  volatile.Register32 // 0x1B38
	LUT359H  volatile.Register32 // 0x1B3C
	LUT360L  volatile.Register32 // 0x1B40
	LUT360H  volatile.Register32 // 0x1B44
	LUT361L  volatile.Register32 // 0x1B48
	LUT361H  volatile.Register32 // 0x1B4C
	LUT362L  volatile.Register32 // 0x1B50
	LUT362H  volatile.Register32 // 0x1B54
	LUT363L  volatile.Register32 // 0x1B58
	LUT363H  volatile.Register32 // 0x1B5C
	LUT364L  volatile.Register32 // 0x1B60
	LUT364H  volatile.Register32 // 0x1B64
	LUT365L  volatile.Register32 // 0x1B68
	LUT365H  volatile.Register32 // 0x1B6C
	LUT366L  volatile.Register32 // 0x1B70
	LUT366H  volatile.Register32 // 0x1B74
	LUT367L  volatile.Register32 // 0x1B78
	LUT367H  volatile.Register32 // 0x1B7C
	LUT368L  volatile.Register32 // 0x1B80
	LUT368H  volatile.Register32 // 0x1B84
	LUT369L  volatile.Register32 // 0x1B88
	LUT369H  volatile.Register32 // 0x1B8C
	LUT370L  volatile.Register32 // 0x1B90
	LUT370H  volatile.Register32 // 0x1B94
	LUT371L  volatile.Register32 // 0x1B98
	LUT371H  volatile.Register32 // 0x1B9C
	LUT372L  volatile.Register32 // 0x1BA0
	LUT372H  volatile.Register32 // 0x1BA4
	LUT373L  volatile.Register32 // 0x1BA8
	LUT373H  volatile.Register32 // 0x1BAC
	LUT374L  volatile.Register32 // 0x1BB0
	LUT374H  volatile.Register32 // 0x1BB4
	LUT375L  volatile.Register32 // 0x1BB8
	LUT375H  volatile.Register32 // 0x1BBC
	LUT376L  volatile.Register32 // 0x1BC0
	LUT376H  volatile.Register32 // 0x1BC4
	LUT377L  volatile.Register32 // 0x1BC8
	LUT377H  volatile.Register32 // 0x1BCC
	LUT378L  volatile.Register32 // 0x1BD0
	LUT378H  volatile.Register32 // 0x1BD4
	LUT379L  volatile.Register32 // 0x1BD8
	LUT379H  volatile.Register32 // 0x1BDC
	LUT380L  volatile.Register32 // 0x1BE0
	LUT380H  volatile.Register32 // 0x1BE4
	LUT381L  volatile.Register32 // 0x1BE8
	LUT381H  volatile.Register32 // 0x1BEC
	LUT382L  volatile.Register32 // 0x1BF0
	LUT382H  volatile.Register32 // 0x1BF4
	LUT383L  volatile.Register32 // 0x1BF8
	LUT383H  volatile.Register32 // 0x1BFC
	LUT384L  volatile.Register32 // 0x1C00
	LUT384H  volatile.Register32 // 0x1C04
	LUT385L  volatile.Register32 // 0x1C08
	LUT385H  volatile.Register32 // 0x1C0C
	LUT386L  volatile.Register32 // 0x1C10
	LUT386H  volatile.Register32 // 0x1C14
	LUT387L  volatile.Register32 // 0x1C18
	LUT387H  volatile.Register32 // 0x1C1C
	LUT388L  volatile.Register32 // 0x1C20
	LUT388H  volatile.Register32 // 0x1C24
	LUT389L  volatile.Register32 // 0x1C28
	LUT389H  volatile.Register32 // 0x1C2C
	LUT390L  volatile.Register32 // 0x1C30
	LUT390H  volatile.Register32 // 0x1C34
	LUT391L  volatile.Register32 // 0x1C38
	LUT391H  volatile.Register32 // 0x1C3C
	LUT392L  volatile.Register32 // 0x1C40
	LUT392H  volatile.Register32 // 0x1C44
	LUT393L  volatile.Register32 // 0x1C48
	LUT393H  volatile.Register32 // 0x1C4C
	LUT394L  volatile.Register32 // 0x1C50
	LUT394H  volatile.Register32 // 0x1C54
	LUT395L  volatile.Register32 // 0x1C58
	LUT395H  volatile.Register32 // 0x1C5C
	LUT396L  volatile.Register32 // 0x1C60
	LUT396H  volatile.Register32 // 0x1C64
	LUT397L  volatile.Register32 // 0x1C68
	LUT397H  volatile.Register32 // 0x1C6C
	LUT398L  volatile.Register32 // 0x1C70
	LUT398H  volatile.Register32 // 0x1C74
	LUT399L  volatile.Register32 // 0x1C78
	LUT399H  volatile.Register32 // 0x1C7C
	LUT400L  volatile.Register32 // 0x1C80
	LUT400H  volatile.Register32 // 0x1C84
	LUT401L  volatile.Register32 // 0x1C88
	LUT401H  volatile.Register32 // 0x1C8C
	LUT402L  volatile.Register32 // 0x1C90
	LUT402H  volatile.Register32 // 0x1C94
	LUT403L  volatile.Register32 // 0x1C98
	LUT403H  volatile.Register32 // 0x1C9C
	LUT404L  volatile.Register32 // 0x1CA0
	LUT404H  volatile.Register32 // 0x1CA4
	LUT405L  volatile.Register32 // 0x1CA8
	LUT405H  volatile.Register32 // 0x1CAC
	LUT406L  volatile.Register32 // 0x1CB0
	LUT406H  volatile.Register32 // 0x1CB4
	LUT407L  volatile.Register32 // 0x1CB8
	LUT407H  volatile.Register32 // 0x1CBC
	LUT408L  volatile.Register32 // 0x1CC0
	LUT408H  volatile.Register32 // 0x1CC4
	LUT409L  volatile.Register32 // 0x1CC8
	LUT409H  volatile.Register32 // 0x1CCC
	LUT410L  volatile.Register32 // 0x1CD0
	LUT410H  volatile.Register32 // 0x1CD4
	LUT411L  volatile.Register32 // 0x1CD8
	LUT411H  volatile.Register32 // 0x1CDC
	LUT412L  volatile.Register32 // 0x1CE0
	LUT412H  volatile.Register32 // 0x1CE4
	LUT413L  volatile.Register32 // 0x1CE8
	LUT413H  volatile.Register32 // 0x1CEC
	LUT414L  volatile.Register32 // 0x1CF0
	LUT414H  volatile.Register32 // 0x1CF4
	LUT415L  volatile.Register32 // 0x1CF8
	LUT415H  volatile.Register32 // 0x1CFC
	LUT416L  volatile.Register32 // 0x1D00
	LUT416H  volatile.Register32 // 0x1D04
	LUT417L  volatile.Register32 // 0x1D08
	LUT417H  volatile.Register32 // 0x1D0C
	LUT418L  volatile.Register32 // 0x1D10
	LUT418H  volatile.Register32 // 0x1D14
	LUT419L  volatile.Register32 // 0x1D18
	LUT419H  volatile.Register32 // 0x1D1C
	LUT420L  volatile.Register32 // 0x1D20
	LUT420H  volatile.Register32 // 0x1D24
	LUT421L  volatile.Register32 // 0x1D28
	LUT421H  volatile.Register32 // 0x1D2C
	LUT422L  volatile.Register32 // 0x1D30
	LUT422H  volatile.Register32 // 0x1D34
	LUT423L  volatile.Register32 // 0x1D38
	LUT423H  volatile.Register32 // 0x1D3C
	LUT424L  volatile.Register32 // 0x1D40
	LUT424H  volatile.Register32 // 0x1D44
	LUT425L  volatile.Register32 // 0x1D48
	LUT425H  volatile.Register32 // 0x1D4C
	LUT426L  volatile.Register32 // 0x1D50
	LUT426H  volatile.Register32 // 0x1D54
	LUT427L  volatile.Register32 // 0x1D58
	LUT427H  volatile.Register32 // 0x1D5C
	LUT428L  volatile.Register32 // 0x1D60
	LUT428H  volatile.Register32 // 0x1D64
	LUT429L  volatile.Register32 // 0x1D68
	LUT429H  volatile.Register32 // 0x1D6C
	LUT430L  volatile.Register32 // 0x1D70
	LUT430H  volatile.Register32 // 0x1D74
	LUT431L  volatile.Register32 // 0x1D78
	LUT431H  volatile.Register32 // 0x1D7C
	LUT432L  volatile.Register32 // 0x1D80
	LUT432H  volatile.Register32 // 0x1D84
	LUT433L  volatile.Register32 // 0x1D88
	LUT433H  volatile.Register32 // 0x1D8C
	LUT434L  volatile.Register32 // 0x1D90
	LUT434H  volatile.Register32 // 0x1D94
	LUT435L  volatile.Register32 // 0x1D98
	LUT435H  volatile.Register32 // 0x1D9C
	LUT436L  volatile.Register32 // 0x1DA0
	LUT436H  volatile.Register32 // 0x1DA4
	LUT437L  volatile.Register32 // 0x1DA8
	LUT437H  volatile.Register32 // 0x1DAC
	LUT438L  volatile.Register32 // 0x1DB0
	LUT438H  volatile.Register32 // 0x1DB4
	LUT439L  volatile.Register32 // 0x1DB8
	LUT439H  volatile.Register32 // 0x1DBC
	LUT440L  volatile.Register32 // 0x1DC0
	LUT440H  volatile.Register32 // 0x1DC4
	LUT441L  volatile.Register32 // 0x1DC8
	LUT441H  volatile.Register32 // 0x1DCC
	LUT442L  volatile.Register32 // 0x1DD0
	LUT442H  volatile.Register32 // 0x1DD4
	LUT443L  volatile.Register32 // 0x1DD8
	LUT443H  volatile.Register32 // 0x1DDC
	LUT444L  volatile.Register32 // 0x1DE0
	LUT444H  volatile.Register32 // 0x1DE4
	LUT445L  volatile.Register32 // 0x1DE8
	LUT445H  volatile.Register32 // 0x1DEC
	LUT446L  volatile.Register32 // 0x1DF0
	LUT446H  volatile.Register32 // 0x1DF4
	LUT447L  volatile.Register32 // 0x1DF8
	LUT447H  volatile.Register32 // 0x1DFC
	LUT448L  volatile.Register32 // 0x1E00
	LUT448H  volatile.Register32 // 0x1E04
	LUT449L  volatile.Register32 // 0x1E08
	LUT449H  volatile.Register32 // 0x1E0C
	LUT450L  volatile.Register32 // 0x1E10
	LUT450H  volatile.Register32 // 0x1E14
	LUT451L  volatile.Register32 // 0x1E18
	LUT451H  volatile.Register32 // 0x1E1C
	LUT452L  volatile.Register32 // 0x1E20
	LUT452H  volatile.Register32 // 0x1E24
	LUT453L  volatile.Register32 // 0x1E28
	LUT453H  volatile.Register32 // 0x1E2C
	LUT454L  volatile.Register32 // 0x1E30
	LUT454H  volatile.Register32 // 0x1E34
	LUT455L  volatile.Register32 // 0x1E38
	LUT455H  volatile.Register32 // 0x1E3C
	LUT456L  volatile.Register32 // 0x1E40
	LUT456H  volatile.Register32 // 0x1E44
	LUT457L  volatile.Register32 // 0x1E48
	LUT457H  volatile.Register32 // 0x1E4C
	LUT458L  volatile.Register32 // 0x1E50
	LUT458H  volatile.Register32 // 0x1E54
	LUT459L  volatile.Register32 // 0x1E58
	LUT459H  volatile.Register32 // 0x1E5C
	LUT460L  volatile.Register32 // 0x1E60
	LUT460H  volatile.Register32 // 0x1E64
	LUT461L  volatile.Register32 // 0x1E68
	LUT461H  volatile.Register32 // 0x1E6C
	LUT462L  volatile.Register32 // 0x1E70
	LUT462H  volatile.Register32 // 0x1E74
	LUT463L  volatile.Register32 // 0x1E78
	LUT463H  volatile.Register32 // 0x1E7C
	LUT464L  volatile.Register32 // 0x1E80
	LUT464H  volatile.Register32 // 0x1E84
	LUT465L  volatile.Register32 // 0x1E88
	LUT465H  volatile.Register32 // 0x1E8C
	LUT466L  volatile.Register32 // 0x1E90
	LUT466H  volatile.Register32 // 0x1E94
	LUT467L  volatile.Register32 // 0x1E98
	LUT467H  volatile.Register32 // 0x1E9C
	LUT468L  volatile.Register32 // 0x1EA0
	LUT468H  volatile.Register32 // 0x1EA4
	LUT469L  volatile.Register32 // 0x1EA8
	LUT469H  volatile.Register32 // 0x1EAC
	LUT470L  volatile.Register32 // 0x1EB0
	LUT470H  volatile.Register32 // 0x1EB4
	LUT471L  volatile.Register32 // 0x1EB8
	LUT471H  volatile.Register32 // 0x1EBC
	LUT472L  volatile.Register32 // 0x1EC0
	LUT472H  volatile.Register32 // 0x1EC4
	LUT473L  volatile.Register32 // 0x1EC8
	LUT473H  volatile.Register32 // 0x1ECC
	LUT474L  volatile.Register32 // 0x1ED0
	LUT474H  volatile.Register32 // 0x1ED4
	LUT475L  volatile.Register32 // 0x1ED8
	LUT475H  volatile.Register32 // 0x1EDC
	LUT476L  volatile.Register32 // 0x1EE0
	LUT476H  volatile.Register32 // 0x1EE4
	LUT477L  volatile.Register32 // 0x1EE8
	LUT477H  volatile.Register32 // 0x1EEC
	LUT478L  volatile.Register32 // 0x1EF0
	LUT478H  volatile.Register32 // 0x1EF4
	LUT479L  volatile.Register32 // 0x1EF8
	LUT479H  volatile.Register32 // 0x1EFC
	LUT480L  volatile.Register32 // 0x1F00
	LUT480H  volatile.Register32 // 0x1F04
	LUT481L  volatile.Register32 // 0x1F08
	LUT481H  volatile.Register32 // 0x1F0C
	LUT482L  volatile.Register32 // 0x1F10
	LUT482H  volatile.Register32 // 0x1F14
	LUT483L  volatile.Register32 // 0x1F18
	LUT483H  volatile.Register32 // 0x1F1C
	LUT484L  volatile.Register32 // 0x1F20
	LUT484H  volatile.Register32 // 0x1F24
	LUT485L  volatile.Register32 // 0x1F28
	LUT485H  volatile.Register32 // 0x1F2C
	LUT486L  volatile.Register32 // 0x1F30
	LUT486H  volatile.Register32 // 0x1F34
	LUT487L  volatile.Register32 // 0x1F38
	LUT487H  volatile.Register32 // 0x1F3C
	LUT488L  volatile.Register32 // 0x1F40
	LUT488H  volatile.Register32 // 0x1F44
	LUT489L  volatile.Register32 // 0x1F48
	LUT489H  volatile.Register32 // 0x1F4C
	LUT490L  volatile.Register32 // 0x1F50
	LUT490H  volatile.Register32 // 0x1F54
	LUT491L  volatile.Register32 // 0x1F58
	LUT491H  volatile.Register32 // 0x1F5C
	LUT492L  volatile.Register32 // 0x1F60
	LUT492H  volatile.Register32 // 0x1F64
	LUT493L  volatile.Register32 // 0x1F68
	LUT493H  volatile.Register32 // 0x1F6C
	LUT494L  volatile.Register32 // 0x1F70
	LUT494H  volatile.Register32 // 0x1F74
	LUT495L  volatile.Register32 // 0x1F78
	LUT495H  volatile.Register32 // 0x1F7C
	LUT496L  volatile.Register32 // 0x1F80
	LUT496H  volatile.Register32 // 0x1F84
	LUT497L  volatile.Register32 // 0x1F88
	LUT497H  volatile.Register32 // 0x1F8C
	LUT498L  volatile.Register32 // 0x1F90
	LUT498H  volatile.Register32 // 0x1F94
	LUT499L  volatile.Register32 // 0x1F98
	LUT499H  volatile.Register32 // 0x1F9C
	LUT500L  volatile.Register32 // 0x1FA0
	LUT500H  volatile.Register32 // 0x1FA4
	LUT501L  volatile.Register32 // 0x1FA8
	LUT501H  volatile.Register32 // 0x1FAC
	LUT502L  volatile.Register32 // 0x1FB0
	LUT502H  volatile.Register32 // 0x1FB4
	LUT503L  volatile.Register32 // 0x1FB8
	LUT503H  volatile.Register32 // 0x1FBC
	LUT504L  volatile.Register32 // 0x1FC0
	LUT504H  volatile.Register32 // 0x1FC4
	LUT505L  volatile.Register32 // 0x1FC8
	LUT505H  volatile.Register32 // 0x1FCC
	LUT506L  volatile.Register32 // 0x1FD0
	LUT506H  volatile.Register32 // 0x1FD4
	LUT507L  volatile.Register32 // 0x1FD8
	LUT507H  volatile.Register32 // 0x1FDC
	LUT508L  volatile.Register32 // 0x1FE0
	LUT508H  volatile.Register32 // 0x1FE4
	LUT509L  volatile.Register32 // 0x1FE8
	LUT509H  volatile.Register32 // 0x1FEC
	LUT510L  volatile.Register32 // 0x1FF0
	LUT510H  volatile.Register32 // 0x1FF4
	LUT511L  volatile.Register32 // 0x1FF8
	LUT511H  volatile.Register32 // 0x1FFC
	LUT512L  volatile.Register32 // 0x2000
	LUT512H  volatile.Register32 // 0x2004
	LUT513L  volatile.Register32 // 0x2008
	LUT513H  volatile.Register32 // 0x200C
	LUT514L  volatile.Register32 // 0x2010
	LUT514H  volatile.Register32 // 0x2014
	LUT515L  volatile.Register32 // 0x2018
	LUT515H  volatile.Register32 // 0x201C
	LUT516L  volatile.Register32 // 0x2020
	LUT516H  volatile.Register32 // 0x2024
	LUT517L  volatile.Register32 // 0x2028
	LUT517H  volatile.Register32 // 0x202C
	LUT518L  volatile.Register32 // 0x2030
	LUT518H  volatile.Register32 // 0x2034
	LUT519L  volatile.Register32 // 0x2038
	LUT519H  volatile.Register32 // 0x203C
	LUT520L  volatile.Register32 // 0x2040
	LUT520H  volatile.Register32 // 0x2044
	LUT521L  volatile.Register32 // 0x2048
	LUT521H  volatile.Register32 // 0x204C
	LUT522L  volatile.Register32 // 0x2050
	LUT522H  volatile.Register32 // 0x2054
	LUT523L  volatile.Register32 // 0x2058
	LUT523H  volatile.Register32 // 0x205C
	LUT524L  volatile.Register32 // 0x2060
	LUT524H  volatile.Register32 // 0x2064
	LUT525L  volatile.Register32 // 0x2068
	LUT525H  volatile.Register32 // 0x206C
	LUT526L  volatile.Register32 // 0x2070
	LUT526H  volatile.Register32 // 0x2074
	LUT527L  volatile.Register32 // 0x2078
	LUT527H  volatile.Register32 // 0x207C
	LUT528L  volatile.Register32 // 0x2080
	LUT528H  volatile.Register32 // 0x2084
	LUT529L  volatile.Register32 // 0x2088
	LUT529H  volatile.Register32 // 0x208C
	LUT530L  volatile.Register32 // 0x2090
	LUT530H  volatile.Register32 // 0x2094
	LUT531L  volatile.Register32 // 0x2098
	LUT531H  volatile.Register32 // 0x209C
	LUT532L  volatile.Register32 // 0x20A0
	LUT532H  volatile.Register32 // 0x20A4
	LUT533L  volatile.Register32 // 0x20A8
	LUT533H  volatile.Register32 // 0x20AC
	LUT534L  volatile.Register32 // 0x20B0
	LUT534H  volatile.Register32 // 0x20B4
	LUT535L  volatile.Register32 // 0x20B8
	LUT535H  volatile.Register32 // 0x20BC
	LUT536L  volatile.Register32 // 0x20C0
	LUT536H  volatile.Register32 // 0x20C4
	LUT537L  volatile.Register32 // 0x20C8
	LUT537H  volatile.Register32 // 0x20CC
	LUT538L  volatile.Register32 // 0x20D0
	LUT538H  volatile.Register32 // 0x20D4
	LUT539L  volatile.Register32 // 0x20D8
	LUT539H  volatile.Register32 // 0x20DC
	LUT540L  volatile.Register32 // 0x20E0
	LUT540H  volatile.Register32 // 0x20E4
	LUT541L  volatile.Register32 // 0x20E8
	LUT541H  volatile.Register32 // 0x20EC
	LUT542L  volatile.Register32 // 0x20F0
	LUT542H  volatile.Register32 // 0x20F4
	LUT543L  volatile.Register32 // 0x20F8
	LUT543H  volatile.Register32 // 0x20FC
	LUT544L  volatile.Register32 // 0x2100
	LUT544H  volatile.Register32 // 0x2104
	LUT545L  volatile.Register32 // 0x2108
	LUT545H  volatile.Register32 // 0x210C
	LUT546L  volatile.Register32 // 0x2110
	LUT546H  volatile.Register32 // 0x2114
	LUT547L  volatile.Register32 // 0x2118
	LUT547H  volatile.Register32 // 0x211C
	LUT548L  volatile.Register32 // 0x2120
	LUT548H  volatile.Register32 // 0x2124
	LUT549L  volatile.Register32 // 0x2128
	LUT549H  volatile.Register32 // 0x212C
	LUT550L  volatile.Register32 // 0x2130
	LUT550H  volatile.Register32 // 0x2134
	LUT551L  volatile.Register32 // 0x2138
	LUT551H  volatile.Register32 // 0x213C
	LUT552L  volatile.Register32 // 0x2140
	LUT552H  volatile.Register32 // 0x2144
	LUT553L  volatile.Register32 // 0x2148
	LUT553H  volatile.Register32 // 0x214C
	LUT554L  volatile.Register32 // 0x2150
	LUT554H  volatile.Register32 // 0x2154
	LUT555L  volatile.Register32 // 0x2158
	LUT555H  volatile.Register32 // 0x215C
	LUT556L  volatile.Register32 // 0x2160
	LUT556H  volatile.Register32 // 0x2164
	LUT557L  volatile.Register32 // 0x2168
	LUT557H  volatile.Register32 // 0x216C
	LUT558L  volatile.Register32 // 0x2170
	LUT558H  volatile.Register32 // 0x2174
	LUT559L  volatile.Register32 // 0x2178
	LUT559H  volatile.Register32 // 0x217C
	LUT560L  volatile.Register32 // 0x2180
	LUT560H  volatile.Register32 // 0x2184
	LUT561L  volatile.Register32 // 0x2188
	LUT561H  volatile.Register32 // 0x218C
	LUT562L  volatile.Register32 // 0x2190
	LUT562H  volatile.Register32 // 0x2194
	LUT563L  volatile.Register32 // 0x2198
	LUT563H  volatile.Register32 // 0x219C
	LUT564L  volatile.Register32 // 0x21A0
	LUT564H  volatile.Register32 // 0x21A4
	LUT565L  volatile.Register32 // 0x21A8
	LUT565H  volatile.Register32 // 0x21AC
	LUT566L  volatile.Register32 // 0x21B0
	LUT566H  volatile.Register32 // 0x21B4
	LUT567L  volatile.Register32 // 0x21B8
	LUT567H  volatile.Register32 // 0x21BC
	LUT568L  volatile.Register32 // 0x21C0
	LUT568H  volatile.Register32 // 0x21C4
	LUT569L  volatile.Register32 // 0x21C8
	LUT569H  volatile.Register32 // 0x21CC
	LUT570L  volatile.Register32 // 0x21D0
	LUT570H  volatile.Register32 // 0x21D4
	LUT571L  volatile.Register32 // 0x21D8
	LUT571H  volatile.Register32 // 0x21DC
	LUT572L  volatile.Register32 // 0x21E0
	LUT572H  volatile.Register32 // 0x21E4
	LUT573L  volatile.Register32 // 0x21E8
	LUT573H  volatile.Register32 // 0x21EC
	LUT574L  volatile.Register32 // 0x21F0
	LUT574H  volatile.Register32 // 0x21F4
	LUT575L  volatile.Register32 // 0x21F8
	LUT575H  volatile.Register32 // 0x21FC
	LUT576L  volatile.Register32 // 0x2200
	LUT576H  volatile.Register32 // 0x2204
	LUT577L  volatile.Register32 // 0x2208
	LUT577H  volatile.Register32 // 0x220C
	LUT578L  volatile.Register32 // 0x2210
	LUT578H  volatile.Register32 // 0x2214
	LUT579L  volatile.Register32 // 0x2218
	LUT579H  volatile.Register32 // 0x221C
	LUT580L  volatile.Register32 // 0x2220
	LUT580H  volatile.Register32 // 0x2224
	LUT581L  volatile.Register32 // 0x2228
	LUT581H  volatile.Register32 // 0x222C
	LUT582L  volatile.Register32 // 0x2230
	LUT582H  volatile.Register32 // 0x2234
	LUT583L  volatile.Register32 // 0x2238
	LUT583H  volatile.Register32 // 0x223C
	LUT584L  volatile.Register32 // 0x2240
	LUT584H  volatile.Register32 // 0x2244
	LUT585L  volatile.Register32 // 0x2248
	LUT585H  volatile.Register32 // 0x224C
	LUT586L  volatile.Register32 // 0x2250
	LUT586H  volatile.Register32 // 0x2254
	LUT587L  volatile.Register32 // 0x2258
	LUT587H  volatile.Register32 // 0x225C
	LUT588L  volatile.Register32 // 0x2260
	LUT588H  volatile.Register32 // 0x2264
	LUT589L  volatile.Register32 // 0x2268
	LUT589H  volatile.Register32 // 0x226C
	LUT590L  volatile.Register32 // 0x2270
	LUT590H  volatile.Register32 // 0x2274
	LUT591L  volatile.Register32 // 0x2278
	LUT591H  volatile.Register32 // 0x227C
	LUT592L  volatile.Register32 // 0x2280
	LUT592H  volatile.Register32 // 0x2284
	LUT593L  volatile.Register32 // 0x2288
	LUT593H  volatile.Register32 // 0x228C
	LUT594L  volatile.Register32 // 0x2290
	LUT594H  volatile.Register32 // 0x2294
	LUT595L  volatile.Register32 // 0x2298
	LUT595H  volatile.Register32 // 0x229C
	LUT596L  volatile.Register32 // 0x22A0
	LUT596H  volatile.Register32 // 0x22A4
	LUT597L  volatile.Register32 // 0x22A8
	LUT597H  volatile.Register32 // 0x22AC
	LUT598L  volatile.Register32 // 0x22B0
	LUT598H  volatile.Register32 // 0x22B4
	LUT599L  volatile.Register32 // 0x22B8
	LUT599H  volatile.Register32 // 0x22BC
	LUT600L  volatile.Register32 // 0x22C0
	LUT600H  volatile.Register32 // 0x22C4
	LUT601L  volatile.Register32 // 0x22C8
	LUT601H  volatile.Register32 // 0x22CC
	LUT602L  volatile.Register32 // 0x22D0
	LUT602H  volatile.Register32 // 0x22D4
	LUT603L  volatile.Register32 // 0x22D8
	LUT603H  volatile.Register32 // 0x22DC
	LUT604L  volatile.Register32 // 0x22E0
	LUT604H  volatile.Register32 // 0x22E4
	LUT605L  volatile.Register32 // 0x22E8
	LUT605H  volatile.Register32 // 0x22EC
	LUT606L  volatile.Register32 // 0x22F0
	LUT606H  volatile.Register32 // 0x22F4
	LUT607L  volatile.Register32 // 0x22F8
	LUT607H  volatile.Register32 // 0x22FC
	LUT608L  volatile.Register32 // 0x2300
	LUT608H  volatile.Register32 // 0x2304
	LUT609L  volatile.Register32 // 0x2308
	LUT609H  volatile.Register32 // 0x230C
	LUT610L  volatile.Register32 // 0x2310
	LUT610H  volatile.Register32 // 0x2314
	LUT611L  volatile.Register32 // 0x2318
	LUT611H  volatile.Register32 // 0x231C
	LUT612L  volatile.Register32 // 0x2320
	LUT612H  volatile.Register32 // 0x2324
	LUT613L  volatile.Register32 // 0x2328
	LUT613H  volatile.Register32 // 0x232C
	LUT614L  volatile.Register32 // 0x2330
	LUT614H  volatile.Register32 // 0x2334
	LUT615L  volatile.Register32 // 0x2338
	LUT615H  volatile.Register32 // 0x233C
	LUT616L  volatile.Register32 // 0x2340
	LUT616H  volatile.Register32 // 0x2344
	LUT617L  volatile.Register32 // 0x2348
	LUT617H  volatile.Register32 // 0x234C
	LUT618L  volatile.Register32 // 0x2350
	LUT618H  volatile.Register32 // 0x2354
	LUT619L  volatile.Register32 // 0x2358
	LUT619H  volatile.Register32 // 0x235C
	LUT620L  volatile.Register32 // 0x2360
	LUT620H  volatile.Register32 // 0x2364
	LUT621L  volatile.Register32 // 0x2368
	LUT621H  volatile.Register32 // 0x236C
	LUT622L  volatile.Register32 // 0x2370
	LUT622H  volatile.Register32 // 0x2374
	LUT623L  volatile.Register32 // 0x2378
	LUT623H  volatile.Register32 // 0x237C
	LUT624L  volatile.Register32 // 0x2380
	LUT624H  volatile.Register32 // 0x2384
	LUT625L  volatile.Register32 // 0x2388
	LUT625H  volatile.Register32 // 0x238C
	LUT626L  volatile.Register32 // 0x2390
	LUT626H  volatile.Register32 // 0x2394
	LUT627L  volatile.Register32 // 0x2398
	LUT627H  volatile.Register32 // 0x239C
	LUT628L  volatile.Register32 // 0x23A0
	LUT628H  volatile.Register32 // 0x23A4
	LUT629L  volatile.Register32 // 0x23A8
	LUT629H  volatile.Register32 // 0x23AC
	LUT630L  volatile.Register32 // 0x23B0
	LUT630H  volatile.Register32 // 0x23B4
	LUT631L  volatile.Register32 // 0x23B8
	LUT631H  volatile.Register32 // 0x23BC
	LUT632L  volatile.Register32 // 0x23C0
	LUT632H  volatile.Register32 // 0x23C4
	LUT633L  volatile.Register32 // 0x23C8
	LUT633H  volatile.Register32 // 0x23CC
	LUT634L  volatile.Register32 // 0x23D0
	LUT634H  volatile.Register32 // 0x23D4
	LUT635L  volatile.Register32 // 0x23D8
	LUT635H  volatile.Register32 // 0x23DC
	LUT636L  volatile.Register32 // 0x23E0
	LUT636H  volatile.Register32 // 0x23E4
	LUT637L  volatile.Register32 // 0x23E8
	LUT637H  volatile.Register32 // 0x23EC
	LUT638L  volatile.Register32 // 0x23F0
	LUT638H  volatile.Register32 // 0x23F4
	LUT639L  volatile.Register32 // 0x23F8
	LUT639H  volatile.Register32 // 0x23FC
	LUT640L  volatile.Register32 // 0x2400
	LUT640H  volatile.Register32 // 0x2404
	LUT641L  volatile.Register32 // 0x2408
	LUT641H  volatile.Register32 // 0x240C
	LUT642L  volatile.Register32 // 0x2410
	LUT642H  volatile.Register32 // 0x2414
	LUT643L  volatile.Register32 // 0x2418
	LUT643H  volatile.Register32 // 0x241C
	LUT644L  volatile.Register32 // 0x2420
	LUT644H  volatile.Register32 // 0x2424
	LUT645L  volatile.Register32 // 0x2428
	LUT645H  volatile.Register32 // 0x242C
	LUT646L  volatile.Register32 // 0x2430
	LUT646H  volatile.Register32 // 0x2434
	LUT647L  volatile.Register32 // 0x2438
	LUT647H  volatile.Register32 // 0x243C
	LUT648L  volatile.Register32 // 0x2440
	LUT648H  volatile.Register32 // 0x2444
	LUT649L  volatile.Register32 // 0x2448
	LUT649H  volatile.Register32 // 0x244C
	LUT650L  volatile.Register32 // 0x2450
	LUT650H  volatile.Register32 // 0x2454
	LUT651L  volatile.Register32 // 0x2458
	LUT651H  volatile.Register32 // 0x245C
	LUT652L  volatile.Register32 // 0x2460
	LUT652H  volatile.Register32 // 0x2464
	LUT653L  volatile.Register32 // 0x2468
	LUT653H  volatile.Register32 // 0x246C
	LUT654L  volatile.Register32 // 0x2470
	LUT654H  volatile.Register32 // 0x2474
	LUT655L  volatile.Register32 // 0x2478
	LUT655H  volatile.Register32 // 0x247C
	LUT656L  volatile.Register32 // 0x2480
	LUT656H  volatile.Register32 // 0x2484
	LUT657L  volatile.Register32 // 0x2488
	LUT657H  volatile.Register32 // 0x248C
	LUT658L  volatile.Register32 // 0x2490
	LUT658H  volatile.Register32 // 0x2494
	LUT659L  volatile.Register32 // 0x2498
	LUT659H  volatile.Register32 // 0x249C
	LUT660L  volatile.Register32 // 0x24A0
	LUT660H  volatile.Register32 // 0x24A4
	LUT661L  volatile.Register32 // 0x24A8
	LUT661H  volatile.Register32 // 0x24AC
	LUT662L  volatile.Register32 // 0x24B0
	LUT662H  volatile.Register32 // 0x24B4
	LUT663L  volatile.Register32 // 0x24B8
	LUT663H  volatile.Register32 // 0x24BC
	LUT664L  volatile.Register32 // 0x24C0
	LUT664H  volatile.Register32 // 0x24C4
	LUT665L  volatile.Register32 // 0x24C8
	LUT665H  volatile.Register32 // 0x24CC
	LUT666L  volatile.Register32 // 0x24D0
	LUT666H  volatile.Register32 // 0x24D4
	LUT667L  volatile.Register32 // 0x24D8
	LUT667H  volatile.Register32 // 0x24DC
	LUT668L  volatile.Register32 // 0x24E0
	LUT668H  volatile.Register32 // 0x24E4
	LUT669L  volatile.Register32 // 0x24E8
	LUT669H  volatile.Register32 // 0x24EC
	LUT670L  volatile.Register32 // 0x24F0
	LUT670H  volatile.Register32 // 0x24F4
	LUT671L  volatile.Register32 // 0x24F8
	LUT671H  volatile.Register32 // 0x24FC
	LUT672L  volatile.Register32 // 0x2500
	LUT672H  volatile.Register32 // 0x2504
	LUT673L  volatile.Register32 // 0x2508
	LUT673H  volatile.Register32 // 0x250C
	LUT674L  volatile.Register32 // 0x2510
	LUT674H  volatile.Register32 // 0x2514
	LUT675L  volatile.Register32 // 0x2518
	LUT675H  volatile.Register32 // 0x251C
	LUT676L  volatile.Register32 // 0x2520
	LUT676H  volatile.Register32 // 0x2524
	LUT677L  volatile.Register32 // 0x2528
	LUT677H  volatile.Register32 // 0x252C
	LUT678L  volatile.Register32 // 0x2530
	LUT678H  volatile.Register32 // 0x2534
	LUT679L  volatile.Register32 // 0x2538
	LUT679H  volatile.Register32 // 0x253C
	LUT680L  volatile.Register32 // 0x2540
	LUT680H  volatile.Register32 // 0x2544
	LUT681L  volatile.Register32 // 0x2548
	LUT681H  volatile.Register32 // 0x254C
	LUT682L  volatile.Register32 // 0x2550
	LUT682H  volatile.Register32 // 0x2554
	LUT683L  volatile.Register32 // 0x2558
	LUT683H  volatile.Register32 // 0x255C
	LUT684L  volatile.Register32 // 0x2560
	LUT684H  volatile.Register32 // 0x2564
	LUT685L  volatile.Register32 // 0x2568
	LUT685H  volatile.Register32 // 0x256C
	LUT686L  volatile.Register32 // 0x2570
	LUT686H  volatile.Register32 // 0x2574
	LUT687L  volatile.Register32 // 0x2578
	LUT687H  volatile.Register32 // 0x257C
	LUT688L  volatile.Register32 // 0x2580
	LUT688H  volatile.Register32 // 0x2584
	LUT689L  volatile.Register32 // 0x2588
	LUT689H  volatile.Register32 // 0x258C
	LUT690L  volatile.Register32 // 0x2590
	LUT690H  volatile.Register32 // 0x2594
	LUT691L  volatile.Register32 // 0x2598
	LUT691H  volatile.Register32 // 0x259C
	LUT692L  volatile.Register32 // 0x25A0
	LUT692H  volatile.Register32 // 0x25A4
	LUT693L  volatile.Register32 // 0x25A8
	LUT693H  volatile.Register32 // 0x25AC
	LUT694L  volatile.Register32 // 0x25B0
	LUT694H  volatile.Register32 // 0x25B4
	LUT695L  volatile.Register32 // 0x25B8
	LUT695H  volatile.Register32 // 0x25BC
	LUT696L  volatile.Register32 // 0x25C0
	LUT696H  volatile.Register32 // 0x25C4
	LUT697L  volatile.Register32 // 0x25C8
	LUT697H  volatile.Register32 // 0x25CC
	LUT698L  volatile.Register32 // 0x25D0
	LUT698H  volatile.Register32 // 0x25D4
	LUT699L  volatile.Register32 // 0x25D8
	LUT699H  volatile.Register32 // 0x25DC
	LUT700L  volatile.Register32 // 0x25E0
	LUT700H  volatile.Register32 // 0x25E4
	LUT701L  volatile.Register32 // 0x25E8
	LUT701H  volatile.Register32 // 0x25EC
	LUT702L  volatile.Register32 // 0x25F0
	LUT702H  volatile.Register32 // 0x25F4
	LUT703L  volatile.Register32 // 0x25F8
	LUT703H  volatile.Register32 // 0x25FC
	LUT704L  volatile.Register32 // 0x2600
	LUT704H  volatile.Register32 // 0x2604
	LUT705L  volatile.Register32 // 0x2608
	LUT705H  volatile.Register32 // 0x260C
	LUT706L  volatile.Register32 // 0x2610
	LUT706H  volatile.Register32 // 0x2614
	LUT707L  volatile.Register32 // 0x2618
	LUT707H  volatile.Register32 // 0x261C
	LUT708L  volatile.Register32 // 0x2620
	LUT708H  volatile.Register32 // 0x2624
	LUT709L  volatile.Register32 // 0x2628
	LUT709H  volatile.Register32 // 0x262C
	LUT710L  volatile.Register32 // 0x2630
	LUT710H  volatile.Register32 // 0x2634
	LUT711L  volatile.Register32 // 0x2638
	LUT711H  volatile.Register32 // 0x263C
	LUT712L  volatile.Register32 // 0x2640
	LUT712H  volatile.Register32 // 0x2644
	LUT713L  volatile.Register32 // 0x2648
	LUT713H  volatile.Register32 // 0x264C
	LUT714L  volatile.Register32 // 0x2650
	LUT714H  volatile.Register32 // 0x2654
	LUT715L  volatile.Register32 // 0x2658
	LUT715H  volatile.Register32 // 0x265C
	LUT716L  volatile.Register32 // 0x2660
	LUT716H  volatile.Register32 // 0x2664
	LUT717L  volatile.Register32 // 0x2668
	LUT717H  volatile.Register32 // 0x266C
	LUT718L  volatile.Register32 // 0x2670
	LUT718H  volatile.Register32 // 0x2674
	LUT719L  volatile.Register32 // 0x2678
	LUT719H  volatile.Register32 // 0x267C
	LUT720L  volatile.Register32 // 0x2680
	LUT720H  volatile.Register32 // 0x2684
	LUT721L  volatile.Register32 // 0x2688
	LUT721H  volatile.Register32 // 0x268C
	LUT722L  volatile.Register32 // 0x2690
	LUT722H  volatile.Register32 // 0x2694
	LUT723L  volatile.Register32 // 0x2698
	LUT723H  volatile.Register32 // 0x269C
	LUT724L  volatile.Register32 // 0x26A0
	LUT724H  volatile.Register32 // 0x26A4
	LUT725L  volatile.Register32 // 0x26A8
	LUT725H  volatile.Register32 // 0x26AC
	LUT726L  volatile.Register32 // 0x26B0
	LUT726H  volatile.Register32 // 0x26B4
	LUT727L  volatile.Register32 // 0x26B8
	LUT727H  volatile.Register32 // 0x26BC
	LUT728L  volatile.Register32 // 0x26C0
	LUT728H  volatile.Register32 // 0x26C4
	LUT729L  volatile.Register32 // 0x26C8
	LUT729H  volatile.Register32 // 0x26CC
	LUT730L  volatile.Register32 // 0x26D0
	LUT730H  volatile.Register32 // 0x26D4
	LUT731L  volatile.Register32 // 0x26D8
	LUT731H  volatile.Register32 // 0x26DC
	LUT732L  volatile.Register32 // 0x26E0
	LUT732H  volatile.Register32 // 0x26E4
	LUT733L  volatile.Register32 // 0x26E8
	LUT733H  volatile.Register32 // 0x26EC
	LUT734L  volatile.Register32 // 0x26F0
	LUT734H  volatile.Register32 // 0x26F4
	LUT735L  volatile.Register32 // 0x26F8
	LUT735H  volatile.Register32 // 0x26FC
	LUT736L  volatile.Register32 // 0x2700
	LUT736H  volatile.Register32 // 0x2704
	LUT737L  volatile.Register32 // 0x2708
	LUT737H  volatile.Register32 // 0x270C
	LUT738L  volatile.Register32 // 0x2710
	LUT738H  volatile.Register32 // 0x2714
	LUT739L  volatile.Register32 // 0x2718
	LUT739H  volatile.Register32 // 0x271C
	LUT740L  volatile.Register32 // 0x2720
	LUT740H  volatile.Register32 // 0x2724
	LUT741L  volatile.Register32 // 0x2728
	LUT741H  volatile.Register32 // 0x272C
	LUT742L  volatile.Register32 // 0x2730
	LUT742H  volatile.Register32 // 0x2734
	LUT743L  volatile.Register32 // 0x2738
	LUT743H  volatile.Register32 // 0x273C
	LUT744L  volatile.Register32 // 0x2740
	LUT744H  volatile.Register32 // 0x2744
	LUT745L  volatile.Register32 // 0x2748
	LUT745H  volatile.Register32 // 0x274C
	LUT746L  volatile.Register32 // 0x2750
	LUT746H  volatile.Register32 // 0x2754
	LUT747L  volatile.Register32 // 0x2758
	LUT747H  volatile.Register32 // 0x275C
	LUT748L  volatile.Register32 // 0x2760
	LUT748H  volatile.Register32 // 0x2764
	LUT749L  volatile.Register32 // 0x2768
	LUT749H  volatile.Register32 // 0x276C
	LUT750L  volatile.Register32 // 0x2770
	LUT750H  volatile.Register32 // 0x2774
	LUT751L  volatile.Register32 // 0x2778
	LUT751H  volatile.Register32 // 0x277C
	LUT752L  volatile.Register32 // 0x2780
	LUT752H  volatile.Register32 // 0x2784
	LUT753L  volatile.Register32 // 0x2788
	LUT753H  volatile.Register32 // 0x278C
	LUT754L  volatile.Register32 // 0x2790
	LUT754H  volatile.Register32 // 0x2794
	LUT755L  volatile.Register32 // 0x2798
	LUT755H  volatile.Register32 // 0x279C
	LUT756L  volatile.Register32 // 0x27A0
	LUT756H  volatile.Register32 // 0x27A4
	LUT757L  volatile.Register32 // 0x27A8
	LUT757H  volatile.Register32 // 0x27AC
	LUT758L  volatile.Register32 // 0x27B0
	LUT758H  volatile.Register32 // 0x27B4
	LUT759L  volatile.Register32 // 0x27B8
	LUT759H  volatile.Register32 // 0x27BC
	LUT760L  volatile.Register32 // 0x27C0
	LUT760H  volatile.Register32 // 0x27C4
	LUT761L  volatile.Register32 // 0x27C8
	LUT761H  volatile.Register32 // 0x27CC
	LUT762L  volatile.Register32 // 0x27D0
	LUT762H  volatile.Register32 // 0x27D4
	LUT763L  volatile.Register32 // 0x27D8
	LUT763H  volatile.Register32 // 0x27DC
	LUT764L  volatile.Register32 // 0x27E0
	LUT764H  volatile.Register32 // 0x27E4
	LUT765L  volatile.Register32 // 0x27E8
	LUT765H  volatile.Register32 // 0x27EC
	LUT766L  volatile.Register32 // 0x27F0
	LUT766H  volatile.Register32 // 0x27F4
	LUT767L  volatile.Register32 // 0x27F8
	LUT767H  volatile.Register32 // 0x27FC
	LUT768L  volatile.Register32 // 0x2800
	LUT768H  volatile.Register32 // 0x2804
	LUT769L  volatile.Register32 // 0x2808
	LUT769H  volatile.Register32 // 0x280C
	LUT770L  volatile.Register32 // 0x2810
	LUT770H  volatile.Register32 // 0x2814
	LUT771L  volatile.Register32 // 0x2818
	LUT771H  volatile.Register32 // 0x281C
	LUT772L  volatile.Register32 // 0x2820
	LUT772H  volatile.Register32 // 0x2824
	LUT773L  volatile.Register32 // 0x2828
	LUT773H  volatile.Register32 // 0x282C
	LUT774L  volatile.Register32 // 0x2830
	LUT774H  volatile.Register32 // 0x2834
	LUT775L  volatile.Register32 // 0x2838
	LUT775H  volatile.Register32 // 0x283C
	LUT776L  volatile.Register32 // 0x2840
	LUT776H  volatile.Register32 // 0x2844
	LUT777L  volatile.Register32 // 0x2848
	LUT777H  volatile.Register32 // 0x284C
	LUT778L  volatile.Register32 // 0x2850
	LUT778H  volatile.Register32 // 0x2854
	LUT779L  volatile.Register32 // 0x2858
	LUT779H  volatile.Register32 // 0x285C
	LUT780L  volatile.Register32 // 0x2860
	LUT780H  volatile.Register32 // 0x2864
	LUT781L  volatile.Register32 // 0x2868
	LUT781H  volatile.Register32 // 0x286C
	LUT782L  volatile.Register32 // 0x2870
	LUT782H  volatile.Register32 // 0x2874
	LUT783L  volatile.Register32 // 0x2878
	LUT783H  volatile.Register32 // 0x287C
	LUT784L  volatile.Register32 // 0x2880
	LUT784H  volatile.Register32 // 0x2884
	LUT785L  volatile.Register32 // 0x2888
	LUT785H  volatile.Register32 // 0x288C
	LUT786L  volatile.Register32 // 0x2890
	LUT786H  volatile.Register32 // 0x2894
	LUT787L  volatile.Register32 // 0x2898
	LUT787H  volatile.Register32 // 0x289C
	LUT788L  volatile.Register32 // 0x28A0
	LUT788H  volatile.Register32 // 0x28A4
	LUT789L  volatile.Register32 // 0x28A8
	LUT789H  volatile.Register32 // 0x28AC
	LUT790L  volatile.Register32 // 0x28B0
	LUT790H  volatile.Register32 // 0x28B4
	LUT791L  volatile.Register32 // 0x28B8
	LUT791H  volatile.Register32 // 0x28BC
	LUT792L  volatile.Register32 // 0x28C0
	LUT792H  volatile.Register32 // 0x28C4
	LUT793L  volatile.Register32 // 0x28C8
	LUT793H  volatile.Register32 // 0x28CC
	LUT794L  volatile.Register32 // 0x28D0
	LUT794H  volatile.Register32 // 0x28D4
	LUT795L  volatile.Register32 // 0x28D8
	LUT795H  volatile.Register32 // 0x28DC
	LUT796L  volatile.Register32 // 0x28E0
	LUT796H  volatile.Register32 // 0x28E4
	LUT797L  volatile.Register32 // 0x28E8
	LUT797H  volatile.Register32 // 0x28EC
	LUT798L  volatile.Register32 // 0x28F0
	LUT798H  volatile.Register32 // 0x28F4
	LUT799L  volatile.Register32 // 0x28F8
	LUT799H  volatile.Register32 // 0x28FC
	LUT800L  volatile.Register32 // 0x2900
	LUT800H  volatile.Register32 // 0x2904
	LUT801L  volatile.Register32 // 0x2908
	LUT801H  volatile.Register32 // 0x290C
	LUT802L  volatile.Register32 // 0x2910
	LUT802H  volatile.Register32 // 0x2914
	LUT803L  volatile.Register32 // 0x2918
	LUT803H  volatile.Register32 // 0x291C
	LUT804L  volatile.Register32 // 0x2920
	LUT804H  volatile.Register32 // 0x2924
	LUT805L  volatile.Register32 // 0x2928
	LUT805H  volatile.Register32 // 0x292C
	LUT806L  volatile.Register32 // 0x2930
	LUT806H  volatile.Register32 // 0x2934
	LUT807L  volatile.Register32 // 0x2938
	LUT807H  volatile.Register32 // 0x293C
	LUT808L  volatile.Register32 // 0x2940
	LUT808H  volatile.Register32 // 0x2944
	LUT809L  volatile.Register32 // 0x2948
	LUT809H  volatile.Register32 // 0x294C
	LUT810L  volatile.Register32 // 0x2950
	LUT810H  volatile.Register32 // 0x2954
	LUT811L  volatile.Register32 // 0x2958
	LUT811H  volatile.Register32 // 0x295C
	LUT812L  volatile.Register32 // 0x2960
	LUT812H  volatile.Register32 // 0x2964
	LUT813L  volatile.Register32 // 0x2968
	LUT813H  volatile.Register32 // 0x296C
	LUT814L  volatile.Register32 // 0x2970
	LUT814H  volatile.Register32 // 0x2974
	LUT815L  volatile.Register32 // 0x2978
	LUT815H  volatile.Register32 // 0x297C
	LUT816L  volatile.Register32 // 0x2980
	LUT816H  volatile.Register32 // 0x2984
	LUT817L  volatile.Register32 // 0x2988
	LUT817H  volatile.Register32 // 0x298C
	LUT818L  volatile.Register32 // 0x2990
	LUT818H  volatile.Register32 // 0x2994
	LUT819L  volatile.Register32 // 0x2998
	LUT819H  volatile.Register32 // 0x299C
	LUT820L  volatile.Register32 // 0x29A0
	LUT820H  volatile.Register32 // 0x29A4
	LUT821L  volatile.Register32 // 0x29A8
	LUT821H  volatile.Register32 // 0x29AC
	LUT822L  volatile.Register32 // 0x29B0
	LUT822H  volatile.Register32 // 0x29B4
	LUT823L  volatile.Register32 // 0x29B8
	LUT823H  volatile.Register32 // 0x29BC
	LUT824L  volatile.Register32 // 0x29C0
	LUT824H  volatile.Register32 // 0x29C4
	LUT825L  volatile.Register32 // 0x29C8
	LUT825H  volatile.Register32 // 0x29CC
	LUT826L  volatile.Register32 // 0x29D0
	LUT826H  volatile.Register32 // 0x29D4
	LUT827L  volatile.Register32 // 0x29D8
	LUT827H  volatile.Register32 // 0x29DC
	LUT828L  volatile.Register32 // 0x29E0
	LUT828H  volatile.Register32 // 0x29E4
	LUT829L  volatile.Register32 // 0x29E8
	LUT829H  volatile.Register32 // 0x29EC
	LUT830L  volatile.Register32 // 0x29F0
	LUT830H  volatile.Register32 // 0x29F4
	LUT831L  volatile.Register32 // 0x29F8
	LUT831H  volatile.Register32 // 0x29FC
	LUT832L  volatile.Register32 // 0x2A00
	LUT832H  volatile.Register32 // 0x2A04
	LUT833L  volatile.Register32 // 0x2A08
	LUT833H  volatile.Register32 // 0x2A0C
	LUT834L  volatile.Register32 // 0x2A10
	LUT834H  volatile.Register32 // 0x2A14
	LUT835L  volatile.Register32 // 0x2A18
	LUT835H  volatile.Register32 // 0x2A1C
	LUT836L  volatile.Register32 // 0x2A20
	LUT836H  volatile.Register32 // 0x2A24
	LUT837L  volatile.Register32 // 0x2A28
	LUT837H  volatile.Register32 // 0x2A2C
	LUT838L  volatile.Register32 // 0x2A30
	LUT838H  volatile.Register32 // 0x2A34
	LUT839L  volatile.Register32 // 0x2A38
	LUT839H  volatile.Register32 // 0x2A3C
	LUT840L  volatile.Register32 // 0x2A40
	LUT840H  volatile.Register32 // 0x2A44
	LUT841L  volatile.Register32 // 0x2A48
	LUT841H  volatile.Register32 // 0x2A4C
	LUT842L  volatile.Register32 // 0x2A50
	LUT842H  volatile.Register32 // 0x2A54
	LUT843L  volatile.Register32 // 0x2A58
	LUT843H  volatile.Register32 // 0x2A5C
	LUT844L  volatile.Register32 // 0x2A60
	LUT844H  volatile.Register32 // 0x2A64
	LUT845L  volatile.Register32 // 0x2A68
	LUT845H  volatile.Register32 // 0x2A6C
	LUT846L  volatile.Register32 // 0x2A70
	LUT846H  volatile.Register32 // 0x2A74
	LUT847L  volatile.Register32 // 0x2A78
	LUT847H  volatile.Register32 // 0x2A7C
	LUT848L  volatile.Register32 // 0x2A80
	LUT848H  volatile.Register32 // 0x2A84
	LUT849L  volatile.Register32 // 0x2A88
	LUT849H  volatile.Register32 // 0x2A8C
	LUT850L  volatile.Register32 // 0x2A90
	LUT850H  volatile.Register32 // 0x2A94
	LUT851L  volatile.Register32 // 0x2A98
	LUT851H  volatile.Register32 // 0x2A9C
	LUT852L  volatile.Register32 // 0x2AA0
	LUT852H  volatile.Register32 // 0x2AA4
	LUT853L  volatile.Register32 // 0x2AA8
	LUT853H  volatile.Register32 // 0x2AAC
	LUT854L  volatile.Register32 // 0x2AB0
	LUT854H  volatile.Register32 // 0x2AB4
	LUT855L  volatile.Register32 // 0x2AB8
	LUT855H  volatile.Register32 // 0x2ABC
	LUT856L  volatile.Register32 // 0x2AC0
	LUT856H  volatile.Register32 // 0x2AC4
	LUT857L  volatile.Register32 // 0x2AC8
	LUT857H  volatile.Register32 // 0x2ACC
	LUT858L  volatile.Register32 // 0x2AD0
	LUT858H  volatile.Register32 // 0x2AD4
	LUT859L  volatile.Register32 // 0x2AD8
	LUT859H  volatile.Register32 // 0x2ADC
	LUT860L  volatile.Register32 // 0x2AE0
	LUT860H  volatile.Register32 // 0x2AE4
	LUT861L  volatile.Register32 // 0x2AE8
	LUT861H  volatile.Register32 // 0x2AEC
	LUT862L  volatile.Register32 // 0x2AF0
	LUT862H  volatile.Register32 // 0x2AF4
	LUT863L  volatile.Register32 // 0x2AF8
	LUT863H  volatile.Register32 // 0x2AFC
	LUT864L  volatile.Register32 // 0x2B00
	LUT864H  volatile.Register32 // 0x2B04
	LUT865L  volatile.Register32 // 0x2B08
	LUT865H  volatile.Register32 // 0x2B0C
	LUT866L  volatile.Register32 // 0x2B10
	LUT866H  volatile.Register32 // 0x2B14
	LUT867L  volatile.Register32 // 0x2B18
	LUT867H  volatile.Register32 // 0x2B1C
	LUT868L  volatile.Register32 // 0x2B20
	LUT868H  volatile.Register32 // 0x2B24
	LUT869L  volatile.Register32 // 0x2B28
	LUT869H  volatile.Register32 // 0x2B2C
	LUT870L  volatile.Register32 // 0x2B30
	LUT870H  volatile.Register32 // 0x2B34
	LUT871L  volatile.Register32 // 0x2B38
	LUT871H  volatile.Register32 // 0x2B3C
	LUT872L  volatile.Register32 // 0x2B40
	LUT872H  volatile.Register32 // 0x2B44
	LUT873L  volatile.Register32 // 0x2B48
	LUT873H  volatile.Register32 // 0x2B4C
	LUT874L  volatile.Register32 // 0x2B50
	LUT874H  volatile.Register32 // 0x2B54
	LUT875L  volatile.Register32 // 0x2B58
	LUT875H  volatile.Register32 // 0x2B5C
	LUT876L  volatile.Register32 // 0x2B60
	LUT876H  volatile.Register32 // 0x2B64
	LUT877L  volatile.Register32 // 0x2B68
	LUT877H  volatile.Register32 // 0x2B6C
	LUT878L  volatile.Register32 // 0x2B70
	LUT878H  volatile.Register32 // 0x2B74
	LUT879L  volatile.Register32 // 0x2B78
	LUT879H  volatile.Register32 // 0x2B7C
	LUT880L  volatile.Register32 // 0x2B80
	LUT880H  volatile.Register32 // 0x2B84
	LUT881L  volatile.Register32 // 0x2B88
	LUT881H  volatile.Register32 // 0x2B8C
	LUT882L  volatile.Register32 // 0x2B90
	LUT882H  volatile.Register32 // 0x2B94
	LUT883L  volatile.Register32 // 0x2B98
	LUT883H  volatile.Register32 // 0x2B9C
	LUT884L  volatile.Register32 // 0x2BA0
	LUT884H  volatile.Register32 // 0x2BA4
	LUT885L  volatile.Register32 // 0x2BA8
	LUT885H  volatile.Register32 // 0x2BAC
	LUT886L  volatile.Register32 // 0x2BB0
	LUT886H  volatile.Register32 // 0x2BB4
	LUT887L  volatile.Register32 // 0x2BB8
	LUT887H  volatile.Register32 // 0x2BBC
	LUT888L  volatile.Register32 // 0x2BC0
	LUT888H  volatile.Register32 // 0x2BC4
	LUT889L  volatile.Register32 // 0x2BC8
	LUT889H  volatile.Register32 // 0x2BCC
	LUT890L  volatile.Register32 // 0x2BD0
	LUT890H  volatile.Register32 // 0x2BD4
	LUT891L  volatile.Register32 // 0x2BD8
	LUT891H  volatile.Register32 // 0x2BDC
	LUT892L  volatile.Register32 // 0x2BE0
	LUT892H  volatile.Register32 // 0x2BE4
	LUT893L  volatile.Register32 // 0x2BE8
	LUT893H  volatile.Register32 // 0x2BEC
	LUT894L  volatile.Register32 // 0x2BF0
	LUT894H  volatile.Register32 // 0x2BF4
	LUT895L  volatile.Register32 // 0x2BF8
	LUT895H  volatile.Register32 // 0x2BFC
	LUT896L  volatile.Register32 // 0x2C00
	LUT896H  volatile.Register32 // 0x2C04
	LUT897L  volatile.Register32 // 0x2C08
	LUT897H  volatile.Register32 // 0x2C0C
	LUT898L  volatile.Register32 // 0x2C10
	LUT898H  volatile.Register32 // 0x2C14
	LUT899L  volatile.Register32 // 0x2C18
	LUT899H  volatile.Register32 // 0x2C1C
	LUT900L  volatile.Register32 // 0x2C20
	LUT900H  volatile.Register32 // 0x2C24
	LUT901L  volatile.Register32 // 0x2C28
	LUT901H  volatile.Register32 // 0x2C2C
	LUT902L  volatile.Register32 // 0x2C30
	LUT902H  volatile.Register32 // 0x2C34
	LUT903L  volatile.Register32 // 0x2C38
	LUT903H  volatile.Register32 // 0x2C3C
	LUT904L  volatile.Register32 // 0x2C40
	LUT904H  volatile.Register32 // 0x2C44
	LUT905L  volatile.Register32 // 0x2C48
	LUT905H  volatile.Register32 // 0x2C4C
	LUT906L  volatile.Register32 // 0x2C50
	LUT906H  volatile.Register32 // 0x2C54
	LUT907L  volatile.Register32 // 0x2C58
	LUT907H  volatile.Register32 // 0x2C5C
	LUT908L  volatile.Register32 // 0x2C60
	LUT908H  volatile.Register32 // 0x2C64
	LUT909L  volatile.Register32 // 0x2C68
	LUT909H  volatile.Register32 // 0x2C6C
	LUT910L  volatile.Register32 // 0x2C70
	LUT910H  volatile.Register32 // 0x2C74
	LUT911L  volatile.Register32 // 0x2C78
	LUT911H  volatile.Register32 // 0x2C7C
	LUT912L  volatile.Register32 // 0x2C80
	LUT912H  volatile.Register32 // 0x2C84
	LUT913L  volatile.Register32 // 0x2C88
	LUT913H  volatile.Register32 // 0x2C8C
	LUT914L  volatile.Register32 // 0x2C90
	LUT914H  volatile.Register32 // 0x2C94
	LUT915L  volatile.Register32 // 0x2C98
	LUT915H  volatile.Register32 // 0x2C9C
	LUT916L  volatile.Register32 // 0x2CA0
	LUT916H  volatile.Register32 // 0x2CA4
	LUT917L  volatile.Register32 // 0x2CA8
	LUT917H  volatile.Register32 // 0x2CAC
	LUT918L  volatile.Register32 // 0x2CB0
	LUT918H  volatile.Register32 // 0x2CB4
	LUT919L  volatile.Register32 // 0x2CB8
	LUT919H  volatile.Register32 // 0x2CBC
	LUT920L  volatile.Register32 // 0x2CC0
	LUT920H  volatile.Register32 // 0x2CC4
	LUT921L  volatile.Register32 // 0x2CC8
	LUT921H  volatile.Register32 // 0x2CCC
	LUT922L  volatile.Register32 // 0x2CD0
	LUT922H  volatile.Register32 // 0x2CD4
	LUT923L  volatile.Register32 // 0x2CD8
	LUT923H  volatile.Register32 // 0x2CDC
	LUT924L  volatile.Register32 // 0x2CE0
	LUT924H  volatile.Register32 // 0x2CE4
	LUT925L  volatile.Register32 // 0x2CE8
	LUT925H  volatile.Register32 // 0x2CEC
	LUT926L  volatile.Register32 // 0x2CF0
	LUT926H  volatile.Register32 // 0x2CF4
	LUT927L  volatile.Register32 // 0x2CF8
	LUT927H  volatile.Register32 // 0x2CFC
	LUT928L  volatile.Register32 // 0x2D00
	LUT928H  volatile.Register32 // 0x2D04
	LUT929L  volatile.Register32 // 0x2D08
	LUT929H  volatile.Register32 // 0x2D0C
	LUT930L  volatile.Register32 // 0x2D10
	LUT930H  volatile.Register32 // 0x2D14
	LUT931L  volatile.Register32 // 0x2D18
	LUT931H  volatile.Register32 // 0x2D1C
	LUT932L  volatile.Register32 // 0x2D20
	LUT932H  volatile.Register32 // 0x2D24
	LUT933L  volatile.Register32 // 0x2D28
	LUT933H  volatile.Register32 // 0x2D2C
	LUT934L  volatile.Register32 // 0x2D30
	LUT934H  volatile.Register32 // 0x2D34
	LUT935L  volatile.Register32 // 0x2D38
	LUT935H  volatile.Register32 // 0x2D3C
	LUT936L  volatile.Register32 // 0x2D40
	LUT936H  volatile.Register32 // 0x2D44
	LUT937L  volatile.Register32 // 0x2D48
	LUT937H  volatile.Register32 // 0x2D4C
	LUT938L  volatile.Register32 // 0x2D50
	LUT938H  volatile.Register32 // 0x2D54
	LUT939L  volatile.Register32 // 0x2D58
	LUT939H  volatile.Register32 // 0x2D5C
	LUT940L  volatile.Register32 // 0x2D60
	LUT940H  volatile.Register32 // 0x2D64
	LUT941L  volatile.Register32 // 0x2D68
	LUT941H  volatile.Register32 // 0x2D6C
	LUT942L  volatile.Register32 // 0x2D70
	LUT942H  volatile.Register32 // 0x2D74
	LUT943L  volatile.Register32 // 0x2D78
	LUT943H  volatile.Register32 // 0x2D7C
	LUT944L  volatile.Register32 // 0x2D80
	LUT944H  volatile.Register32 // 0x2D84
	LUT945L  volatile.Register32 // 0x2D88
	LUT945H  volatile.Register32 // 0x2D8C
	LUT946L  volatile.Register32 // 0x2D90
	LUT946H  volatile.Register32 // 0x2D94
	LUT947L  volatile.Register32 // 0x2D98
	LUT947H  volatile.Register32 // 0x2D9C
	LUT948L  volatile.Register32 // 0x2DA0
	LUT948H  volatile.Register32 // 0x2DA4
	LUT949L  volatile.Register32 // 0x2DA8
	LUT949H  volatile.Register32 // 0x2DAC
	LUT950L  volatile.Register32 // 0x2DB0
	LUT950H  volatile.Register32 // 0x2DB4
	LUT951L  volatile.Register32 // 0x2DB8
	LUT951H  volatile.Register32 // 0x2DBC
	LUT952L  volatile.Register32 // 0x2DC0
	LUT952H  volatile.Register32 // 0x2DC4
	LUT953L  volatile.Register32 // 0x2DC8
	LUT953H  volatile.Register32 // 0x2DCC
	LUT954L  volatile.Register32 // 0x2DD0
	LUT954H  volatile.Register32 // 0x2DD4
	LUT955L  volatile.Register32 // 0x2DD8
	LUT955H  volatile.Register32 // 0x2DDC
	LUT956L  volatile.Register32 // 0x2DE0
	LUT956H  volatile.Register32 // 0x2DE4
	LUT957L  volatile.Register32 // 0x2DE8
	LUT957H  volatile.Register32 // 0x2DEC
	LUT958L  volatile.Register32 // 0x2DF0
	LUT958H  volatile.Register32 // 0x2DF4
	LUT959L  volatile.Register32 // 0x2DF8
	LUT959H  volatile.Register32 // 0x2DFC
	LUT960L  volatile.Register32 // 0x2E00
	LUT960H  volatile.Register32 // 0x2E04
	LUT961L  volatile.Register32 // 0x2E08
	LUT961H  volatile.Register32 // 0x2E0C
	LUT962L  volatile.Register32 // 0x2E10
	LUT962H  volatile.Register32 // 0x2E14
	LUT963L  volatile.Register32 // 0x2E18
	LUT963H  volatile.Register32 // 0x2E1C
	LUT964L  volatile.Register32 // 0x2E20
	LUT964H  volatile.Register32 // 0x2E24
	LUT965L  volatile.Register32 // 0x2E28
	LUT965H  volatile.Register32 // 0x2E2C
	LUT966L  volatile.Register32 // 0x2E30
	LUT966H  volatile.Register32 // 0x2E34
	LUT967L  volatile.Register32 // 0x2E38
	LUT967H  volatile.Register32 // 0x2E3C
	LUT968L  volatile.Register32 // 0x2E40
	LUT968H  volatile.Register32 // 0x2E44
	LUT969L  volatile.Register32 // 0x2E48
	LUT969H  volatile.Register32 // 0x2E4C
	LUT970L  volatile.Register32 // 0x2E50
	LUT970H  volatile.Register32 // 0x2E54
	LUT971L  volatile.Register32 // 0x2E58
	LUT971H  volatile.Register32 // 0x2E5C
	LUT972L  volatile.Register32 // 0x2E60
	LUT972H  volatile.Register32 // 0x2E64
	LUT973L  volatile.Register32 // 0x2E68
	LUT973H  volatile.Register32 // 0x2E6C
	LUT974L  volatile.Register32 // 0x2E70
	LUT974H  volatile.Register32 // 0x2E74
	LUT975L  volatile.Register32 // 0x2E78
	LUT975H  volatile.Register32 // 0x2E7C
	LUT976L  volatile.Register32 // 0x2E80
	LUT976H  volatile.Register32 // 0x2E84
	LUT977L  volatile.Register32 // 0x2E88
	LUT977H  volatile.Register32 // 0x2E8C
	LUT978L  volatile.Register32 // 0x2E90
	LUT978H  volatile.Register32 // 0x2E94
	LUT979L  volatile.Register32 // 0x2E98
	LUT979H  volatile.Register32 // 0x2E9C
	LUT980L  volatile.Register32 // 0x2EA0
	LUT980H  volatile.Register32 // 0x2EA4
	LUT981L  volatile.Register32 // 0x2EA8
	LUT981H  volatile.Register32 // 0x2EAC
	LUT982L  volatile.Register32 // 0x2EB0
	LUT982H  volatile.Register32 // 0x2EB4
	LUT983L  volatile.Register32 // 0x2EB8
	LUT983H  volatile.Register32 // 0x2EBC
	LUT984L  volatile.Register32 // 0x2EC0
	LUT984H  volatile.Register32 // 0x2EC4
	LUT985L  volatile.Register32 // 0x2EC8
	LUT985H  volatile.Register32 // 0x2ECC
	LUT986L  volatile.Register32 // 0x2ED0
	LUT986H  volatile.Register32 // 0x2ED4
	LUT987L  volatile.Register32 // 0x2ED8
	LUT987H  volatile.Register32 // 0x2EDC
	LUT988L  volatile.Register32 // 0x2EE0
	LUT988H  volatile.Register32 // 0x2EE4
	LUT989L  volatile.Register32 // 0x2EE8
	LUT989H  volatile.Register32 // 0x2EEC
	LUT990L  volatile.Register32 // 0x2EF0
	LUT990H  volatile.Register32 // 0x2EF4
	LUT991L  volatile.Register32 // 0x2EF8
	LUT991H  volatile.Register32 // 0x2EFC
	LUT992L  volatile.Register32 // 0x2F00
	LUT992H  volatile.Register32 // 0x2F04
	LUT993L  volatile.Register32 // 0x2F08
	LUT993H  volatile.Register32 // 0x2F0C
	LUT994L  volatile.Register32 // 0x2F10
	LUT994H  volatile.Register32 // 0x2F14
	LUT995L  volatile.Register32 // 0x2F18
	LUT995H  volatile.Register32 // 0x2F1C
	LUT996L  volatile.Register32 // 0x2F20
	LUT996H  volatile.Register32 // 0x2F24
	LUT997L  volatile.Register32 // 0x2F28
	LUT997H  volatile.Register32 // 0x2F2C
	LUT998L  volatile.Register32 // 0x2F30
	LUT998H  volatile.Register32 // 0x2F34
	LUT999L  volatile.Register32 // 0x2F38
	LUT999H  volatile.Register32 // 0x2F3C
	LUT1000L volatile.Register32 // 0x2F40
	LUT1000H volatile.Register32 // 0x2F44
	LUT1001L volatile.Register32 // 0x2F48
	LUT1001H volatile.Register32 // 0x2F4C
	LUT1002L volatile.Register32 // 0x2F50
	LUT1002H volatile.Register32 // 0x2F54
	LUT1003L volatile.Register32 // 0x2F58
	LUT1003H volatile.Register32 // 0x2F5C
	LUT1004L volatile.Register32 // 0x2F60
	LUT1004H volatile.Register32 // 0x2F64
	LUT1005L volatile.Register32 // 0x2F68
	LUT1005H volatile.Register32 // 0x2F6C
	LUT1006L volatile.Register32 // 0x2F70
	LUT1006H volatile.Register32 // 0x2F74
	LUT1007L volatile.Register32 // 0x2F78
	LUT1007H volatile.Register32 // 0x2F7C
	LUT1008L volatile.Register32 // 0x2F80
	LUT1008H volatile.Register32 // 0x2F84
	LUT1009L volatile.Register32 // 0x2F88
	LUT1009H volatile.Register32 // 0x2F8C
	LUT1010L volatile.Register32 // 0x2F90
	LUT1010H volatile.Register32 // 0x2F94
	LUT1011L volatile.Register32 // 0x2F98
	LUT1011H volatile.Register32 // 0x2F9C
	LUT1012L volatile.Register32 // 0x2FA0
	LUT1012H volatile.Register32 // 0x2FA4
	LUT1013L volatile.Register32 // 0x2FA8
	LUT1013H volatile.Register32 // 0x2FAC
	LUT1014L volatile.Register32 // 0x2FB0
	LUT1014H volatile.Register32 // 0x2FB4
	LUT1015L volatile.Register32 // 0x2FB8
	LUT1015H volatile.Register32 // 0x2FBC
	LUT1016L volatile.Register32 // 0x2FC0
	LUT1016H volatile.Register32 // 0x2FC4
	LUT1017L volatile.Register32 // 0x2FC8
	LUT1017H volatile.Register32 // 0x2FCC
	LUT1018L volatile.Register32 // 0x2FD0
	LUT1018H volatile.Register32 // 0x2FD4
	LUT1019L volatile.Register32 // 0x2FD8
	LUT1019H volatile.Register32 // 0x2FDC
	LUT1020L volatile.Register32 // 0x2FE0
	LUT1020H volatile.Register32 // 0x2FE4
	LUT1021L volatile.Register32 // 0x2FE8
	LUT1021H volatile.Register32 // 0x2FEC
	LUT1022L volatile.Register32 // 0x2FF0
	LUT1022H volatile.Register32 // 0x2FF4
	LUT1023L volatile.Register32 // 0x2FF8
	LUT1023H volatile.Register32 // 0x2FFC
}

// GFXMMU.CR: Graphic MMU configuration register
func (o *GFXMMU_Type) SetCR_B0OIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetCR_B0OIE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *GFXMMU_Type) SetCR_B1OIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *GFXMMU_Type) GetCR_B1OIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *GFXMMU_Type) SetCR_B2OIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *GFXMMU_Type) GetCR_B2OIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *GFXMMU_Type) SetCR_B3OIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *GFXMMU_Type) GetCR_B3OIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *GFXMMU_Type) SetCR_AMEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *GFXMMU_Type) GetCR_AMEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *GFXMMU_Type) SetCR_BM192(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *GFXMMU_Type) GetCR_BM192() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}

// GFXMMU.SR: Graphic MMU status register
func (o *GFXMMU_Type) SetSR_B0OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetSR_B0OF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *GFXMMU_Type) SetSR_B1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *GFXMMU_Type) GetSR_B1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *GFXMMU_Type) SetSR_B2OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *GFXMMU_Type) GetSR_B2OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *GFXMMU_Type) SetSR_B3OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *GFXMMU_Type) GetSR_B3OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *GFXMMU_Type) SetSR_AMEF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *GFXMMU_Type) GetSR_AMEF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}

// GFXMMU.FCR: Graphic MMU flag clear register
func (o *GFXMMU_Type) SetFCR_CB0OF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetFCR_CB0OF() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0x1
}
func (o *GFXMMU_Type) SetFCR_CB1OF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *GFXMMU_Type) GetFCR_CB1OF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x2) >> 1
}
func (o *GFXMMU_Type) SetFCR_CB2OF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *GFXMMU_Type) GetFCR_CB2OF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x4) >> 2
}
func (o *GFXMMU_Type) SetFCR_CB3OF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *GFXMMU_Type) GetFCR_CB3OF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x8) >> 3
}
func (o *GFXMMU_Type) SetFCR_CAMEF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x10)|value<<4)
}
func (o *GFXMMU_Type) GetFCR_CAMEF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x10) >> 4
}

// GFXMMU.DVR: Graphic MMU default value register
func (o *GFXMMU_Type) SetDVR(value uint32) {
	volatile.StoreUint32(&o.DVR.Reg, value)
}
func (o *GFXMMU_Type) GetDVR() uint32 {
	return volatile.LoadUint32(&o.DVR.Reg)
}

// GFXMMU.B0CR: Graphic MMU buffer 0 configuration register
func (o *GFXMMU_Type) SetB0CR_PBO(value uint32) {
	volatile.StoreUint32(&o.B0CR.Reg, volatile.LoadUint32(&o.B0CR.Reg)&^(0x7ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetB0CR_PBO() uint32 {
	return (volatile.LoadUint32(&o.B0CR.Reg) & 0x7ffff0) >> 4
}
func (o *GFXMMU_Type) SetB0CR_PBBA(value uint32) {
	volatile.StoreUint32(&o.B0CR.Reg, volatile.LoadUint32(&o.B0CR.Reg)&^(0xff800000)|value<<23)
}
func (o *GFXMMU_Type) GetB0CR_PBBA() uint32 {
	return (volatile.LoadUint32(&o.B0CR.Reg) & 0xff800000) >> 23
}

// GFXMMU.B1CR: Graphic MMU buffer 1 configuration register
func (o *GFXMMU_Type) SetB1CR_PBO(value uint32) {
	volatile.StoreUint32(&o.B1CR.Reg, volatile.LoadUint32(&o.B1CR.Reg)&^(0x7ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetB1CR_PBO() uint32 {
	return (volatile.LoadUint32(&o.B1CR.Reg) & 0x7ffff0) >> 4
}
func (o *GFXMMU_Type) SetB1CR_PBBA(value uint32) {
	volatile.StoreUint32(&o.B1CR.Reg, volatile.LoadUint32(&o.B1CR.Reg)&^(0xff800000)|value<<23)
}
func (o *GFXMMU_Type) GetB1CR_PBBA() uint32 {
	return (volatile.LoadUint32(&o.B1CR.Reg) & 0xff800000) >> 23
}

// GFXMMU.B2CR: Graphic MMU buffer 2 configuration register
func (o *GFXMMU_Type) SetB2CR_PBO(value uint32) {
	volatile.StoreUint32(&o.B2CR.Reg, volatile.LoadUint32(&o.B2CR.Reg)&^(0x7ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetB2CR_PBO() uint32 {
	return (volatile.LoadUint32(&o.B2CR.Reg) & 0x7ffff0) >> 4
}
func (o *GFXMMU_Type) SetB2CR_PBBA(value uint32) {
	volatile.StoreUint32(&o.B2CR.Reg, volatile.LoadUint32(&o.B2CR.Reg)&^(0xff800000)|value<<23)
}
func (o *GFXMMU_Type) GetB2CR_PBBA() uint32 {
	return (volatile.LoadUint32(&o.B2CR.Reg) & 0xff800000) >> 23
}

// GFXMMU.B3CR: Graphic MMU buffer 3 configuration register
func (o *GFXMMU_Type) SetB3CR_PBO(value uint32) {
	volatile.StoreUint32(&o.B3CR.Reg, volatile.LoadUint32(&o.B3CR.Reg)&^(0x7ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetB3CR_PBO() uint32 {
	return (volatile.LoadUint32(&o.B3CR.Reg) & 0x7ffff0) >> 4
}
func (o *GFXMMU_Type) SetB3CR_PBBA(value uint32) {
	volatile.StoreUint32(&o.B3CR.Reg, volatile.LoadUint32(&o.B3CR.Reg)&^(0xff800000)|value<<23)
}
func (o *GFXMMU_Type) GetB3CR_PBBA() uint32 {
	return (volatile.LoadUint32(&o.B3CR.Reg) & 0xff800000) >> 23
}

// GFXMMU.VERR: Graphic MMU version register
func (o *GFXMMU_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *GFXMMU_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *GFXMMU_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *GFXMMU_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// GFXMMU.IPIDR: Graphic MMU identification register
func (o *GFXMMU_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *GFXMMU_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// GFXMMU.SIDR: Graphic MMU size identification register
func (o *GFXMMU_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *GFXMMU_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// GFXMMU.LUT0L: Graphic MMU LUT entry 0 low
func (o *GFXMMU_Type) SetLUT0L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT0L.Reg, volatile.LoadUint32(&o.LUT0L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT0L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT0L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT0L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT0L.Reg, volatile.LoadUint32(&o.LUT0L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT0L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT0L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT0L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT0L.Reg, volatile.LoadUint32(&o.LUT0L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT0L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT0L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT0H: Graphic MMU LUT entry 0 high
func (o *GFXMMU_Type) SetLUT0H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT0H.Reg, volatile.LoadUint32(&o.LUT0H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT0H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT0H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1L: Graphic MMU LUT entry 1 low
func (o *GFXMMU_Type) SetLUT1L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1L.Reg, volatile.LoadUint32(&o.LUT1L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1L.Reg, volatile.LoadUint32(&o.LUT1L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1L.Reg, volatile.LoadUint32(&o.LUT1L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1H: Graphic MMU LUT entry 1 high
func (o *GFXMMU_Type) SetLUT1H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1H.Reg, volatile.LoadUint32(&o.LUT1H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT2L: Graphic MMU LUT entry 2 low
func (o *GFXMMU_Type) SetLUT2L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT2L.Reg, volatile.LoadUint32(&o.LUT2L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT2L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT2L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT2L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT2L.Reg, volatile.LoadUint32(&o.LUT2L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT2L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT2L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT2L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT2L.Reg, volatile.LoadUint32(&o.LUT2L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT2L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT2L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT2H: Graphic MMU LUT entry 2 high
func (o *GFXMMU_Type) SetLUT2H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT2H.Reg, volatile.LoadUint32(&o.LUT2H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT2H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT2H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT3L: Graphic MMU LUT entry 3 low
func (o *GFXMMU_Type) SetLUT3L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT3L.Reg, volatile.LoadUint32(&o.LUT3L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT3L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT3L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT3L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT3L.Reg, volatile.LoadUint32(&o.LUT3L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT3L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT3L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT3L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT3L.Reg, volatile.LoadUint32(&o.LUT3L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT3L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT3L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT3H: Graphic MMU LUT entry 3 high
func (o *GFXMMU_Type) SetLUT3H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT3H.Reg, volatile.LoadUint32(&o.LUT3H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT3H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT3H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT4L: Graphic MMU LUT entry 4 low
func (o *GFXMMU_Type) SetLUT4L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT4L.Reg, volatile.LoadUint32(&o.LUT4L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT4L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT4L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT4L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT4L.Reg, volatile.LoadUint32(&o.LUT4L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT4L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT4L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT4L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT4L.Reg, volatile.LoadUint32(&o.LUT4L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT4L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT4L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT4H: Graphic MMU LUT entry 4 high
func (o *GFXMMU_Type) SetLUT4H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT4H.Reg, volatile.LoadUint32(&o.LUT4H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT4H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT4H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT5L: Graphic MMU LUT entry 5 low
func (o *GFXMMU_Type) SetLUT5L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT5L.Reg, volatile.LoadUint32(&o.LUT5L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT5L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT5L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT5L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT5L.Reg, volatile.LoadUint32(&o.LUT5L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT5L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT5L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT5L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT5L.Reg, volatile.LoadUint32(&o.LUT5L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT5L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT5L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT5H: Graphic MMU LUT entry 5 high
func (o *GFXMMU_Type) SetLUT5H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT5H.Reg, volatile.LoadUint32(&o.LUT5H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT5H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT5H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT6L: Graphic MMU LUT entry 6 low
func (o *GFXMMU_Type) SetLUT6L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT6L.Reg, volatile.LoadUint32(&o.LUT6L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT6L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT6L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT6L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT6L.Reg, volatile.LoadUint32(&o.LUT6L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT6L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT6L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT6L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT6L.Reg, volatile.LoadUint32(&o.LUT6L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT6L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT6L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT6H: Graphic MMU LUT entry 6 high
func (o *GFXMMU_Type) SetLUT6H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT6H.Reg, volatile.LoadUint32(&o.LUT6H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT6H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT6H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT7L: Graphic MMU LUT entry 7 low
func (o *GFXMMU_Type) SetLUT7L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT7L.Reg, volatile.LoadUint32(&o.LUT7L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT7L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT7L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT7L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT7L.Reg, volatile.LoadUint32(&o.LUT7L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT7L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT7L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT7L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT7L.Reg, volatile.LoadUint32(&o.LUT7L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT7L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT7L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT7H: Graphic MMU LUT entry 7 high
func (o *GFXMMU_Type) SetLUT7H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT7H.Reg, volatile.LoadUint32(&o.LUT7H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT7H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT7H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT8L: Graphic MMU LUT entry 8 low
func (o *GFXMMU_Type) SetLUT8L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT8L.Reg, volatile.LoadUint32(&o.LUT8L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT8L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT8L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT8L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT8L.Reg, volatile.LoadUint32(&o.LUT8L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT8L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT8L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT8L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT8L.Reg, volatile.LoadUint32(&o.LUT8L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT8L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT8L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT8H: Graphic MMU LUT entry 8 high
func (o *GFXMMU_Type) SetLUT8H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT8H.Reg, volatile.LoadUint32(&o.LUT8H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT8H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT8H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT9L: Graphic MMU LUT entry 9 low
func (o *GFXMMU_Type) SetLUT9L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT9L.Reg, volatile.LoadUint32(&o.LUT9L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT9L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT9L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT9L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT9L.Reg, volatile.LoadUint32(&o.LUT9L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT9L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT9L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT9L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT9L.Reg, volatile.LoadUint32(&o.LUT9L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT9L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT9L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT9H: Graphic MMU LUT entry 9 high
func (o *GFXMMU_Type) SetLUT9H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT9H.Reg, volatile.LoadUint32(&o.LUT9H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT9H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT9H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT10L: Graphic MMU LUT entry 10 low
func (o *GFXMMU_Type) SetLUT10L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT10L.Reg, volatile.LoadUint32(&o.LUT10L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT10L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT10L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT10L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT10L.Reg, volatile.LoadUint32(&o.LUT10L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT10L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT10L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT10L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT10L.Reg, volatile.LoadUint32(&o.LUT10L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT10L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT10L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT10H: Graphic MMU LUT entry 10 high
func (o *GFXMMU_Type) SetLUT10H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT10H.Reg, volatile.LoadUint32(&o.LUT10H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT10H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT10H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT11L: Graphic MMU LUT entry 11 low
func (o *GFXMMU_Type) SetLUT11L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT11L.Reg, volatile.LoadUint32(&o.LUT11L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT11L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT11L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT11L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT11L.Reg, volatile.LoadUint32(&o.LUT11L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT11L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT11L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT11L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT11L.Reg, volatile.LoadUint32(&o.LUT11L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT11L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT11L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT11H: Graphic MMU LUT entry 11 high
func (o *GFXMMU_Type) SetLUT11H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT11H.Reg, volatile.LoadUint32(&o.LUT11H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT11H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT11H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT12L: Graphic MMU LUT entry 12 low
func (o *GFXMMU_Type) SetLUT12L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT12L.Reg, volatile.LoadUint32(&o.LUT12L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT12L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT12L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT12L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT12L.Reg, volatile.LoadUint32(&o.LUT12L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT12L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT12L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT12L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT12L.Reg, volatile.LoadUint32(&o.LUT12L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT12L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT12L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT12H: Graphic MMU LUT entry 12 high
func (o *GFXMMU_Type) SetLUT12H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT12H.Reg, volatile.LoadUint32(&o.LUT12H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT12H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT12H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT13L: Graphic MMU LUT entry 13 low
func (o *GFXMMU_Type) SetLUT13L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT13L.Reg, volatile.LoadUint32(&o.LUT13L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT13L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT13L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT13L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT13L.Reg, volatile.LoadUint32(&o.LUT13L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT13L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT13L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT13L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT13L.Reg, volatile.LoadUint32(&o.LUT13L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT13L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT13L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT13H: Graphic MMU LUT entry 13 high
func (o *GFXMMU_Type) SetLUT13H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT13H.Reg, volatile.LoadUint32(&o.LUT13H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT13H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT13H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT14L: Graphic MMU LUT entry 14 low
func (o *GFXMMU_Type) SetLUT14L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT14L.Reg, volatile.LoadUint32(&o.LUT14L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT14L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT14L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT14L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT14L.Reg, volatile.LoadUint32(&o.LUT14L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT14L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT14L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT14L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT14L.Reg, volatile.LoadUint32(&o.LUT14L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT14L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT14L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT14H: Graphic MMU LUT entry 14 high
func (o *GFXMMU_Type) SetLUT14H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT14H.Reg, volatile.LoadUint32(&o.LUT14H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT14H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT14H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT15L: Graphic MMU LUT entry 15 low
func (o *GFXMMU_Type) SetLUT15L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT15L.Reg, volatile.LoadUint32(&o.LUT15L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT15L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT15L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT15L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT15L.Reg, volatile.LoadUint32(&o.LUT15L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT15L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT15L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT15L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT15L.Reg, volatile.LoadUint32(&o.LUT15L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT15L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT15L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT15H: Graphic MMU LUT entry 15 high
func (o *GFXMMU_Type) SetLUT15H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT15H.Reg, volatile.LoadUint32(&o.LUT15H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT15H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT15H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT16L: Graphic MMU LUT entry 16 low
func (o *GFXMMU_Type) SetLUT16L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT16L.Reg, volatile.LoadUint32(&o.LUT16L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT16L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT16L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT16L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT16L.Reg, volatile.LoadUint32(&o.LUT16L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT16L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT16L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT16L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT16L.Reg, volatile.LoadUint32(&o.LUT16L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT16L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT16L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT16H: Graphic MMU LUT entry 16 high
func (o *GFXMMU_Type) SetLUT16H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT16H.Reg, volatile.LoadUint32(&o.LUT16H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT16H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT16H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT17L: Graphic MMU LUT entry 17 low
func (o *GFXMMU_Type) SetLUT17L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT17L.Reg, volatile.LoadUint32(&o.LUT17L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT17L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT17L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT17L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT17L.Reg, volatile.LoadUint32(&o.LUT17L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT17L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT17L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT17L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT17L.Reg, volatile.LoadUint32(&o.LUT17L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT17L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT17L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT17H: Graphic MMU LUT entry 17 high
func (o *GFXMMU_Type) SetLUT17H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT17H.Reg, volatile.LoadUint32(&o.LUT17H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT17H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT17H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT18L: Graphic MMU LUT entry 18 low
func (o *GFXMMU_Type) SetLUT18L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT18L.Reg, volatile.LoadUint32(&o.LUT18L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT18L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT18L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT18L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT18L.Reg, volatile.LoadUint32(&o.LUT18L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT18L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT18L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT18L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT18L.Reg, volatile.LoadUint32(&o.LUT18L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT18L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT18L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT18H: Graphic MMU LUT entry 18 high
func (o *GFXMMU_Type) SetLUT18H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT18H.Reg, volatile.LoadUint32(&o.LUT18H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT18H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT18H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT19L: Graphic MMU LUT entry 19 low
func (o *GFXMMU_Type) SetLUT19L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT19L.Reg, volatile.LoadUint32(&o.LUT19L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT19L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT19L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT19L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT19L.Reg, volatile.LoadUint32(&o.LUT19L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT19L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT19L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT19L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT19L.Reg, volatile.LoadUint32(&o.LUT19L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT19L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT19L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT19H: Graphic MMU LUT entry 19 high
func (o *GFXMMU_Type) SetLUT19H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT19H.Reg, volatile.LoadUint32(&o.LUT19H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT19H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT19H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT20L: Graphic MMU LUT entry 20 low
func (o *GFXMMU_Type) SetLUT20L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT20L.Reg, volatile.LoadUint32(&o.LUT20L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT20L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT20L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT20L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT20L.Reg, volatile.LoadUint32(&o.LUT20L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT20L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT20L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT20L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT20L.Reg, volatile.LoadUint32(&o.LUT20L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT20L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT20L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT20H: Graphic MMU LUT entry 20 high
func (o *GFXMMU_Type) SetLUT20H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT20H.Reg, volatile.LoadUint32(&o.LUT20H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT20H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT20H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT21L: Graphic MMU LUT entry 21 low
func (o *GFXMMU_Type) SetLUT21L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT21L.Reg, volatile.LoadUint32(&o.LUT21L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT21L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT21L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT21L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT21L.Reg, volatile.LoadUint32(&o.LUT21L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT21L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT21L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT21L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT21L.Reg, volatile.LoadUint32(&o.LUT21L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT21L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT21L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT21H: Graphic MMU LUT entry 21 high
func (o *GFXMMU_Type) SetLUT21H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT21H.Reg, volatile.LoadUint32(&o.LUT21H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT21H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT21H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT22L: Graphic MMU LUT entry 22 low
func (o *GFXMMU_Type) SetLUT22L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT22L.Reg, volatile.LoadUint32(&o.LUT22L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT22L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT22L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT22L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT22L.Reg, volatile.LoadUint32(&o.LUT22L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT22L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT22L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT22L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT22L.Reg, volatile.LoadUint32(&o.LUT22L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT22L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT22L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT22H: Graphic MMU LUT entry 22 high
func (o *GFXMMU_Type) SetLUT22H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT22H.Reg, volatile.LoadUint32(&o.LUT22H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT22H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT22H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT23L: Graphic MMU LUT entry 23 low
func (o *GFXMMU_Type) SetLUT23L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT23L.Reg, volatile.LoadUint32(&o.LUT23L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT23L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT23L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT23L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT23L.Reg, volatile.LoadUint32(&o.LUT23L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT23L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT23L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT23L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT23L.Reg, volatile.LoadUint32(&o.LUT23L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT23L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT23L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT23H: Graphic MMU LUT entry 23 high
func (o *GFXMMU_Type) SetLUT23H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT23H.Reg, volatile.LoadUint32(&o.LUT23H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT23H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT23H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT24L: Graphic MMU LUT entry 24 low
func (o *GFXMMU_Type) SetLUT24L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT24L.Reg, volatile.LoadUint32(&o.LUT24L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT24L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT24L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT24L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT24L.Reg, volatile.LoadUint32(&o.LUT24L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT24L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT24L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT24L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT24L.Reg, volatile.LoadUint32(&o.LUT24L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT24L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT24L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT24H: Graphic MMU LUT entry 24 high
func (o *GFXMMU_Type) SetLUT24H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT24H.Reg, volatile.LoadUint32(&o.LUT24H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT24H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT24H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT25L: Graphic MMU LUT entry 25 low
func (o *GFXMMU_Type) SetLUT25L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT25L.Reg, volatile.LoadUint32(&o.LUT25L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT25L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT25L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT25L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT25L.Reg, volatile.LoadUint32(&o.LUT25L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT25L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT25L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT25L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT25L.Reg, volatile.LoadUint32(&o.LUT25L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT25L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT25L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT25H: Graphic MMU LUT entry 25 high
func (o *GFXMMU_Type) SetLUT25H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT25H.Reg, volatile.LoadUint32(&o.LUT25H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT25H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT25H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT26L: Graphic MMU LUT entry 26 low
func (o *GFXMMU_Type) SetLUT26L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT26L.Reg, volatile.LoadUint32(&o.LUT26L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT26L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT26L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT26L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT26L.Reg, volatile.LoadUint32(&o.LUT26L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT26L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT26L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT26L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT26L.Reg, volatile.LoadUint32(&o.LUT26L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT26L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT26L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT26H: Graphic MMU LUT entry 26 high
func (o *GFXMMU_Type) SetLUT26H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT26H.Reg, volatile.LoadUint32(&o.LUT26H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT26H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT26H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT27L: Graphic MMU LUT entry 27 low
func (o *GFXMMU_Type) SetLUT27L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT27L.Reg, volatile.LoadUint32(&o.LUT27L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT27L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT27L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT27L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT27L.Reg, volatile.LoadUint32(&o.LUT27L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT27L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT27L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT27L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT27L.Reg, volatile.LoadUint32(&o.LUT27L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT27L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT27L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT27H: Graphic MMU LUT entry 27 high
func (o *GFXMMU_Type) SetLUT27H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT27H.Reg, volatile.LoadUint32(&o.LUT27H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT27H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT27H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT28L: Graphic MMU LUT entry 28 low
func (o *GFXMMU_Type) SetLUT28L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT28L.Reg, volatile.LoadUint32(&o.LUT28L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT28L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT28L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT28L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT28L.Reg, volatile.LoadUint32(&o.LUT28L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT28L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT28L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT28L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT28L.Reg, volatile.LoadUint32(&o.LUT28L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT28L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT28L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT28H: Graphic MMU LUT entry 28 high
func (o *GFXMMU_Type) SetLUT28H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT28H.Reg, volatile.LoadUint32(&o.LUT28H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT28H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT28H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT29L: Graphic MMU LUT entry 29 low
func (o *GFXMMU_Type) SetLUT29L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT29L.Reg, volatile.LoadUint32(&o.LUT29L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT29L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT29L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT29L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT29L.Reg, volatile.LoadUint32(&o.LUT29L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT29L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT29L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT29L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT29L.Reg, volatile.LoadUint32(&o.LUT29L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT29L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT29L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT29H: Graphic MMU LUT entry 29 high
func (o *GFXMMU_Type) SetLUT29H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT29H.Reg, volatile.LoadUint32(&o.LUT29H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT29H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT29H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT30L: Graphic MMU LUT entry 30 low
func (o *GFXMMU_Type) SetLUT30L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT30L.Reg, volatile.LoadUint32(&o.LUT30L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT30L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT30L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT30L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT30L.Reg, volatile.LoadUint32(&o.LUT30L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT30L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT30L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT30L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT30L.Reg, volatile.LoadUint32(&o.LUT30L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT30L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT30L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT30H: Graphic MMU LUT entry 30 high
func (o *GFXMMU_Type) SetLUT30H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT30H.Reg, volatile.LoadUint32(&o.LUT30H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT30H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT30H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT31L: Graphic MMU LUT entry 31 low
func (o *GFXMMU_Type) SetLUT31L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT31L.Reg, volatile.LoadUint32(&o.LUT31L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT31L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT31L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT31L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT31L.Reg, volatile.LoadUint32(&o.LUT31L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT31L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT31L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT31L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT31L.Reg, volatile.LoadUint32(&o.LUT31L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT31L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT31L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT31H: Graphic MMU LUT entry 31 high
func (o *GFXMMU_Type) SetLUT31H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT31H.Reg, volatile.LoadUint32(&o.LUT31H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT31H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT31H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT32L: Graphic MMU LUT entry 32 low
func (o *GFXMMU_Type) SetLUT32L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT32L.Reg, volatile.LoadUint32(&o.LUT32L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT32L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT32L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT32L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT32L.Reg, volatile.LoadUint32(&o.LUT32L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT32L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT32L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT32L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT32L.Reg, volatile.LoadUint32(&o.LUT32L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT32L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT32L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT32H: Graphic MMU LUT entry 32 high
func (o *GFXMMU_Type) SetLUT32H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT32H.Reg, volatile.LoadUint32(&o.LUT32H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT32H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT32H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT33L: Graphic MMU LUT entry 33 low
func (o *GFXMMU_Type) SetLUT33L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT33L.Reg, volatile.LoadUint32(&o.LUT33L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT33L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT33L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT33L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT33L.Reg, volatile.LoadUint32(&o.LUT33L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT33L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT33L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT33L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT33L.Reg, volatile.LoadUint32(&o.LUT33L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT33L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT33L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT33H: Graphic MMU LUT entry 33 high
func (o *GFXMMU_Type) SetLUT33H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT33H.Reg, volatile.LoadUint32(&o.LUT33H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT33H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT33H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT34L: Graphic MMU LUT entry 34 low
func (o *GFXMMU_Type) SetLUT34L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT34L.Reg, volatile.LoadUint32(&o.LUT34L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT34L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT34L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT34L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT34L.Reg, volatile.LoadUint32(&o.LUT34L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT34L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT34L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT34L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT34L.Reg, volatile.LoadUint32(&o.LUT34L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT34L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT34L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT34H: Graphic MMU LUT entry 34 high
func (o *GFXMMU_Type) SetLUT34H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT34H.Reg, volatile.LoadUint32(&o.LUT34H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT34H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT34H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT35L: Graphic MMU LUT entry 35 low
func (o *GFXMMU_Type) SetLUT35L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT35L.Reg, volatile.LoadUint32(&o.LUT35L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT35L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT35L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT35L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT35L.Reg, volatile.LoadUint32(&o.LUT35L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT35L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT35L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT35L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT35L.Reg, volatile.LoadUint32(&o.LUT35L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT35L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT35L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT35H: Graphic MMU LUT entry 35 high
func (o *GFXMMU_Type) SetLUT35H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT35H.Reg, volatile.LoadUint32(&o.LUT35H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT35H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT35H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT36L: Graphic MMU LUT entry 36 low
func (o *GFXMMU_Type) SetLUT36L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT36L.Reg, volatile.LoadUint32(&o.LUT36L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT36L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT36L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT36L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT36L.Reg, volatile.LoadUint32(&o.LUT36L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT36L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT36L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT36L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT36L.Reg, volatile.LoadUint32(&o.LUT36L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT36L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT36L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT36H: Graphic MMU LUT entry 36 high
func (o *GFXMMU_Type) SetLUT36H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT36H.Reg, volatile.LoadUint32(&o.LUT36H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT36H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT36H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT37L: Graphic MMU LUT entry 37 low
func (o *GFXMMU_Type) SetLUT37L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT37L.Reg, volatile.LoadUint32(&o.LUT37L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT37L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT37L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT37L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT37L.Reg, volatile.LoadUint32(&o.LUT37L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT37L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT37L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT37L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT37L.Reg, volatile.LoadUint32(&o.LUT37L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT37L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT37L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT37H: Graphic MMU LUT entry 37 high
func (o *GFXMMU_Type) SetLUT37H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT37H.Reg, volatile.LoadUint32(&o.LUT37H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT37H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT37H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT38L: Graphic MMU LUT entry 38 low
func (o *GFXMMU_Type) SetLUT38L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT38L.Reg, volatile.LoadUint32(&o.LUT38L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT38L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT38L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT38L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT38L.Reg, volatile.LoadUint32(&o.LUT38L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT38L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT38L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT38L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT38L.Reg, volatile.LoadUint32(&o.LUT38L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT38L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT38L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT38H: Graphic MMU LUT entry 38 high
func (o *GFXMMU_Type) SetLUT38H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT38H.Reg, volatile.LoadUint32(&o.LUT38H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT38H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT38H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT39L: Graphic MMU LUT entry 39 low
func (o *GFXMMU_Type) SetLUT39L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT39L.Reg, volatile.LoadUint32(&o.LUT39L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT39L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT39L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT39L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT39L.Reg, volatile.LoadUint32(&o.LUT39L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT39L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT39L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT39L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT39L.Reg, volatile.LoadUint32(&o.LUT39L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT39L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT39L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT39H: Graphic MMU LUT entry 39 high
func (o *GFXMMU_Type) SetLUT39H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT39H.Reg, volatile.LoadUint32(&o.LUT39H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT39H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT39H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT40L: Graphic MMU LUT entry 40 low
func (o *GFXMMU_Type) SetLUT40L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT40L.Reg, volatile.LoadUint32(&o.LUT40L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT40L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT40L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT40L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT40L.Reg, volatile.LoadUint32(&o.LUT40L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT40L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT40L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT40L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT40L.Reg, volatile.LoadUint32(&o.LUT40L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT40L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT40L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT40H: Graphic MMU LUT entry 40 high
func (o *GFXMMU_Type) SetLUT40H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT40H.Reg, volatile.LoadUint32(&o.LUT40H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT40H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT40H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT41L: Graphic MMU LUT entry 41 low
func (o *GFXMMU_Type) SetLUT41L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT41L.Reg, volatile.LoadUint32(&o.LUT41L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT41L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT41L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT41L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT41L.Reg, volatile.LoadUint32(&o.LUT41L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT41L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT41L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT41L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT41L.Reg, volatile.LoadUint32(&o.LUT41L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT41L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT41L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT41H: Graphic MMU LUT entry 41 high
func (o *GFXMMU_Type) SetLUT41H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT41H.Reg, volatile.LoadUint32(&o.LUT41H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT41H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT41H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT42L: Graphic MMU LUT entry 42 low
func (o *GFXMMU_Type) SetLUT42L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT42L.Reg, volatile.LoadUint32(&o.LUT42L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT42L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT42L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT42L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT42L.Reg, volatile.LoadUint32(&o.LUT42L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT42L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT42L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT42L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT42L.Reg, volatile.LoadUint32(&o.LUT42L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT42L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT42L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT42H: Graphic MMU LUT entry 42 high
func (o *GFXMMU_Type) SetLUT42H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT42H.Reg, volatile.LoadUint32(&o.LUT42H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT42H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT42H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT43L: Graphic MMU LUT entry 43 low
func (o *GFXMMU_Type) SetLUT43L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT43L.Reg, volatile.LoadUint32(&o.LUT43L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT43L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT43L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT43L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT43L.Reg, volatile.LoadUint32(&o.LUT43L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT43L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT43L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT43L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT43L.Reg, volatile.LoadUint32(&o.LUT43L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT43L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT43L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT43H: Graphic MMU LUT entry 43 high
func (o *GFXMMU_Type) SetLUT43H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT43H.Reg, volatile.LoadUint32(&o.LUT43H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT43H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT43H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT44L: Graphic MMU LUT entry 44 low
func (o *GFXMMU_Type) SetLUT44L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT44L.Reg, volatile.LoadUint32(&o.LUT44L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT44L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT44L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT44L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT44L.Reg, volatile.LoadUint32(&o.LUT44L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT44L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT44L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT44L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT44L.Reg, volatile.LoadUint32(&o.LUT44L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT44L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT44L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT44H: Graphic MMU LUT entry 44 high
func (o *GFXMMU_Type) SetLUT44H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT44H.Reg, volatile.LoadUint32(&o.LUT44H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT44H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT44H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT45L: Graphic MMU LUT entry 45 low
func (o *GFXMMU_Type) SetLUT45L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT45L.Reg, volatile.LoadUint32(&o.LUT45L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT45L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT45L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT45L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT45L.Reg, volatile.LoadUint32(&o.LUT45L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT45L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT45L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT45L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT45L.Reg, volatile.LoadUint32(&o.LUT45L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT45L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT45L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT45H: Graphic MMU LUT entry 45 high
func (o *GFXMMU_Type) SetLUT45H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT45H.Reg, volatile.LoadUint32(&o.LUT45H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT45H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT45H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT46L: Graphic MMU LUT entry 46 low
func (o *GFXMMU_Type) SetLUT46L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT46L.Reg, volatile.LoadUint32(&o.LUT46L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT46L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT46L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT46L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT46L.Reg, volatile.LoadUint32(&o.LUT46L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT46L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT46L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT46L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT46L.Reg, volatile.LoadUint32(&o.LUT46L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT46L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT46L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT46H: Graphic MMU LUT entry 46 high
func (o *GFXMMU_Type) SetLUT46H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT46H.Reg, volatile.LoadUint32(&o.LUT46H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT46H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT46H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT47L: Graphic MMU LUT entry 47 low
func (o *GFXMMU_Type) SetLUT47L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT47L.Reg, volatile.LoadUint32(&o.LUT47L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT47L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT47L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT47L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT47L.Reg, volatile.LoadUint32(&o.LUT47L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT47L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT47L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT47L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT47L.Reg, volatile.LoadUint32(&o.LUT47L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT47L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT47L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT47H: Graphic MMU LUT entry 47 high
func (o *GFXMMU_Type) SetLUT47H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT47H.Reg, volatile.LoadUint32(&o.LUT47H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT47H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT47H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT48L: Graphic MMU LUT entry 48 low
func (o *GFXMMU_Type) SetLUT48L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT48L.Reg, volatile.LoadUint32(&o.LUT48L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT48L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT48L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT48L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT48L.Reg, volatile.LoadUint32(&o.LUT48L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT48L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT48L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT48L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT48L.Reg, volatile.LoadUint32(&o.LUT48L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT48L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT48L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT48H: Graphic MMU LUT entry 48 high
func (o *GFXMMU_Type) SetLUT48H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT48H.Reg, volatile.LoadUint32(&o.LUT48H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT48H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT48H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT49L: Graphic MMU LUT entry 49 low
func (o *GFXMMU_Type) SetLUT49L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT49L.Reg, volatile.LoadUint32(&o.LUT49L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT49L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT49L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT49L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT49L.Reg, volatile.LoadUint32(&o.LUT49L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT49L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT49L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT49L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT49L.Reg, volatile.LoadUint32(&o.LUT49L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT49L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT49L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT49H: Graphic MMU LUT entry 49 high
func (o *GFXMMU_Type) SetLUT49H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT49H.Reg, volatile.LoadUint32(&o.LUT49H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT49H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT49H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT50L: Graphic MMU LUT entry 50 low
func (o *GFXMMU_Type) SetLUT50L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT50L.Reg, volatile.LoadUint32(&o.LUT50L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT50L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT50L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT50L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT50L.Reg, volatile.LoadUint32(&o.LUT50L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT50L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT50L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT50L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT50L.Reg, volatile.LoadUint32(&o.LUT50L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT50L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT50L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT50H: Graphic MMU LUT entry 50 high
func (o *GFXMMU_Type) SetLUT50H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT50H.Reg, volatile.LoadUint32(&o.LUT50H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT50H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT50H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT51L: Graphic MMU LUT entry 51 low
func (o *GFXMMU_Type) SetLUT51L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT51L.Reg, volatile.LoadUint32(&o.LUT51L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT51L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT51L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT51L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT51L.Reg, volatile.LoadUint32(&o.LUT51L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT51L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT51L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT51L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT51L.Reg, volatile.LoadUint32(&o.LUT51L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT51L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT51L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT51H: Graphic MMU LUT entry 51 high
func (o *GFXMMU_Type) SetLUT51H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT51H.Reg, volatile.LoadUint32(&o.LUT51H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT51H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT51H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT52L: Graphic MMU LUT entry 52 low
func (o *GFXMMU_Type) SetLUT52L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT52L.Reg, volatile.LoadUint32(&o.LUT52L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT52L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT52L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT52L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT52L.Reg, volatile.LoadUint32(&o.LUT52L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT52L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT52L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT52L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT52L.Reg, volatile.LoadUint32(&o.LUT52L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT52L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT52L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT52H: Graphic MMU LUT entry 52 high
func (o *GFXMMU_Type) SetLUT52H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT52H.Reg, volatile.LoadUint32(&o.LUT52H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT52H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT52H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT53L: Graphic MMU LUT entry 53 low
func (o *GFXMMU_Type) SetLUT53L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT53L.Reg, volatile.LoadUint32(&o.LUT53L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT53L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT53L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT53L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT53L.Reg, volatile.LoadUint32(&o.LUT53L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT53L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT53L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT53L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT53L.Reg, volatile.LoadUint32(&o.LUT53L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT53L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT53L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT53H: Graphic MMU LUT entry 53 high
func (o *GFXMMU_Type) SetLUT53H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT53H.Reg, volatile.LoadUint32(&o.LUT53H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT53H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT53H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT54L: Graphic MMU LUT entry 54 low
func (o *GFXMMU_Type) SetLUT54L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT54L.Reg, volatile.LoadUint32(&o.LUT54L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT54L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT54L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT54L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT54L.Reg, volatile.LoadUint32(&o.LUT54L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT54L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT54L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT54L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT54L.Reg, volatile.LoadUint32(&o.LUT54L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT54L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT54L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT54H: Graphic MMU LUT entry 54 high
func (o *GFXMMU_Type) SetLUT54H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT54H.Reg, volatile.LoadUint32(&o.LUT54H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT54H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT54H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT55L: Graphic MMU LUT entry 55 low
func (o *GFXMMU_Type) SetLUT55L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT55L.Reg, volatile.LoadUint32(&o.LUT55L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT55L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT55L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT55L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT55L.Reg, volatile.LoadUint32(&o.LUT55L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT55L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT55L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT55L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT55L.Reg, volatile.LoadUint32(&o.LUT55L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT55L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT55L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT55H: Graphic MMU LUT entry 55 high
func (o *GFXMMU_Type) SetLUT55H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT55H.Reg, volatile.LoadUint32(&o.LUT55H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT55H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT55H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT56L: Graphic MMU LUT entry 56 low
func (o *GFXMMU_Type) SetLUT56L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT56L.Reg, volatile.LoadUint32(&o.LUT56L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT56L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT56L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT56L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT56L.Reg, volatile.LoadUint32(&o.LUT56L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT56L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT56L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT56L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT56L.Reg, volatile.LoadUint32(&o.LUT56L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT56L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT56L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT56H: Graphic MMU LUT entry 56 high
func (o *GFXMMU_Type) SetLUT56H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT56H.Reg, volatile.LoadUint32(&o.LUT56H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT56H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT56H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT57L: Graphic MMU LUT entry 57 low
func (o *GFXMMU_Type) SetLUT57L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT57L.Reg, volatile.LoadUint32(&o.LUT57L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT57L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT57L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT57L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT57L.Reg, volatile.LoadUint32(&o.LUT57L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT57L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT57L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT57L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT57L.Reg, volatile.LoadUint32(&o.LUT57L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT57L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT57L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT57H: Graphic MMU LUT entry 57 high
func (o *GFXMMU_Type) SetLUT57H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT57H.Reg, volatile.LoadUint32(&o.LUT57H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT57H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT57H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT58L: Graphic MMU LUT entry 58 low
func (o *GFXMMU_Type) SetLUT58L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT58L.Reg, volatile.LoadUint32(&o.LUT58L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT58L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT58L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT58L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT58L.Reg, volatile.LoadUint32(&o.LUT58L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT58L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT58L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT58L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT58L.Reg, volatile.LoadUint32(&o.LUT58L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT58L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT58L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT58H: Graphic MMU LUT entry 58 high
func (o *GFXMMU_Type) SetLUT58H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT58H.Reg, volatile.LoadUint32(&o.LUT58H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT58H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT58H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT59L: Graphic MMU LUT entry 59 low
func (o *GFXMMU_Type) SetLUT59L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT59L.Reg, volatile.LoadUint32(&o.LUT59L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT59L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT59L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT59L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT59L.Reg, volatile.LoadUint32(&o.LUT59L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT59L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT59L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT59L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT59L.Reg, volatile.LoadUint32(&o.LUT59L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT59L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT59L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT59H: Graphic MMU LUT entry 59 high
func (o *GFXMMU_Type) SetLUT59H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT59H.Reg, volatile.LoadUint32(&o.LUT59H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT59H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT59H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT60L: Graphic MMU LUT entry 60 low
func (o *GFXMMU_Type) SetLUT60L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT60L.Reg, volatile.LoadUint32(&o.LUT60L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT60L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT60L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT60L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT60L.Reg, volatile.LoadUint32(&o.LUT60L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT60L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT60L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT60L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT60L.Reg, volatile.LoadUint32(&o.LUT60L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT60L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT60L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT60H: Graphic MMU LUT entry 60 high
func (o *GFXMMU_Type) SetLUT60H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT60H.Reg, volatile.LoadUint32(&o.LUT60H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT60H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT60H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT61L: Graphic MMU LUT entry 61 low
func (o *GFXMMU_Type) SetLUT61L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT61L.Reg, volatile.LoadUint32(&o.LUT61L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT61L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT61L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT61L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT61L.Reg, volatile.LoadUint32(&o.LUT61L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT61L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT61L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT61L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT61L.Reg, volatile.LoadUint32(&o.LUT61L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT61L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT61L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT61H: Graphic MMU LUT entry 61 high
func (o *GFXMMU_Type) SetLUT61H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT61H.Reg, volatile.LoadUint32(&o.LUT61H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT61H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT61H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT62L: Graphic MMU LUT entry 62 low
func (o *GFXMMU_Type) SetLUT62L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT62L.Reg, volatile.LoadUint32(&o.LUT62L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT62L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT62L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT62L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT62L.Reg, volatile.LoadUint32(&o.LUT62L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT62L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT62L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT62L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT62L.Reg, volatile.LoadUint32(&o.LUT62L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT62L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT62L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT62H: Graphic MMU LUT entry 62 high
func (o *GFXMMU_Type) SetLUT62H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT62H.Reg, volatile.LoadUint32(&o.LUT62H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT62H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT62H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT63L: Graphic MMU LUT entry 63 low
func (o *GFXMMU_Type) SetLUT63L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT63L.Reg, volatile.LoadUint32(&o.LUT63L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT63L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT63L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT63L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT63L.Reg, volatile.LoadUint32(&o.LUT63L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT63L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT63L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT63L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT63L.Reg, volatile.LoadUint32(&o.LUT63L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT63L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT63L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT63H: Graphic MMU LUT entry 63 high
func (o *GFXMMU_Type) SetLUT63H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT63H.Reg, volatile.LoadUint32(&o.LUT63H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT63H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT63H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT64L: Graphic MMU LUT entry 64 low
func (o *GFXMMU_Type) SetLUT64L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT64L.Reg, volatile.LoadUint32(&o.LUT64L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT64L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT64L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT64L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT64L.Reg, volatile.LoadUint32(&o.LUT64L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT64L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT64L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT64L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT64L.Reg, volatile.LoadUint32(&o.LUT64L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT64L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT64L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT64H: Graphic MMU LUT entry 64 high
func (o *GFXMMU_Type) SetLUT64H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT64H.Reg, volatile.LoadUint32(&o.LUT64H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT64H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT64H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT65L: Graphic MMU LUT entry 65 low
func (o *GFXMMU_Type) SetLUT65L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT65L.Reg, volatile.LoadUint32(&o.LUT65L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT65L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT65L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT65L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT65L.Reg, volatile.LoadUint32(&o.LUT65L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT65L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT65L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT65L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT65L.Reg, volatile.LoadUint32(&o.LUT65L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT65L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT65L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT65H: Graphic MMU LUT entry 65 high
func (o *GFXMMU_Type) SetLUT65H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT65H.Reg, volatile.LoadUint32(&o.LUT65H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT65H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT65H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT66L: Graphic MMU LUT entry 66 low
func (o *GFXMMU_Type) SetLUT66L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT66L.Reg, volatile.LoadUint32(&o.LUT66L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT66L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT66L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT66L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT66L.Reg, volatile.LoadUint32(&o.LUT66L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT66L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT66L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT66L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT66L.Reg, volatile.LoadUint32(&o.LUT66L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT66L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT66L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT66H: Graphic MMU LUT entry 66 high
func (o *GFXMMU_Type) SetLUT66H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT66H.Reg, volatile.LoadUint32(&o.LUT66H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT66H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT66H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT67L: Graphic MMU LUT entry 67 low
func (o *GFXMMU_Type) SetLUT67L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT67L.Reg, volatile.LoadUint32(&o.LUT67L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT67L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT67L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT67L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT67L.Reg, volatile.LoadUint32(&o.LUT67L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT67L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT67L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT67L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT67L.Reg, volatile.LoadUint32(&o.LUT67L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT67L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT67L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT67H: Graphic MMU LUT entry 67 high
func (o *GFXMMU_Type) SetLUT67H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT67H.Reg, volatile.LoadUint32(&o.LUT67H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT67H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT67H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT68L: Graphic MMU LUT entry 68 low
func (o *GFXMMU_Type) SetLUT68L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT68L.Reg, volatile.LoadUint32(&o.LUT68L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT68L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT68L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT68L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT68L.Reg, volatile.LoadUint32(&o.LUT68L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT68L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT68L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT68L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT68L.Reg, volatile.LoadUint32(&o.LUT68L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT68L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT68L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT68H: Graphic MMU LUT entry 68 high
func (o *GFXMMU_Type) SetLUT68H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT68H.Reg, volatile.LoadUint32(&o.LUT68H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT68H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT68H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT69L: Graphic MMU LUT entry 69 low
func (o *GFXMMU_Type) SetLUT69L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT69L.Reg, volatile.LoadUint32(&o.LUT69L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT69L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT69L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT69L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT69L.Reg, volatile.LoadUint32(&o.LUT69L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT69L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT69L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT69L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT69L.Reg, volatile.LoadUint32(&o.LUT69L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT69L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT69L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT69H: Graphic MMU LUT entry 69 high
func (o *GFXMMU_Type) SetLUT69H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT69H.Reg, volatile.LoadUint32(&o.LUT69H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT69H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT69H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT70L: Graphic MMU LUT entry 70 low
func (o *GFXMMU_Type) SetLUT70L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT70L.Reg, volatile.LoadUint32(&o.LUT70L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT70L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT70L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT70L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT70L.Reg, volatile.LoadUint32(&o.LUT70L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT70L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT70L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT70L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT70L.Reg, volatile.LoadUint32(&o.LUT70L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT70L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT70L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT70H: Graphic MMU LUT entry 70 high
func (o *GFXMMU_Type) SetLUT70H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT70H.Reg, volatile.LoadUint32(&o.LUT70H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT70H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT70H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT71L: Graphic MMU LUT entry 71 low
func (o *GFXMMU_Type) SetLUT71L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT71L.Reg, volatile.LoadUint32(&o.LUT71L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT71L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT71L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT71L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT71L.Reg, volatile.LoadUint32(&o.LUT71L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT71L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT71L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT71L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT71L.Reg, volatile.LoadUint32(&o.LUT71L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT71L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT71L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT71H: Graphic MMU LUT entry 71 high
func (o *GFXMMU_Type) SetLUT71H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT71H.Reg, volatile.LoadUint32(&o.LUT71H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT71H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT71H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT72L: Graphic MMU LUT entry 72 low
func (o *GFXMMU_Type) SetLUT72L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT72L.Reg, volatile.LoadUint32(&o.LUT72L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT72L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT72L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT72L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT72L.Reg, volatile.LoadUint32(&o.LUT72L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT72L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT72L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT72L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT72L.Reg, volatile.LoadUint32(&o.LUT72L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT72L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT72L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT72H: Graphic MMU LUT entry 72 high
func (o *GFXMMU_Type) SetLUT72H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT72H.Reg, volatile.LoadUint32(&o.LUT72H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT72H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT72H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT73L: Graphic MMU LUT entry 73 low
func (o *GFXMMU_Type) SetLUT73L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT73L.Reg, volatile.LoadUint32(&o.LUT73L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT73L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT73L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT73L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT73L.Reg, volatile.LoadUint32(&o.LUT73L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT73L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT73L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT73L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT73L.Reg, volatile.LoadUint32(&o.LUT73L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT73L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT73L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT73H: Graphic MMU LUT entry 73 high
func (o *GFXMMU_Type) SetLUT73H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT73H.Reg, volatile.LoadUint32(&o.LUT73H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT73H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT73H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT74L: Graphic MMU LUT entry 74 low
func (o *GFXMMU_Type) SetLUT74L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT74L.Reg, volatile.LoadUint32(&o.LUT74L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT74L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT74L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT74L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT74L.Reg, volatile.LoadUint32(&o.LUT74L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT74L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT74L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT74L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT74L.Reg, volatile.LoadUint32(&o.LUT74L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT74L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT74L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT74H: Graphic MMU LUT entry 74 high
func (o *GFXMMU_Type) SetLUT74H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT74H.Reg, volatile.LoadUint32(&o.LUT74H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT74H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT74H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT75L: Graphic MMU LUT entry 75 low
func (o *GFXMMU_Type) SetLUT75L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT75L.Reg, volatile.LoadUint32(&o.LUT75L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT75L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT75L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT75L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT75L.Reg, volatile.LoadUint32(&o.LUT75L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT75L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT75L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT75L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT75L.Reg, volatile.LoadUint32(&o.LUT75L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT75L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT75L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT75H: Graphic MMU LUT entry 75 high
func (o *GFXMMU_Type) SetLUT75H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT75H.Reg, volatile.LoadUint32(&o.LUT75H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT75H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT75H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT76L: Graphic MMU LUT entry 76 low
func (o *GFXMMU_Type) SetLUT76L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT76L.Reg, volatile.LoadUint32(&o.LUT76L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT76L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT76L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT76L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT76L.Reg, volatile.LoadUint32(&o.LUT76L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT76L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT76L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT76L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT76L.Reg, volatile.LoadUint32(&o.LUT76L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT76L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT76L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT76H: Graphic MMU LUT entry 76 high
func (o *GFXMMU_Type) SetLUT76H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT76H.Reg, volatile.LoadUint32(&o.LUT76H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT76H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT76H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT77L: Graphic MMU LUT entry 77 low
func (o *GFXMMU_Type) SetLUT77L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT77L.Reg, volatile.LoadUint32(&o.LUT77L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT77L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT77L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT77L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT77L.Reg, volatile.LoadUint32(&o.LUT77L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT77L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT77L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT77L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT77L.Reg, volatile.LoadUint32(&o.LUT77L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT77L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT77L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT77H: Graphic MMU LUT entry 77 high
func (o *GFXMMU_Type) SetLUT77H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT77H.Reg, volatile.LoadUint32(&o.LUT77H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT77H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT77H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT78L: Graphic MMU LUT entry 78 low
func (o *GFXMMU_Type) SetLUT78L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT78L.Reg, volatile.LoadUint32(&o.LUT78L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT78L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT78L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT78L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT78L.Reg, volatile.LoadUint32(&o.LUT78L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT78L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT78L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT78L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT78L.Reg, volatile.LoadUint32(&o.LUT78L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT78L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT78L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT78H: Graphic MMU LUT entry 78 high
func (o *GFXMMU_Type) SetLUT78H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT78H.Reg, volatile.LoadUint32(&o.LUT78H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT78H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT78H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT79L: Graphic MMU LUT entry 79 low
func (o *GFXMMU_Type) SetLUT79L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT79L.Reg, volatile.LoadUint32(&o.LUT79L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT79L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT79L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT79L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT79L.Reg, volatile.LoadUint32(&o.LUT79L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT79L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT79L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT79L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT79L.Reg, volatile.LoadUint32(&o.LUT79L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT79L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT79L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT79H: Graphic MMU LUT entry 79 high
func (o *GFXMMU_Type) SetLUT79H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT79H.Reg, volatile.LoadUint32(&o.LUT79H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT79H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT79H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT80L: Graphic MMU LUT entry 80 low
func (o *GFXMMU_Type) SetLUT80L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT80L.Reg, volatile.LoadUint32(&o.LUT80L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT80L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT80L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT80L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT80L.Reg, volatile.LoadUint32(&o.LUT80L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT80L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT80L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT80L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT80L.Reg, volatile.LoadUint32(&o.LUT80L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT80L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT80L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT80H: Graphic MMU LUT entry 80 high
func (o *GFXMMU_Type) SetLUT80H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT80H.Reg, volatile.LoadUint32(&o.LUT80H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT80H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT80H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT81L: Graphic MMU LUT entry 81 low
func (o *GFXMMU_Type) SetLUT81L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT81L.Reg, volatile.LoadUint32(&o.LUT81L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT81L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT81L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT81L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT81L.Reg, volatile.LoadUint32(&o.LUT81L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT81L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT81L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT81L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT81L.Reg, volatile.LoadUint32(&o.LUT81L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT81L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT81L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT81H: Graphic MMU LUT entry 81 high
func (o *GFXMMU_Type) SetLUT81H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT81H.Reg, volatile.LoadUint32(&o.LUT81H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT81H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT81H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT82L: Graphic MMU LUT entry 82 low
func (o *GFXMMU_Type) SetLUT82L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT82L.Reg, volatile.LoadUint32(&o.LUT82L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT82L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT82L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT82L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT82L.Reg, volatile.LoadUint32(&o.LUT82L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT82L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT82L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT82L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT82L.Reg, volatile.LoadUint32(&o.LUT82L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT82L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT82L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT82H: Graphic MMU LUT entry 82 high
func (o *GFXMMU_Type) SetLUT82H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT82H.Reg, volatile.LoadUint32(&o.LUT82H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT82H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT82H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT83L: Graphic MMU LUT entry 83 low
func (o *GFXMMU_Type) SetLUT83L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT83L.Reg, volatile.LoadUint32(&o.LUT83L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT83L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT83L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT83L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT83L.Reg, volatile.LoadUint32(&o.LUT83L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT83L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT83L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT83L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT83L.Reg, volatile.LoadUint32(&o.LUT83L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT83L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT83L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT83H: Graphic MMU LUT entry 83 high
func (o *GFXMMU_Type) SetLUT83H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT83H.Reg, volatile.LoadUint32(&o.LUT83H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT83H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT83H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT84L: Graphic MMU LUT entry 84 low
func (o *GFXMMU_Type) SetLUT84L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT84L.Reg, volatile.LoadUint32(&o.LUT84L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT84L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT84L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT84L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT84L.Reg, volatile.LoadUint32(&o.LUT84L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT84L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT84L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT84L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT84L.Reg, volatile.LoadUint32(&o.LUT84L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT84L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT84L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT84H: Graphic MMU LUT entry 84 high
func (o *GFXMMU_Type) SetLUT84H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT84H.Reg, volatile.LoadUint32(&o.LUT84H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT84H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT84H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT85L: Graphic MMU LUT entry 85 low
func (o *GFXMMU_Type) SetLUT85L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT85L.Reg, volatile.LoadUint32(&o.LUT85L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT85L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT85L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT85L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT85L.Reg, volatile.LoadUint32(&o.LUT85L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT85L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT85L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT85L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT85L.Reg, volatile.LoadUint32(&o.LUT85L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT85L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT85L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT85H: Graphic MMU LUT entry 85 high
func (o *GFXMMU_Type) SetLUT85H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT85H.Reg, volatile.LoadUint32(&o.LUT85H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT85H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT85H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT86L: Graphic MMU LUT entry 86 low
func (o *GFXMMU_Type) SetLUT86L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT86L.Reg, volatile.LoadUint32(&o.LUT86L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT86L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT86L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT86L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT86L.Reg, volatile.LoadUint32(&o.LUT86L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT86L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT86L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT86L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT86L.Reg, volatile.LoadUint32(&o.LUT86L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT86L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT86L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT86H: Graphic MMU LUT entry 86 high
func (o *GFXMMU_Type) SetLUT86H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT86H.Reg, volatile.LoadUint32(&o.LUT86H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT86H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT86H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT87L: Graphic MMU LUT entry 87 low
func (o *GFXMMU_Type) SetLUT87L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT87L.Reg, volatile.LoadUint32(&o.LUT87L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT87L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT87L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT87L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT87L.Reg, volatile.LoadUint32(&o.LUT87L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT87L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT87L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT87L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT87L.Reg, volatile.LoadUint32(&o.LUT87L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT87L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT87L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT87H: Graphic MMU LUT entry 87 high
func (o *GFXMMU_Type) SetLUT87H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT87H.Reg, volatile.LoadUint32(&o.LUT87H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT87H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT87H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT88L: Graphic MMU LUT entry 88 low
func (o *GFXMMU_Type) SetLUT88L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT88L.Reg, volatile.LoadUint32(&o.LUT88L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT88L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT88L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT88L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT88L.Reg, volatile.LoadUint32(&o.LUT88L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT88L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT88L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT88L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT88L.Reg, volatile.LoadUint32(&o.LUT88L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT88L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT88L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT88H: Graphic MMU LUT entry 88 high
func (o *GFXMMU_Type) SetLUT88H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT88H.Reg, volatile.LoadUint32(&o.LUT88H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT88H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT88H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT89L: Graphic MMU LUT entry 89 low
func (o *GFXMMU_Type) SetLUT89L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT89L.Reg, volatile.LoadUint32(&o.LUT89L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT89L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT89L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT89L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT89L.Reg, volatile.LoadUint32(&o.LUT89L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT89L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT89L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT89L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT89L.Reg, volatile.LoadUint32(&o.LUT89L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT89L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT89L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT89H: Graphic MMU LUT entry 89 high
func (o *GFXMMU_Type) SetLUT89H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT89H.Reg, volatile.LoadUint32(&o.LUT89H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT89H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT89H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT90L: Graphic MMU LUT entry 90 low
func (o *GFXMMU_Type) SetLUT90L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT90L.Reg, volatile.LoadUint32(&o.LUT90L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT90L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT90L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT90L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT90L.Reg, volatile.LoadUint32(&o.LUT90L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT90L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT90L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT90L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT90L.Reg, volatile.LoadUint32(&o.LUT90L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT90L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT90L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT90H: Graphic MMU LUT entry 90 high
func (o *GFXMMU_Type) SetLUT90H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT90H.Reg, volatile.LoadUint32(&o.LUT90H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT90H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT90H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT91L: Graphic MMU LUT entry 91 low
func (o *GFXMMU_Type) SetLUT91L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT91L.Reg, volatile.LoadUint32(&o.LUT91L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT91L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT91L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT91L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT91L.Reg, volatile.LoadUint32(&o.LUT91L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT91L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT91L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT91L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT91L.Reg, volatile.LoadUint32(&o.LUT91L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT91L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT91L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT91H: Graphic MMU LUT entry 91 high
func (o *GFXMMU_Type) SetLUT91H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT91H.Reg, volatile.LoadUint32(&o.LUT91H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT91H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT91H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT92L: Graphic MMU LUT entry 92 low
func (o *GFXMMU_Type) SetLUT92L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT92L.Reg, volatile.LoadUint32(&o.LUT92L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT92L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT92L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT92L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT92L.Reg, volatile.LoadUint32(&o.LUT92L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT92L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT92L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT92L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT92L.Reg, volatile.LoadUint32(&o.LUT92L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT92L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT92L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT92H: Graphic MMU LUT entry 92 high
func (o *GFXMMU_Type) SetLUT92H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT92H.Reg, volatile.LoadUint32(&o.LUT92H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT92H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT92H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT93L: Graphic MMU LUT entry 93 low
func (o *GFXMMU_Type) SetLUT93L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT93L.Reg, volatile.LoadUint32(&o.LUT93L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT93L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT93L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT93L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT93L.Reg, volatile.LoadUint32(&o.LUT93L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT93L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT93L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT93L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT93L.Reg, volatile.LoadUint32(&o.LUT93L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT93L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT93L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT93H: Graphic MMU LUT entry 93 high
func (o *GFXMMU_Type) SetLUT93H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT93H.Reg, volatile.LoadUint32(&o.LUT93H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT93H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT93H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT94L: Graphic MMU LUT entry 94 low
func (o *GFXMMU_Type) SetLUT94L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT94L.Reg, volatile.LoadUint32(&o.LUT94L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT94L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT94L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT94L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT94L.Reg, volatile.LoadUint32(&o.LUT94L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT94L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT94L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT94L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT94L.Reg, volatile.LoadUint32(&o.LUT94L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT94L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT94L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT94H: Graphic MMU LUT entry 94 high
func (o *GFXMMU_Type) SetLUT94H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT94H.Reg, volatile.LoadUint32(&o.LUT94H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT94H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT94H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT95L: Graphic MMU LUT entry 95 low
func (o *GFXMMU_Type) SetLUT95L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT95L.Reg, volatile.LoadUint32(&o.LUT95L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT95L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT95L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT95L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT95L.Reg, volatile.LoadUint32(&o.LUT95L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT95L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT95L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT95L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT95L.Reg, volatile.LoadUint32(&o.LUT95L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT95L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT95L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT95H: Graphic MMU LUT entry 95 high
func (o *GFXMMU_Type) SetLUT95H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT95H.Reg, volatile.LoadUint32(&o.LUT95H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT95H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT95H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT96L: Graphic MMU LUT entry 96 low
func (o *GFXMMU_Type) SetLUT96L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT96L.Reg, volatile.LoadUint32(&o.LUT96L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT96L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT96L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT96L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT96L.Reg, volatile.LoadUint32(&o.LUT96L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT96L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT96L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT96L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT96L.Reg, volatile.LoadUint32(&o.LUT96L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT96L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT96L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT96H: Graphic MMU LUT entry 96 high
func (o *GFXMMU_Type) SetLUT96H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT96H.Reg, volatile.LoadUint32(&o.LUT96H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT96H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT96H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT97L: Graphic MMU LUT entry 97 low
func (o *GFXMMU_Type) SetLUT97L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT97L.Reg, volatile.LoadUint32(&o.LUT97L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT97L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT97L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT97L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT97L.Reg, volatile.LoadUint32(&o.LUT97L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT97L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT97L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT97L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT97L.Reg, volatile.LoadUint32(&o.LUT97L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT97L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT97L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT97H: Graphic MMU LUT entry 97 high
func (o *GFXMMU_Type) SetLUT97H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT97H.Reg, volatile.LoadUint32(&o.LUT97H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT97H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT97H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT98L: Graphic MMU LUT entry 98 low
func (o *GFXMMU_Type) SetLUT98L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT98L.Reg, volatile.LoadUint32(&o.LUT98L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT98L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT98L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT98L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT98L.Reg, volatile.LoadUint32(&o.LUT98L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT98L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT98L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT98L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT98L.Reg, volatile.LoadUint32(&o.LUT98L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT98L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT98L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT98H: Graphic MMU LUT entry 98 high
func (o *GFXMMU_Type) SetLUT98H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT98H.Reg, volatile.LoadUint32(&o.LUT98H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT98H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT98H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT99L: Graphic MMU LUT entry 99 low
func (o *GFXMMU_Type) SetLUT99L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT99L.Reg, volatile.LoadUint32(&o.LUT99L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT99L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT99L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT99L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT99L.Reg, volatile.LoadUint32(&o.LUT99L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT99L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT99L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT99L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT99L.Reg, volatile.LoadUint32(&o.LUT99L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT99L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT99L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT99H: Graphic MMU LUT entry 99 high
func (o *GFXMMU_Type) SetLUT99H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT99H.Reg, volatile.LoadUint32(&o.LUT99H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT99H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT99H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT100L: Graphic MMU LUT entry 100 low
func (o *GFXMMU_Type) SetLUT100L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT100L.Reg, volatile.LoadUint32(&o.LUT100L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT100L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT100L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT100L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT100L.Reg, volatile.LoadUint32(&o.LUT100L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT100L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT100L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT100L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT100L.Reg, volatile.LoadUint32(&o.LUT100L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT100L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT100L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT100H: Graphic MMU LUT entry 100 high
func (o *GFXMMU_Type) SetLUT100H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT100H.Reg, volatile.LoadUint32(&o.LUT100H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT100H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT100H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT101L: Graphic MMU LUT entry 101 low
func (o *GFXMMU_Type) SetLUT101L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT101L.Reg, volatile.LoadUint32(&o.LUT101L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT101L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT101L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT101L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT101L.Reg, volatile.LoadUint32(&o.LUT101L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT101L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT101L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT101L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT101L.Reg, volatile.LoadUint32(&o.LUT101L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT101L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT101L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT101H: Graphic MMU LUT entry 101 high
func (o *GFXMMU_Type) SetLUT101H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT101H.Reg, volatile.LoadUint32(&o.LUT101H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT101H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT101H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT102L: Graphic MMU LUT entry 102 low
func (o *GFXMMU_Type) SetLUT102L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT102L.Reg, volatile.LoadUint32(&o.LUT102L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT102L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT102L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT102L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT102L.Reg, volatile.LoadUint32(&o.LUT102L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT102L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT102L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT102L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT102L.Reg, volatile.LoadUint32(&o.LUT102L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT102L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT102L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT102H: Graphic MMU LUT entry 102 high
func (o *GFXMMU_Type) SetLUT102H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT102H.Reg, volatile.LoadUint32(&o.LUT102H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT102H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT102H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT103L: Graphic MMU LUT entry 103 low
func (o *GFXMMU_Type) SetLUT103L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT103L.Reg, volatile.LoadUint32(&o.LUT103L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT103L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT103L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT103L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT103L.Reg, volatile.LoadUint32(&o.LUT103L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT103L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT103L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT103L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT103L.Reg, volatile.LoadUint32(&o.LUT103L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT103L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT103L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT103H: Graphic MMU LUT entry 103 high
func (o *GFXMMU_Type) SetLUT103H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT103H.Reg, volatile.LoadUint32(&o.LUT103H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT103H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT103H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT104L: Graphic MMU LUT entry 104 low
func (o *GFXMMU_Type) SetLUT104L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT104L.Reg, volatile.LoadUint32(&o.LUT104L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT104L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT104L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT104L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT104L.Reg, volatile.LoadUint32(&o.LUT104L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT104L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT104L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT104L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT104L.Reg, volatile.LoadUint32(&o.LUT104L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT104L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT104L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT104H: Graphic MMU LUT entry 104 high
func (o *GFXMMU_Type) SetLUT104H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT104H.Reg, volatile.LoadUint32(&o.LUT104H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT104H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT104H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT105L: Graphic MMU LUT entry 105 low
func (o *GFXMMU_Type) SetLUT105L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT105L.Reg, volatile.LoadUint32(&o.LUT105L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT105L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT105L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT105L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT105L.Reg, volatile.LoadUint32(&o.LUT105L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT105L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT105L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT105L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT105L.Reg, volatile.LoadUint32(&o.LUT105L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT105L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT105L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT105H: Graphic MMU LUT entry 105 high
func (o *GFXMMU_Type) SetLUT105H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT105H.Reg, volatile.LoadUint32(&o.LUT105H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT105H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT105H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT106L: Graphic MMU LUT entry 106 low
func (o *GFXMMU_Type) SetLUT106L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT106L.Reg, volatile.LoadUint32(&o.LUT106L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT106L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT106L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT106L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT106L.Reg, volatile.LoadUint32(&o.LUT106L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT106L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT106L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT106L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT106L.Reg, volatile.LoadUint32(&o.LUT106L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT106L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT106L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT106H: Graphic MMU LUT entry 106 high
func (o *GFXMMU_Type) SetLUT106H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT106H.Reg, volatile.LoadUint32(&o.LUT106H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT106H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT106H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT107L: Graphic MMU LUT entry 107 low
func (o *GFXMMU_Type) SetLUT107L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT107L.Reg, volatile.LoadUint32(&o.LUT107L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT107L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT107L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT107L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT107L.Reg, volatile.LoadUint32(&o.LUT107L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT107L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT107L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT107L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT107L.Reg, volatile.LoadUint32(&o.LUT107L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT107L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT107L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT107H: Graphic MMU LUT entry 107 high
func (o *GFXMMU_Type) SetLUT107H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT107H.Reg, volatile.LoadUint32(&o.LUT107H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT107H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT107H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT108L: Graphic MMU LUT entry 108 low
func (o *GFXMMU_Type) SetLUT108L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT108L.Reg, volatile.LoadUint32(&o.LUT108L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT108L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT108L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT108L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT108L.Reg, volatile.LoadUint32(&o.LUT108L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT108L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT108L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT108L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT108L.Reg, volatile.LoadUint32(&o.LUT108L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT108L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT108L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT108H: Graphic MMU LUT entry 108 high
func (o *GFXMMU_Type) SetLUT108H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT108H.Reg, volatile.LoadUint32(&o.LUT108H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT108H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT108H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT109L: Graphic MMU LUT entry 109 low
func (o *GFXMMU_Type) SetLUT109L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT109L.Reg, volatile.LoadUint32(&o.LUT109L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT109L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT109L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT109L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT109L.Reg, volatile.LoadUint32(&o.LUT109L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT109L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT109L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT109L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT109L.Reg, volatile.LoadUint32(&o.LUT109L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT109L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT109L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT109H: Graphic MMU LUT entry 109 high
func (o *GFXMMU_Type) SetLUT109H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT109H.Reg, volatile.LoadUint32(&o.LUT109H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT109H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT109H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT110L: Graphic MMU LUT entry 110 low
func (o *GFXMMU_Type) SetLUT110L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT110L.Reg, volatile.LoadUint32(&o.LUT110L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT110L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT110L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT110L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT110L.Reg, volatile.LoadUint32(&o.LUT110L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT110L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT110L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT110L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT110L.Reg, volatile.LoadUint32(&o.LUT110L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT110L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT110L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT110H: Graphic MMU LUT entry 110 high
func (o *GFXMMU_Type) SetLUT110H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT110H.Reg, volatile.LoadUint32(&o.LUT110H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT110H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT110H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT111L: Graphic MMU LUT entry 111 low
func (o *GFXMMU_Type) SetLUT111L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT111L.Reg, volatile.LoadUint32(&o.LUT111L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT111L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT111L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT111L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT111L.Reg, volatile.LoadUint32(&o.LUT111L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT111L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT111L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT111L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT111L.Reg, volatile.LoadUint32(&o.LUT111L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT111L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT111L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT111H: Graphic MMU LUT entry 111 high
func (o *GFXMMU_Type) SetLUT111H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT111H.Reg, volatile.LoadUint32(&o.LUT111H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT111H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT111H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT112L: Graphic MMU LUT entry 112 low
func (o *GFXMMU_Type) SetLUT112L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT112L.Reg, volatile.LoadUint32(&o.LUT112L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT112L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT112L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT112L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT112L.Reg, volatile.LoadUint32(&o.LUT112L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT112L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT112L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT112L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT112L.Reg, volatile.LoadUint32(&o.LUT112L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT112L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT112L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT112H: Graphic MMU LUT entry 112 high
func (o *GFXMMU_Type) SetLUT112H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT112H.Reg, volatile.LoadUint32(&o.LUT112H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT112H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT112H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT113L: Graphic MMU LUT entry 113 low
func (o *GFXMMU_Type) SetLUT113L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT113L.Reg, volatile.LoadUint32(&o.LUT113L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT113L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT113L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT113L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT113L.Reg, volatile.LoadUint32(&o.LUT113L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT113L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT113L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT113L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT113L.Reg, volatile.LoadUint32(&o.LUT113L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT113L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT113L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT113H: Graphic MMU LUT entry 113 high
func (o *GFXMMU_Type) SetLUT113H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT113H.Reg, volatile.LoadUint32(&o.LUT113H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT113H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT113H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT114L: Graphic MMU LUT entry 114 low
func (o *GFXMMU_Type) SetLUT114L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT114L.Reg, volatile.LoadUint32(&o.LUT114L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT114L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT114L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT114L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT114L.Reg, volatile.LoadUint32(&o.LUT114L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT114L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT114L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT114L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT114L.Reg, volatile.LoadUint32(&o.LUT114L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT114L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT114L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT114H: Graphic MMU LUT entry 114 high
func (o *GFXMMU_Type) SetLUT114H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT114H.Reg, volatile.LoadUint32(&o.LUT114H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT114H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT114H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT115L: Graphic MMU LUT entry 115 low
func (o *GFXMMU_Type) SetLUT115L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT115L.Reg, volatile.LoadUint32(&o.LUT115L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT115L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT115L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT115L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT115L.Reg, volatile.LoadUint32(&o.LUT115L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT115L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT115L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT115L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT115L.Reg, volatile.LoadUint32(&o.LUT115L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT115L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT115L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT115H: Graphic MMU LUT entry 115 high
func (o *GFXMMU_Type) SetLUT115H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT115H.Reg, volatile.LoadUint32(&o.LUT115H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT115H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT115H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT116L: Graphic MMU LUT entry 116 low
func (o *GFXMMU_Type) SetLUT116L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT116L.Reg, volatile.LoadUint32(&o.LUT116L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT116L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT116L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT116L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT116L.Reg, volatile.LoadUint32(&o.LUT116L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT116L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT116L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT116L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT116L.Reg, volatile.LoadUint32(&o.LUT116L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT116L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT116L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT116H: Graphic MMU LUT entry 116 high
func (o *GFXMMU_Type) SetLUT116H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT116H.Reg, volatile.LoadUint32(&o.LUT116H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT116H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT116H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT117L: Graphic MMU LUT entry 117 low
func (o *GFXMMU_Type) SetLUT117L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT117L.Reg, volatile.LoadUint32(&o.LUT117L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT117L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT117L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT117L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT117L.Reg, volatile.LoadUint32(&o.LUT117L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT117L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT117L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT117L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT117L.Reg, volatile.LoadUint32(&o.LUT117L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT117L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT117L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT117H: Graphic MMU LUT entry 117 high
func (o *GFXMMU_Type) SetLUT117H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT117H.Reg, volatile.LoadUint32(&o.LUT117H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT117H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT117H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT118L: Graphic MMU LUT entry 118 low
func (o *GFXMMU_Type) SetLUT118L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT118L.Reg, volatile.LoadUint32(&o.LUT118L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT118L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT118L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT118L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT118L.Reg, volatile.LoadUint32(&o.LUT118L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT118L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT118L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT118L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT118L.Reg, volatile.LoadUint32(&o.LUT118L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT118L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT118L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT118H: Graphic MMU LUT entry 118 high
func (o *GFXMMU_Type) SetLUT118H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT118H.Reg, volatile.LoadUint32(&o.LUT118H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT118H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT118H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT119L: Graphic MMU LUT entry 119 low
func (o *GFXMMU_Type) SetLUT119L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT119L.Reg, volatile.LoadUint32(&o.LUT119L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT119L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT119L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT119L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT119L.Reg, volatile.LoadUint32(&o.LUT119L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT119L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT119L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT119L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT119L.Reg, volatile.LoadUint32(&o.LUT119L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT119L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT119L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT119H: Graphic MMU LUT entry 119 high
func (o *GFXMMU_Type) SetLUT119H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT119H.Reg, volatile.LoadUint32(&o.LUT119H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT119H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT119H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT120L: Graphic MMU LUT entry 120 low
func (o *GFXMMU_Type) SetLUT120L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT120L.Reg, volatile.LoadUint32(&o.LUT120L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT120L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT120L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT120L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT120L.Reg, volatile.LoadUint32(&o.LUT120L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT120L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT120L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT120L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT120L.Reg, volatile.LoadUint32(&o.LUT120L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT120L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT120L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT120H: Graphic MMU LUT entry 120 high
func (o *GFXMMU_Type) SetLUT120H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT120H.Reg, volatile.LoadUint32(&o.LUT120H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT120H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT120H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT121L: Graphic MMU LUT entry 121 low
func (o *GFXMMU_Type) SetLUT121L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT121L.Reg, volatile.LoadUint32(&o.LUT121L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT121L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT121L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT121L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT121L.Reg, volatile.LoadUint32(&o.LUT121L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT121L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT121L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT121L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT121L.Reg, volatile.LoadUint32(&o.LUT121L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT121L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT121L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT121H: Graphic MMU LUT entry 121 high
func (o *GFXMMU_Type) SetLUT121H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT121H.Reg, volatile.LoadUint32(&o.LUT121H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT121H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT121H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT122L: Graphic MMU LUT entry 122 low
func (o *GFXMMU_Type) SetLUT122L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT122L.Reg, volatile.LoadUint32(&o.LUT122L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT122L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT122L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT122L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT122L.Reg, volatile.LoadUint32(&o.LUT122L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT122L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT122L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT122L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT122L.Reg, volatile.LoadUint32(&o.LUT122L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT122L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT122L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT122H: Graphic MMU LUT entry 122 high
func (o *GFXMMU_Type) SetLUT122H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT122H.Reg, volatile.LoadUint32(&o.LUT122H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT122H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT122H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT123L: Graphic MMU LUT entry 123 low
func (o *GFXMMU_Type) SetLUT123L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT123L.Reg, volatile.LoadUint32(&o.LUT123L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT123L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT123L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT123L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT123L.Reg, volatile.LoadUint32(&o.LUT123L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT123L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT123L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT123L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT123L.Reg, volatile.LoadUint32(&o.LUT123L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT123L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT123L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT123H: Graphic MMU LUT entry 123 high
func (o *GFXMMU_Type) SetLUT123H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT123H.Reg, volatile.LoadUint32(&o.LUT123H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT123H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT123H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT124L: Graphic MMU LUT entry 124 low
func (o *GFXMMU_Type) SetLUT124L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT124L.Reg, volatile.LoadUint32(&o.LUT124L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT124L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT124L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT124L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT124L.Reg, volatile.LoadUint32(&o.LUT124L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT124L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT124L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT124L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT124L.Reg, volatile.LoadUint32(&o.LUT124L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT124L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT124L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT124H: Graphic MMU LUT entry 124 high
func (o *GFXMMU_Type) SetLUT124H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT124H.Reg, volatile.LoadUint32(&o.LUT124H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT124H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT124H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT125L: Graphic MMU LUT entry 125 low
func (o *GFXMMU_Type) SetLUT125L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT125L.Reg, volatile.LoadUint32(&o.LUT125L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT125L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT125L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT125L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT125L.Reg, volatile.LoadUint32(&o.LUT125L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT125L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT125L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT125L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT125L.Reg, volatile.LoadUint32(&o.LUT125L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT125L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT125L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT125H: Graphic MMU LUT entry 125 high
func (o *GFXMMU_Type) SetLUT125H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT125H.Reg, volatile.LoadUint32(&o.LUT125H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT125H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT125H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT126L: Graphic MMU LUT entry 126 low
func (o *GFXMMU_Type) SetLUT126L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT126L.Reg, volatile.LoadUint32(&o.LUT126L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT126L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT126L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT126L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT126L.Reg, volatile.LoadUint32(&o.LUT126L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT126L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT126L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT126L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT126L.Reg, volatile.LoadUint32(&o.LUT126L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT126L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT126L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT126H: Graphic MMU LUT entry 126 high
func (o *GFXMMU_Type) SetLUT126H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT126H.Reg, volatile.LoadUint32(&o.LUT126H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT126H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT126H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT127L: Graphic MMU LUT entry 127 low
func (o *GFXMMU_Type) SetLUT127L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT127L.Reg, volatile.LoadUint32(&o.LUT127L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT127L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT127L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT127L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT127L.Reg, volatile.LoadUint32(&o.LUT127L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT127L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT127L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT127L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT127L.Reg, volatile.LoadUint32(&o.LUT127L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT127L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT127L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT127H: Graphic MMU LUT entry 127 high
func (o *GFXMMU_Type) SetLUT127H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT127H.Reg, volatile.LoadUint32(&o.LUT127H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT127H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT127H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT128L: Graphic MMU LUT entry 128 low
func (o *GFXMMU_Type) SetLUT128L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT128L.Reg, volatile.LoadUint32(&o.LUT128L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT128L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT128L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT128L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT128L.Reg, volatile.LoadUint32(&o.LUT128L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT128L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT128L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT128L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT128L.Reg, volatile.LoadUint32(&o.LUT128L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT128L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT128L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT128H: Graphic MMU LUT entry 128 high
func (o *GFXMMU_Type) SetLUT128H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT128H.Reg, volatile.LoadUint32(&o.LUT128H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT128H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT128H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT129L: Graphic MMU LUT entry 129 low
func (o *GFXMMU_Type) SetLUT129L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT129L.Reg, volatile.LoadUint32(&o.LUT129L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT129L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT129L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT129L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT129L.Reg, volatile.LoadUint32(&o.LUT129L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT129L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT129L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT129L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT129L.Reg, volatile.LoadUint32(&o.LUT129L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT129L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT129L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT129H: Graphic MMU LUT entry 129 high
func (o *GFXMMU_Type) SetLUT129H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT129H.Reg, volatile.LoadUint32(&o.LUT129H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT129H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT129H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT130L: Graphic MMU LUT entry 130 low
func (o *GFXMMU_Type) SetLUT130L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT130L.Reg, volatile.LoadUint32(&o.LUT130L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT130L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT130L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT130L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT130L.Reg, volatile.LoadUint32(&o.LUT130L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT130L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT130L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT130L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT130L.Reg, volatile.LoadUint32(&o.LUT130L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT130L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT130L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT130H: Graphic MMU LUT entry 130 high
func (o *GFXMMU_Type) SetLUT130H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT130H.Reg, volatile.LoadUint32(&o.LUT130H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT130H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT130H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT131L: Graphic MMU LUT entry 131 low
func (o *GFXMMU_Type) SetLUT131L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT131L.Reg, volatile.LoadUint32(&o.LUT131L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT131L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT131L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT131L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT131L.Reg, volatile.LoadUint32(&o.LUT131L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT131L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT131L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT131L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT131L.Reg, volatile.LoadUint32(&o.LUT131L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT131L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT131L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT131H: Graphic MMU LUT entry 131 high
func (o *GFXMMU_Type) SetLUT131H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT131H.Reg, volatile.LoadUint32(&o.LUT131H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT131H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT131H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT132L: Graphic MMU LUT entry 132 low
func (o *GFXMMU_Type) SetLUT132L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT132L.Reg, volatile.LoadUint32(&o.LUT132L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT132L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT132L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT132L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT132L.Reg, volatile.LoadUint32(&o.LUT132L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT132L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT132L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT132L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT132L.Reg, volatile.LoadUint32(&o.LUT132L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT132L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT132L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT132H: Graphic MMU LUT entry 132 high
func (o *GFXMMU_Type) SetLUT132H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT132H.Reg, volatile.LoadUint32(&o.LUT132H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT132H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT132H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT133L: Graphic MMU LUT entry 133 low
func (o *GFXMMU_Type) SetLUT133L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT133L.Reg, volatile.LoadUint32(&o.LUT133L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT133L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT133L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT133L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT133L.Reg, volatile.LoadUint32(&o.LUT133L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT133L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT133L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT133L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT133L.Reg, volatile.LoadUint32(&o.LUT133L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT133L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT133L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT133H: Graphic MMU LUT entry 133 high
func (o *GFXMMU_Type) SetLUT133H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT133H.Reg, volatile.LoadUint32(&o.LUT133H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT133H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT133H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT134L: Graphic MMU LUT entry 134 low
func (o *GFXMMU_Type) SetLUT134L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT134L.Reg, volatile.LoadUint32(&o.LUT134L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT134L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT134L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT134L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT134L.Reg, volatile.LoadUint32(&o.LUT134L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT134L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT134L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT134L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT134L.Reg, volatile.LoadUint32(&o.LUT134L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT134L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT134L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT134H: Graphic MMU LUT entry 134 high
func (o *GFXMMU_Type) SetLUT134H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT134H.Reg, volatile.LoadUint32(&o.LUT134H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT134H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT134H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT135L: Graphic MMU LUT entry 135 low
func (o *GFXMMU_Type) SetLUT135L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT135L.Reg, volatile.LoadUint32(&o.LUT135L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT135L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT135L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT135L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT135L.Reg, volatile.LoadUint32(&o.LUT135L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT135L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT135L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT135L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT135L.Reg, volatile.LoadUint32(&o.LUT135L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT135L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT135L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT135H: Graphic MMU LUT entry 135 high
func (o *GFXMMU_Type) SetLUT135H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT135H.Reg, volatile.LoadUint32(&o.LUT135H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT135H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT135H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT136L: Graphic MMU LUT entry 136 low
func (o *GFXMMU_Type) SetLUT136L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT136L.Reg, volatile.LoadUint32(&o.LUT136L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT136L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT136L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT136L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT136L.Reg, volatile.LoadUint32(&o.LUT136L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT136L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT136L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT136L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT136L.Reg, volatile.LoadUint32(&o.LUT136L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT136L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT136L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT136H: Graphic MMU LUT entry 136 high
func (o *GFXMMU_Type) SetLUT136H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT136H.Reg, volatile.LoadUint32(&o.LUT136H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT136H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT136H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT137L: Graphic MMU LUT entry 137 low
func (o *GFXMMU_Type) SetLUT137L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT137L.Reg, volatile.LoadUint32(&o.LUT137L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT137L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT137L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT137L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT137L.Reg, volatile.LoadUint32(&o.LUT137L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT137L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT137L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT137L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT137L.Reg, volatile.LoadUint32(&o.LUT137L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT137L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT137L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT137H: Graphic MMU LUT entry 137 high
func (o *GFXMMU_Type) SetLUT137H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT137H.Reg, volatile.LoadUint32(&o.LUT137H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT137H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT137H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT138L: Graphic MMU LUT entry 138 low
func (o *GFXMMU_Type) SetLUT138L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT138L.Reg, volatile.LoadUint32(&o.LUT138L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT138L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT138L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT138L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT138L.Reg, volatile.LoadUint32(&o.LUT138L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT138L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT138L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT138L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT138L.Reg, volatile.LoadUint32(&o.LUT138L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT138L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT138L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT138H: Graphic MMU LUT entry 138 high
func (o *GFXMMU_Type) SetLUT138H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT138H.Reg, volatile.LoadUint32(&o.LUT138H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT138H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT138H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT139L: Graphic MMU LUT entry 139 low
func (o *GFXMMU_Type) SetLUT139L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT139L.Reg, volatile.LoadUint32(&o.LUT139L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT139L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT139L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT139L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT139L.Reg, volatile.LoadUint32(&o.LUT139L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT139L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT139L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT139L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT139L.Reg, volatile.LoadUint32(&o.LUT139L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT139L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT139L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT139H: Graphic MMU LUT entry 139 high
func (o *GFXMMU_Type) SetLUT139H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT139H.Reg, volatile.LoadUint32(&o.LUT139H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT139H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT139H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT140L: Graphic MMU LUT entry 140 low
func (o *GFXMMU_Type) SetLUT140L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT140L.Reg, volatile.LoadUint32(&o.LUT140L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT140L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT140L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT140L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT140L.Reg, volatile.LoadUint32(&o.LUT140L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT140L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT140L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT140L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT140L.Reg, volatile.LoadUint32(&o.LUT140L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT140L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT140L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT140H: Graphic MMU LUT entry 140 high
func (o *GFXMMU_Type) SetLUT140H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT140H.Reg, volatile.LoadUint32(&o.LUT140H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT140H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT140H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT141L: Graphic MMU LUT entry 141 low
func (o *GFXMMU_Type) SetLUT141L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT141L.Reg, volatile.LoadUint32(&o.LUT141L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT141L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT141L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT141L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT141L.Reg, volatile.LoadUint32(&o.LUT141L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT141L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT141L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT141L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT141L.Reg, volatile.LoadUint32(&o.LUT141L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT141L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT141L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT141H: Graphic MMU LUT entry 141 high
func (o *GFXMMU_Type) SetLUT141H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT141H.Reg, volatile.LoadUint32(&o.LUT141H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT141H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT141H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT142L: Graphic MMU LUT entry 142 low
func (o *GFXMMU_Type) SetLUT142L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT142L.Reg, volatile.LoadUint32(&o.LUT142L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT142L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT142L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT142L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT142L.Reg, volatile.LoadUint32(&o.LUT142L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT142L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT142L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT142L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT142L.Reg, volatile.LoadUint32(&o.LUT142L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT142L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT142L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT142H: Graphic MMU LUT entry 142 high
func (o *GFXMMU_Type) SetLUT142H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT142H.Reg, volatile.LoadUint32(&o.LUT142H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT142H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT142H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT143L: Graphic MMU LUT entry 143 low
func (o *GFXMMU_Type) SetLUT143L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT143L.Reg, volatile.LoadUint32(&o.LUT143L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT143L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT143L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT143L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT143L.Reg, volatile.LoadUint32(&o.LUT143L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT143L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT143L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT143L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT143L.Reg, volatile.LoadUint32(&o.LUT143L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT143L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT143L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT143H: Graphic MMU LUT entry 143 high
func (o *GFXMMU_Type) SetLUT143H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT143H.Reg, volatile.LoadUint32(&o.LUT143H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT143H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT143H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT144L: Graphic MMU LUT entry 144 low
func (o *GFXMMU_Type) SetLUT144L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT144L.Reg, volatile.LoadUint32(&o.LUT144L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT144L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT144L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT144L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT144L.Reg, volatile.LoadUint32(&o.LUT144L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT144L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT144L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT144L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT144L.Reg, volatile.LoadUint32(&o.LUT144L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT144L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT144L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT144H: Graphic MMU LUT entry 144 high
func (o *GFXMMU_Type) SetLUT144H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT144H.Reg, volatile.LoadUint32(&o.LUT144H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT144H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT144H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT145L: Graphic MMU LUT entry 145 low
func (o *GFXMMU_Type) SetLUT145L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT145L.Reg, volatile.LoadUint32(&o.LUT145L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT145L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT145L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT145L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT145L.Reg, volatile.LoadUint32(&o.LUT145L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT145L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT145L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT145L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT145L.Reg, volatile.LoadUint32(&o.LUT145L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT145L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT145L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT145H: Graphic MMU LUT entry 145 high
func (o *GFXMMU_Type) SetLUT145H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT145H.Reg, volatile.LoadUint32(&o.LUT145H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT145H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT145H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT146L: Graphic MMU LUT entry 146 low
func (o *GFXMMU_Type) SetLUT146L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT146L.Reg, volatile.LoadUint32(&o.LUT146L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT146L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT146L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT146L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT146L.Reg, volatile.LoadUint32(&o.LUT146L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT146L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT146L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT146L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT146L.Reg, volatile.LoadUint32(&o.LUT146L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT146L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT146L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT146H: Graphic MMU LUT entry 146 high
func (o *GFXMMU_Type) SetLUT146H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT146H.Reg, volatile.LoadUint32(&o.LUT146H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT146H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT146H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT147L: Graphic MMU LUT entry 147 low
func (o *GFXMMU_Type) SetLUT147L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT147L.Reg, volatile.LoadUint32(&o.LUT147L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT147L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT147L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT147L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT147L.Reg, volatile.LoadUint32(&o.LUT147L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT147L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT147L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT147L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT147L.Reg, volatile.LoadUint32(&o.LUT147L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT147L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT147L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT147H: Graphic MMU LUT entry 147 high
func (o *GFXMMU_Type) SetLUT147H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT147H.Reg, volatile.LoadUint32(&o.LUT147H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT147H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT147H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT148L: Graphic MMU LUT entry 148 low
func (o *GFXMMU_Type) SetLUT148L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT148L.Reg, volatile.LoadUint32(&o.LUT148L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT148L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT148L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT148L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT148L.Reg, volatile.LoadUint32(&o.LUT148L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT148L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT148L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT148L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT148L.Reg, volatile.LoadUint32(&o.LUT148L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT148L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT148L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT148H: Graphic MMU LUT entry 148 high
func (o *GFXMMU_Type) SetLUT148H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT148H.Reg, volatile.LoadUint32(&o.LUT148H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT148H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT148H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT149L: Graphic MMU LUT entry 149 low
func (o *GFXMMU_Type) SetLUT149L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT149L.Reg, volatile.LoadUint32(&o.LUT149L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT149L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT149L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT149L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT149L.Reg, volatile.LoadUint32(&o.LUT149L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT149L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT149L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT149L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT149L.Reg, volatile.LoadUint32(&o.LUT149L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT149L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT149L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT149H: Graphic MMU LUT entry 149 high
func (o *GFXMMU_Type) SetLUT149H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT149H.Reg, volatile.LoadUint32(&o.LUT149H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT149H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT149H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT150L: Graphic MMU LUT entry 150 low
func (o *GFXMMU_Type) SetLUT150L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT150L.Reg, volatile.LoadUint32(&o.LUT150L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT150L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT150L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT150L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT150L.Reg, volatile.LoadUint32(&o.LUT150L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT150L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT150L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT150L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT150L.Reg, volatile.LoadUint32(&o.LUT150L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT150L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT150L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT150H: Graphic MMU LUT entry 150 high
func (o *GFXMMU_Type) SetLUT150H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT150H.Reg, volatile.LoadUint32(&o.LUT150H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT150H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT150H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT151L: Graphic MMU LUT entry 151 low
func (o *GFXMMU_Type) SetLUT151L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT151L.Reg, volatile.LoadUint32(&o.LUT151L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT151L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT151L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT151L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT151L.Reg, volatile.LoadUint32(&o.LUT151L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT151L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT151L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT151L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT151L.Reg, volatile.LoadUint32(&o.LUT151L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT151L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT151L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT151H: Graphic MMU LUT entry 151 high
func (o *GFXMMU_Type) SetLUT151H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT151H.Reg, volatile.LoadUint32(&o.LUT151H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT151H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT151H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT152L: Graphic MMU LUT entry 152 low
func (o *GFXMMU_Type) SetLUT152L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT152L.Reg, volatile.LoadUint32(&o.LUT152L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT152L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT152L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT152L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT152L.Reg, volatile.LoadUint32(&o.LUT152L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT152L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT152L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT152L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT152L.Reg, volatile.LoadUint32(&o.LUT152L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT152L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT152L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT152H: Graphic MMU LUT entry 152 high
func (o *GFXMMU_Type) SetLUT152H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT152H.Reg, volatile.LoadUint32(&o.LUT152H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT152H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT152H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT153L: Graphic MMU LUT entry 153 low
func (o *GFXMMU_Type) SetLUT153L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT153L.Reg, volatile.LoadUint32(&o.LUT153L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT153L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT153L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT153L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT153L.Reg, volatile.LoadUint32(&o.LUT153L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT153L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT153L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT153L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT153L.Reg, volatile.LoadUint32(&o.LUT153L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT153L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT153L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT153H: Graphic MMU LUT entry 153 high
func (o *GFXMMU_Type) SetLUT153H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT153H.Reg, volatile.LoadUint32(&o.LUT153H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT153H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT153H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT154L: Graphic MMU LUT entry 154 low
func (o *GFXMMU_Type) SetLUT154L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT154L.Reg, volatile.LoadUint32(&o.LUT154L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT154L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT154L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT154L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT154L.Reg, volatile.LoadUint32(&o.LUT154L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT154L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT154L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT154L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT154L.Reg, volatile.LoadUint32(&o.LUT154L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT154L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT154L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT154H: Graphic MMU LUT entry 154 high
func (o *GFXMMU_Type) SetLUT154H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT154H.Reg, volatile.LoadUint32(&o.LUT154H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT154H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT154H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT155L: Graphic MMU LUT entry 155 low
func (o *GFXMMU_Type) SetLUT155L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT155L.Reg, volatile.LoadUint32(&o.LUT155L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT155L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT155L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT155L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT155L.Reg, volatile.LoadUint32(&o.LUT155L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT155L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT155L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT155L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT155L.Reg, volatile.LoadUint32(&o.LUT155L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT155L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT155L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT155H: Graphic MMU LUT entry 155 high
func (o *GFXMMU_Type) SetLUT155H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT155H.Reg, volatile.LoadUint32(&o.LUT155H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT155H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT155H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT156L: Graphic MMU LUT entry 156 low
func (o *GFXMMU_Type) SetLUT156L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT156L.Reg, volatile.LoadUint32(&o.LUT156L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT156L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT156L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT156L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT156L.Reg, volatile.LoadUint32(&o.LUT156L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT156L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT156L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT156L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT156L.Reg, volatile.LoadUint32(&o.LUT156L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT156L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT156L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT156H: Graphic MMU LUT entry 156 high
func (o *GFXMMU_Type) SetLUT156H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT156H.Reg, volatile.LoadUint32(&o.LUT156H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT156H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT156H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT157L: Graphic MMU LUT entry 157 low
func (o *GFXMMU_Type) SetLUT157L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT157L.Reg, volatile.LoadUint32(&o.LUT157L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT157L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT157L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT157L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT157L.Reg, volatile.LoadUint32(&o.LUT157L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT157L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT157L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT157L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT157L.Reg, volatile.LoadUint32(&o.LUT157L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT157L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT157L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT157H: Graphic MMU LUT entry 157 high
func (o *GFXMMU_Type) SetLUT157H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT157H.Reg, volatile.LoadUint32(&o.LUT157H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT157H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT157H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT158L: Graphic MMU LUT entry 158 low
func (o *GFXMMU_Type) SetLUT158L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT158L.Reg, volatile.LoadUint32(&o.LUT158L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT158L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT158L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT158L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT158L.Reg, volatile.LoadUint32(&o.LUT158L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT158L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT158L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT158L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT158L.Reg, volatile.LoadUint32(&o.LUT158L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT158L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT158L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT158H: Graphic MMU LUT entry 158 high
func (o *GFXMMU_Type) SetLUT158H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT158H.Reg, volatile.LoadUint32(&o.LUT158H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT158H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT158H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT159L: Graphic MMU LUT entry 159 low
func (o *GFXMMU_Type) SetLUT159L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT159L.Reg, volatile.LoadUint32(&o.LUT159L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT159L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT159L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT159L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT159L.Reg, volatile.LoadUint32(&o.LUT159L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT159L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT159L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT159L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT159L.Reg, volatile.LoadUint32(&o.LUT159L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT159L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT159L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT159H: Graphic MMU LUT entry 159 high
func (o *GFXMMU_Type) SetLUT159H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT159H.Reg, volatile.LoadUint32(&o.LUT159H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT159H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT159H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT160L: Graphic MMU LUT entry 160 low
func (o *GFXMMU_Type) SetLUT160L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT160L.Reg, volatile.LoadUint32(&o.LUT160L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT160L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT160L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT160L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT160L.Reg, volatile.LoadUint32(&o.LUT160L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT160L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT160L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT160L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT160L.Reg, volatile.LoadUint32(&o.LUT160L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT160L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT160L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT160H: Graphic MMU LUT entry 160 high
func (o *GFXMMU_Type) SetLUT160H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT160H.Reg, volatile.LoadUint32(&o.LUT160H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT160H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT160H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT161L: Graphic MMU LUT entry 161 low
func (o *GFXMMU_Type) SetLUT161L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT161L.Reg, volatile.LoadUint32(&o.LUT161L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT161L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT161L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT161L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT161L.Reg, volatile.LoadUint32(&o.LUT161L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT161L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT161L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT161L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT161L.Reg, volatile.LoadUint32(&o.LUT161L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT161L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT161L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT161H: Graphic MMU LUT entry 161 high
func (o *GFXMMU_Type) SetLUT161H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT161H.Reg, volatile.LoadUint32(&o.LUT161H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT161H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT161H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT162L: Graphic MMU LUT entry 162 low
func (o *GFXMMU_Type) SetLUT162L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT162L.Reg, volatile.LoadUint32(&o.LUT162L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT162L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT162L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT162L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT162L.Reg, volatile.LoadUint32(&o.LUT162L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT162L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT162L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT162L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT162L.Reg, volatile.LoadUint32(&o.LUT162L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT162L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT162L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT162H: Graphic MMU LUT entry 162 high
func (o *GFXMMU_Type) SetLUT162H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT162H.Reg, volatile.LoadUint32(&o.LUT162H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT162H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT162H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT163L: Graphic MMU LUT entry 163 low
func (o *GFXMMU_Type) SetLUT163L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT163L.Reg, volatile.LoadUint32(&o.LUT163L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT163L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT163L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT163L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT163L.Reg, volatile.LoadUint32(&o.LUT163L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT163L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT163L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT163L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT163L.Reg, volatile.LoadUint32(&o.LUT163L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT163L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT163L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT163H: Graphic MMU LUT entry 163 high
func (o *GFXMMU_Type) SetLUT163H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT163H.Reg, volatile.LoadUint32(&o.LUT163H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT163H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT163H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT164L: Graphic MMU LUT entry 164 low
func (o *GFXMMU_Type) SetLUT164L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT164L.Reg, volatile.LoadUint32(&o.LUT164L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT164L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT164L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT164L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT164L.Reg, volatile.LoadUint32(&o.LUT164L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT164L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT164L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT164L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT164L.Reg, volatile.LoadUint32(&o.LUT164L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT164L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT164L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT164H: Graphic MMU LUT entry 164 high
func (o *GFXMMU_Type) SetLUT164H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT164H.Reg, volatile.LoadUint32(&o.LUT164H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT164H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT164H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT165L: Graphic MMU LUT entry 165 low
func (o *GFXMMU_Type) SetLUT165L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT165L.Reg, volatile.LoadUint32(&o.LUT165L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT165L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT165L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT165L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT165L.Reg, volatile.LoadUint32(&o.LUT165L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT165L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT165L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT165L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT165L.Reg, volatile.LoadUint32(&o.LUT165L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT165L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT165L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT165H: Graphic MMU LUT entry 165 high
func (o *GFXMMU_Type) SetLUT165H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT165H.Reg, volatile.LoadUint32(&o.LUT165H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT165H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT165H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT166L: Graphic MMU LUT entry 166 low
func (o *GFXMMU_Type) SetLUT166L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT166L.Reg, volatile.LoadUint32(&o.LUT166L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT166L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT166L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT166L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT166L.Reg, volatile.LoadUint32(&o.LUT166L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT166L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT166L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT166L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT166L.Reg, volatile.LoadUint32(&o.LUT166L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT166L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT166L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT166H: Graphic MMU LUT entry 166 high
func (o *GFXMMU_Type) SetLUT166H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT166H.Reg, volatile.LoadUint32(&o.LUT166H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT166H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT166H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT167L: Graphic MMU LUT entry 167 low
func (o *GFXMMU_Type) SetLUT167L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT167L.Reg, volatile.LoadUint32(&o.LUT167L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT167L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT167L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT167L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT167L.Reg, volatile.LoadUint32(&o.LUT167L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT167L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT167L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT167L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT167L.Reg, volatile.LoadUint32(&o.LUT167L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT167L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT167L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT167H: Graphic MMU LUT entry 167 high
func (o *GFXMMU_Type) SetLUT167H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT167H.Reg, volatile.LoadUint32(&o.LUT167H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT167H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT167H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT168L: Graphic MMU LUT entry 168 low
func (o *GFXMMU_Type) SetLUT168L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT168L.Reg, volatile.LoadUint32(&o.LUT168L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT168L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT168L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT168L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT168L.Reg, volatile.LoadUint32(&o.LUT168L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT168L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT168L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT168L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT168L.Reg, volatile.LoadUint32(&o.LUT168L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT168L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT168L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT168H: Graphic MMU LUT entry 168 high
func (o *GFXMMU_Type) SetLUT168H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT168H.Reg, volatile.LoadUint32(&o.LUT168H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT168H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT168H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT169L: Graphic MMU LUT entry 169 low
func (o *GFXMMU_Type) SetLUT169L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT169L.Reg, volatile.LoadUint32(&o.LUT169L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT169L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT169L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT169L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT169L.Reg, volatile.LoadUint32(&o.LUT169L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT169L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT169L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT169L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT169L.Reg, volatile.LoadUint32(&o.LUT169L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT169L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT169L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT169H: Graphic MMU LUT entry 169 high
func (o *GFXMMU_Type) SetLUT169H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT169H.Reg, volatile.LoadUint32(&o.LUT169H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT169H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT169H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT170L: Graphic MMU LUT entry 170 low
func (o *GFXMMU_Type) SetLUT170L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT170L.Reg, volatile.LoadUint32(&o.LUT170L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT170L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT170L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT170L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT170L.Reg, volatile.LoadUint32(&o.LUT170L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT170L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT170L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT170L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT170L.Reg, volatile.LoadUint32(&o.LUT170L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT170L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT170L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT170H: Graphic MMU LUT entry 170 high
func (o *GFXMMU_Type) SetLUT170H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT170H.Reg, volatile.LoadUint32(&o.LUT170H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT170H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT170H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT171L: Graphic MMU LUT entry 171 low
func (o *GFXMMU_Type) SetLUT171L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT171L.Reg, volatile.LoadUint32(&o.LUT171L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT171L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT171L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT171L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT171L.Reg, volatile.LoadUint32(&o.LUT171L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT171L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT171L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT171L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT171L.Reg, volatile.LoadUint32(&o.LUT171L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT171L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT171L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT171H: Graphic MMU LUT entry 171 high
func (o *GFXMMU_Type) SetLUT171H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT171H.Reg, volatile.LoadUint32(&o.LUT171H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT171H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT171H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT172L: Graphic MMU LUT entry 172 low
func (o *GFXMMU_Type) SetLUT172L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT172L.Reg, volatile.LoadUint32(&o.LUT172L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT172L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT172L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT172L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT172L.Reg, volatile.LoadUint32(&o.LUT172L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT172L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT172L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT172L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT172L.Reg, volatile.LoadUint32(&o.LUT172L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT172L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT172L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT172H: Graphic MMU LUT entry 172 high
func (o *GFXMMU_Type) SetLUT172H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT172H.Reg, volatile.LoadUint32(&o.LUT172H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT172H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT172H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT173L: Graphic MMU LUT entry 173 low
func (o *GFXMMU_Type) SetLUT173L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT173L.Reg, volatile.LoadUint32(&o.LUT173L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT173L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT173L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT173L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT173L.Reg, volatile.LoadUint32(&o.LUT173L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT173L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT173L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT173L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT173L.Reg, volatile.LoadUint32(&o.LUT173L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT173L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT173L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT173H: Graphic MMU LUT entry 173 high
func (o *GFXMMU_Type) SetLUT173H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT173H.Reg, volatile.LoadUint32(&o.LUT173H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT173H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT173H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT174L: Graphic MMU LUT entry 174 low
func (o *GFXMMU_Type) SetLUT174L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT174L.Reg, volatile.LoadUint32(&o.LUT174L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT174L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT174L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT174L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT174L.Reg, volatile.LoadUint32(&o.LUT174L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT174L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT174L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT174L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT174L.Reg, volatile.LoadUint32(&o.LUT174L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT174L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT174L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT174H: Graphic MMU LUT entry 174 high
func (o *GFXMMU_Type) SetLUT174H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT174H.Reg, volatile.LoadUint32(&o.LUT174H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT174H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT174H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT175L: Graphic MMU LUT entry 175 low
func (o *GFXMMU_Type) SetLUT175L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT175L.Reg, volatile.LoadUint32(&o.LUT175L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT175L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT175L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT175L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT175L.Reg, volatile.LoadUint32(&o.LUT175L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT175L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT175L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT175L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT175L.Reg, volatile.LoadUint32(&o.LUT175L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT175L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT175L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT175H: Graphic MMU LUT entry 175 high
func (o *GFXMMU_Type) SetLUT175H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT175H.Reg, volatile.LoadUint32(&o.LUT175H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT175H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT175H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT176L: Graphic MMU LUT entry 176 low
func (o *GFXMMU_Type) SetLUT176L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT176L.Reg, volatile.LoadUint32(&o.LUT176L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT176L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT176L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT176L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT176L.Reg, volatile.LoadUint32(&o.LUT176L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT176L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT176L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT176L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT176L.Reg, volatile.LoadUint32(&o.LUT176L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT176L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT176L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT176H: Graphic MMU LUT entry 176 high
func (o *GFXMMU_Type) SetLUT176H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT176H.Reg, volatile.LoadUint32(&o.LUT176H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT176H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT176H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT177L: Graphic MMU LUT entry 177 low
func (o *GFXMMU_Type) SetLUT177L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT177L.Reg, volatile.LoadUint32(&o.LUT177L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT177L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT177L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT177L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT177L.Reg, volatile.LoadUint32(&o.LUT177L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT177L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT177L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT177L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT177L.Reg, volatile.LoadUint32(&o.LUT177L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT177L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT177L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT177H: Graphic MMU LUT entry 177 high
func (o *GFXMMU_Type) SetLUT177H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT177H.Reg, volatile.LoadUint32(&o.LUT177H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT177H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT177H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT178L: Graphic MMU LUT entry 178 low
func (o *GFXMMU_Type) SetLUT178L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT178L.Reg, volatile.LoadUint32(&o.LUT178L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT178L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT178L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT178L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT178L.Reg, volatile.LoadUint32(&o.LUT178L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT178L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT178L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT178L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT178L.Reg, volatile.LoadUint32(&o.LUT178L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT178L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT178L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT178H: Graphic MMU LUT entry 178 high
func (o *GFXMMU_Type) SetLUT178H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT178H.Reg, volatile.LoadUint32(&o.LUT178H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT178H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT178H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT179L: Graphic MMU LUT entry 179 low
func (o *GFXMMU_Type) SetLUT179L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT179L.Reg, volatile.LoadUint32(&o.LUT179L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT179L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT179L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT179L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT179L.Reg, volatile.LoadUint32(&o.LUT179L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT179L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT179L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT179L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT179L.Reg, volatile.LoadUint32(&o.LUT179L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT179L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT179L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT179H: Graphic MMU LUT entry 179 high
func (o *GFXMMU_Type) SetLUT179H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT179H.Reg, volatile.LoadUint32(&o.LUT179H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT179H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT179H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT180L: Graphic MMU LUT entry 180 low
func (o *GFXMMU_Type) SetLUT180L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT180L.Reg, volatile.LoadUint32(&o.LUT180L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT180L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT180L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT180L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT180L.Reg, volatile.LoadUint32(&o.LUT180L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT180L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT180L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT180L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT180L.Reg, volatile.LoadUint32(&o.LUT180L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT180L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT180L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT180H: Graphic MMU LUT entry 180 high
func (o *GFXMMU_Type) SetLUT180H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT180H.Reg, volatile.LoadUint32(&o.LUT180H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT180H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT180H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT181L: Graphic MMU LUT entry 181 low
func (o *GFXMMU_Type) SetLUT181L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT181L.Reg, volatile.LoadUint32(&o.LUT181L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT181L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT181L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT181L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT181L.Reg, volatile.LoadUint32(&o.LUT181L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT181L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT181L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT181L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT181L.Reg, volatile.LoadUint32(&o.LUT181L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT181L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT181L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT181H: Graphic MMU LUT entry 181 high
func (o *GFXMMU_Type) SetLUT181H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT181H.Reg, volatile.LoadUint32(&o.LUT181H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT181H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT181H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT182L: Graphic MMU LUT entry 182 low
func (o *GFXMMU_Type) SetLUT182L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT182L.Reg, volatile.LoadUint32(&o.LUT182L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT182L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT182L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT182L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT182L.Reg, volatile.LoadUint32(&o.LUT182L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT182L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT182L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT182L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT182L.Reg, volatile.LoadUint32(&o.LUT182L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT182L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT182L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT182H: Graphic MMU LUT entry 182 high
func (o *GFXMMU_Type) SetLUT182H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT182H.Reg, volatile.LoadUint32(&o.LUT182H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT182H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT182H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT183L: Graphic MMU LUT entry 183 low
func (o *GFXMMU_Type) SetLUT183L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT183L.Reg, volatile.LoadUint32(&o.LUT183L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT183L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT183L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT183L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT183L.Reg, volatile.LoadUint32(&o.LUT183L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT183L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT183L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT183L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT183L.Reg, volatile.LoadUint32(&o.LUT183L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT183L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT183L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT183H: Graphic MMU LUT entry 183 high
func (o *GFXMMU_Type) SetLUT183H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT183H.Reg, volatile.LoadUint32(&o.LUT183H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT183H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT183H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT184L: Graphic MMU LUT entry 184 low
func (o *GFXMMU_Type) SetLUT184L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT184L.Reg, volatile.LoadUint32(&o.LUT184L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT184L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT184L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT184L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT184L.Reg, volatile.LoadUint32(&o.LUT184L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT184L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT184L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT184L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT184L.Reg, volatile.LoadUint32(&o.LUT184L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT184L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT184L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT184H: Graphic MMU LUT entry 184 high
func (o *GFXMMU_Type) SetLUT184H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT184H.Reg, volatile.LoadUint32(&o.LUT184H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT184H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT184H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT185L: Graphic MMU LUT entry 185 low
func (o *GFXMMU_Type) SetLUT185L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT185L.Reg, volatile.LoadUint32(&o.LUT185L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT185L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT185L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT185L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT185L.Reg, volatile.LoadUint32(&o.LUT185L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT185L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT185L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT185L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT185L.Reg, volatile.LoadUint32(&o.LUT185L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT185L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT185L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT185H: Graphic MMU LUT entry 185 high
func (o *GFXMMU_Type) SetLUT185H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT185H.Reg, volatile.LoadUint32(&o.LUT185H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT185H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT185H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT186L: Graphic MMU LUT entry 186 low
func (o *GFXMMU_Type) SetLUT186L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT186L.Reg, volatile.LoadUint32(&o.LUT186L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT186L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT186L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT186L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT186L.Reg, volatile.LoadUint32(&o.LUT186L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT186L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT186L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT186L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT186L.Reg, volatile.LoadUint32(&o.LUT186L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT186L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT186L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT186H: Graphic MMU LUT entry 186 high
func (o *GFXMMU_Type) SetLUT186H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT186H.Reg, volatile.LoadUint32(&o.LUT186H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT186H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT186H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT187L: Graphic MMU LUT entry 187 low
func (o *GFXMMU_Type) SetLUT187L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT187L.Reg, volatile.LoadUint32(&o.LUT187L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT187L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT187L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT187L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT187L.Reg, volatile.LoadUint32(&o.LUT187L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT187L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT187L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT187L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT187L.Reg, volatile.LoadUint32(&o.LUT187L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT187L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT187L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT187H: Graphic MMU LUT entry 187 high
func (o *GFXMMU_Type) SetLUT187H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT187H.Reg, volatile.LoadUint32(&o.LUT187H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT187H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT187H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT188L: Graphic MMU LUT entry 188 low
func (o *GFXMMU_Type) SetLUT188L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT188L.Reg, volatile.LoadUint32(&o.LUT188L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT188L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT188L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT188L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT188L.Reg, volatile.LoadUint32(&o.LUT188L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT188L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT188L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT188L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT188L.Reg, volatile.LoadUint32(&o.LUT188L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT188L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT188L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT188H: Graphic MMU LUT entry 188 high
func (o *GFXMMU_Type) SetLUT188H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT188H.Reg, volatile.LoadUint32(&o.LUT188H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT188H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT188H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT189L: Graphic MMU LUT entry 189 low
func (o *GFXMMU_Type) SetLUT189L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT189L.Reg, volatile.LoadUint32(&o.LUT189L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT189L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT189L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT189L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT189L.Reg, volatile.LoadUint32(&o.LUT189L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT189L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT189L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT189L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT189L.Reg, volatile.LoadUint32(&o.LUT189L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT189L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT189L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT189H: Graphic MMU LUT entry 189 high
func (o *GFXMMU_Type) SetLUT189H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT189H.Reg, volatile.LoadUint32(&o.LUT189H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT189H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT189H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT190L: Graphic MMU LUT entry 190 low
func (o *GFXMMU_Type) SetLUT190L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT190L.Reg, volatile.LoadUint32(&o.LUT190L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT190L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT190L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT190L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT190L.Reg, volatile.LoadUint32(&o.LUT190L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT190L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT190L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT190L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT190L.Reg, volatile.LoadUint32(&o.LUT190L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT190L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT190L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT190H: Graphic MMU LUT entry 190 high
func (o *GFXMMU_Type) SetLUT190H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT190H.Reg, volatile.LoadUint32(&o.LUT190H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT190H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT190H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT191L: Graphic MMU LUT entry 191 low
func (o *GFXMMU_Type) SetLUT191L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT191L.Reg, volatile.LoadUint32(&o.LUT191L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT191L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT191L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT191L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT191L.Reg, volatile.LoadUint32(&o.LUT191L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT191L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT191L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT191L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT191L.Reg, volatile.LoadUint32(&o.LUT191L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT191L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT191L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT191H: Graphic MMU LUT entry 191 high
func (o *GFXMMU_Type) SetLUT191H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT191H.Reg, volatile.LoadUint32(&o.LUT191H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT191H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT191H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT192L: Graphic MMU LUT entry 192 low
func (o *GFXMMU_Type) SetLUT192L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT192L.Reg, volatile.LoadUint32(&o.LUT192L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT192L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT192L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT192L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT192L.Reg, volatile.LoadUint32(&o.LUT192L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT192L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT192L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT192L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT192L.Reg, volatile.LoadUint32(&o.LUT192L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT192L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT192L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT192H: Graphic MMU LUT entry 192 high
func (o *GFXMMU_Type) SetLUT192H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT192H.Reg, volatile.LoadUint32(&o.LUT192H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT192H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT192H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT193L: Graphic MMU LUT entry 193 low
func (o *GFXMMU_Type) SetLUT193L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT193L.Reg, volatile.LoadUint32(&o.LUT193L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT193L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT193L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT193L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT193L.Reg, volatile.LoadUint32(&o.LUT193L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT193L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT193L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT193L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT193L.Reg, volatile.LoadUint32(&o.LUT193L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT193L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT193L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT193H: Graphic MMU LUT entry 193 high
func (o *GFXMMU_Type) SetLUT193H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT193H.Reg, volatile.LoadUint32(&o.LUT193H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT193H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT193H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT194L: Graphic MMU LUT entry 194 low
func (o *GFXMMU_Type) SetLUT194L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT194L.Reg, volatile.LoadUint32(&o.LUT194L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT194L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT194L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT194L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT194L.Reg, volatile.LoadUint32(&o.LUT194L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT194L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT194L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT194L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT194L.Reg, volatile.LoadUint32(&o.LUT194L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT194L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT194L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT194H: Graphic MMU LUT entry 194 high
func (o *GFXMMU_Type) SetLUT194H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT194H.Reg, volatile.LoadUint32(&o.LUT194H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT194H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT194H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT195L: Graphic MMU LUT entry 195 low
func (o *GFXMMU_Type) SetLUT195L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT195L.Reg, volatile.LoadUint32(&o.LUT195L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT195L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT195L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT195L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT195L.Reg, volatile.LoadUint32(&o.LUT195L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT195L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT195L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT195L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT195L.Reg, volatile.LoadUint32(&o.LUT195L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT195L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT195L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT195H: Graphic MMU LUT entry 195 high
func (o *GFXMMU_Type) SetLUT195H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT195H.Reg, volatile.LoadUint32(&o.LUT195H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT195H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT195H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT196L: Graphic MMU LUT entry 196 low
func (o *GFXMMU_Type) SetLUT196L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT196L.Reg, volatile.LoadUint32(&o.LUT196L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT196L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT196L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT196L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT196L.Reg, volatile.LoadUint32(&o.LUT196L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT196L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT196L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT196L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT196L.Reg, volatile.LoadUint32(&o.LUT196L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT196L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT196L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT196H: Graphic MMU LUT entry 196 high
func (o *GFXMMU_Type) SetLUT196H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT196H.Reg, volatile.LoadUint32(&o.LUT196H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT196H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT196H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT197L: Graphic MMU LUT entry 197 low
func (o *GFXMMU_Type) SetLUT197L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT197L.Reg, volatile.LoadUint32(&o.LUT197L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT197L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT197L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT197L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT197L.Reg, volatile.LoadUint32(&o.LUT197L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT197L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT197L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT197L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT197L.Reg, volatile.LoadUint32(&o.LUT197L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT197L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT197L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT197H: Graphic MMU LUT entry 197 high
func (o *GFXMMU_Type) SetLUT197H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT197H.Reg, volatile.LoadUint32(&o.LUT197H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT197H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT197H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT198L: Graphic MMU LUT entry 198 low
func (o *GFXMMU_Type) SetLUT198L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT198L.Reg, volatile.LoadUint32(&o.LUT198L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT198L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT198L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT198L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT198L.Reg, volatile.LoadUint32(&o.LUT198L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT198L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT198L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT198L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT198L.Reg, volatile.LoadUint32(&o.LUT198L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT198L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT198L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT198H: Graphic MMU LUT entry 198 high
func (o *GFXMMU_Type) SetLUT198H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT198H.Reg, volatile.LoadUint32(&o.LUT198H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT198H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT198H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT199L: Graphic MMU LUT entry 199 low
func (o *GFXMMU_Type) SetLUT199L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT199L.Reg, volatile.LoadUint32(&o.LUT199L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT199L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT199L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT199L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT199L.Reg, volatile.LoadUint32(&o.LUT199L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT199L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT199L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT199L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT199L.Reg, volatile.LoadUint32(&o.LUT199L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT199L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT199L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT199H: Graphic MMU LUT entry 199 high
func (o *GFXMMU_Type) SetLUT199H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT199H.Reg, volatile.LoadUint32(&o.LUT199H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT199H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT199H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT200L: Graphic MMU LUT entry 200 low
func (o *GFXMMU_Type) SetLUT200L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT200L.Reg, volatile.LoadUint32(&o.LUT200L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT200L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT200L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT200L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT200L.Reg, volatile.LoadUint32(&o.LUT200L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT200L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT200L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT200L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT200L.Reg, volatile.LoadUint32(&o.LUT200L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT200L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT200L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT200H: Graphic MMU LUT entry 200 high
func (o *GFXMMU_Type) SetLUT200H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT200H.Reg, volatile.LoadUint32(&o.LUT200H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT200H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT200H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT201L: Graphic MMU LUT entry 201 low
func (o *GFXMMU_Type) SetLUT201L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT201L.Reg, volatile.LoadUint32(&o.LUT201L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT201L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT201L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT201L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT201L.Reg, volatile.LoadUint32(&o.LUT201L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT201L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT201L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT201L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT201L.Reg, volatile.LoadUint32(&o.LUT201L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT201L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT201L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT201H: Graphic MMU LUT entry 201 high
func (o *GFXMMU_Type) SetLUT201H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT201H.Reg, volatile.LoadUint32(&o.LUT201H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT201H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT201H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT202L: Graphic MMU LUT entry 202 low
func (o *GFXMMU_Type) SetLUT202L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT202L.Reg, volatile.LoadUint32(&o.LUT202L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT202L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT202L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT202L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT202L.Reg, volatile.LoadUint32(&o.LUT202L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT202L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT202L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT202L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT202L.Reg, volatile.LoadUint32(&o.LUT202L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT202L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT202L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT202H: Graphic MMU LUT entry 202 high
func (o *GFXMMU_Type) SetLUT202H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT202H.Reg, volatile.LoadUint32(&o.LUT202H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT202H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT202H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT203L: Graphic MMU LUT entry 203 low
func (o *GFXMMU_Type) SetLUT203L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT203L.Reg, volatile.LoadUint32(&o.LUT203L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT203L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT203L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT203L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT203L.Reg, volatile.LoadUint32(&o.LUT203L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT203L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT203L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT203L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT203L.Reg, volatile.LoadUint32(&o.LUT203L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT203L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT203L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT203H: Graphic MMU LUT entry 203 high
func (o *GFXMMU_Type) SetLUT203H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT203H.Reg, volatile.LoadUint32(&o.LUT203H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT203H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT203H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT204L: Graphic MMU LUT entry 204 low
func (o *GFXMMU_Type) SetLUT204L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT204L.Reg, volatile.LoadUint32(&o.LUT204L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT204L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT204L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT204L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT204L.Reg, volatile.LoadUint32(&o.LUT204L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT204L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT204L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT204L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT204L.Reg, volatile.LoadUint32(&o.LUT204L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT204L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT204L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT204H: Graphic MMU LUT entry 204 high
func (o *GFXMMU_Type) SetLUT204H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT204H.Reg, volatile.LoadUint32(&o.LUT204H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT204H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT204H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT205L: Graphic MMU LUT entry 205 low
func (o *GFXMMU_Type) SetLUT205L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT205L.Reg, volatile.LoadUint32(&o.LUT205L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT205L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT205L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT205L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT205L.Reg, volatile.LoadUint32(&o.LUT205L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT205L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT205L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT205L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT205L.Reg, volatile.LoadUint32(&o.LUT205L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT205L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT205L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT205H: Graphic MMU LUT entry 205 high
func (o *GFXMMU_Type) SetLUT205H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT205H.Reg, volatile.LoadUint32(&o.LUT205H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT205H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT205H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT206L: Graphic MMU LUT entry 206 low
func (o *GFXMMU_Type) SetLUT206L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT206L.Reg, volatile.LoadUint32(&o.LUT206L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT206L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT206L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT206L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT206L.Reg, volatile.LoadUint32(&o.LUT206L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT206L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT206L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT206L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT206L.Reg, volatile.LoadUint32(&o.LUT206L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT206L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT206L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT206H: Graphic MMU LUT entry 206 high
func (o *GFXMMU_Type) SetLUT206H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT206H.Reg, volatile.LoadUint32(&o.LUT206H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT206H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT206H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT207L: Graphic MMU LUT entry 207 low
func (o *GFXMMU_Type) SetLUT207L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT207L.Reg, volatile.LoadUint32(&o.LUT207L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT207L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT207L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT207L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT207L.Reg, volatile.LoadUint32(&o.LUT207L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT207L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT207L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT207L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT207L.Reg, volatile.LoadUint32(&o.LUT207L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT207L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT207L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT207H: Graphic MMU LUT entry 207 high
func (o *GFXMMU_Type) SetLUT207H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT207H.Reg, volatile.LoadUint32(&o.LUT207H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT207H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT207H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT208L: Graphic MMU LUT entry 208 low
func (o *GFXMMU_Type) SetLUT208L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT208L.Reg, volatile.LoadUint32(&o.LUT208L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT208L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT208L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT208L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT208L.Reg, volatile.LoadUint32(&o.LUT208L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT208L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT208L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT208L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT208L.Reg, volatile.LoadUint32(&o.LUT208L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT208L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT208L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT208H: Graphic MMU LUT entry 208 high
func (o *GFXMMU_Type) SetLUT208H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT208H.Reg, volatile.LoadUint32(&o.LUT208H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT208H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT208H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT209L: Graphic MMU LUT entry 209 low
func (o *GFXMMU_Type) SetLUT209L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT209L.Reg, volatile.LoadUint32(&o.LUT209L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT209L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT209L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT209L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT209L.Reg, volatile.LoadUint32(&o.LUT209L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT209L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT209L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT209L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT209L.Reg, volatile.LoadUint32(&o.LUT209L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT209L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT209L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT209H: Graphic MMU LUT entry 209 high
func (o *GFXMMU_Type) SetLUT209H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT209H.Reg, volatile.LoadUint32(&o.LUT209H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT209H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT209H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT210L: Graphic MMU LUT entry 210 low
func (o *GFXMMU_Type) SetLUT210L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT210L.Reg, volatile.LoadUint32(&o.LUT210L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT210L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT210L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT210L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT210L.Reg, volatile.LoadUint32(&o.LUT210L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT210L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT210L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT210L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT210L.Reg, volatile.LoadUint32(&o.LUT210L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT210L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT210L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT210H: Graphic MMU LUT entry 210 high
func (o *GFXMMU_Type) SetLUT210H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT210H.Reg, volatile.LoadUint32(&o.LUT210H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT210H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT210H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT211L: Graphic MMU LUT entry 211 low
func (o *GFXMMU_Type) SetLUT211L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT211L.Reg, volatile.LoadUint32(&o.LUT211L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT211L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT211L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT211L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT211L.Reg, volatile.LoadUint32(&o.LUT211L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT211L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT211L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT211L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT211L.Reg, volatile.LoadUint32(&o.LUT211L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT211L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT211L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT211H: Graphic MMU LUT entry 211 high
func (o *GFXMMU_Type) SetLUT211H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT211H.Reg, volatile.LoadUint32(&o.LUT211H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT211H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT211H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT212L: Graphic MMU LUT entry 212 low
func (o *GFXMMU_Type) SetLUT212L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT212L.Reg, volatile.LoadUint32(&o.LUT212L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT212L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT212L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT212L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT212L.Reg, volatile.LoadUint32(&o.LUT212L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT212L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT212L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT212L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT212L.Reg, volatile.LoadUint32(&o.LUT212L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT212L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT212L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT212H: Graphic MMU LUT entry 212 high
func (o *GFXMMU_Type) SetLUT212H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT212H.Reg, volatile.LoadUint32(&o.LUT212H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT212H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT212H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT213L: Graphic MMU LUT entry 213 low
func (o *GFXMMU_Type) SetLUT213L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT213L.Reg, volatile.LoadUint32(&o.LUT213L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT213L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT213L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT213L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT213L.Reg, volatile.LoadUint32(&o.LUT213L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT213L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT213L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT213L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT213L.Reg, volatile.LoadUint32(&o.LUT213L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT213L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT213L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT213H: Graphic MMU LUT entry 213 high
func (o *GFXMMU_Type) SetLUT213H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT213H.Reg, volatile.LoadUint32(&o.LUT213H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT213H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT213H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT214L: Graphic MMU LUT entry 214 low
func (o *GFXMMU_Type) SetLUT214L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT214L.Reg, volatile.LoadUint32(&o.LUT214L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT214L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT214L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT214L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT214L.Reg, volatile.LoadUint32(&o.LUT214L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT214L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT214L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT214L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT214L.Reg, volatile.LoadUint32(&o.LUT214L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT214L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT214L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT214H: Graphic MMU LUT entry 214 high
func (o *GFXMMU_Type) SetLUT214H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT214H.Reg, volatile.LoadUint32(&o.LUT214H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT214H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT214H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT215L: Graphic MMU LUT entry 215 low
func (o *GFXMMU_Type) SetLUT215L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT215L.Reg, volatile.LoadUint32(&o.LUT215L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT215L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT215L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT215L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT215L.Reg, volatile.LoadUint32(&o.LUT215L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT215L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT215L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT215L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT215L.Reg, volatile.LoadUint32(&o.LUT215L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT215L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT215L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT215H: Graphic MMU LUT entry 215 high
func (o *GFXMMU_Type) SetLUT215H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT215H.Reg, volatile.LoadUint32(&o.LUT215H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT215H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT215H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT216L: Graphic MMU LUT entry 216 low
func (o *GFXMMU_Type) SetLUT216L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT216L.Reg, volatile.LoadUint32(&o.LUT216L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT216L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT216L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT216L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT216L.Reg, volatile.LoadUint32(&o.LUT216L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT216L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT216L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT216L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT216L.Reg, volatile.LoadUint32(&o.LUT216L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT216L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT216L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT216H: Graphic MMU LUT entry 216 high
func (o *GFXMMU_Type) SetLUT216H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT216H.Reg, volatile.LoadUint32(&o.LUT216H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT216H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT216H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT217L: Graphic MMU LUT entry 217 low
func (o *GFXMMU_Type) SetLUT217L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT217L.Reg, volatile.LoadUint32(&o.LUT217L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT217L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT217L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT217L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT217L.Reg, volatile.LoadUint32(&o.LUT217L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT217L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT217L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT217L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT217L.Reg, volatile.LoadUint32(&o.LUT217L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT217L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT217L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT217H: Graphic MMU LUT entry 217 high
func (o *GFXMMU_Type) SetLUT217H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT217H.Reg, volatile.LoadUint32(&o.LUT217H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT217H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT217H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT218L: Graphic MMU LUT entry 218 low
func (o *GFXMMU_Type) SetLUT218L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT218L.Reg, volatile.LoadUint32(&o.LUT218L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT218L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT218L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT218L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT218L.Reg, volatile.LoadUint32(&o.LUT218L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT218L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT218L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT218L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT218L.Reg, volatile.LoadUint32(&o.LUT218L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT218L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT218L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT218H: Graphic MMU LUT entry 218 high
func (o *GFXMMU_Type) SetLUT218H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT218H.Reg, volatile.LoadUint32(&o.LUT218H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT218H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT218H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT219L: Graphic MMU LUT entry 219 low
func (o *GFXMMU_Type) SetLUT219L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT219L.Reg, volatile.LoadUint32(&o.LUT219L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT219L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT219L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT219L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT219L.Reg, volatile.LoadUint32(&o.LUT219L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT219L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT219L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT219L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT219L.Reg, volatile.LoadUint32(&o.LUT219L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT219L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT219L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT219H: Graphic MMU LUT entry 219 high
func (o *GFXMMU_Type) SetLUT219H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT219H.Reg, volatile.LoadUint32(&o.LUT219H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT219H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT219H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT220L: Graphic MMU LUT entry 220 low
func (o *GFXMMU_Type) SetLUT220L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT220L.Reg, volatile.LoadUint32(&o.LUT220L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT220L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT220L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT220L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT220L.Reg, volatile.LoadUint32(&o.LUT220L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT220L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT220L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT220L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT220L.Reg, volatile.LoadUint32(&o.LUT220L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT220L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT220L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT220H: Graphic MMU LUT entry 220 high
func (o *GFXMMU_Type) SetLUT220H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT220H.Reg, volatile.LoadUint32(&o.LUT220H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT220H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT220H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT221L: Graphic MMU LUT entry 221 low
func (o *GFXMMU_Type) SetLUT221L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT221L.Reg, volatile.LoadUint32(&o.LUT221L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT221L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT221L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT221L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT221L.Reg, volatile.LoadUint32(&o.LUT221L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT221L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT221L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT221L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT221L.Reg, volatile.LoadUint32(&o.LUT221L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT221L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT221L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT221H: Graphic MMU LUT entry 221 high
func (o *GFXMMU_Type) SetLUT221H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT221H.Reg, volatile.LoadUint32(&o.LUT221H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT221H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT221H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT222L: Graphic MMU LUT entry 222 low
func (o *GFXMMU_Type) SetLUT222L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT222L.Reg, volatile.LoadUint32(&o.LUT222L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT222L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT222L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT222L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT222L.Reg, volatile.LoadUint32(&o.LUT222L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT222L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT222L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT222L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT222L.Reg, volatile.LoadUint32(&o.LUT222L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT222L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT222L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT222H: Graphic MMU LUT entry 222 high
func (o *GFXMMU_Type) SetLUT222H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT222H.Reg, volatile.LoadUint32(&o.LUT222H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT222H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT222H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT223L: Graphic MMU LUT entry 223 low
func (o *GFXMMU_Type) SetLUT223L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT223L.Reg, volatile.LoadUint32(&o.LUT223L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT223L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT223L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT223L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT223L.Reg, volatile.LoadUint32(&o.LUT223L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT223L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT223L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT223L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT223L.Reg, volatile.LoadUint32(&o.LUT223L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT223L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT223L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT223H: Graphic MMU LUT entry 223 high
func (o *GFXMMU_Type) SetLUT223H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT223H.Reg, volatile.LoadUint32(&o.LUT223H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT223H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT223H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT224L: Graphic MMU LUT entry 224 low
func (o *GFXMMU_Type) SetLUT224L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT224L.Reg, volatile.LoadUint32(&o.LUT224L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT224L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT224L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT224L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT224L.Reg, volatile.LoadUint32(&o.LUT224L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT224L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT224L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT224L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT224L.Reg, volatile.LoadUint32(&o.LUT224L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT224L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT224L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT224H: Graphic MMU LUT entry 224 high
func (o *GFXMMU_Type) SetLUT224H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT224H.Reg, volatile.LoadUint32(&o.LUT224H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT224H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT224H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT225L: Graphic MMU LUT entry 225 low
func (o *GFXMMU_Type) SetLUT225L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT225L.Reg, volatile.LoadUint32(&o.LUT225L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT225L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT225L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT225L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT225L.Reg, volatile.LoadUint32(&o.LUT225L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT225L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT225L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT225L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT225L.Reg, volatile.LoadUint32(&o.LUT225L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT225L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT225L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT225H: Graphic MMU LUT entry 225 high
func (o *GFXMMU_Type) SetLUT225H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT225H.Reg, volatile.LoadUint32(&o.LUT225H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT225H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT225H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT226L: Graphic MMU LUT entry 226 low
func (o *GFXMMU_Type) SetLUT226L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT226L.Reg, volatile.LoadUint32(&o.LUT226L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT226L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT226L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT226L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT226L.Reg, volatile.LoadUint32(&o.LUT226L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT226L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT226L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT226L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT226L.Reg, volatile.LoadUint32(&o.LUT226L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT226L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT226L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT226H: Graphic MMU LUT entry 226 high
func (o *GFXMMU_Type) SetLUT226H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT226H.Reg, volatile.LoadUint32(&o.LUT226H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT226H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT226H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT227L: Graphic MMU LUT entry 227 low
func (o *GFXMMU_Type) SetLUT227L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT227L.Reg, volatile.LoadUint32(&o.LUT227L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT227L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT227L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT227L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT227L.Reg, volatile.LoadUint32(&o.LUT227L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT227L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT227L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT227L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT227L.Reg, volatile.LoadUint32(&o.LUT227L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT227L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT227L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT227H: Graphic MMU LUT entry 227 high
func (o *GFXMMU_Type) SetLUT227H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT227H.Reg, volatile.LoadUint32(&o.LUT227H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT227H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT227H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT228L: Graphic MMU LUT entry 228 low
func (o *GFXMMU_Type) SetLUT228L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT228L.Reg, volatile.LoadUint32(&o.LUT228L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT228L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT228L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT228L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT228L.Reg, volatile.LoadUint32(&o.LUT228L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT228L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT228L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT228L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT228L.Reg, volatile.LoadUint32(&o.LUT228L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT228L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT228L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT228H: Graphic MMU LUT entry 228 high
func (o *GFXMMU_Type) SetLUT228H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT228H.Reg, volatile.LoadUint32(&o.LUT228H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT228H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT228H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT229L: Graphic MMU LUT entry 229 low
func (o *GFXMMU_Type) SetLUT229L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT229L.Reg, volatile.LoadUint32(&o.LUT229L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT229L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT229L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT229L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT229L.Reg, volatile.LoadUint32(&o.LUT229L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT229L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT229L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT229L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT229L.Reg, volatile.LoadUint32(&o.LUT229L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT229L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT229L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT229H: Graphic MMU LUT entry 229 high
func (o *GFXMMU_Type) SetLUT229H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT229H.Reg, volatile.LoadUint32(&o.LUT229H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT229H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT229H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT230L: Graphic MMU LUT entry 230 low
func (o *GFXMMU_Type) SetLUT230L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT230L.Reg, volatile.LoadUint32(&o.LUT230L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT230L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT230L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT230L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT230L.Reg, volatile.LoadUint32(&o.LUT230L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT230L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT230L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT230L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT230L.Reg, volatile.LoadUint32(&o.LUT230L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT230L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT230L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT230H: Graphic MMU LUT entry 230 high
func (o *GFXMMU_Type) SetLUT230H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT230H.Reg, volatile.LoadUint32(&o.LUT230H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT230H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT230H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT231L: Graphic MMU LUT entry 231 low
func (o *GFXMMU_Type) SetLUT231L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT231L.Reg, volatile.LoadUint32(&o.LUT231L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT231L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT231L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT231L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT231L.Reg, volatile.LoadUint32(&o.LUT231L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT231L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT231L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT231L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT231L.Reg, volatile.LoadUint32(&o.LUT231L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT231L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT231L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT231H: Graphic MMU LUT entry 231 high
func (o *GFXMMU_Type) SetLUT231H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT231H.Reg, volatile.LoadUint32(&o.LUT231H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT231H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT231H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT232L: Graphic MMU LUT entry 232 low
func (o *GFXMMU_Type) SetLUT232L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT232L.Reg, volatile.LoadUint32(&o.LUT232L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT232L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT232L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT232L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT232L.Reg, volatile.LoadUint32(&o.LUT232L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT232L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT232L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT232L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT232L.Reg, volatile.LoadUint32(&o.LUT232L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT232L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT232L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT232H: Graphic MMU LUT entry 232 high
func (o *GFXMMU_Type) SetLUT232H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT232H.Reg, volatile.LoadUint32(&o.LUT232H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT232H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT232H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT233L: Graphic MMU LUT entry 233 low
func (o *GFXMMU_Type) SetLUT233L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT233L.Reg, volatile.LoadUint32(&o.LUT233L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT233L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT233L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT233L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT233L.Reg, volatile.LoadUint32(&o.LUT233L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT233L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT233L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT233L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT233L.Reg, volatile.LoadUint32(&o.LUT233L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT233L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT233L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT233H: Graphic MMU LUT entry 233 high
func (o *GFXMMU_Type) SetLUT233H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT233H.Reg, volatile.LoadUint32(&o.LUT233H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT233H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT233H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT234L: Graphic MMU LUT entry 234 low
func (o *GFXMMU_Type) SetLUT234L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT234L.Reg, volatile.LoadUint32(&o.LUT234L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT234L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT234L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT234L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT234L.Reg, volatile.LoadUint32(&o.LUT234L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT234L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT234L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT234L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT234L.Reg, volatile.LoadUint32(&o.LUT234L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT234L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT234L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT234H: Graphic MMU LUT entry 234 high
func (o *GFXMMU_Type) SetLUT234H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT234H.Reg, volatile.LoadUint32(&o.LUT234H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT234H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT234H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT235L: Graphic MMU LUT entry 235 low
func (o *GFXMMU_Type) SetLUT235L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT235L.Reg, volatile.LoadUint32(&o.LUT235L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT235L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT235L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT235L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT235L.Reg, volatile.LoadUint32(&o.LUT235L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT235L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT235L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT235L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT235L.Reg, volatile.LoadUint32(&o.LUT235L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT235L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT235L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT235H: Graphic MMU LUT entry 235 high
func (o *GFXMMU_Type) SetLUT235H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT235H.Reg, volatile.LoadUint32(&o.LUT235H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT235H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT235H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT236L: Graphic MMU LUT entry 236 low
func (o *GFXMMU_Type) SetLUT236L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT236L.Reg, volatile.LoadUint32(&o.LUT236L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT236L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT236L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT236L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT236L.Reg, volatile.LoadUint32(&o.LUT236L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT236L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT236L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT236L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT236L.Reg, volatile.LoadUint32(&o.LUT236L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT236L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT236L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT236H: Graphic MMU LUT entry 236 high
func (o *GFXMMU_Type) SetLUT236H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT236H.Reg, volatile.LoadUint32(&o.LUT236H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT236H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT236H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT237L: Graphic MMU LUT entry 237 low
func (o *GFXMMU_Type) SetLUT237L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT237L.Reg, volatile.LoadUint32(&o.LUT237L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT237L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT237L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT237L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT237L.Reg, volatile.LoadUint32(&o.LUT237L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT237L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT237L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT237L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT237L.Reg, volatile.LoadUint32(&o.LUT237L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT237L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT237L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT237H: Graphic MMU LUT entry 237 high
func (o *GFXMMU_Type) SetLUT237H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT237H.Reg, volatile.LoadUint32(&o.LUT237H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT237H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT237H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT238L: Graphic MMU LUT entry 238 low
func (o *GFXMMU_Type) SetLUT238L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT238L.Reg, volatile.LoadUint32(&o.LUT238L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT238L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT238L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT238L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT238L.Reg, volatile.LoadUint32(&o.LUT238L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT238L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT238L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT238L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT238L.Reg, volatile.LoadUint32(&o.LUT238L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT238L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT238L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT238H: Graphic MMU LUT entry 238 high
func (o *GFXMMU_Type) SetLUT238H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT238H.Reg, volatile.LoadUint32(&o.LUT238H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT238H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT238H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT239L: Graphic MMU LUT entry 239 low
func (o *GFXMMU_Type) SetLUT239L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT239L.Reg, volatile.LoadUint32(&o.LUT239L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT239L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT239L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT239L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT239L.Reg, volatile.LoadUint32(&o.LUT239L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT239L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT239L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT239L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT239L.Reg, volatile.LoadUint32(&o.LUT239L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT239L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT239L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT239H: Graphic MMU LUT entry 239 high
func (o *GFXMMU_Type) SetLUT239H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT239H.Reg, volatile.LoadUint32(&o.LUT239H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT239H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT239H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT240L: Graphic MMU LUT entry 240 low
func (o *GFXMMU_Type) SetLUT240L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT240L.Reg, volatile.LoadUint32(&o.LUT240L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT240L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT240L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT240L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT240L.Reg, volatile.LoadUint32(&o.LUT240L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT240L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT240L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT240L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT240L.Reg, volatile.LoadUint32(&o.LUT240L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT240L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT240L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT240H: Graphic MMU LUT entry 240 high
func (o *GFXMMU_Type) SetLUT240H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT240H.Reg, volatile.LoadUint32(&o.LUT240H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT240H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT240H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT241L: Graphic MMU LUT entry 241 low
func (o *GFXMMU_Type) SetLUT241L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT241L.Reg, volatile.LoadUint32(&o.LUT241L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT241L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT241L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT241L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT241L.Reg, volatile.LoadUint32(&o.LUT241L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT241L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT241L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT241L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT241L.Reg, volatile.LoadUint32(&o.LUT241L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT241L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT241L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT241H: Graphic MMU LUT entry 241 high
func (o *GFXMMU_Type) SetLUT241H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT241H.Reg, volatile.LoadUint32(&o.LUT241H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT241H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT241H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT242L: Graphic MMU LUT entry 242 low
func (o *GFXMMU_Type) SetLUT242L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT242L.Reg, volatile.LoadUint32(&o.LUT242L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT242L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT242L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT242L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT242L.Reg, volatile.LoadUint32(&o.LUT242L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT242L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT242L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT242L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT242L.Reg, volatile.LoadUint32(&o.LUT242L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT242L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT242L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT242H: Graphic MMU LUT entry 242 high
func (o *GFXMMU_Type) SetLUT242H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT242H.Reg, volatile.LoadUint32(&o.LUT242H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT242H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT242H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT243L: Graphic MMU LUT entry 243 low
func (o *GFXMMU_Type) SetLUT243L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT243L.Reg, volatile.LoadUint32(&o.LUT243L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT243L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT243L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT243L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT243L.Reg, volatile.LoadUint32(&o.LUT243L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT243L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT243L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT243L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT243L.Reg, volatile.LoadUint32(&o.LUT243L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT243L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT243L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT243H: Graphic MMU LUT entry 243 high
func (o *GFXMMU_Type) SetLUT243H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT243H.Reg, volatile.LoadUint32(&o.LUT243H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT243H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT243H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT244L: Graphic MMU LUT entry 244 low
func (o *GFXMMU_Type) SetLUT244L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT244L.Reg, volatile.LoadUint32(&o.LUT244L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT244L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT244L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT244L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT244L.Reg, volatile.LoadUint32(&o.LUT244L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT244L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT244L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT244L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT244L.Reg, volatile.LoadUint32(&o.LUT244L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT244L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT244L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT244H: Graphic MMU LUT entry 244 high
func (o *GFXMMU_Type) SetLUT244H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT244H.Reg, volatile.LoadUint32(&o.LUT244H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT244H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT244H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT245L: Graphic MMU LUT entry 245 low
func (o *GFXMMU_Type) SetLUT245L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT245L.Reg, volatile.LoadUint32(&o.LUT245L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT245L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT245L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT245L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT245L.Reg, volatile.LoadUint32(&o.LUT245L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT245L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT245L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT245L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT245L.Reg, volatile.LoadUint32(&o.LUT245L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT245L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT245L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT245H: Graphic MMU LUT entry 245 high
func (o *GFXMMU_Type) SetLUT245H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT245H.Reg, volatile.LoadUint32(&o.LUT245H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT245H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT245H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT246L: Graphic MMU LUT entry 246 low
func (o *GFXMMU_Type) SetLUT246L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT246L.Reg, volatile.LoadUint32(&o.LUT246L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT246L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT246L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT246L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT246L.Reg, volatile.LoadUint32(&o.LUT246L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT246L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT246L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT246L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT246L.Reg, volatile.LoadUint32(&o.LUT246L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT246L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT246L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT246H: Graphic MMU LUT entry 246 high
func (o *GFXMMU_Type) SetLUT246H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT246H.Reg, volatile.LoadUint32(&o.LUT246H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT246H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT246H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT247L: Graphic MMU LUT entry 247 low
func (o *GFXMMU_Type) SetLUT247L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT247L.Reg, volatile.LoadUint32(&o.LUT247L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT247L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT247L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT247L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT247L.Reg, volatile.LoadUint32(&o.LUT247L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT247L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT247L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT247L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT247L.Reg, volatile.LoadUint32(&o.LUT247L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT247L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT247L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT247H: Graphic MMU LUT entry 247 high
func (o *GFXMMU_Type) SetLUT247H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT247H.Reg, volatile.LoadUint32(&o.LUT247H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT247H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT247H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT248L: Graphic MMU LUT entry 248 low
func (o *GFXMMU_Type) SetLUT248L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT248L.Reg, volatile.LoadUint32(&o.LUT248L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT248L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT248L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT248L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT248L.Reg, volatile.LoadUint32(&o.LUT248L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT248L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT248L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT248L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT248L.Reg, volatile.LoadUint32(&o.LUT248L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT248L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT248L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT248H: Graphic MMU LUT entry 248 high
func (o *GFXMMU_Type) SetLUT248H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT248H.Reg, volatile.LoadUint32(&o.LUT248H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT248H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT248H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT249L: Graphic MMU LUT entry 249 low
func (o *GFXMMU_Type) SetLUT249L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT249L.Reg, volatile.LoadUint32(&o.LUT249L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT249L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT249L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT249L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT249L.Reg, volatile.LoadUint32(&o.LUT249L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT249L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT249L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT249L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT249L.Reg, volatile.LoadUint32(&o.LUT249L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT249L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT249L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT249H: Graphic MMU LUT entry 249 high
func (o *GFXMMU_Type) SetLUT249H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT249H.Reg, volatile.LoadUint32(&o.LUT249H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT249H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT249H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT250L: Graphic MMU LUT entry 250 low
func (o *GFXMMU_Type) SetLUT250L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT250L.Reg, volatile.LoadUint32(&o.LUT250L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT250L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT250L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT250L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT250L.Reg, volatile.LoadUint32(&o.LUT250L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT250L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT250L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT250L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT250L.Reg, volatile.LoadUint32(&o.LUT250L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT250L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT250L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT250H: Graphic MMU LUT entry 250 high
func (o *GFXMMU_Type) SetLUT250H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT250H.Reg, volatile.LoadUint32(&o.LUT250H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT250H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT250H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT251L: Graphic MMU LUT entry 251 low
func (o *GFXMMU_Type) SetLUT251L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT251L.Reg, volatile.LoadUint32(&o.LUT251L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT251L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT251L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT251L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT251L.Reg, volatile.LoadUint32(&o.LUT251L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT251L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT251L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT251L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT251L.Reg, volatile.LoadUint32(&o.LUT251L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT251L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT251L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT251H: Graphic MMU LUT entry 251 high
func (o *GFXMMU_Type) SetLUT251H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT251H.Reg, volatile.LoadUint32(&o.LUT251H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT251H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT251H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT252L: Graphic MMU LUT entry 252 low
func (o *GFXMMU_Type) SetLUT252L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT252L.Reg, volatile.LoadUint32(&o.LUT252L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT252L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT252L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT252L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT252L.Reg, volatile.LoadUint32(&o.LUT252L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT252L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT252L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT252L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT252L.Reg, volatile.LoadUint32(&o.LUT252L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT252L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT252L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT252H: Graphic MMU LUT entry 252 high
func (o *GFXMMU_Type) SetLUT252H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT252H.Reg, volatile.LoadUint32(&o.LUT252H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT252H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT252H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT253L: Graphic MMU LUT entry 253 low
func (o *GFXMMU_Type) SetLUT253L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT253L.Reg, volatile.LoadUint32(&o.LUT253L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT253L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT253L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT253L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT253L.Reg, volatile.LoadUint32(&o.LUT253L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT253L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT253L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT253L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT253L.Reg, volatile.LoadUint32(&o.LUT253L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT253L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT253L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT253H: Graphic MMU LUT entry 253 high
func (o *GFXMMU_Type) SetLUT253H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT253H.Reg, volatile.LoadUint32(&o.LUT253H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT253H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT253H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT254L: Graphic MMU LUT entry 254 low
func (o *GFXMMU_Type) SetLUT254L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT254L.Reg, volatile.LoadUint32(&o.LUT254L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT254L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT254L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT254L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT254L.Reg, volatile.LoadUint32(&o.LUT254L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT254L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT254L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT254L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT254L.Reg, volatile.LoadUint32(&o.LUT254L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT254L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT254L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT254H: Graphic MMU LUT entry 254 high
func (o *GFXMMU_Type) SetLUT254H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT254H.Reg, volatile.LoadUint32(&o.LUT254H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT254H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT254H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT255L: Graphic MMU LUT entry 255 low
func (o *GFXMMU_Type) SetLUT255L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT255L.Reg, volatile.LoadUint32(&o.LUT255L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT255L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT255L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT255L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT255L.Reg, volatile.LoadUint32(&o.LUT255L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT255L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT255L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT255L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT255L.Reg, volatile.LoadUint32(&o.LUT255L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT255L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT255L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT255H: Graphic MMU LUT entry 255 high
func (o *GFXMMU_Type) SetLUT255H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT255H.Reg, volatile.LoadUint32(&o.LUT255H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT255H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT255H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT256L: Graphic MMU LUT entry 256 low
func (o *GFXMMU_Type) SetLUT256L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT256L.Reg, volatile.LoadUint32(&o.LUT256L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT256L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT256L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT256L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT256L.Reg, volatile.LoadUint32(&o.LUT256L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT256L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT256L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT256L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT256L.Reg, volatile.LoadUint32(&o.LUT256L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT256L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT256L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT256H: Graphic MMU LUT entry 256 high
func (o *GFXMMU_Type) SetLUT256H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT256H.Reg, volatile.LoadUint32(&o.LUT256H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT256H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT256H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT257L: Graphic MMU LUT entry 257 low
func (o *GFXMMU_Type) SetLUT257L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT257L.Reg, volatile.LoadUint32(&o.LUT257L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT257L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT257L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT257L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT257L.Reg, volatile.LoadUint32(&o.LUT257L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT257L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT257L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT257L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT257L.Reg, volatile.LoadUint32(&o.LUT257L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT257L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT257L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT257H: Graphic MMU LUT entry 257 high
func (o *GFXMMU_Type) SetLUT257H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT257H.Reg, volatile.LoadUint32(&o.LUT257H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT257H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT257H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT258L: Graphic MMU LUT entry 258 low
func (o *GFXMMU_Type) SetLUT258L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT258L.Reg, volatile.LoadUint32(&o.LUT258L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT258L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT258L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT258L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT258L.Reg, volatile.LoadUint32(&o.LUT258L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT258L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT258L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT258L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT258L.Reg, volatile.LoadUint32(&o.LUT258L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT258L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT258L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT258H: Graphic MMU LUT entry 258 high
func (o *GFXMMU_Type) SetLUT258H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT258H.Reg, volatile.LoadUint32(&o.LUT258H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT258H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT258H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT259L: Graphic MMU LUT entry 259 low
func (o *GFXMMU_Type) SetLUT259L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT259L.Reg, volatile.LoadUint32(&o.LUT259L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT259L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT259L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT259L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT259L.Reg, volatile.LoadUint32(&o.LUT259L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT259L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT259L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT259L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT259L.Reg, volatile.LoadUint32(&o.LUT259L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT259L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT259L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT259H: Graphic MMU LUT entry 259 high
func (o *GFXMMU_Type) SetLUT259H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT259H.Reg, volatile.LoadUint32(&o.LUT259H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT259H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT259H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT260L: Graphic MMU LUT entry 260 low
func (o *GFXMMU_Type) SetLUT260L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT260L.Reg, volatile.LoadUint32(&o.LUT260L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT260L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT260L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT260L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT260L.Reg, volatile.LoadUint32(&o.LUT260L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT260L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT260L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT260L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT260L.Reg, volatile.LoadUint32(&o.LUT260L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT260L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT260L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT260H: Graphic MMU LUT entry 260 high
func (o *GFXMMU_Type) SetLUT260H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT260H.Reg, volatile.LoadUint32(&o.LUT260H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT260H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT260H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT261L: Graphic MMU LUT entry 261 low
func (o *GFXMMU_Type) SetLUT261L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT261L.Reg, volatile.LoadUint32(&o.LUT261L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT261L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT261L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT261L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT261L.Reg, volatile.LoadUint32(&o.LUT261L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT261L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT261L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT261L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT261L.Reg, volatile.LoadUint32(&o.LUT261L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT261L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT261L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT261H: Graphic MMU LUT entry 261 high
func (o *GFXMMU_Type) SetLUT261H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT261H.Reg, volatile.LoadUint32(&o.LUT261H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT261H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT261H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT262L: Graphic MMU LUT entry 262 low
func (o *GFXMMU_Type) SetLUT262L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT262L.Reg, volatile.LoadUint32(&o.LUT262L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT262L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT262L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT262L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT262L.Reg, volatile.LoadUint32(&o.LUT262L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT262L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT262L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT262L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT262L.Reg, volatile.LoadUint32(&o.LUT262L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT262L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT262L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT262H: Graphic MMU LUT entry 262 high
func (o *GFXMMU_Type) SetLUT262H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT262H.Reg, volatile.LoadUint32(&o.LUT262H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT262H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT262H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT263L: Graphic MMU LUT entry 263 low
func (o *GFXMMU_Type) SetLUT263L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT263L.Reg, volatile.LoadUint32(&o.LUT263L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT263L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT263L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT263L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT263L.Reg, volatile.LoadUint32(&o.LUT263L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT263L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT263L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT263L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT263L.Reg, volatile.LoadUint32(&o.LUT263L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT263L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT263L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT263H: Graphic MMU LUT entry 263 high
func (o *GFXMMU_Type) SetLUT263H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT263H.Reg, volatile.LoadUint32(&o.LUT263H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT263H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT263H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT264L: Graphic MMU LUT entry 264 low
func (o *GFXMMU_Type) SetLUT264L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT264L.Reg, volatile.LoadUint32(&o.LUT264L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT264L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT264L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT264L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT264L.Reg, volatile.LoadUint32(&o.LUT264L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT264L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT264L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT264L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT264L.Reg, volatile.LoadUint32(&o.LUT264L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT264L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT264L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT264H: Graphic MMU LUT entry 264 high
func (o *GFXMMU_Type) SetLUT264H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT264H.Reg, volatile.LoadUint32(&o.LUT264H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT264H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT264H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT265L: Graphic MMU LUT entry 265 low
func (o *GFXMMU_Type) SetLUT265L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT265L.Reg, volatile.LoadUint32(&o.LUT265L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT265L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT265L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT265L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT265L.Reg, volatile.LoadUint32(&o.LUT265L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT265L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT265L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT265L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT265L.Reg, volatile.LoadUint32(&o.LUT265L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT265L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT265L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT265H: Graphic MMU LUT entry 265 high
func (o *GFXMMU_Type) SetLUT265H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT265H.Reg, volatile.LoadUint32(&o.LUT265H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT265H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT265H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT266L: Graphic MMU LUT entry 266 low
func (o *GFXMMU_Type) SetLUT266L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT266L.Reg, volatile.LoadUint32(&o.LUT266L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT266L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT266L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT266L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT266L.Reg, volatile.LoadUint32(&o.LUT266L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT266L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT266L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT266L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT266L.Reg, volatile.LoadUint32(&o.LUT266L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT266L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT266L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT266H: Graphic MMU LUT entry 266 high
func (o *GFXMMU_Type) SetLUT266H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT266H.Reg, volatile.LoadUint32(&o.LUT266H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT266H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT266H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT267L: Graphic MMU LUT entry 267 low
func (o *GFXMMU_Type) SetLUT267L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT267L.Reg, volatile.LoadUint32(&o.LUT267L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT267L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT267L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT267L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT267L.Reg, volatile.LoadUint32(&o.LUT267L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT267L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT267L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT267L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT267L.Reg, volatile.LoadUint32(&o.LUT267L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT267L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT267L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT267H: Graphic MMU LUT entry 267 high
func (o *GFXMMU_Type) SetLUT267H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT267H.Reg, volatile.LoadUint32(&o.LUT267H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT267H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT267H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT268L: Graphic MMU LUT entry 268 low
func (o *GFXMMU_Type) SetLUT268L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT268L.Reg, volatile.LoadUint32(&o.LUT268L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT268L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT268L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT268L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT268L.Reg, volatile.LoadUint32(&o.LUT268L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT268L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT268L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT268L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT268L.Reg, volatile.LoadUint32(&o.LUT268L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT268L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT268L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT268H: Graphic MMU LUT entry 268 high
func (o *GFXMMU_Type) SetLUT268H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT268H.Reg, volatile.LoadUint32(&o.LUT268H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT268H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT268H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT269L: Graphic MMU LUT entry 269 low
func (o *GFXMMU_Type) SetLUT269L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT269L.Reg, volatile.LoadUint32(&o.LUT269L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT269L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT269L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT269L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT269L.Reg, volatile.LoadUint32(&o.LUT269L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT269L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT269L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT269L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT269L.Reg, volatile.LoadUint32(&o.LUT269L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT269L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT269L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT269H: Graphic MMU LUT entry 269 high
func (o *GFXMMU_Type) SetLUT269H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT269H.Reg, volatile.LoadUint32(&o.LUT269H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT269H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT269H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT270L: Graphic MMU LUT entry 270 low
func (o *GFXMMU_Type) SetLUT270L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT270L.Reg, volatile.LoadUint32(&o.LUT270L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT270L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT270L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT270L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT270L.Reg, volatile.LoadUint32(&o.LUT270L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT270L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT270L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT270L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT270L.Reg, volatile.LoadUint32(&o.LUT270L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT270L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT270L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT270H: Graphic MMU LUT entry 270 high
func (o *GFXMMU_Type) SetLUT270H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT270H.Reg, volatile.LoadUint32(&o.LUT270H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT270H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT270H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT271L: Graphic MMU LUT entry 271 low
func (o *GFXMMU_Type) SetLUT271L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT271L.Reg, volatile.LoadUint32(&o.LUT271L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT271L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT271L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT271L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT271L.Reg, volatile.LoadUint32(&o.LUT271L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT271L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT271L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT271L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT271L.Reg, volatile.LoadUint32(&o.LUT271L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT271L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT271L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT271H: Graphic MMU LUT entry 271 high
func (o *GFXMMU_Type) SetLUT271H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT271H.Reg, volatile.LoadUint32(&o.LUT271H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT271H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT271H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT272L: Graphic MMU LUT entry 272 low
func (o *GFXMMU_Type) SetLUT272L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT272L.Reg, volatile.LoadUint32(&o.LUT272L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT272L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT272L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT272L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT272L.Reg, volatile.LoadUint32(&o.LUT272L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT272L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT272L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT272L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT272L.Reg, volatile.LoadUint32(&o.LUT272L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT272L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT272L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT272H: Graphic MMU LUT entry 272 high
func (o *GFXMMU_Type) SetLUT272H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT272H.Reg, volatile.LoadUint32(&o.LUT272H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT272H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT272H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT273L: Graphic MMU LUT entry 273 low
func (o *GFXMMU_Type) SetLUT273L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT273L.Reg, volatile.LoadUint32(&o.LUT273L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT273L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT273L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT273L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT273L.Reg, volatile.LoadUint32(&o.LUT273L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT273L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT273L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT273L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT273L.Reg, volatile.LoadUint32(&o.LUT273L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT273L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT273L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT273H: Graphic MMU LUT entry 273 high
func (o *GFXMMU_Type) SetLUT273H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT273H.Reg, volatile.LoadUint32(&o.LUT273H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT273H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT273H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT274L: Graphic MMU LUT entry 274 low
func (o *GFXMMU_Type) SetLUT274L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT274L.Reg, volatile.LoadUint32(&o.LUT274L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT274L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT274L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT274L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT274L.Reg, volatile.LoadUint32(&o.LUT274L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT274L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT274L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT274L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT274L.Reg, volatile.LoadUint32(&o.LUT274L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT274L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT274L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT274H: Graphic MMU LUT entry 274 high
func (o *GFXMMU_Type) SetLUT274H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT274H.Reg, volatile.LoadUint32(&o.LUT274H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT274H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT274H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT275L: Graphic MMU LUT entry 275 low
func (o *GFXMMU_Type) SetLUT275L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT275L.Reg, volatile.LoadUint32(&o.LUT275L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT275L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT275L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT275L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT275L.Reg, volatile.LoadUint32(&o.LUT275L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT275L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT275L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT275L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT275L.Reg, volatile.LoadUint32(&o.LUT275L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT275L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT275L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT275H: Graphic MMU LUT entry 275 high
func (o *GFXMMU_Type) SetLUT275H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT275H.Reg, volatile.LoadUint32(&o.LUT275H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT275H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT275H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT276L: Graphic MMU LUT entry 276 low
func (o *GFXMMU_Type) SetLUT276L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT276L.Reg, volatile.LoadUint32(&o.LUT276L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT276L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT276L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT276L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT276L.Reg, volatile.LoadUint32(&o.LUT276L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT276L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT276L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT276L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT276L.Reg, volatile.LoadUint32(&o.LUT276L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT276L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT276L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT276H: Graphic MMU LUT entry 276 high
func (o *GFXMMU_Type) SetLUT276H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT276H.Reg, volatile.LoadUint32(&o.LUT276H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT276H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT276H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT277L: Graphic MMU LUT entry 277 low
func (o *GFXMMU_Type) SetLUT277L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT277L.Reg, volatile.LoadUint32(&o.LUT277L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT277L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT277L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT277L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT277L.Reg, volatile.LoadUint32(&o.LUT277L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT277L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT277L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT277L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT277L.Reg, volatile.LoadUint32(&o.LUT277L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT277L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT277L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT277H: Graphic MMU LUT entry 277 high
func (o *GFXMMU_Type) SetLUT277H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT277H.Reg, volatile.LoadUint32(&o.LUT277H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT277H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT277H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT278L: Graphic MMU LUT entry 278 low
func (o *GFXMMU_Type) SetLUT278L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT278L.Reg, volatile.LoadUint32(&o.LUT278L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT278L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT278L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT278L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT278L.Reg, volatile.LoadUint32(&o.LUT278L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT278L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT278L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT278L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT278L.Reg, volatile.LoadUint32(&o.LUT278L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT278L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT278L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT278H: Graphic MMU LUT entry 278 high
func (o *GFXMMU_Type) SetLUT278H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT278H.Reg, volatile.LoadUint32(&o.LUT278H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT278H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT278H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT279L: Graphic MMU LUT entry 279 low
func (o *GFXMMU_Type) SetLUT279L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT279L.Reg, volatile.LoadUint32(&o.LUT279L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT279L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT279L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT279L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT279L.Reg, volatile.LoadUint32(&o.LUT279L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT279L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT279L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT279L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT279L.Reg, volatile.LoadUint32(&o.LUT279L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT279L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT279L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT279H: Graphic MMU LUT entry 279 high
func (o *GFXMMU_Type) SetLUT279H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT279H.Reg, volatile.LoadUint32(&o.LUT279H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT279H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT279H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT280L: Graphic MMU LUT entry 280 low
func (o *GFXMMU_Type) SetLUT280L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT280L.Reg, volatile.LoadUint32(&o.LUT280L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT280L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT280L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT280L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT280L.Reg, volatile.LoadUint32(&o.LUT280L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT280L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT280L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT280L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT280L.Reg, volatile.LoadUint32(&o.LUT280L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT280L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT280L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT280H: Graphic MMU LUT entry 280 high
func (o *GFXMMU_Type) SetLUT280H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT280H.Reg, volatile.LoadUint32(&o.LUT280H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT280H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT280H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT281L: Graphic MMU LUT entry 281 low
func (o *GFXMMU_Type) SetLUT281L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT281L.Reg, volatile.LoadUint32(&o.LUT281L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT281L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT281L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT281L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT281L.Reg, volatile.LoadUint32(&o.LUT281L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT281L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT281L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT281L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT281L.Reg, volatile.LoadUint32(&o.LUT281L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT281L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT281L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT281H: Graphic MMU LUT entry 281 high
func (o *GFXMMU_Type) SetLUT281H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT281H.Reg, volatile.LoadUint32(&o.LUT281H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT281H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT281H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT282L: Graphic MMU LUT entry 282 low
func (o *GFXMMU_Type) SetLUT282L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT282L.Reg, volatile.LoadUint32(&o.LUT282L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT282L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT282L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT282L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT282L.Reg, volatile.LoadUint32(&o.LUT282L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT282L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT282L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT282L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT282L.Reg, volatile.LoadUint32(&o.LUT282L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT282L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT282L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT282H: Graphic MMU LUT entry 282 high
func (o *GFXMMU_Type) SetLUT282H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT282H.Reg, volatile.LoadUint32(&o.LUT282H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT282H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT282H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT283L: Graphic MMU LUT entry 283 low
func (o *GFXMMU_Type) SetLUT283L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT283L.Reg, volatile.LoadUint32(&o.LUT283L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT283L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT283L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT283L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT283L.Reg, volatile.LoadUint32(&o.LUT283L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT283L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT283L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT283L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT283L.Reg, volatile.LoadUint32(&o.LUT283L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT283L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT283L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT283H: Graphic MMU LUT entry 283 high
func (o *GFXMMU_Type) SetLUT283H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT283H.Reg, volatile.LoadUint32(&o.LUT283H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT283H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT283H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT284L: Graphic MMU LUT entry 284 low
func (o *GFXMMU_Type) SetLUT284L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT284L.Reg, volatile.LoadUint32(&o.LUT284L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT284L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT284L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT284L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT284L.Reg, volatile.LoadUint32(&o.LUT284L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT284L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT284L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT284L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT284L.Reg, volatile.LoadUint32(&o.LUT284L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT284L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT284L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT284H: Graphic MMU LUT entry 284 high
func (o *GFXMMU_Type) SetLUT284H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT284H.Reg, volatile.LoadUint32(&o.LUT284H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT284H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT284H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT285L: Graphic MMU LUT entry 285 low
func (o *GFXMMU_Type) SetLUT285L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT285L.Reg, volatile.LoadUint32(&o.LUT285L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT285L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT285L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT285L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT285L.Reg, volatile.LoadUint32(&o.LUT285L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT285L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT285L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT285L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT285L.Reg, volatile.LoadUint32(&o.LUT285L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT285L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT285L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT285H: Graphic MMU LUT entry 285 high
func (o *GFXMMU_Type) SetLUT285H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT285H.Reg, volatile.LoadUint32(&o.LUT285H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT285H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT285H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT286L: Graphic MMU LUT entry 286 low
func (o *GFXMMU_Type) SetLUT286L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT286L.Reg, volatile.LoadUint32(&o.LUT286L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT286L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT286L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT286L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT286L.Reg, volatile.LoadUint32(&o.LUT286L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT286L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT286L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT286L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT286L.Reg, volatile.LoadUint32(&o.LUT286L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT286L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT286L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT286H: Graphic MMU LUT entry 286 high
func (o *GFXMMU_Type) SetLUT286H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT286H.Reg, volatile.LoadUint32(&o.LUT286H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT286H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT286H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT287L: Graphic MMU LUT entry 287 low
func (o *GFXMMU_Type) SetLUT287L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT287L.Reg, volatile.LoadUint32(&o.LUT287L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT287L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT287L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT287L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT287L.Reg, volatile.LoadUint32(&o.LUT287L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT287L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT287L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT287L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT287L.Reg, volatile.LoadUint32(&o.LUT287L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT287L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT287L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT287H: Graphic MMU LUT entry 287 high
func (o *GFXMMU_Type) SetLUT287H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT287H.Reg, volatile.LoadUint32(&o.LUT287H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT287H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT287H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT288L: Graphic MMU LUT entry 288 low
func (o *GFXMMU_Type) SetLUT288L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT288L.Reg, volatile.LoadUint32(&o.LUT288L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT288L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT288L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT288L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT288L.Reg, volatile.LoadUint32(&o.LUT288L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT288L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT288L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT288L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT288L.Reg, volatile.LoadUint32(&o.LUT288L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT288L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT288L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT288H: Graphic MMU LUT entry 288 high
func (o *GFXMMU_Type) SetLUT288H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT288H.Reg, volatile.LoadUint32(&o.LUT288H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT288H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT288H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT289L: Graphic MMU LUT entry 289 low
func (o *GFXMMU_Type) SetLUT289L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT289L.Reg, volatile.LoadUint32(&o.LUT289L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT289L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT289L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT289L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT289L.Reg, volatile.LoadUint32(&o.LUT289L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT289L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT289L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT289L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT289L.Reg, volatile.LoadUint32(&o.LUT289L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT289L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT289L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT289H: Graphic MMU LUT entry 289 high
func (o *GFXMMU_Type) SetLUT289H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT289H.Reg, volatile.LoadUint32(&o.LUT289H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT289H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT289H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT290L: Graphic MMU LUT entry 290 low
func (o *GFXMMU_Type) SetLUT290L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT290L.Reg, volatile.LoadUint32(&o.LUT290L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT290L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT290L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT290L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT290L.Reg, volatile.LoadUint32(&o.LUT290L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT290L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT290L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT290L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT290L.Reg, volatile.LoadUint32(&o.LUT290L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT290L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT290L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT290H: Graphic MMU LUT entry 290 high
func (o *GFXMMU_Type) SetLUT290H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT290H.Reg, volatile.LoadUint32(&o.LUT290H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT290H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT290H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT291L: Graphic MMU LUT entry 291 low
func (o *GFXMMU_Type) SetLUT291L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT291L.Reg, volatile.LoadUint32(&o.LUT291L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT291L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT291L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT291L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT291L.Reg, volatile.LoadUint32(&o.LUT291L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT291L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT291L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT291L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT291L.Reg, volatile.LoadUint32(&o.LUT291L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT291L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT291L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT291H: Graphic MMU LUT entry 291 high
func (o *GFXMMU_Type) SetLUT291H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT291H.Reg, volatile.LoadUint32(&o.LUT291H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT291H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT291H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT292L: Graphic MMU LUT entry 292 low
func (o *GFXMMU_Type) SetLUT292L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT292L.Reg, volatile.LoadUint32(&o.LUT292L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT292L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT292L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT292L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT292L.Reg, volatile.LoadUint32(&o.LUT292L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT292L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT292L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT292L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT292L.Reg, volatile.LoadUint32(&o.LUT292L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT292L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT292L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT292H: Graphic MMU LUT entry 292 high
func (o *GFXMMU_Type) SetLUT292H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT292H.Reg, volatile.LoadUint32(&o.LUT292H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT292H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT292H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT293L: Graphic MMU LUT entry 293 low
func (o *GFXMMU_Type) SetLUT293L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT293L.Reg, volatile.LoadUint32(&o.LUT293L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT293L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT293L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT293L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT293L.Reg, volatile.LoadUint32(&o.LUT293L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT293L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT293L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT293L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT293L.Reg, volatile.LoadUint32(&o.LUT293L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT293L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT293L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT293H: Graphic MMU LUT entry 293 high
func (o *GFXMMU_Type) SetLUT293H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT293H.Reg, volatile.LoadUint32(&o.LUT293H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT293H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT293H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT294L: Graphic MMU LUT entry 294 low
func (o *GFXMMU_Type) SetLUT294L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT294L.Reg, volatile.LoadUint32(&o.LUT294L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT294L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT294L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT294L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT294L.Reg, volatile.LoadUint32(&o.LUT294L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT294L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT294L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT294L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT294L.Reg, volatile.LoadUint32(&o.LUT294L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT294L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT294L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT294H: Graphic MMU LUT entry 294 high
func (o *GFXMMU_Type) SetLUT294H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT294H.Reg, volatile.LoadUint32(&o.LUT294H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT294H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT294H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT295L: Graphic MMU LUT entry 295 low
func (o *GFXMMU_Type) SetLUT295L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT295L.Reg, volatile.LoadUint32(&o.LUT295L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT295L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT295L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT295L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT295L.Reg, volatile.LoadUint32(&o.LUT295L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT295L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT295L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT295L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT295L.Reg, volatile.LoadUint32(&o.LUT295L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT295L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT295L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT295H: Graphic MMU LUT entry 295 high
func (o *GFXMMU_Type) SetLUT295H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT295H.Reg, volatile.LoadUint32(&o.LUT295H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT295H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT295H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT296L: Graphic MMU LUT entry 296 low
func (o *GFXMMU_Type) SetLUT296L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT296L.Reg, volatile.LoadUint32(&o.LUT296L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT296L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT296L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT296L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT296L.Reg, volatile.LoadUint32(&o.LUT296L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT296L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT296L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT296L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT296L.Reg, volatile.LoadUint32(&o.LUT296L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT296L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT296L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT296H: Graphic MMU LUT entry 296 high
func (o *GFXMMU_Type) SetLUT296H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT296H.Reg, volatile.LoadUint32(&o.LUT296H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT296H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT296H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT297L: Graphic MMU LUT entry 297 low
func (o *GFXMMU_Type) SetLUT297L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT297L.Reg, volatile.LoadUint32(&o.LUT297L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT297L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT297L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT297L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT297L.Reg, volatile.LoadUint32(&o.LUT297L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT297L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT297L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT297L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT297L.Reg, volatile.LoadUint32(&o.LUT297L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT297L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT297L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT297H: Graphic MMU LUT entry 297 high
func (o *GFXMMU_Type) SetLUT297H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT297H.Reg, volatile.LoadUint32(&o.LUT297H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT297H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT297H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT298L: Graphic MMU LUT entry 298 low
func (o *GFXMMU_Type) SetLUT298L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT298L.Reg, volatile.LoadUint32(&o.LUT298L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT298L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT298L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT298L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT298L.Reg, volatile.LoadUint32(&o.LUT298L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT298L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT298L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT298L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT298L.Reg, volatile.LoadUint32(&o.LUT298L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT298L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT298L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT298H: Graphic MMU LUT entry 298 high
func (o *GFXMMU_Type) SetLUT298H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT298H.Reg, volatile.LoadUint32(&o.LUT298H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT298H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT298H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT299L: Graphic MMU LUT entry 299 low
func (o *GFXMMU_Type) SetLUT299L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT299L.Reg, volatile.LoadUint32(&o.LUT299L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT299L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT299L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT299L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT299L.Reg, volatile.LoadUint32(&o.LUT299L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT299L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT299L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT299L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT299L.Reg, volatile.LoadUint32(&o.LUT299L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT299L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT299L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT299H: Graphic MMU LUT entry 299 high
func (o *GFXMMU_Type) SetLUT299H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT299H.Reg, volatile.LoadUint32(&o.LUT299H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT299H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT299H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT300L: Graphic MMU LUT entry 300 low
func (o *GFXMMU_Type) SetLUT300L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT300L.Reg, volatile.LoadUint32(&o.LUT300L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT300L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT300L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT300L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT300L.Reg, volatile.LoadUint32(&o.LUT300L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT300L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT300L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT300L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT300L.Reg, volatile.LoadUint32(&o.LUT300L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT300L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT300L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT300H: Graphic MMU LUT entry 300 high
func (o *GFXMMU_Type) SetLUT300H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT300H.Reg, volatile.LoadUint32(&o.LUT300H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT300H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT300H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT301L: Graphic MMU LUT entry 301 low
func (o *GFXMMU_Type) SetLUT301L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT301L.Reg, volatile.LoadUint32(&o.LUT301L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT301L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT301L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT301L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT301L.Reg, volatile.LoadUint32(&o.LUT301L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT301L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT301L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT301L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT301L.Reg, volatile.LoadUint32(&o.LUT301L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT301L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT301L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT301H: Graphic MMU LUT entry 301 high
func (o *GFXMMU_Type) SetLUT301H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT301H.Reg, volatile.LoadUint32(&o.LUT301H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT301H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT301H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT302L: Graphic MMU LUT entry 302 low
func (o *GFXMMU_Type) SetLUT302L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT302L.Reg, volatile.LoadUint32(&o.LUT302L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT302L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT302L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT302L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT302L.Reg, volatile.LoadUint32(&o.LUT302L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT302L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT302L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT302L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT302L.Reg, volatile.LoadUint32(&o.LUT302L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT302L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT302L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT302H: Graphic MMU LUT entry 302 high
func (o *GFXMMU_Type) SetLUT302H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT302H.Reg, volatile.LoadUint32(&o.LUT302H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT302H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT302H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT303L: Graphic MMU LUT entry 303 low
func (o *GFXMMU_Type) SetLUT303L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT303L.Reg, volatile.LoadUint32(&o.LUT303L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT303L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT303L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT303L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT303L.Reg, volatile.LoadUint32(&o.LUT303L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT303L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT303L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT303L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT303L.Reg, volatile.LoadUint32(&o.LUT303L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT303L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT303L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT303H: Graphic MMU LUT entry 303 high
func (o *GFXMMU_Type) SetLUT303H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT303H.Reg, volatile.LoadUint32(&o.LUT303H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT303H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT303H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT304L: Graphic MMU LUT entry 304 low
func (o *GFXMMU_Type) SetLUT304L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT304L.Reg, volatile.LoadUint32(&o.LUT304L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT304L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT304L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT304L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT304L.Reg, volatile.LoadUint32(&o.LUT304L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT304L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT304L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT304L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT304L.Reg, volatile.LoadUint32(&o.LUT304L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT304L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT304L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT304H: Graphic MMU LUT entry 304 high
func (o *GFXMMU_Type) SetLUT304H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT304H.Reg, volatile.LoadUint32(&o.LUT304H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT304H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT304H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT305L: Graphic MMU LUT entry 305 low
func (o *GFXMMU_Type) SetLUT305L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT305L.Reg, volatile.LoadUint32(&o.LUT305L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT305L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT305L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT305L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT305L.Reg, volatile.LoadUint32(&o.LUT305L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT305L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT305L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT305L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT305L.Reg, volatile.LoadUint32(&o.LUT305L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT305L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT305L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT305H: Graphic MMU LUT entry 305 high
func (o *GFXMMU_Type) SetLUT305H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT305H.Reg, volatile.LoadUint32(&o.LUT305H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT305H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT305H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT306L: Graphic MMU LUT entry 306 low
func (o *GFXMMU_Type) SetLUT306L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT306L.Reg, volatile.LoadUint32(&o.LUT306L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT306L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT306L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT306L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT306L.Reg, volatile.LoadUint32(&o.LUT306L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT306L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT306L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT306L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT306L.Reg, volatile.LoadUint32(&o.LUT306L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT306L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT306L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT306H: Graphic MMU LUT entry 306 high
func (o *GFXMMU_Type) SetLUT306H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT306H.Reg, volatile.LoadUint32(&o.LUT306H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT306H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT306H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT307L: Graphic MMU LUT entry 307 low
func (o *GFXMMU_Type) SetLUT307L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT307L.Reg, volatile.LoadUint32(&o.LUT307L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT307L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT307L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT307L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT307L.Reg, volatile.LoadUint32(&o.LUT307L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT307L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT307L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT307L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT307L.Reg, volatile.LoadUint32(&o.LUT307L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT307L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT307L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT307H: Graphic MMU LUT entry 307 high
func (o *GFXMMU_Type) SetLUT307H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT307H.Reg, volatile.LoadUint32(&o.LUT307H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT307H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT307H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT308L: Graphic MMU LUT entry 308 low
func (o *GFXMMU_Type) SetLUT308L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT308L.Reg, volatile.LoadUint32(&o.LUT308L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT308L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT308L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT308L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT308L.Reg, volatile.LoadUint32(&o.LUT308L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT308L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT308L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT308L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT308L.Reg, volatile.LoadUint32(&o.LUT308L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT308L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT308L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT308H: Graphic MMU LUT entry 308 high
func (o *GFXMMU_Type) SetLUT308H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT308H.Reg, volatile.LoadUint32(&o.LUT308H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT308H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT308H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT309L: Graphic MMU LUT entry 309 low
func (o *GFXMMU_Type) SetLUT309L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT309L.Reg, volatile.LoadUint32(&o.LUT309L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT309L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT309L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT309L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT309L.Reg, volatile.LoadUint32(&o.LUT309L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT309L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT309L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT309L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT309L.Reg, volatile.LoadUint32(&o.LUT309L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT309L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT309L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT309H: Graphic MMU LUT entry 309 high
func (o *GFXMMU_Type) SetLUT309H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT309H.Reg, volatile.LoadUint32(&o.LUT309H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT309H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT309H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT310L: Graphic MMU LUT entry 310 low
func (o *GFXMMU_Type) SetLUT310L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT310L.Reg, volatile.LoadUint32(&o.LUT310L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT310L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT310L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT310L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT310L.Reg, volatile.LoadUint32(&o.LUT310L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT310L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT310L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT310L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT310L.Reg, volatile.LoadUint32(&o.LUT310L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT310L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT310L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT310H: Graphic MMU LUT entry 310 high
func (o *GFXMMU_Type) SetLUT310H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT310H.Reg, volatile.LoadUint32(&o.LUT310H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT310H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT310H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT311L: Graphic MMU LUT entry 311 low
func (o *GFXMMU_Type) SetLUT311L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT311L.Reg, volatile.LoadUint32(&o.LUT311L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT311L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT311L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT311L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT311L.Reg, volatile.LoadUint32(&o.LUT311L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT311L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT311L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT311L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT311L.Reg, volatile.LoadUint32(&o.LUT311L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT311L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT311L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT311H: Graphic MMU LUT entry 311 high
func (o *GFXMMU_Type) SetLUT311H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT311H.Reg, volatile.LoadUint32(&o.LUT311H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT311H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT311H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT312L: Graphic MMU LUT entry 312 low
func (o *GFXMMU_Type) SetLUT312L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT312L.Reg, volatile.LoadUint32(&o.LUT312L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT312L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT312L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT312L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT312L.Reg, volatile.LoadUint32(&o.LUT312L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT312L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT312L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT312L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT312L.Reg, volatile.LoadUint32(&o.LUT312L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT312L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT312L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT312H: Graphic MMU LUT entry 312 high
func (o *GFXMMU_Type) SetLUT312H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT312H.Reg, volatile.LoadUint32(&o.LUT312H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT312H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT312H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT313L: Graphic MMU LUT entry 313 low
func (o *GFXMMU_Type) SetLUT313L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT313L.Reg, volatile.LoadUint32(&o.LUT313L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT313L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT313L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT313L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT313L.Reg, volatile.LoadUint32(&o.LUT313L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT313L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT313L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT313L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT313L.Reg, volatile.LoadUint32(&o.LUT313L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT313L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT313L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT313H: Graphic MMU LUT entry 313 high
func (o *GFXMMU_Type) SetLUT313H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT313H.Reg, volatile.LoadUint32(&o.LUT313H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT313H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT313H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT314L: Graphic MMU LUT entry 314 low
func (o *GFXMMU_Type) SetLUT314L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT314L.Reg, volatile.LoadUint32(&o.LUT314L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT314L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT314L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT314L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT314L.Reg, volatile.LoadUint32(&o.LUT314L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT314L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT314L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT314L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT314L.Reg, volatile.LoadUint32(&o.LUT314L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT314L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT314L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT314H: Graphic MMU LUT entry 314 high
func (o *GFXMMU_Type) SetLUT314H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT314H.Reg, volatile.LoadUint32(&o.LUT314H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT314H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT314H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT315L: Graphic MMU LUT entry 315 low
func (o *GFXMMU_Type) SetLUT315L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT315L.Reg, volatile.LoadUint32(&o.LUT315L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT315L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT315L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT315L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT315L.Reg, volatile.LoadUint32(&o.LUT315L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT315L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT315L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT315L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT315L.Reg, volatile.LoadUint32(&o.LUT315L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT315L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT315L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT315H: Graphic MMU LUT entry 315 high
func (o *GFXMMU_Type) SetLUT315H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT315H.Reg, volatile.LoadUint32(&o.LUT315H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT315H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT315H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT316L: Graphic MMU LUT entry 316 low
func (o *GFXMMU_Type) SetLUT316L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT316L.Reg, volatile.LoadUint32(&o.LUT316L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT316L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT316L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT316L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT316L.Reg, volatile.LoadUint32(&o.LUT316L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT316L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT316L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT316L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT316L.Reg, volatile.LoadUint32(&o.LUT316L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT316L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT316L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT316H: Graphic MMU LUT entry 316 high
func (o *GFXMMU_Type) SetLUT316H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT316H.Reg, volatile.LoadUint32(&o.LUT316H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT316H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT316H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT317L: Graphic MMU LUT entry 317 low
func (o *GFXMMU_Type) SetLUT317L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT317L.Reg, volatile.LoadUint32(&o.LUT317L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT317L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT317L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT317L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT317L.Reg, volatile.LoadUint32(&o.LUT317L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT317L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT317L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT317L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT317L.Reg, volatile.LoadUint32(&o.LUT317L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT317L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT317L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT317H: Graphic MMU LUT entry 317 high
func (o *GFXMMU_Type) SetLUT317H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT317H.Reg, volatile.LoadUint32(&o.LUT317H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT317H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT317H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT318L: Graphic MMU LUT entry 318 low
func (o *GFXMMU_Type) SetLUT318L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT318L.Reg, volatile.LoadUint32(&o.LUT318L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT318L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT318L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT318L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT318L.Reg, volatile.LoadUint32(&o.LUT318L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT318L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT318L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT318L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT318L.Reg, volatile.LoadUint32(&o.LUT318L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT318L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT318L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT318H: Graphic MMU LUT entry 318 high
func (o *GFXMMU_Type) SetLUT318H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT318H.Reg, volatile.LoadUint32(&o.LUT318H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT318H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT318H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT319L: Graphic MMU LUT entry 319 low
func (o *GFXMMU_Type) SetLUT319L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT319L.Reg, volatile.LoadUint32(&o.LUT319L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT319L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT319L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT319L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT319L.Reg, volatile.LoadUint32(&o.LUT319L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT319L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT319L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT319L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT319L.Reg, volatile.LoadUint32(&o.LUT319L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT319L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT319L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT319H: Graphic MMU LUT entry 319 high
func (o *GFXMMU_Type) SetLUT319H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT319H.Reg, volatile.LoadUint32(&o.LUT319H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT319H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT319H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT320L: Graphic MMU LUT entry 320 low
func (o *GFXMMU_Type) SetLUT320L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT320L.Reg, volatile.LoadUint32(&o.LUT320L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT320L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT320L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT320L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT320L.Reg, volatile.LoadUint32(&o.LUT320L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT320L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT320L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT320L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT320L.Reg, volatile.LoadUint32(&o.LUT320L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT320L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT320L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT320H: Graphic MMU LUT entry 320 high
func (o *GFXMMU_Type) SetLUT320H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT320H.Reg, volatile.LoadUint32(&o.LUT320H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT320H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT320H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT321L: Graphic MMU LUT entry 321 low
func (o *GFXMMU_Type) SetLUT321L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT321L.Reg, volatile.LoadUint32(&o.LUT321L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT321L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT321L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT321L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT321L.Reg, volatile.LoadUint32(&o.LUT321L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT321L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT321L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT321L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT321L.Reg, volatile.LoadUint32(&o.LUT321L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT321L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT321L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT321H: Graphic MMU LUT entry 321 high
func (o *GFXMMU_Type) SetLUT321H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT321H.Reg, volatile.LoadUint32(&o.LUT321H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT321H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT321H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT322L: Graphic MMU LUT entry 322 low
func (o *GFXMMU_Type) SetLUT322L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT322L.Reg, volatile.LoadUint32(&o.LUT322L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT322L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT322L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT322L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT322L.Reg, volatile.LoadUint32(&o.LUT322L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT322L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT322L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT322L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT322L.Reg, volatile.LoadUint32(&o.LUT322L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT322L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT322L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT322H: Graphic MMU LUT entry 322 high
func (o *GFXMMU_Type) SetLUT322H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT322H.Reg, volatile.LoadUint32(&o.LUT322H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT322H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT322H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT323L: Graphic MMU LUT entry 323 low
func (o *GFXMMU_Type) SetLUT323L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT323L.Reg, volatile.LoadUint32(&o.LUT323L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT323L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT323L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT323L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT323L.Reg, volatile.LoadUint32(&o.LUT323L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT323L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT323L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT323L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT323L.Reg, volatile.LoadUint32(&o.LUT323L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT323L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT323L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT323H: Graphic MMU LUT entry 323 high
func (o *GFXMMU_Type) SetLUT323H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT323H.Reg, volatile.LoadUint32(&o.LUT323H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT323H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT323H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT324L: Graphic MMU LUT entry 324 low
func (o *GFXMMU_Type) SetLUT324L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT324L.Reg, volatile.LoadUint32(&o.LUT324L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT324L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT324L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT324L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT324L.Reg, volatile.LoadUint32(&o.LUT324L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT324L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT324L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT324L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT324L.Reg, volatile.LoadUint32(&o.LUT324L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT324L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT324L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT324H: Graphic MMU LUT entry 324 high
func (o *GFXMMU_Type) SetLUT324H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT324H.Reg, volatile.LoadUint32(&o.LUT324H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT324H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT324H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT325L: Graphic MMU LUT entry 325 low
func (o *GFXMMU_Type) SetLUT325L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT325L.Reg, volatile.LoadUint32(&o.LUT325L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT325L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT325L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT325L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT325L.Reg, volatile.LoadUint32(&o.LUT325L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT325L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT325L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT325L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT325L.Reg, volatile.LoadUint32(&o.LUT325L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT325L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT325L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT325H: Graphic MMU LUT entry 325 high
func (o *GFXMMU_Type) SetLUT325H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT325H.Reg, volatile.LoadUint32(&o.LUT325H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT325H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT325H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT326L: Graphic MMU LUT entry 326 low
func (o *GFXMMU_Type) SetLUT326L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT326L.Reg, volatile.LoadUint32(&o.LUT326L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT326L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT326L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT326L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT326L.Reg, volatile.LoadUint32(&o.LUT326L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT326L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT326L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT326L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT326L.Reg, volatile.LoadUint32(&o.LUT326L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT326L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT326L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT326H: Graphic MMU LUT entry 326 high
func (o *GFXMMU_Type) SetLUT326H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT326H.Reg, volatile.LoadUint32(&o.LUT326H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT326H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT326H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT327L: Graphic MMU LUT entry 327 low
func (o *GFXMMU_Type) SetLUT327L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT327L.Reg, volatile.LoadUint32(&o.LUT327L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT327L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT327L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT327L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT327L.Reg, volatile.LoadUint32(&o.LUT327L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT327L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT327L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT327L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT327L.Reg, volatile.LoadUint32(&o.LUT327L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT327L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT327L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT327H: Graphic MMU LUT entry 327 high
func (o *GFXMMU_Type) SetLUT327H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT327H.Reg, volatile.LoadUint32(&o.LUT327H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT327H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT327H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT328L: Graphic MMU LUT entry 328 low
func (o *GFXMMU_Type) SetLUT328L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT328L.Reg, volatile.LoadUint32(&o.LUT328L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT328L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT328L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT328L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT328L.Reg, volatile.LoadUint32(&o.LUT328L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT328L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT328L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT328L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT328L.Reg, volatile.LoadUint32(&o.LUT328L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT328L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT328L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT328H: Graphic MMU LUT entry 328 high
func (o *GFXMMU_Type) SetLUT328H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT328H.Reg, volatile.LoadUint32(&o.LUT328H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT328H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT328H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT329L: Graphic MMU LUT entry 329 low
func (o *GFXMMU_Type) SetLUT329L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT329L.Reg, volatile.LoadUint32(&o.LUT329L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT329L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT329L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT329L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT329L.Reg, volatile.LoadUint32(&o.LUT329L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT329L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT329L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT329L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT329L.Reg, volatile.LoadUint32(&o.LUT329L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT329L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT329L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT329H: Graphic MMU LUT entry 329 high
func (o *GFXMMU_Type) SetLUT329H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT329H.Reg, volatile.LoadUint32(&o.LUT329H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT329H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT329H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT330L: Graphic MMU LUT entry 330 low
func (o *GFXMMU_Type) SetLUT330L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT330L.Reg, volatile.LoadUint32(&o.LUT330L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT330L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT330L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT330L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT330L.Reg, volatile.LoadUint32(&o.LUT330L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT330L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT330L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT330L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT330L.Reg, volatile.LoadUint32(&o.LUT330L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT330L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT330L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT330H: Graphic MMU LUT entry 330 high
func (o *GFXMMU_Type) SetLUT330H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT330H.Reg, volatile.LoadUint32(&o.LUT330H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT330H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT330H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT331L: Graphic MMU LUT entry 331 low
func (o *GFXMMU_Type) SetLUT331L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT331L.Reg, volatile.LoadUint32(&o.LUT331L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT331L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT331L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT331L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT331L.Reg, volatile.LoadUint32(&o.LUT331L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT331L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT331L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT331L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT331L.Reg, volatile.LoadUint32(&o.LUT331L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT331L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT331L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT331H: Graphic MMU LUT entry 331 high
func (o *GFXMMU_Type) SetLUT331H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT331H.Reg, volatile.LoadUint32(&o.LUT331H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT331H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT331H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT332L: Graphic MMU LUT entry 332 low
func (o *GFXMMU_Type) SetLUT332L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT332L.Reg, volatile.LoadUint32(&o.LUT332L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT332L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT332L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT332L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT332L.Reg, volatile.LoadUint32(&o.LUT332L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT332L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT332L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT332L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT332L.Reg, volatile.LoadUint32(&o.LUT332L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT332L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT332L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT332H: Graphic MMU LUT entry 332 high
func (o *GFXMMU_Type) SetLUT332H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT332H.Reg, volatile.LoadUint32(&o.LUT332H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT332H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT332H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT333L: Graphic MMU LUT entry 333 low
func (o *GFXMMU_Type) SetLUT333L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT333L.Reg, volatile.LoadUint32(&o.LUT333L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT333L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT333L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT333L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT333L.Reg, volatile.LoadUint32(&o.LUT333L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT333L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT333L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT333L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT333L.Reg, volatile.LoadUint32(&o.LUT333L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT333L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT333L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT333H: Graphic MMU LUT entry 333 high
func (o *GFXMMU_Type) SetLUT333H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT333H.Reg, volatile.LoadUint32(&o.LUT333H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT333H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT333H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT334L: Graphic MMU LUT entry 334 low
func (o *GFXMMU_Type) SetLUT334L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT334L.Reg, volatile.LoadUint32(&o.LUT334L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT334L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT334L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT334L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT334L.Reg, volatile.LoadUint32(&o.LUT334L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT334L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT334L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT334L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT334L.Reg, volatile.LoadUint32(&o.LUT334L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT334L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT334L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT334H: Graphic MMU LUT entry 334 high
func (o *GFXMMU_Type) SetLUT334H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT334H.Reg, volatile.LoadUint32(&o.LUT334H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT334H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT334H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT335L: Graphic MMU LUT entry 335 low
func (o *GFXMMU_Type) SetLUT335L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT335L.Reg, volatile.LoadUint32(&o.LUT335L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT335L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT335L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT335L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT335L.Reg, volatile.LoadUint32(&o.LUT335L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT335L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT335L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT335L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT335L.Reg, volatile.LoadUint32(&o.LUT335L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT335L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT335L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT335H: Graphic MMU LUT entry 335 high
func (o *GFXMMU_Type) SetLUT335H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT335H.Reg, volatile.LoadUint32(&o.LUT335H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT335H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT335H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT336L: Graphic MMU LUT entry 336 low
func (o *GFXMMU_Type) SetLUT336L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT336L.Reg, volatile.LoadUint32(&o.LUT336L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT336L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT336L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT336L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT336L.Reg, volatile.LoadUint32(&o.LUT336L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT336L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT336L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT336L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT336L.Reg, volatile.LoadUint32(&o.LUT336L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT336L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT336L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT336H: Graphic MMU LUT entry 336 high
func (o *GFXMMU_Type) SetLUT336H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT336H.Reg, volatile.LoadUint32(&o.LUT336H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT336H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT336H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT337L: Graphic MMU LUT entry 337 low
func (o *GFXMMU_Type) SetLUT337L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT337L.Reg, volatile.LoadUint32(&o.LUT337L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT337L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT337L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT337L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT337L.Reg, volatile.LoadUint32(&o.LUT337L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT337L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT337L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT337L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT337L.Reg, volatile.LoadUint32(&o.LUT337L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT337L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT337L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT337H: Graphic MMU LUT entry 337 high
func (o *GFXMMU_Type) SetLUT337H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT337H.Reg, volatile.LoadUint32(&o.LUT337H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT337H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT337H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT338L: Graphic MMU LUT entry 338 low
func (o *GFXMMU_Type) SetLUT338L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT338L.Reg, volatile.LoadUint32(&o.LUT338L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT338L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT338L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT338L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT338L.Reg, volatile.LoadUint32(&o.LUT338L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT338L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT338L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT338L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT338L.Reg, volatile.LoadUint32(&o.LUT338L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT338L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT338L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT338H: Graphic MMU LUT entry 338 high
func (o *GFXMMU_Type) SetLUT338H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT338H.Reg, volatile.LoadUint32(&o.LUT338H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT338H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT338H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT339L: Graphic MMU LUT entry 339 low
func (o *GFXMMU_Type) SetLUT339L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT339L.Reg, volatile.LoadUint32(&o.LUT339L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT339L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT339L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT339L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT339L.Reg, volatile.LoadUint32(&o.LUT339L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT339L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT339L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT339L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT339L.Reg, volatile.LoadUint32(&o.LUT339L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT339L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT339L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT339H: Graphic MMU LUT entry 339 high
func (o *GFXMMU_Type) SetLUT339H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT339H.Reg, volatile.LoadUint32(&o.LUT339H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT339H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT339H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT340L: Graphic MMU LUT entry 340 low
func (o *GFXMMU_Type) SetLUT340L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT340L.Reg, volatile.LoadUint32(&o.LUT340L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT340L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT340L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT340L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT340L.Reg, volatile.LoadUint32(&o.LUT340L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT340L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT340L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT340L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT340L.Reg, volatile.LoadUint32(&o.LUT340L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT340L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT340L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT340H: Graphic MMU LUT entry 340 high
func (o *GFXMMU_Type) SetLUT340H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT340H.Reg, volatile.LoadUint32(&o.LUT340H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT340H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT340H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT341L: Graphic MMU LUT entry 341 low
func (o *GFXMMU_Type) SetLUT341L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT341L.Reg, volatile.LoadUint32(&o.LUT341L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT341L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT341L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT341L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT341L.Reg, volatile.LoadUint32(&o.LUT341L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT341L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT341L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT341L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT341L.Reg, volatile.LoadUint32(&o.LUT341L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT341L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT341L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT341H: Graphic MMU LUT entry 341 high
func (o *GFXMMU_Type) SetLUT341H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT341H.Reg, volatile.LoadUint32(&o.LUT341H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT341H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT341H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT342L: Graphic MMU LUT entry 342 low
func (o *GFXMMU_Type) SetLUT342L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT342L.Reg, volatile.LoadUint32(&o.LUT342L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT342L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT342L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT342L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT342L.Reg, volatile.LoadUint32(&o.LUT342L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT342L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT342L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT342L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT342L.Reg, volatile.LoadUint32(&o.LUT342L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT342L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT342L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT342H: Graphic MMU LUT entry 342 high
func (o *GFXMMU_Type) SetLUT342H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT342H.Reg, volatile.LoadUint32(&o.LUT342H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT342H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT342H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT343L: Graphic MMU LUT entry 343 low
func (o *GFXMMU_Type) SetLUT343L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT343L.Reg, volatile.LoadUint32(&o.LUT343L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT343L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT343L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT343L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT343L.Reg, volatile.LoadUint32(&o.LUT343L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT343L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT343L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT343L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT343L.Reg, volatile.LoadUint32(&o.LUT343L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT343L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT343L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT343H: Graphic MMU LUT entry 343 high
func (o *GFXMMU_Type) SetLUT343H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT343H.Reg, volatile.LoadUint32(&o.LUT343H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT343H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT343H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT344L: Graphic MMU LUT entry 344 low
func (o *GFXMMU_Type) SetLUT344L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT344L.Reg, volatile.LoadUint32(&o.LUT344L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT344L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT344L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT344L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT344L.Reg, volatile.LoadUint32(&o.LUT344L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT344L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT344L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT344L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT344L.Reg, volatile.LoadUint32(&o.LUT344L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT344L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT344L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT344H: Graphic MMU LUT entry 344 high
func (o *GFXMMU_Type) SetLUT344H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT344H.Reg, volatile.LoadUint32(&o.LUT344H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT344H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT344H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT345L: Graphic MMU LUT entry 345 low
func (o *GFXMMU_Type) SetLUT345L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT345L.Reg, volatile.LoadUint32(&o.LUT345L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT345L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT345L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT345L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT345L.Reg, volatile.LoadUint32(&o.LUT345L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT345L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT345L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT345L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT345L.Reg, volatile.LoadUint32(&o.LUT345L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT345L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT345L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT345H: Graphic MMU LUT entry 345 high
func (o *GFXMMU_Type) SetLUT345H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT345H.Reg, volatile.LoadUint32(&o.LUT345H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT345H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT345H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT346L: Graphic MMU LUT entry 346 low
func (o *GFXMMU_Type) SetLUT346L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT346L.Reg, volatile.LoadUint32(&o.LUT346L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT346L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT346L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT346L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT346L.Reg, volatile.LoadUint32(&o.LUT346L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT346L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT346L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT346L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT346L.Reg, volatile.LoadUint32(&o.LUT346L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT346L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT346L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT346H: Graphic MMU LUT entry 346 high
func (o *GFXMMU_Type) SetLUT346H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT346H.Reg, volatile.LoadUint32(&o.LUT346H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT346H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT346H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT347L: Graphic MMU LUT entry 347 low
func (o *GFXMMU_Type) SetLUT347L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT347L.Reg, volatile.LoadUint32(&o.LUT347L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT347L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT347L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT347L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT347L.Reg, volatile.LoadUint32(&o.LUT347L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT347L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT347L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT347L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT347L.Reg, volatile.LoadUint32(&o.LUT347L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT347L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT347L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT347H: Graphic MMU LUT entry 347 high
func (o *GFXMMU_Type) SetLUT347H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT347H.Reg, volatile.LoadUint32(&o.LUT347H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT347H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT347H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT348L: Graphic MMU LUT entry 348 low
func (o *GFXMMU_Type) SetLUT348L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT348L.Reg, volatile.LoadUint32(&o.LUT348L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT348L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT348L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT348L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT348L.Reg, volatile.LoadUint32(&o.LUT348L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT348L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT348L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT348L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT348L.Reg, volatile.LoadUint32(&o.LUT348L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT348L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT348L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT348H: Graphic MMU LUT entry 348 high
func (o *GFXMMU_Type) SetLUT348H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT348H.Reg, volatile.LoadUint32(&o.LUT348H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT348H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT348H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT349L: Graphic MMU LUT entry 349 low
func (o *GFXMMU_Type) SetLUT349L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT349L.Reg, volatile.LoadUint32(&o.LUT349L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT349L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT349L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT349L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT349L.Reg, volatile.LoadUint32(&o.LUT349L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT349L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT349L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT349L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT349L.Reg, volatile.LoadUint32(&o.LUT349L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT349L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT349L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT349H: Graphic MMU LUT entry 349 high
func (o *GFXMMU_Type) SetLUT349H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT349H.Reg, volatile.LoadUint32(&o.LUT349H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT349H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT349H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT350L: Graphic MMU LUT entry 350 low
func (o *GFXMMU_Type) SetLUT350L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT350L.Reg, volatile.LoadUint32(&o.LUT350L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT350L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT350L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT350L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT350L.Reg, volatile.LoadUint32(&o.LUT350L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT350L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT350L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT350L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT350L.Reg, volatile.LoadUint32(&o.LUT350L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT350L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT350L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT350H: Graphic MMU LUT entry 350 high
func (o *GFXMMU_Type) SetLUT350H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT350H.Reg, volatile.LoadUint32(&o.LUT350H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT350H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT350H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT351L: Graphic MMU LUT entry 351 low
func (o *GFXMMU_Type) SetLUT351L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT351L.Reg, volatile.LoadUint32(&o.LUT351L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT351L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT351L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT351L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT351L.Reg, volatile.LoadUint32(&o.LUT351L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT351L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT351L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT351L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT351L.Reg, volatile.LoadUint32(&o.LUT351L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT351L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT351L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT351H: Graphic MMU LUT entry 351 high
func (o *GFXMMU_Type) SetLUT351H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT351H.Reg, volatile.LoadUint32(&o.LUT351H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT351H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT351H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT352L: Graphic MMU LUT entry 352 low
func (o *GFXMMU_Type) SetLUT352L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT352L.Reg, volatile.LoadUint32(&o.LUT352L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT352L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT352L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT352L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT352L.Reg, volatile.LoadUint32(&o.LUT352L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT352L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT352L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT352L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT352L.Reg, volatile.LoadUint32(&o.LUT352L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT352L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT352L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT352H: Graphic MMU LUT entry 352 high
func (o *GFXMMU_Type) SetLUT352H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT352H.Reg, volatile.LoadUint32(&o.LUT352H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT352H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT352H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT353L: Graphic MMU LUT entry 353 low
func (o *GFXMMU_Type) SetLUT353L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT353L.Reg, volatile.LoadUint32(&o.LUT353L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT353L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT353L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT353L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT353L.Reg, volatile.LoadUint32(&o.LUT353L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT353L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT353L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT353L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT353L.Reg, volatile.LoadUint32(&o.LUT353L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT353L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT353L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT353H: Graphic MMU LUT entry 353 high
func (o *GFXMMU_Type) SetLUT353H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT353H.Reg, volatile.LoadUint32(&o.LUT353H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT353H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT353H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT354L: Graphic MMU LUT entry 354 low
func (o *GFXMMU_Type) SetLUT354L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT354L.Reg, volatile.LoadUint32(&o.LUT354L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT354L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT354L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT354L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT354L.Reg, volatile.LoadUint32(&o.LUT354L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT354L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT354L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT354L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT354L.Reg, volatile.LoadUint32(&o.LUT354L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT354L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT354L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT354H: Graphic MMU LUT entry 354 high
func (o *GFXMMU_Type) SetLUT354H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT354H.Reg, volatile.LoadUint32(&o.LUT354H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT354H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT354H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT355L: Graphic MMU LUT entry 355 low
func (o *GFXMMU_Type) SetLUT355L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT355L.Reg, volatile.LoadUint32(&o.LUT355L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT355L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT355L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT355L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT355L.Reg, volatile.LoadUint32(&o.LUT355L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT355L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT355L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT355L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT355L.Reg, volatile.LoadUint32(&o.LUT355L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT355L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT355L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT355H: Graphic MMU LUT entry 355 high
func (o *GFXMMU_Type) SetLUT355H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT355H.Reg, volatile.LoadUint32(&o.LUT355H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT355H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT355H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT356L: Graphic MMU LUT entry 356 low
func (o *GFXMMU_Type) SetLUT356L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT356L.Reg, volatile.LoadUint32(&o.LUT356L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT356L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT356L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT356L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT356L.Reg, volatile.LoadUint32(&o.LUT356L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT356L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT356L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT356L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT356L.Reg, volatile.LoadUint32(&o.LUT356L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT356L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT356L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT356H: Graphic MMU LUT entry 356 high
func (o *GFXMMU_Type) SetLUT356H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT356H.Reg, volatile.LoadUint32(&o.LUT356H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT356H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT356H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT357L: Graphic MMU LUT entry 357 low
func (o *GFXMMU_Type) SetLUT357L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT357L.Reg, volatile.LoadUint32(&o.LUT357L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT357L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT357L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT357L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT357L.Reg, volatile.LoadUint32(&o.LUT357L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT357L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT357L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT357L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT357L.Reg, volatile.LoadUint32(&o.LUT357L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT357L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT357L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT357H: Graphic MMU LUT entry 357 high
func (o *GFXMMU_Type) SetLUT357H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT357H.Reg, volatile.LoadUint32(&o.LUT357H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT357H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT357H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT358L: Graphic MMU LUT entry 358 low
func (o *GFXMMU_Type) SetLUT358L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT358L.Reg, volatile.LoadUint32(&o.LUT358L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT358L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT358L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT358L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT358L.Reg, volatile.LoadUint32(&o.LUT358L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT358L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT358L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT358L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT358L.Reg, volatile.LoadUint32(&o.LUT358L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT358L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT358L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT358H: Graphic MMU LUT entry 358 high
func (o *GFXMMU_Type) SetLUT358H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT358H.Reg, volatile.LoadUint32(&o.LUT358H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT358H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT358H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT359L: Graphic MMU LUT entry 359 low
func (o *GFXMMU_Type) SetLUT359L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT359L.Reg, volatile.LoadUint32(&o.LUT359L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT359L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT359L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT359L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT359L.Reg, volatile.LoadUint32(&o.LUT359L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT359L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT359L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT359L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT359L.Reg, volatile.LoadUint32(&o.LUT359L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT359L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT359L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT359H: Graphic MMU LUT entry 359 high
func (o *GFXMMU_Type) SetLUT359H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT359H.Reg, volatile.LoadUint32(&o.LUT359H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT359H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT359H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT360L: Graphic MMU LUT entry 360 low
func (o *GFXMMU_Type) SetLUT360L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT360L.Reg, volatile.LoadUint32(&o.LUT360L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT360L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT360L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT360L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT360L.Reg, volatile.LoadUint32(&o.LUT360L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT360L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT360L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT360L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT360L.Reg, volatile.LoadUint32(&o.LUT360L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT360L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT360L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT360H: Graphic MMU LUT entry 360 high
func (o *GFXMMU_Type) SetLUT360H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT360H.Reg, volatile.LoadUint32(&o.LUT360H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT360H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT360H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT361L: Graphic MMU LUT entry 361 low
func (o *GFXMMU_Type) SetLUT361L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT361L.Reg, volatile.LoadUint32(&o.LUT361L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT361L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT361L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT361L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT361L.Reg, volatile.LoadUint32(&o.LUT361L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT361L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT361L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT361L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT361L.Reg, volatile.LoadUint32(&o.LUT361L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT361L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT361L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT361H: Graphic MMU LUT entry 361 high
func (o *GFXMMU_Type) SetLUT361H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT361H.Reg, volatile.LoadUint32(&o.LUT361H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT361H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT361H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT362L: Graphic MMU LUT entry 362 low
func (o *GFXMMU_Type) SetLUT362L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT362L.Reg, volatile.LoadUint32(&o.LUT362L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT362L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT362L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT362L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT362L.Reg, volatile.LoadUint32(&o.LUT362L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT362L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT362L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT362L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT362L.Reg, volatile.LoadUint32(&o.LUT362L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT362L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT362L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT362H: Graphic MMU LUT entry 362 high
func (o *GFXMMU_Type) SetLUT362H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT362H.Reg, volatile.LoadUint32(&o.LUT362H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT362H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT362H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT363L: Graphic MMU LUT entry 363 low
func (o *GFXMMU_Type) SetLUT363L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT363L.Reg, volatile.LoadUint32(&o.LUT363L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT363L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT363L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT363L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT363L.Reg, volatile.LoadUint32(&o.LUT363L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT363L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT363L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT363L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT363L.Reg, volatile.LoadUint32(&o.LUT363L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT363L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT363L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT363H: Graphic MMU LUT entry 363 high
func (o *GFXMMU_Type) SetLUT363H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT363H.Reg, volatile.LoadUint32(&o.LUT363H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT363H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT363H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT364L: Graphic MMU LUT entry 364 low
func (o *GFXMMU_Type) SetLUT364L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT364L.Reg, volatile.LoadUint32(&o.LUT364L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT364L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT364L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT364L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT364L.Reg, volatile.LoadUint32(&o.LUT364L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT364L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT364L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT364L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT364L.Reg, volatile.LoadUint32(&o.LUT364L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT364L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT364L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT364H: Graphic MMU LUT entry 364 high
func (o *GFXMMU_Type) SetLUT364H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT364H.Reg, volatile.LoadUint32(&o.LUT364H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT364H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT364H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT365L: Graphic MMU LUT entry 365 low
func (o *GFXMMU_Type) SetLUT365L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT365L.Reg, volatile.LoadUint32(&o.LUT365L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT365L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT365L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT365L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT365L.Reg, volatile.LoadUint32(&o.LUT365L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT365L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT365L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT365L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT365L.Reg, volatile.LoadUint32(&o.LUT365L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT365L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT365L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT365H: Graphic MMU LUT entry 365 high
func (o *GFXMMU_Type) SetLUT365H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT365H.Reg, volatile.LoadUint32(&o.LUT365H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT365H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT365H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT366L: Graphic MMU LUT entry 366 low
func (o *GFXMMU_Type) SetLUT366L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT366L.Reg, volatile.LoadUint32(&o.LUT366L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT366L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT366L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT366L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT366L.Reg, volatile.LoadUint32(&o.LUT366L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT366L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT366L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT366L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT366L.Reg, volatile.LoadUint32(&o.LUT366L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT366L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT366L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT366H: Graphic MMU LUT entry 366 high
func (o *GFXMMU_Type) SetLUT366H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT366H.Reg, volatile.LoadUint32(&o.LUT366H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT366H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT366H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT367L: Graphic MMU LUT entry 367 low
func (o *GFXMMU_Type) SetLUT367L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT367L.Reg, volatile.LoadUint32(&o.LUT367L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT367L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT367L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT367L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT367L.Reg, volatile.LoadUint32(&o.LUT367L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT367L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT367L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT367L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT367L.Reg, volatile.LoadUint32(&o.LUT367L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT367L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT367L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT367H: Graphic MMU LUT entry 367 high
func (o *GFXMMU_Type) SetLUT367H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT367H.Reg, volatile.LoadUint32(&o.LUT367H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT367H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT367H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT368L: Graphic MMU LUT entry 368 low
func (o *GFXMMU_Type) SetLUT368L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT368L.Reg, volatile.LoadUint32(&o.LUT368L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT368L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT368L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT368L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT368L.Reg, volatile.LoadUint32(&o.LUT368L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT368L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT368L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT368L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT368L.Reg, volatile.LoadUint32(&o.LUT368L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT368L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT368L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT368H: Graphic MMU LUT entry 368 high
func (o *GFXMMU_Type) SetLUT368H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT368H.Reg, volatile.LoadUint32(&o.LUT368H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT368H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT368H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT369L: Graphic MMU LUT entry 369 low
func (o *GFXMMU_Type) SetLUT369L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT369L.Reg, volatile.LoadUint32(&o.LUT369L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT369L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT369L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT369L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT369L.Reg, volatile.LoadUint32(&o.LUT369L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT369L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT369L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT369L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT369L.Reg, volatile.LoadUint32(&o.LUT369L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT369L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT369L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT369H: Graphic MMU LUT entry 369 high
func (o *GFXMMU_Type) SetLUT369H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT369H.Reg, volatile.LoadUint32(&o.LUT369H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT369H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT369H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT370L: Graphic MMU LUT entry 370 low
func (o *GFXMMU_Type) SetLUT370L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT370L.Reg, volatile.LoadUint32(&o.LUT370L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT370L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT370L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT370L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT370L.Reg, volatile.LoadUint32(&o.LUT370L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT370L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT370L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT370L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT370L.Reg, volatile.LoadUint32(&o.LUT370L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT370L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT370L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT370H: Graphic MMU LUT entry 370 high
func (o *GFXMMU_Type) SetLUT370H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT370H.Reg, volatile.LoadUint32(&o.LUT370H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT370H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT370H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT371L: Graphic MMU LUT entry 371 low
func (o *GFXMMU_Type) SetLUT371L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT371L.Reg, volatile.LoadUint32(&o.LUT371L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT371L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT371L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT371L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT371L.Reg, volatile.LoadUint32(&o.LUT371L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT371L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT371L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT371L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT371L.Reg, volatile.LoadUint32(&o.LUT371L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT371L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT371L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT371H: Graphic MMU LUT entry 371 high
func (o *GFXMMU_Type) SetLUT371H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT371H.Reg, volatile.LoadUint32(&o.LUT371H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT371H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT371H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT372L: Graphic MMU LUT entry 372 low
func (o *GFXMMU_Type) SetLUT372L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT372L.Reg, volatile.LoadUint32(&o.LUT372L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT372L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT372L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT372L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT372L.Reg, volatile.LoadUint32(&o.LUT372L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT372L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT372L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT372L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT372L.Reg, volatile.LoadUint32(&o.LUT372L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT372L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT372L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT372H: Graphic MMU LUT entry 372 high
func (o *GFXMMU_Type) SetLUT372H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT372H.Reg, volatile.LoadUint32(&o.LUT372H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT372H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT372H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT373L: Graphic MMU LUT entry 373 low
func (o *GFXMMU_Type) SetLUT373L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT373L.Reg, volatile.LoadUint32(&o.LUT373L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT373L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT373L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT373L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT373L.Reg, volatile.LoadUint32(&o.LUT373L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT373L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT373L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT373L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT373L.Reg, volatile.LoadUint32(&o.LUT373L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT373L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT373L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT373H: Graphic MMU LUT entry 373 high
func (o *GFXMMU_Type) SetLUT373H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT373H.Reg, volatile.LoadUint32(&o.LUT373H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT373H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT373H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT374L: Graphic MMU LUT entry 374 low
func (o *GFXMMU_Type) SetLUT374L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT374L.Reg, volatile.LoadUint32(&o.LUT374L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT374L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT374L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT374L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT374L.Reg, volatile.LoadUint32(&o.LUT374L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT374L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT374L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT374L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT374L.Reg, volatile.LoadUint32(&o.LUT374L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT374L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT374L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT374H: Graphic MMU LUT entry 374 high
func (o *GFXMMU_Type) SetLUT374H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT374H.Reg, volatile.LoadUint32(&o.LUT374H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT374H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT374H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT375L: Graphic MMU LUT entry 375 low
func (o *GFXMMU_Type) SetLUT375L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT375L.Reg, volatile.LoadUint32(&o.LUT375L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT375L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT375L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT375L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT375L.Reg, volatile.LoadUint32(&o.LUT375L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT375L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT375L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT375L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT375L.Reg, volatile.LoadUint32(&o.LUT375L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT375L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT375L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT375H: Graphic MMU LUT entry 375 high
func (o *GFXMMU_Type) SetLUT375H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT375H.Reg, volatile.LoadUint32(&o.LUT375H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT375H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT375H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT376L: Graphic MMU LUT entry 376 low
func (o *GFXMMU_Type) SetLUT376L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT376L.Reg, volatile.LoadUint32(&o.LUT376L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT376L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT376L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT376L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT376L.Reg, volatile.LoadUint32(&o.LUT376L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT376L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT376L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT376L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT376L.Reg, volatile.LoadUint32(&o.LUT376L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT376L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT376L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT376H: Graphic MMU LUT entry 376 high
func (o *GFXMMU_Type) SetLUT376H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT376H.Reg, volatile.LoadUint32(&o.LUT376H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT376H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT376H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT377L: Graphic MMU LUT entry 377 low
func (o *GFXMMU_Type) SetLUT377L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT377L.Reg, volatile.LoadUint32(&o.LUT377L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT377L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT377L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT377L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT377L.Reg, volatile.LoadUint32(&o.LUT377L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT377L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT377L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT377L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT377L.Reg, volatile.LoadUint32(&o.LUT377L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT377L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT377L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT377H: Graphic MMU LUT entry 377 high
func (o *GFXMMU_Type) SetLUT377H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT377H.Reg, volatile.LoadUint32(&o.LUT377H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT377H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT377H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT378L: Graphic MMU LUT entry 378 low
func (o *GFXMMU_Type) SetLUT378L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT378L.Reg, volatile.LoadUint32(&o.LUT378L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT378L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT378L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT378L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT378L.Reg, volatile.LoadUint32(&o.LUT378L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT378L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT378L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT378L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT378L.Reg, volatile.LoadUint32(&o.LUT378L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT378L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT378L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT378H: Graphic MMU LUT entry 378 high
func (o *GFXMMU_Type) SetLUT378H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT378H.Reg, volatile.LoadUint32(&o.LUT378H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT378H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT378H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT379L: Graphic MMU LUT entry 379 low
func (o *GFXMMU_Type) SetLUT379L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT379L.Reg, volatile.LoadUint32(&o.LUT379L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT379L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT379L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT379L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT379L.Reg, volatile.LoadUint32(&o.LUT379L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT379L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT379L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT379L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT379L.Reg, volatile.LoadUint32(&o.LUT379L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT379L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT379L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT379H: Graphic MMU LUT entry 379 high
func (o *GFXMMU_Type) SetLUT379H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT379H.Reg, volatile.LoadUint32(&o.LUT379H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT379H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT379H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT380L: Graphic MMU LUT entry 380 low
func (o *GFXMMU_Type) SetLUT380L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT380L.Reg, volatile.LoadUint32(&o.LUT380L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT380L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT380L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT380L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT380L.Reg, volatile.LoadUint32(&o.LUT380L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT380L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT380L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT380L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT380L.Reg, volatile.LoadUint32(&o.LUT380L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT380L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT380L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT380H: Graphic MMU LUT entry 380 high
func (o *GFXMMU_Type) SetLUT380H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT380H.Reg, volatile.LoadUint32(&o.LUT380H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT380H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT380H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT381L: Graphic MMU LUT entry 381 low
func (o *GFXMMU_Type) SetLUT381L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT381L.Reg, volatile.LoadUint32(&o.LUT381L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT381L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT381L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT381L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT381L.Reg, volatile.LoadUint32(&o.LUT381L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT381L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT381L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT381L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT381L.Reg, volatile.LoadUint32(&o.LUT381L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT381L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT381L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT381H: Graphic MMU LUT entry 381 high
func (o *GFXMMU_Type) SetLUT381H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT381H.Reg, volatile.LoadUint32(&o.LUT381H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT381H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT381H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT382L: Graphic MMU LUT entry 382 low
func (o *GFXMMU_Type) SetLUT382L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT382L.Reg, volatile.LoadUint32(&o.LUT382L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT382L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT382L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT382L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT382L.Reg, volatile.LoadUint32(&o.LUT382L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT382L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT382L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT382L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT382L.Reg, volatile.LoadUint32(&o.LUT382L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT382L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT382L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT382H: Graphic MMU LUT entry 382 high
func (o *GFXMMU_Type) SetLUT382H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT382H.Reg, volatile.LoadUint32(&o.LUT382H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT382H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT382H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT383L: Graphic MMU LUT entry 383 low
func (o *GFXMMU_Type) SetLUT383L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT383L.Reg, volatile.LoadUint32(&o.LUT383L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT383L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT383L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT383L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT383L.Reg, volatile.LoadUint32(&o.LUT383L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT383L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT383L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT383L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT383L.Reg, volatile.LoadUint32(&o.LUT383L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT383L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT383L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT383H: Graphic MMU LUT entry 383 high
func (o *GFXMMU_Type) SetLUT383H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT383H.Reg, volatile.LoadUint32(&o.LUT383H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT383H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT383H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT384L: Graphic MMU LUT entry 384 low
func (o *GFXMMU_Type) SetLUT384L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT384L.Reg, volatile.LoadUint32(&o.LUT384L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT384L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT384L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT384L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT384L.Reg, volatile.LoadUint32(&o.LUT384L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT384L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT384L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT384L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT384L.Reg, volatile.LoadUint32(&o.LUT384L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT384L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT384L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT384H: Graphic MMU LUT entry 384 high
func (o *GFXMMU_Type) SetLUT384H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT384H.Reg, volatile.LoadUint32(&o.LUT384H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT384H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT384H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT385L: Graphic MMU LUT entry 385 low
func (o *GFXMMU_Type) SetLUT385L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT385L.Reg, volatile.LoadUint32(&o.LUT385L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT385L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT385L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT385L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT385L.Reg, volatile.LoadUint32(&o.LUT385L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT385L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT385L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT385L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT385L.Reg, volatile.LoadUint32(&o.LUT385L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT385L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT385L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT385H: Graphic MMU LUT entry 385 high
func (o *GFXMMU_Type) SetLUT385H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT385H.Reg, volatile.LoadUint32(&o.LUT385H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT385H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT385H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT386L: Graphic MMU LUT entry 386 low
func (o *GFXMMU_Type) SetLUT386L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT386L.Reg, volatile.LoadUint32(&o.LUT386L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT386L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT386L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT386L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT386L.Reg, volatile.LoadUint32(&o.LUT386L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT386L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT386L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT386L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT386L.Reg, volatile.LoadUint32(&o.LUT386L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT386L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT386L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT386H: Graphic MMU LUT entry 386 high
func (o *GFXMMU_Type) SetLUT386H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT386H.Reg, volatile.LoadUint32(&o.LUT386H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT386H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT386H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT387L: Graphic MMU LUT entry 387 low
func (o *GFXMMU_Type) SetLUT387L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT387L.Reg, volatile.LoadUint32(&o.LUT387L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT387L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT387L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT387L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT387L.Reg, volatile.LoadUint32(&o.LUT387L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT387L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT387L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT387L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT387L.Reg, volatile.LoadUint32(&o.LUT387L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT387L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT387L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT387H: Graphic MMU LUT entry 387 high
func (o *GFXMMU_Type) SetLUT387H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT387H.Reg, volatile.LoadUint32(&o.LUT387H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT387H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT387H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT388L: Graphic MMU LUT entry 388 low
func (o *GFXMMU_Type) SetLUT388L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT388L.Reg, volatile.LoadUint32(&o.LUT388L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT388L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT388L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT388L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT388L.Reg, volatile.LoadUint32(&o.LUT388L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT388L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT388L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT388L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT388L.Reg, volatile.LoadUint32(&o.LUT388L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT388L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT388L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT388H: Graphic MMU LUT entry 388 high
func (o *GFXMMU_Type) SetLUT388H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT388H.Reg, volatile.LoadUint32(&o.LUT388H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT388H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT388H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT389L: Graphic MMU LUT entry 389 low
func (o *GFXMMU_Type) SetLUT389L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT389L.Reg, volatile.LoadUint32(&o.LUT389L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT389L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT389L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT389L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT389L.Reg, volatile.LoadUint32(&o.LUT389L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT389L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT389L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT389L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT389L.Reg, volatile.LoadUint32(&o.LUT389L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT389L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT389L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT389H: Graphic MMU LUT entry 389 high
func (o *GFXMMU_Type) SetLUT389H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT389H.Reg, volatile.LoadUint32(&o.LUT389H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT389H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT389H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT390L: Graphic MMU LUT entry 390 low
func (o *GFXMMU_Type) SetLUT390L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT390L.Reg, volatile.LoadUint32(&o.LUT390L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT390L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT390L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT390L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT390L.Reg, volatile.LoadUint32(&o.LUT390L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT390L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT390L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT390L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT390L.Reg, volatile.LoadUint32(&o.LUT390L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT390L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT390L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT390H: Graphic MMU LUT entry 390 high
func (o *GFXMMU_Type) SetLUT390H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT390H.Reg, volatile.LoadUint32(&o.LUT390H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT390H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT390H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT391L: Graphic MMU LUT entry 391 low
func (o *GFXMMU_Type) SetLUT391L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT391L.Reg, volatile.LoadUint32(&o.LUT391L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT391L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT391L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT391L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT391L.Reg, volatile.LoadUint32(&o.LUT391L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT391L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT391L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT391L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT391L.Reg, volatile.LoadUint32(&o.LUT391L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT391L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT391L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT391H: Graphic MMU LUT entry 391 high
func (o *GFXMMU_Type) SetLUT391H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT391H.Reg, volatile.LoadUint32(&o.LUT391H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT391H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT391H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT392L: Graphic MMU LUT entry 392 low
func (o *GFXMMU_Type) SetLUT392L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT392L.Reg, volatile.LoadUint32(&o.LUT392L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT392L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT392L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT392L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT392L.Reg, volatile.LoadUint32(&o.LUT392L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT392L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT392L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT392L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT392L.Reg, volatile.LoadUint32(&o.LUT392L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT392L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT392L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT392H: Graphic MMU LUT entry 392 high
func (o *GFXMMU_Type) SetLUT392H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT392H.Reg, volatile.LoadUint32(&o.LUT392H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT392H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT392H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT393L: Graphic MMU LUT entry 393 low
func (o *GFXMMU_Type) SetLUT393L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT393L.Reg, volatile.LoadUint32(&o.LUT393L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT393L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT393L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT393L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT393L.Reg, volatile.LoadUint32(&o.LUT393L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT393L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT393L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT393L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT393L.Reg, volatile.LoadUint32(&o.LUT393L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT393L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT393L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT393H: Graphic MMU LUT entry 393 high
func (o *GFXMMU_Type) SetLUT393H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT393H.Reg, volatile.LoadUint32(&o.LUT393H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT393H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT393H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT394L: Graphic MMU LUT entry 394 low
func (o *GFXMMU_Type) SetLUT394L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT394L.Reg, volatile.LoadUint32(&o.LUT394L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT394L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT394L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT394L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT394L.Reg, volatile.LoadUint32(&o.LUT394L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT394L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT394L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT394L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT394L.Reg, volatile.LoadUint32(&o.LUT394L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT394L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT394L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT394H: Graphic MMU LUT entry 394 high
func (o *GFXMMU_Type) SetLUT394H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT394H.Reg, volatile.LoadUint32(&o.LUT394H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT394H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT394H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT395L: Graphic MMU LUT entry 395 low
func (o *GFXMMU_Type) SetLUT395L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT395L.Reg, volatile.LoadUint32(&o.LUT395L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT395L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT395L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT395L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT395L.Reg, volatile.LoadUint32(&o.LUT395L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT395L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT395L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT395L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT395L.Reg, volatile.LoadUint32(&o.LUT395L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT395L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT395L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT395H: Graphic MMU LUT entry 395 high
func (o *GFXMMU_Type) SetLUT395H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT395H.Reg, volatile.LoadUint32(&o.LUT395H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT395H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT395H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT396L: Graphic MMU LUT entry 396 low
func (o *GFXMMU_Type) SetLUT396L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT396L.Reg, volatile.LoadUint32(&o.LUT396L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT396L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT396L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT396L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT396L.Reg, volatile.LoadUint32(&o.LUT396L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT396L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT396L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT396L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT396L.Reg, volatile.LoadUint32(&o.LUT396L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT396L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT396L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT396H: Graphic MMU LUT entry 396 high
func (o *GFXMMU_Type) SetLUT396H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT396H.Reg, volatile.LoadUint32(&o.LUT396H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT396H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT396H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT397L: Graphic MMU LUT entry 397 low
func (o *GFXMMU_Type) SetLUT397L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT397L.Reg, volatile.LoadUint32(&o.LUT397L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT397L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT397L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT397L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT397L.Reg, volatile.LoadUint32(&o.LUT397L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT397L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT397L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT397L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT397L.Reg, volatile.LoadUint32(&o.LUT397L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT397L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT397L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT397H: Graphic MMU LUT entry 397 high
func (o *GFXMMU_Type) SetLUT397H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT397H.Reg, volatile.LoadUint32(&o.LUT397H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT397H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT397H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT398L: Graphic MMU LUT entry 398 low
func (o *GFXMMU_Type) SetLUT398L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT398L.Reg, volatile.LoadUint32(&o.LUT398L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT398L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT398L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT398L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT398L.Reg, volatile.LoadUint32(&o.LUT398L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT398L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT398L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT398L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT398L.Reg, volatile.LoadUint32(&o.LUT398L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT398L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT398L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT398H: Graphic MMU LUT entry 398 high
func (o *GFXMMU_Type) SetLUT398H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT398H.Reg, volatile.LoadUint32(&o.LUT398H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT398H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT398H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT399L: Graphic MMU LUT entry 399 low
func (o *GFXMMU_Type) SetLUT399L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT399L.Reg, volatile.LoadUint32(&o.LUT399L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT399L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT399L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT399L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT399L.Reg, volatile.LoadUint32(&o.LUT399L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT399L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT399L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT399L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT399L.Reg, volatile.LoadUint32(&o.LUT399L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT399L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT399L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT399H: Graphic MMU LUT entry 399 high
func (o *GFXMMU_Type) SetLUT399H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT399H.Reg, volatile.LoadUint32(&o.LUT399H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT399H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT399H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT400L: Graphic MMU LUT entry 400 low
func (o *GFXMMU_Type) SetLUT400L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT400L.Reg, volatile.LoadUint32(&o.LUT400L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT400L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT400L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT400L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT400L.Reg, volatile.LoadUint32(&o.LUT400L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT400L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT400L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT400L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT400L.Reg, volatile.LoadUint32(&o.LUT400L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT400L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT400L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT400H: Graphic MMU LUT entry 400 high
func (o *GFXMMU_Type) SetLUT400H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT400H.Reg, volatile.LoadUint32(&o.LUT400H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT400H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT400H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT401L: Graphic MMU LUT entry 401 low
func (o *GFXMMU_Type) SetLUT401L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT401L.Reg, volatile.LoadUint32(&o.LUT401L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT401L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT401L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT401L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT401L.Reg, volatile.LoadUint32(&o.LUT401L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT401L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT401L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT401L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT401L.Reg, volatile.LoadUint32(&o.LUT401L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT401L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT401L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT401H: Graphic MMU LUT entry 401 high
func (o *GFXMMU_Type) SetLUT401H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT401H.Reg, volatile.LoadUint32(&o.LUT401H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT401H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT401H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT402L: Graphic MMU LUT entry 402 low
func (o *GFXMMU_Type) SetLUT402L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT402L.Reg, volatile.LoadUint32(&o.LUT402L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT402L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT402L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT402L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT402L.Reg, volatile.LoadUint32(&o.LUT402L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT402L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT402L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT402L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT402L.Reg, volatile.LoadUint32(&o.LUT402L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT402L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT402L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT402H: Graphic MMU LUT entry 402 high
func (o *GFXMMU_Type) SetLUT402H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT402H.Reg, volatile.LoadUint32(&o.LUT402H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT402H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT402H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT403L: Graphic MMU LUT entry 403 low
func (o *GFXMMU_Type) SetLUT403L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT403L.Reg, volatile.LoadUint32(&o.LUT403L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT403L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT403L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT403L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT403L.Reg, volatile.LoadUint32(&o.LUT403L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT403L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT403L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT403L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT403L.Reg, volatile.LoadUint32(&o.LUT403L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT403L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT403L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT403H: Graphic MMU LUT entry 403 high
func (o *GFXMMU_Type) SetLUT403H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT403H.Reg, volatile.LoadUint32(&o.LUT403H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT403H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT403H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT404L: Graphic MMU LUT entry 404 low
func (o *GFXMMU_Type) SetLUT404L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT404L.Reg, volatile.LoadUint32(&o.LUT404L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT404L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT404L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT404L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT404L.Reg, volatile.LoadUint32(&o.LUT404L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT404L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT404L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT404L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT404L.Reg, volatile.LoadUint32(&o.LUT404L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT404L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT404L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT404H: Graphic MMU LUT entry 404 high
func (o *GFXMMU_Type) SetLUT404H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT404H.Reg, volatile.LoadUint32(&o.LUT404H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT404H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT404H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT405L: Graphic MMU LUT entry 405 low
func (o *GFXMMU_Type) SetLUT405L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT405L.Reg, volatile.LoadUint32(&o.LUT405L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT405L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT405L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT405L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT405L.Reg, volatile.LoadUint32(&o.LUT405L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT405L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT405L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT405L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT405L.Reg, volatile.LoadUint32(&o.LUT405L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT405L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT405L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT405H: Graphic MMU LUT entry 405 high
func (o *GFXMMU_Type) SetLUT405H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT405H.Reg, volatile.LoadUint32(&o.LUT405H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT405H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT405H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT406L: Graphic MMU LUT entry 406 low
func (o *GFXMMU_Type) SetLUT406L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT406L.Reg, volatile.LoadUint32(&o.LUT406L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT406L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT406L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT406L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT406L.Reg, volatile.LoadUint32(&o.LUT406L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT406L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT406L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT406L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT406L.Reg, volatile.LoadUint32(&o.LUT406L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT406L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT406L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT406H: Graphic MMU LUT entry 406 high
func (o *GFXMMU_Type) SetLUT406H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT406H.Reg, volatile.LoadUint32(&o.LUT406H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT406H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT406H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT407L: Graphic MMU LUT entry 407 low
func (o *GFXMMU_Type) SetLUT407L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT407L.Reg, volatile.LoadUint32(&o.LUT407L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT407L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT407L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT407L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT407L.Reg, volatile.LoadUint32(&o.LUT407L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT407L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT407L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT407L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT407L.Reg, volatile.LoadUint32(&o.LUT407L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT407L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT407L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT407H: Graphic MMU LUT entry 407 high
func (o *GFXMMU_Type) SetLUT407H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT407H.Reg, volatile.LoadUint32(&o.LUT407H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT407H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT407H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT408L: Graphic MMU LUT entry 408 low
func (o *GFXMMU_Type) SetLUT408L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT408L.Reg, volatile.LoadUint32(&o.LUT408L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT408L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT408L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT408L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT408L.Reg, volatile.LoadUint32(&o.LUT408L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT408L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT408L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT408L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT408L.Reg, volatile.LoadUint32(&o.LUT408L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT408L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT408L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT408H: Graphic MMU LUT entry 408 high
func (o *GFXMMU_Type) SetLUT408H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT408H.Reg, volatile.LoadUint32(&o.LUT408H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT408H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT408H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT409L: Graphic MMU LUT entry 409 low
func (o *GFXMMU_Type) SetLUT409L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT409L.Reg, volatile.LoadUint32(&o.LUT409L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT409L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT409L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT409L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT409L.Reg, volatile.LoadUint32(&o.LUT409L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT409L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT409L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT409L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT409L.Reg, volatile.LoadUint32(&o.LUT409L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT409L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT409L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT409H: Graphic MMU LUT entry 409 high
func (o *GFXMMU_Type) SetLUT409H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT409H.Reg, volatile.LoadUint32(&o.LUT409H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT409H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT409H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT410L: Graphic MMU LUT entry 410 low
func (o *GFXMMU_Type) SetLUT410L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT410L.Reg, volatile.LoadUint32(&o.LUT410L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT410L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT410L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT410L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT410L.Reg, volatile.LoadUint32(&o.LUT410L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT410L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT410L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT410L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT410L.Reg, volatile.LoadUint32(&o.LUT410L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT410L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT410L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT410H: Graphic MMU LUT entry 410 high
func (o *GFXMMU_Type) SetLUT410H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT410H.Reg, volatile.LoadUint32(&o.LUT410H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT410H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT410H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT411L: Graphic MMU LUT entry 411 low
func (o *GFXMMU_Type) SetLUT411L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT411L.Reg, volatile.LoadUint32(&o.LUT411L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT411L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT411L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT411L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT411L.Reg, volatile.LoadUint32(&o.LUT411L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT411L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT411L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT411L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT411L.Reg, volatile.LoadUint32(&o.LUT411L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT411L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT411L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT411H: Graphic MMU LUT entry 411 high
func (o *GFXMMU_Type) SetLUT411H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT411H.Reg, volatile.LoadUint32(&o.LUT411H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT411H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT411H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT412L: Graphic MMU LUT entry 412 low
func (o *GFXMMU_Type) SetLUT412L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT412L.Reg, volatile.LoadUint32(&o.LUT412L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT412L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT412L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT412L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT412L.Reg, volatile.LoadUint32(&o.LUT412L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT412L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT412L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT412L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT412L.Reg, volatile.LoadUint32(&o.LUT412L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT412L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT412L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT412H: Graphic MMU LUT entry 412 high
func (o *GFXMMU_Type) SetLUT412H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT412H.Reg, volatile.LoadUint32(&o.LUT412H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT412H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT412H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT413L: Graphic MMU LUT entry 413 low
func (o *GFXMMU_Type) SetLUT413L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT413L.Reg, volatile.LoadUint32(&o.LUT413L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT413L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT413L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT413L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT413L.Reg, volatile.LoadUint32(&o.LUT413L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT413L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT413L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT413L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT413L.Reg, volatile.LoadUint32(&o.LUT413L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT413L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT413L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT413H: Graphic MMU LUT entry 413 high
func (o *GFXMMU_Type) SetLUT413H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT413H.Reg, volatile.LoadUint32(&o.LUT413H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT413H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT413H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT414L: Graphic MMU LUT entry 414 low
func (o *GFXMMU_Type) SetLUT414L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT414L.Reg, volatile.LoadUint32(&o.LUT414L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT414L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT414L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT414L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT414L.Reg, volatile.LoadUint32(&o.LUT414L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT414L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT414L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT414L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT414L.Reg, volatile.LoadUint32(&o.LUT414L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT414L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT414L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT414H: Graphic MMU LUT entry 414 high
func (o *GFXMMU_Type) SetLUT414H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT414H.Reg, volatile.LoadUint32(&o.LUT414H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT414H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT414H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT415L: Graphic MMU LUT entry 415 low
func (o *GFXMMU_Type) SetLUT415L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT415L.Reg, volatile.LoadUint32(&o.LUT415L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT415L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT415L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT415L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT415L.Reg, volatile.LoadUint32(&o.LUT415L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT415L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT415L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT415L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT415L.Reg, volatile.LoadUint32(&o.LUT415L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT415L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT415L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT415H: Graphic MMU LUT entry 415 high
func (o *GFXMMU_Type) SetLUT415H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT415H.Reg, volatile.LoadUint32(&o.LUT415H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT415H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT415H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT416L: Graphic MMU LUT entry 416 low
func (o *GFXMMU_Type) SetLUT416L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT416L.Reg, volatile.LoadUint32(&o.LUT416L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT416L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT416L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT416L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT416L.Reg, volatile.LoadUint32(&o.LUT416L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT416L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT416L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT416L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT416L.Reg, volatile.LoadUint32(&o.LUT416L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT416L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT416L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT416H: Graphic MMU LUT entry 416 high
func (o *GFXMMU_Type) SetLUT416H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT416H.Reg, volatile.LoadUint32(&o.LUT416H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT416H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT416H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT417L: Graphic MMU LUT entry 417 low
func (o *GFXMMU_Type) SetLUT417L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT417L.Reg, volatile.LoadUint32(&o.LUT417L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT417L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT417L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT417L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT417L.Reg, volatile.LoadUint32(&o.LUT417L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT417L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT417L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT417L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT417L.Reg, volatile.LoadUint32(&o.LUT417L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT417L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT417L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT417H: Graphic MMU LUT entry 417 high
func (o *GFXMMU_Type) SetLUT417H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT417H.Reg, volatile.LoadUint32(&o.LUT417H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT417H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT417H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT418L: Graphic MMU LUT entry 418 low
func (o *GFXMMU_Type) SetLUT418L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT418L.Reg, volatile.LoadUint32(&o.LUT418L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT418L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT418L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT418L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT418L.Reg, volatile.LoadUint32(&o.LUT418L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT418L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT418L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT418L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT418L.Reg, volatile.LoadUint32(&o.LUT418L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT418L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT418L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT418H: Graphic MMU LUT entry 418 high
func (o *GFXMMU_Type) SetLUT418H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT418H.Reg, volatile.LoadUint32(&o.LUT418H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT418H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT418H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT419L: Graphic MMU LUT entry 419 low
func (o *GFXMMU_Type) SetLUT419L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT419L.Reg, volatile.LoadUint32(&o.LUT419L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT419L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT419L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT419L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT419L.Reg, volatile.LoadUint32(&o.LUT419L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT419L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT419L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT419L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT419L.Reg, volatile.LoadUint32(&o.LUT419L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT419L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT419L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT419H: Graphic MMU LUT entry 419 high
func (o *GFXMMU_Type) SetLUT419H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT419H.Reg, volatile.LoadUint32(&o.LUT419H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT419H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT419H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT420L: Graphic MMU LUT entry 420 low
func (o *GFXMMU_Type) SetLUT420L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT420L.Reg, volatile.LoadUint32(&o.LUT420L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT420L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT420L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT420L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT420L.Reg, volatile.LoadUint32(&o.LUT420L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT420L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT420L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT420L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT420L.Reg, volatile.LoadUint32(&o.LUT420L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT420L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT420L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT420H: Graphic MMU LUT entry 420 high
func (o *GFXMMU_Type) SetLUT420H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT420H.Reg, volatile.LoadUint32(&o.LUT420H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT420H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT420H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT421L: Graphic MMU LUT entry 421 low
func (o *GFXMMU_Type) SetLUT421L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT421L.Reg, volatile.LoadUint32(&o.LUT421L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT421L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT421L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT421L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT421L.Reg, volatile.LoadUint32(&o.LUT421L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT421L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT421L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT421L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT421L.Reg, volatile.LoadUint32(&o.LUT421L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT421L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT421L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT421H: Graphic MMU LUT entry 421 high
func (o *GFXMMU_Type) SetLUT421H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT421H.Reg, volatile.LoadUint32(&o.LUT421H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT421H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT421H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT422L: Graphic MMU LUT entry 422 low
func (o *GFXMMU_Type) SetLUT422L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT422L.Reg, volatile.LoadUint32(&o.LUT422L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT422L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT422L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT422L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT422L.Reg, volatile.LoadUint32(&o.LUT422L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT422L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT422L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT422L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT422L.Reg, volatile.LoadUint32(&o.LUT422L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT422L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT422L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT422H: Graphic MMU LUT entry 422 high
func (o *GFXMMU_Type) SetLUT422H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT422H.Reg, volatile.LoadUint32(&o.LUT422H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT422H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT422H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT423L: Graphic MMU LUT entry 423 low
func (o *GFXMMU_Type) SetLUT423L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT423L.Reg, volatile.LoadUint32(&o.LUT423L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT423L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT423L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT423L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT423L.Reg, volatile.LoadUint32(&o.LUT423L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT423L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT423L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT423L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT423L.Reg, volatile.LoadUint32(&o.LUT423L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT423L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT423L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT423H: Graphic MMU LUT entry 423 high
func (o *GFXMMU_Type) SetLUT423H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT423H.Reg, volatile.LoadUint32(&o.LUT423H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT423H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT423H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT424L: Graphic MMU LUT entry 424 low
func (o *GFXMMU_Type) SetLUT424L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT424L.Reg, volatile.LoadUint32(&o.LUT424L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT424L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT424L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT424L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT424L.Reg, volatile.LoadUint32(&o.LUT424L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT424L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT424L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT424L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT424L.Reg, volatile.LoadUint32(&o.LUT424L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT424L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT424L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT424H: Graphic MMU LUT entry 424 high
func (o *GFXMMU_Type) SetLUT424H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT424H.Reg, volatile.LoadUint32(&o.LUT424H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT424H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT424H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT425L: Graphic MMU LUT entry 425 low
func (o *GFXMMU_Type) SetLUT425L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT425L.Reg, volatile.LoadUint32(&o.LUT425L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT425L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT425L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT425L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT425L.Reg, volatile.LoadUint32(&o.LUT425L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT425L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT425L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT425L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT425L.Reg, volatile.LoadUint32(&o.LUT425L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT425L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT425L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT425H: Graphic MMU LUT entry 425 high
func (o *GFXMMU_Type) SetLUT425H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT425H.Reg, volatile.LoadUint32(&o.LUT425H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT425H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT425H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT426L: Graphic MMU LUT entry 426 low
func (o *GFXMMU_Type) SetLUT426L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT426L.Reg, volatile.LoadUint32(&o.LUT426L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT426L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT426L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT426L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT426L.Reg, volatile.LoadUint32(&o.LUT426L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT426L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT426L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT426L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT426L.Reg, volatile.LoadUint32(&o.LUT426L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT426L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT426L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT426H: Graphic MMU LUT entry 426 high
func (o *GFXMMU_Type) SetLUT426H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT426H.Reg, volatile.LoadUint32(&o.LUT426H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT426H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT426H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT427L: Graphic MMU LUT entry 427 low
func (o *GFXMMU_Type) SetLUT427L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT427L.Reg, volatile.LoadUint32(&o.LUT427L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT427L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT427L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT427L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT427L.Reg, volatile.LoadUint32(&o.LUT427L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT427L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT427L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT427L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT427L.Reg, volatile.LoadUint32(&o.LUT427L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT427L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT427L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT427H: Graphic MMU LUT entry 427 high
func (o *GFXMMU_Type) SetLUT427H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT427H.Reg, volatile.LoadUint32(&o.LUT427H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT427H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT427H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT428L: Graphic MMU LUT entry 428 low
func (o *GFXMMU_Type) SetLUT428L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT428L.Reg, volatile.LoadUint32(&o.LUT428L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT428L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT428L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT428L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT428L.Reg, volatile.LoadUint32(&o.LUT428L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT428L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT428L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT428L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT428L.Reg, volatile.LoadUint32(&o.LUT428L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT428L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT428L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT428H: Graphic MMU LUT entry 428 high
func (o *GFXMMU_Type) SetLUT428H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT428H.Reg, volatile.LoadUint32(&o.LUT428H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT428H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT428H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT429L: Graphic MMU LUT entry 429 low
func (o *GFXMMU_Type) SetLUT429L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT429L.Reg, volatile.LoadUint32(&o.LUT429L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT429L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT429L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT429L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT429L.Reg, volatile.LoadUint32(&o.LUT429L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT429L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT429L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT429L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT429L.Reg, volatile.LoadUint32(&o.LUT429L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT429L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT429L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT429H: Graphic MMU LUT entry 429 high
func (o *GFXMMU_Type) SetLUT429H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT429H.Reg, volatile.LoadUint32(&o.LUT429H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT429H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT429H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT430L: Graphic MMU LUT entry 430 low
func (o *GFXMMU_Type) SetLUT430L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT430L.Reg, volatile.LoadUint32(&o.LUT430L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT430L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT430L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT430L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT430L.Reg, volatile.LoadUint32(&o.LUT430L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT430L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT430L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT430L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT430L.Reg, volatile.LoadUint32(&o.LUT430L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT430L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT430L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT430H: Graphic MMU LUT entry 430 high
func (o *GFXMMU_Type) SetLUT430H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT430H.Reg, volatile.LoadUint32(&o.LUT430H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT430H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT430H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT431L: Graphic MMU LUT entry 431 low
func (o *GFXMMU_Type) SetLUT431L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT431L.Reg, volatile.LoadUint32(&o.LUT431L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT431L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT431L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT431L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT431L.Reg, volatile.LoadUint32(&o.LUT431L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT431L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT431L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT431L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT431L.Reg, volatile.LoadUint32(&o.LUT431L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT431L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT431L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT431H: Graphic MMU LUT entry 431 high
func (o *GFXMMU_Type) SetLUT431H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT431H.Reg, volatile.LoadUint32(&o.LUT431H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT431H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT431H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT432L: Graphic MMU LUT entry 432 low
func (o *GFXMMU_Type) SetLUT432L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT432L.Reg, volatile.LoadUint32(&o.LUT432L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT432L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT432L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT432L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT432L.Reg, volatile.LoadUint32(&o.LUT432L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT432L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT432L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT432L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT432L.Reg, volatile.LoadUint32(&o.LUT432L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT432L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT432L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT432H: Graphic MMU LUT entry 432 high
func (o *GFXMMU_Type) SetLUT432H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT432H.Reg, volatile.LoadUint32(&o.LUT432H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT432H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT432H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT433L: Graphic MMU LUT entry 433 low
func (o *GFXMMU_Type) SetLUT433L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT433L.Reg, volatile.LoadUint32(&o.LUT433L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT433L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT433L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT433L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT433L.Reg, volatile.LoadUint32(&o.LUT433L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT433L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT433L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT433L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT433L.Reg, volatile.LoadUint32(&o.LUT433L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT433L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT433L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT433H: Graphic MMU LUT entry 433 high
func (o *GFXMMU_Type) SetLUT433H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT433H.Reg, volatile.LoadUint32(&o.LUT433H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT433H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT433H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT434L: Graphic MMU LUT entry 434 low
func (o *GFXMMU_Type) SetLUT434L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT434L.Reg, volatile.LoadUint32(&o.LUT434L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT434L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT434L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT434L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT434L.Reg, volatile.LoadUint32(&o.LUT434L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT434L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT434L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT434L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT434L.Reg, volatile.LoadUint32(&o.LUT434L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT434L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT434L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT434H: Graphic MMU LUT entry 434 high
func (o *GFXMMU_Type) SetLUT434H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT434H.Reg, volatile.LoadUint32(&o.LUT434H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT434H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT434H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT435L: Graphic MMU LUT entry 435 low
func (o *GFXMMU_Type) SetLUT435L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT435L.Reg, volatile.LoadUint32(&o.LUT435L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT435L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT435L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT435L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT435L.Reg, volatile.LoadUint32(&o.LUT435L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT435L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT435L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT435L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT435L.Reg, volatile.LoadUint32(&o.LUT435L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT435L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT435L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT435H: Graphic MMU LUT entry 435 high
func (o *GFXMMU_Type) SetLUT435H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT435H.Reg, volatile.LoadUint32(&o.LUT435H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT435H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT435H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT436L: Graphic MMU LUT entry 436 low
func (o *GFXMMU_Type) SetLUT436L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT436L.Reg, volatile.LoadUint32(&o.LUT436L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT436L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT436L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT436L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT436L.Reg, volatile.LoadUint32(&o.LUT436L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT436L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT436L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT436L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT436L.Reg, volatile.LoadUint32(&o.LUT436L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT436L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT436L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT436H: Graphic MMU LUT entry 436 high
func (o *GFXMMU_Type) SetLUT436H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT436H.Reg, volatile.LoadUint32(&o.LUT436H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT436H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT436H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT437L: Graphic MMU LUT entry 437 low
func (o *GFXMMU_Type) SetLUT437L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT437L.Reg, volatile.LoadUint32(&o.LUT437L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT437L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT437L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT437L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT437L.Reg, volatile.LoadUint32(&o.LUT437L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT437L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT437L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT437L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT437L.Reg, volatile.LoadUint32(&o.LUT437L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT437L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT437L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT437H: Graphic MMU LUT entry 437 high
func (o *GFXMMU_Type) SetLUT437H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT437H.Reg, volatile.LoadUint32(&o.LUT437H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT437H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT437H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT438L: Graphic MMU LUT entry 438 low
func (o *GFXMMU_Type) SetLUT438L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT438L.Reg, volatile.LoadUint32(&o.LUT438L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT438L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT438L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT438L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT438L.Reg, volatile.LoadUint32(&o.LUT438L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT438L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT438L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT438L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT438L.Reg, volatile.LoadUint32(&o.LUT438L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT438L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT438L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT438H: Graphic MMU LUT entry 438 high
func (o *GFXMMU_Type) SetLUT438H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT438H.Reg, volatile.LoadUint32(&o.LUT438H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT438H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT438H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT439L: Graphic MMU LUT entry 439 low
func (o *GFXMMU_Type) SetLUT439L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT439L.Reg, volatile.LoadUint32(&o.LUT439L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT439L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT439L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT439L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT439L.Reg, volatile.LoadUint32(&o.LUT439L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT439L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT439L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT439L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT439L.Reg, volatile.LoadUint32(&o.LUT439L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT439L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT439L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT439H: Graphic MMU LUT entry 439 high
func (o *GFXMMU_Type) SetLUT439H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT439H.Reg, volatile.LoadUint32(&o.LUT439H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT439H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT439H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT440L: Graphic MMU LUT entry 440 low
func (o *GFXMMU_Type) SetLUT440L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT440L.Reg, volatile.LoadUint32(&o.LUT440L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT440L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT440L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT440L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT440L.Reg, volatile.LoadUint32(&o.LUT440L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT440L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT440L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT440L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT440L.Reg, volatile.LoadUint32(&o.LUT440L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT440L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT440L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT440H: Graphic MMU LUT entry 440 high
func (o *GFXMMU_Type) SetLUT440H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT440H.Reg, volatile.LoadUint32(&o.LUT440H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT440H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT440H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT441L: Graphic MMU LUT entry 441 low
func (o *GFXMMU_Type) SetLUT441L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT441L.Reg, volatile.LoadUint32(&o.LUT441L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT441L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT441L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT441L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT441L.Reg, volatile.LoadUint32(&o.LUT441L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT441L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT441L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT441L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT441L.Reg, volatile.LoadUint32(&o.LUT441L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT441L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT441L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT441H: Graphic MMU LUT entry 441 high
func (o *GFXMMU_Type) SetLUT441H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT441H.Reg, volatile.LoadUint32(&o.LUT441H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT441H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT441H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT442L: Graphic MMU LUT entry 442 low
func (o *GFXMMU_Type) SetLUT442L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT442L.Reg, volatile.LoadUint32(&o.LUT442L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT442L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT442L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT442L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT442L.Reg, volatile.LoadUint32(&o.LUT442L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT442L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT442L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT442L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT442L.Reg, volatile.LoadUint32(&o.LUT442L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT442L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT442L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT442H: Graphic MMU LUT entry 442 high
func (o *GFXMMU_Type) SetLUT442H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT442H.Reg, volatile.LoadUint32(&o.LUT442H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT442H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT442H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT443L: Graphic MMU LUT entry 443 low
func (o *GFXMMU_Type) SetLUT443L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT443L.Reg, volatile.LoadUint32(&o.LUT443L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT443L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT443L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT443L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT443L.Reg, volatile.LoadUint32(&o.LUT443L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT443L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT443L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT443L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT443L.Reg, volatile.LoadUint32(&o.LUT443L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT443L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT443L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT443H: Graphic MMU LUT entry 443 high
func (o *GFXMMU_Type) SetLUT443H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT443H.Reg, volatile.LoadUint32(&o.LUT443H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT443H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT443H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT444L: Graphic MMU LUT entry 444 low
func (o *GFXMMU_Type) SetLUT444L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT444L.Reg, volatile.LoadUint32(&o.LUT444L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT444L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT444L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT444L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT444L.Reg, volatile.LoadUint32(&o.LUT444L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT444L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT444L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT444L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT444L.Reg, volatile.LoadUint32(&o.LUT444L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT444L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT444L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT444H: Graphic MMU LUT entry 444 high
func (o *GFXMMU_Type) SetLUT444H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT444H.Reg, volatile.LoadUint32(&o.LUT444H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT444H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT444H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT445L: Graphic MMU LUT entry 445 low
func (o *GFXMMU_Type) SetLUT445L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT445L.Reg, volatile.LoadUint32(&o.LUT445L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT445L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT445L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT445L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT445L.Reg, volatile.LoadUint32(&o.LUT445L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT445L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT445L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT445L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT445L.Reg, volatile.LoadUint32(&o.LUT445L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT445L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT445L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT445H: Graphic MMU LUT entry 445 high
func (o *GFXMMU_Type) SetLUT445H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT445H.Reg, volatile.LoadUint32(&o.LUT445H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT445H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT445H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT446L: Graphic MMU LUT entry 446 low
func (o *GFXMMU_Type) SetLUT446L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT446L.Reg, volatile.LoadUint32(&o.LUT446L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT446L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT446L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT446L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT446L.Reg, volatile.LoadUint32(&o.LUT446L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT446L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT446L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT446L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT446L.Reg, volatile.LoadUint32(&o.LUT446L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT446L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT446L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT446H: Graphic MMU LUT entry 446 high
func (o *GFXMMU_Type) SetLUT446H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT446H.Reg, volatile.LoadUint32(&o.LUT446H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT446H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT446H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT447L: Graphic MMU LUT entry 447 low
func (o *GFXMMU_Type) SetLUT447L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT447L.Reg, volatile.LoadUint32(&o.LUT447L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT447L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT447L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT447L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT447L.Reg, volatile.LoadUint32(&o.LUT447L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT447L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT447L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT447L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT447L.Reg, volatile.LoadUint32(&o.LUT447L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT447L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT447L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT447H: Graphic MMU LUT entry 447 high
func (o *GFXMMU_Type) SetLUT447H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT447H.Reg, volatile.LoadUint32(&o.LUT447H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT447H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT447H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT448L: Graphic MMU LUT entry 448 low
func (o *GFXMMU_Type) SetLUT448L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT448L.Reg, volatile.LoadUint32(&o.LUT448L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT448L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT448L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT448L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT448L.Reg, volatile.LoadUint32(&o.LUT448L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT448L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT448L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT448L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT448L.Reg, volatile.LoadUint32(&o.LUT448L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT448L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT448L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT448H: Graphic MMU LUT entry 448 high
func (o *GFXMMU_Type) SetLUT448H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT448H.Reg, volatile.LoadUint32(&o.LUT448H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT448H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT448H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT449L: Graphic MMU LUT entry 449 low
func (o *GFXMMU_Type) SetLUT449L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT449L.Reg, volatile.LoadUint32(&o.LUT449L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT449L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT449L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT449L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT449L.Reg, volatile.LoadUint32(&o.LUT449L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT449L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT449L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT449L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT449L.Reg, volatile.LoadUint32(&o.LUT449L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT449L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT449L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT449H: Graphic MMU LUT entry 449 high
func (o *GFXMMU_Type) SetLUT449H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT449H.Reg, volatile.LoadUint32(&o.LUT449H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT449H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT449H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT450L: Graphic MMU LUT entry 450 low
func (o *GFXMMU_Type) SetLUT450L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT450L.Reg, volatile.LoadUint32(&o.LUT450L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT450L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT450L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT450L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT450L.Reg, volatile.LoadUint32(&o.LUT450L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT450L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT450L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT450L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT450L.Reg, volatile.LoadUint32(&o.LUT450L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT450L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT450L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT450H: Graphic MMU LUT entry 450 high
func (o *GFXMMU_Type) SetLUT450H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT450H.Reg, volatile.LoadUint32(&o.LUT450H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT450H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT450H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT451L: Graphic MMU LUT entry 451 low
func (o *GFXMMU_Type) SetLUT451L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT451L.Reg, volatile.LoadUint32(&o.LUT451L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT451L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT451L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT451L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT451L.Reg, volatile.LoadUint32(&o.LUT451L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT451L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT451L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT451L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT451L.Reg, volatile.LoadUint32(&o.LUT451L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT451L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT451L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT451H: Graphic MMU LUT entry 451 high
func (o *GFXMMU_Type) SetLUT451H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT451H.Reg, volatile.LoadUint32(&o.LUT451H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT451H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT451H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT452L: Graphic MMU LUT entry 452 low
func (o *GFXMMU_Type) SetLUT452L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT452L.Reg, volatile.LoadUint32(&o.LUT452L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT452L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT452L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT452L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT452L.Reg, volatile.LoadUint32(&o.LUT452L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT452L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT452L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT452L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT452L.Reg, volatile.LoadUint32(&o.LUT452L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT452L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT452L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT452H: Graphic MMU LUT entry 452 high
func (o *GFXMMU_Type) SetLUT452H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT452H.Reg, volatile.LoadUint32(&o.LUT452H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT452H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT452H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT453L: Graphic MMU LUT entry 453 low
func (o *GFXMMU_Type) SetLUT453L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT453L.Reg, volatile.LoadUint32(&o.LUT453L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT453L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT453L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT453L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT453L.Reg, volatile.LoadUint32(&o.LUT453L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT453L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT453L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT453L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT453L.Reg, volatile.LoadUint32(&o.LUT453L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT453L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT453L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT453H: Graphic MMU LUT entry 453 high
func (o *GFXMMU_Type) SetLUT453H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT453H.Reg, volatile.LoadUint32(&o.LUT453H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT453H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT453H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT454L: Graphic MMU LUT entry 454 low
func (o *GFXMMU_Type) SetLUT454L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT454L.Reg, volatile.LoadUint32(&o.LUT454L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT454L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT454L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT454L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT454L.Reg, volatile.LoadUint32(&o.LUT454L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT454L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT454L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT454L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT454L.Reg, volatile.LoadUint32(&o.LUT454L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT454L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT454L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT454H: Graphic MMU LUT entry 454 high
func (o *GFXMMU_Type) SetLUT454H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT454H.Reg, volatile.LoadUint32(&o.LUT454H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT454H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT454H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT455L: Graphic MMU LUT entry 455 low
func (o *GFXMMU_Type) SetLUT455L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT455L.Reg, volatile.LoadUint32(&o.LUT455L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT455L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT455L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT455L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT455L.Reg, volatile.LoadUint32(&o.LUT455L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT455L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT455L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT455L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT455L.Reg, volatile.LoadUint32(&o.LUT455L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT455L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT455L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT455H: Graphic MMU LUT entry 455 high
func (o *GFXMMU_Type) SetLUT455H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT455H.Reg, volatile.LoadUint32(&o.LUT455H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT455H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT455H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT456L: Graphic MMU LUT entry 456 low
func (o *GFXMMU_Type) SetLUT456L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT456L.Reg, volatile.LoadUint32(&o.LUT456L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT456L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT456L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT456L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT456L.Reg, volatile.LoadUint32(&o.LUT456L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT456L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT456L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT456L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT456L.Reg, volatile.LoadUint32(&o.LUT456L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT456L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT456L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT456H: Graphic MMU LUT entry 456 high
func (o *GFXMMU_Type) SetLUT456H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT456H.Reg, volatile.LoadUint32(&o.LUT456H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT456H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT456H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT457L: Graphic MMU LUT entry 457 low
func (o *GFXMMU_Type) SetLUT457L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT457L.Reg, volatile.LoadUint32(&o.LUT457L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT457L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT457L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT457L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT457L.Reg, volatile.LoadUint32(&o.LUT457L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT457L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT457L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT457L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT457L.Reg, volatile.LoadUint32(&o.LUT457L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT457L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT457L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT457H: Graphic MMU LUT entry 457 high
func (o *GFXMMU_Type) SetLUT457H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT457H.Reg, volatile.LoadUint32(&o.LUT457H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT457H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT457H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT458L: Graphic MMU LUT entry 458 low
func (o *GFXMMU_Type) SetLUT458L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT458L.Reg, volatile.LoadUint32(&o.LUT458L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT458L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT458L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT458L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT458L.Reg, volatile.LoadUint32(&o.LUT458L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT458L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT458L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT458L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT458L.Reg, volatile.LoadUint32(&o.LUT458L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT458L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT458L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT458H: Graphic MMU LUT entry 458 high
func (o *GFXMMU_Type) SetLUT458H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT458H.Reg, volatile.LoadUint32(&o.LUT458H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT458H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT458H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT459L: Graphic MMU LUT entry 459 low
func (o *GFXMMU_Type) SetLUT459L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT459L.Reg, volatile.LoadUint32(&o.LUT459L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT459L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT459L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT459L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT459L.Reg, volatile.LoadUint32(&o.LUT459L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT459L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT459L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT459L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT459L.Reg, volatile.LoadUint32(&o.LUT459L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT459L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT459L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT459H: Graphic MMU LUT entry 459 high
func (o *GFXMMU_Type) SetLUT459H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT459H.Reg, volatile.LoadUint32(&o.LUT459H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT459H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT459H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT460L: Graphic MMU LUT entry 460 low
func (o *GFXMMU_Type) SetLUT460L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT460L.Reg, volatile.LoadUint32(&o.LUT460L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT460L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT460L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT460L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT460L.Reg, volatile.LoadUint32(&o.LUT460L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT460L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT460L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT460L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT460L.Reg, volatile.LoadUint32(&o.LUT460L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT460L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT460L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT460H: Graphic MMU LUT entry 460 high
func (o *GFXMMU_Type) SetLUT460H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT460H.Reg, volatile.LoadUint32(&o.LUT460H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT460H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT460H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT461L: Graphic MMU LUT entry 461 low
func (o *GFXMMU_Type) SetLUT461L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT461L.Reg, volatile.LoadUint32(&o.LUT461L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT461L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT461L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT461L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT461L.Reg, volatile.LoadUint32(&o.LUT461L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT461L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT461L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT461L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT461L.Reg, volatile.LoadUint32(&o.LUT461L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT461L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT461L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT461H: Graphic MMU LUT entry 461 high
func (o *GFXMMU_Type) SetLUT461H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT461H.Reg, volatile.LoadUint32(&o.LUT461H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT461H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT461H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT462L: Graphic MMU LUT entry 462 low
func (o *GFXMMU_Type) SetLUT462L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT462L.Reg, volatile.LoadUint32(&o.LUT462L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT462L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT462L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT462L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT462L.Reg, volatile.LoadUint32(&o.LUT462L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT462L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT462L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT462L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT462L.Reg, volatile.LoadUint32(&o.LUT462L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT462L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT462L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT462H: Graphic MMU LUT entry 462 high
func (o *GFXMMU_Type) SetLUT462H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT462H.Reg, volatile.LoadUint32(&o.LUT462H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT462H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT462H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT463L: Graphic MMU LUT entry 463 low
func (o *GFXMMU_Type) SetLUT463L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT463L.Reg, volatile.LoadUint32(&o.LUT463L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT463L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT463L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT463L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT463L.Reg, volatile.LoadUint32(&o.LUT463L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT463L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT463L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT463L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT463L.Reg, volatile.LoadUint32(&o.LUT463L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT463L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT463L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT463H: Graphic MMU LUT entry 463 high
func (o *GFXMMU_Type) SetLUT463H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT463H.Reg, volatile.LoadUint32(&o.LUT463H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT463H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT463H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT464L: Graphic MMU LUT entry 464 low
func (o *GFXMMU_Type) SetLUT464L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT464L.Reg, volatile.LoadUint32(&o.LUT464L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT464L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT464L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT464L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT464L.Reg, volatile.LoadUint32(&o.LUT464L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT464L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT464L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT464L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT464L.Reg, volatile.LoadUint32(&o.LUT464L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT464L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT464L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT464H: Graphic MMU LUT entry 464 high
func (o *GFXMMU_Type) SetLUT464H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT464H.Reg, volatile.LoadUint32(&o.LUT464H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT464H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT464H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT465L: Graphic MMU LUT entry 465 low
func (o *GFXMMU_Type) SetLUT465L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT465L.Reg, volatile.LoadUint32(&o.LUT465L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT465L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT465L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT465L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT465L.Reg, volatile.LoadUint32(&o.LUT465L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT465L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT465L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT465L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT465L.Reg, volatile.LoadUint32(&o.LUT465L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT465L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT465L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT465H: Graphic MMU LUT entry 465 high
func (o *GFXMMU_Type) SetLUT465H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT465H.Reg, volatile.LoadUint32(&o.LUT465H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT465H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT465H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT466L: Graphic MMU LUT entry 466 low
func (o *GFXMMU_Type) SetLUT466L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT466L.Reg, volatile.LoadUint32(&o.LUT466L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT466L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT466L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT466L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT466L.Reg, volatile.LoadUint32(&o.LUT466L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT466L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT466L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT466L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT466L.Reg, volatile.LoadUint32(&o.LUT466L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT466L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT466L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT466H: Graphic MMU LUT entry 466 high
func (o *GFXMMU_Type) SetLUT466H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT466H.Reg, volatile.LoadUint32(&o.LUT466H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT466H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT466H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT467L: Graphic MMU LUT entry 467 low
func (o *GFXMMU_Type) SetLUT467L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT467L.Reg, volatile.LoadUint32(&o.LUT467L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT467L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT467L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT467L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT467L.Reg, volatile.LoadUint32(&o.LUT467L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT467L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT467L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT467L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT467L.Reg, volatile.LoadUint32(&o.LUT467L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT467L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT467L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT467H: Graphic MMU LUT entry 467 high
func (o *GFXMMU_Type) SetLUT467H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT467H.Reg, volatile.LoadUint32(&o.LUT467H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT467H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT467H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT468L: Graphic MMU LUT entry 468 low
func (o *GFXMMU_Type) SetLUT468L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT468L.Reg, volatile.LoadUint32(&o.LUT468L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT468L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT468L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT468L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT468L.Reg, volatile.LoadUint32(&o.LUT468L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT468L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT468L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT468L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT468L.Reg, volatile.LoadUint32(&o.LUT468L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT468L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT468L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT468H: Graphic MMU LUT entry 468 high
func (o *GFXMMU_Type) SetLUT468H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT468H.Reg, volatile.LoadUint32(&o.LUT468H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT468H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT468H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT469L: Graphic MMU LUT entry 469 low
func (o *GFXMMU_Type) SetLUT469L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT469L.Reg, volatile.LoadUint32(&o.LUT469L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT469L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT469L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT469L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT469L.Reg, volatile.LoadUint32(&o.LUT469L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT469L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT469L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT469L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT469L.Reg, volatile.LoadUint32(&o.LUT469L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT469L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT469L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT469H: Graphic MMU LUT entry 469 high
func (o *GFXMMU_Type) SetLUT469H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT469H.Reg, volatile.LoadUint32(&o.LUT469H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT469H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT469H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT470L: Graphic MMU LUT entry 470 low
func (o *GFXMMU_Type) SetLUT470L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT470L.Reg, volatile.LoadUint32(&o.LUT470L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT470L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT470L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT470L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT470L.Reg, volatile.LoadUint32(&o.LUT470L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT470L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT470L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT470L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT470L.Reg, volatile.LoadUint32(&o.LUT470L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT470L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT470L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT470H: Graphic MMU LUT entry 470 high
func (o *GFXMMU_Type) SetLUT470H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT470H.Reg, volatile.LoadUint32(&o.LUT470H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT470H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT470H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT471L: Graphic MMU LUT entry 471 low
func (o *GFXMMU_Type) SetLUT471L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT471L.Reg, volatile.LoadUint32(&o.LUT471L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT471L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT471L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT471L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT471L.Reg, volatile.LoadUint32(&o.LUT471L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT471L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT471L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT471L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT471L.Reg, volatile.LoadUint32(&o.LUT471L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT471L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT471L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT471H: Graphic MMU LUT entry 471 high
func (o *GFXMMU_Type) SetLUT471H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT471H.Reg, volatile.LoadUint32(&o.LUT471H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT471H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT471H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT472L: Graphic MMU LUT entry 472 low
func (o *GFXMMU_Type) SetLUT472L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT472L.Reg, volatile.LoadUint32(&o.LUT472L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT472L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT472L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT472L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT472L.Reg, volatile.LoadUint32(&o.LUT472L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT472L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT472L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT472L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT472L.Reg, volatile.LoadUint32(&o.LUT472L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT472L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT472L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT472H: Graphic MMU LUT entry 472 high
func (o *GFXMMU_Type) SetLUT472H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT472H.Reg, volatile.LoadUint32(&o.LUT472H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT472H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT472H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT473L: Graphic MMU LUT entry 473 low
func (o *GFXMMU_Type) SetLUT473L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT473L.Reg, volatile.LoadUint32(&o.LUT473L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT473L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT473L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT473L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT473L.Reg, volatile.LoadUint32(&o.LUT473L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT473L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT473L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT473L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT473L.Reg, volatile.LoadUint32(&o.LUT473L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT473L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT473L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT473H: Graphic MMU LUT entry 473 high
func (o *GFXMMU_Type) SetLUT473H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT473H.Reg, volatile.LoadUint32(&o.LUT473H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT473H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT473H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT474L: Graphic MMU LUT entry 474 low
func (o *GFXMMU_Type) SetLUT474L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT474L.Reg, volatile.LoadUint32(&o.LUT474L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT474L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT474L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT474L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT474L.Reg, volatile.LoadUint32(&o.LUT474L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT474L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT474L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT474L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT474L.Reg, volatile.LoadUint32(&o.LUT474L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT474L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT474L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT474H: Graphic MMU LUT entry 474 high
func (o *GFXMMU_Type) SetLUT474H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT474H.Reg, volatile.LoadUint32(&o.LUT474H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT474H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT474H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT475L: Graphic MMU LUT entry 475 low
func (o *GFXMMU_Type) SetLUT475L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT475L.Reg, volatile.LoadUint32(&o.LUT475L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT475L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT475L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT475L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT475L.Reg, volatile.LoadUint32(&o.LUT475L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT475L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT475L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT475L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT475L.Reg, volatile.LoadUint32(&o.LUT475L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT475L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT475L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT475H: Graphic MMU LUT entry 475 high
func (o *GFXMMU_Type) SetLUT475H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT475H.Reg, volatile.LoadUint32(&o.LUT475H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT475H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT475H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT476L: Graphic MMU LUT entry 476 low
func (o *GFXMMU_Type) SetLUT476L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT476L.Reg, volatile.LoadUint32(&o.LUT476L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT476L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT476L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT476L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT476L.Reg, volatile.LoadUint32(&o.LUT476L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT476L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT476L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT476L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT476L.Reg, volatile.LoadUint32(&o.LUT476L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT476L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT476L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT476H: Graphic MMU LUT entry 476 high
func (o *GFXMMU_Type) SetLUT476H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT476H.Reg, volatile.LoadUint32(&o.LUT476H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT476H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT476H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT477L: Graphic MMU LUT entry 477 low
func (o *GFXMMU_Type) SetLUT477L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT477L.Reg, volatile.LoadUint32(&o.LUT477L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT477L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT477L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT477L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT477L.Reg, volatile.LoadUint32(&o.LUT477L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT477L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT477L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT477L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT477L.Reg, volatile.LoadUint32(&o.LUT477L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT477L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT477L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT477H: Graphic MMU LUT entry 477 high
func (o *GFXMMU_Type) SetLUT477H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT477H.Reg, volatile.LoadUint32(&o.LUT477H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT477H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT477H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT478L: Graphic MMU LUT entry 478 low
func (o *GFXMMU_Type) SetLUT478L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT478L.Reg, volatile.LoadUint32(&o.LUT478L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT478L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT478L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT478L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT478L.Reg, volatile.LoadUint32(&o.LUT478L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT478L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT478L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT478L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT478L.Reg, volatile.LoadUint32(&o.LUT478L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT478L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT478L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT478H: Graphic MMU LUT entry 478 high
func (o *GFXMMU_Type) SetLUT478H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT478H.Reg, volatile.LoadUint32(&o.LUT478H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT478H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT478H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT479L: Graphic MMU LUT entry 479 low
func (o *GFXMMU_Type) SetLUT479L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT479L.Reg, volatile.LoadUint32(&o.LUT479L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT479L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT479L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT479L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT479L.Reg, volatile.LoadUint32(&o.LUT479L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT479L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT479L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT479L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT479L.Reg, volatile.LoadUint32(&o.LUT479L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT479L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT479L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT479H: Graphic MMU LUT entry 479 high
func (o *GFXMMU_Type) SetLUT479H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT479H.Reg, volatile.LoadUint32(&o.LUT479H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT479H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT479H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT480L: Graphic MMU LUT entry 480 low
func (o *GFXMMU_Type) SetLUT480L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT480L.Reg, volatile.LoadUint32(&o.LUT480L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT480L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT480L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT480L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT480L.Reg, volatile.LoadUint32(&o.LUT480L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT480L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT480L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT480L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT480L.Reg, volatile.LoadUint32(&o.LUT480L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT480L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT480L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT480H: Graphic MMU LUT entry 480 high
func (o *GFXMMU_Type) SetLUT480H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT480H.Reg, volatile.LoadUint32(&o.LUT480H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT480H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT480H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT481L: Graphic MMU LUT entry 481 low
func (o *GFXMMU_Type) SetLUT481L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT481L.Reg, volatile.LoadUint32(&o.LUT481L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT481L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT481L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT481L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT481L.Reg, volatile.LoadUint32(&o.LUT481L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT481L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT481L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT481L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT481L.Reg, volatile.LoadUint32(&o.LUT481L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT481L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT481L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT481H: Graphic MMU LUT entry 481 high
func (o *GFXMMU_Type) SetLUT481H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT481H.Reg, volatile.LoadUint32(&o.LUT481H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT481H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT481H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT482L: Graphic MMU LUT entry 482 low
func (o *GFXMMU_Type) SetLUT482L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT482L.Reg, volatile.LoadUint32(&o.LUT482L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT482L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT482L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT482L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT482L.Reg, volatile.LoadUint32(&o.LUT482L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT482L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT482L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT482L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT482L.Reg, volatile.LoadUint32(&o.LUT482L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT482L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT482L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT482H: Graphic MMU LUT entry 482 high
func (o *GFXMMU_Type) SetLUT482H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT482H.Reg, volatile.LoadUint32(&o.LUT482H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT482H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT482H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT483L: Graphic MMU LUT entry 483 low
func (o *GFXMMU_Type) SetLUT483L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT483L.Reg, volatile.LoadUint32(&o.LUT483L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT483L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT483L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT483L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT483L.Reg, volatile.LoadUint32(&o.LUT483L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT483L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT483L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT483L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT483L.Reg, volatile.LoadUint32(&o.LUT483L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT483L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT483L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT483H: Graphic MMU LUT entry 483 high
func (o *GFXMMU_Type) SetLUT483H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT483H.Reg, volatile.LoadUint32(&o.LUT483H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT483H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT483H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT484L: Graphic MMU LUT entry 484 low
func (o *GFXMMU_Type) SetLUT484L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT484L.Reg, volatile.LoadUint32(&o.LUT484L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT484L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT484L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT484L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT484L.Reg, volatile.LoadUint32(&o.LUT484L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT484L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT484L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT484L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT484L.Reg, volatile.LoadUint32(&o.LUT484L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT484L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT484L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT484H: Graphic MMU LUT entry 484 high
func (o *GFXMMU_Type) SetLUT484H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT484H.Reg, volatile.LoadUint32(&o.LUT484H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT484H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT484H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT485L: Graphic MMU LUT entry 485 low
func (o *GFXMMU_Type) SetLUT485L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT485L.Reg, volatile.LoadUint32(&o.LUT485L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT485L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT485L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT485L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT485L.Reg, volatile.LoadUint32(&o.LUT485L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT485L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT485L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT485L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT485L.Reg, volatile.LoadUint32(&o.LUT485L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT485L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT485L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT485H: Graphic MMU LUT entry 485 high
func (o *GFXMMU_Type) SetLUT485H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT485H.Reg, volatile.LoadUint32(&o.LUT485H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT485H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT485H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT486L: Graphic MMU LUT entry 486 low
func (o *GFXMMU_Type) SetLUT486L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT486L.Reg, volatile.LoadUint32(&o.LUT486L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT486L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT486L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT486L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT486L.Reg, volatile.LoadUint32(&o.LUT486L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT486L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT486L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT486L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT486L.Reg, volatile.LoadUint32(&o.LUT486L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT486L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT486L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT486H: Graphic MMU LUT entry 486 high
func (o *GFXMMU_Type) SetLUT486H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT486H.Reg, volatile.LoadUint32(&o.LUT486H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT486H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT486H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT487L: Graphic MMU LUT entry 487 low
func (o *GFXMMU_Type) SetLUT487L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT487L.Reg, volatile.LoadUint32(&o.LUT487L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT487L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT487L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT487L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT487L.Reg, volatile.LoadUint32(&o.LUT487L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT487L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT487L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT487L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT487L.Reg, volatile.LoadUint32(&o.LUT487L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT487L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT487L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT487H: Graphic MMU LUT entry 487 high
func (o *GFXMMU_Type) SetLUT487H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT487H.Reg, volatile.LoadUint32(&o.LUT487H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT487H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT487H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT488L: Graphic MMU LUT entry 488 low
func (o *GFXMMU_Type) SetLUT488L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT488L.Reg, volatile.LoadUint32(&o.LUT488L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT488L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT488L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT488L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT488L.Reg, volatile.LoadUint32(&o.LUT488L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT488L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT488L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT488L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT488L.Reg, volatile.LoadUint32(&o.LUT488L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT488L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT488L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT488H: Graphic MMU LUT entry 488 high
func (o *GFXMMU_Type) SetLUT488H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT488H.Reg, volatile.LoadUint32(&o.LUT488H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT488H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT488H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT489L: Graphic MMU LUT entry 489 low
func (o *GFXMMU_Type) SetLUT489L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT489L.Reg, volatile.LoadUint32(&o.LUT489L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT489L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT489L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT489L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT489L.Reg, volatile.LoadUint32(&o.LUT489L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT489L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT489L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT489L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT489L.Reg, volatile.LoadUint32(&o.LUT489L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT489L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT489L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT489H: Graphic MMU LUT entry 489 high
func (o *GFXMMU_Type) SetLUT489H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT489H.Reg, volatile.LoadUint32(&o.LUT489H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT489H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT489H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT490L: Graphic MMU LUT entry 490 low
func (o *GFXMMU_Type) SetLUT490L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT490L.Reg, volatile.LoadUint32(&o.LUT490L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT490L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT490L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT490L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT490L.Reg, volatile.LoadUint32(&o.LUT490L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT490L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT490L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT490L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT490L.Reg, volatile.LoadUint32(&o.LUT490L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT490L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT490L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT490H: Graphic MMU LUT entry 490 high
func (o *GFXMMU_Type) SetLUT490H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT490H.Reg, volatile.LoadUint32(&o.LUT490H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT490H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT490H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT491L: Graphic MMU LUT entry 491 low
func (o *GFXMMU_Type) SetLUT491L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT491L.Reg, volatile.LoadUint32(&o.LUT491L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT491L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT491L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT491L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT491L.Reg, volatile.LoadUint32(&o.LUT491L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT491L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT491L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT491L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT491L.Reg, volatile.LoadUint32(&o.LUT491L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT491L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT491L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT491H: Graphic MMU LUT entry 491 high
func (o *GFXMMU_Type) SetLUT491H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT491H.Reg, volatile.LoadUint32(&o.LUT491H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT491H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT491H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT492L: Graphic MMU LUT entry 492 low
func (o *GFXMMU_Type) SetLUT492L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT492L.Reg, volatile.LoadUint32(&o.LUT492L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT492L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT492L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT492L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT492L.Reg, volatile.LoadUint32(&o.LUT492L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT492L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT492L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT492L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT492L.Reg, volatile.LoadUint32(&o.LUT492L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT492L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT492L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT492H: Graphic MMU LUT entry 492 high
func (o *GFXMMU_Type) SetLUT492H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT492H.Reg, volatile.LoadUint32(&o.LUT492H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT492H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT492H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT493L: Graphic MMU LUT entry 493 low
func (o *GFXMMU_Type) SetLUT493L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT493L.Reg, volatile.LoadUint32(&o.LUT493L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT493L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT493L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT493L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT493L.Reg, volatile.LoadUint32(&o.LUT493L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT493L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT493L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT493L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT493L.Reg, volatile.LoadUint32(&o.LUT493L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT493L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT493L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT493H: Graphic MMU LUT entry 493 high
func (o *GFXMMU_Type) SetLUT493H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT493H.Reg, volatile.LoadUint32(&o.LUT493H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT493H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT493H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT494L: Graphic MMU LUT entry 494 low
func (o *GFXMMU_Type) SetLUT494L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT494L.Reg, volatile.LoadUint32(&o.LUT494L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT494L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT494L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT494L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT494L.Reg, volatile.LoadUint32(&o.LUT494L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT494L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT494L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT494L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT494L.Reg, volatile.LoadUint32(&o.LUT494L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT494L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT494L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT494H: Graphic MMU LUT entry 494 high
func (o *GFXMMU_Type) SetLUT494H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT494H.Reg, volatile.LoadUint32(&o.LUT494H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT494H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT494H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT495L: Graphic MMU LUT entry 495 low
func (o *GFXMMU_Type) SetLUT495L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT495L.Reg, volatile.LoadUint32(&o.LUT495L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT495L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT495L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT495L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT495L.Reg, volatile.LoadUint32(&o.LUT495L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT495L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT495L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT495L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT495L.Reg, volatile.LoadUint32(&o.LUT495L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT495L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT495L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT495H: Graphic MMU LUT entry 495 high
func (o *GFXMMU_Type) SetLUT495H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT495H.Reg, volatile.LoadUint32(&o.LUT495H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT495H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT495H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT496L: Graphic MMU LUT entry 496 low
func (o *GFXMMU_Type) SetLUT496L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT496L.Reg, volatile.LoadUint32(&o.LUT496L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT496L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT496L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT496L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT496L.Reg, volatile.LoadUint32(&o.LUT496L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT496L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT496L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT496L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT496L.Reg, volatile.LoadUint32(&o.LUT496L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT496L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT496L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT496H: Graphic MMU LUT entry 496 high
func (o *GFXMMU_Type) SetLUT496H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT496H.Reg, volatile.LoadUint32(&o.LUT496H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT496H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT496H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT497L: Graphic MMU LUT entry 497 low
func (o *GFXMMU_Type) SetLUT497L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT497L.Reg, volatile.LoadUint32(&o.LUT497L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT497L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT497L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT497L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT497L.Reg, volatile.LoadUint32(&o.LUT497L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT497L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT497L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT497L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT497L.Reg, volatile.LoadUint32(&o.LUT497L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT497L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT497L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT497H: Graphic MMU LUT entry 497 high
func (o *GFXMMU_Type) SetLUT497H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT497H.Reg, volatile.LoadUint32(&o.LUT497H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT497H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT497H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT498L: Graphic MMU LUT entry 498 low
func (o *GFXMMU_Type) SetLUT498L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT498L.Reg, volatile.LoadUint32(&o.LUT498L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT498L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT498L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT498L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT498L.Reg, volatile.LoadUint32(&o.LUT498L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT498L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT498L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT498L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT498L.Reg, volatile.LoadUint32(&o.LUT498L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT498L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT498L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT498H: Graphic MMU LUT entry 498 high
func (o *GFXMMU_Type) SetLUT498H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT498H.Reg, volatile.LoadUint32(&o.LUT498H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT498H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT498H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT499L: Graphic MMU LUT entry 499 low
func (o *GFXMMU_Type) SetLUT499L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT499L.Reg, volatile.LoadUint32(&o.LUT499L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT499L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT499L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT499L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT499L.Reg, volatile.LoadUint32(&o.LUT499L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT499L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT499L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT499L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT499L.Reg, volatile.LoadUint32(&o.LUT499L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT499L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT499L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT499H: Graphic MMU LUT entry 499 high
func (o *GFXMMU_Type) SetLUT499H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT499H.Reg, volatile.LoadUint32(&o.LUT499H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT499H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT499H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT500L: Graphic MMU LUT entry 500 low
func (o *GFXMMU_Type) SetLUT500L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT500L.Reg, volatile.LoadUint32(&o.LUT500L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT500L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT500L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT500L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT500L.Reg, volatile.LoadUint32(&o.LUT500L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT500L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT500L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT500L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT500L.Reg, volatile.LoadUint32(&o.LUT500L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT500L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT500L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT500H: Graphic MMU LUT entry 500 high
func (o *GFXMMU_Type) SetLUT500H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT500H.Reg, volatile.LoadUint32(&o.LUT500H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT500H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT500H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT501L: Graphic MMU LUT entry 501 low
func (o *GFXMMU_Type) SetLUT501L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT501L.Reg, volatile.LoadUint32(&o.LUT501L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT501L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT501L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT501L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT501L.Reg, volatile.LoadUint32(&o.LUT501L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT501L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT501L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT501L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT501L.Reg, volatile.LoadUint32(&o.LUT501L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT501L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT501L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT501H: Graphic MMU LUT entry 501 high
func (o *GFXMMU_Type) SetLUT501H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT501H.Reg, volatile.LoadUint32(&o.LUT501H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT501H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT501H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT502L: Graphic MMU LUT entry 502 low
func (o *GFXMMU_Type) SetLUT502L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT502L.Reg, volatile.LoadUint32(&o.LUT502L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT502L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT502L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT502L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT502L.Reg, volatile.LoadUint32(&o.LUT502L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT502L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT502L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT502L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT502L.Reg, volatile.LoadUint32(&o.LUT502L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT502L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT502L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT502H: Graphic MMU LUT entry 502 high
func (o *GFXMMU_Type) SetLUT502H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT502H.Reg, volatile.LoadUint32(&o.LUT502H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT502H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT502H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT503L: Graphic MMU LUT entry 503 low
func (o *GFXMMU_Type) SetLUT503L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT503L.Reg, volatile.LoadUint32(&o.LUT503L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT503L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT503L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT503L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT503L.Reg, volatile.LoadUint32(&o.LUT503L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT503L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT503L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT503L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT503L.Reg, volatile.LoadUint32(&o.LUT503L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT503L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT503L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT503H: Graphic MMU LUT entry 503 high
func (o *GFXMMU_Type) SetLUT503H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT503H.Reg, volatile.LoadUint32(&o.LUT503H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT503H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT503H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT504L: Graphic MMU LUT entry 504 low
func (o *GFXMMU_Type) SetLUT504L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT504L.Reg, volatile.LoadUint32(&o.LUT504L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT504L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT504L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT504L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT504L.Reg, volatile.LoadUint32(&o.LUT504L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT504L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT504L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT504L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT504L.Reg, volatile.LoadUint32(&o.LUT504L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT504L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT504L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT504H: Graphic MMU LUT entry 504 high
func (o *GFXMMU_Type) SetLUT504H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT504H.Reg, volatile.LoadUint32(&o.LUT504H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT504H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT504H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT505L: Graphic MMU LUT entry 505 low
func (o *GFXMMU_Type) SetLUT505L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT505L.Reg, volatile.LoadUint32(&o.LUT505L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT505L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT505L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT505L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT505L.Reg, volatile.LoadUint32(&o.LUT505L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT505L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT505L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT505L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT505L.Reg, volatile.LoadUint32(&o.LUT505L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT505L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT505L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT505H: Graphic MMU LUT entry 505 high
func (o *GFXMMU_Type) SetLUT505H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT505H.Reg, volatile.LoadUint32(&o.LUT505H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT505H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT505H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT506L: Graphic MMU LUT entry 506 low
func (o *GFXMMU_Type) SetLUT506L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT506L.Reg, volatile.LoadUint32(&o.LUT506L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT506L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT506L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT506L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT506L.Reg, volatile.LoadUint32(&o.LUT506L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT506L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT506L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT506L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT506L.Reg, volatile.LoadUint32(&o.LUT506L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT506L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT506L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT506H: Graphic MMU LUT entry 506 high
func (o *GFXMMU_Type) SetLUT506H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT506H.Reg, volatile.LoadUint32(&o.LUT506H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT506H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT506H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT507L: Graphic MMU LUT entry 507 low
func (o *GFXMMU_Type) SetLUT507L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT507L.Reg, volatile.LoadUint32(&o.LUT507L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT507L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT507L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT507L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT507L.Reg, volatile.LoadUint32(&o.LUT507L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT507L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT507L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT507L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT507L.Reg, volatile.LoadUint32(&o.LUT507L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT507L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT507L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT507H: Graphic MMU LUT entry 507 high
func (o *GFXMMU_Type) SetLUT507H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT507H.Reg, volatile.LoadUint32(&o.LUT507H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT507H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT507H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT508L: Graphic MMU LUT entry 508 low
func (o *GFXMMU_Type) SetLUT508L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT508L.Reg, volatile.LoadUint32(&o.LUT508L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT508L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT508L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT508L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT508L.Reg, volatile.LoadUint32(&o.LUT508L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT508L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT508L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT508L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT508L.Reg, volatile.LoadUint32(&o.LUT508L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT508L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT508L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT508H: Graphic MMU LUT entry 508 high
func (o *GFXMMU_Type) SetLUT508H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT508H.Reg, volatile.LoadUint32(&o.LUT508H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT508H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT508H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT509L: Graphic MMU LUT entry 509 low
func (o *GFXMMU_Type) SetLUT509L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT509L.Reg, volatile.LoadUint32(&o.LUT509L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT509L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT509L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT509L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT509L.Reg, volatile.LoadUint32(&o.LUT509L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT509L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT509L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT509L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT509L.Reg, volatile.LoadUint32(&o.LUT509L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT509L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT509L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT509H: Graphic MMU LUT entry 509 high
func (o *GFXMMU_Type) SetLUT509H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT509H.Reg, volatile.LoadUint32(&o.LUT509H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT509H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT509H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT510L: Graphic MMU LUT entry 510 low
func (o *GFXMMU_Type) SetLUT510L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT510L.Reg, volatile.LoadUint32(&o.LUT510L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT510L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT510L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT510L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT510L.Reg, volatile.LoadUint32(&o.LUT510L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT510L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT510L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT510L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT510L.Reg, volatile.LoadUint32(&o.LUT510L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT510L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT510L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT510H: Graphic MMU LUT entry 510 high
func (o *GFXMMU_Type) SetLUT510H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT510H.Reg, volatile.LoadUint32(&o.LUT510H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT510H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT510H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT511L: Graphic MMU LUT entry 511 low
func (o *GFXMMU_Type) SetLUT511L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT511L.Reg, volatile.LoadUint32(&o.LUT511L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT511L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT511L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT511L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT511L.Reg, volatile.LoadUint32(&o.LUT511L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT511L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT511L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT511L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT511L.Reg, volatile.LoadUint32(&o.LUT511L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT511L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT511L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT511H: Graphic MMU LUT entry 511 high
func (o *GFXMMU_Type) SetLUT511H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT511H.Reg, volatile.LoadUint32(&o.LUT511H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT511H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT511H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT512L: Graphic MMU LUT entry 512 low
func (o *GFXMMU_Type) SetLUT512L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT512L.Reg, volatile.LoadUint32(&o.LUT512L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT512L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT512L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT512L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT512L.Reg, volatile.LoadUint32(&o.LUT512L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT512L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT512L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT512L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT512L.Reg, volatile.LoadUint32(&o.LUT512L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT512L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT512L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT512H: Graphic MMU LUT entry 512 high
func (o *GFXMMU_Type) SetLUT512H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT512H.Reg, volatile.LoadUint32(&o.LUT512H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT512H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT512H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT513L: Graphic MMU LUT entry 513 low
func (o *GFXMMU_Type) SetLUT513L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT513L.Reg, volatile.LoadUint32(&o.LUT513L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT513L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT513L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT513L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT513L.Reg, volatile.LoadUint32(&o.LUT513L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT513L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT513L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT513L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT513L.Reg, volatile.LoadUint32(&o.LUT513L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT513L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT513L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT513H: Graphic MMU LUT entry 513 high
func (o *GFXMMU_Type) SetLUT513H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT513H.Reg, volatile.LoadUint32(&o.LUT513H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT513H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT513H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT514L: Graphic MMU LUT entry 514 low
func (o *GFXMMU_Type) SetLUT514L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT514L.Reg, volatile.LoadUint32(&o.LUT514L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT514L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT514L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT514L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT514L.Reg, volatile.LoadUint32(&o.LUT514L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT514L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT514L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT514L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT514L.Reg, volatile.LoadUint32(&o.LUT514L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT514L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT514L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT514H: Graphic MMU LUT entry 514 high
func (o *GFXMMU_Type) SetLUT514H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT514H.Reg, volatile.LoadUint32(&o.LUT514H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT514H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT514H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT515L: Graphic MMU LUT entry 515 low
func (o *GFXMMU_Type) SetLUT515L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT515L.Reg, volatile.LoadUint32(&o.LUT515L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT515L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT515L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT515L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT515L.Reg, volatile.LoadUint32(&o.LUT515L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT515L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT515L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT515L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT515L.Reg, volatile.LoadUint32(&o.LUT515L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT515L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT515L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT515H: Graphic MMU LUT entry 515 high
func (o *GFXMMU_Type) SetLUT515H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT515H.Reg, volatile.LoadUint32(&o.LUT515H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT515H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT515H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT516L: Graphic MMU LUT entry 516 low
func (o *GFXMMU_Type) SetLUT516L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT516L.Reg, volatile.LoadUint32(&o.LUT516L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT516L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT516L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT516L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT516L.Reg, volatile.LoadUint32(&o.LUT516L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT516L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT516L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT516L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT516L.Reg, volatile.LoadUint32(&o.LUT516L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT516L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT516L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT516H: Graphic MMU LUT entry 516 high
func (o *GFXMMU_Type) SetLUT516H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT516H.Reg, volatile.LoadUint32(&o.LUT516H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT516H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT516H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT517L: Graphic MMU LUT entry 517 low
func (o *GFXMMU_Type) SetLUT517L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT517L.Reg, volatile.LoadUint32(&o.LUT517L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT517L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT517L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT517L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT517L.Reg, volatile.LoadUint32(&o.LUT517L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT517L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT517L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT517L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT517L.Reg, volatile.LoadUint32(&o.LUT517L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT517L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT517L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT517H: Graphic MMU LUT entry 517 high
func (o *GFXMMU_Type) SetLUT517H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT517H.Reg, volatile.LoadUint32(&o.LUT517H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT517H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT517H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT518L: Graphic MMU LUT entry 518 low
func (o *GFXMMU_Type) SetLUT518L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT518L.Reg, volatile.LoadUint32(&o.LUT518L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT518L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT518L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT518L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT518L.Reg, volatile.LoadUint32(&o.LUT518L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT518L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT518L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT518L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT518L.Reg, volatile.LoadUint32(&o.LUT518L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT518L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT518L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT518H: Graphic MMU LUT entry 518 high
func (o *GFXMMU_Type) SetLUT518H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT518H.Reg, volatile.LoadUint32(&o.LUT518H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT518H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT518H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT519L: Graphic MMU LUT entry 519 low
func (o *GFXMMU_Type) SetLUT519L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT519L.Reg, volatile.LoadUint32(&o.LUT519L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT519L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT519L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT519L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT519L.Reg, volatile.LoadUint32(&o.LUT519L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT519L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT519L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT519L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT519L.Reg, volatile.LoadUint32(&o.LUT519L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT519L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT519L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT519H: Graphic MMU LUT entry 519 high
func (o *GFXMMU_Type) SetLUT519H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT519H.Reg, volatile.LoadUint32(&o.LUT519H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT519H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT519H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT520L: Graphic MMU LUT entry 520 low
func (o *GFXMMU_Type) SetLUT520L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT520L.Reg, volatile.LoadUint32(&o.LUT520L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT520L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT520L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT520L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT520L.Reg, volatile.LoadUint32(&o.LUT520L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT520L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT520L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT520L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT520L.Reg, volatile.LoadUint32(&o.LUT520L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT520L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT520L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT520H: Graphic MMU LUT entry 520 high
func (o *GFXMMU_Type) SetLUT520H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT520H.Reg, volatile.LoadUint32(&o.LUT520H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT520H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT520H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT521L: Graphic MMU LUT entry 521 low
func (o *GFXMMU_Type) SetLUT521L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT521L.Reg, volatile.LoadUint32(&o.LUT521L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT521L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT521L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT521L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT521L.Reg, volatile.LoadUint32(&o.LUT521L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT521L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT521L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT521L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT521L.Reg, volatile.LoadUint32(&o.LUT521L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT521L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT521L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT521H: Graphic MMU LUT entry 521 high
func (o *GFXMMU_Type) SetLUT521H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT521H.Reg, volatile.LoadUint32(&o.LUT521H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT521H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT521H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT522L: Graphic MMU LUT entry 522 low
func (o *GFXMMU_Type) SetLUT522L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT522L.Reg, volatile.LoadUint32(&o.LUT522L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT522L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT522L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT522L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT522L.Reg, volatile.LoadUint32(&o.LUT522L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT522L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT522L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT522L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT522L.Reg, volatile.LoadUint32(&o.LUT522L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT522L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT522L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT522H: Graphic MMU LUT entry 522 high
func (o *GFXMMU_Type) SetLUT522H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT522H.Reg, volatile.LoadUint32(&o.LUT522H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT522H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT522H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT523L: Graphic MMU LUT entry 523 low
func (o *GFXMMU_Type) SetLUT523L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT523L.Reg, volatile.LoadUint32(&o.LUT523L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT523L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT523L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT523L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT523L.Reg, volatile.LoadUint32(&o.LUT523L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT523L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT523L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT523L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT523L.Reg, volatile.LoadUint32(&o.LUT523L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT523L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT523L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT523H: Graphic MMU LUT entry 523 high
func (o *GFXMMU_Type) SetLUT523H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT523H.Reg, volatile.LoadUint32(&o.LUT523H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT523H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT523H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT524L: Graphic MMU LUT entry 524 low
func (o *GFXMMU_Type) SetLUT524L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT524L.Reg, volatile.LoadUint32(&o.LUT524L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT524L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT524L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT524L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT524L.Reg, volatile.LoadUint32(&o.LUT524L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT524L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT524L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT524L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT524L.Reg, volatile.LoadUint32(&o.LUT524L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT524L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT524L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT524H: Graphic MMU LUT entry 524 high
func (o *GFXMMU_Type) SetLUT524H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT524H.Reg, volatile.LoadUint32(&o.LUT524H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT524H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT524H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT525L: Graphic MMU LUT entry 525 low
func (o *GFXMMU_Type) SetLUT525L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT525L.Reg, volatile.LoadUint32(&o.LUT525L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT525L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT525L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT525L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT525L.Reg, volatile.LoadUint32(&o.LUT525L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT525L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT525L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT525L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT525L.Reg, volatile.LoadUint32(&o.LUT525L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT525L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT525L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT525H: Graphic MMU LUT entry 525 high
func (o *GFXMMU_Type) SetLUT525H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT525H.Reg, volatile.LoadUint32(&o.LUT525H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT525H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT525H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT526L: Graphic MMU LUT entry 526 low
func (o *GFXMMU_Type) SetLUT526L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT526L.Reg, volatile.LoadUint32(&o.LUT526L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT526L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT526L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT526L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT526L.Reg, volatile.LoadUint32(&o.LUT526L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT526L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT526L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT526L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT526L.Reg, volatile.LoadUint32(&o.LUT526L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT526L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT526L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT526H: Graphic MMU LUT entry 526 high
func (o *GFXMMU_Type) SetLUT526H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT526H.Reg, volatile.LoadUint32(&o.LUT526H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT526H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT526H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT527L: Graphic MMU LUT entry 527 low
func (o *GFXMMU_Type) SetLUT527L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT527L.Reg, volatile.LoadUint32(&o.LUT527L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT527L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT527L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT527L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT527L.Reg, volatile.LoadUint32(&o.LUT527L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT527L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT527L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT527L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT527L.Reg, volatile.LoadUint32(&o.LUT527L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT527L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT527L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT527H: Graphic MMU LUT entry 527 high
func (o *GFXMMU_Type) SetLUT527H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT527H.Reg, volatile.LoadUint32(&o.LUT527H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT527H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT527H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT528L: Graphic MMU LUT entry 528 low
func (o *GFXMMU_Type) SetLUT528L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT528L.Reg, volatile.LoadUint32(&o.LUT528L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT528L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT528L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT528L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT528L.Reg, volatile.LoadUint32(&o.LUT528L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT528L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT528L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT528L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT528L.Reg, volatile.LoadUint32(&o.LUT528L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT528L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT528L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT528H: Graphic MMU LUT entry 528 high
func (o *GFXMMU_Type) SetLUT528H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT528H.Reg, volatile.LoadUint32(&o.LUT528H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT528H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT528H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT529L: Graphic MMU LUT entry 529 low
func (o *GFXMMU_Type) SetLUT529L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT529L.Reg, volatile.LoadUint32(&o.LUT529L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT529L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT529L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT529L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT529L.Reg, volatile.LoadUint32(&o.LUT529L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT529L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT529L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT529L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT529L.Reg, volatile.LoadUint32(&o.LUT529L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT529L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT529L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT529H: Graphic MMU LUT entry 529 high
func (o *GFXMMU_Type) SetLUT529H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT529H.Reg, volatile.LoadUint32(&o.LUT529H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT529H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT529H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT530L: Graphic MMU LUT entry 530 low
func (o *GFXMMU_Type) SetLUT530L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT530L.Reg, volatile.LoadUint32(&o.LUT530L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT530L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT530L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT530L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT530L.Reg, volatile.LoadUint32(&o.LUT530L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT530L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT530L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT530L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT530L.Reg, volatile.LoadUint32(&o.LUT530L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT530L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT530L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT530H: Graphic MMU LUT entry 530 high
func (o *GFXMMU_Type) SetLUT530H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT530H.Reg, volatile.LoadUint32(&o.LUT530H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT530H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT530H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT531L: Graphic MMU LUT entry 531 low
func (o *GFXMMU_Type) SetLUT531L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT531L.Reg, volatile.LoadUint32(&o.LUT531L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT531L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT531L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT531L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT531L.Reg, volatile.LoadUint32(&o.LUT531L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT531L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT531L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT531L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT531L.Reg, volatile.LoadUint32(&o.LUT531L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT531L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT531L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT531H: Graphic MMU LUT entry 531 high
func (o *GFXMMU_Type) SetLUT531H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT531H.Reg, volatile.LoadUint32(&o.LUT531H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT531H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT531H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT532L: Graphic MMU LUT entry 532 low
func (o *GFXMMU_Type) SetLUT532L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT532L.Reg, volatile.LoadUint32(&o.LUT532L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT532L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT532L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT532L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT532L.Reg, volatile.LoadUint32(&o.LUT532L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT532L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT532L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT532L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT532L.Reg, volatile.LoadUint32(&o.LUT532L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT532L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT532L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT532H: Graphic MMU LUT entry 532 high
func (o *GFXMMU_Type) SetLUT532H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT532H.Reg, volatile.LoadUint32(&o.LUT532H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT532H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT532H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT533L: Graphic MMU LUT entry 533 low
func (o *GFXMMU_Type) SetLUT533L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT533L.Reg, volatile.LoadUint32(&o.LUT533L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT533L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT533L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT533L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT533L.Reg, volatile.LoadUint32(&o.LUT533L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT533L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT533L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT533L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT533L.Reg, volatile.LoadUint32(&o.LUT533L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT533L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT533L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT533H: Graphic MMU LUT entry 533 high
func (o *GFXMMU_Type) SetLUT533H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT533H.Reg, volatile.LoadUint32(&o.LUT533H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT533H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT533H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT534L: Graphic MMU LUT entry 534 low
func (o *GFXMMU_Type) SetLUT534L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT534L.Reg, volatile.LoadUint32(&o.LUT534L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT534L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT534L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT534L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT534L.Reg, volatile.LoadUint32(&o.LUT534L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT534L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT534L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT534L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT534L.Reg, volatile.LoadUint32(&o.LUT534L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT534L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT534L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT534H: Graphic MMU LUT entry 534 high
func (o *GFXMMU_Type) SetLUT534H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT534H.Reg, volatile.LoadUint32(&o.LUT534H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT534H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT534H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT535L: Graphic MMU LUT entry 535 low
func (o *GFXMMU_Type) SetLUT535L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT535L.Reg, volatile.LoadUint32(&o.LUT535L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT535L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT535L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT535L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT535L.Reg, volatile.LoadUint32(&o.LUT535L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT535L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT535L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT535L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT535L.Reg, volatile.LoadUint32(&o.LUT535L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT535L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT535L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT535H: Graphic MMU LUT entry 535 high
func (o *GFXMMU_Type) SetLUT535H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT535H.Reg, volatile.LoadUint32(&o.LUT535H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT535H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT535H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT536L: Graphic MMU LUT entry 536 low
func (o *GFXMMU_Type) SetLUT536L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT536L.Reg, volatile.LoadUint32(&o.LUT536L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT536L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT536L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT536L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT536L.Reg, volatile.LoadUint32(&o.LUT536L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT536L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT536L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT536L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT536L.Reg, volatile.LoadUint32(&o.LUT536L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT536L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT536L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT536H: Graphic MMU LUT entry 536 high
func (o *GFXMMU_Type) SetLUT536H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT536H.Reg, volatile.LoadUint32(&o.LUT536H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT536H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT536H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT537L: Graphic MMU LUT entry 537 low
func (o *GFXMMU_Type) SetLUT537L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT537L.Reg, volatile.LoadUint32(&o.LUT537L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT537L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT537L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT537L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT537L.Reg, volatile.LoadUint32(&o.LUT537L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT537L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT537L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT537L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT537L.Reg, volatile.LoadUint32(&o.LUT537L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT537L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT537L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT537H: Graphic MMU LUT entry 537 high
func (o *GFXMMU_Type) SetLUT537H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT537H.Reg, volatile.LoadUint32(&o.LUT537H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT537H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT537H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT538L: Graphic MMU LUT entry 538 low
func (o *GFXMMU_Type) SetLUT538L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT538L.Reg, volatile.LoadUint32(&o.LUT538L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT538L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT538L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT538L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT538L.Reg, volatile.LoadUint32(&o.LUT538L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT538L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT538L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT538L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT538L.Reg, volatile.LoadUint32(&o.LUT538L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT538L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT538L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT538H: Graphic MMU LUT entry 538 high
func (o *GFXMMU_Type) SetLUT538H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT538H.Reg, volatile.LoadUint32(&o.LUT538H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT538H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT538H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT539L: Graphic MMU LUT entry 539 low
func (o *GFXMMU_Type) SetLUT539L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT539L.Reg, volatile.LoadUint32(&o.LUT539L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT539L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT539L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT539L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT539L.Reg, volatile.LoadUint32(&o.LUT539L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT539L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT539L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT539L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT539L.Reg, volatile.LoadUint32(&o.LUT539L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT539L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT539L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT539H: Graphic MMU LUT entry 539 high
func (o *GFXMMU_Type) SetLUT539H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT539H.Reg, volatile.LoadUint32(&o.LUT539H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT539H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT539H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT540L: Graphic MMU LUT entry 540 low
func (o *GFXMMU_Type) SetLUT540L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT540L.Reg, volatile.LoadUint32(&o.LUT540L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT540L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT540L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT540L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT540L.Reg, volatile.LoadUint32(&o.LUT540L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT540L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT540L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT540L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT540L.Reg, volatile.LoadUint32(&o.LUT540L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT540L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT540L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT540H: Graphic MMU LUT entry 540 high
func (o *GFXMMU_Type) SetLUT540H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT540H.Reg, volatile.LoadUint32(&o.LUT540H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT540H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT540H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT541L: Graphic MMU LUT entry 541 low
func (o *GFXMMU_Type) SetLUT541L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT541L.Reg, volatile.LoadUint32(&o.LUT541L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT541L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT541L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT541L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT541L.Reg, volatile.LoadUint32(&o.LUT541L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT541L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT541L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT541L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT541L.Reg, volatile.LoadUint32(&o.LUT541L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT541L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT541L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT541H: Graphic MMU LUT entry 541 high
func (o *GFXMMU_Type) SetLUT541H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT541H.Reg, volatile.LoadUint32(&o.LUT541H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT541H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT541H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT542L: Graphic MMU LUT entry 542 low
func (o *GFXMMU_Type) SetLUT542L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT542L.Reg, volatile.LoadUint32(&o.LUT542L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT542L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT542L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT542L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT542L.Reg, volatile.LoadUint32(&o.LUT542L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT542L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT542L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT542L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT542L.Reg, volatile.LoadUint32(&o.LUT542L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT542L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT542L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT542H: Graphic MMU LUT entry 542 high
func (o *GFXMMU_Type) SetLUT542H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT542H.Reg, volatile.LoadUint32(&o.LUT542H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT542H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT542H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT543L: Graphic MMU LUT entry 543 low
func (o *GFXMMU_Type) SetLUT543L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT543L.Reg, volatile.LoadUint32(&o.LUT543L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT543L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT543L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT543L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT543L.Reg, volatile.LoadUint32(&o.LUT543L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT543L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT543L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT543L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT543L.Reg, volatile.LoadUint32(&o.LUT543L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT543L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT543L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT543H: Graphic MMU LUT entry 543 high
func (o *GFXMMU_Type) SetLUT543H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT543H.Reg, volatile.LoadUint32(&o.LUT543H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT543H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT543H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT544L: Graphic MMU LUT entry 544 low
func (o *GFXMMU_Type) SetLUT544L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT544L.Reg, volatile.LoadUint32(&o.LUT544L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT544L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT544L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT544L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT544L.Reg, volatile.LoadUint32(&o.LUT544L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT544L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT544L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT544L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT544L.Reg, volatile.LoadUint32(&o.LUT544L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT544L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT544L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT544H: Graphic MMU LUT entry 544 high
func (o *GFXMMU_Type) SetLUT544H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT544H.Reg, volatile.LoadUint32(&o.LUT544H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT544H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT544H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT545L: Graphic MMU LUT entry 545 low
func (o *GFXMMU_Type) SetLUT545L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT545L.Reg, volatile.LoadUint32(&o.LUT545L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT545L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT545L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT545L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT545L.Reg, volatile.LoadUint32(&o.LUT545L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT545L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT545L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT545L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT545L.Reg, volatile.LoadUint32(&o.LUT545L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT545L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT545L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT545H: Graphic MMU LUT entry 545 high
func (o *GFXMMU_Type) SetLUT545H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT545H.Reg, volatile.LoadUint32(&o.LUT545H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT545H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT545H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT546L: Graphic MMU LUT entry 546 low
func (o *GFXMMU_Type) SetLUT546L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT546L.Reg, volatile.LoadUint32(&o.LUT546L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT546L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT546L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT546L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT546L.Reg, volatile.LoadUint32(&o.LUT546L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT546L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT546L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT546L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT546L.Reg, volatile.LoadUint32(&o.LUT546L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT546L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT546L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT546H: Graphic MMU LUT entry 546 high
func (o *GFXMMU_Type) SetLUT546H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT546H.Reg, volatile.LoadUint32(&o.LUT546H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT546H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT546H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT547L: Graphic MMU LUT entry 547 low
func (o *GFXMMU_Type) SetLUT547L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT547L.Reg, volatile.LoadUint32(&o.LUT547L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT547L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT547L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT547L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT547L.Reg, volatile.LoadUint32(&o.LUT547L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT547L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT547L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT547L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT547L.Reg, volatile.LoadUint32(&o.LUT547L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT547L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT547L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT547H: Graphic MMU LUT entry 547 high
func (o *GFXMMU_Type) SetLUT547H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT547H.Reg, volatile.LoadUint32(&o.LUT547H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT547H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT547H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT548L: Graphic MMU LUT entry 548 low
func (o *GFXMMU_Type) SetLUT548L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT548L.Reg, volatile.LoadUint32(&o.LUT548L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT548L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT548L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT548L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT548L.Reg, volatile.LoadUint32(&o.LUT548L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT548L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT548L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT548L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT548L.Reg, volatile.LoadUint32(&o.LUT548L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT548L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT548L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT548H: Graphic MMU LUT entry 548 high
func (o *GFXMMU_Type) SetLUT548H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT548H.Reg, volatile.LoadUint32(&o.LUT548H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT548H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT548H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT549L: Graphic MMU LUT entry 549 low
func (o *GFXMMU_Type) SetLUT549L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT549L.Reg, volatile.LoadUint32(&o.LUT549L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT549L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT549L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT549L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT549L.Reg, volatile.LoadUint32(&o.LUT549L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT549L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT549L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT549L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT549L.Reg, volatile.LoadUint32(&o.LUT549L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT549L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT549L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT549H: Graphic MMU LUT entry 549 high
func (o *GFXMMU_Type) SetLUT549H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT549H.Reg, volatile.LoadUint32(&o.LUT549H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT549H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT549H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT550L: Graphic MMU LUT entry 550 low
func (o *GFXMMU_Type) SetLUT550L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT550L.Reg, volatile.LoadUint32(&o.LUT550L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT550L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT550L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT550L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT550L.Reg, volatile.LoadUint32(&o.LUT550L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT550L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT550L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT550L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT550L.Reg, volatile.LoadUint32(&o.LUT550L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT550L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT550L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT550H: Graphic MMU LUT entry 550 high
func (o *GFXMMU_Type) SetLUT550H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT550H.Reg, volatile.LoadUint32(&o.LUT550H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT550H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT550H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT551L: Graphic MMU LUT entry 551 low
func (o *GFXMMU_Type) SetLUT551L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT551L.Reg, volatile.LoadUint32(&o.LUT551L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT551L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT551L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT551L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT551L.Reg, volatile.LoadUint32(&o.LUT551L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT551L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT551L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT551L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT551L.Reg, volatile.LoadUint32(&o.LUT551L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT551L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT551L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT551H: Graphic MMU LUT entry 551 high
func (o *GFXMMU_Type) SetLUT551H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT551H.Reg, volatile.LoadUint32(&o.LUT551H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT551H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT551H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT552L: Graphic MMU LUT entry 552 low
func (o *GFXMMU_Type) SetLUT552L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT552L.Reg, volatile.LoadUint32(&o.LUT552L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT552L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT552L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT552L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT552L.Reg, volatile.LoadUint32(&o.LUT552L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT552L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT552L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT552L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT552L.Reg, volatile.LoadUint32(&o.LUT552L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT552L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT552L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT552H: Graphic MMU LUT entry 552 high
func (o *GFXMMU_Type) SetLUT552H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT552H.Reg, volatile.LoadUint32(&o.LUT552H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT552H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT552H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT553L: Graphic MMU LUT entry 553 low
func (o *GFXMMU_Type) SetLUT553L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT553L.Reg, volatile.LoadUint32(&o.LUT553L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT553L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT553L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT553L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT553L.Reg, volatile.LoadUint32(&o.LUT553L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT553L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT553L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT553L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT553L.Reg, volatile.LoadUint32(&o.LUT553L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT553L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT553L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT553H: Graphic MMU LUT entry 553 high
func (o *GFXMMU_Type) SetLUT553H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT553H.Reg, volatile.LoadUint32(&o.LUT553H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT553H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT553H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT554L: Graphic MMU LUT entry 554 low
func (o *GFXMMU_Type) SetLUT554L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT554L.Reg, volatile.LoadUint32(&o.LUT554L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT554L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT554L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT554L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT554L.Reg, volatile.LoadUint32(&o.LUT554L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT554L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT554L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT554L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT554L.Reg, volatile.LoadUint32(&o.LUT554L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT554L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT554L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT554H: Graphic MMU LUT entry 554 high
func (o *GFXMMU_Type) SetLUT554H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT554H.Reg, volatile.LoadUint32(&o.LUT554H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT554H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT554H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT555L: Graphic MMU LUT entry 555 low
func (o *GFXMMU_Type) SetLUT555L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT555L.Reg, volatile.LoadUint32(&o.LUT555L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT555L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT555L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT555L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT555L.Reg, volatile.LoadUint32(&o.LUT555L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT555L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT555L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT555L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT555L.Reg, volatile.LoadUint32(&o.LUT555L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT555L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT555L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT555H: Graphic MMU LUT entry 555 high
func (o *GFXMMU_Type) SetLUT555H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT555H.Reg, volatile.LoadUint32(&o.LUT555H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT555H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT555H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT556L: Graphic MMU LUT entry 556 low
func (o *GFXMMU_Type) SetLUT556L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT556L.Reg, volatile.LoadUint32(&o.LUT556L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT556L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT556L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT556L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT556L.Reg, volatile.LoadUint32(&o.LUT556L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT556L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT556L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT556L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT556L.Reg, volatile.LoadUint32(&o.LUT556L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT556L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT556L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT556H: Graphic MMU LUT entry 556 high
func (o *GFXMMU_Type) SetLUT556H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT556H.Reg, volatile.LoadUint32(&o.LUT556H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT556H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT556H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT557L: Graphic MMU LUT entry 557 low
func (o *GFXMMU_Type) SetLUT557L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT557L.Reg, volatile.LoadUint32(&o.LUT557L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT557L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT557L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT557L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT557L.Reg, volatile.LoadUint32(&o.LUT557L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT557L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT557L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT557L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT557L.Reg, volatile.LoadUint32(&o.LUT557L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT557L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT557L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT557H: Graphic MMU LUT entry 557 high
func (o *GFXMMU_Type) SetLUT557H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT557H.Reg, volatile.LoadUint32(&o.LUT557H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT557H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT557H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT558L: Graphic MMU LUT entry 558 low
func (o *GFXMMU_Type) SetLUT558L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT558L.Reg, volatile.LoadUint32(&o.LUT558L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT558L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT558L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT558L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT558L.Reg, volatile.LoadUint32(&o.LUT558L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT558L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT558L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT558L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT558L.Reg, volatile.LoadUint32(&o.LUT558L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT558L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT558L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT558H: Graphic MMU LUT entry 558 high
func (o *GFXMMU_Type) SetLUT558H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT558H.Reg, volatile.LoadUint32(&o.LUT558H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT558H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT558H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT559L: Graphic MMU LUT entry 559 low
func (o *GFXMMU_Type) SetLUT559L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT559L.Reg, volatile.LoadUint32(&o.LUT559L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT559L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT559L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT559L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT559L.Reg, volatile.LoadUint32(&o.LUT559L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT559L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT559L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT559L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT559L.Reg, volatile.LoadUint32(&o.LUT559L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT559L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT559L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT559H: Graphic MMU LUT entry 559 high
func (o *GFXMMU_Type) SetLUT559H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT559H.Reg, volatile.LoadUint32(&o.LUT559H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT559H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT559H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT560L: Graphic MMU LUT entry 560 low
func (o *GFXMMU_Type) SetLUT560L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT560L.Reg, volatile.LoadUint32(&o.LUT560L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT560L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT560L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT560L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT560L.Reg, volatile.LoadUint32(&o.LUT560L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT560L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT560L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT560L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT560L.Reg, volatile.LoadUint32(&o.LUT560L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT560L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT560L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT560H: Graphic MMU LUT entry 560 high
func (o *GFXMMU_Type) SetLUT560H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT560H.Reg, volatile.LoadUint32(&o.LUT560H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT560H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT560H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT561L: Graphic MMU LUT entry 561 low
func (o *GFXMMU_Type) SetLUT561L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT561L.Reg, volatile.LoadUint32(&o.LUT561L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT561L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT561L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT561L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT561L.Reg, volatile.LoadUint32(&o.LUT561L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT561L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT561L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT561L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT561L.Reg, volatile.LoadUint32(&o.LUT561L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT561L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT561L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT561H: Graphic MMU LUT entry 561 high
func (o *GFXMMU_Type) SetLUT561H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT561H.Reg, volatile.LoadUint32(&o.LUT561H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT561H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT561H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT562L: Graphic MMU LUT entry 562 low
func (o *GFXMMU_Type) SetLUT562L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT562L.Reg, volatile.LoadUint32(&o.LUT562L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT562L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT562L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT562L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT562L.Reg, volatile.LoadUint32(&o.LUT562L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT562L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT562L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT562L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT562L.Reg, volatile.LoadUint32(&o.LUT562L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT562L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT562L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT562H: Graphic MMU LUT entry 562 high
func (o *GFXMMU_Type) SetLUT562H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT562H.Reg, volatile.LoadUint32(&o.LUT562H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT562H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT562H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT563L: Graphic MMU LUT entry 563 low
func (o *GFXMMU_Type) SetLUT563L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT563L.Reg, volatile.LoadUint32(&o.LUT563L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT563L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT563L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT563L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT563L.Reg, volatile.LoadUint32(&o.LUT563L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT563L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT563L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT563L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT563L.Reg, volatile.LoadUint32(&o.LUT563L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT563L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT563L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT563H: Graphic MMU LUT entry 563 high
func (o *GFXMMU_Type) SetLUT563H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT563H.Reg, volatile.LoadUint32(&o.LUT563H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT563H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT563H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT564L: Graphic MMU LUT entry 564 low
func (o *GFXMMU_Type) SetLUT564L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT564L.Reg, volatile.LoadUint32(&o.LUT564L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT564L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT564L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT564L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT564L.Reg, volatile.LoadUint32(&o.LUT564L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT564L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT564L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT564L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT564L.Reg, volatile.LoadUint32(&o.LUT564L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT564L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT564L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT564H: Graphic MMU LUT entry 564 high
func (o *GFXMMU_Type) SetLUT564H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT564H.Reg, volatile.LoadUint32(&o.LUT564H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT564H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT564H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT565L: Graphic MMU LUT entry 565 low
func (o *GFXMMU_Type) SetLUT565L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT565L.Reg, volatile.LoadUint32(&o.LUT565L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT565L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT565L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT565L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT565L.Reg, volatile.LoadUint32(&o.LUT565L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT565L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT565L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT565L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT565L.Reg, volatile.LoadUint32(&o.LUT565L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT565L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT565L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT565H: Graphic MMU LUT entry 565 high
func (o *GFXMMU_Type) SetLUT565H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT565H.Reg, volatile.LoadUint32(&o.LUT565H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT565H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT565H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT566L: Graphic MMU LUT entry 566 low
func (o *GFXMMU_Type) SetLUT566L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT566L.Reg, volatile.LoadUint32(&o.LUT566L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT566L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT566L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT566L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT566L.Reg, volatile.LoadUint32(&o.LUT566L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT566L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT566L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT566L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT566L.Reg, volatile.LoadUint32(&o.LUT566L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT566L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT566L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT566H: Graphic MMU LUT entry 566 high
func (o *GFXMMU_Type) SetLUT566H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT566H.Reg, volatile.LoadUint32(&o.LUT566H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT566H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT566H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT567L: Graphic MMU LUT entry 567 low
func (o *GFXMMU_Type) SetLUT567L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT567L.Reg, volatile.LoadUint32(&o.LUT567L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT567L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT567L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT567L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT567L.Reg, volatile.LoadUint32(&o.LUT567L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT567L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT567L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT567L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT567L.Reg, volatile.LoadUint32(&o.LUT567L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT567L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT567L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT567H: Graphic MMU LUT entry 567 high
func (o *GFXMMU_Type) SetLUT567H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT567H.Reg, volatile.LoadUint32(&o.LUT567H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT567H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT567H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT568L: Graphic MMU LUT entry 568 low
func (o *GFXMMU_Type) SetLUT568L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT568L.Reg, volatile.LoadUint32(&o.LUT568L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT568L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT568L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT568L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT568L.Reg, volatile.LoadUint32(&o.LUT568L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT568L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT568L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT568L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT568L.Reg, volatile.LoadUint32(&o.LUT568L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT568L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT568L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT568H: Graphic MMU LUT entry 568 high
func (o *GFXMMU_Type) SetLUT568H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT568H.Reg, volatile.LoadUint32(&o.LUT568H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT568H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT568H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT569L: Graphic MMU LUT entry 569 low
func (o *GFXMMU_Type) SetLUT569L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT569L.Reg, volatile.LoadUint32(&o.LUT569L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT569L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT569L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT569L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT569L.Reg, volatile.LoadUint32(&o.LUT569L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT569L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT569L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT569L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT569L.Reg, volatile.LoadUint32(&o.LUT569L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT569L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT569L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT569H: Graphic MMU LUT entry 569 high
func (o *GFXMMU_Type) SetLUT569H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT569H.Reg, volatile.LoadUint32(&o.LUT569H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT569H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT569H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT570L: Graphic MMU LUT entry 570 low
func (o *GFXMMU_Type) SetLUT570L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT570L.Reg, volatile.LoadUint32(&o.LUT570L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT570L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT570L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT570L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT570L.Reg, volatile.LoadUint32(&o.LUT570L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT570L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT570L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT570L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT570L.Reg, volatile.LoadUint32(&o.LUT570L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT570L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT570L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT570H: Graphic MMU LUT entry 570 high
func (o *GFXMMU_Type) SetLUT570H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT570H.Reg, volatile.LoadUint32(&o.LUT570H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT570H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT570H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT571L: Graphic MMU LUT entry 571 low
func (o *GFXMMU_Type) SetLUT571L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT571L.Reg, volatile.LoadUint32(&o.LUT571L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT571L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT571L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT571L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT571L.Reg, volatile.LoadUint32(&o.LUT571L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT571L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT571L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT571L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT571L.Reg, volatile.LoadUint32(&o.LUT571L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT571L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT571L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT571H: Graphic MMU LUT entry 571 high
func (o *GFXMMU_Type) SetLUT571H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT571H.Reg, volatile.LoadUint32(&o.LUT571H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT571H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT571H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT572L: Graphic MMU LUT entry 572 low
func (o *GFXMMU_Type) SetLUT572L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT572L.Reg, volatile.LoadUint32(&o.LUT572L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT572L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT572L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT572L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT572L.Reg, volatile.LoadUint32(&o.LUT572L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT572L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT572L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT572L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT572L.Reg, volatile.LoadUint32(&o.LUT572L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT572L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT572L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT572H: Graphic MMU LUT entry 572 high
func (o *GFXMMU_Type) SetLUT572H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT572H.Reg, volatile.LoadUint32(&o.LUT572H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT572H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT572H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT573L: Graphic MMU LUT entry 573 low
func (o *GFXMMU_Type) SetLUT573L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT573L.Reg, volatile.LoadUint32(&o.LUT573L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT573L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT573L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT573L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT573L.Reg, volatile.LoadUint32(&o.LUT573L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT573L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT573L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT573L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT573L.Reg, volatile.LoadUint32(&o.LUT573L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT573L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT573L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT573H: Graphic MMU LUT entry 573 high
func (o *GFXMMU_Type) SetLUT573H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT573H.Reg, volatile.LoadUint32(&o.LUT573H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT573H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT573H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT574L: Graphic MMU LUT entry 574 low
func (o *GFXMMU_Type) SetLUT574L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT574L.Reg, volatile.LoadUint32(&o.LUT574L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT574L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT574L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT574L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT574L.Reg, volatile.LoadUint32(&o.LUT574L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT574L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT574L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT574L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT574L.Reg, volatile.LoadUint32(&o.LUT574L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT574L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT574L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT574H: Graphic MMU LUT entry 574 high
func (o *GFXMMU_Type) SetLUT574H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT574H.Reg, volatile.LoadUint32(&o.LUT574H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT574H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT574H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT575L: Graphic MMU LUT entry 575 low
func (o *GFXMMU_Type) SetLUT575L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT575L.Reg, volatile.LoadUint32(&o.LUT575L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT575L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT575L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT575L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT575L.Reg, volatile.LoadUint32(&o.LUT575L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT575L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT575L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT575L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT575L.Reg, volatile.LoadUint32(&o.LUT575L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT575L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT575L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT575H: Graphic MMU LUT entry 575 high
func (o *GFXMMU_Type) SetLUT575H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT575H.Reg, volatile.LoadUint32(&o.LUT575H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT575H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT575H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT576L: Graphic MMU LUT entry 576 low
func (o *GFXMMU_Type) SetLUT576L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT576L.Reg, volatile.LoadUint32(&o.LUT576L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT576L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT576L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT576L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT576L.Reg, volatile.LoadUint32(&o.LUT576L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT576L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT576L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT576L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT576L.Reg, volatile.LoadUint32(&o.LUT576L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT576L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT576L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT576H: Graphic MMU LUT entry 576 high
func (o *GFXMMU_Type) SetLUT576H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT576H.Reg, volatile.LoadUint32(&o.LUT576H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT576H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT576H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT577L: Graphic MMU LUT entry 577 low
func (o *GFXMMU_Type) SetLUT577L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT577L.Reg, volatile.LoadUint32(&o.LUT577L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT577L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT577L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT577L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT577L.Reg, volatile.LoadUint32(&o.LUT577L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT577L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT577L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT577L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT577L.Reg, volatile.LoadUint32(&o.LUT577L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT577L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT577L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT577H: Graphic MMU LUT entry 577 high
func (o *GFXMMU_Type) SetLUT577H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT577H.Reg, volatile.LoadUint32(&o.LUT577H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT577H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT577H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT578L: Graphic MMU LUT entry 578 low
func (o *GFXMMU_Type) SetLUT578L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT578L.Reg, volatile.LoadUint32(&o.LUT578L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT578L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT578L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT578L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT578L.Reg, volatile.LoadUint32(&o.LUT578L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT578L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT578L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT578L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT578L.Reg, volatile.LoadUint32(&o.LUT578L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT578L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT578L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT578H: Graphic MMU LUT entry 578 high
func (o *GFXMMU_Type) SetLUT578H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT578H.Reg, volatile.LoadUint32(&o.LUT578H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT578H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT578H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT579L: Graphic MMU LUT entry 579 low
func (o *GFXMMU_Type) SetLUT579L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT579L.Reg, volatile.LoadUint32(&o.LUT579L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT579L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT579L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT579L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT579L.Reg, volatile.LoadUint32(&o.LUT579L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT579L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT579L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT579L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT579L.Reg, volatile.LoadUint32(&o.LUT579L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT579L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT579L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT579H: Graphic MMU LUT entry 579 high
func (o *GFXMMU_Type) SetLUT579H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT579H.Reg, volatile.LoadUint32(&o.LUT579H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT579H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT579H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT580L: Graphic MMU LUT entry 580 low
func (o *GFXMMU_Type) SetLUT580L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT580L.Reg, volatile.LoadUint32(&o.LUT580L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT580L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT580L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT580L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT580L.Reg, volatile.LoadUint32(&o.LUT580L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT580L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT580L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT580L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT580L.Reg, volatile.LoadUint32(&o.LUT580L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT580L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT580L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT580H: Graphic MMU LUT entry 580 high
func (o *GFXMMU_Type) SetLUT580H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT580H.Reg, volatile.LoadUint32(&o.LUT580H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT580H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT580H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT581L: Graphic MMU LUT entry 581 low
func (o *GFXMMU_Type) SetLUT581L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT581L.Reg, volatile.LoadUint32(&o.LUT581L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT581L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT581L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT581L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT581L.Reg, volatile.LoadUint32(&o.LUT581L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT581L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT581L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT581L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT581L.Reg, volatile.LoadUint32(&o.LUT581L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT581L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT581L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT581H: Graphic MMU LUT entry 581 high
func (o *GFXMMU_Type) SetLUT581H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT581H.Reg, volatile.LoadUint32(&o.LUT581H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT581H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT581H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT582L: Graphic MMU LUT entry 582 low
func (o *GFXMMU_Type) SetLUT582L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT582L.Reg, volatile.LoadUint32(&o.LUT582L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT582L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT582L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT582L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT582L.Reg, volatile.LoadUint32(&o.LUT582L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT582L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT582L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT582L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT582L.Reg, volatile.LoadUint32(&o.LUT582L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT582L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT582L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT582H: Graphic MMU LUT entry 582 high
func (o *GFXMMU_Type) SetLUT582H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT582H.Reg, volatile.LoadUint32(&o.LUT582H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT582H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT582H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT583L: Graphic MMU LUT entry 583 low
func (o *GFXMMU_Type) SetLUT583L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT583L.Reg, volatile.LoadUint32(&o.LUT583L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT583L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT583L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT583L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT583L.Reg, volatile.LoadUint32(&o.LUT583L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT583L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT583L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT583L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT583L.Reg, volatile.LoadUint32(&o.LUT583L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT583L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT583L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT583H: Graphic MMU LUT entry 583 high
func (o *GFXMMU_Type) SetLUT583H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT583H.Reg, volatile.LoadUint32(&o.LUT583H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT583H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT583H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT584L: Graphic MMU LUT entry 584 low
func (o *GFXMMU_Type) SetLUT584L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT584L.Reg, volatile.LoadUint32(&o.LUT584L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT584L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT584L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT584L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT584L.Reg, volatile.LoadUint32(&o.LUT584L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT584L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT584L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT584L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT584L.Reg, volatile.LoadUint32(&o.LUT584L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT584L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT584L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT584H: Graphic MMU LUT entry 584 high
func (o *GFXMMU_Type) SetLUT584H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT584H.Reg, volatile.LoadUint32(&o.LUT584H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT584H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT584H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT585L: Graphic MMU LUT entry 585 low
func (o *GFXMMU_Type) SetLUT585L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT585L.Reg, volatile.LoadUint32(&o.LUT585L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT585L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT585L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT585L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT585L.Reg, volatile.LoadUint32(&o.LUT585L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT585L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT585L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT585L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT585L.Reg, volatile.LoadUint32(&o.LUT585L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT585L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT585L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT585H: Graphic MMU LUT entry 585 high
func (o *GFXMMU_Type) SetLUT585H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT585H.Reg, volatile.LoadUint32(&o.LUT585H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT585H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT585H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT586L: Graphic MMU LUT entry 586 low
func (o *GFXMMU_Type) SetLUT586L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT586L.Reg, volatile.LoadUint32(&o.LUT586L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT586L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT586L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT586L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT586L.Reg, volatile.LoadUint32(&o.LUT586L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT586L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT586L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT586L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT586L.Reg, volatile.LoadUint32(&o.LUT586L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT586L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT586L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT586H: Graphic MMU LUT entry 586 high
func (o *GFXMMU_Type) SetLUT586H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT586H.Reg, volatile.LoadUint32(&o.LUT586H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT586H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT586H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT587L: Graphic MMU LUT entry 587 low
func (o *GFXMMU_Type) SetLUT587L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT587L.Reg, volatile.LoadUint32(&o.LUT587L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT587L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT587L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT587L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT587L.Reg, volatile.LoadUint32(&o.LUT587L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT587L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT587L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT587L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT587L.Reg, volatile.LoadUint32(&o.LUT587L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT587L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT587L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT587H: Graphic MMU LUT entry 587 high
func (o *GFXMMU_Type) SetLUT587H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT587H.Reg, volatile.LoadUint32(&o.LUT587H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT587H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT587H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT588L: Graphic MMU LUT entry 588 low
func (o *GFXMMU_Type) SetLUT588L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT588L.Reg, volatile.LoadUint32(&o.LUT588L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT588L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT588L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT588L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT588L.Reg, volatile.LoadUint32(&o.LUT588L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT588L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT588L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT588L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT588L.Reg, volatile.LoadUint32(&o.LUT588L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT588L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT588L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT588H: Graphic MMU LUT entry 588 high
func (o *GFXMMU_Type) SetLUT588H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT588H.Reg, volatile.LoadUint32(&o.LUT588H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT588H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT588H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT589L: Graphic MMU LUT entry 589 low
func (o *GFXMMU_Type) SetLUT589L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT589L.Reg, volatile.LoadUint32(&o.LUT589L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT589L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT589L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT589L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT589L.Reg, volatile.LoadUint32(&o.LUT589L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT589L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT589L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT589L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT589L.Reg, volatile.LoadUint32(&o.LUT589L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT589L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT589L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT589H: Graphic MMU LUT entry 589 high
func (o *GFXMMU_Type) SetLUT589H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT589H.Reg, volatile.LoadUint32(&o.LUT589H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT589H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT589H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT590L: Graphic MMU LUT entry 590 low
func (o *GFXMMU_Type) SetLUT590L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT590L.Reg, volatile.LoadUint32(&o.LUT590L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT590L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT590L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT590L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT590L.Reg, volatile.LoadUint32(&o.LUT590L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT590L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT590L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT590L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT590L.Reg, volatile.LoadUint32(&o.LUT590L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT590L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT590L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT590H: Graphic MMU LUT entry 590 high
func (o *GFXMMU_Type) SetLUT590H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT590H.Reg, volatile.LoadUint32(&o.LUT590H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT590H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT590H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT591L: Graphic MMU LUT entry 591 low
func (o *GFXMMU_Type) SetLUT591L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT591L.Reg, volatile.LoadUint32(&o.LUT591L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT591L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT591L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT591L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT591L.Reg, volatile.LoadUint32(&o.LUT591L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT591L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT591L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT591L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT591L.Reg, volatile.LoadUint32(&o.LUT591L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT591L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT591L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT591H: Graphic MMU LUT entry 591 high
func (o *GFXMMU_Type) SetLUT591H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT591H.Reg, volatile.LoadUint32(&o.LUT591H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT591H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT591H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT592L: Graphic MMU LUT entry 592 low
func (o *GFXMMU_Type) SetLUT592L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT592L.Reg, volatile.LoadUint32(&o.LUT592L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT592L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT592L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT592L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT592L.Reg, volatile.LoadUint32(&o.LUT592L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT592L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT592L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT592L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT592L.Reg, volatile.LoadUint32(&o.LUT592L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT592L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT592L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT592H: Graphic MMU LUT entry 592 high
func (o *GFXMMU_Type) SetLUT592H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT592H.Reg, volatile.LoadUint32(&o.LUT592H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT592H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT592H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT593L: Graphic MMU LUT entry 593 low
func (o *GFXMMU_Type) SetLUT593L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT593L.Reg, volatile.LoadUint32(&o.LUT593L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT593L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT593L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT593L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT593L.Reg, volatile.LoadUint32(&o.LUT593L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT593L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT593L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT593L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT593L.Reg, volatile.LoadUint32(&o.LUT593L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT593L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT593L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT593H: Graphic MMU LUT entry 593 high
func (o *GFXMMU_Type) SetLUT593H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT593H.Reg, volatile.LoadUint32(&o.LUT593H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT593H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT593H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT594L: Graphic MMU LUT entry 594 low
func (o *GFXMMU_Type) SetLUT594L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT594L.Reg, volatile.LoadUint32(&o.LUT594L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT594L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT594L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT594L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT594L.Reg, volatile.LoadUint32(&o.LUT594L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT594L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT594L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT594L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT594L.Reg, volatile.LoadUint32(&o.LUT594L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT594L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT594L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT594H: Graphic MMU LUT entry 594 high
func (o *GFXMMU_Type) SetLUT594H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT594H.Reg, volatile.LoadUint32(&o.LUT594H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT594H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT594H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT595L: Graphic MMU LUT entry 595 low
func (o *GFXMMU_Type) SetLUT595L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT595L.Reg, volatile.LoadUint32(&o.LUT595L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT595L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT595L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT595L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT595L.Reg, volatile.LoadUint32(&o.LUT595L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT595L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT595L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT595L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT595L.Reg, volatile.LoadUint32(&o.LUT595L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT595L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT595L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT595H: Graphic MMU LUT entry 595 high
func (o *GFXMMU_Type) SetLUT595H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT595H.Reg, volatile.LoadUint32(&o.LUT595H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT595H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT595H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT596L: Graphic MMU LUT entry 596 low
func (o *GFXMMU_Type) SetLUT596L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT596L.Reg, volatile.LoadUint32(&o.LUT596L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT596L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT596L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT596L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT596L.Reg, volatile.LoadUint32(&o.LUT596L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT596L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT596L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT596L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT596L.Reg, volatile.LoadUint32(&o.LUT596L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT596L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT596L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT596H: Graphic MMU LUT entry 596 high
func (o *GFXMMU_Type) SetLUT596H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT596H.Reg, volatile.LoadUint32(&o.LUT596H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT596H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT596H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT597L: Graphic MMU LUT entry 597 low
func (o *GFXMMU_Type) SetLUT597L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT597L.Reg, volatile.LoadUint32(&o.LUT597L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT597L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT597L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT597L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT597L.Reg, volatile.LoadUint32(&o.LUT597L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT597L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT597L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT597L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT597L.Reg, volatile.LoadUint32(&o.LUT597L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT597L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT597L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT597H: Graphic MMU LUT entry 597 high
func (o *GFXMMU_Type) SetLUT597H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT597H.Reg, volatile.LoadUint32(&o.LUT597H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT597H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT597H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT598L: Graphic MMU LUT entry 598 low
func (o *GFXMMU_Type) SetLUT598L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT598L.Reg, volatile.LoadUint32(&o.LUT598L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT598L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT598L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT598L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT598L.Reg, volatile.LoadUint32(&o.LUT598L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT598L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT598L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT598L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT598L.Reg, volatile.LoadUint32(&o.LUT598L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT598L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT598L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT598H: Graphic MMU LUT entry 598 high
func (o *GFXMMU_Type) SetLUT598H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT598H.Reg, volatile.LoadUint32(&o.LUT598H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT598H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT598H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT599L: Graphic MMU LUT entry 599 low
func (o *GFXMMU_Type) SetLUT599L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT599L.Reg, volatile.LoadUint32(&o.LUT599L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT599L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT599L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT599L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT599L.Reg, volatile.LoadUint32(&o.LUT599L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT599L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT599L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT599L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT599L.Reg, volatile.LoadUint32(&o.LUT599L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT599L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT599L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT599H: Graphic MMU LUT entry 599 high
func (o *GFXMMU_Type) SetLUT599H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT599H.Reg, volatile.LoadUint32(&o.LUT599H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT599H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT599H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT600L: Graphic MMU LUT entry 600 low
func (o *GFXMMU_Type) SetLUT600L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT600L.Reg, volatile.LoadUint32(&o.LUT600L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT600L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT600L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT600L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT600L.Reg, volatile.LoadUint32(&o.LUT600L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT600L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT600L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT600L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT600L.Reg, volatile.LoadUint32(&o.LUT600L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT600L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT600L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT600H: Graphic MMU LUT entry 600 high
func (o *GFXMMU_Type) SetLUT600H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT600H.Reg, volatile.LoadUint32(&o.LUT600H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT600H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT600H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT601L: Graphic MMU LUT entry 601 low
func (o *GFXMMU_Type) SetLUT601L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT601L.Reg, volatile.LoadUint32(&o.LUT601L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT601L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT601L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT601L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT601L.Reg, volatile.LoadUint32(&o.LUT601L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT601L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT601L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT601L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT601L.Reg, volatile.LoadUint32(&o.LUT601L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT601L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT601L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT601H: Graphic MMU LUT entry 601 high
func (o *GFXMMU_Type) SetLUT601H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT601H.Reg, volatile.LoadUint32(&o.LUT601H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT601H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT601H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT602L: Graphic MMU LUT entry 602 low
func (o *GFXMMU_Type) SetLUT602L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT602L.Reg, volatile.LoadUint32(&o.LUT602L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT602L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT602L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT602L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT602L.Reg, volatile.LoadUint32(&o.LUT602L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT602L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT602L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT602L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT602L.Reg, volatile.LoadUint32(&o.LUT602L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT602L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT602L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT602H: Graphic MMU LUT entry 602 high
func (o *GFXMMU_Type) SetLUT602H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT602H.Reg, volatile.LoadUint32(&o.LUT602H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT602H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT602H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT603L: Graphic MMU LUT entry 603 low
func (o *GFXMMU_Type) SetLUT603L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT603L.Reg, volatile.LoadUint32(&o.LUT603L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT603L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT603L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT603L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT603L.Reg, volatile.LoadUint32(&o.LUT603L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT603L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT603L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT603L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT603L.Reg, volatile.LoadUint32(&o.LUT603L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT603L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT603L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT603H: Graphic MMU LUT entry 603 high
func (o *GFXMMU_Type) SetLUT603H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT603H.Reg, volatile.LoadUint32(&o.LUT603H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT603H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT603H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT604L: Graphic MMU LUT entry 604 low
func (o *GFXMMU_Type) SetLUT604L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT604L.Reg, volatile.LoadUint32(&o.LUT604L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT604L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT604L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT604L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT604L.Reg, volatile.LoadUint32(&o.LUT604L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT604L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT604L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT604L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT604L.Reg, volatile.LoadUint32(&o.LUT604L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT604L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT604L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT604H: Graphic MMU LUT entry 604 high
func (o *GFXMMU_Type) SetLUT604H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT604H.Reg, volatile.LoadUint32(&o.LUT604H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT604H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT604H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT605L: Graphic MMU LUT entry 605 low
func (o *GFXMMU_Type) SetLUT605L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT605L.Reg, volatile.LoadUint32(&o.LUT605L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT605L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT605L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT605L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT605L.Reg, volatile.LoadUint32(&o.LUT605L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT605L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT605L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT605L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT605L.Reg, volatile.LoadUint32(&o.LUT605L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT605L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT605L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT605H: Graphic MMU LUT entry 605 high
func (o *GFXMMU_Type) SetLUT605H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT605H.Reg, volatile.LoadUint32(&o.LUT605H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT605H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT605H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT606L: Graphic MMU LUT entry 606 low
func (o *GFXMMU_Type) SetLUT606L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT606L.Reg, volatile.LoadUint32(&o.LUT606L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT606L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT606L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT606L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT606L.Reg, volatile.LoadUint32(&o.LUT606L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT606L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT606L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT606L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT606L.Reg, volatile.LoadUint32(&o.LUT606L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT606L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT606L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT606H: Graphic MMU LUT entry 606 high
func (o *GFXMMU_Type) SetLUT606H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT606H.Reg, volatile.LoadUint32(&o.LUT606H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT606H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT606H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT607L: Graphic MMU LUT entry 607 low
func (o *GFXMMU_Type) SetLUT607L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT607L.Reg, volatile.LoadUint32(&o.LUT607L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT607L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT607L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT607L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT607L.Reg, volatile.LoadUint32(&o.LUT607L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT607L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT607L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT607L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT607L.Reg, volatile.LoadUint32(&o.LUT607L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT607L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT607L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT607H: Graphic MMU LUT entry 607 high
func (o *GFXMMU_Type) SetLUT607H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT607H.Reg, volatile.LoadUint32(&o.LUT607H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT607H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT607H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT608L: Graphic MMU LUT entry 608 low
func (o *GFXMMU_Type) SetLUT608L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT608L.Reg, volatile.LoadUint32(&o.LUT608L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT608L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT608L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT608L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT608L.Reg, volatile.LoadUint32(&o.LUT608L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT608L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT608L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT608L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT608L.Reg, volatile.LoadUint32(&o.LUT608L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT608L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT608L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT608H: Graphic MMU LUT entry 608 high
func (o *GFXMMU_Type) SetLUT608H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT608H.Reg, volatile.LoadUint32(&o.LUT608H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT608H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT608H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT609L: Graphic MMU LUT entry 609 low
func (o *GFXMMU_Type) SetLUT609L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT609L.Reg, volatile.LoadUint32(&o.LUT609L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT609L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT609L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT609L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT609L.Reg, volatile.LoadUint32(&o.LUT609L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT609L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT609L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT609L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT609L.Reg, volatile.LoadUint32(&o.LUT609L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT609L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT609L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT609H: Graphic MMU LUT entry 609 high
func (o *GFXMMU_Type) SetLUT609H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT609H.Reg, volatile.LoadUint32(&o.LUT609H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT609H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT609H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT610L: Graphic MMU LUT entry 610 low
func (o *GFXMMU_Type) SetLUT610L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT610L.Reg, volatile.LoadUint32(&o.LUT610L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT610L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT610L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT610L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT610L.Reg, volatile.LoadUint32(&o.LUT610L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT610L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT610L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT610L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT610L.Reg, volatile.LoadUint32(&o.LUT610L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT610L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT610L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT610H: Graphic MMU LUT entry 610 high
func (o *GFXMMU_Type) SetLUT610H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT610H.Reg, volatile.LoadUint32(&o.LUT610H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT610H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT610H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT611L: Graphic MMU LUT entry 611 low
func (o *GFXMMU_Type) SetLUT611L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT611L.Reg, volatile.LoadUint32(&o.LUT611L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT611L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT611L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT611L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT611L.Reg, volatile.LoadUint32(&o.LUT611L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT611L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT611L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT611L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT611L.Reg, volatile.LoadUint32(&o.LUT611L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT611L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT611L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT611H: Graphic MMU LUT entry 611 high
func (o *GFXMMU_Type) SetLUT611H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT611H.Reg, volatile.LoadUint32(&o.LUT611H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT611H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT611H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT612L: Graphic MMU LUT entry 612 low
func (o *GFXMMU_Type) SetLUT612L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT612L.Reg, volatile.LoadUint32(&o.LUT612L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT612L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT612L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT612L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT612L.Reg, volatile.LoadUint32(&o.LUT612L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT612L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT612L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT612L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT612L.Reg, volatile.LoadUint32(&o.LUT612L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT612L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT612L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT612H: Graphic MMU LUT entry 612 high
func (o *GFXMMU_Type) SetLUT612H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT612H.Reg, volatile.LoadUint32(&o.LUT612H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT612H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT612H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT613L: Graphic MMU LUT entry 613 low
func (o *GFXMMU_Type) SetLUT613L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT613L.Reg, volatile.LoadUint32(&o.LUT613L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT613L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT613L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT613L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT613L.Reg, volatile.LoadUint32(&o.LUT613L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT613L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT613L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT613L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT613L.Reg, volatile.LoadUint32(&o.LUT613L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT613L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT613L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT613H: Graphic MMU LUT entry 613 high
func (o *GFXMMU_Type) SetLUT613H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT613H.Reg, volatile.LoadUint32(&o.LUT613H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT613H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT613H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT614L: Graphic MMU LUT entry 614 low
func (o *GFXMMU_Type) SetLUT614L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT614L.Reg, volatile.LoadUint32(&o.LUT614L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT614L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT614L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT614L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT614L.Reg, volatile.LoadUint32(&o.LUT614L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT614L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT614L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT614L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT614L.Reg, volatile.LoadUint32(&o.LUT614L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT614L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT614L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT614H: Graphic MMU LUT entry 614 high
func (o *GFXMMU_Type) SetLUT614H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT614H.Reg, volatile.LoadUint32(&o.LUT614H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT614H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT614H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT615L: Graphic MMU LUT entry 615 low
func (o *GFXMMU_Type) SetLUT615L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT615L.Reg, volatile.LoadUint32(&o.LUT615L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT615L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT615L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT615L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT615L.Reg, volatile.LoadUint32(&o.LUT615L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT615L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT615L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT615L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT615L.Reg, volatile.LoadUint32(&o.LUT615L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT615L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT615L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT615H: Graphic MMU LUT entry 615 high
func (o *GFXMMU_Type) SetLUT615H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT615H.Reg, volatile.LoadUint32(&o.LUT615H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT615H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT615H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT616L: Graphic MMU LUT entry 616 low
func (o *GFXMMU_Type) SetLUT616L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT616L.Reg, volatile.LoadUint32(&o.LUT616L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT616L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT616L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT616L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT616L.Reg, volatile.LoadUint32(&o.LUT616L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT616L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT616L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT616L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT616L.Reg, volatile.LoadUint32(&o.LUT616L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT616L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT616L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT616H: Graphic MMU LUT entry 616 high
func (o *GFXMMU_Type) SetLUT616H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT616H.Reg, volatile.LoadUint32(&o.LUT616H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT616H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT616H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT617L: Graphic MMU LUT entry 617 low
func (o *GFXMMU_Type) SetLUT617L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT617L.Reg, volatile.LoadUint32(&o.LUT617L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT617L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT617L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT617L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT617L.Reg, volatile.LoadUint32(&o.LUT617L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT617L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT617L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT617L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT617L.Reg, volatile.LoadUint32(&o.LUT617L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT617L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT617L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT617H: Graphic MMU LUT entry 617 high
func (o *GFXMMU_Type) SetLUT617H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT617H.Reg, volatile.LoadUint32(&o.LUT617H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT617H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT617H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT618L: Graphic MMU LUT entry 618 low
func (o *GFXMMU_Type) SetLUT618L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT618L.Reg, volatile.LoadUint32(&o.LUT618L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT618L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT618L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT618L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT618L.Reg, volatile.LoadUint32(&o.LUT618L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT618L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT618L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT618L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT618L.Reg, volatile.LoadUint32(&o.LUT618L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT618L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT618L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT618H: Graphic MMU LUT entry 618 high
func (o *GFXMMU_Type) SetLUT618H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT618H.Reg, volatile.LoadUint32(&o.LUT618H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT618H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT618H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT619L: Graphic MMU LUT entry 619 low
func (o *GFXMMU_Type) SetLUT619L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT619L.Reg, volatile.LoadUint32(&o.LUT619L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT619L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT619L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT619L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT619L.Reg, volatile.LoadUint32(&o.LUT619L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT619L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT619L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT619L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT619L.Reg, volatile.LoadUint32(&o.LUT619L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT619L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT619L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT619H: Graphic MMU LUT entry 619 high
func (o *GFXMMU_Type) SetLUT619H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT619H.Reg, volatile.LoadUint32(&o.LUT619H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT619H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT619H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT620L: Graphic MMU LUT entry 620 low
func (o *GFXMMU_Type) SetLUT620L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT620L.Reg, volatile.LoadUint32(&o.LUT620L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT620L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT620L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT620L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT620L.Reg, volatile.LoadUint32(&o.LUT620L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT620L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT620L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT620L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT620L.Reg, volatile.LoadUint32(&o.LUT620L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT620L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT620L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT620H: Graphic MMU LUT entry 620 high
func (o *GFXMMU_Type) SetLUT620H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT620H.Reg, volatile.LoadUint32(&o.LUT620H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT620H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT620H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT621L: Graphic MMU LUT entry 621 low
func (o *GFXMMU_Type) SetLUT621L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT621L.Reg, volatile.LoadUint32(&o.LUT621L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT621L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT621L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT621L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT621L.Reg, volatile.LoadUint32(&o.LUT621L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT621L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT621L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT621L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT621L.Reg, volatile.LoadUint32(&o.LUT621L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT621L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT621L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT621H: Graphic MMU LUT entry 621 high
func (o *GFXMMU_Type) SetLUT621H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT621H.Reg, volatile.LoadUint32(&o.LUT621H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT621H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT621H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT622L: Graphic MMU LUT entry 622 low
func (o *GFXMMU_Type) SetLUT622L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT622L.Reg, volatile.LoadUint32(&o.LUT622L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT622L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT622L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT622L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT622L.Reg, volatile.LoadUint32(&o.LUT622L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT622L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT622L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT622L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT622L.Reg, volatile.LoadUint32(&o.LUT622L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT622L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT622L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT622H: Graphic MMU LUT entry 622 high
func (o *GFXMMU_Type) SetLUT622H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT622H.Reg, volatile.LoadUint32(&o.LUT622H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT622H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT622H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT623L: Graphic MMU LUT entry 623 low
func (o *GFXMMU_Type) SetLUT623L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT623L.Reg, volatile.LoadUint32(&o.LUT623L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT623L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT623L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT623L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT623L.Reg, volatile.LoadUint32(&o.LUT623L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT623L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT623L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT623L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT623L.Reg, volatile.LoadUint32(&o.LUT623L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT623L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT623L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT623H: Graphic MMU LUT entry 623 high
func (o *GFXMMU_Type) SetLUT623H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT623H.Reg, volatile.LoadUint32(&o.LUT623H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT623H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT623H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT624L: Graphic MMU LUT entry 624 low
func (o *GFXMMU_Type) SetLUT624L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT624L.Reg, volatile.LoadUint32(&o.LUT624L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT624L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT624L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT624L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT624L.Reg, volatile.LoadUint32(&o.LUT624L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT624L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT624L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT624L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT624L.Reg, volatile.LoadUint32(&o.LUT624L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT624L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT624L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT624H: Graphic MMU LUT entry 624 high
func (o *GFXMMU_Type) SetLUT624H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT624H.Reg, volatile.LoadUint32(&o.LUT624H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT624H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT624H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT625L: Graphic MMU LUT entry 625 low
func (o *GFXMMU_Type) SetLUT625L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT625L.Reg, volatile.LoadUint32(&o.LUT625L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT625L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT625L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT625L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT625L.Reg, volatile.LoadUint32(&o.LUT625L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT625L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT625L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT625L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT625L.Reg, volatile.LoadUint32(&o.LUT625L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT625L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT625L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT625H: Graphic MMU LUT entry 625 high
func (o *GFXMMU_Type) SetLUT625H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT625H.Reg, volatile.LoadUint32(&o.LUT625H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT625H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT625H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT626L: Graphic MMU LUT entry 626 low
func (o *GFXMMU_Type) SetLUT626L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT626L.Reg, volatile.LoadUint32(&o.LUT626L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT626L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT626L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT626L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT626L.Reg, volatile.LoadUint32(&o.LUT626L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT626L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT626L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT626L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT626L.Reg, volatile.LoadUint32(&o.LUT626L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT626L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT626L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT626H: Graphic MMU LUT entry 626 high
func (o *GFXMMU_Type) SetLUT626H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT626H.Reg, volatile.LoadUint32(&o.LUT626H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT626H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT626H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT627L: Graphic MMU LUT entry 627 low
func (o *GFXMMU_Type) SetLUT627L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT627L.Reg, volatile.LoadUint32(&o.LUT627L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT627L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT627L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT627L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT627L.Reg, volatile.LoadUint32(&o.LUT627L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT627L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT627L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT627L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT627L.Reg, volatile.LoadUint32(&o.LUT627L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT627L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT627L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT627H: Graphic MMU LUT entry 627 high
func (o *GFXMMU_Type) SetLUT627H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT627H.Reg, volatile.LoadUint32(&o.LUT627H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT627H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT627H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT628L: Graphic MMU LUT entry 628 low
func (o *GFXMMU_Type) SetLUT628L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT628L.Reg, volatile.LoadUint32(&o.LUT628L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT628L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT628L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT628L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT628L.Reg, volatile.LoadUint32(&o.LUT628L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT628L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT628L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT628L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT628L.Reg, volatile.LoadUint32(&o.LUT628L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT628L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT628L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT628H: Graphic MMU LUT entry 628 high
func (o *GFXMMU_Type) SetLUT628H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT628H.Reg, volatile.LoadUint32(&o.LUT628H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT628H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT628H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT629L: Graphic MMU LUT entry 629 low
func (o *GFXMMU_Type) SetLUT629L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT629L.Reg, volatile.LoadUint32(&o.LUT629L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT629L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT629L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT629L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT629L.Reg, volatile.LoadUint32(&o.LUT629L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT629L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT629L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT629L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT629L.Reg, volatile.LoadUint32(&o.LUT629L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT629L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT629L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT629H: Graphic MMU LUT entry 629 high
func (o *GFXMMU_Type) SetLUT629H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT629H.Reg, volatile.LoadUint32(&o.LUT629H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT629H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT629H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT630L: Graphic MMU LUT entry 630 low
func (o *GFXMMU_Type) SetLUT630L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT630L.Reg, volatile.LoadUint32(&o.LUT630L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT630L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT630L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT630L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT630L.Reg, volatile.LoadUint32(&o.LUT630L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT630L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT630L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT630L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT630L.Reg, volatile.LoadUint32(&o.LUT630L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT630L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT630L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT630H: Graphic MMU LUT entry 630 high
func (o *GFXMMU_Type) SetLUT630H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT630H.Reg, volatile.LoadUint32(&o.LUT630H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT630H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT630H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT631L: Graphic MMU LUT entry 631 low
func (o *GFXMMU_Type) SetLUT631L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT631L.Reg, volatile.LoadUint32(&o.LUT631L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT631L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT631L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT631L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT631L.Reg, volatile.LoadUint32(&o.LUT631L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT631L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT631L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT631L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT631L.Reg, volatile.LoadUint32(&o.LUT631L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT631L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT631L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT631H: Graphic MMU LUT entry 631 high
func (o *GFXMMU_Type) SetLUT631H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT631H.Reg, volatile.LoadUint32(&o.LUT631H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT631H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT631H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT632L: Graphic MMU LUT entry 632 low
func (o *GFXMMU_Type) SetLUT632L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT632L.Reg, volatile.LoadUint32(&o.LUT632L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT632L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT632L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT632L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT632L.Reg, volatile.LoadUint32(&o.LUT632L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT632L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT632L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT632L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT632L.Reg, volatile.LoadUint32(&o.LUT632L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT632L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT632L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT632H: Graphic MMU LUT entry 632 high
func (o *GFXMMU_Type) SetLUT632H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT632H.Reg, volatile.LoadUint32(&o.LUT632H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT632H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT632H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT633L: Graphic MMU LUT entry 633 low
func (o *GFXMMU_Type) SetLUT633L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT633L.Reg, volatile.LoadUint32(&o.LUT633L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT633L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT633L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT633L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT633L.Reg, volatile.LoadUint32(&o.LUT633L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT633L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT633L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT633L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT633L.Reg, volatile.LoadUint32(&o.LUT633L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT633L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT633L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT633H: Graphic MMU LUT entry 633 high
func (o *GFXMMU_Type) SetLUT633H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT633H.Reg, volatile.LoadUint32(&o.LUT633H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT633H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT633H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT634L: Graphic MMU LUT entry 634 low
func (o *GFXMMU_Type) SetLUT634L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT634L.Reg, volatile.LoadUint32(&o.LUT634L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT634L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT634L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT634L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT634L.Reg, volatile.LoadUint32(&o.LUT634L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT634L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT634L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT634L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT634L.Reg, volatile.LoadUint32(&o.LUT634L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT634L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT634L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT634H: Graphic MMU LUT entry 634 high
func (o *GFXMMU_Type) SetLUT634H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT634H.Reg, volatile.LoadUint32(&o.LUT634H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT634H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT634H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT635L: Graphic MMU LUT entry 635 low
func (o *GFXMMU_Type) SetLUT635L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT635L.Reg, volatile.LoadUint32(&o.LUT635L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT635L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT635L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT635L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT635L.Reg, volatile.LoadUint32(&o.LUT635L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT635L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT635L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT635L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT635L.Reg, volatile.LoadUint32(&o.LUT635L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT635L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT635L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT635H: Graphic MMU LUT entry 635 high
func (o *GFXMMU_Type) SetLUT635H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT635H.Reg, volatile.LoadUint32(&o.LUT635H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT635H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT635H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT636L: Graphic MMU LUT entry 636 low
func (o *GFXMMU_Type) SetLUT636L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT636L.Reg, volatile.LoadUint32(&o.LUT636L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT636L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT636L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT636L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT636L.Reg, volatile.LoadUint32(&o.LUT636L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT636L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT636L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT636L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT636L.Reg, volatile.LoadUint32(&o.LUT636L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT636L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT636L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT636H: Graphic MMU LUT entry 636 high
func (o *GFXMMU_Type) SetLUT636H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT636H.Reg, volatile.LoadUint32(&o.LUT636H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT636H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT636H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT637L: Graphic MMU LUT entry 637 low
func (o *GFXMMU_Type) SetLUT637L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT637L.Reg, volatile.LoadUint32(&o.LUT637L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT637L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT637L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT637L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT637L.Reg, volatile.LoadUint32(&o.LUT637L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT637L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT637L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT637L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT637L.Reg, volatile.LoadUint32(&o.LUT637L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT637L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT637L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT637H: Graphic MMU LUT entry 637 high
func (o *GFXMMU_Type) SetLUT637H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT637H.Reg, volatile.LoadUint32(&o.LUT637H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT637H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT637H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT638L: Graphic MMU LUT entry 638 low
func (o *GFXMMU_Type) SetLUT638L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT638L.Reg, volatile.LoadUint32(&o.LUT638L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT638L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT638L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT638L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT638L.Reg, volatile.LoadUint32(&o.LUT638L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT638L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT638L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT638L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT638L.Reg, volatile.LoadUint32(&o.LUT638L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT638L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT638L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT638H: Graphic MMU LUT entry 638 high
func (o *GFXMMU_Type) SetLUT638H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT638H.Reg, volatile.LoadUint32(&o.LUT638H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT638H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT638H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT639L: Graphic MMU LUT entry 639 low
func (o *GFXMMU_Type) SetLUT639L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT639L.Reg, volatile.LoadUint32(&o.LUT639L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT639L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT639L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT639L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT639L.Reg, volatile.LoadUint32(&o.LUT639L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT639L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT639L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT639L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT639L.Reg, volatile.LoadUint32(&o.LUT639L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT639L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT639L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT639H: Graphic MMU LUT entry 639 high
func (o *GFXMMU_Type) SetLUT639H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT639H.Reg, volatile.LoadUint32(&o.LUT639H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT639H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT639H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT640L: Graphic MMU LUT entry 640 low
func (o *GFXMMU_Type) SetLUT640L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT640L.Reg, volatile.LoadUint32(&o.LUT640L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT640L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT640L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT640L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT640L.Reg, volatile.LoadUint32(&o.LUT640L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT640L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT640L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT640L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT640L.Reg, volatile.LoadUint32(&o.LUT640L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT640L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT640L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT640H: Graphic MMU LUT entry 640 high
func (o *GFXMMU_Type) SetLUT640H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT640H.Reg, volatile.LoadUint32(&o.LUT640H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT640H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT640H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT641L: Graphic MMU LUT entry 641 low
func (o *GFXMMU_Type) SetLUT641L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT641L.Reg, volatile.LoadUint32(&o.LUT641L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT641L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT641L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT641L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT641L.Reg, volatile.LoadUint32(&o.LUT641L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT641L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT641L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT641L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT641L.Reg, volatile.LoadUint32(&o.LUT641L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT641L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT641L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT641H: Graphic MMU LUT entry 641 high
func (o *GFXMMU_Type) SetLUT641H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT641H.Reg, volatile.LoadUint32(&o.LUT641H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT641H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT641H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT642L: Graphic MMU LUT entry 642 low
func (o *GFXMMU_Type) SetLUT642L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT642L.Reg, volatile.LoadUint32(&o.LUT642L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT642L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT642L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT642L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT642L.Reg, volatile.LoadUint32(&o.LUT642L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT642L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT642L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT642L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT642L.Reg, volatile.LoadUint32(&o.LUT642L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT642L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT642L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT642H: Graphic MMU LUT entry 642 high
func (o *GFXMMU_Type) SetLUT642H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT642H.Reg, volatile.LoadUint32(&o.LUT642H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT642H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT642H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT643L: Graphic MMU LUT entry 643 low
func (o *GFXMMU_Type) SetLUT643L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT643L.Reg, volatile.LoadUint32(&o.LUT643L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT643L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT643L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT643L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT643L.Reg, volatile.LoadUint32(&o.LUT643L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT643L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT643L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT643L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT643L.Reg, volatile.LoadUint32(&o.LUT643L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT643L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT643L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT643H: Graphic MMU LUT entry 643 high
func (o *GFXMMU_Type) SetLUT643H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT643H.Reg, volatile.LoadUint32(&o.LUT643H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT643H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT643H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT644L: Graphic MMU LUT entry 644 low
func (o *GFXMMU_Type) SetLUT644L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT644L.Reg, volatile.LoadUint32(&o.LUT644L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT644L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT644L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT644L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT644L.Reg, volatile.LoadUint32(&o.LUT644L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT644L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT644L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT644L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT644L.Reg, volatile.LoadUint32(&o.LUT644L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT644L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT644L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT644H: Graphic MMU LUT entry 644 high
func (o *GFXMMU_Type) SetLUT644H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT644H.Reg, volatile.LoadUint32(&o.LUT644H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT644H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT644H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT645L: Graphic MMU LUT entry 645 low
func (o *GFXMMU_Type) SetLUT645L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT645L.Reg, volatile.LoadUint32(&o.LUT645L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT645L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT645L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT645L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT645L.Reg, volatile.LoadUint32(&o.LUT645L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT645L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT645L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT645L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT645L.Reg, volatile.LoadUint32(&o.LUT645L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT645L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT645L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT645H: Graphic MMU LUT entry 645 high
func (o *GFXMMU_Type) SetLUT645H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT645H.Reg, volatile.LoadUint32(&o.LUT645H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT645H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT645H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT646L: Graphic MMU LUT entry 646 low
func (o *GFXMMU_Type) SetLUT646L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT646L.Reg, volatile.LoadUint32(&o.LUT646L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT646L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT646L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT646L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT646L.Reg, volatile.LoadUint32(&o.LUT646L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT646L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT646L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT646L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT646L.Reg, volatile.LoadUint32(&o.LUT646L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT646L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT646L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT646H: Graphic MMU LUT entry 646 high
func (o *GFXMMU_Type) SetLUT646H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT646H.Reg, volatile.LoadUint32(&o.LUT646H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT646H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT646H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT647L: Graphic MMU LUT entry 647 low
func (o *GFXMMU_Type) SetLUT647L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT647L.Reg, volatile.LoadUint32(&o.LUT647L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT647L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT647L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT647L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT647L.Reg, volatile.LoadUint32(&o.LUT647L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT647L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT647L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT647L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT647L.Reg, volatile.LoadUint32(&o.LUT647L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT647L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT647L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT647H: Graphic MMU LUT entry 647 high
func (o *GFXMMU_Type) SetLUT647H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT647H.Reg, volatile.LoadUint32(&o.LUT647H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT647H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT647H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT648L: Graphic MMU LUT entry 648 low
func (o *GFXMMU_Type) SetLUT648L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT648L.Reg, volatile.LoadUint32(&o.LUT648L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT648L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT648L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT648L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT648L.Reg, volatile.LoadUint32(&o.LUT648L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT648L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT648L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT648L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT648L.Reg, volatile.LoadUint32(&o.LUT648L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT648L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT648L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT648H: Graphic MMU LUT entry 648 high
func (o *GFXMMU_Type) SetLUT648H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT648H.Reg, volatile.LoadUint32(&o.LUT648H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT648H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT648H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT649L: Graphic MMU LUT entry 649 low
func (o *GFXMMU_Type) SetLUT649L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT649L.Reg, volatile.LoadUint32(&o.LUT649L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT649L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT649L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT649L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT649L.Reg, volatile.LoadUint32(&o.LUT649L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT649L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT649L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT649L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT649L.Reg, volatile.LoadUint32(&o.LUT649L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT649L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT649L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT649H: Graphic MMU LUT entry 649 high
func (o *GFXMMU_Type) SetLUT649H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT649H.Reg, volatile.LoadUint32(&o.LUT649H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT649H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT649H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT650L: Graphic MMU LUT entry 650 low
func (o *GFXMMU_Type) SetLUT650L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT650L.Reg, volatile.LoadUint32(&o.LUT650L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT650L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT650L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT650L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT650L.Reg, volatile.LoadUint32(&o.LUT650L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT650L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT650L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT650L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT650L.Reg, volatile.LoadUint32(&o.LUT650L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT650L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT650L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT650H: Graphic MMU LUT entry 650 high
func (o *GFXMMU_Type) SetLUT650H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT650H.Reg, volatile.LoadUint32(&o.LUT650H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT650H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT650H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT651L: Graphic MMU LUT entry 651 low
func (o *GFXMMU_Type) SetLUT651L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT651L.Reg, volatile.LoadUint32(&o.LUT651L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT651L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT651L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT651L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT651L.Reg, volatile.LoadUint32(&o.LUT651L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT651L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT651L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT651L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT651L.Reg, volatile.LoadUint32(&o.LUT651L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT651L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT651L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT651H: Graphic MMU LUT entry 651 high
func (o *GFXMMU_Type) SetLUT651H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT651H.Reg, volatile.LoadUint32(&o.LUT651H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT651H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT651H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT652L: Graphic MMU LUT entry 652 low
func (o *GFXMMU_Type) SetLUT652L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT652L.Reg, volatile.LoadUint32(&o.LUT652L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT652L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT652L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT652L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT652L.Reg, volatile.LoadUint32(&o.LUT652L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT652L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT652L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT652L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT652L.Reg, volatile.LoadUint32(&o.LUT652L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT652L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT652L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT652H: Graphic MMU LUT entry 652 high
func (o *GFXMMU_Type) SetLUT652H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT652H.Reg, volatile.LoadUint32(&o.LUT652H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT652H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT652H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT653L: Graphic MMU LUT entry 653 low
func (o *GFXMMU_Type) SetLUT653L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT653L.Reg, volatile.LoadUint32(&o.LUT653L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT653L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT653L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT653L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT653L.Reg, volatile.LoadUint32(&o.LUT653L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT653L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT653L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT653L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT653L.Reg, volatile.LoadUint32(&o.LUT653L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT653L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT653L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT653H: Graphic MMU LUT entry 653 high
func (o *GFXMMU_Type) SetLUT653H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT653H.Reg, volatile.LoadUint32(&o.LUT653H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT653H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT653H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT654L: Graphic MMU LUT entry 654 low
func (o *GFXMMU_Type) SetLUT654L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT654L.Reg, volatile.LoadUint32(&o.LUT654L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT654L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT654L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT654L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT654L.Reg, volatile.LoadUint32(&o.LUT654L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT654L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT654L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT654L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT654L.Reg, volatile.LoadUint32(&o.LUT654L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT654L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT654L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT654H: Graphic MMU LUT entry 654 high
func (o *GFXMMU_Type) SetLUT654H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT654H.Reg, volatile.LoadUint32(&o.LUT654H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT654H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT654H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT655L: Graphic MMU LUT entry 655 low
func (o *GFXMMU_Type) SetLUT655L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT655L.Reg, volatile.LoadUint32(&o.LUT655L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT655L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT655L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT655L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT655L.Reg, volatile.LoadUint32(&o.LUT655L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT655L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT655L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT655L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT655L.Reg, volatile.LoadUint32(&o.LUT655L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT655L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT655L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT655H: Graphic MMU LUT entry 655 high
func (o *GFXMMU_Type) SetLUT655H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT655H.Reg, volatile.LoadUint32(&o.LUT655H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT655H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT655H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT656L: Graphic MMU LUT entry 656 low
func (o *GFXMMU_Type) SetLUT656L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT656L.Reg, volatile.LoadUint32(&o.LUT656L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT656L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT656L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT656L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT656L.Reg, volatile.LoadUint32(&o.LUT656L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT656L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT656L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT656L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT656L.Reg, volatile.LoadUint32(&o.LUT656L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT656L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT656L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT656H: Graphic MMU LUT entry 656 high
func (o *GFXMMU_Type) SetLUT656H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT656H.Reg, volatile.LoadUint32(&o.LUT656H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT656H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT656H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT657L: Graphic MMU LUT entry 657 low
func (o *GFXMMU_Type) SetLUT657L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT657L.Reg, volatile.LoadUint32(&o.LUT657L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT657L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT657L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT657L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT657L.Reg, volatile.LoadUint32(&o.LUT657L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT657L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT657L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT657L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT657L.Reg, volatile.LoadUint32(&o.LUT657L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT657L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT657L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT657H: Graphic MMU LUT entry 657 high
func (o *GFXMMU_Type) SetLUT657H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT657H.Reg, volatile.LoadUint32(&o.LUT657H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT657H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT657H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT658L: Graphic MMU LUT entry 658 low
func (o *GFXMMU_Type) SetLUT658L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT658L.Reg, volatile.LoadUint32(&o.LUT658L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT658L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT658L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT658L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT658L.Reg, volatile.LoadUint32(&o.LUT658L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT658L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT658L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT658L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT658L.Reg, volatile.LoadUint32(&o.LUT658L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT658L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT658L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT658H: Graphic MMU LUT entry 658 high
func (o *GFXMMU_Type) SetLUT658H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT658H.Reg, volatile.LoadUint32(&o.LUT658H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT658H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT658H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT659L: Graphic MMU LUT entry 659 low
func (o *GFXMMU_Type) SetLUT659L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT659L.Reg, volatile.LoadUint32(&o.LUT659L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT659L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT659L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT659L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT659L.Reg, volatile.LoadUint32(&o.LUT659L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT659L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT659L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT659L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT659L.Reg, volatile.LoadUint32(&o.LUT659L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT659L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT659L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT659H: Graphic MMU LUT entry 659 high
func (o *GFXMMU_Type) SetLUT659H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT659H.Reg, volatile.LoadUint32(&o.LUT659H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT659H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT659H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT660L: Graphic MMU LUT entry 660 low
func (o *GFXMMU_Type) SetLUT660L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT660L.Reg, volatile.LoadUint32(&o.LUT660L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT660L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT660L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT660L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT660L.Reg, volatile.LoadUint32(&o.LUT660L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT660L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT660L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT660L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT660L.Reg, volatile.LoadUint32(&o.LUT660L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT660L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT660L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT660H: Graphic MMU LUT entry 660 high
func (o *GFXMMU_Type) SetLUT660H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT660H.Reg, volatile.LoadUint32(&o.LUT660H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT660H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT660H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT661L: Graphic MMU LUT entry 661 low
func (o *GFXMMU_Type) SetLUT661L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT661L.Reg, volatile.LoadUint32(&o.LUT661L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT661L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT661L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT661L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT661L.Reg, volatile.LoadUint32(&o.LUT661L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT661L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT661L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT661L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT661L.Reg, volatile.LoadUint32(&o.LUT661L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT661L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT661L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT661H: Graphic MMU LUT entry 661 high
func (o *GFXMMU_Type) SetLUT661H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT661H.Reg, volatile.LoadUint32(&o.LUT661H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT661H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT661H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT662L: Graphic MMU LUT entry 662 low
func (o *GFXMMU_Type) SetLUT662L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT662L.Reg, volatile.LoadUint32(&o.LUT662L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT662L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT662L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT662L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT662L.Reg, volatile.LoadUint32(&o.LUT662L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT662L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT662L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT662L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT662L.Reg, volatile.LoadUint32(&o.LUT662L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT662L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT662L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT662H: Graphic MMU LUT entry 662 high
func (o *GFXMMU_Type) SetLUT662H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT662H.Reg, volatile.LoadUint32(&o.LUT662H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT662H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT662H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT663L: Graphic MMU LUT entry 663 low
func (o *GFXMMU_Type) SetLUT663L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT663L.Reg, volatile.LoadUint32(&o.LUT663L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT663L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT663L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT663L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT663L.Reg, volatile.LoadUint32(&o.LUT663L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT663L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT663L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT663L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT663L.Reg, volatile.LoadUint32(&o.LUT663L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT663L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT663L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT663H: Graphic MMU LUT entry 663 high
func (o *GFXMMU_Type) SetLUT663H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT663H.Reg, volatile.LoadUint32(&o.LUT663H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT663H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT663H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT664L: Graphic MMU LUT entry 664 low
func (o *GFXMMU_Type) SetLUT664L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT664L.Reg, volatile.LoadUint32(&o.LUT664L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT664L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT664L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT664L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT664L.Reg, volatile.LoadUint32(&o.LUT664L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT664L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT664L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT664L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT664L.Reg, volatile.LoadUint32(&o.LUT664L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT664L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT664L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT664H: Graphic MMU LUT entry 664 high
func (o *GFXMMU_Type) SetLUT664H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT664H.Reg, volatile.LoadUint32(&o.LUT664H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT664H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT664H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT665L: Graphic MMU LUT entry 665 low
func (o *GFXMMU_Type) SetLUT665L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT665L.Reg, volatile.LoadUint32(&o.LUT665L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT665L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT665L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT665L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT665L.Reg, volatile.LoadUint32(&o.LUT665L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT665L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT665L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT665L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT665L.Reg, volatile.LoadUint32(&o.LUT665L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT665L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT665L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT665H: Graphic MMU LUT entry 665 high
func (o *GFXMMU_Type) SetLUT665H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT665H.Reg, volatile.LoadUint32(&o.LUT665H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT665H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT665H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT666L: Graphic MMU LUT entry 666 low
func (o *GFXMMU_Type) SetLUT666L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT666L.Reg, volatile.LoadUint32(&o.LUT666L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT666L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT666L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT666L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT666L.Reg, volatile.LoadUint32(&o.LUT666L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT666L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT666L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT666L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT666L.Reg, volatile.LoadUint32(&o.LUT666L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT666L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT666L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT666H: Graphic MMU LUT entry 666 high
func (o *GFXMMU_Type) SetLUT666H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT666H.Reg, volatile.LoadUint32(&o.LUT666H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT666H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT666H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT667L: Graphic MMU LUT entry 667 low
func (o *GFXMMU_Type) SetLUT667L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT667L.Reg, volatile.LoadUint32(&o.LUT667L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT667L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT667L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT667L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT667L.Reg, volatile.LoadUint32(&o.LUT667L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT667L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT667L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT667L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT667L.Reg, volatile.LoadUint32(&o.LUT667L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT667L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT667L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT667H: Graphic MMU LUT entry 667 high
func (o *GFXMMU_Type) SetLUT667H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT667H.Reg, volatile.LoadUint32(&o.LUT667H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT667H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT667H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT668L: Graphic MMU LUT entry 668 low
func (o *GFXMMU_Type) SetLUT668L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT668L.Reg, volatile.LoadUint32(&o.LUT668L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT668L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT668L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT668L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT668L.Reg, volatile.LoadUint32(&o.LUT668L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT668L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT668L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT668L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT668L.Reg, volatile.LoadUint32(&o.LUT668L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT668L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT668L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT668H: Graphic MMU LUT entry 668 high
func (o *GFXMMU_Type) SetLUT668H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT668H.Reg, volatile.LoadUint32(&o.LUT668H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT668H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT668H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT669L: Graphic MMU LUT entry 669 low
func (o *GFXMMU_Type) SetLUT669L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT669L.Reg, volatile.LoadUint32(&o.LUT669L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT669L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT669L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT669L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT669L.Reg, volatile.LoadUint32(&o.LUT669L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT669L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT669L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT669L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT669L.Reg, volatile.LoadUint32(&o.LUT669L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT669L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT669L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT669H: Graphic MMU LUT entry 669 high
func (o *GFXMMU_Type) SetLUT669H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT669H.Reg, volatile.LoadUint32(&o.LUT669H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT669H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT669H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT670L: Graphic MMU LUT entry 670 low
func (o *GFXMMU_Type) SetLUT670L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT670L.Reg, volatile.LoadUint32(&o.LUT670L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT670L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT670L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT670L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT670L.Reg, volatile.LoadUint32(&o.LUT670L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT670L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT670L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT670L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT670L.Reg, volatile.LoadUint32(&o.LUT670L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT670L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT670L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT670H: Graphic MMU LUT entry 670 high
func (o *GFXMMU_Type) SetLUT670H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT670H.Reg, volatile.LoadUint32(&o.LUT670H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT670H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT670H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT671L: Graphic MMU LUT entry 671 low
func (o *GFXMMU_Type) SetLUT671L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT671L.Reg, volatile.LoadUint32(&o.LUT671L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT671L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT671L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT671L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT671L.Reg, volatile.LoadUint32(&o.LUT671L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT671L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT671L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT671L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT671L.Reg, volatile.LoadUint32(&o.LUT671L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT671L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT671L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT671H: Graphic MMU LUT entry 671 high
func (o *GFXMMU_Type) SetLUT671H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT671H.Reg, volatile.LoadUint32(&o.LUT671H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT671H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT671H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT672L: Graphic MMU LUT entry 672 low
func (o *GFXMMU_Type) SetLUT672L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT672L.Reg, volatile.LoadUint32(&o.LUT672L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT672L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT672L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT672L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT672L.Reg, volatile.LoadUint32(&o.LUT672L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT672L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT672L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT672L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT672L.Reg, volatile.LoadUint32(&o.LUT672L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT672L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT672L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT672H: Graphic MMU LUT entry 672 high
func (o *GFXMMU_Type) SetLUT672H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT672H.Reg, volatile.LoadUint32(&o.LUT672H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT672H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT672H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT673L: Graphic MMU LUT entry 673 low
func (o *GFXMMU_Type) SetLUT673L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT673L.Reg, volatile.LoadUint32(&o.LUT673L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT673L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT673L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT673L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT673L.Reg, volatile.LoadUint32(&o.LUT673L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT673L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT673L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT673L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT673L.Reg, volatile.LoadUint32(&o.LUT673L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT673L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT673L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT673H: Graphic MMU LUT entry 673 high
func (o *GFXMMU_Type) SetLUT673H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT673H.Reg, volatile.LoadUint32(&o.LUT673H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT673H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT673H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT674L: Graphic MMU LUT entry 674 low
func (o *GFXMMU_Type) SetLUT674L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT674L.Reg, volatile.LoadUint32(&o.LUT674L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT674L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT674L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT674L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT674L.Reg, volatile.LoadUint32(&o.LUT674L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT674L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT674L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT674L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT674L.Reg, volatile.LoadUint32(&o.LUT674L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT674L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT674L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT674H: Graphic MMU LUT entry 674 high
func (o *GFXMMU_Type) SetLUT674H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT674H.Reg, volatile.LoadUint32(&o.LUT674H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT674H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT674H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT675L: Graphic MMU LUT entry 675 low
func (o *GFXMMU_Type) SetLUT675L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT675L.Reg, volatile.LoadUint32(&o.LUT675L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT675L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT675L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT675L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT675L.Reg, volatile.LoadUint32(&o.LUT675L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT675L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT675L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT675L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT675L.Reg, volatile.LoadUint32(&o.LUT675L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT675L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT675L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT675H: Graphic MMU LUT entry 675 high
func (o *GFXMMU_Type) SetLUT675H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT675H.Reg, volatile.LoadUint32(&o.LUT675H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT675H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT675H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT676L: Graphic MMU LUT entry 676 low
func (o *GFXMMU_Type) SetLUT676L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT676L.Reg, volatile.LoadUint32(&o.LUT676L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT676L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT676L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT676L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT676L.Reg, volatile.LoadUint32(&o.LUT676L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT676L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT676L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT676L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT676L.Reg, volatile.LoadUint32(&o.LUT676L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT676L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT676L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT676H: Graphic MMU LUT entry 676 high
func (o *GFXMMU_Type) SetLUT676H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT676H.Reg, volatile.LoadUint32(&o.LUT676H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT676H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT676H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT677L: Graphic MMU LUT entry 677 low
func (o *GFXMMU_Type) SetLUT677L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT677L.Reg, volatile.LoadUint32(&o.LUT677L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT677L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT677L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT677L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT677L.Reg, volatile.LoadUint32(&o.LUT677L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT677L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT677L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT677L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT677L.Reg, volatile.LoadUint32(&o.LUT677L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT677L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT677L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT677H: Graphic MMU LUT entry 677 high
func (o *GFXMMU_Type) SetLUT677H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT677H.Reg, volatile.LoadUint32(&o.LUT677H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT677H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT677H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT678L: Graphic MMU LUT entry 678 low
func (o *GFXMMU_Type) SetLUT678L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT678L.Reg, volatile.LoadUint32(&o.LUT678L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT678L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT678L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT678L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT678L.Reg, volatile.LoadUint32(&o.LUT678L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT678L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT678L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT678L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT678L.Reg, volatile.LoadUint32(&o.LUT678L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT678L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT678L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT678H: Graphic MMU LUT entry 678 high
func (o *GFXMMU_Type) SetLUT678H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT678H.Reg, volatile.LoadUint32(&o.LUT678H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT678H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT678H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT679L: Graphic MMU LUT entry 679 low
func (o *GFXMMU_Type) SetLUT679L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT679L.Reg, volatile.LoadUint32(&o.LUT679L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT679L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT679L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT679L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT679L.Reg, volatile.LoadUint32(&o.LUT679L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT679L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT679L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT679L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT679L.Reg, volatile.LoadUint32(&o.LUT679L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT679L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT679L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT679H: Graphic MMU LUT entry 679 high
func (o *GFXMMU_Type) SetLUT679H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT679H.Reg, volatile.LoadUint32(&o.LUT679H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT679H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT679H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT680L: Graphic MMU LUT entry 680 low
func (o *GFXMMU_Type) SetLUT680L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT680L.Reg, volatile.LoadUint32(&o.LUT680L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT680L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT680L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT680L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT680L.Reg, volatile.LoadUint32(&o.LUT680L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT680L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT680L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT680L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT680L.Reg, volatile.LoadUint32(&o.LUT680L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT680L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT680L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT680H: Graphic MMU LUT entry 680 high
func (o *GFXMMU_Type) SetLUT680H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT680H.Reg, volatile.LoadUint32(&o.LUT680H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT680H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT680H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT681L: Graphic MMU LUT entry 681 low
func (o *GFXMMU_Type) SetLUT681L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT681L.Reg, volatile.LoadUint32(&o.LUT681L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT681L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT681L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT681L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT681L.Reg, volatile.LoadUint32(&o.LUT681L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT681L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT681L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT681L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT681L.Reg, volatile.LoadUint32(&o.LUT681L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT681L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT681L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT681H: Graphic MMU LUT entry 681 high
func (o *GFXMMU_Type) SetLUT681H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT681H.Reg, volatile.LoadUint32(&o.LUT681H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT681H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT681H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT682L: Graphic MMU LUT entry 682 low
func (o *GFXMMU_Type) SetLUT682L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT682L.Reg, volatile.LoadUint32(&o.LUT682L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT682L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT682L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT682L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT682L.Reg, volatile.LoadUint32(&o.LUT682L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT682L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT682L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT682L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT682L.Reg, volatile.LoadUint32(&o.LUT682L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT682L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT682L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT682H: Graphic MMU LUT entry 682 high
func (o *GFXMMU_Type) SetLUT682H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT682H.Reg, volatile.LoadUint32(&o.LUT682H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT682H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT682H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT683L: Graphic MMU LUT entry 683 low
func (o *GFXMMU_Type) SetLUT683L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT683L.Reg, volatile.LoadUint32(&o.LUT683L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT683L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT683L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT683L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT683L.Reg, volatile.LoadUint32(&o.LUT683L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT683L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT683L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT683L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT683L.Reg, volatile.LoadUint32(&o.LUT683L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT683L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT683L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT683H: Graphic MMU LUT entry 683 high
func (o *GFXMMU_Type) SetLUT683H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT683H.Reg, volatile.LoadUint32(&o.LUT683H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT683H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT683H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT684L: Graphic MMU LUT entry 684 low
func (o *GFXMMU_Type) SetLUT684L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT684L.Reg, volatile.LoadUint32(&o.LUT684L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT684L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT684L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT684L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT684L.Reg, volatile.LoadUint32(&o.LUT684L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT684L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT684L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT684L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT684L.Reg, volatile.LoadUint32(&o.LUT684L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT684L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT684L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT684H: Graphic MMU LUT entry 684 high
func (o *GFXMMU_Type) SetLUT684H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT684H.Reg, volatile.LoadUint32(&o.LUT684H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT684H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT684H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT685L: Graphic MMU LUT entry 685 low
func (o *GFXMMU_Type) SetLUT685L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT685L.Reg, volatile.LoadUint32(&o.LUT685L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT685L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT685L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT685L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT685L.Reg, volatile.LoadUint32(&o.LUT685L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT685L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT685L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT685L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT685L.Reg, volatile.LoadUint32(&o.LUT685L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT685L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT685L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT685H: Graphic MMU LUT entry 685 high
func (o *GFXMMU_Type) SetLUT685H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT685H.Reg, volatile.LoadUint32(&o.LUT685H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT685H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT685H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT686L: Graphic MMU LUT entry 686 low
func (o *GFXMMU_Type) SetLUT686L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT686L.Reg, volatile.LoadUint32(&o.LUT686L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT686L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT686L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT686L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT686L.Reg, volatile.LoadUint32(&o.LUT686L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT686L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT686L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT686L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT686L.Reg, volatile.LoadUint32(&o.LUT686L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT686L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT686L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT686H: Graphic MMU LUT entry 686 high
func (o *GFXMMU_Type) SetLUT686H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT686H.Reg, volatile.LoadUint32(&o.LUT686H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT686H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT686H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT687L: Graphic MMU LUT entry 687 low
func (o *GFXMMU_Type) SetLUT687L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT687L.Reg, volatile.LoadUint32(&o.LUT687L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT687L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT687L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT687L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT687L.Reg, volatile.LoadUint32(&o.LUT687L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT687L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT687L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT687L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT687L.Reg, volatile.LoadUint32(&o.LUT687L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT687L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT687L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT687H: Graphic MMU LUT entry 687 high
func (o *GFXMMU_Type) SetLUT687H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT687H.Reg, volatile.LoadUint32(&o.LUT687H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT687H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT687H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT688L: Graphic MMU LUT entry 688 low
func (o *GFXMMU_Type) SetLUT688L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT688L.Reg, volatile.LoadUint32(&o.LUT688L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT688L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT688L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT688L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT688L.Reg, volatile.LoadUint32(&o.LUT688L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT688L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT688L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT688L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT688L.Reg, volatile.LoadUint32(&o.LUT688L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT688L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT688L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT688H: Graphic MMU LUT entry 688 high
func (o *GFXMMU_Type) SetLUT688H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT688H.Reg, volatile.LoadUint32(&o.LUT688H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT688H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT688H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT689L: Graphic MMU LUT entry 689 low
func (o *GFXMMU_Type) SetLUT689L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT689L.Reg, volatile.LoadUint32(&o.LUT689L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT689L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT689L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT689L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT689L.Reg, volatile.LoadUint32(&o.LUT689L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT689L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT689L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT689L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT689L.Reg, volatile.LoadUint32(&o.LUT689L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT689L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT689L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT689H: Graphic MMU LUT entry 689 high
func (o *GFXMMU_Type) SetLUT689H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT689H.Reg, volatile.LoadUint32(&o.LUT689H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT689H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT689H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT690L: Graphic MMU LUT entry 690 low
func (o *GFXMMU_Type) SetLUT690L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT690L.Reg, volatile.LoadUint32(&o.LUT690L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT690L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT690L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT690L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT690L.Reg, volatile.LoadUint32(&o.LUT690L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT690L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT690L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT690L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT690L.Reg, volatile.LoadUint32(&o.LUT690L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT690L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT690L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT690H: Graphic MMU LUT entry 690 high
func (o *GFXMMU_Type) SetLUT690H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT690H.Reg, volatile.LoadUint32(&o.LUT690H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT690H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT690H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT691L: Graphic MMU LUT entry 691 low
func (o *GFXMMU_Type) SetLUT691L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT691L.Reg, volatile.LoadUint32(&o.LUT691L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT691L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT691L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT691L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT691L.Reg, volatile.LoadUint32(&o.LUT691L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT691L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT691L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT691L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT691L.Reg, volatile.LoadUint32(&o.LUT691L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT691L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT691L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT691H: Graphic MMU LUT entry 691 high
func (o *GFXMMU_Type) SetLUT691H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT691H.Reg, volatile.LoadUint32(&o.LUT691H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT691H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT691H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT692L: Graphic MMU LUT entry 692 low
func (o *GFXMMU_Type) SetLUT692L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT692L.Reg, volatile.LoadUint32(&o.LUT692L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT692L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT692L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT692L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT692L.Reg, volatile.LoadUint32(&o.LUT692L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT692L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT692L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT692L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT692L.Reg, volatile.LoadUint32(&o.LUT692L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT692L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT692L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT692H: Graphic MMU LUT entry 692 high
func (o *GFXMMU_Type) SetLUT692H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT692H.Reg, volatile.LoadUint32(&o.LUT692H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT692H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT692H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT693L: Graphic MMU LUT entry 693 low
func (o *GFXMMU_Type) SetLUT693L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT693L.Reg, volatile.LoadUint32(&o.LUT693L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT693L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT693L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT693L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT693L.Reg, volatile.LoadUint32(&o.LUT693L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT693L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT693L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT693L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT693L.Reg, volatile.LoadUint32(&o.LUT693L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT693L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT693L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT693H: Graphic MMU LUT entry 693 high
func (o *GFXMMU_Type) SetLUT693H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT693H.Reg, volatile.LoadUint32(&o.LUT693H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT693H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT693H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT694L: Graphic MMU LUT entry 694 low
func (o *GFXMMU_Type) SetLUT694L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT694L.Reg, volatile.LoadUint32(&o.LUT694L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT694L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT694L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT694L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT694L.Reg, volatile.LoadUint32(&o.LUT694L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT694L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT694L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT694L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT694L.Reg, volatile.LoadUint32(&o.LUT694L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT694L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT694L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT694H: Graphic MMU LUT entry 694 high
func (o *GFXMMU_Type) SetLUT694H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT694H.Reg, volatile.LoadUint32(&o.LUT694H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT694H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT694H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT695L: Graphic MMU LUT entry 695 low
func (o *GFXMMU_Type) SetLUT695L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT695L.Reg, volatile.LoadUint32(&o.LUT695L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT695L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT695L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT695L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT695L.Reg, volatile.LoadUint32(&o.LUT695L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT695L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT695L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT695L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT695L.Reg, volatile.LoadUint32(&o.LUT695L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT695L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT695L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT695H: Graphic MMU LUT entry 695 high
func (o *GFXMMU_Type) SetLUT695H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT695H.Reg, volatile.LoadUint32(&o.LUT695H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT695H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT695H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT696L: Graphic MMU LUT entry 696 low
func (o *GFXMMU_Type) SetLUT696L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT696L.Reg, volatile.LoadUint32(&o.LUT696L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT696L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT696L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT696L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT696L.Reg, volatile.LoadUint32(&o.LUT696L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT696L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT696L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT696L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT696L.Reg, volatile.LoadUint32(&o.LUT696L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT696L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT696L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT696H: Graphic MMU LUT entry 696 high
func (o *GFXMMU_Type) SetLUT696H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT696H.Reg, volatile.LoadUint32(&o.LUT696H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT696H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT696H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT697L: Graphic MMU LUT entry 697 low
func (o *GFXMMU_Type) SetLUT697L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT697L.Reg, volatile.LoadUint32(&o.LUT697L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT697L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT697L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT697L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT697L.Reg, volatile.LoadUint32(&o.LUT697L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT697L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT697L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT697L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT697L.Reg, volatile.LoadUint32(&o.LUT697L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT697L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT697L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT697H: Graphic MMU LUT entry 697 high
func (o *GFXMMU_Type) SetLUT697H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT697H.Reg, volatile.LoadUint32(&o.LUT697H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT697H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT697H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT698L: Graphic MMU LUT entry 698 low
func (o *GFXMMU_Type) SetLUT698L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT698L.Reg, volatile.LoadUint32(&o.LUT698L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT698L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT698L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT698L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT698L.Reg, volatile.LoadUint32(&o.LUT698L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT698L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT698L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT698L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT698L.Reg, volatile.LoadUint32(&o.LUT698L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT698L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT698L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT698H: Graphic MMU LUT entry 698 high
func (o *GFXMMU_Type) SetLUT698H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT698H.Reg, volatile.LoadUint32(&o.LUT698H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT698H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT698H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT699L: Graphic MMU LUT entry 699 low
func (o *GFXMMU_Type) SetLUT699L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT699L.Reg, volatile.LoadUint32(&o.LUT699L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT699L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT699L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT699L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT699L.Reg, volatile.LoadUint32(&o.LUT699L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT699L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT699L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT699L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT699L.Reg, volatile.LoadUint32(&o.LUT699L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT699L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT699L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT699H: Graphic MMU LUT entry 699 high
func (o *GFXMMU_Type) SetLUT699H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT699H.Reg, volatile.LoadUint32(&o.LUT699H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT699H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT699H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT700L: Graphic MMU LUT entry 700 low
func (o *GFXMMU_Type) SetLUT700L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT700L.Reg, volatile.LoadUint32(&o.LUT700L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT700L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT700L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT700L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT700L.Reg, volatile.LoadUint32(&o.LUT700L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT700L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT700L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT700L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT700L.Reg, volatile.LoadUint32(&o.LUT700L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT700L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT700L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT700H: Graphic MMU LUT entry 700 high
func (o *GFXMMU_Type) SetLUT700H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT700H.Reg, volatile.LoadUint32(&o.LUT700H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT700H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT700H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT701L: Graphic MMU LUT entry 701 low
func (o *GFXMMU_Type) SetLUT701L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT701L.Reg, volatile.LoadUint32(&o.LUT701L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT701L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT701L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT701L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT701L.Reg, volatile.LoadUint32(&o.LUT701L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT701L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT701L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT701L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT701L.Reg, volatile.LoadUint32(&o.LUT701L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT701L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT701L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT701H: Graphic MMU LUT entry 701 high
func (o *GFXMMU_Type) SetLUT701H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT701H.Reg, volatile.LoadUint32(&o.LUT701H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT701H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT701H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT702L: Graphic MMU LUT entry 702 low
func (o *GFXMMU_Type) SetLUT702L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT702L.Reg, volatile.LoadUint32(&o.LUT702L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT702L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT702L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT702L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT702L.Reg, volatile.LoadUint32(&o.LUT702L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT702L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT702L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT702L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT702L.Reg, volatile.LoadUint32(&o.LUT702L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT702L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT702L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT702H: Graphic MMU LUT entry 702 high
func (o *GFXMMU_Type) SetLUT702H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT702H.Reg, volatile.LoadUint32(&o.LUT702H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT702H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT702H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT703L: Graphic MMU LUT entry 703 low
func (o *GFXMMU_Type) SetLUT703L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT703L.Reg, volatile.LoadUint32(&o.LUT703L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT703L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT703L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT703L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT703L.Reg, volatile.LoadUint32(&o.LUT703L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT703L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT703L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT703L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT703L.Reg, volatile.LoadUint32(&o.LUT703L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT703L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT703L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT703H: Graphic MMU LUT entry 703 high
func (o *GFXMMU_Type) SetLUT703H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT703H.Reg, volatile.LoadUint32(&o.LUT703H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT703H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT703H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT704L: Graphic MMU LUT entry 704 low
func (o *GFXMMU_Type) SetLUT704L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT704L.Reg, volatile.LoadUint32(&o.LUT704L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT704L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT704L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT704L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT704L.Reg, volatile.LoadUint32(&o.LUT704L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT704L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT704L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT704L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT704L.Reg, volatile.LoadUint32(&o.LUT704L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT704L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT704L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT704H: Graphic MMU LUT entry 704 high
func (o *GFXMMU_Type) SetLUT704H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT704H.Reg, volatile.LoadUint32(&o.LUT704H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT704H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT704H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT705L: Graphic MMU LUT entry 705 low
func (o *GFXMMU_Type) SetLUT705L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT705L.Reg, volatile.LoadUint32(&o.LUT705L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT705L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT705L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT705L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT705L.Reg, volatile.LoadUint32(&o.LUT705L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT705L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT705L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT705L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT705L.Reg, volatile.LoadUint32(&o.LUT705L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT705L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT705L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT705H: Graphic MMU LUT entry 705 high
func (o *GFXMMU_Type) SetLUT705H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT705H.Reg, volatile.LoadUint32(&o.LUT705H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT705H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT705H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT706L: Graphic MMU LUT entry 706 low
func (o *GFXMMU_Type) SetLUT706L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT706L.Reg, volatile.LoadUint32(&o.LUT706L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT706L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT706L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT706L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT706L.Reg, volatile.LoadUint32(&o.LUT706L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT706L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT706L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT706L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT706L.Reg, volatile.LoadUint32(&o.LUT706L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT706L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT706L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT706H: Graphic MMU LUT entry 706 high
func (o *GFXMMU_Type) SetLUT706H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT706H.Reg, volatile.LoadUint32(&o.LUT706H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT706H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT706H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT707L: Graphic MMU LUT entry 707 low
func (o *GFXMMU_Type) SetLUT707L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT707L.Reg, volatile.LoadUint32(&o.LUT707L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT707L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT707L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT707L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT707L.Reg, volatile.LoadUint32(&o.LUT707L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT707L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT707L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT707L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT707L.Reg, volatile.LoadUint32(&o.LUT707L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT707L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT707L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT707H: Graphic MMU LUT entry 707 high
func (o *GFXMMU_Type) SetLUT707H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT707H.Reg, volatile.LoadUint32(&o.LUT707H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT707H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT707H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT708L: Graphic MMU LUT entry 708 low
func (o *GFXMMU_Type) SetLUT708L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT708L.Reg, volatile.LoadUint32(&o.LUT708L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT708L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT708L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT708L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT708L.Reg, volatile.LoadUint32(&o.LUT708L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT708L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT708L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT708L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT708L.Reg, volatile.LoadUint32(&o.LUT708L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT708L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT708L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT708H: Graphic MMU LUT entry 708 high
func (o *GFXMMU_Type) SetLUT708H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT708H.Reg, volatile.LoadUint32(&o.LUT708H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT708H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT708H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT709L: Graphic MMU LUT entry 709 low
func (o *GFXMMU_Type) SetLUT709L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT709L.Reg, volatile.LoadUint32(&o.LUT709L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT709L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT709L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT709L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT709L.Reg, volatile.LoadUint32(&o.LUT709L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT709L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT709L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT709L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT709L.Reg, volatile.LoadUint32(&o.LUT709L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT709L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT709L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT709H: Graphic MMU LUT entry 709 high
func (o *GFXMMU_Type) SetLUT709H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT709H.Reg, volatile.LoadUint32(&o.LUT709H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT709H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT709H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT710L: Graphic MMU LUT entry 710 low
func (o *GFXMMU_Type) SetLUT710L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT710L.Reg, volatile.LoadUint32(&o.LUT710L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT710L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT710L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT710L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT710L.Reg, volatile.LoadUint32(&o.LUT710L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT710L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT710L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT710L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT710L.Reg, volatile.LoadUint32(&o.LUT710L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT710L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT710L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT710H: Graphic MMU LUT entry 710 high
func (o *GFXMMU_Type) SetLUT710H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT710H.Reg, volatile.LoadUint32(&o.LUT710H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT710H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT710H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT711L: Graphic MMU LUT entry 711 low
func (o *GFXMMU_Type) SetLUT711L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT711L.Reg, volatile.LoadUint32(&o.LUT711L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT711L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT711L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT711L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT711L.Reg, volatile.LoadUint32(&o.LUT711L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT711L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT711L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT711L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT711L.Reg, volatile.LoadUint32(&o.LUT711L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT711L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT711L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT711H: Graphic MMU LUT entry 711 high
func (o *GFXMMU_Type) SetLUT711H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT711H.Reg, volatile.LoadUint32(&o.LUT711H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT711H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT711H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT712L: Graphic MMU LUT entry 712 low
func (o *GFXMMU_Type) SetLUT712L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT712L.Reg, volatile.LoadUint32(&o.LUT712L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT712L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT712L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT712L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT712L.Reg, volatile.LoadUint32(&o.LUT712L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT712L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT712L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT712L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT712L.Reg, volatile.LoadUint32(&o.LUT712L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT712L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT712L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT712H: Graphic MMU LUT entry 712 high
func (o *GFXMMU_Type) SetLUT712H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT712H.Reg, volatile.LoadUint32(&o.LUT712H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT712H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT712H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT713L: Graphic MMU LUT entry 713 low
func (o *GFXMMU_Type) SetLUT713L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT713L.Reg, volatile.LoadUint32(&o.LUT713L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT713L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT713L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT713L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT713L.Reg, volatile.LoadUint32(&o.LUT713L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT713L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT713L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT713L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT713L.Reg, volatile.LoadUint32(&o.LUT713L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT713L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT713L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT713H: Graphic MMU LUT entry 713 high
func (o *GFXMMU_Type) SetLUT713H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT713H.Reg, volatile.LoadUint32(&o.LUT713H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT713H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT713H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT714L: Graphic MMU LUT entry 714 low
func (o *GFXMMU_Type) SetLUT714L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT714L.Reg, volatile.LoadUint32(&o.LUT714L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT714L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT714L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT714L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT714L.Reg, volatile.LoadUint32(&o.LUT714L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT714L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT714L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT714L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT714L.Reg, volatile.LoadUint32(&o.LUT714L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT714L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT714L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT714H: Graphic MMU LUT entry 714 high
func (o *GFXMMU_Type) SetLUT714H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT714H.Reg, volatile.LoadUint32(&o.LUT714H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT714H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT714H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT715L: Graphic MMU LUT entry 715 low
func (o *GFXMMU_Type) SetLUT715L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT715L.Reg, volatile.LoadUint32(&o.LUT715L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT715L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT715L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT715L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT715L.Reg, volatile.LoadUint32(&o.LUT715L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT715L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT715L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT715L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT715L.Reg, volatile.LoadUint32(&o.LUT715L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT715L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT715L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT715H: Graphic MMU LUT entry 715 high
func (o *GFXMMU_Type) SetLUT715H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT715H.Reg, volatile.LoadUint32(&o.LUT715H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT715H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT715H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT716L: Graphic MMU LUT entry 716 low
func (o *GFXMMU_Type) SetLUT716L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT716L.Reg, volatile.LoadUint32(&o.LUT716L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT716L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT716L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT716L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT716L.Reg, volatile.LoadUint32(&o.LUT716L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT716L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT716L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT716L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT716L.Reg, volatile.LoadUint32(&o.LUT716L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT716L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT716L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT716H: Graphic MMU LUT entry 716 high
func (o *GFXMMU_Type) SetLUT716H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT716H.Reg, volatile.LoadUint32(&o.LUT716H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT716H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT716H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT717L: Graphic MMU LUT entry 717 low
func (o *GFXMMU_Type) SetLUT717L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT717L.Reg, volatile.LoadUint32(&o.LUT717L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT717L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT717L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT717L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT717L.Reg, volatile.LoadUint32(&o.LUT717L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT717L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT717L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT717L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT717L.Reg, volatile.LoadUint32(&o.LUT717L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT717L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT717L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT717H: Graphic MMU LUT entry 717 high
func (o *GFXMMU_Type) SetLUT717H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT717H.Reg, volatile.LoadUint32(&o.LUT717H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT717H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT717H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT718L: Graphic MMU LUT entry 718 low
func (o *GFXMMU_Type) SetLUT718L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT718L.Reg, volatile.LoadUint32(&o.LUT718L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT718L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT718L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT718L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT718L.Reg, volatile.LoadUint32(&o.LUT718L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT718L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT718L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT718L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT718L.Reg, volatile.LoadUint32(&o.LUT718L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT718L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT718L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT718H: Graphic MMU LUT entry 718 high
func (o *GFXMMU_Type) SetLUT718H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT718H.Reg, volatile.LoadUint32(&o.LUT718H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT718H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT718H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT719L: Graphic MMU LUT entry 719 low
func (o *GFXMMU_Type) SetLUT719L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT719L.Reg, volatile.LoadUint32(&o.LUT719L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT719L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT719L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT719L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT719L.Reg, volatile.LoadUint32(&o.LUT719L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT719L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT719L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT719L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT719L.Reg, volatile.LoadUint32(&o.LUT719L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT719L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT719L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT719H: Graphic MMU LUT entry 719 high
func (o *GFXMMU_Type) SetLUT719H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT719H.Reg, volatile.LoadUint32(&o.LUT719H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT719H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT719H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT720L: Graphic MMU LUT entry 720 low
func (o *GFXMMU_Type) SetLUT720L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT720L.Reg, volatile.LoadUint32(&o.LUT720L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT720L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT720L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT720L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT720L.Reg, volatile.LoadUint32(&o.LUT720L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT720L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT720L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT720L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT720L.Reg, volatile.LoadUint32(&o.LUT720L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT720L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT720L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT720H: Graphic MMU LUT entry 720 high
func (o *GFXMMU_Type) SetLUT720H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT720H.Reg, volatile.LoadUint32(&o.LUT720H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT720H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT720H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT721L: Graphic MMU LUT entry 721 low
func (o *GFXMMU_Type) SetLUT721L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT721L.Reg, volatile.LoadUint32(&o.LUT721L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT721L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT721L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT721L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT721L.Reg, volatile.LoadUint32(&o.LUT721L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT721L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT721L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT721L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT721L.Reg, volatile.LoadUint32(&o.LUT721L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT721L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT721L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT721H: Graphic MMU LUT entry 721 high
func (o *GFXMMU_Type) SetLUT721H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT721H.Reg, volatile.LoadUint32(&o.LUT721H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT721H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT721H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT722L: Graphic MMU LUT entry 722 low
func (o *GFXMMU_Type) SetLUT722L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT722L.Reg, volatile.LoadUint32(&o.LUT722L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT722L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT722L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT722L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT722L.Reg, volatile.LoadUint32(&o.LUT722L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT722L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT722L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT722L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT722L.Reg, volatile.LoadUint32(&o.LUT722L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT722L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT722L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT722H: Graphic MMU LUT entry 722 high
func (o *GFXMMU_Type) SetLUT722H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT722H.Reg, volatile.LoadUint32(&o.LUT722H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT722H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT722H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT723L: Graphic MMU LUT entry 723 low
func (o *GFXMMU_Type) SetLUT723L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT723L.Reg, volatile.LoadUint32(&o.LUT723L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT723L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT723L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT723L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT723L.Reg, volatile.LoadUint32(&o.LUT723L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT723L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT723L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT723L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT723L.Reg, volatile.LoadUint32(&o.LUT723L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT723L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT723L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT723H: Graphic MMU LUT entry 723 high
func (o *GFXMMU_Type) SetLUT723H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT723H.Reg, volatile.LoadUint32(&o.LUT723H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT723H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT723H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT724L: Graphic MMU LUT entry 724 low
func (o *GFXMMU_Type) SetLUT724L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT724L.Reg, volatile.LoadUint32(&o.LUT724L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT724L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT724L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT724L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT724L.Reg, volatile.LoadUint32(&o.LUT724L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT724L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT724L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT724L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT724L.Reg, volatile.LoadUint32(&o.LUT724L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT724L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT724L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT724H: Graphic MMU LUT entry 724 high
func (o *GFXMMU_Type) SetLUT724H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT724H.Reg, volatile.LoadUint32(&o.LUT724H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT724H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT724H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT725L: Graphic MMU LUT entry 725 low
func (o *GFXMMU_Type) SetLUT725L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT725L.Reg, volatile.LoadUint32(&o.LUT725L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT725L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT725L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT725L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT725L.Reg, volatile.LoadUint32(&o.LUT725L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT725L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT725L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT725L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT725L.Reg, volatile.LoadUint32(&o.LUT725L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT725L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT725L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT725H: Graphic MMU LUT entry 725 high
func (o *GFXMMU_Type) SetLUT725H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT725H.Reg, volatile.LoadUint32(&o.LUT725H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT725H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT725H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT726L: Graphic MMU LUT entry 726 low
func (o *GFXMMU_Type) SetLUT726L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT726L.Reg, volatile.LoadUint32(&o.LUT726L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT726L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT726L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT726L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT726L.Reg, volatile.LoadUint32(&o.LUT726L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT726L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT726L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT726L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT726L.Reg, volatile.LoadUint32(&o.LUT726L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT726L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT726L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT726H: Graphic MMU LUT entry 726 high
func (o *GFXMMU_Type) SetLUT726H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT726H.Reg, volatile.LoadUint32(&o.LUT726H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT726H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT726H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT727L: Graphic MMU LUT entry 727 low
func (o *GFXMMU_Type) SetLUT727L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT727L.Reg, volatile.LoadUint32(&o.LUT727L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT727L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT727L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT727L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT727L.Reg, volatile.LoadUint32(&o.LUT727L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT727L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT727L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT727L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT727L.Reg, volatile.LoadUint32(&o.LUT727L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT727L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT727L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT727H: Graphic MMU LUT entry 727 high
func (o *GFXMMU_Type) SetLUT727H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT727H.Reg, volatile.LoadUint32(&o.LUT727H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT727H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT727H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT728L: Graphic MMU LUT entry 728 low
func (o *GFXMMU_Type) SetLUT728L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT728L.Reg, volatile.LoadUint32(&o.LUT728L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT728L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT728L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT728L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT728L.Reg, volatile.LoadUint32(&o.LUT728L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT728L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT728L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT728L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT728L.Reg, volatile.LoadUint32(&o.LUT728L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT728L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT728L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT728H: Graphic MMU LUT entry 728 high
func (o *GFXMMU_Type) SetLUT728H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT728H.Reg, volatile.LoadUint32(&o.LUT728H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT728H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT728H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT729L: Graphic MMU LUT entry 729 low
func (o *GFXMMU_Type) SetLUT729L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT729L.Reg, volatile.LoadUint32(&o.LUT729L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT729L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT729L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT729L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT729L.Reg, volatile.LoadUint32(&o.LUT729L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT729L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT729L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT729L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT729L.Reg, volatile.LoadUint32(&o.LUT729L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT729L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT729L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT729H: Graphic MMU LUT entry 729 high
func (o *GFXMMU_Type) SetLUT729H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT729H.Reg, volatile.LoadUint32(&o.LUT729H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT729H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT729H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT730L: Graphic MMU LUT entry 730 low
func (o *GFXMMU_Type) SetLUT730L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT730L.Reg, volatile.LoadUint32(&o.LUT730L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT730L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT730L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT730L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT730L.Reg, volatile.LoadUint32(&o.LUT730L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT730L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT730L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT730L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT730L.Reg, volatile.LoadUint32(&o.LUT730L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT730L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT730L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT730H: Graphic MMU LUT entry 730 high
func (o *GFXMMU_Type) SetLUT730H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT730H.Reg, volatile.LoadUint32(&o.LUT730H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT730H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT730H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT731L: Graphic MMU LUT entry 731 low
func (o *GFXMMU_Type) SetLUT731L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT731L.Reg, volatile.LoadUint32(&o.LUT731L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT731L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT731L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT731L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT731L.Reg, volatile.LoadUint32(&o.LUT731L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT731L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT731L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT731L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT731L.Reg, volatile.LoadUint32(&o.LUT731L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT731L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT731L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT731H: Graphic MMU LUT entry 731 high
func (o *GFXMMU_Type) SetLUT731H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT731H.Reg, volatile.LoadUint32(&o.LUT731H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT731H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT731H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT732L: Graphic MMU LUT entry 732 low
func (o *GFXMMU_Type) SetLUT732L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT732L.Reg, volatile.LoadUint32(&o.LUT732L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT732L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT732L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT732L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT732L.Reg, volatile.LoadUint32(&o.LUT732L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT732L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT732L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT732L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT732L.Reg, volatile.LoadUint32(&o.LUT732L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT732L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT732L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT732H: Graphic MMU LUT entry 732 high
func (o *GFXMMU_Type) SetLUT732H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT732H.Reg, volatile.LoadUint32(&o.LUT732H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT732H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT732H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT733L: Graphic MMU LUT entry 733 low
func (o *GFXMMU_Type) SetLUT733L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT733L.Reg, volatile.LoadUint32(&o.LUT733L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT733L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT733L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT733L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT733L.Reg, volatile.LoadUint32(&o.LUT733L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT733L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT733L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT733L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT733L.Reg, volatile.LoadUint32(&o.LUT733L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT733L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT733L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT733H: Graphic MMU LUT entry 733 high
func (o *GFXMMU_Type) SetLUT733H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT733H.Reg, volatile.LoadUint32(&o.LUT733H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT733H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT733H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT734L: Graphic MMU LUT entry 734 low
func (o *GFXMMU_Type) SetLUT734L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT734L.Reg, volatile.LoadUint32(&o.LUT734L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT734L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT734L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT734L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT734L.Reg, volatile.LoadUint32(&o.LUT734L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT734L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT734L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT734L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT734L.Reg, volatile.LoadUint32(&o.LUT734L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT734L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT734L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT734H: Graphic MMU LUT entry 734 high
func (o *GFXMMU_Type) SetLUT734H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT734H.Reg, volatile.LoadUint32(&o.LUT734H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT734H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT734H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT735L: Graphic MMU LUT entry 735 low
func (o *GFXMMU_Type) SetLUT735L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT735L.Reg, volatile.LoadUint32(&o.LUT735L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT735L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT735L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT735L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT735L.Reg, volatile.LoadUint32(&o.LUT735L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT735L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT735L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT735L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT735L.Reg, volatile.LoadUint32(&o.LUT735L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT735L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT735L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT735H: Graphic MMU LUT entry 735 high
func (o *GFXMMU_Type) SetLUT735H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT735H.Reg, volatile.LoadUint32(&o.LUT735H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT735H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT735H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT736L: Graphic MMU LUT entry 736 low
func (o *GFXMMU_Type) SetLUT736L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT736L.Reg, volatile.LoadUint32(&o.LUT736L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT736L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT736L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT736L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT736L.Reg, volatile.LoadUint32(&o.LUT736L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT736L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT736L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT736L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT736L.Reg, volatile.LoadUint32(&o.LUT736L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT736L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT736L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT736H: Graphic MMU LUT entry 736 high
func (o *GFXMMU_Type) SetLUT736H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT736H.Reg, volatile.LoadUint32(&o.LUT736H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT736H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT736H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT737L: Graphic MMU LUT entry 737 low
func (o *GFXMMU_Type) SetLUT737L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT737L.Reg, volatile.LoadUint32(&o.LUT737L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT737L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT737L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT737L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT737L.Reg, volatile.LoadUint32(&o.LUT737L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT737L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT737L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT737L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT737L.Reg, volatile.LoadUint32(&o.LUT737L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT737L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT737L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT737H: Graphic MMU LUT entry 737 high
func (o *GFXMMU_Type) SetLUT737H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT737H.Reg, volatile.LoadUint32(&o.LUT737H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT737H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT737H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT738L: Graphic MMU LUT entry 738 low
func (o *GFXMMU_Type) SetLUT738L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT738L.Reg, volatile.LoadUint32(&o.LUT738L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT738L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT738L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT738L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT738L.Reg, volatile.LoadUint32(&o.LUT738L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT738L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT738L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT738L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT738L.Reg, volatile.LoadUint32(&o.LUT738L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT738L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT738L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT738H: Graphic MMU LUT entry 738 high
func (o *GFXMMU_Type) SetLUT738H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT738H.Reg, volatile.LoadUint32(&o.LUT738H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT738H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT738H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT739L: Graphic MMU LUT entry 739 low
func (o *GFXMMU_Type) SetLUT739L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT739L.Reg, volatile.LoadUint32(&o.LUT739L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT739L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT739L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT739L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT739L.Reg, volatile.LoadUint32(&o.LUT739L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT739L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT739L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT739L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT739L.Reg, volatile.LoadUint32(&o.LUT739L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT739L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT739L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT739H: Graphic MMU LUT entry 739 high
func (o *GFXMMU_Type) SetLUT739H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT739H.Reg, volatile.LoadUint32(&o.LUT739H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT739H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT739H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT740L: Graphic MMU LUT entry 740 low
func (o *GFXMMU_Type) SetLUT740L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT740L.Reg, volatile.LoadUint32(&o.LUT740L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT740L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT740L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT740L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT740L.Reg, volatile.LoadUint32(&o.LUT740L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT740L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT740L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT740L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT740L.Reg, volatile.LoadUint32(&o.LUT740L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT740L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT740L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT740H: Graphic MMU LUT entry 740 high
func (o *GFXMMU_Type) SetLUT740H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT740H.Reg, volatile.LoadUint32(&o.LUT740H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT740H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT740H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT741L: Graphic MMU LUT entry 741 low
func (o *GFXMMU_Type) SetLUT741L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT741L.Reg, volatile.LoadUint32(&o.LUT741L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT741L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT741L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT741L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT741L.Reg, volatile.LoadUint32(&o.LUT741L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT741L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT741L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT741L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT741L.Reg, volatile.LoadUint32(&o.LUT741L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT741L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT741L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT741H: Graphic MMU LUT entry 741 high
func (o *GFXMMU_Type) SetLUT741H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT741H.Reg, volatile.LoadUint32(&o.LUT741H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT741H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT741H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT742L: Graphic MMU LUT entry 742 low
func (o *GFXMMU_Type) SetLUT742L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT742L.Reg, volatile.LoadUint32(&o.LUT742L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT742L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT742L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT742L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT742L.Reg, volatile.LoadUint32(&o.LUT742L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT742L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT742L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT742L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT742L.Reg, volatile.LoadUint32(&o.LUT742L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT742L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT742L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT742H: Graphic MMU LUT entry 742 high
func (o *GFXMMU_Type) SetLUT742H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT742H.Reg, volatile.LoadUint32(&o.LUT742H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT742H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT742H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT743L: Graphic MMU LUT entry 743 low
func (o *GFXMMU_Type) SetLUT743L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT743L.Reg, volatile.LoadUint32(&o.LUT743L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT743L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT743L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT743L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT743L.Reg, volatile.LoadUint32(&o.LUT743L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT743L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT743L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT743L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT743L.Reg, volatile.LoadUint32(&o.LUT743L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT743L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT743L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT743H: Graphic MMU LUT entry 743 high
func (o *GFXMMU_Type) SetLUT743H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT743H.Reg, volatile.LoadUint32(&o.LUT743H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT743H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT743H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT744L: Graphic MMU LUT entry 744 low
func (o *GFXMMU_Type) SetLUT744L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT744L.Reg, volatile.LoadUint32(&o.LUT744L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT744L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT744L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT744L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT744L.Reg, volatile.LoadUint32(&o.LUT744L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT744L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT744L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT744L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT744L.Reg, volatile.LoadUint32(&o.LUT744L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT744L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT744L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT744H: Graphic MMU LUT entry 744 high
func (o *GFXMMU_Type) SetLUT744H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT744H.Reg, volatile.LoadUint32(&o.LUT744H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT744H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT744H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT745L: Graphic MMU LUT entry 745 low
func (o *GFXMMU_Type) SetLUT745L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT745L.Reg, volatile.LoadUint32(&o.LUT745L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT745L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT745L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT745L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT745L.Reg, volatile.LoadUint32(&o.LUT745L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT745L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT745L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT745L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT745L.Reg, volatile.LoadUint32(&o.LUT745L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT745L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT745L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT745H: Graphic MMU LUT entry 745 high
func (o *GFXMMU_Type) SetLUT745H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT745H.Reg, volatile.LoadUint32(&o.LUT745H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT745H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT745H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT746L: Graphic MMU LUT entry 746 low
func (o *GFXMMU_Type) SetLUT746L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT746L.Reg, volatile.LoadUint32(&o.LUT746L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT746L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT746L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT746L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT746L.Reg, volatile.LoadUint32(&o.LUT746L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT746L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT746L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT746L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT746L.Reg, volatile.LoadUint32(&o.LUT746L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT746L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT746L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT746H: Graphic MMU LUT entry 746 high
func (o *GFXMMU_Type) SetLUT746H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT746H.Reg, volatile.LoadUint32(&o.LUT746H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT746H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT746H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT747L: Graphic MMU LUT entry 747 low
func (o *GFXMMU_Type) SetLUT747L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT747L.Reg, volatile.LoadUint32(&o.LUT747L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT747L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT747L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT747L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT747L.Reg, volatile.LoadUint32(&o.LUT747L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT747L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT747L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT747L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT747L.Reg, volatile.LoadUint32(&o.LUT747L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT747L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT747L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT747H: Graphic MMU LUT entry 747 high
func (o *GFXMMU_Type) SetLUT747H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT747H.Reg, volatile.LoadUint32(&o.LUT747H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT747H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT747H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT748L: Graphic MMU LUT entry 748 low
func (o *GFXMMU_Type) SetLUT748L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT748L.Reg, volatile.LoadUint32(&o.LUT748L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT748L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT748L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT748L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT748L.Reg, volatile.LoadUint32(&o.LUT748L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT748L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT748L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT748L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT748L.Reg, volatile.LoadUint32(&o.LUT748L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT748L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT748L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT748H: Graphic MMU LUT entry 748 high
func (o *GFXMMU_Type) SetLUT748H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT748H.Reg, volatile.LoadUint32(&o.LUT748H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT748H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT748H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT749L: Graphic MMU LUT entry 749 low
func (o *GFXMMU_Type) SetLUT749L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT749L.Reg, volatile.LoadUint32(&o.LUT749L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT749L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT749L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT749L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT749L.Reg, volatile.LoadUint32(&o.LUT749L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT749L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT749L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT749L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT749L.Reg, volatile.LoadUint32(&o.LUT749L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT749L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT749L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT749H: Graphic MMU LUT entry 749 high
func (o *GFXMMU_Type) SetLUT749H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT749H.Reg, volatile.LoadUint32(&o.LUT749H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT749H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT749H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT750L: Graphic MMU LUT entry 750 low
func (o *GFXMMU_Type) SetLUT750L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT750L.Reg, volatile.LoadUint32(&o.LUT750L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT750L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT750L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT750L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT750L.Reg, volatile.LoadUint32(&o.LUT750L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT750L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT750L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT750L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT750L.Reg, volatile.LoadUint32(&o.LUT750L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT750L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT750L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT750H: Graphic MMU LUT entry 750 high
func (o *GFXMMU_Type) SetLUT750H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT750H.Reg, volatile.LoadUint32(&o.LUT750H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT750H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT750H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT751L: Graphic MMU LUT entry 751 low
func (o *GFXMMU_Type) SetLUT751L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT751L.Reg, volatile.LoadUint32(&o.LUT751L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT751L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT751L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT751L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT751L.Reg, volatile.LoadUint32(&o.LUT751L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT751L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT751L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT751L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT751L.Reg, volatile.LoadUint32(&o.LUT751L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT751L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT751L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT751H: Graphic MMU LUT entry 751 high
func (o *GFXMMU_Type) SetLUT751H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT751H.Reg, volatile.LoadUint32(&o.LUT751H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT751H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT751H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT752L: Graphic MMU LUT entry 752 low
func (o *GFXMMU_Type) SetLUT752L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT752L.Reg, volatile.LoadUint32(&o.LUT752L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT752L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT752L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT752L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT752L.Reg, volatile.LoadUint32(&o.LUT752L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT752L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT752L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT752L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT752L.Reg, volatile.LoadUint32(&o.LUT752L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT752L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT752L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT752H: Graphic MMU LUT entry 752 high
func (o *GFXMMU_Type) SetLUT752H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT752H.Reg, volatile.LoadUint32(&o.LUT752H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT752H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT752H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT753L: Graphic MMU LUT entry 753 low
func (o *GFXMMU_Type) SetLUT753L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT753L.Reg, volatile.LoadUint32(&o.LUT753L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT753L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT753L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT753L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT753L.Reg, volatile.LoadUint32(&o.LUT753L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT753L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT753L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT753L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT753L.Reg, volatile.LoadUint32(&o.LUT753L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT753L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT753L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT753H: Graphic MMU LUT entry 753 high
func (o *GFXMMU_Type) SetLUT753H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT753H.Reg, volatile.LoadUint32(&o.LUT753H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT753H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT753H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT754L: Graphic MMU LUT entry 754 low
func (o *GFXMMU_Type) SetLUT754L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT754L.Reg, volatile.LoadUint32(&o.LUT754L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT754L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT754L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT754L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT754L.Reg, volatile.LoadUint32(&o.LUT754L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT754L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT754L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT754L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT754L.Reg, volatile.LoadUint32(&o.LUT754L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT754L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT754L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT754H: Graphic MMU LUT entry 754 high
func (o *GFXMMU_Type) SetLUT754H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT754H.Reg, volatile.LoadUint32(&o.LUT754H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT754H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT754H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT755L: Graphic MMU LUT entry 755 low
func (o *GFXMMU_Type) SetLUT755L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT755L.Reg, volatile.LoadUint32(&o.LUT755L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT755L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT755L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT755L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT755L.Reg, volatile.LoadUint32(&o.LUT755L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT755L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT755L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT755L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT755L.Reg, volatile.LoadUint32(&o.LUT755L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT755L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT755L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT755H: Graphic MMU LUT entry 755 high
func (o *GFXMMU_Type) SetLUT755H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT755H.Reg, volatile.LoadUint32(&o.LUT755H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT755H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT755H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT756L: Graphic MMU LUT entry 756 low
func (o *GFXMMU_Type) SetLUT756L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT756L.Reg, volatile.LoadUint32(&o.LUT756L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT756L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT756L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT756L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT756L.Reg, volatile.LoadUint32(&o.LUT756L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT756L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT756L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT756L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT756L.Reg, volatile.LoadUint32(&o.LUT756L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT756L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT756L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT756H: Graphic MMU LUT entry 756 high
func (o *GFXMMU_Type) SetLUT756H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT756H.Reg, volatile.LoadUint32(&o.LUT756H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT756H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT756H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT757L: Graphic MMU LUT entry 757 low
func (o *GFXMMU_Type) SetLUT757L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT757L.Reg, volatile.LoadUint32(&o.LUT757L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT757L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT757L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT757L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT757L.Reg, volatile.LoadUint32(&o.LUT757L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT757L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT757L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT757L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT757L.Reg, volatile.LoadUint32(&o.LUT757L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT757L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT757L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT757H: Graphic MMU LUT entry 757 high
func (o *GFXMMU_Type) SetLUT757H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT757H.Reg, volatile.LoadUint32(&o.LUT757H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT757H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT757H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT758L: Graphic MMU LUT entry 758 low
func (o *GFXMMU_Type) SetLUT758L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT758L.Reg, volatile.LoadUint32(&o.LUT758L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT758L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT758L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT758L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT758L.Reg, volatile.LoadUint32(&o.LUT758L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT758L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT758L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT758L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT758L.Reg, volatile.LoadUint32(&o.LUT758L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT758L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT758L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT758H: Graphic MMU LUT entry 758 high
func (o *GFXMMU_Type) SetLUT758H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT758H.Reg, volatile.LoadUint32(&o.LUT758H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT758H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT758H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT759L: Graphic MMU LUT entry 759 low
func (o *GFXMMU_Type) SetLUT759L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT759L.Reg, volatile.LoadUint32(&o.LUT759L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT759L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT759L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT759L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT759L.Reg, volatile.LoadUint32(&o.LUT759L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT759L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT759L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT759L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT759L.Reg, volatile.LoadUint32(&o.LUT759L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT759L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT759L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT759H: Graphic MMU LUT entry 759 high
func (o *GFXMMU_Type) SetLUT759H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT759H.Reg, volatile.LoadUint32(&o.LUT759H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT759H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT759H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT760L: Graphic MMU LUT entry 760 low
func (o *GFXMMU_Type) SetLUT760L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT760L.Reg, volatile.LoadUint32(&o.LUT760L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT760L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT760L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT760L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT760L.Reg, volatile.LoadUint32(&o.LUT760L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT760L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT760L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT760L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT760L.Reg, volatile.LoadUint32(&o.LUT760L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT760L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT760L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT760H: Graphic MMU LUT entry 760 high
func (o *GFXMMU_Type) SetLUT760H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT760H.Reg, volatile.LoadUint32(&o.LUT760H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT760H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT760H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT761L: Graphic MMU LUT entry 761 low
func (o *GFXMMU_Type) SetLUT761L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT761L.Reg, volatile.LoadUint32(&o.LUT761L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT761L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT761L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT761L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT761L.Reg, volatile.LoadUint32(&o.LUT761L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT761L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT761L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT761L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT761L.Reg, volatile.LoadUint32(&o.LUT761L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT761L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT761L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT761H: Graphic MMU LUT entry 761 high
func (o *GFXMMU_Type) SetLUT761H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT761H.Reg, volatile.LoadUint32(&o.LUT761H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT761H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT761H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT762L: Graphic MMU LUT entry 762 low
func (o *GFXMMU_Type) SetLUT762L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT762L.Reg, volatile.LoadUint32(&o.LUT762L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT762L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT762L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT762L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT762L.Reg, volatile.LoadUint32(&o.LUT762L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT762L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT762L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT762L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT762L.Reg, volatile.LoadUint32(&o.LUT762L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT762L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT762L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT762H: Graphic MMU LUT entry 762 high
func (o *GFXMMU_Type) SetLUT762H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT762H.Reg, volatile.LoadUint32(&o.LUT762H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT762H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT762H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT763L: Graphic MMU LUT entry 763 low
func (o *GFXMMU_Type) SetLUT763L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT763L.Reg, volatile.LoadUint32(&o.LUT763L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT763L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT763L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT763L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT763L.Reg, volatile.LoadUint32(&o.LUT763L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT763L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT763L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT763L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT763L.Reg, volatile.LoadUint32(&o.LUT763L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT763L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT763L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT763H: Graphic MMU LUT entry 763 high
func (o *GFXMMU_Type) SetLUT763H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT763H.Reg, volatile.LoadUint32(&o.LUT763H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT763H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT763H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT764L: Graphic MMU LUT entry 764 low
func (o *GFXMMU_Type) SetLUT764L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT764L.Reg, volatile.LoadUint32(&o.LUT764L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT764L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT764L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT764L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT764L.Reg, volatile.LoadUint32(&o.LUT764L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT764L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT764L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT764L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT764L.Reg, volatile.LoadUint32(&o.LUT764L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT764L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT764L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT764H: Graphic MMU LUT entry 764 high
func (o *GFXMMU_Type) SetLUT764H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT764H.Reg, volatile.LoadUint32(&o.LUT764H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT764H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT764H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT765L: Graphic MMU LUT entry 765 low
func (o *GFXMMU_Type) SetLUT765L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT765L.Reg, volatile.LoadUint32(&o.LUT765L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT765L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT765L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT765L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT765L.Reg, volatile.LoadUint32(&o.LUT765L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT765L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT765L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT765L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT765L.Reg, volatile.LoadUint32(&o.LUT765L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT765L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT765L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT765H: Graphic MMU LUT entry 765 high
func (o *GFXMMU_Type) SetLUT765H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT765H.Reg, volatile.LoadUint32(&o.LUT765H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT765H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT765H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT766L: Graphic MMU LUT entry 766 low
func (o *GFXMMU_Type) SetLUT766L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT766L.Reg, volatile.LoadUint32(&o.LUT766L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT766L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT766L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT766L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT766L.Reg, volatile.LoadUint32(&o.LUT766L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT766L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT766L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT766L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT766L.Reg, volatile.LoadUint32(&o.LUT766L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT766L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT766L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT766H: Graphic MMU LUT entry 766 high
func (o *GFXMMU_Type) SetLUT766H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT766H.Reg, volatile.LoadUint32(&o.LUT766H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT766H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT766H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT767L: Graphic MMU LUT entry 767 low
func (o *GFXMMU_Type) SetLUT767L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT767L.Reg, volatile.LoadUint32(&o.LUT767L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT767L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT767L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT767L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT767L.Reg, volatile.LoadUint32(&o.LUT767L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT767L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT767L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT767L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT767L.Reg, volatile.LoadUint32(&o.LUT767L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT767L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT767L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT767H: Graphic MMU LUT entry 767 high
func (o *GFXMMU_Type) SetLUT767H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT767H.Reg, volatile.LoadUint32(&o.LUT767H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT767H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT767H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT768L: Graphic MMU LUT entry 768 low
func (o *GFXMMU_Type) SetLUT768L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT768L.Reg, volatile.LoadUint32(&o.LUT768L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT768L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT768L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT768L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT768L.Reg, volatile.LoadUint32(&o.LUT768L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT768L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT768L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT768L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT768L.Reg, volatile.LoadUint32(&o.LUT768L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT768L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT768L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT768H: Graphic MMU LUT entry 768 high
func (o *GFXMMU_Type) SetLUT768H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT768H.Reg, volatile.LoadUint32(&o.LUT768H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT768H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT768H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT769L: Graphic MMU LUT entry 769 low
func (o *GFXMMU_Type) SetLUT769L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT769L.Reg, volatile.LoadUint32(&o.LUT769L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT769L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT769L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT769L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT769L.Reg, volatile.LoadUint32(&o.LUT769L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT769L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT769L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT769L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT769L.Reg, volatile.LoadUint32(&o.LUT769L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT769L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT769L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT769H: Graphic MMU LUT entry 769 high
func (o *GFXMMU_Type) SetLUT769H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT769H.Reg, volatile.LoadUint32(&o.LUT769H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT769H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT769H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT770L: Graphic MMU LUT entry 770 low
func (o *GFXMMU_Type) SetLUT770L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT770L.Reg, volatile.LoadUint32(&o.LUT770L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT770L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT770L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT770L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT770L.Reg, volatile.LoadUint32(&o.LUT770L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT770L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT770L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT770L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT770L.Reg, volatile.LoadUint32(&o.LUT770L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT770L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT770L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT770H: Graphic MMU LUT entry 770 high
func (o *GFXMMU_Type) SetLUT770H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT770H.Reg, volatile.LoadUint32(&o.LUT770H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT770H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT770H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT771L: Graphic MMU LUT entry 771 low
func (o *GFXMMU_Type) SetLUT771L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT771L.Reg, volatile.LoadUint32(&o.LUT771L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT771L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT771L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT771L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT771L.Reg, volatile.LoadUint32(&o.LUT771L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT771L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT771L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT771L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT771L.Reg, volatile.LoadUint32(&o.LUT771L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT771L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT771L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT771H: Graphic MMU LUT entry 771 high
func (o *GFXMMU_Type) SetLUT771H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT771H.Reg, volatile.LoadUint32(&o.LUT771H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT771H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT771H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT772L: Graphic MMU LUT entry 772 low
func (o *GFXMMU_Type) SetLUT772L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT772L.Reg, volatile.LoadUint32(&o.LUT772L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT772L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT772L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT772L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT772L.Reg, volatile.LoadUint32(&o.LUT772L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT772L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT772L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT772L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT772L.Reg, volatile.LoadUint32(&o.LUT772L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT772L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT772L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT772H: Graphic MMU LUT entry 772 high
func (o *GFXMMU_Type) SetLUT772H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT772H.Reg, volatile.LoadUint32(&o.LUT772H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT772H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT772H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT773L: Graphic MMU LUT entry 773 low
func (o *GFXMMU_Type) SetLUT773L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT773L.Reg, volatile.LoadUint32(&o.LUT773L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT773L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT773L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT773L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT773L.Reg, volatile.LoadUint32(&o.LUT773L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT773L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT773L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT773L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT773L.Reg, volatile.LoadUint32(&o.LUT773L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT773L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT773L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT773H: Graphic MMU LUT entry 773 high
func (o *GFXMMU_Type) SetLUT773H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT773H.Reg, volatile.LoadUint32(&o.LUT773H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT773H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT773H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT774L: Graphic MMU LUT entry 774 low
func (o *GFXMMU_Type) SetLUT774L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT774L.Reg, volatile.LoadUint32(&o.LUT774L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT774L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT774L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT774L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT774L.Reg, volatile.LoadUint32(&o.LUT774L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT774L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT774L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT774L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT774L.Reg, volatile.LoadUint32(&o.LUT774L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT774L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT774L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT774H: Graphic MMU LUT entry 774 high
func (o *GFXMMU_Type) SetLUT774H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT774H.Reg, volatile.LoadUint32(&o.LUT774H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT774H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT774H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT775L: Graphic MMU LUT entry 775 low
func (o *GFXMMU_Type) SetLUT775L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT775L.Reg, volatile.LoadUint32(&o.LUT775L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT775L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT775L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT775L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT775L.Reg, volatile.LoadUint32(&o.LUT775L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT775L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT775L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT775L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT775L.Reg, volatile.LoadUint32(&o.LUT775L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT775L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT775L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT775H: Graphic MMU LUT entry 775 high
func (o *GFXMMU_Type) SetLUT775H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT775H.Reg, volatile.LoadUint32(&o.LUT775H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT775H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT775H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT776L: Graphic MMU LUT entry 776 low
func (o *GFXMMU_Type) SetLUT776L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT776L.Reg, volatile.LoadUint32(&o.LUT776L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT776L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT776L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT776L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT776L.Reg, volatile.LoadUint32(&o.LUT776L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT776L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT776L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT776L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT776L.Reg, volatile.LoadUint32(&o.LUT776L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT776L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT776L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT776H: Graphic MMU LUT entry 776 high
func (o *GFXMMU_Type) SetLUT776H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT776H.Reg, volatile.LoadUint32(&o.LUT776H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT776H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT776H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT777L: Graphic MMU LUT entry 777 low
func (o *GFXMMU_Type) SetLUT777L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT777L.Reg, volatile.LoadUint32(&o.LUT777L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT777L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT777L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT777L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT777L.Reg, volatile.LoadUint32(&o.LUT777L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT777L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT777L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT777L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT777L.Reg, volatile.LoadUint32(&o.LUT777L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT777L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT777L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT777H: Graphic MMU LUT entry 777 high
func (o *GFXMMU_Type) SetLUT777H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT777H.Reg, volatile.LoadUint32(&o.LUT777H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT777H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT777H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT778L: Graphic MMU LUT entry 778 low
func (o *GFXMMU_Type) SetLUT778L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT778L.Reg, volatile.LoadUint32(&o.LUT778L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT778L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT778L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT778L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT778L.Reg, volatile.LoadUint32(&o.LUT778L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT778L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT778L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT778L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT778L.Reg, volatile.LoadUint32(&o.LUT778L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT778L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT778L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT778H: Graphic MMU LUT entry 778 high
func (o *GFXMMU_Type) SetLUT778H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT778H.Reg, volatile.LoadUint32(&o.LUT778H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT778H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT778H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT779L: Graphic MMU LUT entry 779 low
func (o *GFXMMU_Type) SetLUT779L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT779L.Reg, volatile.LoadUint32(&o.LUT779L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT779L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT779L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT779L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT779L.Reg, volatile.LoadUint32(&o.LUT779L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT779L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT779L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT779L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT779L.Reg, volatile.LoadUint32(&o.LUT779L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT779L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT779L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT779H: Graphic MMU LUT entry 779 high
func (o *GFXMMU_Type) SetLUT779H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT779H.Reg, volatile.LoadUint32(&o.LUT779H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT779H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT779H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT780L: Graphic MMU LUT entry 780 low
func (o *GFXMMU_Type) SetLUT780L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT780L.Reg, volatile.LoadUint32(&o.LUT780L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT780L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT780L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT780L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT780L.Reg, volatile.LoadUint32(&o.LUT780L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT780L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT780L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT780L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT780L.Reg, volatile.LoadUint32(&o.LUT780L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT780L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT780L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT780H: Graphic MMU LUT entry 780 high
func (o *GFXMMU_Type) SetLUT780H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT780H.Reg, volatile.LoadUint32(&o.LUT780H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT780H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT780H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT781L: Graphic MMU LUT entry 781 low
func (o *GFXMMU_Type) SetLUT781L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT781L.Reg, volatile.LoadUint32(&o.LUT781L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT781L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT781L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT781L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT781L.Reg, volatile.LoadUint32(&o.LUT781L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT781L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT781L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT781L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT781L.Reg, volatile.LoadUint32(&o.LUT781L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT781L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT781L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT781H: Graphic MMU LUT entry 781 high
func (o *GFXMMU_Type) SetLUT781H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT781H.Reg, volatile.LoadUint32(&o.LUT781H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT781H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT781H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT782L: Graphic MMU LUT entry 782 low
func (o *GFXMMU_Type) SetLUT782L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT782L.Reg, volatile.LoadUint32(&o.LUT782L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT782L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT782L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT782L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT782L.Reg, volatile.LoadUint32(&o.LUT782L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT782L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT782L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT782L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT782L.Reg, volatile.LoadUint32(&o.LUT782L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT782L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT782L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT782H: Graphic MMU LUT entry 782 high
func (o *GFXMMU_Type) SetLUT782H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT782H.Reg, volatile.LoadUint32(&o.LUT782H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT782H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT782H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT783L: Graphic MMU LUT entry 783 low
func (o *GFXMMU_Type) SetLUT783L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT783L.Reg, volatile.LoadUint32(&o.LUT783L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT783L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT783L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT783L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT783L.Reg, volatile.LoadUint32(&o.LUT783L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT783L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT783L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT783L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT783L.Reg, volatile.LoadUint32(&o.LUT783L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT783L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT783L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT783H: Graphic MMU LUT entry 783 high
func (o *GFXMMU_Type) SetLUT783H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT783H.Reg, volatile.LoadUint32(&o.LUT783H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT783H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT783H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT784L: Graphic MMU LUT entry 784 low
func (o *GFXMMU_Type) SetLUT784L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT784L.Reg, volatile.LoadUint32(&o.LUT784L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT784L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT784L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT784L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT784L.Reg, volatile.LoadUint32(&o.LUT784L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT784L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT784L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT784L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT784L.Reg, volatile.LoadUint32(&o.LUT784L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT784L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT784L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT784H: Graphic MMU LUT entry 784 high
func (o *GFXMMU_Type) SetLUT784H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT784H.Reg, volatile.LoadUint32(&o.LUT784H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT784H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT784H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT785L: Graphic MMU LUT entry 785 low
func (o *GFXMMU_Type) SetLUT785L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT785L.Reg, volatile.LoadUint32(&o.LUT785L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT785L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT785L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT785L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT785L.Reg, volatile.LoadUint32(&o.LUT785L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT785L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT785L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT785L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT785L.Reg, volatile.LoadUint32(&o.LUT785L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT785L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT785L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT785H: Graphic MMU LUT entry 785 high
func (o *GFXMMU_Type) SetLUT785H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT785H.Reg, volatile.LoadUint32(&o.LUT785H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT785H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT785H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT786L: Graphic MMU LUT entry 786 low
func (o *GFXMMU_Type) SetLUT786L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT786L.Reg, volatile.LoadUint32(&o.LUT786L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT786L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT786L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT786L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT786L.Reg, volatile.LoadUint32(&o.LUT786L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT786L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT786L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT786L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT786L.Reg, volatile.LoadUint32(&o.LUT786L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT786L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT786L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT786H: Graphic MMU LUT entry 786 high
func (o *GFXMMU_Type) SetLUT786H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT786H.Reg, volatile.LoadUint32(&o.LUT786H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT786H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT786H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT787L: Graphic MMU LUT entry 787 low
func (o *GFXMMU_Type) SetLUT787L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT787L.Reg, volatile.LoadUint32(&o.LUT787L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT787L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT787L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT787L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT787L.Reg, volatile.LoadUint32(&o.LUT787L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT787L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT787L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT787L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT787L.Reg, volatile.LoadUint32(&o.LUT787L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT787L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT787L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT787H: Graphic MMU LUT entry 787 high
func (o *GFXMMU_Type) SetLUT787H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT787H.Reg, volatile.LoadUint32(&o.LUT787H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT787H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT787H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT788L: Graphic MMU LUT entry 788 low
func (o *GFXMMU_Type) SetLUT788L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT788L.Reg, volatile.LoadUint32(&o.LUT788L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT788L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT788L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT788L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT788L.Reg, volatile.LoadUint32(&o.LUT788L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT788L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT788L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT788L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT788L.Reg, volatile.LoadUint32(&o.LUT788L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT788L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT788L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT788H: Graphic MMU LUT entry 788 high
func (o *GFXMMU_Type) SetLUT788H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT788H.Reg, volatile.LoadUint32(&o.LUT788H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT788H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT788H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT789L: Graphic MMU LUT entry 789 low
func (o *GFXMMU_Type) SetLUT789L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT789L.Reg, volatile.LoadUint32(&o.LUT789L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT789L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT789L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT789L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT789L.Reg, volatile.LoadUint32(&o.LUT789L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT789L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT789L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT789L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT789L.Reg, volatile.LoadUint32(&o.LUT789L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT789L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT789L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT789H: Graphic MMU LUT entry 789 high
func (o *GFXMMU_Type) SetLUT789H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT789H.Reg, volatile.LoadUint32(&o.LUT789H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT789H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT789H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT790L: Graphic MMU LUT entry 790 low
func (o *GFXMMU_Type) SetLUT790L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT790L.Reg, volatile.LoadUint32(&o.LUT790L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT790L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT790L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT790L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT790L.Reg, volatile.LoadUint32(&o.LUT790L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT790L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT790L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT790L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT790L.Reg, volatile.LoadUint32(&o.LUT790L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT790L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT790L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT790H: Graphic MMU LUT entry 790 high
func (o *GFXMMU_Type) SetLUT790H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT790H.Reg, volatile.LoadUint32(&o.LUT790H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT790H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT790H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT791L: Graphic MMU LUT entry 791 low
func (o *GFXMMU_Type) SetLUT791L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT791L.Reg, volatile.LoadUint32(&o.LUT791L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT791L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT791L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT791L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT791L.Reg, volatile.LoadUint32(&o.LUT791L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT791L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT791L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT791L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT791L.Reg, volatile.LoadUint32(&o.LUT791L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT791L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT791L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT791H: Graphic MMU LUT entry 791 high
func (o *GFXMMU_Type) SetLUT791H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT791H.Reg, volatile.LoadUint32(&o.LUT791H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT791H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT791H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT792L: Graphic MMU LUT entry 792 low
func (o *GFXMMU_Type) SetLUT792L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT792L.Reg, volatile.LoadUint32(&o.LUT792L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT792L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT792L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT792L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT792L.Reg, volatile.LoadUint32(&o.LUT792L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT792L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT792L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT792L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT792L.Reg, volatile.LoadUint32(&o.LUT792L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT792L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT792L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT792H: Graphic MMU LUT entry 792 high
func (o *GFXMMU_Type) SetLUT792H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT792H.Reg, volatile.LoadUint32(&o.LUT792H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT792H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT792H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT793L: Graphic MMU LUT entry 793 low
func (o *GFXMMU_Type) SetLUT793L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT793L.Reg, volatile.LoadUint32(&o.LUT793L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT793L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT793L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT793L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT793L.Reg, volatile.LoadUint32(&o.LUT793L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT793L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT793L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT793L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT793L.Reg, volatile.LoadUint32(&o.LUT793L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT793L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT793L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT793H: Graphic MMU LUT entry 793 high
func (o *GFXMMU_Type) SetLUT793H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT793H.Reg, volatile.LoadUint32(&o.LUT793H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT793H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT793H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT794L: Graphic MMU LUT entry 794 low
func (o *GFXMMU_Type) SetLUT794L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT794L.Reg, volatile.LoadUint32(&o.LUT794L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT794L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT794L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT794L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT794L.Reg, volatile.LoadUint32(&o.LUT794L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT794L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT794L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT794L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT794L.Reg, volatile.LoadUint32(&o.LUT794L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT794L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT794L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT794H: Graphic MMU LUT entry 794 high
func (o *GFXMMU_Type) SetLUT794H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT794H.Reg, volatile.LoadUint32(&o.LUT794H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT794H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT794H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT795L: Graphic MMU LUT entry 795 low
func (o *GFXMMU_Type) SetLUT795L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT795L.Reg, volatile.LoadUint32(&o.LUT795L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT795L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT795L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT795L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT795L.Reg, volatile.LoadUint32(&o.LUT795L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT795L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT795L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT795L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT795L.Reg, volatile.LoadUint32(&o.LUT795L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT795L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT795L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT795H: Graphic MMU LUT entry 795 high
func (o *GFXMMU_Type) SetLUT795H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT795H.Reg, volatile.LoadUint32(&o.LUT795H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT795H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT795H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT796L: Graphic MMU LUT entry 796 low
func (o *GFXMMU_Type) SetLUT796L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT796L.Reg, volatile.LoadUint32(&o.LUT796L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT796L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT796L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT796L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT796L.Reg, volatile.LoadUint32(&o.LUT796L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT796L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT796L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT796L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT796L.Reg, volatile.LoadUint32(&o.LUT796L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT796L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT796L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT796H: Graphic MMU LUT entry 796 high
func (o *GFXMMU_Type) SetLUT796H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT796H.Reg, volatile.LoadUint32(&o.LUT796H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT796H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT796H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT797L: Graphic MMU LUT entry 797 low
func (o *GFXMMU_Type) SetLUT797L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT797L.Reg, volatile.LoadUint32(&o.LUT797L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT797L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT797L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT797L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT797L.Reg, volatile.LoadUint32(&o.LUT797L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT797L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT797L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT797L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT797L.Reg, volatile.LoadUint32(&o.LUT797L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT797L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT797L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT797H: Graphic MMU LUT entry 797 high
func (o *GFXMMU_Type) SetLUT797H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT797H.Reg, volatile.LoadUint32(&o.LUT797H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT797H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT797H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT798L: Graphic MMU LUT entry 798 low
func (o *GFXMMU_Type) SetLUT798L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT798L.Reg, volatile.LoadUint32(&o.LUT798L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT798L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT798L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT798L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT798L.Reg, volatile.LoadUint32(&o.LUT798L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT798L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT798L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT798L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT798L.Reg, volatile.LoadUint32(&o.LUT798L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT798L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT798L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT798H: Graphic MMU LUT entry 798 high
func (o *GFXMMU_Type) SetLUT798H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT798H.Reg, volatile.LoadUint32(&o.LUT798H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT798H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT798H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT799L: Graphic MMU LUT entry 799 low
func (o *GFXMMU_Type) SetLUT799L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT799L.Reg, volatile.LoadUint32(&o.LUT799L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT799L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT799L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT799L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT799L.Reg, volatile.LoadUint32(&o.LUT799L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT799L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT799L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT799L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT799L.Reg, volatile.LoadUint32(&o.LUT799L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT799L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT799L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT799H: Graphic MMU LUT entry 799 high
func (o *GFXMMU_Type) SetLUT799H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT799H.Reg, volatile.LoadUint32(&o.LUT799H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT799H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT799H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT800L: Graphic MMU LUT entry 800 low
func (o *GFXMMU_Type) SetLUT800L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT800L.Reg, volatile.LoadUint32(&o.LUT800L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT800L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT800L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT800L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT800L.Reg, volatile.LoadUint32(&o.LUT800L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT800L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT800L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT800L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT800L.Reg, volatile.LoadUint32(&o.LUT800L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT800L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT800L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT800H: Graphic MMU LUT entry 800 high
func (o *GFXMMU_Type) SetLUT800H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT800H.Reg, volatile.LoadUint32(&o.LUT800H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT800H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT800H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT801L: Graphic MMU LUT entry 801 low
func (o *GFXMMU_Type) SetLUT801L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT801L.Reg, volatile.LoadUint32(&o.LUT801L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT801L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT801L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT801L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT801L.Reg, volatile.LoadUint32(&o.LUT801L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT801L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT801L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT801L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT801L.Reg, volatile.LoadUint32(&o.LUT801L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT801L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT801L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT801H: Graphic MMU LUT entry 801 high
func (o *GFXMMU_Type) SetLUT801H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT801H.Reg, volatile.LoadUint32(&o.LUT801H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT801H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT801H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT802L: Graphic MMU LUT entry 802 low
func (o *GFXMMU_Type) SetLUT802L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT802L.Reg, volatile.LoadUint32(&o.LUT802L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT802L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT802L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT802L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT802L.Reg, volatile.LoadUint32(&o.LUT802L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT802L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT802L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT802L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT802L.Reg, volatile.LoadUint32(&o.LUT802L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT802L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT802L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT802H: Graphic MMU LUT entry 802 high
func (o *GFXMMU_Type) SetLUT802H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT802H.Reg, volatile.LoadUint32(&o.LUT802H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT802H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT802H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT803L: Graphic MMU LUT entry 803 low
func (o *GFXMMU_Type) SetLUT803L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT803L.Reg, volatile.LoadUint32(&o.LUT803L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT803L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT803L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT803L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT803L.Reg, volatile.LoadUint32(&o.LUT803L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT803L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT803L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT803L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT803L.Reg, volatile.LoadUint32(&o.LUT803L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT803L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT803L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT803H: Graphic MMU LUT entry 803 high
func (o *GFXMMU_Type) SetLUT803H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT803H.Reg, volatile.LoadUint32(&o.LUT803H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT803H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT803H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT804L: Graphic MMU LUT entry 804 low
func (o *GFXMMU_Type) SetLUT804L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT804L.Reg, volatile.LoadUint32(&o.LUT804L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT804L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT804L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT804L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT804L.Reg, volatile.LoadUint32(&o.LUT804L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT804L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT804L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT804L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT804L.Reg, volatile.LoadUint32(&o.LUT804L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT804L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT804L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT804H: Graphic MMU LUT entry 804 high
func (o *GFXMMU_Type) SetLUT804H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT804H.Reg, volatile.LoadUint32(&o.LUT804H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT804H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT804H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT805L: Graphic MMU LUT entry 805 low
func (o *GFXMMU_Type) SetLUT805L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT805L.Reg, volatile.LoadUint32(&o.LUT805L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT805L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT805L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT805L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT805L.Reg, volatile.LoadUint32(&o.LUT805L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT805L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT805L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT805L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT805L.Reg, volatile.LoadUint32(&o.LUT805L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT805L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT805L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT805H: Graphic MMU LUT entry 805 high
func (o *GFXMMU_Type) SetLUT805H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT805H.Reg, volatile.LoadUint32(&o.LUT805H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT805H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT805H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT806L: Graphic MMU LUT entry 806 low
func (o *GFXMMU_Type) SetLUT806L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT806L.Reg, volatile.LoadUint32(&o.LUT806L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT806L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT806L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT806L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT806L.Reg, volatile.LoadUint32(&o.LUT806L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT806L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT806L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT806L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT806L.Reg, volatile.LoadUint32(&o.LUT806L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT806L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT806L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT806H: Graphic MMU LUT entry 806 high
func (o *GFXMMU_Type) SetLUT806H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT806H.Reg, volatile.LoadUint32(&o.LUT806H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT806H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT806H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT807L: Graphic MMU LUT entry 807 low
func (o *GFXMMU_Type) SetLUT807L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT807L.Reg, volatile.LoadUint32(&o.LUT807L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT807L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT807L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT807L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT807L.Reg, volatile.LoadUint32(&o.LUT807L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT807L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT807L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT807L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT807L.Reg, volatile.LoadUint32(&o.LUT807L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT807L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT807L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT807H: Graphic MMU LUT entry 807 high
func (o *GFXMMU_Type) SetLUT807H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT807H.Reg, volatile.LoadUint32(&o.LUT807H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT807H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT807H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT808L: Graphic MMU LUT entry 808 low
func (o *GFXMMU_Type) SetLUT808L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT808L.Reg, volatile.LoadUint32(&o.LUT808L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT808L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT808L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT808L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT808L.Reg, volatile.LoadUint32(&o.LUT808L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT808L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT808L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT808L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT808L.Reg, volatile.LoadUint32(&o.LUT808L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT808L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT808L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT808H: Graphic MMU LUT entry 808 high
func (o *GFXMMU_Type) SetLUT808H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT808H.Reg, volatile.LoadUint32(&o.LUT808H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT808H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT808H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT809L: Graphic MMU LUT entry 809 low
func (o *GFXMMU_Type) SetLUT809L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT809L.Reg, volatile.LoadUint32(&o.LUT809L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT809L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT809L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT809L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT809L.Reg, volatile.LoadUint32(&o.LUT809L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT809L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT809L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT809L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT809L.Reg, volatile.LoadUint32(&o.LUT809L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT809L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT809L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT809H: Graphic MMU LUT entry 809 high
func (o *GFXMMU_Type) SetLUT809H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT809H.Reg, volatile.LoadUint32(&o.LUT809H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT809H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT809H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT810L: Graphic MMU LUT entry 810 low
func (o *GFXMMU_Type) SetLUT810L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT810L.Reg, volatile.LoadUint32(&o.LUT810L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT810L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT810L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT810L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT810L.Reg, volatile.LoadUint32(&o.LUT810L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT810L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT810L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT810L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT810L.Reg, volatile.LoadUint32(&o.LUT810L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT810L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT810L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT810H: Graphic MMU LUT entry 810 high
func (o *GFXMMU_Type) SetLUT810H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT810H.Reg, volatile.LoadUint32(&o.LUT810H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT810H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT810H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT811L: Graphic MMU LUT entry 811 low
func (o *GFXMMU_Type) SetLUT811L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT811L.Reg, volatile.LoadUint32(&o.LUT811L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT811L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT811L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT811L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT811L.Reg, volatile.LoadUint32(&o.LUT811L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT811L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT811L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT811L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT811L.Reg, volatile.LoadUint32(&o.LUT811L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT811L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT811L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT811H: Graphic MMU LUT entry 811 high
func (o *GFXMMU_Type) SetLUT811H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT811H.Reg, volatile.LoadUint32(&o.LUT811H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT811H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT811H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT812L: Graphic MMU LUT entry 812 low
func (o *GFXMMU_Type) SetLUT812L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT812L.Reg, volatile.LoadUint32(&o.LUT812L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT812L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT812L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT812L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT812L.Reg, volatile.LoadUint32(&o.LUT812L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT812L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT812L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT812L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT812L.Reg, volatile.LoadUint32(&o.LUT812L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT812L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT812L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT812H: Graphic MMU LUT entry 812 high
func (o *GFXMMU_Type) SetLUT812H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT812H.Reg, volatile.LoadUint32(&o.LUT812H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT812H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT812H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT813L: Graphic MMU LUT entry 813 low
func (o *GFXMMU_Type) SetLUT813L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT813L.Reg, volatile.LoadUint32(&o.LUT813L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT813L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT813L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT813L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT813L.Reg, volatile.LoadUint32(&o.LUT813L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT813L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT813L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT813L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT813L.Reg, volatile.LoadUint32(&o.LUT813L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT813L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT813L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT813H: Graphic MMU LUT entry 813 high
func (o *GFXMMU_Type) SetLUT813H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT813H.Reg, volatile.LoadUint32(&o.LUT813H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT813H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT813H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT814L: Graphic MMU LUT entry 814 low
func (o *GFXMMU_Type) SetLUT814L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT814L.Reg, volatile.LoadUint32(&o.LUT814L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT814L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT814L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT814L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT814L.Reg, volatile.LoadUint32(&o.LUT814L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT814L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT814L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT814L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT814L.Reg, volatile.LoadUint32(&o.LUT814L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT814L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT814L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT814H: Graphic MMU LUT entry 814 high
func (o *GFXMMU_Type) SetLUT814H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT814H.Reg, volatile.LoadUint32(&o.LUT814H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT814H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT814H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT815L: Graphic MMU LUT entry 815 low
func (o *GFXMMU_Type) SetLUT815L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT815L.Reg, volatile.LoadUint32(&o.LUT815L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT815L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT815L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT815L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT815L.Reg, volatile.LoadUint32(&o.LUT815L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT815L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT815L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT815L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT815L.Reg, volatile.LoadUint32(&o.LUT815L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT815L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT815L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT815H: Graphic MMU LUT entry 815 high
func (o *GFXMMU_Type) SetLUT815H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT815H.Reg, volatile.LoadUint32(&o.LUT815H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT815H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT815H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT816L: Graphic MMU LUT entry 816 low
func (o *GFXMMU_Type) SetLUT816L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT816L.Reg, volatile.LoadUint32(&o.LUT816L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT816L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT816L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT816L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT816L.Reg, volatile.LoadUint32(&o.LUT816L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT816L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT816L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT816L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT816L.Reg, volatile.LoadUint32(&o.LUT816L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT816L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT816L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT816H: Graphic MMU LUT entry 816 high
func (o *GFXMMU_Type) SetLUT816H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT816H.Reg, volatile.LoadUint32(&o.LUT816H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT816H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT816H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT817L: Graphic MMU LUT entry 817 low
func (o *GFXMMU_Type) SetLUT817L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT817L.Reg, volatile.LoadUint32(&o.LUT817L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT817L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT817L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT817L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT817L.Reg, volatile.LoadUint32(&o.LUT817L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT817L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT817L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT817L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT817L.Reg, volatile.LoadUint32(&o.LUT817L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT817L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT817L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT817H: Graphic MMU LUT entry 817 high
func (o *GFXMMU_Type) SetLUT817H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT817H.Reg, volatile.LoadUint32(&o.LUT817H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT817H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT817H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT818L: Graphic MMU LUT entry 818 low
func (o *GFXMMU_Type) SetLUT818L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT818L.Reg, volatile.LoadUint32(&o.LUT818L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT818L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT818L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT818L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT818L.Reg, volatile.LoadUint32(&o.LUT818L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT818L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT818L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT818L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT818L.Reg, volatile.LoadUint32(&o.LUT818L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT818L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT818L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT818H: Graphic MMU LUT entry 818 high
func (o *GFXMMU_Type) SetLUT818H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT818H.Reg, volatile.LoadUint32(&o.LUT818H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT818H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT818H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT819L: Graphic MMU LUT entry 819 low
func (o *GFXMMU_Type) SetLUT819L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT819L.Reg, volatile.LoadUint32(&o.LUT819L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT819L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT819L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT819L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT819L.Reg, volatile.LoadUint32(&o.LUT819L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT819L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT819L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT819L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT819L.Reg, volatile.LoadUint32(&o.LUT819L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT819L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT819L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT819H: Graphic MMU LUT entry 819 high
func (o *GFXMMU_Type) SetLUT819H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT819H.Reg, volatile.LoadUint32(&o.LUT819H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT819H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT819H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT820L: Graphic MMU LUT entry 820 low
func (o *GFXMMU_Type) SetLUT820L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT820L.Reg, volatile.LoadUint32(&o.LUT820L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT820L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT820L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT820L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT820L.Reg, volatile.LoadUint32(&o.LUT820L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT820L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT820L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT820L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT820L.Reg, volatile.LoadUint32(&o.LUT820L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT820L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT820L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT820H: Graphic MMU LUT entry 820 high
func (o *GFXMMU_Type) SetLUT820H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT820H.Reg, volatile.LoadUint32(&o.LUT820H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT820H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT820H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT821L: Graphic MMU LUT entry 821 low
func (o *GFXMMU_Type) SetLUT821L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT821L.Reg, volatile.LoadUint32(&o.LUT821L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT821L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT821L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT821L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT821L.Reg, volatile.LoadUint32(&o.LUT821L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT821L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT821L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT821L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT821L.Reg, volatile.LoadUint32(&o.LUT821L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT821L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT821L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT821H: Graphic MMU LUT entry 821 high
func (o *GFXMMU_Type) SetLUT821H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT821H.Reg, volatile.LoadUint32(&o.LUT821H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT821H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT821H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT822L: Graphic MMU LUT entry 822 low
func (o *GFXMMU_Type) SetLUT822L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT822L.Reg, volatile.LoadUint32(&o.LUT822L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT822L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT822L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT822L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT822L.Reg, volatile.LoadUint32(&o.LUT822L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT822L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT822L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT822L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT822L.Reg, volatile.LoadUint32(&o.LUT822L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT822L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT822L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT822H: Graphic MMU LUT entry 822 high
func (o *GFXMMU_Type) SetLUT822H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT822H.Reg, volatile.LoadUint32(&o.LUT822H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT822H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT822H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT823L: Graphic MMU LUT entry 823 low
func (o *GFXMMU_Type) SetLUT823L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT823L.Reg, volatile.LoadUint32(&o.LUT823L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT823L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT823L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT823L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT823L.Reg, volatile.LoadUint32(&o.LUT823L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT823L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT823L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT823L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT823L.Reg, volatile.LoadUint32(&o.LUT823L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT823L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT823L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT823H: Graphic MMU LUT entry 823 high
func (o *GFXMMU_Type) SetLUT823H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT823H.Reg, volatile.LoadUint32(&o.LUT823H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT823H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT823H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT824L: Graphic MMU LUT entry 824 low
func (o *GFXMMU_Type) SetLUT824L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT824L.Reg, volatile.LoadUint32(&o.LUT824L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT824L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT824L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT824L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT824L.Reg, volatile.LoadUint32(&o.LUT824L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT824L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT824L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT824L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT824L.Reg, volatile.LoadUint32(&o.LUT824L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT824L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT824L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT824H: Graphic MMU LUT entry 824 high
func (o *GFXMMU_Type) SetLUT824H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT824H.Reg, volatile.LoadUint32(&o.LUT824H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT824H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT824H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT825L: Graphic MMU LUT entry 825 low
func (o *GFXMMU_Type) SetLUT825L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT825L.Reg, volatile.LoadUint32(&o.LUT825L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT825L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT825L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT825L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT825L.Reg, volatile.LoadUint32(&o.LUT825L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT825L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT825L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT825L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT825L.Reg, volatile.LoadUint32(&o.LUT825L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT825L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT825L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT825H: Graphic MMU LUT entry 825 high
func (o *GFXMMU_Type) SetLUT825H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT825H.Reg, volatile.LoadUint32(&o.LUT825H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT825H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT825H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT826L: Graphic MMU LUT entry 826 low
func (o *GFXMMU_Type) SetLUT826L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT826L.Reg, volatile.LoadUint32(&o.LUT826L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT826L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT826L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT826L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT826L.Reg, volatile.LoadUint32(&o.LUT826L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT826L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT826L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT826L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT826L.Reg, volatile.LoadUint32(&o.LUT826L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT826L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT826L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT826H: Graphic MMU LUT entry 826 high
func (o *GFXMMU_Type) SetLUT826H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT826H.Reg, volatile.LoadUint32(&o.LUT826H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT826H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT826H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT827L: Graphic MMU LUT entry 827 low
func (o *GFXMMU_Type) SetLUT827L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT827L.Reg, volatile.LoadUint32(&o.LUT827L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT827L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT827L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT827L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT827L.Reg, volatile.LoadUint32(&o.LUT827L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT827L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT827L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT827L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT827L.Reg, volatile.LoadUint32(&o.LUT827L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT827L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT827L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT827H: Graphic MMU LUT entry 827 high
func (o *GFXMMU_Type) SetLUT827H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT827H.Reg, volatile.LoadUint32(&o.LUT827H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT827H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT827H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT828L: Graphic MMU LUT entry 828 low
func (o *GFXMMU_Type) SetLUT828L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT828L.Reg, volatile.LoadUint32(&o.LUT828L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT828L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT828L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT828L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT828L.Reg, volatile.LoadUint32(&o.LUT828L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT828L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT828L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT828L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT828L.Reg, volatile.LoadUint32(&o.LUT828L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT828L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT828L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT828H: Graphic MMU LUT entry 828 high
func (o *GFXMMU_Type) SetLUT828H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT828H.Reg, volatile.LoadUint32(&o.LUT828H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT828H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT828H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT829L: Graphic MMU LUT entry 829 low
func (o *GFXMMU_Type) SetLUT829L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT829L.Reg, volatile.LoadUint32(&o.LUT829L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT829L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT829L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT829L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT829L.Reg, volatile.LoadUint32(&o.LUT829L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT829L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT829L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT829L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT829L.Reg, volatile.LoadUint32(&o.LUT829L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT829L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT829L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT829H: Graphic MMU LUT entry 829 high
func (o *GFXMMU_Type) SetLUT829H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT829H.Reg, volatile.LoadUint32(&o.LUT829H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT829H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT829H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT830L: Graphic MMU LUT entry 830 low
func (o *GFXMMU_Type) SetLUT830L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT830L.Reg, volatile.LoadUint32(&o.LUT830L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT830L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT830L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT830L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT830L.Reg, volatile.LoadUint32(&o.LUT830L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT830L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT830L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT830L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT830L.Reg, volatile.LoadUint32(&o.LUT830L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT830L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT830L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT830H: Graphic MMU LUT entry 830 high
func (o *GFXMMU_Type) SetLUT830H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT830H.Reg, volatile.LoadUint32(&o.LUT830H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT830H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT830H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT831L: Graphic MMU LUT entry 831 low
func (o *GFXMMU_Type) SetLUT831L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT831L.Reg, volatile.LoadUint32(&o.LUT831L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT831L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT831L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT831L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT831L.Reg, volatile.LoadUint32(&o.LUT831L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT831L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT831L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT831L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT831L.Reg, volatile.LoadUint32(&o.LUT831L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT831L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT831L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT831H: Graphic MMU LUT entry 831 high
func (o *GFXMMU_Type) SetLUT831H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT831H.Reg, volatile.LoadUint32(&o.LUT831H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT831H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT831H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT832L: Graphic MMU LUT entry 832 low
func (o *GFXMMU_Type) SetLUT832L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT832L.Reg, volatile.LoadUint32(&o.LUT832L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT832L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT832L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT832L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT832L.Reg, volatile.LoadUint32(&o.LUT832L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT832L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT832L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT832L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT832L.Reg, volatile.LoadUint32(&o.LUT832L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT832L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT832L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT832H: Graphic MMU LUT entry 832 high
func (o *GFXMMU_Type) SetLUT832H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT832H.Reg, volatile.LoadUint32(&o.LUT832H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT832H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT832H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT833L: Graphic MMU LUT entry 833 low
func (o *GFXMMU_Type) SetLUT833L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT833L.Reg, volatile.LoadUint32(&o.LUT833L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT833L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT833L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT833L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT833L.Reg, volatile.LoadUint32(&o.LUT833L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT833L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT833L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT833L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT833L.Reg, volatile.LoadUint32(&o.LUT833L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT833L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT833L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT833H: Graphic MMU LUT entry 833 high
func (o *GFXMMU_Type) SetLUT833H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT833H.Reg, volatile.LoadUint32(&o.LUT833H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT833H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT833H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT834L: Graphic MMU LUT entry 834 low
func (o *GFXMMU_Type) SetLUT834L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT834L.Reg, volatile.LoadUint32(&o.LUT834L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT834L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT834L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT834L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT834L.Reg, volatile.LoadUint32(&o.LUT834L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT834L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT834L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT834L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT834L.Reg, volatile.LoadUint32(&o.LUT834L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT834L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT834L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT834H: Graphic MMU LUT entry 834 high
func (o *GFXMMU_Type) SetLUT834H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT834H.Reg, volatile.LoadUint32(&o.LUT834H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT834H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT834H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT835L: Graphic MMU LUT entry 835 low
func (o *GFXMMU_Type) SetLUT835L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT835L.Reg, volatile.LoadUint32(&o.LUT835L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT835L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT835L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT835L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT835L.Reg, volatile.LoadUint32(&o.LUT835L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT835L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT835L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT835L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT835L.Reg, volatile.LoadUint32(&o.LUT835L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT835L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT835L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT835H: Graphic MMU LUT entry 835 high
func (o *GFXMMU_Type) SetLUT835H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT835H.Reg, volatile.LoadUint32(&o.LUT835H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT835H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT835H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT836L: Graphic MMU LUT entry 836 low
func (o *GFXMMU_Type) SetLUT836L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT836L.Reg, volatile.LoadUint32(&o.LUT836L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT836L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT836L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT836L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT836L.Reg, volatile.LoadUint32(&o.LUT836L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT836L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT836L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT836L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT836L.Reg, volatile.LoadUint32(&o.LUT836L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT836L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT836L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT836H: Graphic MMU LUT entry 836 high
func (o *GFXMMU_Type) SetLUT836H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT836H.Reg, volatile.LoadUint32(&o.LUT836H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT836H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT836H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT837L: Graphic MMU LUT entry 837 low
func (o *GFXMMU_Type) SetLUT837L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT837L.Reg, volatile.LoadUint32(&o.LUT837L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT837L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT837L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT837L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT837L.Reg, volatile.LoadUint32(&o.LUT837L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT837L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT837L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT837L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT837L.Reg, volatile.LoadUint32(&o.LUT837L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT837L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT837L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT837H: Graphic MMU LUT entry 837 high
func (o *GFXMMU_Type) SetLUT837H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT837H.Reg, volatile.LoadUint32(&o.LUT837H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT837H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT837H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT838L: Graphic MMU LUT entry 838 low
func (o *GFXMMU_Type) SetLUT838L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT838L.Reg, volatile.LoadUint32(&o.LUT838L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT838L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT838L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT838L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT838L.Reg, volatile.LoadUint32(&o.LUT838L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT838L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT838L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT838L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT838L.Reg, volatile.LoadUint32(&o.LUT838L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT838L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT838L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT838H: Graphic MMU LUT entry 838 high
func (o *GFXMMU_Type) SetLUT838H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT838H.Reg, volatile.LoadUint32(&o.LUT838H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT838H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT838H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT839L: Graphic MMU LUT entry 839 low
func (o *GFXMMU_Type) SetLUT839L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT839L.Reg, volatile.LoadUint32(&o.LUT839L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT839L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT839L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT839L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT839L.Reg, volatile.LoadUint32(&o.LUT839L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT839L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT839L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT839L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT839L.Reg, volatile.LoadUint32(&o.LUT839L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT839L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT839L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT839H: Graphic MMU LUT entry 839 high
func (o *GFXMMU_Type) SetLUT839H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT839H.Reg, volatile.LoadUint32(&o.LUT839H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT839H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT839H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT840L: Graphic MMU LUT entry 840 low
func (o *GFXMMU_Type) SetLUT840L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT840L.Reg, volatile.LoadUint32(&o.LUT840L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT840L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT840L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT840L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT840L.Reg, volatile.LoadUint32(&o.LUT840L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT840L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT840L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT840L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT840L.Reg, volatile.LoadUint32(&o.LUT840L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT840L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT840L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT840H: Graphic MMU LUT entry 840 high
func (o *GFXMMU_Type) SetLUT840H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT840H.Reg, volatile.LoadUint32(&o.LUT840H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT840H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT840H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT841L: Graphic MMU LUT entry 841 low
func (o *GFXMMU_Type) SetLUT841L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT841L.Reg, volatile.LoadUint32(&o.LUT841L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT841L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT841L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT841L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT841L.Reg, volatile.LoadUint32(&o.LUT841L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT841L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT841L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT841L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT841L.Reg, volatile.LoadUint32(&o.LUT841L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT841L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT841L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT841H: Graphic MMU LUT entry 841 high
func (o *GFXMMU_Type) SetLUT841H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT841H.Reg, volatile.LoadUint32(&o.LUT841H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT841H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT841H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT842L: Graphic MMU LUT entry 842 low
func (o *GFXMMU_Type) SetLUT842L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT842L.Reg, volatile.LoadUint32(&o.LUT842L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT842L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT842L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT842L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT842L.Reg, volatile.LoadUint32(&o.LUT842L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT842L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT842L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT842L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT842L.Reg, volatile.LoadUint32(&o.LUT842L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT842L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT842L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT842H: Graphic MMU LUT entry 842 high
func (o *GFXMMU_Type) SetLUT842H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT842H.Reg, volatile.LoadUint32(&o.LUT842H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT842H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT842H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT843L: Graphic MMU LUT entry 843 low
func (o *GFXMMU_Type) SetLUT843L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT843L.Reg, volatile.LoadUint32(&o.LUT843L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT843L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT843L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT843L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT843L.Reg, volatile.LoadUint32(&o.LUT843L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT843L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT843L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT843L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT843L.Reg, volatile.LoadUint32(&o.LUT843L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT843L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT843L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT843H: Graphic MMU LUT entry 843 high
func (o *GFXMMU_Type) SetLUT843H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT843H.Reg, volatile.LoadUint32(&o.LUT843H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT843H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT843H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT844L: Graphic MMU LUT entry 844 low
func (o *GFXMMU_Type) SetLUT844L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT844L.Reg, volatile.LoadUint32(&o.LUT844L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT844L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT844L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT844L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT844L.Reg, volatile.LoadUint32(&o.LUT844L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT844L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT844L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT844L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT844L.Reg, volatile.LoadUint32(&o.LUT844L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT844L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT844L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT844H: Graphic MMU LUT entry 844 high
func (o *GFXMMU_Type) SetLUT844H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT844H.Reg, volatile.LoadUint32(&o.LUT844H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT844H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT844H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT845L: Graphic MMU LUT entry 845 low
func (o *GFXMMU_Type) SetLUT845L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT845L.Reg, volatile.LoadUint32(&o.LUT845L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT845L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT845L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT845L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT845L.Reg, volatile.LoadUint32(&o.LUT845L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT845L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT845L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT845L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT845L.Reg, volatile.LoadUint32(&o.LUT845L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT845L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT845L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT845H: Graphic MMU LUT entry 845 high
func (o *GFXMMU_Type) SetLUT845H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT845H.Reg, volatile.LoadUint32(&o.LUT845H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT845H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT845H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT846L: Graphic MMU LUT entry 846 low
func (o *GFXMMU_Type) SetLUT846L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT846L.Reg, volatile.LoadUint32(&o.LUT846L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT846L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT846L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT846L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT846L.Reg, volatile.LoadUint32(&o.LUT846L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT846L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT846L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT846L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT846L.Reg, volatile.LoadUint32(&o.LUT846L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT846L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT846L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT846H: Graphic MMU LUT entry 846 high
func (o *GFXMMU_Type) SetLUT846H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT846H.Reg, volatile.LoadUint32(&o.LUT846H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT846H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT846H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT847L: Graphic MMU LUT entry 847 low
func (o *GFXMMU_Type) SetLUT847L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT847L.Reg, volatile.LoadUint32(&o.LUT847L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT847L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT847L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT847L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT847L.Reg, volatile.LoadUint32(&o.LUT847L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT847L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT847L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT847L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT847L.Reg, volatile.LoadUint32(&o.LUT847L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT847L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT847L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT847H: Graphic MMU LUT entry 847 high
func (o *GFXMMU_Type) SetLUT847H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT847H.Reg, volatile.LoadUint32(&o.LUT847H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT847H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT847H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT848L: Graphic MMU LUT entry 848 low
func (o *GFXMMU_Type) SetLUT848L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT848L.Reg, volatile.LoadUint32(&o.LUT848L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT848L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT848L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT848L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT848L.Reg, volatile.LoadUint32(&o.LUT848L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT848L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT848L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT848L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT848L.Reg, volatile.LoadUint32(&o.LUT848L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT848L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT848L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT848H: Graphic MMU LUT entry 848 high
func (o *GFXMMU_Type) SetLUT848H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT848H.Reg, volatile.LoadUint32(&o.LUT848H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT848H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT848H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT849L: Graphic MMU LUT entry 849 low
func (o *GFXMMU_Type) SetLUT849L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT849L.Reg, volatile.LoadUint32(&o.LUT849L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT849L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT849L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT849L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT849L.Reg, volatile.LoadUint32(&o.LUT849L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT849L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT849L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT849L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT849L.Reg, volatile.LoadUint32(&o.LUT849L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT849L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT849L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT849H: Graphic MMU LUT entry 849 high
func (o *GFXMMU_Type) SetLUT849H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT849H.Reg, volatile.LoadUint32(&o.LUT849H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT849H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT849H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT850L: Graphic MMU LUT entry 850 low
func (o *GFXMMU_Type) SetLUT850L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT850L.Reg, volatile.LoadUint32(&o.LUT850L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT850L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT850L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT850L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT850L.Reg, volatile.LoadUint32(&o.LUT850L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT850L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT850L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT850L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT850L.Reg, volatile.LoadUint32(&o.LUT850L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT850L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT850L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT850H: Graphic MMU LUT entry 850 high
func (o *GFXMMU_Type) SetLUT850H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT850H.Reg, volatile.LoadUint32(&o.LUT850H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT850H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT850H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT851L: Graphic MMU LUT entry 851 low
func (o *GFXMMU_Type) SetLUT851L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT851L.Reg, volatile.LoadUint32(&o.LUT851L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT851L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT851L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT851L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT851L.Reg, volatile.LoadUint32(&o.LUT851L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT851L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT851L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT851L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT851L.Reg, volatile.LoadUint32(&o.LUT851L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT851L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT851L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT851H: Graphic MMU LUT entry 851 high
func (o *GFXMMU_Type) SetLUT851H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT851H.Reg, volatile.LoadUint32(&o.LUT851H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT851H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT851H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT852L: Graphic MMU LUT entry 852 low
func (o *GFXMMU_Type) SetLUT852L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT852L.Reg, volatile.LoadUint32(&o.LUT852L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT852L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT852L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT852L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT852L.Reg, volatile.LoadUint32(&o.LUT852L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT852L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT852L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT852L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT852L.Reg, volatile.LoadUint32(&o.LUT852L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT852L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT852L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT852H: Graphic MMU LUT entry 852 high
func (o *GFXMMU_Type) SetLUT852H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT852H.Reg, volatile.LoadUint32(&o.LUT852H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT852H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT852H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT853L: Graphic MMU LUT entry 853 low
func (o *GFXMMU_Type) SetLUT853L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT853L.Reg, volatile.LoadUint32(&o.LUT853L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT853L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT853L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT853L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT853L.Reg, volatile.LoadUint32(&o.LUT853L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT853L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT853L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT853L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT853L.Reg, volatile.LoadUint32(&o.LUT853L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT853L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT853L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT853H: Graphic MMU LUT entry 853 high
func (o *GFXMMU_Type) SetLUT853H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT853H.Reg, volatile.LoadUint32(&o.LUT853H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT853H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT853H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT854L: Graphic MMU LUT entry 854 low
func (o *GFXMMU_Type) SetLUT854L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT854L.Reg, volatile.LoadUint32(&o.LUT854L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT854L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT854L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT854L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT854L.Reg, volatile.LoadUint32(&o.LUT854L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT854L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT854L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT854L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT854L.Reg, volatile.LoadUint32(&o.LUT854L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT854L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT854L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT854H: Graphic MMU LUT entry 854 high
func (o *GFXMMU_Type) SetLUT854H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT854H.Reg, volatile.LoadUint32(&o.LUT854H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT854H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT854H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT855L: Graphic MMU LUT entry 855 low
func (o *GFXMMU_Type) SetLUT855L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT855L.Reg, volatile.LoadUint32(&o.LUT855L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT855L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT855L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT855L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT855L.Reg, volatile.LoadUint32(&o.LUT855L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT855L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT855L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT855L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT855L.Reg, volatile.LoadUint32(&o.LUT855L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT855L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT855L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT855H: Graphic MMU LUT entry 855 high
func (o *GFXMMU_Type) SetLUT855H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT855H.Reg, volatile.LoadUint32(&o.LUT855H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT855H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT855H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT856L: Graphic MMU LUT entry 856 low
func (o *GFXMMU_Type) SetLUT856L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT856L.Reg, volatile.LoadUint32(&o.LUT856L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT856L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT856L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT856L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT856L.Reg, volatile.LoadUint32(&o.LUT856L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT856L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT856L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT856L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT856L.Reg, volatile.LoadUint32(&o.LUT856L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT856L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT856L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT856H: Graphic MMU LUT entry 856 high
func (o *GFXMMU_Type) SetLUT856H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT856H.Reg, volatile.LoadUint32(&o.LUT856H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT856H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT856H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT857L: Graphic MMU LUT entry 857 low
func (o *GFXMMU_Type) SetLUT857L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT857L.Reg, volatile.LoadUint32(&o.LUT857L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT857L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT857L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT857L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT857L.Reg, volatile.LoadUint32(&o.LUT857L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT857L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT857L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT857L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT857L.Reg, volatile.LoadUint32(&o.LUT857L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT857L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT857L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT857H: Graphic MMU LUT entry 857 high
func (o *GFXMMU_Type) SetLUT857H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT857H.Reg, volatile.LoadUint32(&o.LUT857H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT857H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT857H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT858L: Graphic MMU LUT entry 858 low
func (o *GFXMMU_Type) SetLUT858L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT858L.Reg, volatile.LoadUint32(&o.LUT858L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT858L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT858L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT858L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT858L.Reg, volatile.LoadUint32(&o.LUT858L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT858L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT858L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT858L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT858L.Reg, volatile.LoadUint32(&o.LUT858L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT858L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT858L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT858H: Graphic MMU LUT entry 858 high
func (o *GFXMMU_Type) SetLUT858H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT858H.Reg, volatile.LoadUint32(&o.LUT858H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT858H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT858H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT859L: Graphic MMU LUT entry 859 low
func (o *GFXMMU_Type) SetLUT859L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT859L.Reg, volatile.LoadUint32(&o.LUT859L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT859L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT859L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT859L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT859L.Reg, volatile.LoadUint32(&o.LUT859L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT859L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT859L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT859L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT859L.Reg, volatile.LoadUint32(&o.LUT859L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT859L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT859L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT859H: Graphic MMU LUT entry 859 high
func (o *GFXMMU_Type) SetLUT859H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT859H.Reg, volatile.LoadUint32(&o.LUT859H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT859H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT859H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT860L: Graphic MMU LUT entry 860 low
func (o *GFXMMU_Type) SetLUT860L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT860L.Reg, volatile.LoadUint32(&o.LUT860L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT860L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT860L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT860L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT860L.Reg, volatile.LoadUint32(&o.LUT860L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT860L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT860L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT860L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT860L.Reg, volatile.LoadUint32(&o.LUT860L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT860L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT860L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT860H: Graphic MMU LUT entry 860 high
func (o *GFXMMU_Type) SetLUT860H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT860H.Reg, volatile.LoadUint32(&o.LUT860H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT860H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT860H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT861L: Graphic MMU LUT entry 861 low
func (o *GFXMMU_Type) SetLUT861L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT861L.Reg, volatile.LoadUint32(&o.LUT861L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT861L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT861L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT861L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT861L.Reg, volatile.LoadUint32(&o.LUT861L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT861L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT861L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT861L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT861L.Reg, volatile.LoadUint32(&o.LUT861L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT861L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT861L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT861H: Graphic MMU LUT entry 861 high
func (o *GFXMMU_Type) SetLUT861H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT861H.Reg, volatile.LoadUint32(&o.LUT861H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT861H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT861H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT862L: Graphic MMU LUT entry 862 low
func (o *GFXMMU_Type) SetLUT862L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT862L.Reg, volatile.LoadUint32(&o.LUT862L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT862L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT862L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT862L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT862L.Reg, volatile.LoadUint32(&o.LUT862L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT862L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT862L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT862L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT862L.Reg, volatile.LoadUint32(&o.LUT862L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT862L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT862L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT862H: Graphic MMU LUT entry 862 high
func (o *GFXMMU_Type) SetLUT862H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT862H.Reg, volatile.LoadUint32(&o.LUT862H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT862H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT862H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT863L: Graphic MMU LUT entry 863 low
func (o *GFXMMU_Type) SetLUT863L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT863L.Reg, volatile.LoadUint32(&o.LUT863L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT863L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT863L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT863L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT863L.Reg, volatile.LoadUint32(&o.LUT863L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT863L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT863L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT863L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT863L.Reg, volatile.LoadUint32(&o.LUT863L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT863L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT863L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT863H: Graphic MMU LUT entry 863 high
func (o *GFXMMU_Type) SetLUT863H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT863H.Reg, volatile.LoadUint32(&o.LUT863H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT863H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT863H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT864L: Graphic MMU LUT entry 864 low
func (o *GFXMMU_Type) SetLUT864L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT864L.Reg, volatile.LoadUint32(&o.LUT864L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT864L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT864L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT864L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT864L.Reg, volatile.LoadUint32(&o.LUT864L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT864L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT864L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT864L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT864L.Reg, volatile.LoadUint32(&o.LUT864L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT864L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT864L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT864H: Graphic MMU LUT entry 864 high
func (o *GFXMMU_Type) SetLUT864H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT864H.Reg, volatile.LoadUint32(&o.LUT864H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT864H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT864H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT865L: Graphic MMU LUT entry 865 low
func (o *GFXMMU_Type) SetLUT865L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT865L.Reg, volatile.LoadUint32(&o.LUT865L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT865L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT865L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT865L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT865L.Reg, volatile.LoadUint32(&o.LUT865L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT865L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT865L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT865L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT865L.Reg, volatile.LoadUint32(&o.LUT865L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT865L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT865L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT865H: Graphic MMU LUT entry 865 high
func (o *GFXMMU_Type) SetLUT865H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT865H.Reg, volatile.LoadUint32(&o.LUT865H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT865H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT865H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT866L: Graphic MMU LUT entry 866 low
func (o *GFXMMU_Type) SetLUT866L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT866L.Reg, volatile.LoadUint32(&o.LUT866L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT866L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT866L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT866L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT866L.Reg, volatile.LoadUint32(&o.LUT866L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT866L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT866L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT866L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT866L.Reg, volatile.LoadUint32(&o.LUT866L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT866L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT866L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT866H: Graphic MMU LUT entry 866 high
func (o *GFXMMU_Type) SetLUT866H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT866H.Reg, volatile.LoadUint32(&o.LUT866H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT866H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT866H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT867L: Graphic MMU LUT entry 867 low
func (o *GFXMMU_Type) SetLUT867L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT867L.Reg, volatile.LoadUint32(&o.LUT867L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT867L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT867L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT867L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT867L.Reg, volatile.LoadUint32(&o.LUT867L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT867L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT867L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT867L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT867L.Reg, volatile.LoadUint32(&o.LUT867L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT867L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT867L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT867H: Graphic MMU LUT entry 867 high
func (o *GFXMMU_Type) SetLUT867H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT867H.Reg, volatile.LoadUint32(&o.LUT867H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT867H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT867H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT868L: Graphic MMU LUT entry 868 low
func (o *GFXMMU_Type) SetLUT868L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT868L.Reg, volatile.LoadUint32(&o.LUT868L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT868L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT868L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT868L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT868L.Reg, volatile.LoadUint32(&o.LUT868L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT868L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT868L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT868L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT868L.Reg, volatile.LoadUint32(&o.LUT868L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT868L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT868L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT868H: Graphic MMU LUT entry 868 high
func (o *GFXMMU_Type) SetLUT868H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT868H.Reg, volatile.LoadUint32(&o.LUT868H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT868H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT868H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT869L: Graphic MMU LUT entry 869 low
func (o *GFXMMU_Type) SetLUT869L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT869L.Reg, volatile.LoadUint32(&o.LUT869L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT869L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT869L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT869L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT869L.Reg, volatile.LoadUint32(&o.LUT869L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT869L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT869L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT869L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT869L.Reg, volatile.LoadUint32(&o.LUT869L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT869L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT869L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT869H: Graphic MMU LUT entry 869 high
func (o *GFXMMU_Type) SetLUT869H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT869H.Reg, volatile.LoadUint32(&o.LUT869H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT869H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT869H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT870L: Graphic MMU LUT entry 870 low
func (o *GFXMMU_Type) SetLUT870L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT870L.Reg, volatile.LoadUint32(&o.LUT870L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT870L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT870L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT870L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT870L.Reg, volatile.LoadUint32(&o.LUT870L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT870L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT870L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT870L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT870L.Reg, volatile.LoadUint32(&o.LUT870L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT870L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT870L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT870H: Graphic MMU LUT entry 870 high
func (o *GFXMMU_Type) SetLUT870H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT870H.Reg, volatile.LoadUint32(&o.LUT870H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT870H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT870H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT871L: Graphic MMU LUT entry 871 low
func (o *GFXMMU_Type) SetLUT871L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT871L.Reg, volatile.LoadUint32(&o.LUT871L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT871L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT871L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT871L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT871L.Reg, volatile.LoadUint32(&o.LUT871L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT871L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT871L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT871L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT871L.Reg, volatile.LoadUint32(&o.LUT871L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT871L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT871L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT871H: Graphic MMU LUT entry 871 high
func (o *GFXMMU_Type) SetLUT871H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT871H.Reg, volatile.LoadUint32(&o.LUT871H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT871H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT871H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT872L: Graphic MMU LUT entry 872 low
func (o *GFXMMU_Type) SetLUT872L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT872L.Reg, volatile.LoadUint32(&o.LUT872L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT872L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT872L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT872L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT872L.Reg, volatile.LoadUint32(&o.LUT872L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT872L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT872L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT872L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT872L.Reg, volatile.LoadUint32(&o.LUT872L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT872L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT872L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT872H: Graphic MMU LUT entry 872 high
func (o *GFXMMU_Type) SetLUT872H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT872H.Reg, volatile.LoadUint32(&o.LUT872H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT872H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT872H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT873L: Graphic MMU LUT entry 873 low
func (o *GFXMMU_Type) SetLUT873L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT873L.Reg, volatile.LoadUint32(&o.LUT873L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT873L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT873L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT873L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT873L.Reg, volatile.LoadUint32(&o.LUT873L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT873L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT873L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT873L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT873L.Reg, volatile.LoadUint32(&o.LUT873L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT873L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT873L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT873H: Graphic MMU LUT entry 873 high
func (o *GFXMMU_Type) SetLUT873H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT873H.Reg, volatile.LoadUint32(&o.LUT873H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT873H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT873H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT874L: Graphic MMU LUT entry 874 low
func (o *GFXMMU_Type) SetLUT874L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT874L.Reg, volatile.LoadUint32(&o.LUT874L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT874L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT874L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT874L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT874L.Reg, volatile.LoadUint32(&o.LUT874L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT874L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT874L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT874L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT874L.Reg, volatile.LoadUint32(&o.LUT874L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT874L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT874L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT874H: Graphic MMU LUT entry 874 high
func (o *GFXMMU_Type) SetLUT874H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT874H.Reg, volatile.LoadUint32(&o.LUT874H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT874H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT874H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT875L: Graphic MMU LUT entry 875 low
func (o *GFXMMU_Type) SetLUT875L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT875L.Reg, volatile.LoadUint32(&o.LUT875L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT875L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT875L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT875L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT875L.Reg, volatile.LoadUint32(&o.LUT875L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT875L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT875L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT875L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT875L.Reg, volatile.LoadUint32(&o.LUT875L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT875L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT875L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT875H: Graphic MMU LUT entry 875 high
func (o *GFXMMU_Type) SetLUT875H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT875H.Reg, volatile.LoadUint32(&o.LUT875H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT875H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT875H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT876L: Graphic MMU LUT entry 876 low
func (o *GFXMMU_Type) SetLUT876L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT876L.Reg, volatile.LoadUint32(&o.LUT876L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT876L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT876L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT876L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT876L.Reg, volatile.LoadUint32(&o.LUT876L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT876L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT876L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT876L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT876L.Reg, volatile.LoadUint32(&o.LUT876L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT876L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT876L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT876H: Graphic MMU LUT entry 876 high
func (o *GFXMMU_Type) SetLUT876H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT876H.Reg, volatile.LoadUint32(&o.LUT876H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT876H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT876H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT877L: Graphic MMU LUT entry 877 low
func (o *GFXMMU_Type) SetLUT877L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT877L.Reg, volatile.LoadUint32(&o.LUT877L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT877L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT877L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT877L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT877L.Reg, volatile.LoadUint32(&o.LUT877L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT877L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT877L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT877L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT877L.Reg, volatile.LoadUint32(&o.LUT877L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT877L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT877L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT877H: Graphic MMU LUT entry 877 high
func (o *GFXMMU_Type) SetLUT877H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT877H.Reg, volatile.LoadUint32(&o.LUT877H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT877H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT877H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT878L: Graphic MMU LUT entry 878 low
func (o *GFXMMU_Type) SetLUT878L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT878L.Reg, volatile.LoadUint32(&o.LUT878L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT878L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT878L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT878L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT878L.Reg, volatile.LoadUint32(&o.LUT878L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT878L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT878L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT878L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT878L.Reg, volatile.LoadUint32(&o.LUT878L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT878L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT878L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT878H: Graphic MMU LUT entry 878 high
func (o *GFXMMU_Type) SetLUT878H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT878H.Reg, volatile.LoadUint32(&o.LUT878H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT878H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT878H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT879L: Graphic MMU LUT entry 879 low
func (o *GFXMMU_Type) SetLUT879L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT879L.Reg, volatile.LoadUint32(&o.LUT879L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT879L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT879L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT879L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT879L.Reg, volatile.LoadUint32(&o.LUT879L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT879L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT879L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT879L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT879L.Reg, volatile.LoadUint32(&o.LUT879L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT879L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT879L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT879H: Graphic MMU LUT entry 879 high
func (o *GFXMMU_Type) SetLUT879H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT879H.Reg, volatile.LoadUint32(&o.LUT879H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT879H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT879H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT880L: Graphic MMU LUT entry 880 low
func (o *GFXMMU_Type) SetLUT880L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT880L.Reg, volatile.LoadUint32(&o.LUT880L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT880L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT880L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT880L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT880L.Reg, volatile.LoadUint32(&o.LUT880L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT880L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT880L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT880L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT880L.Reg, volatile.LoadUint32(&o.LUT880L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT880L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT880L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT880H: Graphic MMU LUT entry 880 high
func (o *GFXMMU_Type) SetLUT880H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT880H.Reg, volatile.LoadUint32(&o.LUT880H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT880H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT880H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT881L: Graphic MMU LUT entry 881 low
func (o *GFXMMU_Type) SetLUT881L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT881L.Reg, volatile.LoadUint32(&o.LUT881L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT881L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT881L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT881L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT881L.Reg, volatile.LoadUint32(&o.LUT881L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT881L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT881L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT881L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT881L.Reg, volatile.LoadUint32(&o.LUT881L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT881L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT881L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT881H: Graphic MMU LUT entry 881 high
func (o *GFXMMU_Type) SetLUT881H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT881H.Reg, volatile.LoadUint32(&o.LUT881H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT881H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT881H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT882L: Graphic MMU LUT entry 882 low
func (o *GFXMMU_Type) SetLUT882L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT882L.Reg, volatile.LoadUint32(&o.LUT882L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT882L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT882L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT882L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT882L.Reg, volatile.LoadUint32(&o.LUT882L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT882L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT882L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT882L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT882L.Reg, volatile.LoadUint32(&o.LUT882L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT882L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT882L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT882H: Graphic MMU LUT entry 882 high
func (o *GFXMMU_Type) SetLUT882H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT882H.Reg, volatile.LoadUint32(&o.LUT882H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT882H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT882H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT883L: Graphic MMU LUT entry 883 low
func (o *GFXMMU_Type) SetLUT883L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT883L.Reg, volatile.LoadUint32(&o.LUT883L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT883L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT883L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT883L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT883L.Reg, volatile.LoadUint32(&o.LUT883L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT883L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT883L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT883L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT883L.Reg, volatile.LoadUint32(&o.LUT883L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT883L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT883L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT883H: Graphic MMU LUT entry 883 high
func (o *GFXMMU_Type) SetLUT883H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT883H.Reg, volatile.LoadUint32(&o.LUT883H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT883H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT883H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT884L: Graphic MMU LUT entry 884 low
func (o *GFXMMU_Type) SetLUT884L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT884L.Reg, volatile.LoadUint32(&o.LUT884L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT884L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT884L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT884L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT884L.Reg, volatile.LoadUint32(&o.LUT884L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT884L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT884L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT884L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT884L.Reg, volatile.LoadUint32(&o.LUT884L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT884L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT884L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT884H: Graphic MMU LUT entry 884 high
func (o *GFXMMU_Type) SetLUT884H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT884H.Reg, volatile.LoadUint32(&o.LUT884H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT884H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT884H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT885L: Graphic MMU LUT entry 885 low
func (o *GFXMMU_Type) SetLUT885L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT885L.Reg, volatile.LoadUint32(&o.LUT885L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT885L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT885L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT885L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT885L.Reg, volatile.LoadUint32(&o.LUT885L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT885L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT885L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT885L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT885L.Reg, volatile.LoadUint32(&o.LUT885L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT885L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT885L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT885H: Graphic MMU LUT entry 885 high
func (o *GFXMMU_Type) SetLUT885H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT885H.Reg, volatile.LoadUint32(&o.LUT885H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT885H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT885H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT886L: Graphic MMU LUT entry 886 low
func (o *GFXMMU_Type) SetLUT886L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT886L.Reg, volatile.LoadUint32(&o.LUT886L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT886L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT886L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT886L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT886L.Reg, volatile.LoadUint32(&o.LUT886L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT886L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT886L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT886L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT886L.Reg, volatile.LoadUint32(&o.LUT886L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT886L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT886L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT886H: Graphic MMU LUT entry 886 high
func (o *GFXMMU_Type) SetLUT886H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT886H.Reg, volatile.LoadUint32(&o.LUT886H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT886H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT886H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT887L: Graphic MMU LUT entry 887 low
func (o *GFXMMU_Type) SetLUT887L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT887L.Reg, volatile.LoadUint32(&o.LUT887L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT887L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT887L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT887L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT887L.Reg, volatile.LoadUint32(&o.LUT887L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT887L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT887L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT887L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT887L.Reg, volatile.LoadUint32(&o.LUT887L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT887L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT887L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT887H: Graphic MMU LUT entry 887 high
func (o *GFXMMU_Type) SetLUT887H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT887H.Reg, volatile.LoadUint32(&o.LUT887H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT887H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT887H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT888L: Graphic MMU LUT entry 888 low
func (o *GFXMMU_Type) SetLUT888L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT888L.Reg, volatile.LoadUint32(&o.LUT888L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT888L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT888L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT888L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT888L.Reg, volatile.LoadUint32(&o.LUT888L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT888L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT888L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT888L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT888L.Reg, volatile.LoadUint32(&o.LUT888L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT888L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT888L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT888H: Graphic MMU LUT entry 888 high
func (o *GFXMMU_Type) SetLUT888H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT888H.Reg, volatile.LoadUint32(&o.LUT888H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT888H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT888H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT889L: Graphic MMU LUT entry 889 low
func (o *GFXMMU_Type) SetLUT889L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT889L.Reg, volatile.LoadUint32(&o.LUT889L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT889L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT889L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT889L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT889L.Reg, volatile.LoadUint32(&o.LUT889L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT889L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT889L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT889L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT889L.Reg, volatile.LoadUint32(&o.LUT889L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT889L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT889L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT889H: Graphic MMU LUT entry 889 high
func (o *GFXMMU_Type) SetLUT889H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT889H.Reg, volatile.LoadUint32(&o.LUT889H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT889H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT889H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT890L: Graphic MMU LUT entry 890 low
func (o *GFXMMU_Type) SetLUT890L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT890L.Reg, volatile.LoadUint32(&o.LUT890L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT890L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT890L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT890L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT890L.Reg, volatile.LoadUint32(&o.LUT890L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT890L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT890L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT890L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT890L.Reg, volatile.LoadUint32(&o.LUT890L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT890L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT890L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT890H: Graphic MMU LUT entry 890 high
func (o *GFXMMU_Type) SetLUT890H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT890H.Reg, volatile.LoadUint32(&o.LUT890H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT890H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT890H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT891L: Graphic MMU LUT entry 891 low
func (o *GFXMMU_Type) SetLUT891L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT891L.Reg, volatile.LoadUint32(&o.LUT891L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT891L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT891L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT891L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT891L.Reg, volatile.LoadUint32(&o.LUT891L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT891L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT891L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT891L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT891L.Reg, volatile.LoadUint32(&o.LUT891L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT891L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT891L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT891H: Graphic MMU LUT entry 891 high
func (o *GFXMMU_Type) SetLUT891H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT891H.Reg, volatile.LoadUint32(&o.LUT891H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT891H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT891H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT892L: Graphic MMU LUT entry 892 low
func (o *GFXMMU_Type) SetLUT892L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT892L.Reg, volatile.LoadUint32(&o.LUT892L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT892L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT892L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT892L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT892L.Reg, volatile.LoadUint32(&o.LUT892L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT892L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT892L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT892L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT892L.Reg, volatile.LoadUint32(&o.LUT892L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT892L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT892L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT892H: Graphic MMU LUT entry 892 high
func (o *GFXMMU_Type) SetLUT892H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT892H.Reg, volatile.LoadUint32(&o.LUT892H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT892H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT892H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT893L: Graphic MMU LUT entry 893 low
func (o *GFXMMU_Type) SetLUT893L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT893L.Reg, volatile.LoadUint32(&o.LUT893L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT893L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT893L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT893L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT893L.Reg, volatile.LoadUint32(&o.LUT893L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT893L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT893L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT893L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT893L.Reg, volatile.LoadUint32(&o.LUT893L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT893L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT893L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT893H: Graphic MMU LUT entry 893 high
func (o *GFXMMU_Type) SetLUT893H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT893H.Reg, volatile.LoadUint32(&o.LUT893H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT893H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT893H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT894L: Graphic MMU LUT entry 894 low
func (o *GFXMMU_Type) SetLUT894L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT894L.Reg, volatile.LoadUint32(&o.LUT894L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT894L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT894L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT894L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT894L.Reg, volatile.LoadUint32(&o.LUT894L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT894L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT894L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT894L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT894L.Reg, volatile.LoadUint32(&o.LUT894L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT894L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT894L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT894H: Graphic MMU LUT entry 894 high
func (o *GFXMMU_Type) SetLUT894H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT894H.Reg, volatile.LoadUint32(&o.LUT894H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT894H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT894H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT895L: Graphic MMU LUT entry 895 low
func (o *GFXMMU_Type) SetLUT895L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT895L.Reg, volatile.LoadUint32(&o.LUT895L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT895L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT895L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT895L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT895L.Reg, volatile.LoadUint32(&o.LUT895L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT895L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT895L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT895L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT895L.Reg, volatile.LoadUint32(&o.LUT895L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT895L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT895L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT895H: Graphic MMU LUT entry 895 high
func (o *GFXMMU_Type) SetLUT895H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT895H.Reg, volatile.LoadUint32(&o.LUT895H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT895H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT895H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT896L: Graphic MMU LUT entry 896 low
func (o *GFXMMU_Type) SetLUT896L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT896L.Reg, volatile.LoadUint32(&o.LUT896L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT896L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT896L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT896L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT896L.Reg, volatile.LoadUint32(&o.LUT896L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT896L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT896L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT896L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT896L.Reg, volatile.LoadUint32(&o.LUT896L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT896L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT896L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT896H: Graphic MMU LUT entry 896 high
func (o *GFXMMU_Type) SetLUT896H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT896H.Reg, volatile.LoadUint32(&o.LUT896H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT896H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT896H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT897L: Graphic MMU LUT entry 897 low
func (o *GFXMMU_Type) SetLUT897L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT897L.Reg, volatile.LoadUint32(&o.LUT897L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT897L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT897L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT897L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT897L.Reg, volatile.LoadUint32(&o.LUT897L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT897L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT897L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT897L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT897L.Reg, volatile.LoadUint32(&o.LUT897L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT897L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT897L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT897H: Graphic MMU LUT entry 897 high
func (o *GFXMMU_Type) SetLUT897H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT897H.Reg, volatile.LoadUint32(&o.LUT897H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT897H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT897H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT898L: Graphic MMU LUT entry 898 low
func (o *GFXMMU_Type) SetLUT898L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT898L.Reg, volatile.LoadUint32(&o.LUT898L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT898L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT898L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT898L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT898L.Reg, volatile.LoadUint32(&o.LUT898L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT898L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT898L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT898L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT898L.Reg, volatile.LoadUint32(&o.LUT898L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT898L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT898L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT898H: Graphic MMU LUT entry 898 high
func (o *GFXMMU_Type) SetLUT898H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT898H.Reg, volatile.LoadUint32(&o.LUT898H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT898H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT898H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT899L: Graphic MMU LUT entry 899 low
func (o *GFXMMU_Type) SetLUT899L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT899L.Reg, volatile.LoadUint32(&o.LUT899L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT899L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT899L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT899L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT899L.Reg, volatile.LoadUint32(&o.LUT899L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT899L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT899L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT899L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT899L.Reg, volatile.LoadUint32(&o.LUT899L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT899L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT899L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT899H: Graphic MMU LUT entry 899 high
func (o *GFXMMU_Type) SetLUT899H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT899H.Reg, volatile.LoadUint32(&o.LUT899H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT899H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT899H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT900L: Graphic MMU LUT entry 900 low
func (o *GFXMMU_Type) SetLUT900L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT900L.Reg, volatile.LoadUint32(&o.LUT900L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT900L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT900L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT900L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT900L.Reg, volatile.LoadUint32(&o.LUT900L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT900L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT900L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT900L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT900L.Reg, volatile.LoadUint32(&o.LUT900L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT900L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT900L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT900H: Graphic MMU LUT entry 900 high
func (o *GFXMMU_Type) SetLUT900H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT900H.Reg, volatile.LoadUint32(&o.LUT900H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT900H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT900H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT901L: Graphic MMU LUT entry 901 low
func (o *GFXMMU_Type) SetLUT901L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT901L.Reg, volatile.LoadUint32(&o.LUT901L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT901L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT901L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT901L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT901L.Reg, volatile.LoadUint32(&o.LUT901L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT901L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT901L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT901L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT901L.Reg, volatile.LoadUint32(&o.LUT901L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT901L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT901L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT901H: Graphic MMU LUT entry 901 high
func (o *GFXMMU_Type) SetLUT901H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT901H.Reg, volatile.LoadUint32(&o.LUT901H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT901H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT901H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT902L: Graphic MMU LUT entry 902 low
func (o *GFXMMU_Type) SetLUT902L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT902L.Reg, volatile.LoadUint32(&o.LUT902L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT902L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT902L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT902L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT902L.Reg, volatile.LoadUint32(&o.LUT902L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT902L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT902L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT902L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT902L.Reg, volatile.LoadUint32(&o.LUT902L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT902L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT902L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT902H: Graphic MMU LUT entry 902 high
func (o *GFXMMU_Type) SetLUT902H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT902H.Reg, volatile.LoadUint32(&o.LUT902H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT902H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT902H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT903L: Graphic MMU LUT entry 903 low
func (o *GFXMMU_Type) SetLUT903L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT903L.Reg, volatile.LoadUint32(&o.LUT903L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT903L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT903L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT903L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT903L.Reg, volatile.LoadUint32(&o.LUT903L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT903L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT903L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT903L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT903L.Reg, volatile.LoadUint32(&o.LUT903L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT903L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT903L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT903H: Graphic MMU LUT entry 903 high
func (o *GFXMMU_Type) SetLUT903H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT903H.Reg, volatile.LoadUint32(&o.LUT903H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT903H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT903H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT904L: Graphic MMU LUT entry 904 low
func (o *GFXMMU_Type) SetLUT904L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT904L.Reg, volatile.LoadUint32(&o.LUT904L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT904L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT904L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT904L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT904L.Reg, volatile.LoadUint32(&o.LUT904L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT904L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT904L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT904L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT904L.Reg, volatile.LoadUint32(&o.LUT904L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT904L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT904L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT904H: Graphic MMU LUT entry 904 high
func (o *GFXMMU_Type) SetLUT904H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT904H.Reg, volatile.LoadUint32(&o.LUT904H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT904H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT904H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT905L: Graphic MMU LUT entry 905 low
func (o *GFXMMU_Type) SetLUT905L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT905L.Reg, volatile.LoadUint32(&o.LUT905L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT905L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT905L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT905L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT905L.Reg, volatile.LoadUint32(&o.LUT905L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT905L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT905L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT905L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT905L.Reg, volatile.LoadUint32(&o.LUT905L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT905L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT905L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT905H: Graphic MMU LUT entry 905 high
func (o *GFXMMU_Type) SetLUT905H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT905H.Reg, volatile.LoadUint32(&o.LUT905H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT905H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT905H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT906L: Graphic MMU LUT entry 906 low
func (o *GFXMMU_Type) SetLUT906L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT906L.Reg, volatile.LoadUint32(&o.LUT906L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT906L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT906L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT906L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT906L.Reg, volatile.LoadUint32(&o.LUT906L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT906L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT906L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT906L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT906L.Reg, volatile.LoadUint32(&o.LUT906L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT906L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT906L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT906H: Graphic MMU LUT entry 906 high
func (o *GFXMMU_Type) SetLUT906H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT906H.Reg, volatile.LoadUint32(&o.LUT906H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT906H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT906H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT907L: Graphic MMU LUT entry 907 low
func (o *GFXMMU_Type) SetLUT907L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT907L.Reg, volatile.LoadUint32(&o.LUT907L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT907L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT907L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT907L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT907L.Reg, volatile.LoadUint32(&o.LUT907L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT907L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT907L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT907L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT907L.Reg, volatile.LoadUint32(&o.LUT907L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT907L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT907L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT907H: Graphic MMU LUT entry 907 high
func (o *GFXMMU_Type) SetLUT907H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT907H.Reg, volatile.LoadUint32(&o.LUT907H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT907H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT907H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT908L: Graphic MMU LUT entry 908 low
func (o *GFXMMU_Type) SetLUT908L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT908L.Reg, volatile.LoadUint32(&o.LUT908L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT908L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT908L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT908L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT908L.Reg, volatile.LoadUint32(&o.LUT908L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT908L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT908L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT908L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT908L.Reg, volatile.LoadUint32(&o.LUT908L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT908L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT908L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT908H: Graphic MMU LUT entry 908 high
func (o *GFXMMU_Type) SetLUT908H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT908H.Reg, volatile.LoadUint32(&o.LUT908H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT908H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT908H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT909L: Graphic MMU LUT entry 909 low
func (o *GFXMMU_Type) SetLUT909L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT909L.Reg, volatile.LoadUint32(&o.LUT909L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT909L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT909L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT909L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT909L.Reg, volatile.LoadUint32(&o.LUT909L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT909L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT909L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT909L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT909L.Reg, volatile.LoadUint32(&o.LUT909L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT909L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT909L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT909H: Graphic MMU LUT entry 909 high
func (o *GFXMMU_Type) SetLUT909H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT909H.Reg, volatile.LoadUint32(&o.LUT909H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT909H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT909H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT910L: Graphic MMU LUT entry 910 low
func (o *GFXMMU_Type) SetLUT910L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT910L.Reg, volatile.LoadUint32(&o.LUT910L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT910L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT910L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT910L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT910L.Reg, volatile.LoadUint32(&o.LUT910L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT910L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT910L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT910L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT910L.Reg, volatile.LoadUint32(&o.LUT910L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT910L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT910L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT910H: Graphic MMU LUT entry 910 high
func (o *GFXMMU_Type) SetLUT910H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT910H.Reg, volatile.LoadUint32(&o.LUT910H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT910H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT910H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT911L: Graphic MMU LUT entry 911 low
func (o *GFXMMU_Type) SetLUT911L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT911L.Reg, volatile.LoadUint32(&o.LUT911L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT911L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT911L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT911L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT911L.Reg, volatile.LoadUint32(&o.LUT911L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT911L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT911L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT911L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT911L.Reg, volatile.LoadUint32(&o.LUT911L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT911L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT911L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT911H: Graphic MMU LUT entry 911 high
func (o *GFXMMU_Type) SetLUT911H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT911H.Reg, volatile.LoadUint32(&o.LUT911H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT911H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT911H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT912L: Graphic MMU LUT entry 912 low
func (o *GFXMMU_Type) SetLUT912L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT912L.Reg, volatile.LoadUint32(&o.LUT912L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT912L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT912L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT912L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT912L.Reg, volatile.LoadUint32(&o.LUT912L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT912L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT912L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT912L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT912L.Reg, volatile.LoadUint32(&o.LUT912L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT912L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT912L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT912H: Graphic MMU LUT entry 912 high
func (o *GFXMMU_Type) SetLUT912H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT912H.Reg, volatile.LoadUint32(&o.LUT912H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT912H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT912H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT913L: Graphic MMU LUT entry 913 low
func (o *GFXMMU_Type) SetLUT913L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT913L.Reg, volatile.LoadUint32(&o.LUT913L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT913L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT913L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT913L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT913L.Reg, volatile.LoadUint32(&o.LUT913L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT913L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT913L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT913L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT913L.Reg, volatile.LoadUint32(&o.LUT913L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT913L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT913L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT913H: Graphic MMU LUT entry 913 high
func (o *GFXMMU_Type) SetLUT913H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT913H.Reg, volatile.LoadUint32(&o.LUT913H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT913H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT913H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT914L: Graphic MMU LUT entry 914 low
func (o *GFXMMU_Type) SetLUT914L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT914L.Reg, volatile.LoadUint32(&o.LUT914L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT914L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT914L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT914L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT914L.Reg, volatile.LoadUint32(&o.LUT914L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT914L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT914L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT914L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT914L.Reg, volatile.LoadUint32(&o.LUT914L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT914L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT914L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT914H: Graphic MMU LUT entry 914 high
func (o *GFXMMU_Type) SetLUT914H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT914H.Reg, volatile.LoadUint32(&o.LUT914H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT914H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT914H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT915L: Graphic MMU LUT entry 915 low
func (o *GFXMMU_Type) SetLUT915L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT915L.Reg, volatile.LoadUint32(&o.LUT915L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT915L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT915L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT915L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT915L.Reg, volatile.LoadUint32(&o.LUT915L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT915L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT915L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT915L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT915L.Reg, volatile.LoadUint32(&o.LUT915L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT915L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT915L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT915H: Graphic MMU LUT entry 915 high
func (o *GFXMMU_Type) SetLUT915H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT915H.Reg, volatile.LoadUint32(&o.LUT915H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT915H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT915H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT916L: Graphic MMU LUT entry 916 low
func (o *GFXMMU_Type) SetLUT916L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT916L.Reg, volatile.LoadUint32(&o.LUT916L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT916L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT916L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT916L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT916L.Reg, volatile.LoadUint32(&o.LUT916L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT916L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT916L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT916L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT916L.Reg, volatile.LoadUint32(&o.LUT916L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT916L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT916L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT916H: Graphic MMU LUT entry 916 high
func (o *GFXMMU_Type) SetLUT916H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT916H.Reg, volatile.LoadUint32(&o.LUT916H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT916H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT916H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT917L: Graphic MMU LUT entry 917 low
func (o *GFXMMU_Type) SetLUT917L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT917L.Reg, volatile.LoadUint32(&o.LUT917L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT917L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT917L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT917L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT917L.Reg, volatile.LoadUint32(&o.LUT917L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT917L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT917L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT917L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT917L.Reg, volatile.LoadUint32(&o.LUT917L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT917L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT917L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT917H: Graphic MMU LUT entry 917 high
func (o *GFXMMU_Type) SetLUT917H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT917H.Reg, volatile.LoadUint32(&o.LUT917H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT917H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT917H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT918L: Graphic MMU LUT entry 918 low
func (o *GFXMMU_Type) SetLUT918L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT918L.Reg, volatile.LoadUint32(&o.LUT918L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT918L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT918L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT918L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT918L.Reg, volatile.LoadUint32(&o.LUT918L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT918L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT918L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT918L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT918L.Reg, volatile.LoadUint32(&o.LUT918L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT918L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT918L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT918H: Graphic MMU LUT entry 918 high
func (o *GFXMMU_Type) SetLUT918H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT918H.Reg, volatile.LoadUint32(&o.LUT918H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT918H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT918H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT919L: Graphic MMU LUT entry 919 low
func (o *GFXMMU_Type) SetLUT919L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT919L.Reg, volatile.LoadUint32(&o.LUT919L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT919L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT919L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT919L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT919L.Reg, volatile.LoadUint32(&o.LUT919L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT919L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT919L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT919L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT919L.Reg, volatile.LoadUint32(&o.LUT919L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT919L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT919L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT919H: Graphic MMU LUT entry 919 high
func (o *GFXMMU_Type) SetLUT919H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT919H.Reg, volatile.LoadUint32(&o.LUT919H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT919H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT919H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT920L: Graphic MMU LUT entry 920 low
func (o *GFXMMU_Type) SetLUT920L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT920L.Reg, volatile.LoadUint32(&o.LUT920L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT920L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT920L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT920L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT920L.Reg, volatile.LoadUint32(&o.LUT920L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT920L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT920L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT920L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT920L.Reg, volatile.LoadUint32(&o.LUT920L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT920L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT920L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT920H: Graphic MMU LUT entry 920 high
func (o *GFXMMU_Type) SetLUT920H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT920H.Reg, volatile.LoadUint32(&o.LUT920H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT920H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT920H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT921L: Graphic MMU LUT entry 921 low
func (o *GFXMMU_Type) SetLUT921L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT921L.Reg, volatile.LoadUint32(&o.LUT921L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT921L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT921L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT921L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT921L.Reg, volatile.LoadUint32(&o.LUT921L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT921L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT921L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT921L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT921L.Reg, volatile.LoadUint32(&o.LUT921L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT921L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT921L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT921H: Graphic MMU LUT entry 921 high
func (o *GFXMMU_Type) SetLUT921H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT921H.Reg, volatile.LoadUint32(&o.LUT921H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT921H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT921H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT922L: Graphic MMU LUT entry 922 low
func (o *GFXMMU_Type) SetLUT922L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT922L.Reg, volatile.LoadUint32(&o.LUT922L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT922L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT922L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT922L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT922L.Reg, volatile.LoadUint32(&o.LUT922L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT922L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT922L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT922L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT922L.Reg, volatile.LoadUint32(&o.LUT922L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT922L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT922L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT922H: Graphic MMU LUT entry 922 high
func (o *GFXMMU_Type) SetLUT922H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT922H.Reg, volatile.LoadUint32(&o.LUT922H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT922H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT922H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT923L: Graphic MMU LUT entry 923 low
func (o *GFXMMU_Type) SetLUT923L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT923L.Reg, volatile.LoadUint32(&o.LUT923L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT923L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT923L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT923L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT923L.Reg, volatile.LoadUint32(&o.LUT923L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT923L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT923L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT923L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT923L.Reg, volatile.LoadUint32(&o.LUT923L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT923L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT923L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT923H: Graphic MMU LUT entry 923 high
func (o *GFXMMU_Type) SetLUT923H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT923H.Reg, volatile.LoadUint32(&o.LUT923H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT923H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT923H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT924L: Graphic MMU LUT entry 924 low
func (o *GFXMMU_Type) SetLUT924L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT924L.Reg, volatile.LoadUint32(&o.LUT924L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT924L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT924L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT924L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT924L.Reg, volatile.LoadUint32(&o.LUT924L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT924L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT924L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT924L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT924L.Reg, volatile.LoadUint32(&o.LUT924L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT924L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT924L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT924H: Graphic MMU LUT entry 924 high
func (o *GFXMMU_Type) SetLUT924H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT924H.Reg, volatile.LoadUint32(&o.LUT924H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT924H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT924H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT925L: Graphic MMU LUT entry 925 low
func (o *GFXMMU_Type) SetLUT925L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT925L.Reg, volatile.LoadUint32(&o.LUT925L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT925L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT925L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT925L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT925L.Reg, volatile.LoadUint32(&o.LUT925L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT925L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT925L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT925L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT925L.Reg, volatile.LoadUint32(&o.LUT925L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT925L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT925L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT925H: Graphic MMU LUT entry 925 high
func (o *GFXMMU_Type) SetLUT925H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT925H.Reg, volatile.LoadUint32(&o.LUT925H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT925H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT925H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT926L: Graphic MMU LUT entry 926 low
func (o *GFXMMU_Type) SetLUT926L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT926L.Reg, volatile.LoadUint32(&o.LUT926L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT926L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT926L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT926L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT926L.Reg, volatile.LoadUint32(&o.LUT926L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT926L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT926L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT926L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT926L.Reg, volatile.LoadUint32(&o.LUT926L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT926L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT926L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT926H: Graphic MMU LUT entry 926 high
func (o *GFXMMU_Type) SetLUT926H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT926H.Reg, volatile.LoadUint32(&o.LUT926H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT926H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT926H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT927L: Graphic MMU LUT entry 927 low
func (o *GFXMMU_Type) SetLUT927L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT927L.Reg, volatile.LoadUint32(&o.LUT927L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT927L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT927L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT927L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT927L.Reg, volatile.LoadUint32(&o.LUT927L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT927L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT927L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT927L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT927L.Reg, volatile.LoadUint32(&o.LUT927L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT927L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT927L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT927H: Graphic MMU LUT entry 927 high
func (o *GFXMMU_Type) SetLUT927H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT927H.Reg, volatile.LoadUint32(&o.LUT927H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT927H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT927H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT928L: Graphic MMU LUT entry 928 low
func (o *GFXMMU_Type) SetLUT928L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT928L.Reg, volatile.LoadUint32(&o.LUT928L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT928L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT928L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT928L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT928L.Reg, volatile.LoadUint32(&o.LUT928L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT928L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT928L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT928L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT928L.Reg, volatile.LoadUint32(&o.LUT928L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT928L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT928L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT928H: Graphic MMU LUT entry 928 high
func (o *GFXMMU_Type) SetLUT928H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT928H.Reg, volatile.LoadUint32(&o.LUT928H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT928H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT928H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT929L: Graphic MMU LUT entry 929 low
func (o *GFXMMU_Type) SetLUT929L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT929L.Reg, volatile.LoadUint32(&o.LUT929L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT929L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT929L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT929L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT929L.Reg, volatile.LoadUint32(&o.LUT929L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT929L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT929L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT929L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT929L.Reg, volatile.LoadUint32(&o.LUT929L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT929L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT929L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT929H: Graphic MMU LUT entry 929 high
func (o *GFXMMU_Type) SetLUT929H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT929H.Reg, volatile.LoadUint32(&o.LUT929H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT929H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT929H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT930L: Graphic MMU LUT entry 930 low
func (o *GFXMMU_Type) SetLUT930L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT930L.Reg, volatile.LoadUint32(&o.LUT930L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT930L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT930L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT930L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT930L.Reg, volatile.LoadUint32(&o.LUT930L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT930L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT930L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT930L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT930L.Reg, volatile.LoadUint32(&o.LUT930L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT930L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT930L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT930H: Graphic MMU LUT entry 930 high
func (o *GFXMMU_Type) SetLUT930H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT930H.Reg, volatile.LoadUint32(&o.LUT930H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT930H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT930H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT931L: Graphic MMU LUT entry 931 low
func (o *GFXMMU_Type) SetLUT931L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT931L.Reg, volatile.LoadUint32(&o.LUT931L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT931L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT931L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT931L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT931L.Reg, volatile.LoadUint32(&o.LUT931L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT931L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT931L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT931L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT931L.Reg, volatile.LoadUint32(&o.LUT931L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT931L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT931L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT931H: Graphic MMU LUT entry 931 high
func (o *GFXMMU_Type) SetLUT931H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT931H.Reg, volatile.LoadUint32(&o.LUT931H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT931H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT931H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT932L: Graphic MMU LUT entry 932 low
func (o *GFXMMU_Type) SetLUT932L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT932L.Reg, volatile.LoadUint32(&o.LUT932L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT932L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT932L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT932L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT932L.Reg, volatile.LoadUint32(&o.LUT932L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT932L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT932L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT932L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT932L.Reg, volatile.LoadUint32(&o.LUT932L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT932L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT932L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT932H: Graphic MMU LUT entry 932 high
func (o *GFXMMU_Type) SetLUT932H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT932H.Reg, volatile.LoadUint32(&o.LUT932H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT932H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT932H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT933L: Graphic MMU LUT entry 933 low
func (o *GFXMMU_Type) SetLUT933L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT933L.Reg, volatile.LoadUint32(&o.LUT933L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT933L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT933L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT933L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT933L.Reg, volatile.LoadUint32(&o.LUT933L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT933L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT933L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT933L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT933L.Reg, volatile.LoadUint32(&o.LUT933L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT933L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT933L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT933H: Graphic MMU LUT entry 933 high
func (o *GFXMMU_Type) SetLUT933H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT933H.Reg, volatile.LoadUint32(&o.LUT933H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT933H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT933H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT934L: Graphic MMU LUT entry 934 low
func (o *GFXMMU_Type) SetLUT934L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT934L.Reg, volatile.LoadUint32(&o.LUT934L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT934L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT934L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT934L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT934L.Reg, volatile.LoadUint32(&o.LUT934L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT934L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT934L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT934L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT934L.Reg, volatile.LoadUint32(&o.LUT934L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT934L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT934L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT934H: Graphic MMU LUT entry 934 high
func (o *GFXMMU_Type) SetLUT934H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT934H.Reg, volatile.LoadUint32(&o.LUT934H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT934H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT934H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT935L: Graphic MMU LUT entry 935 low
func (o *GFXMMU_Type) SetLUT935L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT935L.Reg, volatile.LoadUint32(&o.LUT935L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT935L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT935L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT935L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT935L.Reg, volatile.LoadUint32(&o.LUT935L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT935L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT935L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT935L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT935L.Reg, volatile.LoadUint32(&o.LUT935L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT935L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT935L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT935H: Graphic MMU LUT entry 935 high
func (o *GFXMMU_Type) SetLUT935H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT935H.Reg, volatile.LoadUint32(&o.LUT935H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT935H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT935H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT936L: Graphic MMU LUT entry 936 low
func (o *GFXMMU_Type) SetLUT936L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT936L.Reg, volatile.LoadUint32(&o.LUT936L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT936L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT936L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT936L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT936L.Reg, volatile.LoadUint32(&o.LUT936L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT936L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT936L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT936L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT936L.Reg, volatile.LoadUint32(&o.LUT936L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT936L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT936L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT936H: Graphic MMU LUT entry 936 high
func (o *GFXMMU_Type) SetLUT936H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT936H.Reg, volatile.LoadUint32(&o.LUT936H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT936H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT936H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT937L: Graphic MMU LUT entry 937 low
func (o *GFXMMU_Type) SetLUT937L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT937L.Reg, volatile.LoadUint32(&o.LUT937L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT937L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT937L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT937L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT937L.Reg, volatile.LoadUint32(&o.LUT937L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT937L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT937L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT937L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT937L.Reg, volatile.LoadUint32(&o.LUT937L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT937L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT937L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT937H: Graphic MMU LUT entry 937 high
func (o *GFXMMU_Type) SetLUT937H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT937H.Reg, volatile.LoadUint32(&o.LUT937H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT937H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT937H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT938L: Graphic MMU LUT entry 938 low
func (o *GFXMMU_Type) SetLUT938L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT938L.Reg, volatile.LoadUint32(&o.LUT938L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT938L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT938L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT938L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT938L.Reg, volatile.LoadUint32(&o.LUT938L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT938L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT938L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT938L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT938L.Reg, volatile.LoadUint32(&o.LUT938L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT938L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT938L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT938H: Graphic MMU LUT entry 938 high
func (o *GFXMMU_Type) SetLUT938H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT938H.Reg, volatile.LoadUint32(&o.LUT938H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT938H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT938H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT939L: Graphic MMU LUT entry 939 low
func (o *GFXMMU_Type) SetLUT939L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT939L.Reg, volatile.LoadUint32(&o.LUT939L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT939L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT939L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT939L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT939L.Reg, volatile.LoadUint32(&o.LUT939L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT939L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT939L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT939L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT939L.Reg, volatile.LoadUint32(&o.LUT939L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT939L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT939L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT939H: Graphic MMU LUT entry 939 high
func (o *GFXMMU_Type) SetLUT939H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT939H.Reg, volatile.LoadUint32(&o.LUT939H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT939H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT939H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT940L: Graphic MMU LUT entry 940 low
func (o *GFXMMU_Type) SetLUT940L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT940L.Reg, volatile.LoadUint32(&o.LUT940L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT940L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT940L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT940L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT940L.Reg, volatile.LoadUint32(&o.LUT940L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT940L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT940L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT940L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT940L.Reg, volatile.LoadUint32(&o.LUT940L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT940L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT940L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT940H: Graphic MMU LUT entry 940 high
func (o *GFXMMU_Type) SetLUT940H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT940H.Reg, volatile.LoadUint32(&o.LUT940H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT940H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT940H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT941L: Graphic MMU LUT entry 941 low
func (o *GFXMMU_Type) SetLUT941L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT941L.Reg, volatile.LoadUint32(&o.LUT941L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT941L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT941L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT941L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT941L.Reg, volatile.LoadUint32(&o.LUT941L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT941L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT941L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT941L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT941L.Reg, volatile.LoadUint32(&o.LUT941L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT941L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT941L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT941H: Graphic MMU LUT entry 941 high
func (o *GFXMMU_Type) SetLUT941H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT941H.Reg, volatile.LoadUint32(&o.LUT941H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT941H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT941H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT942L: Graphic MMU LUT entry 942 low
func (o *GFXMMU_Type) SetLUT942L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT942L.Reg, volatile.LoadUint32(&o.LUT942L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT942L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT942L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT942L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT942L.Reg, volatile.LoadUint32(&o.LUT942L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT942L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT942L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT942L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT942L.Reg, volatile.LoadUint32(&o.LUT942L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT942L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT942L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT942H: Graphic MMU LUT entry 942 high
func (o *GFXMMU_Type) SetLUT942H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT942H.Reg, volatile.LoadUint32(&o.LUT942H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT942H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT942H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT943L: Graphic MMU LUT entry 943 low
func (o *GFXMMU_Type) SetLUT943L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT943L.Reg, volatile.LoadUint32(&o.LUT943L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT943L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT943L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT943L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT943L.Reg, volatile.LoadUint32(&o.LUT943L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT943L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT943L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT943L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT943L.Reg, volatile.LoadUint32(&o.LUT943L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT943L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT943L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT943H: Graphic MMU LUT entry 943 high
func (o *GFXMMU_Type) SetLUT943H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT943H.Reg, volatile.LoadUint32(&o.LUT943H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT943H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT943H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT944L: Graphic MMU LUT entry 944 low
func (o *GFXMMU_Type) SetLUT944L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT944L.Reg, volatile.LoadUint32(&o.LUT944L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT944L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT944L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT944L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT944L.Reg, volatile.LoadUint32(&o.LUT944L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT944L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT944L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT944L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT944L.Reg, volatile.LoadUint32(&o.LUT944L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT944L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT944L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT944H: Graphic MMU LUT entry 944 high
func (o *GFXMMU_Type) SetLUT944H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT944H.Reg, volatile.LoadUint32(&o.LUT944H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT944H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT944H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT945L: Graphic MMU LUT entry 945 low
func (o *GFXMMU_Type) SetLUT945L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT945L.Reg, volatile.LoadUint32(&o.LUT945L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT945L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT945L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT945L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT945L.Reg, volatile.LoadUint32(&o.LUT945L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT945L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT945L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT945L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT945L.Reg, volatile.LoadUint32(&o.LUT945L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT945L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT945L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT945H: Graphic MMU LUT entry 945 high
func (o *GFXMMU_Type) SetLUT945H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT945H.Reg, volatile.LoadUint32(&o.LUT945H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT945H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT945H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT946L: Graphic MMU LUT entry 946 low
func (o *GFXMMU_Type) SetLUT946L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT946L.Reg, volatile.LoadUint32(&o.LUT946L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT946L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT946L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT946L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT946L.Reg, volatile.LoadUint32(&o.LUT946L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT946L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT946L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT946L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT946L.Reg, volatile.LoadUint32(&o.LUT946L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT946L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT946L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT946H: Graphic MMU LUT entry 946 high
func (o *GFXMMU_Type) SetLUT946H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT946H.Reg, volatile.LoadUint32(&o.LUT946H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT946H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT946H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT947L: Graphic MMU LUT entry 947 low
func (o *GFXMMU_Type) SetLUT947L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT947L.Reg, volatile.LoadUint32(&o.LUT947L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT947L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT947L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT947L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT947L.Reg, volatile.LoadUint32(&o.LUT947L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT947L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT947L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT947L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT947L.Reg, volatile.LoadUint32(&o.LUT947L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT947L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT947L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT947H: Graphic MMU LUT entry 947 high
func (o *GFXMMU_Type) SetLUT947H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT947H.Reg, volatile.LoadUint32(&o.LUT947H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT947H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT947H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT948L: Graphic MMU LUT entry 948 low
func (o *GFXMMU_Type) SetLUT948L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT948L.Reg, volatile.LoadUint32(&o.LUT948L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT948L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT948L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT948L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT948L.Reg, volatile.LoadUint32(&o.LUT948L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT948L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT948L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT948L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT948L.Reg, volatile.LoadUint32(&o.LUT948L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT948L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT948L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT948H: Graphic MMU LUT entry 948 high
func (o *GFXMMU_Type) SetLUT948H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT948H.Reg, volatile.LoadUint32(&o.LUT948H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT948H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT948H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT949L: Graphic MMU LUT entry 949 low
func (o *GFXMMU_Type) SetLUT949L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT949L.Reg, volatile.LoadUint32(&o.LUT949L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT949L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT949L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT949L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT949L.Reg, volatile.LoadUint32(&o.LUT949L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT949L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT949L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT949L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT949L.Reg, volatile.LoadUint32(&o.LUT949L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT949L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT949L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT949H: Graphic MMU LUT entry 949 high
func (o *GFXMMU_Type) SetLUT949H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT949H.Reg, volatile.LoadUint32(&o.LUT949H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT949H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT949H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT950L: Graphic MMU LUT entry 950 low
func (o *GFXMMU_Type) SetLUT950L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT950L.Reg, volatile.LoadUint32(&o.LUT950L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT950L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT950L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT950L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT950L.Reg, volatile.LoadUint32(&o.LUT950L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT950L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT950L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT950L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT950L.Reg, volatile.LoadUint32(&o.LUT950L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT950L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT950L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT950H: Graphic MMU LUT entry 950 high
func (o *GFXMMU_Type) SetLUT950H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT950H.Reg, volatile.LoadUint32(&o.LUT950H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT950H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT950H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT951L: Graphic MMU LUT entry 951 low
func (o *GFXMMU_Type) SetLUT951L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT951L.Reg, volatile.LoadUint32(&o.LUT951L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT951L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT951L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT951L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT951L.Reg, volatile.LoadUint32(&o.LUT951L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT951L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT951L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT951L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT951L.Reg, volatile.LoadUint32(&o.LUT951L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT951L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT951L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT951H: Graphic MMU LUT entry 951 high
func (o *GFXMMU_Type) SetLUT951H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT951H.Reg, volatile.LoadUint32(&o.LUT951H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT951H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT951H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT952L: Graphic MMU LUT entry 952 low
func (o *GFXMMU_Type) SetLUT952L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT952L.Reg, volatile.LoadUint32(&o.LUT952L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT952L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT952L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT952L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT952L.Reg, volatile.LoadUint32(&o.LUT952L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT952L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT952L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT952L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT952L.Reg, volatile.LoadUint32(&o.LUT952L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT952L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT952L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT952H: Graphic MMU LUT entry 952 high
func (o *GFXMMU_Type) SetLUT952H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT952H.Reg, volatile.LoadUint32(&o.LUT952H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT952H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT952H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT953L: Graphic MMU LUT entry 953 low
func (o *GFXMMU_Type) SetLUT953L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT953L.Reg, volatile.LoadUint32(&o.LUT953L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT953L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT953L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT953L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT953L.Reg, volatile.LoadUint32(&o.LUT953L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT953L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT953L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT953L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT953L.Reg, volatile.LoadUint32(&o.LUT953L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT953L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT953L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT953H: Graphic MMU LUT entry 953 high
func (o *GFXMMU_Type) SetLUT953H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT953H.Reg, volatile.LoadUint32(&o.LUT953H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT953H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT953H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT954L: Graphic MMU LUT entry 954 low
func (o *GFXMMU_Type) SetLUT954L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT954L.Reg, volatile.LoadUint32(&o.LUT954L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT954L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT954L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT954L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT954L.Reg, volatile.LoadUint32(&o.LUT954L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT954L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT954L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT954L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT954L.Reg, volatile.LoadUint32(&o.LUT954L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT954L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT954L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT954H: Graphic MMU LUT entry 954 high
func (o *GFXMMU_Type) SetLUT954H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT954H.Reg, volatile.LoadUint32(&o.LUT954H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT954H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT954H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT955L: Graphic MMU LUT entry 955 low
func (o *GFXMMU_Type) SetLUT955L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT955L.Reg, volatile.LoadUint32(&o.LUT955L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT955L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT955L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT955L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT955L.Reg, volatile.LoadUint32(&o.LUT955L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT955L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT955L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT955L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT955L.Reg, volatile.LoadUint32(&o.LUT955L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT955L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT955L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT955H: Graphic MMU LUT entry 955 high
func (o *GFXMMU_Type) SetLUT955H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT955H.Reg, volatile.LoadUint32(&o.LUT955H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT955H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT955H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT956L: Graphic MMU LUT entry 956 low
func (o *GFXMMU_Type) SetLUT956L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT956L.Reg, volatile.LoadUint32(&o.LUT956L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT956L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT956L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT956L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT956L.Reg, volatile.LoadUint32(&o.LUT956L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT956L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT956L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT956L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT956L.Reg, volatile.LoadUint32(&o.LUT956L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT956L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT956L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT956H: Graphic MMU LUT entry 956 high
func (o *GFXMMU_Type) SetLUT956H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT956H.Reg, volatile.LoadUint32(&o.LUT956H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT956H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT956H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT957L: Graphic MMU LUT entry 957 low
func (o *GFXMMU_Type) SetLUT957L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT957L.Reg, volatile.LoadUint32(&o.LUT957L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT957L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT957L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT957L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT957L.Reg, volatile.LoadUint32(&o.LUT957L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT957L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT957L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT957L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT957L.Reg, volatile.LoadUint32(&o.LUT957L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT957L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT957L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT957H: Graphic MMU LUT entry 957 high
func (o *GFXMMU_Type) SetLUT957H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT957H.Reg, volatile.LoadUint32(&o.LUT957H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT957H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT957H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT958L: Graphic MMU LUT entry 958 low
func (o *GFXMMU_Type) SetLUT958L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT958L.Reg, volatile.LoadUint32(&o.LUT958L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT958L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT958L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT958L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT958L.Reg, volatile.LoadUint32(&o.LUT958L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT958L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT958L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT958L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT958L.Reg, volatile.LoadUint32(&o.LUT958L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT958L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT958L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT958H: Graphic MMU LUT entry 958 high
func (o *GFXMMU_Type) SetLUT958H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT958H.Reg, volatile.LoadUint32(&o.LUT958H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT958H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT958H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT959L: Graphic MMU LUT entry 959 low
func (o *GFXMMU_Type) SetLUT959L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT959L.Reg, volatile.LoadUint32(&o.LUT959L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT959L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT959L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT959L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT959L.Reg, volatile.LoadUint32(&o.LUT959L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT959L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT959L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT959L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT959L.Reg, volatile.LoadUint32(&o.LUT959L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT959L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT959L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT959H: Graphic MMU LUT entry 959 high
func (o *GFXMMU_Type) SetLUT959H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT959H.Reg, volatile.LoadUint32(&o.LUT959H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT959H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT959H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT960L: Graphic MMU LUT entry 960 low
func (o *GFXMMU_Type) SetLUT960L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT960L.Reg, volatile.LoadUint32(&o.LUT960L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT960L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT960L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT960L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT960L.Reg, volatile.LoadUint32(&o.LUT960L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT960L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT960L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT960L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT960L.Reg, volatile.LoadUint32(&o.LUT960L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT960L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT960L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT960H: Graphic MMU LUT entry 960 high
func (o *GFXMMU_Type) SetLUT960H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT960H.Reg, volatile.LoadUint32(&o.LUT960H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT960H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT960H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT961L: Graphic MMU LUT entry 961 low
func (o *GFXMMU_Type) SetLUT961L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT961L.Reg, volatile.LoadUint32(&o.LUT961L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT961L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT961L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT961L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT961L.Reg, volatile.LoadUint32(&o.LUT961L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT961L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT961L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT961L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT961L.Reg, volatile.LoadUint32(&o.LUT961L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT961L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT961L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT961H: Graphic MMU LUT entry 961 high
func (o *GFXMMU_Type) SetLUT961H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT961H.Reg, volatile.LoadUint32(&o.LUT961H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT961H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT961H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT962L: Graphic MMU LUT entry 962 low
func (o *GFXMMU_Type) SetLUT962L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT962L.Reg, volatile.LoadUint32(&o.LUT962L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT962L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT962L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT962L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT962L.Reg, volatile.LoadUint32(&o.LUT962L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT962L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT962L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT962L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT962L.Reg, volatile.LoadUint32(&o.LUT962L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT962L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT962L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT962H: Graphic MMU LUT entry 962 high
func (o *GFXMMU_Type) SetLUT962H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT962H.Reg, volatile.LoadUint32(&o.LUT962H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT962H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT962H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT963L: Graphic MMU LUT entry 963 low
func (o *GFXMMU_Type) SetLUT963L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT963L.Reg, volatile.LoadUint32(&o.LUT963L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT963L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT963L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT963L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT963L.Reg, volatile.LoadUint32(&o.LUT963L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT963L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT963L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT963L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT963L.Reg, volatile.LoadUint32(&o.LUT963L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT963L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT963L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT963H: Graphic MMU LUT entry 963 high
func (o *GFXMMU_Type) SetLUT963H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT963H.Reg, volatile.LoadUint32(&o.LUT963H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT963H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT963H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT964L: Graphic MMU LUT entry 964 low
func (o *GFXMMU_Type) SetLUT964L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT964L.Reg, volatile.LoadUint32(&o.LUT964L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT964L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT964L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT964L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT964L.Reg, volatile.LoadUint32(&o.LUT964L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT964L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT964L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT964L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT964L.Reg, volatile.LoadUint32(&o.LUT964L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT964L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT964L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT964H: Graphic MMU LUT entry 964 high
func (o *GFXMMU_Type) SetLUT964H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT964H.Reg, volatile.LoadUint32(&o.LUT964H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT964H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT964H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT965L: Graphic MMU LUT entry 965 low
func (o *GFXMMU_Type) SetLUT965L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT965L.Reg, volatile.LoadUint32(&o.LUT965L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT965L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT965L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT965L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT965L.Reg, volatile.LoadUint32(&o.LUT965L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT965L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT965L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT965L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT965L.Reg, volatile.LoadUint32(&o.LUT965L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT965L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT965L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT965H: Graphic MMU LUT entry 965 high
func (o *GFXMMU_Type) SetLUT965H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT965H.Reg, volatile.LoadUint32(&o.LUT965H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT965H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT965H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT966L: Graphic MMU LUT entry 966 low
func (o *GFXMMU_Type) SetLUT966L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT966L.Reg, volatile.LoadUint32(&o.LUT966L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT966L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT966L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT966L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT966L.Reg, volatile.LoadUint32(&o.LUT966L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT966L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT966L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT966L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT966L.Reg, volatile.LoadUint32(&o.LUT966L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT966L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT966L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT966H: Graphic MMU LUT entry 966 high
func (o *GFXMMU_Type) SetLUT966H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT966H.Reg, volatile.LoadUint32(&o.LUT966H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT966H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT966H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT967L: Graphic MMU LUT entry 967 low
func (o *GFXMMU_Type) SetLUT967L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT967L.Reg, volatile.LoadUint32(&o.LUT967L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT967L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT967L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT967L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT967L.Reg, volatile.LoadUint32(&o.LUT967L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT967L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT967L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT967L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT967L.Reg, volatile.LoadUint32(&o.LUT967L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT967L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT967L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT967H: Graphic MMU LUT entry 967 high
func (o *GFXMMU_Type) SetLUT967H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT967H.Reg, volatile.LoadUint32(&o.LUT967H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT967H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT967H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT968L: Graphic MMU LUT entry 968 low
func (o *GFXMMU_Type) SetLUT968L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT968L.Reg, volatile.LoadUint32(&o.LUT968L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT968L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT968L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT968L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT968L.Reg, volatile.LoadUint32(&o.LUT968L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT968L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT968L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT968L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT968L.Reg, volatile.LoadUint32(&o.LUT968L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT968L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT968L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT968H: Graphic MMU LUT entry 968 high
func (o *GFXMMU_Type) SetLUT968H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT968H.Reg, volatile.LoadUint32(&o.LUT968H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT968H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT968H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT969L: Graphic MMU LUT entry 969 low
func (o *GFXMMU_Type) SetLUT969L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT969L.Reg, volatile.LoadUint32(&o.LUT969L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT969L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT969L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT969L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT969L.Reg, volatile.LoadUint32(&o.LUT969L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT969L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT969L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT969L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT969L.Reg, volatile.LoadUint32(&o.LUT969L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT969L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT969L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT969H: Graphic MMU LUT entry 969 high
func (o *GFXMMU_Type) SetLUT969H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT969H.Reg, volatile.LoadUint32(&o.LUT969H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT969H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT969H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT970L: Graphic MMU LUT entry 970 low
func (o *GFXMMU_Type) SetLUT970L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT970L.Reg, volatile.LoadUint32(&o.LUT970L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT970L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT970L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT970L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT970L.Reg, volatile.LoadUint32(&o.LUT970L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT970L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT970L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT970L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT970L.Reg, volatile.LoadUint32(&o.LUT970L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT970L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT970L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT970H: Graphic MMU LUT entry 970 high
func (o *GFXMMU_Type) SetLUT970H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT970H.Reg, volatile.LoadUint32(&o.LUT970H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT970H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT970H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT971L: Graphic MMU LUT entry 971 low
func (o *GFXMMU_Type) SetLUT971L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT971L.Reg, volatile.LoadUint32(&o.LUT971L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT971L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT971L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT971L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT971L.Reg, volatile.LoadUint32(&o.LUT971L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT971L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT971L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT971L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT971L.Reg, volatile.LoadUint32(&o.LUT971L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT971L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT971L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT971H: Graphic MMU LUT entry 971 high
func (o *GFXMMU_Type) SetLUT971H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT971H.Reg, volatile.LoadUint32(&o.LUT971H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT971H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT971H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT972L: Graphic MMU LUT entry 972 low
func (o *GFXMMU_Type) SetLUT972L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT972L.Reg, volatile.LoadUint32(&o.LUT972L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT972L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT972L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT972L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT972L.Reg, volatile.LoadUint32(&o.LUT972L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT972L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT972L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT972L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT972L.Reg, volatile.LoadUint32(&o.LUT972L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT972L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT972L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT972H: Graphic MMU LUT entry 972 high
func (o *GFXMMU_Type) SetLUT972H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT972H.Reg, volatile.LoadUint32(&o.LUT972H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT972H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT972H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT973L: Graphic MMU LUT entry 973 low
func (o *GFXMMU_Type) SetLUT973L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT973L.Reg, volatile.LoadUint32(&o.LUT973L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT973L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT973L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT973L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT973L.Reg, volatile.LoadUint32(&o.LUT973L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT973L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT973L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT973L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT973L.Reg, volatile.LoadUint32(&o.LUT973L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT973L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT973L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT973H: Graphic MMU LUT entry 973 high
func (o *GFXMMU_Type) SetLUT973H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT973H.Reg, volatile.LoadUint32(&o.LUT973H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT973H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT973H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT974L: Graphic MMU LUT entry 974 low
func (o *GFXMMU_Type) SetLUT974L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT974L.Reg, volatile.LoadUint32(&o.LUT974L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT974L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT974L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT974L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT974L.Reg, volatile.LoadUint32(&o.LUT974L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT974L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT974L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT974L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT974L.Reg, volatile.LoadUint32(&o.LUT974L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT974L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT974L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT974H: Graphic MMU LUT entry 974 high
func (o *GFXMMU_Type) SetLUT974H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT974H.Reg, volatile.LoadUint32(&o.LUT974H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT974H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT974H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT975L: Graphic MMU LUT entry 975 low
func (o *GFXMMU_Type) SetLUT975L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT975L.Reg, volatile.LoadUint32(&o.LUT975L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT975L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT975L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT975L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT975L.Reg, volatile.LoadUint32(&o.LUT975L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT975L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT975L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT975L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT975L.Reg, volatile.LoadUint32(&o.LUT975L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT975L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT975L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT975H: Graphic MMU LUT entry 975 high
func (o *GFXMMU_Type) SetLUT975H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT975H.Reg, volatile.LoadUint32(&o.LUT975H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT975H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT975H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT976L: Graphic MMU LUT entry 976 low
func (o *GFXMMU_Type) SetLUT976L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT976L.Reg, volatile.LoadUint32(&o.LUT976L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT976L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT976L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT976L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT976L.Reg, volatile.LoadUint32(&o.LUT976L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT976L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT976L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT976L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT976L.Reg, volatile.LoadUint32(&o.LUT976L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT976L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT976L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT976H: Graphic MMU LUT entry 976 high
func (o *GFXMMU_Type) SetLUT976H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT976H.Reg, volatile.LoadUint32(&o.LUT976H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT976H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT976H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT977L: Graphic MMU LUT entry 977 low
func (o *GFXMMU_Type) SetLUT977L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT977L.Reg, volatile.LoadUint32(&o.LUT977L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT977L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT977L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT977L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT977L.Reg, volatile.LoadUint32(&o.LUT977L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT977L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT977L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT977L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT977L.Reg, volatile.LoadUint32(&o.LUT977L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT977L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT977L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT977H: Graphic MMU LUT entry 977 high
func (o *GFXMMU_Type) SetLUT977H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT977H.Reg, volatile.LoadUint32(&o.LUT977H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT977H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT977H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT978L: Graphic MMU LUT entry 978 low
func (o *GFXMMU_Type) SetLUT978L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT978L.Reg, volatile.LoadUint32(&o.LUT978L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT978L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT978L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT978L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT978L.Reg, volatile.LoadUint32(&o.LUT978L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT978L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT978L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT978L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT978L.Reg, volatile.LoadUint32(&o.LUT978L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT978L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT978L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT978H: Graphic MMU LUT entry 978 high
func (o *GFXMMU_Type) SetLUT978H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT978H.Reg, volatile.LoadUint32(&o.LUT978H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT978H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT978H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT979L: Graphic MMU LUT entry 979 low
func (o *GFXMMU_Type) SetLUT979L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT979L.Reg, volatile.LoadUint32(&o.LUT979L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT979L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT979L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT979L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT979L.Reg, volatile.LoadUint32(&o.LUT979L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT979L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT979L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT979L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT979L.Reg, volatile.LoadUint32(&o.LUT979L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT979L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT979L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT979H: Graphic MMU LUT entry 979 high
func (o *GFXMMU_Type) SetLUT979H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT979H.Reg, volatile.LoadUint32(&o.LUT979H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT979H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT979H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT980L: Graphic MMU LUT entry 980 low
func (o *GFXMMU_Type) SetLUT980L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT980L.Reg, volatile.LoadUint32(&o.LUT980L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT980L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT980L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT980L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT980L.Reg, volatile.LoadUint32(&o.LUT980L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT980L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT980L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT980L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT980L.Reg, volatile.LoadUint32(&o.LUT980L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT980L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT980L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT980H: Graphic MMU LUT entry 980 high
func (o *GFXMMU_Type) SetLUT980H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT980H.Reg, volatile.LoadUint32(&o.LUT980H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT980H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT980H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT981L: Graphic MMU LUT entry 981 low
func (o *GFXMMU_Type) SetLUT981L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT981L.Reg, volatile.LoadUint32(&o.LUT981L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT981L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT981L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT981L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT981L.Reg, volatile.LoadUint32(&o.LUT981L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT981L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT981L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT981L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT981L.Reg, volatile.LoadUint32(&o.LUT981L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT981L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT981L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT981H: Graphic MMU LUT entry 981 high
func (o *GFXMMU_Type) SetLUT981H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT981H.Reg, volatile.LoadUint32(&o.LUT981H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT981H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT981H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT982L: Graphic MMU LUT entry 982 low
func (o *GFXMMU_Type) SetLUT982L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT982L.Reg, volatile.LoadUint32(&o.LUT982L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT982L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT982L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT982L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT982L.Reg, volatile.LoadUint32(&o.LUT982L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT982L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT982L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT982L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT982L.Reg, volatile.LoadUint32(&o.LUT982L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT982L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT982L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT982H: Graphic MMU LUT entry 982 high
func (o *GFXMMU_Type) SetLUT982H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT982H.Reg, volatile.LoadUint32(&o.LUT982H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT982H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT982H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT983L: Graphic MMU LUT entry 983 low
func (o *GFXMMU_Type) SetLUT983L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT983L.Reg, volatile.LoadUint32(&o.LUT983L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT983L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT983L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT983L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT983L.Reg, volatile.LoadUint32(&o.LUT983L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT983L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT983L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT983L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT983L.Reg, volatile.LoadUint32(&o.LUT983L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT983L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT983L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT983H: Graphic MMU LUT entry 983 high
func (o *GFXMMU_Type) SetLUT983H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT983H.Reg, volatile.LoadUint32(&o.LUT983H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT983H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT983H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT984L: Graphic MMU LUT entry 984 low
func (o *GFXMMU_Type) SetLUT984L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT984L.Reg, volatile.LoadUint32(&o.LUT984L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT984L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT984L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT984L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT984L.Reg, volatile.LoadUint32(&o.LUT984L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT984L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT984L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT984L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT984L.Reg, volatile.LoadUint32(&o.LUT984L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT984L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT984L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT984H: Graphic MMU LUT entry 984 high
func (o *GFXMMU_Type) SetLUT984H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT984H.Reg, volatile.LoadUint32(&o.LUT984H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT984H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT984H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT985L: Graphic MMU LUT entry 985 low
func (o *GFXMMU_Type) SetLUT985L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT985L.Reg, volatile.LoadUint32(&o.LUT985L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT985L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT985L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT985L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT985L.Reg, volatile.LoadUint32(&o.LUT985L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT985L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT985L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT985L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT985L.Reg, volatile.LoadUint32(&o.LUT985L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT985L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT985L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT985H: Graphic MMU LUT entry 985 high
func (o *GFXMMU_Type) SetLUT985H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT985H.Reg, volatile.LoadUint32(&o.LUT985H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT985H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT985H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT986L: Graphic MMU LUT entry 986 low
func (o *GFXMMU_Type) SetLUT986L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT986L.Reg, volatile.LoadUint32(&o.LUT986L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT986L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT986L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT986L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT986L.Reg, volatile.LoadUint32(&o.LUT986L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT986L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT986L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT986L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT986L.Reg, volatile.LoadUint32(&o.LUT986L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT986L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT986L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT986H: Graphic MMU LUT entry 986 high
func (o *GFXMMU_Type) SetLUT986H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT986H.Reg, volatile.LoadUint32(&o.LUT986H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT986H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT986H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT987L: Graphic MMU LUT entry 987 low
func (o *GFXMMU_Type) SetLUT987L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT987L.Reg, volatile.LoadUint32(&o.LUT987L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT987L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT987L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT987L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT987L.Reg, volatile.LoadUint32(&o.LUT987L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT987L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT987L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT987L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT987L.Reg, volatile.LoadUint32(&o.LUT987L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT987L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT987L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT987H: Graphic MMU LUT entry 987 high
func (o *GFXMMU_Type) SetLUT987H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT987H.Reg, volatile.LoadUint32(&o.LUT987H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT987H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT987H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT988L: Graphic MMU LUT entry 988 low
func (o *GFXMMU_Type) SetLUT988L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT988L.Reg, volatile.LoadUint32(&o.LUT988L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT988L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT988L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT988L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT988L.Reg, volatile.LoadUint32(&o.LUT988L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT988L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT988L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT988L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT988L.Reg, volatile.LoadUint32(&o.LUT988L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT988L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT988L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT988H: Graphic MMU LUT entry 988 high
func (o *GFXMMU_Type) SetLUT988H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT988H.Reg, volatile.LoadUint32(&o.LUT988H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT988H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT988H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT989L: Graphic MMU LUT entry 989 low
func (o *GFXMMU_Type) SetLUT989L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT989L.Reg, volatile.LoadUint32(&o.LUT989L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT989L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT989L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT989L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT989L.Reg, volatile.LoadUint32(&o.LUT989L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT989L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT989L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT989L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT989L.Reg, volatile.LoadUint32(&o.LUT989L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT989L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT989L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT989H: Graphic MMU LUT entry 989 high
func (o *GFXMMU_Type) SetLUT989H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT989H.Reg, volatile.LoadUint32(&o.LUT989H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT989H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT989H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT990L: Graphic MMU LUT entry 990 low
func (o *GFXMMU_Type) SetLUT990L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT990L.Reg, volatile.LoadUint32(&o.LUT990L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT990L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT990L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT990L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT990L.Reg, volatile.LoadUint32(&o.LUT990L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT990L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT990L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT990L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT990L.Reg, volatile.LoadUint32(&o.LUT990L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT990L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT990L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT990H: Graphic MMU LUT entry 990 high
func (o *GFXMMU_Type) SetLUT990H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT990H.Reg, volatile.LoadUint32(&o.LUT990H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT990H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT990H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT991L: Graphic MMU LUT entry 991 low
func (o *GFXMMU_Type) SetLUT991L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT991L.Reg, volatile.LoadUint32(&o.LUT991L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT991L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT991L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT991L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT991L.Reg, volatile.LoadUint32(&o.LUT991L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT991L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT991L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT991L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT991L.Reg, volatile.LoadUint32(&o.LUT991L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT991L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT991L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT991H: Graphic MMU LUT entry 991 high
func (o *GFXMMU_Type) SetLUT991H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT991H.Reg, volatile.LoadUint32(&o.LUT991H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT991H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT991H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT992L: Graphic MMU LUT entry 992 low
func (o *GFXMMU_Type) SetLUT992L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT992L.Reg, volatile.LoadUint32(&o.LUT992L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT992L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT992L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT992L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT992L.Reg, volatile.LoadUint32(&o.LUT992L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT992L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT992L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT992L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT992L.Reg, volatile.LoadUint32(&o.LUT992L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT992L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT992L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT992H: Graphic MMU LUT entry 992 high
func (o *GFXMMU_Type) SetLUT992H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT992H.Reg, volatile.LoadUint32(&o.LUT992H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT992H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT992H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT993L: Graphic MMU LUT entry 993 low
func (o *GFXMMU_Type) SetLUT993L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT993L.Reg, volatile.LoadUint32(&o.LUT993L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT993L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT993L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT993L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT993L.Reg, volatile.LoadUint32(&o.LUT993L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT993L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT993L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT993L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT993L.Reg, volatile.LoadUint32(&o.LUT993L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT993L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT993L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT993H: Graphic MMU LUT entry 993 high
func (o *GFXMMU_Type) SetLUT993H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT993H.Reg, volatile.LoadUint32(&o.LUT993H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT993H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT993H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT994L: Graphic MMU LUT entry 994 low
func (o *GFXMMU_Type) SetLUT994L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT994L.Reg, volatile.LoadUint32(&o.LUT994L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT994L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT994L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT994L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT994L.Reg, volatile.LoadUint32(&o.LUT994L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT994L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT994L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT994L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT994L.Reg, volatile.LoadUint32(&o.LUT994L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT994L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT994L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT994H: Graphic MMU LUT entry 994 high
func (o *GFXMMU_Type) SetLUT994H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT994H.Reg, volatile.LoadUint32(&o.LUT994H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT994H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT994H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT995L: Graphic MMU LUT entry 995 low
func (o *GFXMMU_Type) SetLUT995L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT995L.Reg, volatile.LoadUint32(&o.LUT995L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT995L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT995L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT995L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT995L.Reg, volatile.LoadUint32(&o.LUT995L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT995L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT995L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT995L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT995L.Reg, volatile.LoadUint32(&o.LUT995L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT995L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT995L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT995H: Graphic MMU LUT entry 995 high
func (o *GFXMMU_Type) SetLUT995H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT995H.Reg, volatile.LoadUint32(&o.LUT995H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT995H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT995H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT996L: Graphic MMU LUT entry 996 low
func (o *GFXMMU_Type) SetLUT996L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT996L.Reg, volatile.LoadUint32(&o.LUT996L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT996L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT996L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT996L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT996L.Reg, volatile.LoadUint32(&o.LUT996L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT996L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT996L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT996L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT996L.Reg, volatile.LoadUint32(&o.LUT996L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT996L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT996L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT996H: Graphic MMU LUT entry 996 high
func (o *GFXMMU_Type) SetLUT996H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT996H.Reg, volatile.LoadUint32(&o.LUT996H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT996H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT996H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT997L: Graphic MMU LUT entry 997 low
func (o *GFXMMU_Type) SetLUT997L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT997L.Reg, volatile.LoadUint32(&o.LUT997L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT997L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT997L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT997L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT997L.Reg, volatile.LoadUint32(&o.LUT997L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT997L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT997L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT997L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT997L.Reg, volatile.LoadUint32(&o.LUT997L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT997L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT997L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT997H: Graphic MMU LUT entry 997 high
func (o *GFXMMU_Type) SetLUT997H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT997H.Reg, volatile.LoadUint32(&o.LUT997H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT997H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT997H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT998L: Graphic MMU LUT entry 998 low
func (o *GFXMMU_Type) SetLUT998L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT998L.Reg, volatile.LoadUint32(&o.LUT998L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT998L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT998L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT998L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT998L.Reg, volatile.LoadUint32(&o.LUT998L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT998L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT998L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT998L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT998L.Reg, volatile.LoadUint32(&o.LUT998L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT998L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT998L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT998H: Graphic MMU LUT entry 998 high
func (o *GFXMMU_Type) SetLUT998H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT998H.Reg, volatile.LoadUint32(&o.LUT998H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT998H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT998H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT999L: Graphic MMU LUT entry 999 low
func (o *GFXMMU_Type) SetLUT999L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT999L.Reg, volatile.LoadUint32(&o.LUT999L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT999L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT999L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT999L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT999L.Reg, volatile.LoadUint32(&o.LUT999L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT999L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT999L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT999L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT999L.Reg, volatile.LoadUint32(&o.LUT999L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT999L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT999L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT999H: Graphic MMU LUT entry 999 high
func (o *GFXMMU_Type) SetLUT999H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT999H.Reg, volatile.LoadUint32(&o.LUT999H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT999H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT999H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1000L: Graphic MMU LUT entry 1000 low
func (o *GFXMMU_Type) SetLUT1000L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1000L.Reg, volatile.LoadUint32(&o.LUT1000L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1000L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1000L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1000L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1000L.Reg, volatile.LoadUint32(&o.LUT1000L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1000L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1000L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1000L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1000L.Reg, volatile.LoadUint32(&o.LUT1000L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1000L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1000L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1000H: Graphic MMU LUT entry 1000 high
func (o *GFXMMU_Type) SetLUT1000H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1000H.Reg, volatile.LoadUint32(&o.LUT1000H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1000H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1000H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1001L: Graphic MMU LUT entry 1001 low
func (o *GFXMMU_Type) SetLUT1001L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1001L.Reg, volatile.LoadUint32(&o.LUT1001L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1001L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1001L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1001L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1001L.Reg, volatile.LoadUint32(&o.LUT1001L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1001L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1001L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1001L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1001L.Reg, volatile.LoadUint32(&o.LUT1001L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1001L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1001L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1001H: Graphic MMU LUT entry 1001 high
func (o *GFXMMU_Type) SetLUT1001H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1001H.Reg, volatile.LoadUint32(&o.LUT1001H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1001H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1001H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1002L: Graphic MMU LUT entry 1002 low
func (o *GFXMMU_Type) SetLUT1002L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1002L.Reg, volatile.LoadUint32(&o.LUT1002L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1002L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1002L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1002L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1002L.Reg, volatile.LoadUint32(&o.LUT1002L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1002L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1002L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1002L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1002L.Reg, volatile.LoadUint32(&o.LUT1002L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1002L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1002L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1002H: Graphic MMU LUT entry 1002 high
func (o *GFXMMU_Type) SetLUT1002H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1002H.Reg, volatile.LoadUint32(&o.LUT1002H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1002H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1002H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1003L: Graphic MMU LUT entry 1003 low
func (o *GFXMMU_Type) SetLUT1003L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1003L.Reg, volatile.LoadUint32(&o.LUT1003L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1003L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1003L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1003L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1003L.Reg, volatile.LoadUint32(&o.LUT1003L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1003L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1003L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1003L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1003L.Reg, volatile.LoadUint32(&o.LUT1003L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1003L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1003L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1003H: Graphic MMU LUT entry 1003 high
func (o *GFXMMU_Type) SetLUT1003H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1003H.Reg, volatile.LoadUint32(&o.LUT1003H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1003H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1003H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1004L: Graphic MMU LUT entry 1004 low
func (o *GFXMMU_Type) SetLUT1004L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1004L.Reg, volatile.LoadUint32(&o.LUT1004L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1004L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1004L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1004L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1004L.Reg, volatile.LoadUint32(&o.LUT1004L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1004L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1004L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1004L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1004L.Reg, volatile.LoadUint32(&o.LUT1004L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1004L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1004L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1004H: Graphic MMU LUT entry 1004 high
func (o *GFXMMU_Type) SetLUT1004H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1004H.Reg, volatile.LoadUint32(&o.LUT1004H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1004H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1004H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1005L: Graphic MMU LUT entry 1005 low
func (o *GFXMMU_Type) SetLUT1005L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1005L.Reg, volatile.LoadUint32(&o.LUT1005L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1005L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1005L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1005L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1005L.Reg, volatile.LoadUint32(&o.LUT1005L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1005L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1005L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1005L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1005L.Reg, volatile.LoadUint32(&o.LUT1005L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1005L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1005L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1005H: Graphic MMU LUT entry 1005 high
func (o *GFXMMU_Type) SetLUT1005H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1005H.Reg, volatile.LoadUint32(&o.LUT1005H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1005H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1005H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1006L: Graphic MMU LUT entry 1006 low
func (o *GFXMMU_Type) SetLUT1006L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1006L.Reg, volatile.LoadUint32(&o.LUT1006L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1006L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1006L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1006L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1006L.Reg, volatile.LoadUint32(&o.LUT1006L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1006L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1006L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1006L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1006L.Reg, volatile.LoadUint32(&o.LUT1006L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1006L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1006L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1006H: Graphic MMU LUT entry 1006 high
func (o *GFXMMU_Type) SetLUT1006H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1006H.Reg, volatile.LoadUint32(&o.LUT1006H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1006H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1006H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1007L: Graphic MMU LUT entry 1007 low
func (o *GFXMMU_Type) SetLUT1007L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1007L.Reg, volatile.LoadUint32(&o.LUT1007L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1007L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1007L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1007L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1007L.Reg, volatile.LoadUint32(&o.LUT1007L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1007L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1007L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1007L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1007L.Reg, volatile.LoadUint32(&o.LUT1007L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1007L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1007L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1007H: Graphic MMU LUT entry 1007 high
func (o *GFXMMU_Type) SetLUT1007H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1007H.Reg, volatile.LoadUint32(&o.LUT1007H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1007H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1007H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1008L: Graphic MMU LUT entry 1008 low
func (o *GFXMMU_Type) SetLUT1008L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1008L.Reg, volatile.LoadUint32(&o.LUT1008L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1008L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1008L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1008L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1008L.Reg, volatile.LoadUint32(&o.LUT1008L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1008L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1008L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1008L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1008L.Reg, volatile.LoadUint32(&o.LUT1008L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1008L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1008L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1008H: Graphic MMU LUT entry 1008 high
func (o *GFXMMU_Type) SetLUT1008H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1008H.Reg, volatile.LoadUint32(&o.LUT1008H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1008H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1008H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1009L: Graphic MMU LUT entry 1009 low
func (o *GFXMMU_Type) SetLUT1009L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1009L.Reg, volatile.LoadUint32(&o.LUT1009L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1009L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1009L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1009L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1009L.Reg, volatile.LoadUint32(&o.LUT1009L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1009L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1009L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1009L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1009L.Reg, volatile.LoadUint32(&o.LUT1009L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1009L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1009L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1009H: Graphic MMU LUT entry 1009 high
func (o *GFXMMU_Type) SetLUT1009H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1009H.Reg, volatile.LoadUint32(&o.LUT1009H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1009H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1009H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1010L: Graphic MMU LUT entry 1010 low
func (o *GFXMMU_Type) SetLUT1010L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1010L.Reg, volatile.LoadUint32(&o.LUT1010L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1010L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1010L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1010L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1010L.Reg, volatile.LoadUint32(&o.LUT1010L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1010L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1010L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1010L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1010L.Reg, volatile.LoadUint32(&o.LUT1010L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1010L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1010L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1010H: Graphic MMU LUT entry 1010 high
func (o *GFXMMU_Type) SetLUT1010H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1010H.Reg, volatile.LoadUint32(&o.LUT1010H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1010H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1010H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1011L: Graphic MMU LUT entry 1011 low
func (o *GFXMMU_Type) SetLUT1011L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1011L.Reg, volatile.LoadUint32(&o.LUT1011L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1011L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1011L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1011L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1011L.Reg, volatile.LoadUint32(&o.LUT1011L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1011L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1011L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1011L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1011L.Reg, volatile.LoadUint32(&o.LUT1011L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1011L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1011L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1011H: Graphic MMU LUT entry 1011 high
func (o *GFXMMU_Type) SetLUT1011H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1011H.Reg, volatile.LoadUint32(&o.LUT1011H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1011H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1011H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1012L: Graphic MMU LUT entry 1012 low
func (o *GFXMMU_Type) SetLUT1012L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1012L.Reg, volatile.LoadUint32(&o.LUT1012L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1012L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1012L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1012L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1012L.Reg, volatile.LoadUint32(&o.LUT1012L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1012L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1012L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1012L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1012L.Reg, volatile.LoadUint32(&o.LUT1012L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1012L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1012L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1012H: Graphic MMU LUT entry 1012 high
func (o *GFXMMU_Type) SetLUT1012H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1012H.Reg, volatile.LoadUint32(&o.LUT1012H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1012H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1012H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1013L: Graphic MMU LUT entry 1013 low
func (o *GFXMMU_Type) SetLUT1013L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1013L.Reg, volatile.LoadUint32(&o.LUT1013L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1013L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1013L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1013L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1013L.Reg, volatile.LoadUint32(&o.LUT1013L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1013L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1013L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1013L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1013L.Reg, volatile.LoadUint32(&o.LUT1013L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1013L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1013L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1013H: Graphic MMU LUT entry 1013 high
func (o *GFXMMU_Type) SetLUT1013H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1013H.Reg, volatile.LoadUint32(&o.LUT1013H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1013H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1013H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1014L: Graphic MMU LUT entry 1014 low
func (o *GFXMMU_Type) SetLUT1014L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1014L.Reg, volatile.LoadUint32(&o.LUT1014L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1014L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1014L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1014L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1014L.Reg, volatile.LoadUint32(&o.LUT1014L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1014L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1014L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1014L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1014L.Reg, volatile.LoadUint32(&o.LUT1014L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1014L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1014L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1014H: Graphic MMU LUT entry 1014 high
func (o *GFXMMU_Type) SetLUT1014H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1014H.Reg, volatile.LoadUint32(&o.LUT1014H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1014H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1014H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1015L: Graphic MMU LUT entry 1015 low
func (o *GFXMMU_Type) SetLUT1015L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1015L.Reg, volatile.LoadUint32(&o.LUT1015L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1015L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1015L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1015L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1015L.Reg, volatile.LoadUint32(&o.LUT1015L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1015L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1015L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1015L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1015L.Reg, volatile.LoadUint32(&o.LUT1015L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1015L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1015L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1015H: Graphic MMU LUT entry 1015 high
func (o *GFXMMU_Type) SetLUT1015H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1015H.Reg, volatile.LoadUint32(&o.LUT1015H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1015H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1015H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1016L: Graphic MMU LUT entry 1016 low
func (o *GFXMMU_Type) SetLUT1016L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1016L.Reg, volatile.LoadUint32(&o.LUT1016L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1016L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1016L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1016L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1016L.Reg, volatile.LoadUint32(&o.LUT1016L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1016L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1016L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1016L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1016L.Reg, volatile.LoadUint32(&o.LUT1016L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1016L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1016L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1016H: Graphic MMU LUT entry 1016 high
func (o *GFXMMU_Type) SetLUT1016H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1016H.Reg, volatile.LoadUint32(&o.LUT1016H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1016H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1016H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1017L: Graphic MMU LUT entry 1017 low
func (o *GFXMMU_Type) SetLUT1017L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1017L.Reg, volatile.LoadUint32(&o.LUT1017L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1017L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1017L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1017L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1017L.Reg, volatile.LoadUint32(&o.LUT1017L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1017L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1017L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1017L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1017L.Reg, volatile.LoadUint32(&o.LUT1017L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1017L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1017L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1017H: Graphic MMU LUT entry 1017 high
func (o *GFXMMU_Type) SetLUT1017H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1017H.Reg, volatile.LoadUint32(&o.LUT1017H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1017H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1017H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1018L: Graphic MMU LUT entry 1018 low
func (o *GFXMMU_Type) SetLUT1018L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1018L.Reg, volatile.LoadUint32(&o.LUT1018L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1018L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1018L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1018L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1018L.Reg, volatile.LoadUint32(&o.LUT1018L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1018L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1018L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1018L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1018L.Reg, volatile.LoadUint32(&o.LUT1018L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1018L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1018L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1018H: Graphic MMU LUT entry 1018 high
func (o *GFXMMU_Type) SetLUT1018H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1018H.Reg, volatile.LoadUint32(&o.LUT1018H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1018H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1018H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1019L: Graphic MMU LUT entry 1019 low
func (o *GFXMMU_Type) SetLUT1019L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1019L.Reg, volatile.LoadUint32(&o.LUT1019L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1019L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1019L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1019L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1019L.Reg, volatile.LoadUint32(&o.LUT1019L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1019L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1019L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1019L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1019L.Reg, volatile.LoadUint32(&o.LUT1019L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1019L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1019L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1019H: Graphic MMU LUT entry 1019 high
func (o *GFXMMU_Type) SetLUT1019H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1019H.Reg, volatile.LoadUint32(&o.LUT1019H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1019H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1019H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1020L: Graphic MMU LUT entry 1020 low
func (o *GFXMMU_Type) SetLUT1020L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1020L.Reg, volatile.LoadUint32(&o.LUT1020L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1020L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1020L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1020L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1020L.Reg, volatile.LoadUint32(&o.LUT1020L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1020L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1020L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1020L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1020L.Reg, volatile.LoadUint32(&o.LUT1020L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1020L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1020L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1020H: Graphic MMU LUT entry 1020 high
func (o *GFXMMU_Type) SetLUT1020H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1020H.Reg, volatile.LoadUint32(&o.LUT1020H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1020H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1020H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1021L: Graphic MMU LUT entry 1021 low
func (o *GFXMMU_Type) SetLUT1021L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1021L.Reg, volatile.LoadUint32(&o.LUT1021L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1021L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1021L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1021L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1021L.Reg, volatile.LoadUint32(&o.LUT1021L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1021L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1021L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1021L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1021L.Reg, volatile.LoadUint32(&o.LUT1021L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1021L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1021L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1021H: Graphic MMU LUT entry 1021 high
func (o *GFXMMU_Type) SetLUT1021H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1021H.Reg, volatile.LoadUint32(&o.LUT1021H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1021H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1021H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1022L: Graphic MMU LUT entry 1022 low
func (o *GFXMMU_Type) SetLUT1022L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1022L.Reg, volatile.LoadUint32(&o.LUT1022L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1022L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1022L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1022L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1022L.Reg, volatile.LoadUint32(&o.LUT1022L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1022L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1022L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1022L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1022L.Reg, volatile.LoadUint32(&o.LUT1022L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1022L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1022L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1022H: Graphic MMU LUT entry 1022 high
func (o *GFXMMU_Type) SetLUT1022H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1022H.Reg, volatile.LoadUint32(&o.LUT1022H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1022H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1022H.Reg) & 0x3ffff0) >> 4
}

// GFXMMU.LUT1023L: Graphic MMU LUT entry 1023 low
func (o *GFXMMU_Type) SetLUT1023L_EN(value uint32) {
	volatile.StoreUint32(&o.LUT1023L.Reg, volatile.LoadUint32(&o.LUT1023L.Reg)&^(0x1)|value)
}
func (o *GFXMMU_Type) GetLUT1023L_EN() uint32 {
	return volatile.LoadUint32(&o.LUT1023L.Reg) & 0x1
}
func (o *GFXMMU_Type) SetLUT1023L_FVB(value uint32) {
	volatile.StoreUint32(&o.LUT1023L.Reg, volatile.LoadUint32(&o.LUT1023L.Reg)&^(0xff00)|value<<8)
}
func (o *GFXMMU_Type) GetLUT1023L_FVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1023L.Reg) & 0xff00) >> 8
}
func (o *GFXMMU_Type) SetLUT1023L_LVB(value uint32) {
	volatile.StoreUint32(&o.LUT1023L.Reg, volatile.LoadUint32(&o.LUT1023L.Reg)&^(0xff0000)|value<<16)
}
func (o *GFXMMU_Type) GetLUT1023L_LVB() uint32 {
	return (volatile.LoadUint32(&o.LUT1023L.Reg) & 0xff0000) >> 16
}

// GFXMMU.LUT1023H: Graphic MMU LUT entry 1023 high
func (o *GFXMMU_Type) SetLUT1023H_LO(value uint32) {
	volatile.StoreUint32(&o.LUT1023H.Reg, volatile.LoadUint32(&o.LUT1023H.Reg)&^(0x3ffff0)|value<<4)
}
func (o *GFXMMU_Type) GetLUT1023H_LO() uint32 {
	return (volatile.LoadUint32(&o.LUT1023H.Reg) & 0x3ffff0) >> 4
}

// OctoSPI IO Manager
type OCTOSPIM_Type struct {
	_    [4]byte
	P1CR volatile.Register32 // 0x4
	P2CR volatile.Register32 // 0x8
}

// OCTOSPIM.P1CR: OctoSPI IO Manager Port 1 Configuration Register
func (o *OCTOSPIM_Type) SetP1CR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x1)|value)
}
func (o *OCTOSPIM_Type) GetP1CR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.P1CR.Reg) & 0x1
}
func (o *OCTOSPIM_Type) SetP1CR_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x2)|value<<1)
}
func (o *OCTOSPIM_Type) GetP1CR_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x2) >> 1
}
func (o *OCTOSPIM_Type) SetP1CR_DQSEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x10)|value<<4)
}
func (o *OCTOSPIM_Type) GetP1CR_DQSEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x10) >> 4
}
func (o *OCTOSPIM_Type) SetP1CR_DQSSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x20)|value<<5)
}
func (o *OCTOSPIM_Type) GetP1CR_DQSSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x20) >> 5
}
func (o *OCTOSPIM_Type) SetP1CR_NCSEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x100)|value<<8)
}
func (o *OCTOSPIM_Type) GetP1CR_NCSEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x100) >> 8
}
func (o *OCTOSPIM_Type) SetP1CR_NCSSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x200)|value<<9)
}
func (o *OCTOSPIM_Type) GetP1CR_NCSSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x200) >> 9
}
func (o *OCTOSPIM_Type) SetP1CR_IOLEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x10000)|value<<16)
}
func (o *OCTOSPIM_Type) GetP1CR_IOLEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x10000) >> 16
}
func (o *OCTOSPIM_Type) SetP1CR_IOLSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x60000)|value<<17)
}
func (o *OCTOSPIM_Type) GetP1CR_IOLSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x60000) >> 17
}
func (o *OCTOSPIM_Type) SetP1CR_IOHEN(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x1000000)|value<<24)
}
func (o *OCTOSPIM_Type) GetP1CR_IOHEN() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x1000000) >> 24
}
func (o *OCTOSPIM_Type) SetP1CR_IOHSRC(value uint32) {
	volatile.StoreUint32(&o.P1CR.Reg, volatile.LoadUint32(&o.P1CR.Reg)&^(0x6000000)|value<<25)
}
func (o *OCTOSPIM_Type) GetP1CR_IOHSRC() uint32 {
	return (volatile.LoadUint32(&o.P1CR.Reg) & 0x6000000) >> 25
}

// OCTOSPIM.P2CR: OctoSPI IO Manager Port 2 Configuration Register
func (o *OCTOSPIM_Type) SetP2CR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x1)|value)
}
func (o *OCTOSPIM_Type) GetP2CR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.P2CR.Reg) & 0x1
}
func (o *OCTOSPIM_Type) SetP2CR_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x2)|value<<1)
}
func (o *OCTOSPIM_Type) GetP2CR_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x2) >> 1
}
func (o *OCTOSPIM_Type) SetP2CR_DQSEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x10)|value<<4)
}
func (o *OCTOSPIM_Type) GetP2CR_DQSEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x10) >> 4
}
func (o *OCTOSPIM_Type) SetP2CR_DQSSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x20)|value<<5)
}
func (o *OCTOSPIM_Type) GetP2CR_DQSSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x20) >> 5
}
func (o *OCTOSPIM_Type) SetP2CR_NCSEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x100)|value<<8)
}
func (o *OCTOSPIM_Type) GetP2CR_NCSEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x100) >> 8
}
func (o *OCTOSPIM_Type) SetP2CR_NCSSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x200)|value<<9)
}
func (o *OCTOSPIM_Type) GetP2CR_NCSSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x200) >> 9
}
func (o *OCTOSPIM_Type) SetP2CR_IOLEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x10000)|value<<16)
}
func (o *OCTOSPIM_Type) GetP2CR_IOLEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x10000) >> 16
}
func (o *OCTOSPIM_Type) SetP2CR_IOLSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x60000)|value<<17)
}
func (o *OCTOSPIM_Type) GetP2CR_IOLSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x60000) >> 17
}
func (o *OCTOSPIM_Type) SetP2CR_IOHEN(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x1000000)|value<<24)
}
func (o *OCTOSPIM_Type) GetP2CR_IOHEN() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x1000000) >> 24
}
func (o *OCTOSPIM_Type) SetP2CR_IOHSRC(value uint32) {
	volatile.StoreUint32(&o.P2CR.Reg, volatile.LoadUint32(&o.P2CR.Reg)&^(0x6000000)|value<<25)
}
func (o *OCTOSPIM_Type) GetP2CR_IOHSRC() uint32 {
	return (volatile.LoadUint32(&o.P2CR.Reg) & 0x6000000) >> 25
}

// Floting point unit
type FPU_Type struct {
	FPCCR volatile.Register32 // 0x0
	FPCAR volatile.Register32 // 0x4
	FPSCR volatile.Register32 // 0x8
}

// FPU.FPCCR: Floating-point context control register
func (o *FPU_Type) SetFPCCR_LSPACT(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetFPCCR_LSPACT() uint32 {
	return volatile.LoadUint32(&o.FPCCR.Reg) & 0x1
}
func (o *FPU_Type) SetFPCCR_USER(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetFPCCR_USER() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetFPCCR_THREAD(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetFPCCR_THREAD() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetFPCCR_HFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetFPCCR_HFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetFPCCR_MMRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetFPCCR_MMRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x20) >> 5
}
func (o *FPU_Type) SetFPCCR_BFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40)|value<<6)
}
func (o *FPU_Type) GetFPCCR_BFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40) >> 6
}
func (o *FPU_Type) SetFPCCR_MONRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x100)|value<<8)
}
func (o *FPU_Type) GetFPCCR_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x100) >> 8
}
func (o *FPU_Type) SetFPCCR_LSPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FPU_Type) GetFPCCR_LSPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40000000) >> 30
}
func (o *FPU_Type) SetFPCCR_ASPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FPU_Type) GetFPCCR_ASPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x80000000) >> 31
}

// FPU.FPCAR: Floating-point context address register
func (o *FPU_Type) SetFPCAR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.FPCAR.Reg, volatile.LoadUint32(&o.FPCAR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *FPU_Type) GetFPCAR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.FPCAR.Reg) & 0xfffffff8) >> 3
}

// FPU.FPSCR: Floating-point status control register
func (o *FPU_Type) SetFPSCR_IOC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetFPSCR_IOC() uint32 {
	return volatile.LoadUint32(&o.FPSCR.Reg) & 0x1
}
func (o *FPU_Type) SetFPSCR_DZC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetFPSCR_DZC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetFPSCR_OFC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x4)|value<<2)
}
func (o *FPU_Type) GetFPSCR_OFC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x4) >> 2
}
func (o *FPU_Type) SetFPSCR_UFC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetFPSCR_UFC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetFPSCR_IXC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetFPSCR_IXC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetFPSCR_IDC(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x80)|value<<7)
}
func (o *FPU_Type) GetFPSCR_IDC() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x80) >> 7
}
func (o *FPU_Type) SetFPSCR_RMode(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *FPU_Type) GetFPSCR_RMode() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0xc00000) >> 22
}
func (o *FPU_Type) SetFPSCR_FZ(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *FPU_Type) GetFPSCR_FZ() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x1000000) >> 24
}
func (o *FPU_Type) SetFPSCR_DN(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *FPU_Type) GetFPSCR_DN() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x2000000) >> 25
}
func (o *FPU_Type) SetFPSCR_AHP(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *FPU_Type) GetFPSCR_AHP() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x4000000) >> 26
}
func (o *FPU_Type) SetFPSCR_V(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x10000000)|value<<28)
}
func (o *FPU_Type) GetFPSCR_V() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x10000000) >> 28
}
func (o *FPU_Type) SetFPSCR_C(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *FPU_Type) GetFPSCR_C() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x20000000) >> 29
}
func (o *FPU_Type) SetFPSCR_Z(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FPU_Type) GetFPSCR_Z() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x40000000) >> 30
}
func (o *FPU_Type) SetFPSCR_N(value uint32) {
	volatile.StoreUint32(&o.FPSCR.Reg, volatile.LoadUint32(&o.FPSCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FPU_Type) GetFPSCR_N() uint32 {
	return (volatile.LoadUint32(&o.FPSCR.Reg) & 0x80000000) >> 31
}

// Memory protection unit
type MPU_Type struct {
	TYPER volatile.Register32 // 0x0
	CTRL  volatile.Register32 // 0x4
	RNR   volatile.Register32 // 0x8
	RBAR  volatile.Register32 // 0xC
	RASR  volatile.Register32 // 0x10
}

// MPU.TYPER: MPU type register
func (o *MPU_Type) SetTYPER_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPER_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPER.Reg) & 0x1
}
func (o *MPU_Type) SetTYPER_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPER_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPER_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPER_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU control register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU region number register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU region base address register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU region attribute and size register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x3e)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x3e) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// SysTick timer
type STK_Type struct {
	CTRL  volatile.Register32 // 0x0
	LOAD  volatile.Register32 // 0x4
	VAL   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// STK.CTRL: SysTick control and status register
func (o *STK_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *STK_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *STK_Type) SetCTRL_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *STK_Type) GetCTRL_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *STK_Type) SetCTRL_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *STK_Type) GetCTRL_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *STK_Type) SetCTRL_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *STK_Type) GetCTRL_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}

// STK.LOAD: SysTick reload value register
func (o *STK_Type) SetLOAD_RELOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, volatile.LoadUint32(&o.LOAD.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetLOAD_RELOAD() uint32 {
	return volatile.LoadUint32(&o.LOAD.Reg) & 0xffffff
}

// STK.VAL: SysTick current value register
func (o *STK_Type) SetVAL_CURRENT(value uint32) {
	volatile.StoreUint32(&o.VAL.Reg, volatile.LoadUint32(&o.VAL.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetVAL_CURRENT() uint32 {
	return volatile.LoadUint32(&o.VAL.Reg) & 0xffffff
}

// STK.CALIB: SysTick calibration value register
func (o *STK_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *STK_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *STK_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *STK_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *STK_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// System control block
type SCB_Type struct {
	CPUID                volatile.Register32 // 0x0
	ICSR                 volatile.Register32 // 0x4
	VTOR                 volatile.Register32 // 0x8
	AIRCR                volatile.Register32 // 0xC
	SCR                  volatile.Register32 // 0x10
	CCR                  volatile.Register32 // 0x14
	SHPR1                volatile.Register32 // 0x18
	SHPR2                volatile.Register32 // 0x1C
	SHPR3                volatile.Register32 // 0x20
	SHCSR                volatile.Register32 // 0x24
	CFSR_UFSR_BFSR_MMFSR volatile.Register32 // 0x28
	HFSR                 volatile.Register32 // 0x2C
	_                    [4]byte
	MMFAR                volatile.Register32 // 0x34
	BFAR                 volatile.Register32 // 0x38
	AFSR                 volatile.Register32 // 0x3C
}

// SCB.CPUID: CPUID base register
func (o *SCB_Type) SetCPUID_Revision(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCPUID_Revision() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SCB_Type) SetCPUID_PartNo(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SCB_Type) GetCPUID_PartNo() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SCB_Type) SetCPUID_Constant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCPUID_Constant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCPUID_Variant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCPUID_Variant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCPUID_Implementer(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetCPUID_Implementer() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SCB.ICSR: Interrupt control and state register
func (o *SCB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SCB_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x7f000)|value<<12)
}
func (o *SCB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x7f000) >> 12
}
func (o *SCB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SCB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SCB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SCB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SCB.VTOR: Vector table offset register
func (o *SCB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0x3ffffe00)|value<<9)
}
func (o *SCB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0x3ffffe00) >> 9
}

// SCB.AIRCR: Application interrupt and reset control register
func (o *SCB_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SCB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SCB_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SCB_Type) SetAIRCR_ENDIANESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetAIRCR_ENDIANESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetAIRCR_VECTKEYSTAT(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCB_Type) GetAIRCR_VECTKEYSTAT() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SCB.SCR: System control register
func (o *SCB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetSCR_SEVEONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetSCR_SEVEONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SCB.CCR: Configuration and control register
func (o *SCB_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SCB_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCCR_UNALIGN__TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCCR_UNALIGN__TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}

// SCB.SHPR1: System handler priority registers
func (o *SCB_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SCB_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SCB_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SCB_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SCB_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SCB.SHPR2: System handler priority registers
func (o *SCB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SCB.SHPR3: System handler priority registers
func (o *SCB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SCB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SCB.SHCSR: System handler control and state register
func (o *SCB_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SCB_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SCB_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SCB.CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x20)|value<<5)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x20) >> 5
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x40000) >> 18
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x80000) >> 19
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x1000000) >> 24
}
func (o *SCB_Type) SetCFSR_UFSR_BFSR_MMFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg, volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetCFSR_UFSR_BFSR_MMFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR_UFSR_BFSR_MMFSR.Reg) & 0x2000000) >> 25
}

// SCB.HFSR: Hard fault status register
func (o *SCB_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetHFSR_DEBUG_VT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetHFSR_DEBUG_VT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SCB.MMFAR: Memory management fault address register
func (o *SCB_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SCB_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SCB.BFAR: Bus fault address register
func (o *SCB_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SCB_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SCB.AFSR: Auxiliary fault status register
func (o *SCB_Type) SetAFSR(value uint32) {
	volatile.StoreUint32(&o.AFSR.Reg, value)
}
func (o *SCB_Type) GetAFSR() uint32 {
	return volatile.LoadUint32(&o.AFSR.Reg)
}

// Constants for DAC: Digital-to-analog converter
const (
	// CR: control register
	// Position of EN1 field.
	DAC_CR_EN1_Pos = 0x0
	// Bit mask of EN1 field.
	DAC_CR_EN1_Msk = 0x1
	// Bit EN1.
	DAC_CR_EN1 = 0x1
	// Position of TEN1 field.
	DAC_CR_TEN1_Pos = 0x2
	// Bit mask of TEN1 field.
	DAC_CR_TEN1_Msk = 0x4
	// Bit TEN1.
	DAC_CR_TEN1 = 0x4
	// Position of TSEL1 field.
	DAC_CR_TSEL1_Pos = 0x3
	// Bit mask of TSEL1 field.
	DAC_CR_TSEL1_Msk = 0x38
	// Position of WAVE1 field.
	DAC_CR_WAVE1_Pos = 0x6
	// Bit mask of WAVE1 field.
	DAC_CR_WAVE1_Msk = 0xc0
	// Position of MAMP1 field.
	DAC_CR_MAMP1_Pos = 0x8
	// Bit mask of MAMP1 field.
	DAC_CR_MAMP1_Msk = 0xf00
	// Position of DMAEN1 field.
	DAC_CR_DMAEN1_Pos = 0xc
	// Bit mask of DMAEN1 field.
	DAC_CR_DMAEN1_Msk = 0x1000
	// Bit DMAEN1.
	DAC_CR_DMAEN1 = 0x1000
	// Position of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Pos = 0xd
	// Bit mask of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Msk = 0x2000
	// Bit DMAUDRIE1.
	DAC_CR_DMAUDRIE1 = 0x2000
	// Position of CEN1 field.
	DAC_CR_CEN1_Pos = 0xe
	// Bit mask of CEN1 field.
	DAC_CR_CEN1_Msk = 0x4000
	// Bit CEN1.
	DAC_CR_CEN1 = 0x4000
	// Position of EN2 field.
	DAC_CR_EN2_Pos = 0x10
	// Bit mask of EN2 field.
	DAC_CR_EN2_Msk = 0x10000
	// Bit EN2.
	DAC_CR_EN2 = 0x10000
	// Position of TEN2 field.
	DAC_CR_TEN2_Pos = 0x12
	// Bit mask of TEN2 field.
	DAC_CR_TEN2_Msk = 0x40000
	// Bit TEN2.
	DAC_CR_TEN2 = 0x40000
	// Position of TSEL2 field.
	DAC_CR_TSEL2_Pos = 0x13
	// Bit mask of TSEL2 field.
	DAC_CR_TSEL2_Msk = 0x380000
	// Position of WAVE2 field.
	DAC_CR_WAVE2_Pos = 0x16
	// Bit mask of WAVE2 field.
	DAC_CR_WAVE2_Msk = 0xc00000
	// Position of MAMP2 field.
	DAC_CR_MAMP2_Pos = 0x18
	// Bit mask of MAMP2 field.
	DAC_CR_MAMP2_Msk = 0xf000000
	// Position of DMAEN2 field.
	DAC_CR_DMAEN2_Pos = 0x1c
	// Bit mask of DMAEN2 field.
	DAC_CR_DMAEN2_Msk = 0x10000000
	// Bit DMAEN2.
	DAC_CR_DMAEN2 = 0x10000000
	// Position of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Pos = 0x1d
	// Bit mask of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Msk = 0x20000000
	// Bit DMAUDRIE2.
	DAC_CR_DMAUDRIE2 = 0x20000000
	// Position of CEN2 field.
	DAC_CR_CEN2_Pos = 0x1e
	// Bit mask of CEN2 field.
	DAC_CR_CEN2_Msk = 0x40000000
	// Bit CEN2.
	DAC_CR_CEN2 = 0x40000000

	// SWTRIGR: software trigger register
	// Position of SWTRIG1 field.
	DAC_SWTRIGR_SWTRIG1_Pos = 0x0
	// Bit mask of SWTRIG1 field.
	DAC_SWTRIGR_SWTRIG1_Msk = 0x1
	// Bit SWTRIG1.
	DAC_SWTRIGR_SWTRIG1 = 0x1
	// Position of SWTRIG2 field.
	DAC_SWTRIGR_SWTRIG2_Pos = 0x1
	// Bit mask of SWTRIG2 field.
	DAC_SWTRIGR_SWTRIG2_Msk = 0x2
	// Bit SWTRIG2.
	DAC_SWTRIGR_SWTRIG2 = 0x2

	// DHR12R1: channel1 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Msk = 0xfff

	// DHR12L1: channel1 12-bit left-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Msk = 0xfff0

	// DHR8R1: channel1 8-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Msk = 0xff

	// DHR12R2: channel2 12-bit right aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Msk = 0xfff

	// DHR12L2: channel2 12-bit left aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Pos = 0x4
	// Bit mask of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Msk = 0xfff0

	// DHR8R2: channel2 8-bit right-aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Msk = 0xff

	// DHR12RD: Dual DAC 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Msk = 0xfff
	// Position of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Pos = 0x10
	// Bit mask of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Msk = 0xfff0000

	// DHR12LD: DUAL DAC 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Msk = 0xfff0
	// Position of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Pos = 0x14
	// Bit mask of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Msk = 0xfff00000

	// DHR8RD: DUAL DAC 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Msk = 0xff
	// Position of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Pos = 0x8
	// Bit mask of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Msk = 0xff00

	// DOR1: channel1 data output register
	// Position of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Pos = 0x0
	// Bit mask of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Msk = 0xfff

	// DOR2: channel2 data output register
	// Position of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Pos = 0x0
	// Bit mask of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Msk = 0xfff

	// SR: status register
	// Position of DMAUDR1 field.
	DAC_SR_DMAUDR1_Pos = 0xd
	// Bit mask of DMAUDR1 field.
	DAC_SR_DMAUDR1_Msk = 0x2000
	// Bit DMAUDR1.
	DAC_SR_DMAUDR1 = 0x2000
	// Position of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Pos = 0xe
	// Bit mask of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Msk = 0x4000
	// Bit CAL_FLAG1.
	DAC_SR_CAL_FLAG1 = 0x4000
	// Position of BWST1 field.
	DAC_SR_BWST1_Pos = 0xf
	// Bit mask of BWST1 field.
	DAC_SR_BWST1_Msk = 0x8000
	// Bit BWST1.
	DAC_SR_BWST1 = 0x8000
	// Position of DMAUDR2 field.
	DAC_SR_DMAUDR2_Pos = 0x1d
	// Bit mask of DMAUDR2 field.
	DAC_SR_DMAUDR2_Msk = 0x20000000
	// Bit DMAUDR2.
	DAC_SR_DMAUDR2 = 0x20000000
	// Position of CAL_FLAG2 field.
	DAC_SR_CAL_FLAG2_Pos = 0x1e
	// Bit mask of CAL_FLAG2 field.
	DAC_SR_CAL_FLAG2_Msk = 0x40000000
	// Bit CAL_FLAG2.
	DAC_SR_CAL_FLAG2 = 0x40000000
	// Position of BWST2 field.
	DAC_SR_BWST2_Pos = 0x1f
	// Bit mask of BWST2 field.
	DAC_SR_BWST2_Msk = 0x80000000
	// Bit BWST2.
	DAC_SR_BWST2 = 0x80000000

	// CCR: calibration control register
	// Position of OTRIM1 field.
	DAC_CCR_OTRIM1_Pos = 0x0
	// Bit mask of OTRIM1 field.
	DAC_CCR_OTRIM1_Msk = 0x1f
	// Position of OTRIM2 field.
	DAC_CCR_OTRIM2_Pos = 0x10
	// Bit mask of OTRIM2 field.
	DAC_CCR_OTRIM2_Msk = 0x1f0000

	// MCR: mode control register
	// Position of MODE1 field.
	DAC_MCR_MODE1_Pos = 0x0
	// Bit mask of MODE1 field.
	DAC_MCR_MODE1_Msk = 0x7
	// Position of MODE2 field.
	DAC_MCR_MODE2_Pos = 0x10
	// Bit mask of MODE2 field.
	DAC_MCR_MODE2_Msk = 0x70000

	// SHSR1: Sample and Hold sample time register 1
	// Position of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Pos = 0x0
	// Bit mask of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Msk = 0x3ff

	// SHSR2: Sample and Hold sample time register 2
	// Position of TSAMPLE2 field.
	DAC_SHSR2_TSAMPLE2_Pos = 0x0
	// Bit mask of TSAMPLE2 field.
	DAC_SHSR2_TSAMPLE2_Msk = 0x3ff

	// SHHR: Sample and Hold hold time register
	// Position of THOLD1 field.
	DAC_SHHR_THOLD1_Pos = 0x0
	// Bit mask of THOLD1 field.
	DAC_SHHR_THOLD1_Msk = 0x3ff
	// Position of THOLD2 field.
	DAC_SHHR_THOLD2_Pos = 0x10
	// Bit mask of THOLD2 field.
	DAC_SHHR_THOLD2_Msk = 0x3ff0000

	// SHRR: Sample and Hold refresh time register
	// Position of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Pos = 0x0
	// Bit mask of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Msk = 0xff
	// Position of TREFRESH2 field.
	DAC_SHRR_TREFRESH2_Pos = 0x10
	// Bit mask of TREFRESH2 field.
	DAC_SHRR_TREFRESH2_Msk = 0xff0000
)

// Constants for DMA1: Direct memory access controller
const (
	// ISR: interrupt status register
	// Position of TEIF7 field.
	DMA_ISR_TEIF7_Pos = 0x1b
	// Bit mask of TEIF7 field.
	DMA_ISR_TEIF7_Msk = 0x8000000
	// Bit TEIF7.
	DMA_ISR_TEIF7 = 0x8000000
	// No transfer error
	DMA_ISR_TEIF7_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF7_Error = 0x1
	// Position of HTIF7 field.
	DMA_ISR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA_ISR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA_ISR_HTIF7 = 0x4000000
	// No half transfer event
	DMA_ISR_HTIF7_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF7_Half = 0x1
	// Position of TCIF7 field.
	DMA_ISR_TCIF7_Pos = 0x19
	// Bit mask of TCIF7 field.
	DMA_ISR_TCIF7_Msk = 0x2000000
	// Bit TCIF7.
	DMA_ISR_TCIF7 = 0x2000000
	// No transfer complete event
	DMA_ISR_TCIF7_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF7_Complete = 0x1
	// Position of GIF7 field.
	DMA_ISR_GIF7_Pos = 0x18
	// Bit mask of GIF7 field.
	DMA_ISR_GIF7_Msk = 0x1000000
	// Bit GIF7.
	DMA_ISR_GIF7 = 0x1000000
	// No transfer error, half event, complete event
	DMA_ISR_GIF7_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF7_Event = 0x1
	// Position of TEIF6 field.
	DMA_ISR_TEIF6_Pos = 0x17
	// Bit mask of TEIF6 field.
	DMA_ISR_TEIF6_Msk = 0x800000
	// Bit TEIF6.
	DMA_ISR_TEIF6 = 0x800000
	// No transfer error
	DMA_ISR_TEIF6_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF6_Error = 0x1
	// Position of HTIF6 field.
	DMA_ISR_HTIF6_Pos = 0x16
	// Bit mask of HTIF6 field.
	DMA_ISR_HTIF6_Msk = 0x400000
	// Bit HTIF6.
	DMA_ISR_HTIF6 = 0x400000
	// No half transfer event
	DMA_ISR_HTIF6_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF6_Half = 0x1
	// Position of TCIF6 field.
	DMA_ISR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA_ISR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA_ISR_TCIF6 = 0x200000
	// No transfer complete event
	DMA_ISR_TCIF6_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF6_Complete = 0x1
	// Position of GIF6 field.
	DMA_ISR_GIF6_Pos = 0x14
	// Bit mask of GIF6 field.
	DMA_ISR_GIF6_Msk = 0x100000
	// Bit GIF6.
	DMA_ISR_GIF6 = 0x100000
	// No transfer error, half event, complete event
	DMA_ISR_GIF6_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF6_Event = 0x1
	// Position of TEIF5 field.
	DMA_ISR_TEIF5_Pos = 0x13
	// Bit mask of TEIF5 field.
	DMA_ISR_TEIF5_Msk = 0x80000
	// Bit TEIF5.
	DMA_ISR_TEIF5 = 0x80000
	// No transfer error
	DMA_ISR_TEIF5_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF5_Error = 0x1
	// Position of HTIF5 field.
	DMA_ISR_HTIF5_Pos = 0x12
	// Bit mask of HTIF5 field.
	DMA_ISR_HTIF5_Msk = 0x40000
	// Bit HTIF5.
	DMA_ISR_HTIF5 = 0x40000
	// No half transfer event
	DMA_ISR_HTIF5_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF5_Half = 0x1
	// Position of TCIF5 field.
	DMA_ISR_TCIF5_Pos = 0x11
	// Bit mask of TCIF5 field.
	DMA_ISR_TCIF5_Msk = 0x20000
	// Bit TCIF5.
	DMA_ISR_TCIF5 = 0x20000
	// No transfer complete event
	DMA_ISR_TCIF5_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF5_Complete = 0x1
	// Position of GIF5 field.
	DMA_ISR_GIF5_Pos = 0x10
	// Bit mask of GIF5 field.
	DMA_ISR_GIF5_Msk = 0x10000
	// Bit GIF5.
	DMA_ISR_GIF5 = 0x10000
	// No transfer error, half event, complete event
	DMA_ISR_GIF5_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF5_Event = 0x1
	// Position of TEIF4 field.
	DMA_ISR_TEIF4_Pos = 0xf
	// Bit mask of TEIF4 field.
	DMA_ISR_TEIF4_Msk = 0x8000
	// Bit TEIF4.
	DMA_ISR_TEIF4 = 0x8000
	// No transfer error
	DMA_ISR_TEIF4_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF4_Error = 0x1
	// Position of HTIF4 field.
	DMA_ISR_HTIF4_Pos = 0xe
	// Bit mask of HTIF4 field.
	DMA_ISR_HTIF4_Msk = 0x4000
	// Bit HTIF4.
	DMA_ISR_HTIF4 = 0x4000
	// No half transfer event
	DMA_ISR_HTIF4_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF4_Half = 0x1
	// Position of TCIF4 field.
	DMA_ISR_TCIF4_Pos = 0xd
	// Bit mask of TCIF4 field.
	DMA_ISR_TCIF4_Msk = 0x2000
	// Bit TCIF4.
	DMA_ISR_TCIF4 = 0x2000
	// No transfer complete event
	DMA_ISR_TCIF4_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF4_Complete = 0x1
	// Position of GIF4 field.
	DMA_ISR_GIF4_Pos = 0xc
	// Bit mask of GIF4 field.
	DMA_ISR_GIF4_Msk = 0x1000
	// Bit GIF4.
	DMA_ISR_GIF4 = 0x1000
	// No transfer error, half event, complete event
	DMA_ISR_GIF4_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF4_Event = 0x1
	// Position of TEIF3 field.
	DMA_ISR_TEIF3_Pos = 0xb
	// Bit mask of TEIF3 field.
	DMA_ISR_TEIF3_Msk = 0x800
	// Bit TEIF3.
	DMA_ISR_TEIF3 = 0x800
	// No transfer error
	DMA_ISR_TEIF3_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF3_Error = 0x1
	// Position of HTIF3 field.
	DMA_ISR_HTIF3_Pos = 0xa
	// Bit mask of HTIF3 field.
	DMA_ISR_HTIF3_Msk = 0x400
	// Bit HTIF3.
	DMA_ISR_HTIF3 = 0x400
	// No half transfer event
	DMA_ISR_HTIF3_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF3_Half = 0x1
	// Position of TCIF3 field.
	DMA_ISR_TCIF3_Pos = 0x9
	// Bit mask of TCIF3 field.
	DMA_ISR_TCIF3_Msk = 0x200
	// Bit TCIF3.
	DMA_ISR_TCIF3 = 0x200
	// No transfer complete event
	DMA_ISR_TCIF3_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF3_Complete = 0x1
	// Position of GIF3 field.
	DMA_ISR_GIF3_Pos = 0x8
	// Bit mask of GIF3 field.
	DMA_ISR_GIF3_Msk = 0x100
	// Bit GIF3.
	DMA_ISR_GIF3 = 0x100
	// No transfer error, half event, complete event
	DMA_ISR_GIF3_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF3_Event = 0x1
	// Position of TEIF2 field.
	DMA_ISR_TEIF2_Pos = 0x7
	// Bit mask of TEIF2 field.
	DMA_ISR_TEIF2_Msk = 0x80
	// Bit TEIF2.
	DMA_ISR_TEIF2 = 0x80
	// No transfer error
	DMA_ISR_TEIF2_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF2_Error = 0x1
	// Position of HTIF2 field.
	DMA_ISR_HTIF2_Pos = 0x6
	// Bit mask of HTIF2 field.
	DMA_ISR_HTIF2_Msk = 0x40
	// Bit HTIF2.
	DMA_ISR_HTIF2 = 0x40
	// No half transfer event
	DMA_ISR_HTIF2_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF2_Half = 0x1
	// Position of TCIF2 field.
	DMA_ISR_TCIF2_Pos = 0x5
	// Bit mask of TCIF2 field.
	DMA_ISR_TCIF2_Msk = 0x20
	// Bit TCIF2.
	DMA_ISR_TCIF2 = 0x20
	// No transfer complete event
	DMA_ISR_TCIF2_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF2_Complete = 0x1
	// Position of GIF2 field.
	DMA_ISR_GIF2_Pos = 0x4
	// Bit mask of GIF2 field.
	DMA_ISR_GIF2_Msk = 0x10
	// Bit GIF2.
	DMA_ISR_GIF2 = 0x10
	// No transfer error, half event, complete event
	DMA_ISR_GIF2_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF2_Event = 0x1
	// Position of TEIF1 field.
	DMA_ISR_TEIF1_Pos = 0x3
	// Bit mask of TEIF1 field.
	DMA_ISR_TEIF1_Msk = 0x8
	// Bit TEIF1.
	DMA_ISR_TEIF1 = 0x8
	// No transfer error
	DMA_ISR_TEIF1_NoError = 0x0
	// A transfer error has occured
	DMA_ISR_TEIF1_Error = 0x1
	// Position of HTIF1 field.
	DMA_ISR_HTIF1_Pos = 0x2
	// Bit mask of HTIF1 field.
	DMA_ISR_HTIF1_Msk = 0x4
	// Bit HTIF1.
	DMA_ISR_HTIF1 = 0x4
	// No half transfer event
	DMA_ISR_HTIF1_NotHalf = 0x0
	// A half transfer event has occured
	DMA_ISR_HTIF1_Half = 0x1
	// Position of TCIF1 field.
	DMA_ISR_TCIF1_Pos = 0x1
	// Bit mask of TCIF1 field.
	DMA_ISR_TCIF1_Msk = 0x2
	// Bit TCIF1.
	DMA_ISR_TCIF1 = 0x2
	// No transfer complete event
	DMA_ISR_TCIF1_NotComplete = 0x0
	// A transfer complete event has occured
	DMA_ISR_TCIF1_Complete = 0x1
	// Position of GIF1 field.
	DMA_ISR_GIF1_Pos = 0x0
	// Bit mask of GIF1 field.
	DMA_ISR_GIF1_Msk = 0x1
	// Bit GIF1.
	DMA_ISR_GIF1 = 0x1
	// No transfer error, half event, complete event
	DMA_ISR_GIF1_NoEvent = 0x0
	// A transfer error, half event or complete event has occured
	DMA_ISR_GIF1_Event = 0x1

	// IFCR: interrupt flag clear register
	// Position of CTEIF7 field.
	DMA_IFCR_CTEIF7_Pos = 0x1b
	// Bit mask of CTEIF7 field.
	DMA_IFCR_CTEIF7_Msk = 0x8000000
	// Bit CTEIF7.
	DMA_IFCR_CTEIF7 = 0x8000000
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF7_Clear = 0x1
	// Position of CHTIF7 field.
	DMA_IFCR_CHTIF7_Pos = 0x1a
	// Bit mask of CHTIF7 field.
	DMA_IFCR_CHTIF7_Msk = 0x4000000
	// Bit CHTIF7.
	DMA_IFCR_CHTIF7 = 0x4000000
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF7_Clear = 0x1
	// Position of CTCIF7 field.
	DMA_IFCR_CTCIF7_Pos = 0x19
	// Bit mask of CTCIF7 field.
	DMA_IFCR_CTCIF7_Msk = 0x2000000
	// Bit CTCIF7.
	DMA_IFCR_CTCIF7 = 0x2000000
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF7_Clear = 0x1
	// Position of CGIF7 field.
	DMA_IFCR_CGIF7_Pos = 0x18
	// Bit mask of CGIF7 field.
	DMA_IFCR_CGIF7_Msk = 0x1000000
	// Bit CGIF7.
	DMA_IFCR_CGIF7 = 0x1000000
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF7_Clear = 0x1
	// Position of CTEIF6 field.
	DMA_IFCR_CTEIF6_Pos = 0x17
	// Bit mask of CTEIF6 field.
	DMA_IFCR_CTEIF6_Msk = 0x800000
	// Bit CTEIF6.
	DMA_IFCR_CTEIF6 = 0x800000
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF6_Clear = 0x1
	// Position of CHTIF6 field.
	DMA_IFCR_CHTIF6_Pos = 0x16
	// Bit mask of CHTIF6 field.
	DMA_IFCR_CHTIF6_Msk = 0x400000
	// Bit CHTIF6.
	DMA_IFCR_CHTIF6 = 0x400000
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF6_Clear = 0x1
	// Position of CTCIF6 field.
	DMA_IFCR_CTCIF6_Pos = 0x15
	// Bit mask of CTCIF6 field.
	DMA_IFCR_CTCIF6_Msk = 0x200000
	// Bit CTCIF6.
	DMA_IFCR_CTCIF6 = 0x200000
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF6_Clear = 0x1
	// Position of CGIF6 field.
	DMA_IFCR_CGIF6_Pos = 0x14
	// Bit mask of CGIF6 field.
	DMA_IFCR_CGIF6_Msk = 0x100000
	// Bit CGIF6.
	DMA_IFCR_CGIF6 = 0x100000
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF6_Clear = 0x1
	// Position of CTEIF5 field.
	DMA_IFCR_CTEIF5_Pos = 0x13
	// Bit mask of CTEIF5 field.
	DMA_IFCR_CTEIF5_Msk = 0x80000
	// Bit CTEIF5.
	DMA_IFCR_CTEIF5 = 0x80000
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF5_Clear = 0x1
	// Position of CHTIF5 field.
	DMA_IFCR_CHTIF5_Pos = 0x12
	// Bit mask of CHTIF5 field.
	DMA_IFCR_CHTIF5_Msk = 0x40000
	// Bit CHTIF5.
	DMA_IFCR_CHTIF5 = 0x40000
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF5_Clear = 0x1
	// Position of CTCIF5 field.
	DMA_IFCR_CTCIF5_Pos = 0x11
	// Bit mask of CTCIF5 field.
	DMA_IFCR_CTCIF5_Msk = 0x20000
	// Bit CTCIF5.
	DMA_IFCR_CTCIF5 = 0x20000
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF5_Clear = 0x1
	// Position of CGIF5 field.
	DMA_IFCR_CGIF5_Pos = 0x10
	// Bit mask of CGIF5 field.
	DMA_IFCR_CGIF5_Msk = 0x10000
	// Bit CGIF5.
	DMA_IFCR_CGIF5 = 0x10000
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF5_Clear = 0x1
	// Position of CTEIF4 field.
	DMA_IFCR_CTEIF4_Pos = 0xf
	// Bit mask of CTEIF4 field.
	DMA_IFCR_CTEIF4_Msk = 0x8000
	// Bit CTEIF4.
	DMA_IFCR_CTEIF4 = 0x8000
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF4_Clear = 0x1
	// Position of CHTIF4 field.
	DMA_IFCR_CHTIF4_Pos = 0xe
	// Bit mask of CHTIF4 field.
	DMA_IFCR_CHTIF4_Msk = 0x4000
	// Bit CHTIF4.
	DMA_IFCR_CHTIF4 = 0x4000
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF4_Clear = 0x1
	// Position of CTCIF4 field.
	DMA_IFCR_CTCIF4_Pos = 0xd
	// Bit mask of CTCIF4 field.
	DMA_IFCR_CTCIF4_Msk = 0x2000
	// Bit CTCIF4.
	DMA_IFCR_CTCIF4 = 0x2000
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF4_Clear = 0x1
	// Position of CGIF4 field.
	DMA_IFCR_CGIF4_Pos = 0xc
	// Bit mask of CGIF4 field.
	DMA_IFCR_CGIF4_Msk = 0x1000
	// Bit CGIF4.
	DMA_IFCR_CGIF4 = 0x1000
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF4_Clear = 0x1
	// Position of CTEIF3 field.
	DMA_IFCR_CTEIF3_Pos = 0xb
	// Bit mask of CTEIF3 field.
	DMA_IFCR_CTEIF3_Msk = 0x800
	// Bit CTEIF3.
	DMA_IFCR_CTEIF3 = 0x800
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF3_Clear = 0x1
	// Position of CHTIF3 field.
	DMA_IFCR_CHTIF3_Pos = 0xa
	// Bit mask of CHTIF3 field.
	DMA_IFCR_CHTIF3_Msk = 0x400
	// Bit CHTIF3.
	DMA_IFCR_CHTIF3 = 0x400
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF3_Clear = 0x1
	// Position of CTCIF3 field.
	DMA_IFCR_CTCIF3_Pos = 0x9
	// Bit mask of CTCIF3 field.
	DMA_IFCR_CTCIF3_Msk = 0x200
	// Bit CTCIF3.
	DMA_IFCR_CTCIF3 = 0x200
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF3_Clear = 0x1
	// Position of CGIF3 field.
	DMA_IFCR_CGIF3_Pos = 0x8
	// Bit mask of CGIF3 field.
	DMA_IFCR_CGIF3_Msk = 0x100
	// Bit CGIF3.
	DMA_IFCR_CGIF3 = 0x100
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF3_Clear = 0x1
	// Position of CTEIF2 field.
	DMA_IFCR_CTEIF2_Pos = 0x7
	// Bit mask of CTEIF2 field.
	DMA_IFCR_CTEIF2_Msk = 0x80
	// Bit CTEIF2.
	DMA_IFCR_CTEIF2 = 0x80
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF2_Clear = 0x1
	// Position of CHTIF2 field.
	DMA_IFCR_CHTIF2_Pos = 0x6
	// Bit mask of CHTIF2 field.
	DMA_IFCR_CHTIF2_Msk = 0x40
	// Bit CHTIF2.
	DMA_IFCR_CHTIF2 = 0x40
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF2_Clear = 0x1
	// Position of CTCIF2 field.
	DMA_IFCR_CTCIF2_Pos = 0x5
	// Bit mask of CTCIF2 field.
	DMA_IFCR_CTCIF2_Msk = 0x20
	// Bit CTCIF2.
	DMA_IFCR_CTCIF2 = 0x20
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF2_Clear = 0x1
	// Position of CGIF2 field.
	DMA_IFCR_CGIF2_Pos = 0x4
	// Bit mask of CGIF2 field.
	DMA_IFCR_CGIF2_Msk = 0x10
	// Bit CGIF2.
	DMA_IFCR_CGIF2 = 0x10
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF2_Clear = 0x1
	// Position of CTEIF1 field.
	DMA_IFCR_CTEIF1_Pos = 0x3
	// Bit mask of CTEIF1 field.
	DMA_IFCR_CTEIF1_Msk = 0x8
	// Bit CTEIF1.
	DMA_IFCR_CTEIF1 = 0x8
	// Clears the TEIF flag in the ISR register
	DMA_IFCR_CTEIF1_Clear = 0x1
	// Position of CHTIF1 field.
	DMA_IFCR_CHTIF1_Pos = 0x2
	// Bit mask of CHTIF1 field.
	DMA_IFCR_CHTIF1_Msk = 0x4
	// Bit CHTIF1.
	DMA_IFCR_CHTIF1 = 0x4
	// Clears the HTIF flag in the ISR register
	DMA_IFCR_CHTIF1_Clear = 0x1
	// Position of CTCIF1 field.
	DMA_IFCR_CTCIF1_Pos = 0x1
	// Bit mask of CTCIF1 field.
	DMA_IFCR_CTCIF1_Msk = 0x2
	// Bit CTCIF1.
	DMA_IFCR_CTCIF1 = 0x2
	// Clears the TCIF flag in the ISR register
	DMA_IFCR_CTCIF1_Clear = 0x1
	// Position of CGIF1 field.
	DMA_IFCR_CGIF1_Pos = 0x0
	// Bit mask of CGIF1 field.
	DMA_IFCR_CGIF1_Msk = 0x1
	// Bit CGIF1.
	DMA_IFCR_CGIF1 = 0x1
	// Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
	DMA_IFCR_CGIF1_Clear = 0x1

	// CCR1: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR1_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR1_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR1_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR1_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR1_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR1_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR1_PL_Msk = 0x3000
	// Low priority
	DMA_CCR1_PL_Low = 0x0
	// Medium priority
	DMA_CCR1_PL_Medium = 0x1
	// High priority
	DMA_CCR1_PL_High = 0x2
	// Very high priority
	DMA_CCR1_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR1_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR1_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR1_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR1_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR1_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR1_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR1_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR1_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR1_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR1_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR1_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR1_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR1_MINC = 0x80
	// Increment mode disabled
	DMA_CCR1_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR1_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR1_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR1_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR1_PINC = 0x40
	// Increment mode disabled
	DMA_CCR1_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR1_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR1_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR1_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR1_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR1_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR1_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR1_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR1_DIR = 0x10
	// Read from peripheral
	DMA_CCR1_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR1_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR1_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR1_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR1_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR1_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR1_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR1_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR1_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR1_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR1_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR1_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR1_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR1_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR1_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR1_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR1_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR1_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR1_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR1_EN = 0x1
	// Channel disabled
	DMA_CCR1_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR1_EN_Enabled = 0x1

	// CNDTR1: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR1_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR1_NDT_Msk = 0xffff

	// CPAR1: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR1_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR1_PA_Msk = 0xffffffff

	// CMAR1: channel x memory address register
	// Position of MA field.
	DMA_CMAR1_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR1_MA_Msk = 0xffffffff

	// CCR2: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR2_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR2_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR2_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR2_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR2_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR2_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR2_PL_Msk = 0x3000
	// Low priority
	DMA_CCR2_PL_Low = 0x0
	// Medium priority
	DMA_CCR2_PL_Medium = 0x1
	// High priority
	DMA_CCR2_PL_High = 0x2
	// Very high priority
	DMA_CCR2_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR2_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR2_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR2_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR2_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR2_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR2_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR2_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR2_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR2_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR2_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR2_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR2_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR2_MINC = 0x80
	// Increment mode disabled
	DMA_CCR2_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR2_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR2_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR2_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR2_PINC = 0x40
	// Increment mode disabled
	DMA_CCR2_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR2_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR2_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR2_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR2_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR2_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR2_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR2_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR2_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR2_DIR = 0x10
	// Read from peripheral
	DMA_CCR2_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR2_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR2_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR2_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR2_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR2_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR2_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR2_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR2_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR2_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR2_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR2_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR2_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR2_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR2_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR2_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR2_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR2_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR2_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR2_EN = 0x1
	// Channel disabled
	DMA_CCR2_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR2_EN_Enabled = 0x1

	// CNDTR2: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR2_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR2_NDT_Msk = 0xffff

	// CPAR2: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR2_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR2_PA_Msk = 0xffffffff

	// CMAR2: channel x memory address register
	// Position of MA field.
	DMA_CMAR2_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR2_MA_Msk = 0xffffffff

	// CCR3: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR3_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR3_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR3_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR3_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR3_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR3_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR3_PL_Msk = 0x3000
	// Low priority
	DMA_CCR3_PL_Low = 0x0
	// Medium priority
	DMA_CCR3_PL_Medium = 0x1
	// High priority
	DMA_CCR3_PL_High = 0x2
	// Very high priority
	DMA_CCR3_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR3_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR3_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR3_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR3_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR3_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR3_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR3_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR3_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR3_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR3_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR3_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR3_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR3_MINC = 0x80
	// Increment mode disabled
	DMA_CCR3_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR3_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR3_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR3_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR3_PINC = 0x40
	// Increment mode disabled
	DMA_CCR3_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR3_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR3_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR3_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR3_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR3_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR3_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR3_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR3_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR3_DIR = 0x10
	// Read from peripheral
	DMA_CCR3_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR3_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR3_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR3_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR3_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR3_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR3_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR3_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR3_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR3_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR3_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR3_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR3_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR3_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR3_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR3_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR3_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR3_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR3_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR3_EN = 0x1
	// Channel disabled
	DMA_CCR3_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR3_EN_Enabled = 0x1

	// CNDTR3: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR3_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR3_NDT_Msk = 0xffff

	// CPAR3: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR3_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR3_PA_Msk = 0xffffffff

	// CMAR3: channel x memory address register
	// Position of MA field.
	DMA_CMAR3_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR3_MA_Msk = 0xffffffff

	// CCR4: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR4_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR4_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR4_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR4_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR4_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR4_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR4_PL_Msk = 0x3000
	// Low priority
	DMA_CCR4_PL_Low = 0x0
	// Medium priority
	DMA_CCR4_PL_Medium = 0x1
	// High priority
	DMA_CCR4_PL_High = 0x2
	// Very high priority
	DMA_CCR4_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR4_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR4_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR4_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR4_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR4_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR4_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR4_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR4_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR4_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR4_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR4_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR4_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR4_MINC = 0x80
	// Increment mode disabled
	DMA_CCR4_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR4_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR4_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR4_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR4_PINC = 0x40
	// Increment mode disabled
	DMA_CCR4_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR4_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR4_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR4_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR4_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR4_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR4_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR4_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR4_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR4_DIR = 0x10
	// Read from peripheral
	DMA_CCR4_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR4_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR4_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR4_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR4_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR4_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR4_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR4_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR4_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR4_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR4_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR4_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR4_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR4_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR4_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR4_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR4_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR4_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR4_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR4_EN = 0x1
	// Channel disabled
	DMA_CCR4_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR4_EN_Enabled = 0x1

	// CNDTR4: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR4_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR4_NDT_Msk = 0xffff

	// CPAR4: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR4_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR4_PA_Msk = 0xffffffff

	// CMAR4: channel x memory address register
	// Position of MA field.
	DMA_CMAR4_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR4_MA_Msk = 0xffffffff

	// CCR5: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR5_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR5_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR5_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR5_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR5_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR5_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR5_PL_Msk = 0x3000
	// Low priority
	DMA_CCR5_PL_Low = 0x0
	// Medium priority
	DMA_CCR5_PL_Medium = 0x1
	// High priority
	DMA_CCR5_PL_High = 0x2
	// Very high priority
	DMA_CCR5_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR5_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR5_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR5_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR5_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR5_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR5_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR5_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR5_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR5_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR5_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR5_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR5_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR5_MINC = 0x80
	// Increment mode disabled
	DMA_CCR5_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR5_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR5_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR5_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR5_PINC = 0x40
	// Increment mode disabled
	DMA_CCR5_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR5_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR5_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR5_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR5_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR5_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR5_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR5_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR5_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR5_DIR = 0x10
	// Read from peripheral
	DMA_CCR5_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR5_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR5_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR5_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR5_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR5_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR5_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR5_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR5_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR5_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR5_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR5_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR5_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR5_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR5_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR5_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR5_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR5_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR5_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR5_EN = 0x1
	// Channel disabled
	DMA_CCR5_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR5_EN_Enabled = 0x1

	// CNDTR5: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR5_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR5_NDT_Msk = 0xffff

	// CPAR5: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR5_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR5_PA_Msk = 0xffffffff

	// CMAR5: channel x memory address register
	// Position of MA field.
	DMA_CMAR5_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR5_MA_Msk = 0xffffffff

	// CCR6: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR6_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR6_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR6_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR6_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR6_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR6_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR6_PL_Msk = 0x3000
	// Low priority
	DMA_CCR6_PL_Low = 0x0
	// Medium priority
	DMA_CCR6_PL_Medium = 0x1
	// High priority
	DMA_CCR6_PL_High = 0x2
	// Very high priority
	DMA_CCR6_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR6_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR6_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR6_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR6_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR6_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR6_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR6_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR6_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR6_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR6_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR6_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR6_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR6_MINC = 0x80
	// Increment mode disabled
	DMA_CCR6_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR6_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR6_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR6_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR6_PINC = 0x40
	// Increment mode disabled
	DMA_CCR6_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR6_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR6_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR6_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR6_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR6_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR6_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR6_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR6_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR6_DIR = 0x10
	// Read from peripheral
	DMA_CCR6_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR6_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR6_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR6_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR6_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR6_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR6_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR6_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR6_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR6_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR6_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR6_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR6_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR6_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR6_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR6_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR6_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR6_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR6_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR6_EN = 0x1
	// Channel disabled
	DMA_CCR6_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR6_EN_Enabled = 0x1

	// CNDTR6: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR6_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR6_NDT_Msk = 0xffff

	// CPAR6: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR6_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR6_PA_Msk = 0xffffffff

	// CMAR6: channel x memory address register
	// Position of MA field.
	DMA_CMAR6_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR6_MA_Msk = 0xffffffff

	// CCR7: channel x configuration register
	// Position of MEM2MEM field.
	DMA_CCR7_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CCR7_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CCR7_MEM2MEM = 0x4000
	// Memory to memory mode disabled
	DMA_CCR7_MEM2MEM_Disabled = 0x0
	// Memory to memory mode enabled
	DMA_CCR7_MEM2MEM_Enabled = 0x1
	// Position of PL field.
	DMA_CCR7_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CCR7_PL_Msk = 0x3000
	// Low priority
	DMA_CCR7_PL_Low = 0x0
	// Medium priority
	DMA_CCR7_PL_Medium = 0x1
	// High priority
	DMA_CCR7_PL_High = 0x2
	// Very high priority
	DMA_CCR7_PL_VeryHigh = 0x3
	// Position of MSIZE field.
	DMA_CCR7_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CCR7_MSIZE_Msk = 0xc00
	// 8-bit size
	DMA_CCR7_MSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR7_MSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR7_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_CCR7_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CCR7_PSIZE_Msk = 0x300
	// 8-bit size
	DMA_CCR7_PSIZE_Bits8 = 0x0
	// 16-bit size
	DMA_CCR7_PSIZE_Bits16 = 0x1
	// 32-bit size
	DMA_CCR7_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_CCR7_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CCR7_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CCR7_MINC = 0x80
	// Increment mode disabled
	DMA_CCR7_MINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR7_MINC_Enabled = 0x1
	// Position of PINC field.
	DMA_CCR7_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CCR7_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CCR7_PINC = 0x40
	// Increment mode disabled
	DMA_CCR7_PINC_Disabled = 0x0
	// Increment mode enabled
	DMA_CCR7_PINC_Enabled = 0x1
	// Position of CIRC field.
	DMA_CCR7_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CCR7_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CCR7_CIRC = 0x20
	// Circular buffer disabled
	DMA_CCR7_CIRC_Disabled = 0x0
	// Circular buffer enabled
	DMA_CCR7_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_CCR7_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CCR7_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CCR7_DIR = 0x10
	// Read from peripheral
	DMA_CCR7_DIR_FromPeripheral = 0x0
	// Read from memory
	DMA_CCR7_DIR_FromMemory = 0x1
	// Position of TEIE field.
	DMA_CCR7_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CCR7_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CCR7_TEIE = 0x8
	// Transfer Error interrupt disabled
	DMA_CCR7_TEIE_Disabled = 0x0
	// Transfer Error interrupt enabled
	DMA_CCR7_TEIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_CCR7_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CCR7_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CCR7_HTIE = 0x4
	// Half Transfer interrupt disabled
	DMA_CCR7_HTIE_Disabled = 0x0
	// Half Transfer interrupt enabled
	DMA_CCR7_HTIE_Enabled = 0x1
	// Position of TCIE field.
	DMA_CCR7_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CCR7_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CCR7_TCIE = 0x2
	// Transfer Complete interrupt disabled
	DMA_CCR7_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	DMA_CCR7_TCIE_Enabled = 0x1
	// Position of EN field.
	DMA_CCR7_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CCR7_EN_Msk = 0x1
	// Bit EN.
	DMA_CCR7_EN = 0x1
	// Channel disabled
	DMA_CCR7_EN_Disabled = 0x0
	// Channel enabled
	DMA_CCR7_EN_Enabled = 0x1

	// CNDTR7: channel x number of data register
	// Position of NDT field.
	DMA_CNDTR7_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CNDTR7_NDT_Msk = 0xffff

	// CPAR7: channel x peripheral address register
	// Position of PA field.
	DMA_CPAR7_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CPAR7_PA_Msk = 0xffffffff

	// CMAR7: channel x memory address register
	// Position of MA field.
	DMA_CMAR7_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CMAR7_MA_Msk = 0xffffffff
)

// Constants for DMAMUX1: DMA request multiplexer
const (
	// C0CR: channel 0 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C0CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C0CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C0CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C0CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C0CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C0CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C0CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C0CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C0CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C0CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C0CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C0CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C0CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C0CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C0CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C0CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C0CR_DMAREQ_ID_Msk = 0x7f

	// C1CR: channel 1 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C1CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C1CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C1CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C1CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C1CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C1CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C1CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C1CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C1CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C1CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C1CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C1CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C1CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C1CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C1CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C1CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C1CR_DMAREQ_ID_Msk = 0x7f

	// C2CR: channel 2 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C2CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C2CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C2CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C2CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C2CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C2CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C2CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C2CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C2CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C2CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C2CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C2CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C2CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C2CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C2CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C2CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C2CR_DMAREQ_ID_Msk = 0x7f

	// C3CR: channel 3 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C3CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C3CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C3CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C3CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C3CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C3CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C3CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C3CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C3CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C3CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C3CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C3CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C3CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C3CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C3CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C3CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C3CR_DMAREQ_ID_Msk = 0x7f

	// C4CR: channel 4 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C4CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C4CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C4CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C4CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C4CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C4CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C4CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C4CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C4CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C4CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C4CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C4CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C4CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C4CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C4CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C4CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C4CR_DMAREQ_ID_Msk = 0x7f

	// C5CR: channel 5 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C5CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C5CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C5CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C5CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C5CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C5CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C5CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C5CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C5CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C5CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C5CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C5CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C5CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C5CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C5CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C5CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C5CR_DMAREQ_ID_Msk = 0x7f

	// C6CR: channel 6 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C6CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C6CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C6CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C6CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C6CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C6CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C6CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C6CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C6CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C6CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C6CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C6CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C6CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C6CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C6CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C6CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C6CR_DMAREQ_ID_Msk = 0x7f

	// C7CR: channel 7 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C7CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C7CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C7CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C7CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C7CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C7CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C7CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C7CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C7CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C7CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C7CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C7CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C7CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C7CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C7CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C7CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C7CR_DMAREQ_ID_Msk = 0x7f

	// C8CR: channel 8 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C8CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C8CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C8CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C8CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C8CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C8CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C8CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C8CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C8CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C8CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C8CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C8CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C8CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C8CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C8CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C8CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C8CR_DMAREQ_ID_Msk = 0x7f

	// C9CR: channel 9 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C9CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C9CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C9CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C9CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C9CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C9CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C9CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C9CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C9CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C9CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C9CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C9CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C9CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C9CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C9CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C9CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C9CR_DMAREQ_ID_Msk = 0x7f

	// C10CR: channel 10 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C10CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C10CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C10CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C10CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C10CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C10CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C10CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C10CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C10CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C10CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C10CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C10CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C10CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C10CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C10CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C10CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C10CR_DMAREQ_ID_Msk = 0x7f

	// C11CR: channel 11 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C11CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C11CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C11CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C11CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C11CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C11CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C11CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C11CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C11CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C11CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C11CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C11CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C11CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C11CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C11CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C11CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C11CR_DMAREQ_ID_Msk = 0x7f

	// C12CR: channel 12 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C12CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C12CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C12CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C12CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C12CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C12CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C12CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C12CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C12CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C12CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C12CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C12CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C12CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C12CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C12CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C12CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C12CR_DMAREQ_ID_Msk = 0x7f

	// C13CR: channel 13 configuration register
	// Position of SYNC_ID field.
	DMAMUX_C13CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C13CR_SYNC_ID_Msk = 0x1f000000
	// Position of NBREQ field.
	DMAMUX_C13CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C13CR_NBREQ_Msk = 0xf80000
	// Position of SPOL field.
	DMAMUX_C13CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C13CR_SPOL_Msk = 0x60000
	// Position of SE field.
	DMAMUX_C13CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C13CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C13CR_SE = 0x10000
	// Position of EGE field.
	DMAMUX_C13CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C13CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C13CR_EGE = 0x200
	// Position of SOIE field.
	DMAMUX_C13CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C13CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C13CR_SOIE = 0x100
	// Position of DMAREQ_ID field.
	DMAMUX_C13CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C13CR_DMAREQ_ID_Msk = 0x7f

	// CSR: channel status register
	// Position of SOF0 field.
	DMAMUX_CSR_SOF0_Pos = 0x0
	// Bit mask of SOF0 field.
	DMAMUX_CSR_SOF0_Msk = 0x1
	// Bit SOF0.
	DMAMUX_CSR_SOF0 = 0x1
	// Position of SOF1 field.
	DMAMUX_CSR_SOF1_Pos = 0x1
	// Bit mask of SOF1 field.
	DMAMUX_CSR_SOF1_Msk = 0x2
	// Bit SOF1.
	DMAMUX_CSR_SOF1 = 0x2
	// Position of SOF2 field.
	DMAMUX_CSR_SOF2_Pos = 0x2
	// Bit mask of SOF2 field.
	DMAMUX_CSR_SOF2_Msk = 0x4
	// Bit SOF2.
	DMAMUX_CSR_SOF2 = 0x4
	// Position of SOF3 field.
	DMAMUX_CSR_SOF3_Pos = 0x3
	// Bit mask of SOF3 field.
	DMAMUX_CSR_SOF3_Msk = 0x8
	// Bit SOF3.
	DMAMUX_CSR_SOF3 = 0x8
	// Position of SOF4 field.
	DMAMUX_CSR_SOF4_Pos = 0x4
	// Bit mask of SOF4 field.
	DMAMUX_CSR_SOF4_Msk = 0x10
	// Bit SOF4.
	DMAMUX_CSR_SOF4 = 0x10
	// Position of SOF5 field.
	DMAMUX_CSR_SOF5_Pos = 0x5
	// Bit mask of SOF5 field.
	DMAMUX_CSR_SOF5_Msk = 0x20
	// Bit SOF5.
	DMAMUX_CSR_SOF5 = 0x20
	// Position of SOF6 field.
	DMAMUX_CSR_SOF6_Pos = 0x6
	// Bit mask of SOF6 field.
	DMAMUX_CSR_SOF6_Msk = 0x40
	// Bit SOF6.
	DMAMUX_CSR_SOF6 = 0x40
	// Position of SOF7 field.
	DMAMUX_CSR_SOF7_Pos = 0x7
	// Bit mask of SOF7 field.
	DMAMUX_CSR_SOF7_Msk = 0x80
	// Bit SOF7.
	DMAMUX_CSR_SOF7 = 0x80
	// Position of SOF8 field.
	DMAMUX_CSR_SOF8_Pos = 0x8
	// Bit mask of SOF8 field.
	DMAMUX_CSR_SOF8_Msk = 0x100
	// Bit SOF8.
	DMAMUX_CSR_SOF8 = 0x100
	// Position of SOF9 field.
	DMAMUX_CSR_SOF9_Pos = 0x9
	// Bit mask of SOF9 field.
	DMAMUX_CSR_SOF9_Msk = 0x200
	// Bit SOF9.
	DMAMUX_CSR_SOF9 = 0x200
	// Position of SOF10 field.
	DMAMUX_CSR_SOF10_Pos = 0xa
	// Bit mask of SOF10 field.
	DMAMUX_CSR_SOF10_Msk = 0x400
	// Bit SOF10.
	DMAMUX_CSR_SOF10 = 0x400
	// Position of SOF11 field.
	DMAMUX_CSR_SOF11_Pos = 0xb
	// Bit mask of SOF11 field.
	DMAMUX_CSR_SOF11_Msk = 0x800
	// Bit SOF11.
	DMAMUX_CSR_SOF11 = 0x800
	// Position of SOF12 field.
	DMAMUX_CSR_SOF12_Pos = 0xc
	// Bit mask of SOF12 field.
	DMAMUX_CSR_SOF12_Msk = 0x1000
	// Bit SOF12.
	DMAMUX_CSR_SOF12 = 0x1000
	// Position of SOF13 field.
	DMAMUX_CSR_SOF13_Pos = 0xd
	// Bit mask of SOF13 field.
	DMAMUX_CSR_SOF13_Msk = 0x2000
	// Bit SOF13.
	DMAMUX_CSR_SOF13 = 0x2000

	// CFR: clear flag register
	// Position of CSOF0 field.
	DMAMUX_CFR_CSOF0_Pos = 0x0
	// Bit mask of CSOF0 field.
	DMAMUX_CFR_CSOF0_Msk = 0x1
	// Bit CSOF0.
	DMAMUX_CFR_CSOF0 = 0x1
	// Position of CSOF1 field.
	DMAMUX_CFR_CSOF1_Pos = 0x1
	// Bit mask of CSOF1 field.
	DMAMUX_CFR_CSOF1_Msk = 0x2
	// Bit CSOF1.
	DMAMUX_CFR_CSOF1 = 0x2
	// Position of CSOF2 field.
	DMAMUX_CFR_CSOF2_Pos = 0x2
	// Bit mask of CSOF2 field.
	DMAMUX_CFR_CSOF2_Msk = 0x4
	// Bit CSOF2.
	DMAMUX_CFR_CSOF2 = 0x4
	// Position of CSOF3 field.
	DMAMUX_CFR_CSOF3_Pos = 0x3
	// Bit mask of CSOF3 field.
	DMAMUX_CFR_CSOF3_Msk = 0x8
	// Bit CSOF3.
	DMAMUX_CFR_CSOF3 = 0x8
	// Position of CSOF4 field.
	DMAMUX_CFR_CSOF4_Pos = 0x4
	// Bit mask of CSOF4 field.
	DMAMUX_CFR_CSOF4_Msk = 0x10
	// Bit CSOF4.
	DMAMUX_CFR_CSOF4 = 0x10
	// Position of CSOF5 field.
	DMAMUX_CFR_CSOF5_Pos = 0x5
	// Bit mask of CSOF5 field.
	DMAMUX_CFR_CSOF5_Msk = 0x20
	// Bit CSOF5.
	DMAMUX_CFR_CSOF5 = 0x20
	// Position of CSOF6 field.
	DMAMUX_CFR_CSOF6_Pos = 0x6
	// Bit mask of CSOF6 field.
	DMAMUX_CFR_CSOF6_Msk = 0x40
	// Bit CSOF6.
	DMAMUX_CFR_CSOF6 = 0x40
	// Position of CSOF7 field.
	DMAMUX_CFR_CSOF7_Pos = 0x7
	// Bit mask of CSOF7 field.
	DMAMUX_CFR_CSOF7_Msk = 0x80
	// Bit CSOF7.
	DMAMUX_CFR_CSOF7 = 0x80
	// Position of CSOF8 field.
	DMAMUX_CFR_CSOF8_Pos = 0x8
	// Bit mask of CSOF8 field.
	DMAMUX_CFR_CSOF8_Msk = 0x100
	// Bit CSOF8.
	DMAMUX_CFR_CSOF8 = 0x100
	// Position of CSOF9 field.
	DMAMUX_CFR_CSOF9_Pos = 0x9
	// Bit mask of CSOF9 field.
	DMAMUX_CFR_CSOF9_Msk = 0x200
	// Bit CSOF9.
	DMAMUX_CFR_CSOF9 = 0x200
	// Position of CSOF10 field.
	DMAMUX_CFR_CSOF10_Pos = 0xa
	// Bit mask of CSOF10 field.
	DMAMUX_CFR_CSOF10_Msk = 0x400
	// Bit CSOF10.
	DMAMUX_CFR_CSOF10 = 0x400
	// Position of CSOF11 field.
	DMAMUX_CFR_CSOF11_Pos = 0xb
	// Bit mask of CSOF11 field.
	DMAMUX_CFR_CSOF11_Msk = 0x800
	// Bit CSOF11.
	DMAMUX_CFR_CSOF11 = 0x800
	// Position of CSOF12 field.
	DMAMUX_CFR_CSOF12_Pos = 0xc
	// Bit mask of CSOF12 field.
	DMAMUX_CFR_CSOF12_Msk = 0x1000
	// Bit CSOF12.
	DMAMUX_CFR_CSOF12 = 0x1000
	// Position of CSOF13 field.
	DMAMUX_CFR_CSOF13_Pos = 0xd
	// Bit mask of CSOF13 field.
	DMAMUX_CFR_CSOF13_Msk = 0x2000
	// Bit CSOF13.
	DMAMUX_CFR_CSOF13 = 0x2000

	// RG0CR: request generator channel 0 configuration register
	// Position of GNBREQ field.
	DMAMUX_RG0CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG0CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG0CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG0CR_GPOL_Msk = 0x60000
	// Position of GE field.
	DMAMUX_RG0CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG0CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG0CR_GE = 0x10000
	// Position of OIE field.
	DMAMUX_RG0CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG0CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG0CR_OIE = 0x100
	// Position of SIG_ID field.
	DMAMUX_RG0CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG0CR_SIG_ID_Msk = 0x1f

	// RG1CR: request generator channel 1 configuration register
	// Position of GNBREQ field.
	DMAMUX_RG1CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG1CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG1CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG1CR_GPOL_Msk = 0x60000
	// Position of GE field.
	DMAMUX_RG1CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG1CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG1CR_GE = 0x10000
	// Position of OIE field.
	DMAMUX_RG1CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG1CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG1CR_OIE = 0x100
	// Position of SIG_ID field.
	DMAMUX_RG1CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG1CR_SIG_ID_Msk = 0x1f

	// RG2CR: request generator channel 2 configuration register
	// Position of GNBREQ field.
	DMAMUX_RG2CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG2CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG2CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG2CR_GPOL_Msk = 0x60000
	// Position of GE field.
	DMAMUX_RG2CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG2CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG2CR_GE = 0x10000
	// Position of OIE field.
	DMAMUX_RG2CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG2CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG2CR_OIE = 0x100
	// Position of SIG_ID field.
	DMAMUX_RG2CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG2CR_SIG_ID_Msk = 0x1f

	// RG3CR: request generator channel 3 configuration register
	// Position of GNBREQ field.
	DMAMUX_RG3CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG3CR_GNBREQ_Msk = 0xf80000
	// Position of GPOL field.
	DMAMUX_RG3CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG3CR_GPOL_Msk = 0x60000
	// Position of GE field.
	DMAMUX_RG3CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG3CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG3CR_GE = 0x10000
	// Position of OIE field.
	DMAMUX_RG3CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG3CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG3CR_OIE = 0x100
	// Position of SIG_ID field.
	DMAMUX_RG3CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG3CR_SIG_ID_Msk = 0x1f

	// RGSR: request generator interrupt status register
	// Position of OF3 field.
	DMAMUX_RGSR_OF3_Pos = 0x3
	// Bit mask of OF3 field.
	DMAMUX_RGSR_OF3_Msk = 0x8
	// Bit OF3.
	DMAMUX_RGSR_OF3 = 0x8
	// Position of OF2 field.
	DMAMUX_RGSR_OF2_Pos = 0x2
	// Bit mask of OF2 field.
	DMAMUX_RGSR_OF2_Msk = 0x4
	// Bit OF2.
	DMAMUX_RGSR_OF2 = 0x4
	// Position of OF1 field.
	DMAMUX_RGSR_OF1_Pos = 0x1
	// Bit mask of OF1 field.
	DMAMUX_RGSR_OF1_Msk = 0x2
	// Bit OF1.
	DMAMUX_RGSR_OF1 = 0x2
	// Position of OF0 field.
	DMAMUX_RGSR_OF0_Pos = 0x0
	// Bit mask of OF0 field.
	DMAMUX_RGSR_OF0_Msk = 0x1
	// Bit OF0.
	DMAMUX_RGSR_OF0 = 0x1

	// RGCFR: request generator interrupt clear flag register
	// Position of COF3 field.
	DMAMUX_RGCFR_COF3_Pos = 0x3
	// Bit mask of COF3 field.
	DMAMUX_RGCFR_COF3_Msk = 0x8
	// Bit COF3.
	DMAMUX_RGCFR_COF3 = 0x8
	// Position of COF2 field.
	DMAMUX_RGCFR_COF2_Pos = 0x2
	// Bit mask of COF2 field.
	DMAMUX_RGCFR_COF2_Msk = 0x4
	// Bit COF2.
	DMAMUX_RGCFR_COF2 = 0x4
	// Position of COF1 field.
	DMAMUX_RGCFR_COF1_Pos = 0x1
	// Bit mask of COF1 field.
	DMAMUX_RGCFR_COF1_Msk = 0x2
	// Bit COF1.
	DMAMUX_RGCFR_COF1 = 0x2
	// Position of COF0 field.
	DMAMUX_RGCFR_COF0_Pos = 0x0
	// Bit mask of COF0 field.
	DMAMUX_RGCFR_COF0_Msk = 0x1
	// Bit COF0.
	DMAMUX_RGCFR_COF0 = 0x1
)

// Constants for CRC: Cyclic redundancy check calculation unit
const (
	// DR: Data register
	// Position of DR field.
	CRC_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	CRC_DR_DR_Msk = 0xffffffff

	// DR8: Data register - byte sized
	// Position of DR8 field.
	CRC_DR8_DR8_Pos = 0x0
	// Bit mask of DR8 field.
	CRC_DR8_DR8_Msk = 0xff

	// DR16: Data register - half-word sized
	// Position of DR16 field.
	CRC_DR16_DR16_Pos = 0x0
	// Bit mask of DR16 field.
	CRC_DR16_DR16_Msk = 0xffff

	// IDR: Independent data register
	// Position of IDR field.
	CRC_IDR_IDR_Pos = 0x0
	// Bit mask of IDR field.
	CRC_IDR_IDR_Msk = 0xff

	// CR: Control register
	// Position of REV_OUT field.
	CRC_CR_REV_OUT_Pos = 0x7
	// Bit mask of REV_OUT field.
	CRC_CR_REV_OUT_Msk = 0x80
	// Bit REV_OUT.
	CRC_CR_REV_OUT = 0x80
	// Bit order not affected
	CRC_CR_REV_OUT_Normal = 0x0
	// Bit reversed output
	CRC_CR_REV_OUT_Reversed = 0x1
	// Position of REV_IN field.
	CRC_CR_REV_IN_Pos = 0x5
	// Bit mask of REV_IN field.
	CRC_CR_REV_IN_Msk = 0x60
	// Bit order not affected
	CRC_CR_REV_IN_Normal = 0x0
	// Bit reversal done by byte
	CRC_CR_REV_IN_Byte = 0x1
	// Bit reversal done by half-word
	CRC_CR_REV_IN_HalfWord = 0x2
	// Bit reversal done by word
	CRC_CR_REV_IN_Word = 0x3
	// Position of POLYSIZE field.
	CRC_CR_POLYSIZE_Pos = 0x3
	// Bit mask of POLYSIZE field.
	CRC_CR_POLYSIZE_Msk = 0x18
	// 32-bit polynomial
	CRC_CR_POLYSIZE_Polysize32 = 0x0
	// 16-bit polynomial
	CRC_CR_POLYSIZE_Polysize16 = 0x1
	// 8-bit polynomial
	CRC_CR_POLYSIZE_Polysize8 = 0x2
	// 7-bit polynomial
	CRC_CR_POLYSIZE_Polysize7 = 0x3
	// Position of RESET field.
	CRC_CR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	CRC_CR_RESET_Msk = 0x1
	// Bit RESET.
	CRC_CR_RESET = 0x1
	// Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
	CRC_CR_RESET_Reset = 0x1

	// INIT: Initial CRC value
	// Position of INIT field.
	CRC_INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	CRC_INIT_INIT_Msk = 0xffffffff

	// POL: polynomial
	// Position of Polynomialcoefficients field.
	CRC_POL_Polynomialcoefficients_Pos = 0x0
	// Bit mask of Polynomialcoefficients field.
	CRC_POL_Polynomialcoefficients_Msk = 0xffffffff
)

// Constants for LTCD: Liquid crystal display controller
const (
	// SSCR: LTDC Synchronization Size Configuration Register
	// Position of VSH field.
	LCD_SSCR_VSH_Pos = 0x0
	// Bit mask of VSH field.
	LCD_SSCR_VSH_Msk = 0x7ff
	// Position of HSW field.
	LCD_SSCR_HSW_Pos = 0x10
	// Bit mask of HSW field.
	LCD_SSCR_HSW_Msk = 0xfff0000

	// BPCR: LTDC Back Porch Configuration Register
	// Position of AVBP field.
	LCD_BPCR_AVBP_Pos = 0x0
	// Bit mask of AVBP field.
	LCD_BPCR_AVBP_Msk = 0x7ff
	// Position of AHBP field.
	LCD_BPCR_AHBP_Pos = 0x10
	// Bit mask of AHBP field.
	LCD_BPCR_AHBP_Msk = 0xfff0000

	// AWCR: LTDC Active Width Configuration Register
	// Position of AAH field.
	LCD_AWCR_AAH_Pos = 0x0
	// Bit mask of AAH field.
	LCD_AWCR_AAH_Msk = 0x7ff
	// Position of AAW field.
	LCD_AWCR_AAW_Pos = 0x10
	// Bit mask of AAW field.
	LCD_AWCR_AAW_Msk = 0xfff0000

	// TWCR: LTDC Total Width Configuration Register
	// Position of TOTALH field.
	LCD_TWCR_TOTALH_Pos = 0x0
	// Bit mask of TOTALH field.
	LCD_TWCR_TOTALH_Msk = 0x7ff
	// Position of TOTALW field.
	LCD_TWCR_TOTALW_Pos = 0x10
	// Bit mask of TOTALW field.
	LCD_TWCR_TOTALW_Msk = 0xfff0000

	// GCR: LTDC Global Control Register
	// Position of LTDCEN field.
	LCD_GCR_LTDCEN_Pos = 0x0
	// Bit mask of LTDCEN field.
	LCD_GCR_LTDCEN_Msk = 0x1
	// Bit LTDCEN.
	LCD_GCR_LTDCEN = 0x1
	// Position of DBW field.
	LCD_GCR_DBW_Pos = 0x4
	// Bit mask of DBW field.
	LCD_GCR_DBW_Msk = 0x70
	// Position of DGW field.
	LCD_GCR_DGW_Pos = 0x8
	// Bit mask of DGW field.
	LCD_GCR_DGW_Msk = 0x700
	// Position of DRW field.
	LCD_GCR_DRW_Pos = 0xc
	// Bit mask of DRW field.
	LCD_GCR_DRW_Msk = 0x7000
	// Position of DEN field.
	LCD_GCR_DEN_Pos = 0x10
	// Bit mask of DEN field.
	LCD_GCR_DEN_Msk = 0x10000
	// Bit DEN.
	LCD_GCR_DEN = 0x10000
	// Position of PCPOL field.
	LCD_GCR_PCPOL_Pos = 0x1c
	// Bit mask of PCPOL field.
	LCD_GCR_PCPOL_Msk = 0x10000000
	// Bit PCPOL.
	LCD_GCR_PCPOL = 0x10000000
	// Position of DEPOL field.
	LCD_GCR_DEPOL_Pos = 0x1d
	// Bit mask of DEPOL field.
	LCD_GCR_DEPOL_Msk = 0x20000000
	// Bit DEPOL.
	LCD_GCR_DEPOL = 0x20000000
	// Position of VSPOL field.
	LCD_GCR_VSPOL_Pos = 0x1e
	// Bit mask of VSPOL field.
	LCD_GCR_VSPOL_Msk = 0x40000000
	// Bit VSPOL.
	LCD_GCR_VSPOL = 0x40000000
	// Position of HSPOL field.
	LCD_GCR_HSPOL_Pos = 0x1f
	// Bit mask of HSPOL field.
	LCD_GCR_HSPOL_Msk = 0x80000000
	// Bit HSPOL.
	LCD_GCR_HSPOL = 0x80000000

	// SRCR: LTDC Shadow Reload Configuration Register
	// Position of IMR field.
	LCD_SRCR_IMR_Pos = 0x0
	// Bit mask of IMR field.
	LCD_SRCR_IMR_Msk = 0x1
	// Bit IMR.
	LCD_SRCR_IMR = 0x1
	// Position of VBR field.
	LCD_SRCR_VBR_Pos = 0x1
	// Bit mask of VBR field.
	LCD_SRCR_VBR_Msk = 0x2
	// Bit VBR.
	LCD_SRCR_VBR = 0x2

	// BCCR: LTDC Background Color Configuration Register
	// Position of BCBLUE field.
	LCD_BCCR_BCBLUE_Pos = 0x0
	// Bit mask of BCBLUE field.
	LCD_BCCR_BCBLUE_Msk = 0xff
	// Position of BCGREEN field.
	LCD_BCCR_BCGREEN_Pos = 0x8
	// Bit mask of BCGREEN field.
	LCD_BCCR_BCGREEN_Msk = 0xff00
	// Position of BCRED field.
	LCD_BCCR_BCRED_Pos = 0x10
	// Bit mask of BCRED field.
	LCD_BCCR_BCRED_Msk = 0xff0000

	// IER: LTDC Interrupt Enable Register
	// Position of LIE field.
	LCD_IER_LIE_Pos = 0x0
	// Bit mask of LIE field.
	LCD_IER_LIE_Msk = 0x1
	// Bit LIE.
	LCD_IER_LIE = 0x1
	// Position of FUIE field.
	LCD_IER_FUIE_Pos = 0x1
	// Bit mask of FUIE field.
	LCD_IER_FUIE_Msk = 0x2
	// Bit FUIE.
	LCD_IER_FUIE = 0x2
	// Position of TERRIE field.
	LCD_IER_TERRIE_Pos = 0x2
	// Bit mask of TERRIE field.
	LCD_IER_TERRIE_Msk = 0x4
	// Bit TERRIE.
	LCD_IER_TERRIE = 0x4
	// Position of RRIE field.
	LCD_IER_RRIE_Pos = 0x3
	// Bit mask of RRIE field.
	LCD_IER_RRIE_Msk = 0x8
	// Bit RRIE.
	LCD_IER_RRIE = 0x8

	// ISR: LTDC Interrupt Status Register
	// Position of LIF field.
	LCD_ISR_LIF_Pos = 0x0
	// Bit mask of LIF field.
	LCD_ISR_LIF_Msk = 0x1
	// Bit LIF.
	LCD_ISR_LIF = 0x1
	// Position of FUIF field.
	LCD_ISR_FUIF_Pos = 0x1
	// Bit mask of FUIF field.
	LCD_ISR_FUIF_Msk = 0x2
	// Bit FUIF.
	LCD_ISR_FUIF = 0x2
	// Position of TERRIF field.
	LCD_ISR_TERRIF_Pos = 0x2
	// Bit mask of TERRIF field.
	LCD_ISR_TERRIF_Msk = 0x4
	// Bit TERRIF.
	LCD_ISR_TERRIF = 0x4
	// Position of RRIF field.
	LCD_ISR_RRIF_Pos = 0x3
	// Bit mask of RRIF field.
	LCD_ISR_RRIF_Msk = 0x8
	// Bit RRIF.
	LCD_ISR_RRIF = 0x8

	// ICR: LTDC Interrupt Clear Register
	// Position of CLIF field.
	LCD_ICR_CLIF_Pos = 0x0
	// Bit mask of CLIF field.
	LCD_ICR_CLIF_Msk = 0x1
	// Bit CLIF.
	LCD_ICR_CLIF = 0x1
	// Position of CFUIF field.
	LCD_ICR_CFUIF_Pos = 0x1
	// Bit mask of CFUIF field.
	LCD_ICR_CFUIF_Msk = 0x2
	// Bit CFUIF.
	LCD_ICR_CFUIF = 0x2
	// Position of CTERRIF field.
	LCD_ICR_CTERRIF_Pos = 0x2
	// Bit mask of CTERRIF field.
	LCD_ICR_CTERRIF_Msk = 0x4
	// Bit CTERRIF.
	LCD_ICR_CTERRIF = 0x4
	// Position of CRRIF field.
	LCD_ICR_CRRIF_Pos = 0x3
	// Bit mask of CRRIF field.
	LCD_ICR_CRRIF_Msk = 0x8
	// Bit CRRIF.
	LCD_ICR_CRRIF = 0x8

	// LIPCR: LTDC Line Interrupt Position Configuration Register
	// Position of LIPOS field.
	LCD_LIPCR_LIPOS_Pos = 0x0
	// Bit mask of LIPOS field.
	LCD_LIPCR_LIPOS_Msk = 0x7ff

	// CPSR: LTDC Current Position Status Register
	// Position of CYPOS field.
	LCD_CPSR_CYPOS_Pos = 0x0
	// Bit mask of CYPOS field.
	LCD_CPSR_CYPOS_Msk = 0xffff
	// Position of CXPOS field.
	LCD_CPSR_CXPOS_Pos = 0x10
	// Bit mask of CXPOS field.
	LCD_CPSR_CXPOS_Msk = 0xffff0000

	// CDSR: LTDC Current Display Status Register
	// Position of VDES field.
	LCD_CDSR_VDES_Pos = 0x0
	// Bit mask of VDES field.
	LCD_CDSR_VDES_Msk = 0x1
	// Bit VDES.
	LCD_CDSR_VDES = 0x1
	// Position of HDES field.
	LCD_CDSR_HDES_Pos = 0x1
	// Bit mask of HDES field.
	LCD_CDSR_HDES_Msk = 0x2
	// Bit HDES.
	LCD_CDSR_HDES = 0x2
	// Position of VSYNCS field.
	LCD_CDSR_VSYNCS_Pos = 0x2
	// Bit mask of VSYNCS field.
	LCD_CDSR_VSYNCS_Msk = 0x4
	// Bit VSYNCS.
	LCD_CDSR_VSYNCS = 0x4
	// Position of HSYNCS field.
	LCD_CDSR_HSYNCS_Pos = 0x3
	// Bit mask of HSYNCS field.
	LCD_CDSR_HSYNCS_Msk = 0x8
	// Bit HSYNCS.
	LCD_CDSR_HSYNCS = 0x8

	// L1CR: LTDC Layer Control Register
	// Position of LEN field.
	LCD_L1CR_LEN_Pos = 0x0
	// Bit mask of LEN field.
	LCD_L1CR_LEN_Msk = 0x1
	// Bit LEN.
	LCD_L1CR_LEN = 0x1
	// Position of COLKEN field.
	LCD_L1CR_COLKEN_Pos = 0x1
	// Bit mask of COLKEN field.
	LCD_L1CR_COLKEN_Msk = 0x2
	// Bit COLKEN.
	LCD_L1CR_COLKEN = 0x2
	// Position of CLUTEN field.
	LCD_L1CR_CLUTEN_Pos = 0x4
	// Bit mask of CLUTEN field.
	LCD_L1CR_CLUTEN_Msk = 0x10
	// Bit CLUTEN.
	LCD_L1CR_CLUTEN = 0x10

	// L1WHPCR: LTDC Layer Window Horizontal Position Configuration Register
	// Position of WHSTPOS field.
	LCD_L1WHPCR_WHSTPOS_Pos = 0x0
	// Bit mask of WHSTPOS field.
	LCD_L1WHPCR_WHSTPOS_Msk = 0xfff
	// Position of WHSPPOS field.
	LCD_L1WHPCR_WHSPPOS_Pos = 0x10
	// Bit mask of WHSPPOS field.
	LCD_L1WHPCR_WHSPPOS_Msk = 0xfff0000

	// L1WVPCR: LTDC Layer Window Vertical Position Configuration Register
	// Position of WVSTPOS field.
	LCD_L1WVPCR_WVSTPOS_Pos = 0x0
	// Bit mask of WVSTPOS field.
	LCD_L1WVPCR_WVSTPOS_Msk = 0x7ff
	// Position of WVSPPOS field.
	LCD_L1WVPCR_WVSPPOS_Pos = 0x10
	// Bit mask of WVSPPOS field.
	LCD_L1WVPCR_WVSPPOS_Msk = 0x7ff0000

	// L1CKCR: LTDC Layer Color Keying Configuration Register
	// Position of CKBLUE field.
	LCD_L1CKCR_CKBLUE_Pos = 0x0
	// Bit mask of CKBLUE field.
	LCD_L1CKCR_CKBLUE_Msk = 0xff
	// Position of CKGREEN field.
	LCD_L1CKCR_CKGREEN_Pos = 0x8
	// Bit mask of CKGREEN field.
	LCD_L1CKCR_CKGREEN_Msk = 0xff00
	// Position of CKRED field.
	LCD_L1CKCR_CKRED_Pos = 0x10
	// Bit mask of CKRED field.
	LCD_L1CKCR_CKRED_Msk = 0xff0000

	// L1PFCR: LTDC Layer Pixel Format Configuration Register
	// Position of PF field.
	LCD_L1PFCR_PF_Pos = 0x0
	// Bit mask of PF field.
	LCD_L1PFCR_PF_Msk = 0x7

	// L1CACR: LTDC Layer Constant Alpha Configuration Register
	// Position of CONSTA field.
	LCD_L1CACR_CONSTA_Pos = 0x0
	// Bit mask of CONSTA field.
	LCD_L1CACR_CONSTA_Msk = 0xff

	// L1DCCR: LTDC Layer Default Color Configuration Register
	// Position of DCBLUE field.
	LCD_L1DCCR_DCBLUE_Pos = 0x0
	// Bit mask of DCBLUE field.
	LCD_L1DCCR_DCBLUE_Msk = 0xff
	// Position of DCGREEN field.
	LCD_L1DCCR_DCGREEN_Pos = 0x8
	// Bit mask of DCGREEN field.
	LCD_L1DCCR_DCGREEN_Msk = 0xff00
	// Position of DCRED field.
	LCD_L1DCCR_DCRED_Pos = 0x10
	// Bit mask of DCRED field.
	LCD_L1DCCR_DCRED_Msk = 0xff0000
	// Position of DCALPHA field.
	LCD_L1DCCR_DCALPHA_Pos = 0x18
	// Bit mask of DCALPHA field.
	LCD_L1DCCR_DCALPHA_Msk = 0xff000000

	// L1BFCR: LTDC Layer Blending Factors Configuration Register
	// Position of BF2 field.
	LCD_L1BFCR_BF2_Pos = 0x0
	// Bit mask of BF2 field.
	LCD_L1BFCR_BF2_Msk = 0x7
	// Position of BF1 field.
	LCD_L1BFCR_BF1_Pos = 0x8
	// Bit mask of BF1 field.
	LCD_L1BFCR_BF1_Msk = 0x700

	// L1CFBAR: LTDC Layer Color Frame Buffer Address Register
	// Position of CFBADD field.
	LCD_L1CFBAR_CFBADD_Pos = 0x0
	// Bit mask of CFBADD field.
	LCD_L1CFBAR_CFBADD_Msk = 0xffffffff

	// L1CFBLR: LTDC Layer Color Frame Buffer Length Register
	// Position of CFBLL field.
	LCD_L1CFBLR_CFBLL_Pos = 0x0
	// Bit mask of CFBLL field.
	LCD_L1CFBLR_CFBLL_Msk = 0x1fff
	// Position of CFBP field.
	LCD_L1CFBLR_CFBP_Pos = 0x10
	// Bit mask of CFBP field.
	LCD_L1CFBLR_CFBP_Msk = 0x1fff0000

	// L1CFBLNR: LTDC Layer ColorFrame Buffer Line Number Register
	// Position of CFBLNBR field.
	LCD_L1CFBLNR_CFBLNBR_Pos = 0x0
	// Bit mask of CFBLNBR field.
	LCD_L1CFBLNR_CFBLNBR_Msk = 0x7ff

	// L1CLUTWR: LTDC Layerx CLUT Write Register
	// Position of BLUE field.
	LCD_L1CLUTWR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	LCD_L1CLUTWR_BLUE_Msk = 0xff
	// Position of GREEN field.
	LCD_L1CLUTWR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LCD_L1CLUTWR_GREEN_Msk = 0xff00
	// Position of RED field.
	LCD_L1CLUTWR_RED_Pos = 0x10
	// Bit mask of RED field.
	LCD_L1CLUTWR_RED_Msk = 0xff0000
	// Position of CLUTADD field.
	LCD_L1CLUTWR_CLUTADD_Pos = 0x18
	// Bit mask of CLUTADD field.
	LCD_L1CLUTWR_CLUTADD_Msk = 0xff000000

	// L2CR: LTDC Layer Control Register
	// Position of LEN field.
	LCD_L2CR_LEN_Pos = 0x0
	// Bit mask of LEN field.
	LCD_L2CR_LEN_Msk = 0x1
	// Bit LEN.
	LCD_L2CR_LEN = 0x1
	// Position of COLKEN field.
	LCD_L2CR_COLKEN_Pos = 0x1
	// Bit mask of COLKEN field.
	LCD_L2CR_COLKEN_Msk = 0x2
	// Bit COLKEN.
	LCD_L2CR_COLKEN = 0x2
	// Position of CLUTEN field.
	LCD_L2CR_CLUTEN_Pos = 0x4
	// Bit mask of CLUTEN field.
	LCD_L2CR_CLUTEN_Msk = 0x10
	// Bit CLUTEN.
	LCD_L2CR_CLUTEN = 0x10

	// L2WHPCR: LTDC Layerx Window Horizontal Position Configuration Register
	// Position of WHSTPOS field.
	LCD_L2WHPCR_WHSTPOS_Pos = 0x0
	// Bit mask of WHSTPOS field.
	LCD_L2WHPCR_WHSTPOS_Msk = 0xfff
	// Position of WHSPPOS field.
	LCD_L2WHPCR_WHSPPOS_Pos = 0x10
	// Bit mask of WHSPPOS field.
	LCD_L2WHPCR_WHSPPOS_Msk = 0xfff0000

	// L2WVPCR: LTDC Layer Window Vertical Position Configuration Register
	// Position of WVSTPOS field.
	LCD_L2WVPCR_WVSTPOS_Pos = 0x0
	// Bit mask of WVSTPOS field.
	LCD_L2WVPCR_WVSTPOS_Msk = 0x7ff
	// Position of WVSPPOS field.
	LCD_L2WVPCR_WVSPPOS_Pos = 0x10
	// Bit mask of WVSPPOS field.
	LCD_L2WVPCR_WVSPPOS_Msk = 0x7ff0000

	// L2CKCR: LTDC Layer Color Keying Configuration Register
	// Position of CKBLUE field.
	LCD_L2CKCR_CKBLUE_Pos = 0x0
	// Bit mask of CKBLUE field.
	LCD_L2CKCR_CKBLUE_Msk = 0xff
	// Position of CKGREEN field.
	LCD_L2CKCR_CKGREEN_Pos = 0x8
	// Bit mask of CKGREEN field.
	LCD_L2CKCR_CKGREEN_Msk = 0xff00
	// Position of CKRED field.
	LCD_L2CKCR_CKRED_Pos = 0x10
	// Bit mask of CKRED field.
	LCD_L2CKCR_CKRED_Msk = 0xff0000

	// L2PFCR: LTDC Layer Pixel Format Configuration Register
	// Position of PF field.
	LCD_L2PFCR_PF_Pos = 0x0
	// Bit mask of PF field.
	LCD_L2PFCR_PF_Msk = 0x7

	// L2CACR: LTDC Layer Constant Alpha Configuration Register
	// Position of CONSTA field.
	LCD_L2CACR_CONSTA_Pos = 0x0
	// Bit mask of CONSTA field.
	LCD_L2CACR_CONSTA_Msk = 0xff

	// L2DCCR: LTDC Layer Default Color Configuration Register
	// Position of DCBLUE field.
	LCD_L2DCCR_DCBLUE_Pos = 0x0
	// Bit mask of DCBLUE field.
	LCD_L2DCCR_DCBLUE_Msk = 0xff
	// Position of DCGREEN field.
	LCD_L2DCCR_DCGREEN_Pos = 0x8
	// Bit mask of DCGREEN field.
	LCD_L2DCCR_DCGREEN_Msk = 0xff00
	// Position of DCRED field.
	LCD_L2DCCR_DCRED_Pos = 0x10
	// Bit mask of DCRED field.
	LCD_L2DCCR_DCRED_Msk = 0xff0000
	// Position of DCALPHA field.
	LCD_L2DCCR_DCALPHA_Pos = 0x18
	// Bit mask of DCALPHA field.
	LCD_L2DCCR_DCALPHA_Msk = 0xff000000

	// L2BFCR: LTDC Layer Blending Factors Configuration Register
	// Position of BF2 field.
	LCD_L2BFCR_BF2_Pos = 0x0
	// Bit mask of BF2 field.
	LCD_L2BFCR_BF2_Msk = 0x7
	// Position of BF1 field.
	LCD_L2BFCR_BF1_Pos = 0x8
	// Bit mask of BF1 field.
	LCD_L2BFCR_BF1_Msk = 0x700

	// L2CFBAR: LTDC Layer Color Frame Buffer Address Register
	// Position of CFBADD field.
	LCD_L2CFBAR_CFBADD_Pos = 0x0
	// Bit mask of CFBADD field.
	LCD_L2CFBAR_CFBADD_Msk = 0xffffffff

	// L2CFBLR: LTDC Layer Color Frame Buffer Length Register
	// Position of CFBLL field.
	LCD_L2CFBLR_CFBLL_Pos = 0x0
	// Bit mask of CFBLL field.
	LCD_L2CFBLR_CFBLL_Msk = 0x1fff
	// Position of CFBP field.
	LCD_L2CFBLR_CFBP_Pos = 0x10
	// Bit mask of CFBP field.
	LCD_L2CFBLR_CFBP_Msk = 0x1fff0000

	// L2CFBLNR: LTDC Layer ColorFrame Buffer Line Number Register
	// Position of CFBLNBR field.
	LCD_L2CFBLNR_CFBLNBR_Pos = 0x0
	// Bit mask of CFBLNBR field.
	LCD_L2CFBLNR_CFBLNBR_Msk = 0x7ff

	// L2CLUTWR: LTDC Layerx CLUT Write Register
	// Position of BLUE field.
	LCD_L2CLUTWR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	LCD_L2CLUTWR_BLUE_Msk = 0xff
	// Position of GREEN field.
	LCD_L2CLUTWR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LCD_L2CLUTWR_GREEN_Msk = 0xff00
	// Position of RED field.
	LCD_L2CLUTWR_RED_Pos = 0x10
	// Bit mask of RED field.
	LCD_L2CLUTWR_RED_Msk = 0xff0000
	// Position of CLUTADD field.
	LCD_L2CLUTWR_CLUTADD_Pos = 0x18
	// Bit mask of CLUTADD field.
	LCD_L2CLUTWR_CLUTADD_Msk = 0xff000000
)

// Constants for TSC: Touch sensing controller
const (
	// CR: control register
	// Position of CTPH field.
	TSC_CR_CTPH_Pos = 0x1c
	// Bit mask of CTPH field.
	TSC_CR_CTPH_Msk = 0xf0000000
	// Position of CTPL field.
	TSC_CR_CTPL_Pos = 0x18
	// Bit mask of CTPL field.
	TSC_CR_CTPL_Msk = 0xf000000
	// Position of SSD field.
	TSC_CR_SSD_Pos = 0x11
	// Bit mask of SSD field.
	TSC_CR_SSD_Msk = 0xfe0000
	// Position of SSE field.
	TSC_CR_SSE_Pos = 0x10
	// Bit mask of SSE field.
	TSC_CR_SSE_Msk = 0x10000
	// Bit SSE.
	TSC_CR_SSE = 0x10000
	// Position of SSPSC field.
	TSC_CR_SSPSC_Pos = 0xf
	// Bit mask of SSPSC field.
	TSC_CR_SSPSC_Msk = 0x8000
	// Bit SSPSC.
	TSC_CR_SSPSC = 0x8000
	// Position of PGPSC field.
	TSC_CR_PGPSC_Pos = 0xc
	// Bit mask of PGPSC field.
	TSC_CR_PGPSC_Msk = 0x7000
	// Position of MCV field.
	TSC_CR_MCV_Pos = 0x5
	// Bit mask of MCV field.
	TSC_CR_MCV_Msk = 0xe0
	// Position of IODEF field.
	TSC_CR_IODEF_Pos = 0x4
	// Bit mask of IODEF field.
	TSC_CR_IODEF_Msk = 0x10
	// Bit IODEF.
	TSC_CR_IODEF = 0x10
	// Position of SYNCPOL field.
	TSC_CR_SYNCPOL_Pos = 0x3
	// Bit mask of SYNCPOL field.
	TSC_CR_SYNCPOL_Msk = 0x8
	// Bit SYNCPOL.
	TSC_CR_SYNCPOL = 0x8
	// Position of AM field.
	TSC_CR_AM_Pos = 0x2
	// Bit mask of AM field.
	TSC_CR_AM_Msk = 0x4
	// Bit AM.
	TSC_CR_AM = 0x4
	// Position of START field.
	TSC_CR_START_Pos = 0x1
	// Bit mask of START field.
	TSC_CR_START_Msk = 0x2
	// Bit START.
	TSC_CR_START = 0x2
	// Position of TSCE field.
	TSC_CR_TSCE_Pos = 0x0
	// Bit mask of TSCE field.
	TSC_CR_TSCE_Msk = 0x1
	// Bit TSCE.
	TSC_CR_TSCE = 0x1

	// IER: interrupt enable register
	// Position of MCEIE field.
	TSC_IER_MCEIE_Pos = 0x1
	// Bit mask of MCEIE field.
	TSC_IER_MCEIE_Msk = 0x2
	// Bit MCEIE.
	TSC_IER_MCEIE = 0x2
	// Position of EOAIE field.
	TSC_IER_EOAIE_Pos = 0x0
	// Bit mask of EOAIE field.
	TSC_IER_EOAIE_Msk = 0x1
	// Bit EOAIE.
	TSC_IER_EOAIE = 0x1

	// ICR: interrupt clear register
	// Position of MCEIC field.
	TSC_ICR_MCEIC_Pos = 0x1
	// Bit mask of MCEIC field.
	TSC_ICR_MCEIC_Msk = 0x2
	// Bit MCEIC.
	TSC_ICR_MCEIC = 0x2
	// Position of EOAIC field.
	TSC_ICR_EOAIC_Pos = 0x0
	// Bit mask of EOAIC field.
	TSC_ICR_EOAIC_Msk = 0x1
	// Bit EOAIC.
	TSC_ICR_EOAIC = 0x1

	// ISR: interrupt status register
	// Position of MCEF field.
	TSC_ISR_MCEF_Pos = 0x1
	// Bit mask of MCEF field.
	TSC_ISR_MCEF_Msk = 0x2
	// Bit MCEF.
	TSC_ISR_MCEF = 0x2
	// Position of EOAF field.
	TSC_ISR_EOAF_Pos = 0x0
	// Bit mask of EOAF field.
	TSC_ISR_EOAF_Msk = 0x1
	// Bit EOAF.
	TSC_ISR_EOAF = 0x1

	// IOHCR: I/O hysteresis control register
	// Position of G8_IO4 field.
	TSC_IOHCR_G8_IO4_Pos = 0x1f
	// Bit mask of G8_IO4 field.
	TSC_IOHCR_G8_IO4_Msk = 0x80000000
	// Bit G8_IO4.
	TSC_IOHCR_G8_IO4 = 0x80000000
	// Position of G8_IO3 field.
	TSC_IOHCR_G8_IO3_Pos = 0x1e
	// Bit mask of G8_IO3 field.
	TSC_IOHCR_G8_IO3_Msk = 0x40000000
	// Bit G8_IO3.
	TSC_IOHCR_G8_IO3 = 0x40000000
	// Position of G8_IO2 field.
	TSC_IOHCR_G8_IO2_Pos = 0x1d
	// Bit mask of G8_IO2 field.
	TSC_IOHCR_G8_IO2_Msk = 0x20000000
	// Bit G8_IO2.
	TSC_IOHCR_G8_IO2 = 0x20000000
	// Position of G8_IO1 field.
	TSC_IOHCR_G8_IO1_Pos = 0x1c
	// Bit mask of G8_IO1 field.
	TSC_IOHCR_G8_IO1_Msk = 0x10000000
	// Bit G8_IO1.
	TSC_IOHCR_G8_IO1 = 0x10000000
	// Position of G7_IO4 field.
	TSC_IOHCR_G7_IO4_Pos = 0x1b
	// Bit mask of G7_IO4 field.
	TSC_IOHCR_G7_IO4_Msk = 0x8000000
	// Bit G7_IO4.
	TSC_IOHCR_G7_IO4 = 0x8000000
	// Position of G7_IO3 field.
	TSC_IOHCR_G7_IO3_Pos = 0x1a
	// Bit mask of G7_IO3 field.
	TSC_IOHCR_G7_IO3_Msk = 0x4000000
	// Bit G7_IO3.
	TSC_IOHCR_G7_IO3 = 0x4000000
	// Position of G7_IO2 field.
	TSC_IOHCR_G7_IO2_Pos = 0x19
	// Bit mask of G7_IO2 field.
	TSC_IOHCR_G7_IO2_Msk = 0x2000000
	// Bit G7_IO2.
	TSC_IOHCR_G7_IO2 = 0x2000000
	// Position of G7_IO1 field.
	TSC_IOHCR_G7_IO1_Pos = 0x18
	// Bit mask of G7_IO1 field.
	TSC_IOHCR_G7_IO1_Msk = 0x1000000
	// Bit G7_IO1.
	TSC_IOHCR_G7_IO1 = 0x1000000
	// Position of G6_IO4 field.
	TSC_IOHCR_G6_IO4_Pos = 0x17
	// Bit mask of G6_IO4 field.
	TSC_IOHCR_G6_IO4_Msk = 0x800000
	// Bit G6_IO4.
	TSC_IOHCR_G6_IO4 = 0x800000
	// Position of G6_IO3 field.
	TSC_IOHCR_G6_IO3_Pos = 0x16
	// Bit mask of G6_IO3 field.
	TSC_IOHCR_G6_IO3_Msk = 0x400000
	// Bit G6_IO3.
	TSC_IOHCR_G6_IO3 = 0x400000
	// Position of G6_IO2 field.
	TSC_IOHCR_G6_IO2_Pos = 0x15
	// Bit mask of G6_IO2 field.
	TSC_IOHCR_G6_IO2_Msk = 0x200000
	// Bit G6_IO2.
	TSC_IOHCR_G6_IO2 = 0x200000
	// Position of G6_IO1 field.
	TSC_IOHCR_G6_IO1_Pos = 0x14
	// Bit mask of G6_IO1 field.
	TSC_IOHCR_G6_IO1_Msk = 0x100000
	// Bit G6_IO1.
	TSC_IOHCR_G6_IO1 = 0x100000
	// Position of G5_IO4 field.
	TSC_IOHCR_G5_IO4_Pos = 0x13
	// Bit mask of G5_IO4 field.
	TSC_IOHCR_G5_IO4_Msk = 0x80000
	// Bit G5_IO4.
	TSC_IOHCR_G5_IO4 = 0x80000
	// Position of G5_IO3 field.
	TSC_IOHCR_G5_IO3_Pos = 0x12
	// Bit mask of G5_IO3 field.
	TSC_IOHCR_G5_IO3_Msk = 0x40000
	// Bit G5_IO3.
	TSC_IOHCR_G5_IO3 = 0x40000
	// Position of G5_IO2 field.
	TSC_IOHCR_G5_IO2_Pos = 0x11
	// Bit mask of G5_IO2 field.
	TSC_IOHCR_G5_IO2_Msk = 0x20000
	// Bit G5_IO2.
	TSC_IOHCR_G5_IO2 = 0x20000
	// Position of G5_IO1 field.
	TSC_IOHCR_G5_IO1_Pos = 0x10
	// Bit mask of G5_IO1 field.
	TSC_IOHCR_G5_IO1_Msk = 0x10000
	// Bit G5_IO1.
	TSC_IOHCR_G5_IO1 = 0x10000
	// Position of G4_IO4 field.
	TSC_IOHCR_G4_IO4_Pos = 0xf
	// Bit mask of G4_IO4 field.
	TSC_IOHCR_G4_IO4_Msk = 0x8000
	// Bit G4_IO4.
	TSC_IOHCR_G4_IO4 = 0x8000
	// Position of G4_IO3 field.
	TSC_IOHCR_G4_IO3_Pos = 0xe
	// Bit mask of G4_IO3 field.
	TSC_IOHCR_G4_IO3_Msk = 0x4000
	// Bit G4_IO3.
	TSC_IOHCR_G4_IO3 = 0x4000
	// Position of G4_IO2 field.
	TSC_IOHCR_G4_IO2_Pos = 0xd
	// Bit mask of G4_IO2 field.
	TSC_IOHCR_G4_IO2_Msk = 0x2000
	// Bit G4_IO2.
	TSC_IOHCR_G4_IO2 = 0x2000
	// Position of G4_IO1 field.
	TSC_IOHCR_G4_IO1_Pos = 0xc
	// Bit mask of G4_IO1 field.
	TSC_IOHCR_G4_IO1_Msk = 0x1000
	// Bit G4_IO1.
	TSC_IOHCR_G4_IO1 = 0x1000
	// Position of G3_IO4 field.
	TSC_IOHCR_G3_IO4_Pos = 0xb
	// Bit mask of G3_IO4 field.
	TSC_IOHCR_G3_IO4_Msk = 0x800
	// Bit G3_IO4.
	TSC_IOHCR_G3_IO4 = 0x800
	// Position of G3_IO3 field.
	TSC_IOHCR_G3_IO3_Pos = 0xa
	// Bit mask of G3_IO3 field.
	TSC_IOHCR_G3_IO3_Msk = 0x400
	// Bit G3_IO3.
	TSC_IOHCR_G3_IO3 = 0x400
	// Position of G3_IO2 field.
	TSC_IOHCR_G3_IO2_Pos = 0x9
	// Bit mask of G3_IO2 field.
	TSC_IOHCR_G3_IO2_Msk = 0x200
	// Bit G3_IO2.
	TSC_IOHCR_G3_IO2 = 0x200
	// Position of G3_IO1 field.
	TSC_IOHCR_G3_IO1_Pos = 0x8
	// Bit mask of G3_IO1 field.
	TSC_IOHCR_G3_IO1_Msk = 0x100
	// Bit G3_IO1.
	TSC_IOHCR_G3_IO1 = 0x100
	// Position of G2_IO4 field.
	TSC_IOHCR_G2_IO4_Pos = 0x7
	// Bit mask of G2_IO4 field.
	TSC_IOHCR_G2_IO4_Msk = 0x80
	// Bit G2_IO4.
	TSC_IOHCR_G2_IO4 = 0x80
	// Position of G2_IO3 field.
	TSC_IOHCR_G2_IO3_Pos = 0x6
	// Bit mask of G2_IO3 field.
	TSC_IOHCR_G2_IO3_Msk = 0x40
	// Bit G2_IO3.
	TSC_IOHCR_G2_IO3 = 0x40
	// Position of G2_IO2 field.
	TSC_IOHCR_G2_IO2_Pos = 0x5
	// Bit mask of G2_IO2 field.
	TSC_IOHCR_G2_IO2_Msk = 0x20
	// Bit G2_IO2.
	TSC_IOHCR_G2_IO2 = 0x20
	// Position of G2_IO1 field.
	TSC_IOHCR_G2_IO1_Pos = 0x4
	// Bit mask of G2_IO1 field.
	TSC_IOHCR_G2_IO1_Msk = 0x10
	// Bit G2_IO1.
	TSC_IOHCR_G2_IO1 = 0x10
	// Position of G1_IO4 field.
	TSC_IOHCR_G1_IO4_Pos = 0x3
	// Bit mask of G1_IO4 field.
	TSC_IOHCR_G1_IO4_Msk = 0x8
	// Bit G1_IO4.
	TSC_IOHCR_G1_IO4 = 0x8
	// Position of G1_IO3 field.
	TSC_IOHCR_G1_IO3_Pos = 0x2
	// Bit mask of G1_IO3 field.
	TSC_IOHCR_G1_IO3_Msk = 0x4
	// Bit G1_IO3.
	TSC_IOHCR_G1_IO3 = 0x4
	// Position of G1_IO2 field.
	TSC_IOHCR_G1_IO2_Pos = 0x1
	// Bit mask of G1_IO2 field.
	TSC_IOHCR_G1_IO2_Msk = 0x2
	// Bit G1_IO2.
	TSC_IOHCR_G1_IO2 = 0x2
	// Position of G1_IO1 field.
	TSC_IOHCR_G1_IO1_Pos = 0x0
	// Bit mask of G1_IO1 field.
	TSC_IOHCR_G1_IO1_Msk = 0x1
	// Bit G1_IO1.
	TSC_IOHCR_G1_IO1 = 0x1

	// IOASCR: I/O analog switch control register
	// Position of G8_IO4 field.
	TSC_IOASCR_G8_IO4_Pos = 0x1f
	// Bit mask of G8_IO4 field.
	TSC_IOASCR_G8_IO4_Msk = 0x80000000
	// Bit G8_IO4.
	TSC_IOASCR_G8_IO4 = 0x80000000
	// Position of G8_IO3 field.
	TSC_IOASCR_G8_IO3_Pos = 0x1e
	// Bit mask of G8_IO3 field.
	TSC_IOASCR_G8_IO3_Msk = 0x40000000
	// Bit G8_IO3.
	TSC_IOASCR_G8_IO3 = 0x40000000
	// Position of G8_IO2 field.
	TSC_IOASCR_G8_IO2_Pos = 0x1d
	// Bit mask of G8_IO2 field.
	TSC_IOASCR_G8_IO2_Msk = 0x20000000
	// Bit G8_IO2.
	TSC_IOASCR_G8_IO2 = 0x20000000
	// Position of G8_IO1 field.
	TSC_IOASCR_G8_IO1_Pos = 0x1c
	// Bit mask of G8_IO1 field.
	TSC_IOASCR_G8_IO1_Msk = 0x10000000
	// Bit G8_IO1.
	TSC_IOASCR_G8_IO1 = 0x10000000
	// Position of G7_IO4 field.
	TSC_IOASCR_G7_IO4_Pos = 0x1b
	// Bit mask of G7_IO4 field.
	TSC_IOASCR_G7_IO4_Msk = 0x8000000
	// Bit G7_IO4.
	TSC_IOASCR_G7_IO4 = 0x8000000
	// Position of G7_IO3 field.
	TSC_IOASCR_G7_IO3_Pos = 0x1a
	// Bit mask of G7_IO3 field.
	TSC_IOASCR_G7_IO3_Msk = 0x4000000
	// Bit G7_IO3.
	TSC_IOASCR_G7_IO3 = 0x4000000
	// Position of G7_IO2 field.
	TSC_IOASCR_G7_IO2_Pos = 0x19
	// Bit mask of G7_IO2 field.
	TSC_IOASCR_G7_IO2_Msk = 0x2000000
	// Bit G7_IO2.
	TSC_IOASCR_G7_IO2 = 0x2000000
	// Position of G7_IO1 field.
	TSC_IOASCR_G7_IO1_Pos = 0x18
	// Bit mask of G7_IO1 field.
	TSC_IOASCR_G7_IO1_Msk = 0x1000000
	// Bit G7_IO1.
	TSC_IOASCR_G7_IO1 = 0x1000000
	// Position of G6_IO4 field.
	TSC_IOASCR_G6_IO4_Pos = 0x17
	// Bit mask of G6_IO4 field.
	TSC_IOASCR_G6_IO4_Msk = 0x800000
	// Bit G6_IO4.
	TSC_IOASCR_G6_IO4 = 0x800000
	// Position of G6_IO3 field.
	TSC_IOASCR_G6_IO3_Pos = 0x16
	// Bit mask of G6_IO3 field.
	TSC_IOASCR_G6_IO3_Msk = 0x400000
	// Bit G6_IO3.
	TSC_IOASCR_G6_IO3 = 0x400000
	// Position of G6_IO2 field.
	TSC_IOASCR_G6_IO2_Pos = 0x15
	// Bit mask of G6_IO2 field.
	TSC_IOASCR_G6_IO2_Msk = 0x200000
	// Bit G6_IO2.
	TSC_IOASCR_G6_IO2 = 0x200000
	// Position of G6_IO1 field.
	TSC_IOASCR_G6_IO1_Pos = 0x14
	// Bit mask of G6_IO1 field.
	TSC_IOASCR_G6_IO1_Msk = 0x100000
	// Bit G6_IO1.
	TSC_IOASCR_G6_IO1 = 0x100000
	// Position of G5_IO4 field.
	TSC_IOASCR_G5_IO4_Pos = 0x13
	// Bit mask of G5_IO4 field.
	TSC_IOASCR_G5_IO4_Msk = 0x80000
	// Bit G5_IO4.
	TSC_IOASCR_G5_IO4 = 0x80000
	// Position of G5_IO3 field.
	TSC_IOASCR_G5_IO3_Pos = 0x12
	// Bit mask of G5_IO3 field.
	TSC_IOASCR_G5_IO3_Msk = 0x40000
	// Bit G5_IO3.
	TSC_IOASCR_G5_IO3 = 0x40000
	// Position of G5_IO2 field.
	TSC_IOASCR_G5_IO2_Pos = 0x11
	// Bit mask of G5_IO2 field.
	TSC_IOASCR_G5_IO2_Msk = 0x20000
	// Bit G5_IO2.
	TSC_IOASCR_G5_IO2 = 0x20000
	// Position of G5_IO1 field.
	TSC_IOASCR_G5_IO1_Pos = 0x10
	// Bit mask of G5_IO1 field.
	TSC_IOASCR_G5_IO1_Msk = 0x10000
	// Bit G5_IO1.
	TSC_IOASCR_G5_IO1 = 0x10000
	// Position of G4_IO4 field.
	TSC_IOASCR_G4_IO4_Pos = 0xf
	// Bit mask of G4_IO4 field.
	TSC_IOASCR_G4_IO4_Msk = 0x8000
	// Bit G4_IO4.
	TSC_IOASCR_G4_IO4 = 0x8000
	// Position of G4_IO3 field.
	TSC_IOASCR_G4_IO3_Pos = 0xe
	// Bit mask of G4_IO3 field.
	TSC_IOASCR_G4_IO3_Msk = 0x4000
	// Bit G4_IO3.
	TSC_IOASCR_G4_IO3 = 0x4000
	// Position of G4_IO2 field.
	TSC_IOASCR_G4_IO2_Pos = 0xd
	// Bit mask of G4_IO2 field.
	TSC_IOASCR_G4_IO2_Msk = 0x2000
	// Bit G4_IO2.
	TSC_IOASCR_G4_IO2 = 0x2000
	// Position of G4_IO1 field.
	TSC_IOASCR_G4_IO1_Pos = 0xc
	// Bit mask of G4_IO1 field.
	TSC_IOASCR_G4_IO1_Msk = 0x1000
	// Bit G4_IO1.
	TSC_IOASCR_G4_IO1 = 0x1000
	// Position of G3_IO4 field.
	TSC_IOASCR_G3_IO4_Pos = 0xb
	// Bit mask of G3_IO4 field.
	TSC_IOASCR_G3_IO4_Msk = 0x800
	// Bit G3_IO4.
	TSC_IOASCR_G3_IO4 = 0x800
	// Position of G3_IO3 field.
	TSC_IOASCR_G3_IO3_Pos = 0xa
	// Bit mask of G3_IO3 field.
	TSC_IOASCR_G3_IO3_Msk = 0x400
	// Bit G3_IO3.
	TSC_IOASCR_G3_IO3 = 0x400
	// Position of G3_IO2 field.
	TSC_IOASCR_G3_IO2_Pos = 0x9
	// Bit mask of G3_IO2 field.
	TSC_IOASCR_G3_IO2_Msk = 0x200
	// Bit G3_IO2.
	TSC_IOASCR_G3_IO2 = 0x200
	// Position of G3_IO1 field.
	TSC_IOASCR_G3_IO1_Pos = 0x8
	// Bit mask of G3_IO1 field.
	TSC_IOASCR_G3_IO1_Msk = 0x100
	// Bit G3_IO1.
	TSC_IOASCR_G3_IO1 = 0x100
	// Position of G2_IO4 field.
	TSC_IOASCR_G2_IO4_Pos = 0x7
	// Bit mask of G2_IO4 field.
	TSC_IOASCR_G2_IO4_Msk = 0x80
	// Bit G2_IO4.
	TSC_IOASCR_G2_IO4 = 0x80
	// Position of G2_IO3 field.
	TSC_IOASCR_G2_IO3_Pos = 0x6
	// Bit mask of G2_IO3 field.
	TSC_IOASCR_G2_IO3_Msk = 0x40
	// Bit G2_IO3.
	TSC_IOASCR_G2_IO3 = 0x40
	// Position of G2_IO2 field.
	TSC_IOASCR_G2_IO2_Pos = 0x5
	// Bit mask of G2_IO2 field.
	TSC_IOASCR_G2_IO2_Msk = 0x20
	// Bit G2_IO2.
	TSC_IOASCR_G2_IO2 = 0x20
	// Position of G2_IO1 field.
	TSC_IOASCR_G2_IO1_Pos = 0x4
	// Bit mask of G2_IO1 field.
	TSC_IOASCR_G2_IO1_Msk = 0x10
	// Bit G2_IO1.
	TSC_IOASCR_G2_IO1 = 0x10
	// Position of G1_IO4 field.
	TSC_IOASCR_G1_IO4_Pos = 0x3
	// Bit mask of G1_IO4 field.
	TSC_IOASCR_G1_IO4_Msk = 0x8
	// Bit G1_IO4.
	TSC_IOASCR_G1_IO4 = 0x8
	// Position of G1_IO3 field.
	TSC_IOASCR_G1_IO3_Pos = 0x2
	// Bit mask of G1_IO3 field.
	TSC_IOASCR_G1_IO3_Msk = 0x4
	// Bit G1_IO3.
	TSC_IOASCR_G1_IO3 = 0x4
	// Position of G1_IO2 field.
	TSC_IOASCR_G1_IO2_Pos = 0x1
	// Bit mask of G1_IO2 field.
	TSC_IOASCR_G1_IO2_Msk = 0x2
	// Bit G1_IO2.
	TSC_IOASCR_G1_IO2 = 0x2
	// Position of G1_IO1 field.
	TSC_IOASCR_G1_IO1_Pos = 0x0
	// Bit mask of G1_IO1 field.
	TSC_IOASCR_G1_IO1_Msk = 0x1
	// Bit G1_IO1.
	TSC_IOASCR_G1_IO1 = 0x1

	// IOSCR: I/O sampling control register
	// Position of G8_IO4 field.
	TSC_IOSCR_G8_IO4_Pos = 0x1f
	// Bit mask of G8_IO4 field.
	TSC_IOSCR_G8_IO4_Msk = 0x80000000
	// Bit G8_IO4.
	TSC_IOSCR_G8_IO4 = 0x80000000
	// Position of G8_IO3 field.
	TSC_IOSCR_G8_IO3_Pos = 0x1e
	// Bit mask of G8_IO3 field.
	TSC_IOSCR_G8_IO3_Msk = 0x40000000
	// Bit G8_IO3.
	TSC_IOSCR_G8_IO3 = 0x40000000
	// Position of G8_IO2 field.
	TSC_IOSCR_G8_IO2_Pos = 0x1d
	// Bit mask of G8_IO2 field.
	TSC_IOSCR_G8_IO2_Msk = 0x20000000
	// Bit G8_IO2.
	TSC_IOSCR_G8_IO2 = 0x20000000
	// Position of G8_IO1 field.
	TSC_IOSCR_G8_IO1_Pos = 0x1c
	// Bit mask of G8_IO1 field.
	TSC_IOSCR_G8_IO1_Msk = 0x10000000
	// Bit G8_IO1.
	TSC_IOSCR_G8_IO1 = 0x10000000
	// Position of G7_IO4 field.
	TSC_IOSCR_G7_IO4_Pos = 0x1b
	// Bit mask of G7_IO4 field.
	TSC_IOSCR_G7_IO4_Msk = 0x8000000
	// Bit G7_IO4.
	TSC_IOSCR_G7_IO4 = 0x8000000
	// Position of G7_IO3 field.
	TSC_IOSCR_G7_IO3_Pos = 0x1a
	// Bit mask of G7_IO3 field.
	TSC_IOSCR_G7_IO3_Msk = 0x4000000
	// Bit G7_IO3.
	TSC_IOSCR_G7_IO3 = 0x4000000
	// Position of G7_IO2 field.
	TSC_IOSCR_G7_IO2_Pos = 0x19
	// Bit mask of G7_IO2 field.
	TSC_IOSCR_G7_IO2_Msk = 0x2000000
	// Bit G7_IO2.
	TSC_IOSCR_G7_IO2 = 0x2000000
	// Position of G7_IO1 field.
	TSC_IOSCR_G7_IO1_Pos = 0x18
	// Bit mask of G7_IO1 field.
	TSC_IOSCR_G7_IO1_Msk = 0x1000000
	// Bit G7_IO1.
	TSC_IOSCR_G7_IO1 = 0x1000000
	// Position of G6_IO4 field.
	TSC_IOSCR_G6_IO4_Pos = 0x17
	// Bit mask of G6_IO4 field.
	TSC_IOSCR_G6_IO4_Msk = 0x800000
	// Bit G6_IO4.
	TSC_IOSCR_G6_IO4 = 0x800000
	// Position of G6_IO3 field.
	TSC_IOSCR_G6_IO3_Pos = 0x16
	// Bit mask of G6_IO3 field.
	TSC_IOSCR_G6_IO3_Msk = 0x400000
	// Bit G6_IO3.
	TSC_IOSCR_G6_IO3 = 0x400000
	// Position of G6_IO2 field.
	TSC_IOSCR_G6_IO2_Pos = 0x15
	// Bit mask of G6_IO2 field.
	TSC_IOSCR_G6_IO2_Msk = 0x200000
	// Bit G6_IO2.
	TSC_IOSCR_G6_IO2 = 0x200000
	// Position of G6_IO1 field.
	TSC_IOSCR_G6_IO1_Pos = 0x14
	// Bit mask of G6_IO1 field.
	TSC_IOSCR_G6_IO1_Msk = 0x100000
	// Bit G6_IO1.
	TSC_IOSCR_G6_IO1 = 0x100000
	// Position of G5_IO4 field.
	TSC_IOSCR_G5_IO4_Pos = 0x13
	// Bit mask of G5_IO4 field.
	TSC_IOSCR_G5_IO4_Msk = 0x80000
	// Bit G5_IO4.
	TSC_IOSCR_G5_IO4 = 0x80000
	// Position of G5_IO3 field.
	TSC_IOSCR_G5_IO3_Pos = 0x12
	// Bit mask of G5_IO3 field.
	TSC_IOSCR_G5_IO3_Msk = 0x40000
	// Bit G5_IO3.
	TSC_IOSCR_G5_IO3 = 0x40000
	// Position of G5_IO2 field.
	TSC_IOSCR_G5_IO2_Pos = 0x11
	// Bit mask of G5_IO2 field.
	TSC_IOSCR_G5_IO2_Msk = 0x20000
	// Bit G5_IO2.
	TSC_IOSCR_G5_IO2 = 0x20000
	// Position of G5_IO1 field.
	TSC_IOSCR_G5_IO1_Pos = 0x10
	// Bit mask of G5_IO1 field.
	TSC_IOSCR_G5_IO1_Msk = 0x10000
	// Bit G5_IO1.
	TSC_IOSCR_G5_IO1 = 0x10000
	// Position of G4_IO4 field.
	TSC_IOSCR_G4_IO4_Pos = 0xf
	// Bit mask of G4_IO4 field.
	TSC_IOSCR_G4_IO4_Msk = 0x8000
	// Bit G4_IO4.
	TSC_IOSCR_G4_IO4 = 0x8000
	// Position of G4_IO3 field.
	TSC_IOSCR_G4_IO3_Pos = 0xe
	// Bit mask of G4_IO3 field.
	TSC_IOSCR_G4_IO3_Msk = 0x4000
	// Bit G4_IO3.
	TSC_IOSCR_G4_IO3 = 0x4000
	// Position of G4_IO2 field.
	TSC_IOSCR_G4_IO2_Pos = 0xd
	// Bit mask of G4_IO2 field.
	TSC_IOSCR_G4_IO2_Msk = 0x2000
	// Bit G4_IO2.
	TSC_IOSCR_G4_IO2 = 0x2000
	// Position of G4_IO1 field.
	TSC_IOSCR_G4_IO1_Pos = 0xc
	// Bit mask of G4_IO1 field.
	TSC_IOSCR_G4_IO1_Msk = 0x1000
	// Bit G4_IO1.
	TSC_IOSCR_G4_IO1 = 0x1000
	// Position of G3_IO4 field.
	TSC_IOSCR_G3_IO4_Pos = 0xb
	// Bit mask of G3_IO4 field.
	TSC_IOSCR_G3_IO4_Msk = 0x800
	// Bit G3_IO4.
	TSC_IOSCR_G3_IO4 = 0x800
	// Position of G3_IO3 field.
	TSC_IOSCR_G3_IO3_Pos = 0xa
	// Bit mask of G3_IO3 field.
	TSC_IOSCR_G3_IO3_Msk = 0x400
	// Bit G3_IO3.
	TSC_IOSCR_G3_IO3 = 0x400
	// Position of G3_IO2 field.
	TSC_IOSCR_G3_IO2_Pos = 0x9
	// Bit mask of G3_IO2 field.
	TSC_IOSCR_G3_IO2_Msk = 0x200
	// Bit G3_IO2.
	TSC_IOSCR_G3_IO2 = 0x200
	// Position of G3_IO1 field.
	TSC_IOSCR_G3_IO1_Pos = 0x8
	// Bit mask of G3_IO1 field.
	TSC_IOSCR_G3_IO1_Msk = 0x100
	// Bit G3_IO1.
	TSC_IOSCR_G3_IO1 = 0x100
	// Position of G2_IO4 field.
	TSC_IOSCR_G2_IO4_Pos = 0x7
	// Bit mask of G2_IO4 field.
	TSC_IOSCR_G2_IO4_Msk = 0x80
	// Bit G2_IO4.
	TSC_IOSCR_G2_IO4 = 0x80
	// Position of G2_IO3 field.
	TSC_IOSCR_G2_IO3_Pos = 0x6
	// Bit mask of G2_IO3 field.
	TSC_IOSCR_G2_IO3_Msk = 0x40
	// Bit G2_IO3.
	TSC_IOSCR_G2_IO3 = 0x40
	// Position of G2_IO2 field.
	TSC_IOSCR_G2_IO2_Pos = 0x5
	// Bit mask of G2_IO2 field.
	TSC_IOSCR_G2_IO2_Msk = 0x20
	// Bit G2_IO2.
	TSC_IOSCR_G2_IO2 = 0x20
	// Position of G2_IO1 field.
	TSC_IOSCR_G2_IO1_Pos = 0x4
	// Bit mask of G2_IO1 field.
	TSC_IOSCR_G2_IO1_Msk = 0x10
	// Bit G2_IO1.
	TSC_IOSCR_G2_IO1 = 0x10
	// Position of G1_IO4 field.
	TSC_IOSCR_G1_IO4_Pos = 0x3
	// Bit mask of G1_IO4 field.
	TSC_IOSCR_G1_IO4_Msk = 0x8
	// Bit G1_IO4.
	TSC_IOSCR_G1_IO4 = 0x8
	// Position of G1_IO3 field.
	TSC_IOSCR_G1_IO3_Pos = 0x2
	// Bit mask of G1_IO3 field.
	TSC_IOSCR_G1_IO3_Msk = 0x4
	// Bit G1_IO3.
	TSC_IOSCR_G1_IO3 = 0x4
	// Position of G1_IO2 field.
	TSC_IOSCR_G1_IO2_Pos = 0x1
	// Bit mask of G1_IO2 field.
	TSC_IOSCR_G1_IO2_Msk = 0x2
	// Bit G1_IO2.
	TSC_IOSCR_G1_IO2 = 0x2
	// Position of G1_IO1 field.
	TSC_IOSCR_G1_IO1_Pos = 0x0
	// Bit mask of G1_IO1 field.
	TSC_IOSCR_G1_IO1_Msk = 0x1
	// Bit G1_IO1.
	TSC_IOSCR_G1_IO1 = 0x1

	// IOCCR: I/O channel control register
	// Position of G8_IO4 field.
	TSC_IOCCR_G8_IO4_Pos = 0x1f
	// Bit mask of G8_IO4 field.
	TSC_IOCCR_G8_IO4_Msk = 0x80000000
	// Bit G8_IO4.
	TSC_IOCCR_G8_IO4 = 0x80000000
	// Position of G8_IO3 field.
	TSC_IOCCR_G8_IO3_Pos = 0x1e
	// Bit mask of G8_IO3 field.
	TSC_IOCCR_G8_IO3_Msk = 0x40000000
	// Bit G8_IO3.
	TSC_IOCCR_G8_IO3 = 0x40000000
	// Position of G8_IO2 field.
	TSC_IOCCR_G8_IO2_Pos = 0x1d
	// Bit mask of G8_IO2 field.
	TSC_IOCCR_G8_IO2_Msk = 0x20000000
	// Bit G8_IO2.
	TSC_IOCCR_G8_IO2 = 0x20000000
	// Position of G8_IO1 field.
	TSC_IOCCR_G8_IO1_Pos = 0x1c
	// Bit mask of G8_IO1 field.
	TSC_IOCCR_G8_IO1_Msk = 0x10000000
	// Bit G8_IO1.
	TSC_IOCCR_G8_IO1 = 0x10000000
	// Position of G7_IO4 field.
	TSC_IOCCR_G7_IO4_Pos = 0x1b
	// Bit mask of G7_IO4 field.
	TSC_IOCCR_G7_IO4_Msk = 0x8000000
	// Bit G7_IO4.
	TSC_IOCCR_G7_IO4 = 0x8000000
	// Position of G7_IO3 field.
	TSC_IOCCR_G7_IO3_Pos = 0x1a
	// Bit mask of G7_IO3 field.
	TSC_IOCCR_G7_IO3_Msk = 0x4000000
	// Bit G7_IO3.
	TSC_IOCCR_G7_IO3 = 0x4000000
	// Position of G7_IO2 field.
	TSC_IOCCR_G7_IO2_Pos = 0x19
	// Bit mask of G7_IO2 field.
	TSC_IOCCR_G7_IO2_Msk = 0x2000000
	// Bit G7_IO2.
	TSC_IOCCR_G7_IO2 = 0x2000000
	// Position of G7_IO1 field.
	TSC_IOCCR_G7_IO1_Pos = 0x18
	// Bit mask of G7_IO1 field.
	TSC_IOCCR_G7_IO1_Msk = 0x1000000
	// Bit G7_IO1.
	TSC_IOCCR_G7_IO1 = 0x1000000
	// Position of G6_IO4 field.
	TSC_IOCCR_G6_IO4_Pos = 0x17
	// Bit mask of G6_IO4 field.
	TSC_IOCCR_G6_IO4_Msk = 0x800000
	// Bit G6_IO4.
	TSC_IOCCR_G6_IO4 = 0x800000
	// Position of G6_IO3 field.
	TSC_IOCCR_G6_IO3_Pos = 0x16
	// Bit mask of G6_IO3 field.
	TSC_IOCCR_G6_IO3_Msk = 0x400000
	// Bit G6_IO3.
	TSC_IOCCR_G6_IO3 = 0x400000
	// Position of G6_IO2 field.
	TSC_IOCCR_G6_IO2_Pos = 0x15
	// Bit mask of G6_IO2 field.
	TSC_IOCCR_G6_IO2_Msk = 0x200000
	// Bit G6_IO2.
	TSC_IOCCR_G6_IO2 = 0x200000
	// Position of G6_IO1 field.
	TSC_IOCCR_G6_IO1_Pos = 0x14
	// Bit mask of G6_IO1 field.
	TSC_IOCCR_G6_IO1_Msk = 0x100000
	// Bit G6_IO1.
	TSC_IOCCR_G6_IO1 = 0x100000
	// Position of G5_IO4 field.
	TSC_IOCCR_G5_IO4_Pos = 0x13
	// Bit mask of G5_IO4 field.
	TSC_IOCCR_G5_IO4_Msk = 0x80000
	// Bit G5_IO4.
	TSC_IOCCR_G5_IO4 = 0x80000
	// Position of G5_IO3 field.
	TSC_IOCCR_G5_IO3_Pos = 0x12
	// Bit mask of G5_IO3 field.
	TSC_IOCCR_G5_IO3_Msk = 0x40000
	// Bit G5_IO3.
	TSC_IOCCR_G5_IO3 = 0x40000
	// Position of G5_IO2 field.
	TSC_IOCCR_G5_IO2_Pos = 0x11
	// Bit mask of G5_IO2 field.
	TSC_IOCCR_G5_IO2_Msk = 0x20000
	// Bit G5_IO2.
	TSC_IOCCR_G5_IO2 = 0x20000
	// Position of G5_IO1 field.
	TSC_IOCCR_G5_IO1_Pos = 0x10
	// Bit mask of G5_IO1 field.
	TSC_IOCCR_G5_IO1_Msk = 0x10000
	// Bit G5_IO1.
	TSC_IOCCR_G5_IO1 = 0x10000
	// Position of G4_IO4 field.
	TSC_IOCCR_G4_IO4_Pos = 0xf
	// Bit mask of G4_IO4 field.
	TSC_IOCCR_G4_IO4_Msk = 0x8000
	// Bit G4_IO4.
	TSC_IOCCR_G4_IO4 = 0x8000
	// Position of G4_IO3 field.
	TSC_IOCCR_G4_IO3_Pos = 0xe
	// Bit mask of G4_IO3 field.
	TSC_IOCCR_G4_IO3_Msk = 0x4000
	// Bit G4_IO3.
	TSC_IOCCR_G4_IO3 = 0x4000
	// Position of G4_IO2 field.
	TSC_IOCCR_G4_IO2_Pos = 0xd
	// Bit mask of G4_IO2 field.
	TSC_IOCCR_G4_IO2_Msk = 0x2000
	// Bit G4_IO2.
	TSC_IOCCR_G4_IO2 = 0x2000
	// Position of G4_IO1 field.
	TSC_IOCCR_G4_IO1_Pos = 0xc
	// Bit mask of G4_IO1 field.
	TSC_IOCCR_G4_IO1_Msk = 0x1000
	// Bit G4_IO1.
	TSC_IOCCR_G4_IO1 = 0x1000
	// Position of G3_IO4 field.
	TSC_IOCCR_G3_IO4_Pos = 0xb
	// Bit mask of G3_IO4 field.
	TSC_IOCCR_G3_IO4_Msk = 0x800
	// Bit G3_IO4.
	TSC_IOCCR_G3_IO4 = 0x800
	// Position of G3_IO3 field.
	TSC_IOCCR_G3_IO3_Pos = 0xa
	// Bit mask of G3_IO3 field.
	TSC_IOCCR_G3_IO3_Msk = 0x400
	// Bit G3_IO3.
	TSC_IOCCR_G3_IO3 = 0x400
	// Position of G3_IO2 field.
	TSC_IOCCR_G3_IO2_Pos = 0x9
	// Bit mask of G3_IO2 field.
	TSC_IOCCR_G3_IO2_Msk = 0x200
	// Bit G3_IO2.
	TSC_IOCCR_G3_IO2 = 0x200
	// Position of G3_IO1 field.
	TSC_IOCCR_G3_IO1_Pos = 0x8
	// Bit mask of G3_IO1 field.
	TSC_IOCCR_G3_IO1_Msk = 0x100
	// Bit G3_IO1.
	TSC_IOCCR_G3_IO1 = 0x100
	// Position of G2_IO4 field.
	TSC_IOCCR_G2_IO4_Pos = 0x7
	// Bit mask of G2_IO4 field.
	TSC_IOCCR_G2_IO4_Msk = 0x80
	// Bit G2_IO4.
	TSC_IOCCR_G2_IO4 = 0x80
	// Position of G2_IO3 field.
	TSC_IOCCR_G2_IO3_Pos = 0x6
	// Bit mask of G2_IO3 field.
	TSC_IOCCR_G2_IO3_Msk = 0x40
	// Bit G2_IO3.
	TSC_IOCCR_G2_IO3 = 0x40
	// Position of G2_IO2 field.
	TSC_IOCCR_G2_IO2_Pos = 0x5
	// Bit mask of G2_IO2 field.
	TSC_IOCCR_G2_IO2_Msk = 0x20
	// Bit G2_IO2.
	TSC_IOCCR_G2_IO2 = 0x20
	// Position of G2_IO1 field.
	TSC_IOCCR_G2_IO1_Pos = 0x4
	// Bit mask of G2_IO1 field.
	TSC_IOCCR_G2_IO1_Msk = 0x10
	// Bit G2_IO1.
	TSC_IOCCR_G2_IO1 = 0x10
	// Position of G1_IO4 field.
	TSC_IOCCR_G1_IO4_Pos = 0x3
	// Bit mask of G1_IO4 field.
	TSC_IOCCR_G1_IO4_Msk = 0x8
	// Bit G1_IO4.
	TSC_IOCCR_G1_IO4 = 0x8
	// Position of G1_IO3 field.
	TSC_IOCCR_G1_IO3_Pos = 0x2
	// Bit mask of G1_IO3 field.
	TSC_IOCCR_G1_IO3_Msk = 0x4
	// Bit G1_IO3.
	TSC_IOCCR_G1_IO3 = 0x4
	// Position of G1_IO2 field.
	TSC_IOCCR_G1_IO2_Pos = 0x1
	// Bit mask of G1_IO2 field.
	TSC_IOCCR_G1_IO2_Msk = 0x2
	// Bit G1_IO2.
	TSC_IOCCR_G1_IO2 = 0x2
	// Position of G1_IO1 field.
	TSC_IOCCR_G1_IO1_Pos = 0x0
	// Bit mask of G1_IO1 field.
	TSC_IOCCR_G1_IO1_Msk = 0x1
	// Bit G1_IO1.
	TSC_IOCCR_G1_IO1 = 0x1

	// IOGCSR: I/O group control status register
	// Position of G8S field.
	TSC_IOGCSR_G8S_Pos = 0x17
	// Bit mask of G8S field.
	TSC_IOGCSR_G8S_Msk = 0x800000
	// Bit G8S.
	TSC_IOGCSR_G8S = 0x800000
	// Position of G7S field.
	TSC_IOGCSR_G7S_Pos = 0x16
	// Bit mask of G7S field.
	TSC_IOGCSR_G7S_Msk = 0x400000
	// Bit G7S.
	TSC_IOGCSR_G7S = 0x400000
	// Position of G6S field.
	TSC_IOGCSR_G6S_Pos = 0x15
	// Bit mask of G6S field.
	TSC_IOGCSR_G6S_Msk = 0x200000
	// Bit G6S.
	TSC_IOGCSR_G6S = 0x200000
	// Position of G5S field.
	TSC_IOGCSR_G5S_Pos = 0x14
	// Bit mask of G5S field.
	TSC_IOGCSR_G5S_Msk = 0x100000
	// Bit G5S.
	TSC_IOGCSR_G5S = 0x100000
	// Position of G4S field.
	TSC_IOGCSR_G4S_Pos = 0x13
	// Bit mask of G4S field.
	TSC_IOGCSR_G4S_Msk = 0x80000
	// Bit G4S.
	TSC_IOGCSR_G4S = 0x80000
	// Position of G3S field.
	TSC_IOGCSR_G3S_Pos = 0x12
	// Bit mask of G3S field.
	TSC_IOGCSR_G3S_Msk = 0x40000
	// Bit G3S.
	TSC_IOGCSR_G3S = 0x40000
	// Position of G2S field.
	TSC_IOGCSR_G2S_Pos = 0x11
	// Bit mask of G2S field.
	TSC_IOGCSR_G2S_Msk = 0x20000
	// Bit G2S.
	TSC_IOGCSR_G2S = 0x20000
	// Position of G1S field.
	TSC_IOGCSR_G1S_Pos = 0x10
	// Bit mask of G1S field.
	TSC_IOGCSR_G1S_Msk = 0x10000
	// Bit G1S.
	TSC_IOGCSR_G1S = 0x10000
	// Position of G8E field.
	TSC_IOGCSR_G8E_Pos = 0x7
	// Bit mask of G8E field.
	TSC_IOGCSR_G8E_Msk = 0x80
	// Bit G8E.
	TSC_IOGCSR_G8E = 0x80
	// Position of G7E field.
	TSC_IOGCSR_G7E_Pos = 0x6
	// Bit mask of G7E field.
	TSC_IOGCSR_G7E_Msk = 0x40
	// Bit G7E.
	TSC_IOGCSR_G7E = 0x40
	// Position of G6E field.
	TSC_IOGCSR_G6E_Pos = 0x5
	// Bit mask of G6E field.
	TSC_IOGCSR_G6E_Msk = 0x20
	// Bit G6E.
	TSC_IOGCSR_G6E = 0x20
	// Position of G5E field.
	TSC_IOGCSR_G5E_Pos = 0x4
	// Bit mask of G5E field.
	TSC_IOGCSR_G5E_Msk = 0x10
	// Bit G5E.
	TSC_IOGCSR_G5E = 0x10
	// Position of G4E field.
	TSC_IOGCSR_G4E_Pos = 0x3
	// Bit mask of G4E field.
	TSC_IOGCSR_G4E_Msk = 0x8
	// Bit G4E.
	TSC_IOGCSR_G4E = 0x8
	// Position of G3E field.
	TSC_IOGCSR_G3E_Pos = 0x2
	// Bit mask of G3E field.
	TSC_IOGCSR_G3E_Msk = 0x4
	// Bit G3E.
	TSC_IOGCSR_G3E = 0x4
	// Position of G2E field.
	TSC_IOGCSR_G2E_Pos = 0x1
	// Bit mask of G2E field.
	TSC_IOGCSR_G2E_Msk = 0x2
	// Bit G2E.
	TSC_IOGCSR_G2E = 0x2
	// Position of G1E field.
	TSC_IOGCSR_G1E_Pos = 0x0
	// Bit mask of G1E field.
	TSC_IOGCSR_G1E_Msk = 0x1
	// Bit G1E.
	TSC_IOGCSR_G1E = 0x1

	// IOG1CR: I/O group x counter register
	// Position of CNT field.
	TSC_IOGCR_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TSC_IOGCR_CNT_Msk = 0x3fff
)

// Constants for IWDG: Independent watchdog
const (
	// KR: Key register
	// Position of KEY field.
	IWDG_KR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	IWDG_KR_KEY_Msk = 0xffff
	// Enable access to PR, RLR and WINR registers (0x5555)
	IWDG_KR_KEY_Enable = 0x5555
	// Reset the watchdog value (0xAAAA)
	IWDG_KR_KEY_Reset = 0xaaaa
	// Start the watchdog (0xCCCC)
	IWDG_KR_KEY_Start = 0xcccc

	// PR: Prescaler register
	// Position of PR field.
	IWDG_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	IWDG_PR_PR_Msk = 0x7
	// Divider /4
	IWDG_PR_PR_DivideBy4 = 0x0
	// Divider /8
	IWDG_PR_PR_DivideBy8 = 0x1
	// Divider /16
	IWDG_PR_PR_DivideBy16 = 0x2
	// Divider /32
	IWDG_PR_PR_DivideBy32 = 0x3
	// Divider /64
	IWDG_PR_PR_DivideBy64 = 0x4
	// Divider /128
	IWDG_PR_PR_DivideBy128 = 0x5
	// Divider /256
	IWDG_PR_PR_DivideBy256 = 0x6
	// Divider /256
	IWDG_PR_PR_DivideBy256bis = 0x7

	// RLR: Reload register
	// Position of RL field.
	IWDG_RLR_RL_Pos = 0x0
	// Bit mask of RL field.
	IWDG_RLR_RL_Msk = 0xfff

	// SR: Status register
	// Position of WVU field.
	IWDG_SR_WVU_Pos = 0x2
	// Bit mask of WVU field.
	IWDG_SR_WVU_Msk = 0x4
	// Bit WVU.
	IWDG_SR_WVU = 0x4
	// Position of RVU field.
	IWDG_SR_RVU_Pos = 0x1
	// Bit mask of RVU field.
	IWDG_SR_RVU_Msk = 0x2
	// Bit RVU.
	IWDG_SR_RVU = 0x2
	// Position of PVU field.
	IWDG_SR_PVU_Pos = 0x0
	// Bit mask of PVU field.
	IWDG_SR_PVU_Msk = 0x1
	// Bit PVU.
	IWDG_SR_PVU = 0x1

	// WINR: Window register
	// Position of WIN field.
	IWDG_WINR_WIN_Pos = 0x0
	// Bit mask of WIN field.
	IWDG_WINR_WIN_Msk = 0xfff
)

// Constants for WWDG: System window watchdog
const (
	// CR: Control register
	// Position of WDGA field.
	WWDG_CR_WDGA_Pos = 0x7
	// Bit mask of WDGA field.
	WWDG_CR_WDGA_Msk = 0x80
	// Bit WDGA.
	WWDG_CR_WDGA = 0x80
	// Watchdog disabled
	WWDG_CR_WDGA_Disabled = 0x0
	// Watchdog enabled
	WWDG_CR_WDGA_Enabled = 0x1
	// Position of T field.
	WWDG_CR_T_Pos = 0x0
	// Bit mask of T field.
	WWDG_CR_T_Msk = 0x7f

	// CFR: Configuration register
	// Position of EWI field.
	WWDG_CFR_EWI_Pos = 0x9
	// Bit mask of EWI field.
	WWDG_CFR_EWI_Msk = 0x200
	// Bit EWI.
	WWDG_CFR_EWI = 0x200
	// interrupt occurs whenever the counter reaches the value 0x40
	WWDG_CFR_EWI_Enable = 0x1
	// Position of W field.
	WWDG_CFR_W_Pos = 0x0
	// Bit mask of W field.
	WWDG_CFR_W_Msk = 0x7f
	// Position of WDGTB field.
	WWDG_CFR_WDGTB_Pos = 0x7
	// Bit mask of WDGTB field.
	WWDG_CFR_WDGTB_Msk = 0x180
	// Counter clock (PCLK1 div 4096) div 1
	WWDG_CFR_WDGTB_Div1 = 0x0
	// Counter clock (PCLK1 div 4096) div 2
	WWDG_CFR_WDGTB_Div2 = 0x1
	// Counter clock (PCLK1 div 4096) div 4
	WWDG_CFR_WDGTB_Div4 = 0x2
	// Counter clock (PCLK1 div 4096) div 8
	WWDG_CFR_WDGTB_Div8 = 0x3

	// SR: Status register
	// Position of EWIF field.
	WWDG_SR_EWIF_Pos = 0x0
	// Bit mask of EWIF field.
	WWDG_SR_EWIF_Msk = 0x1
	// Bit EWIF.
	WWDG_SR_EWIF = 0x1
	// The EWI Interrupt Service Routine has been triggered
	WWDG_SR_EWIF_Pending = 0x1
	// The EWI Interrupt Service Routine has been serviced
	WWDG_SR_EWIF_Finished = 0x0
)

// Constants for COMP: Comparator
const (
	// COMP1_CSR: Comparator 1 control and status register
	// Position of COMP1_EN field.
	COMP_COMP1_CSR_COMP1_EN_Pos = 0x0
	// Bit mask of COMP1_EN field.
	COMP_COMP1_CSR_COMP1_EN_Msk = 0x1
	// Bit COMP1_EN.
	COMP_COMP1_CSR_COMP1_EN = 0x1
	// Position of COMP1_PWRMODE field.
	COMP_COMP1_CSR_COMP1_PWRMODE_Pos = 0x2
	// Bit mask of COMP1_PWRMODE field.
	COMP_COMP1_CSR_COMP1_PWRMODE_Msk = 0xc
	// Position of COMP1_INMSEL field.
	COMP_COMP1_CSR_COMP1_INMSEL_Pos = 0x4
	// Bit mask of COMP1_INMSEL field.
	COMP_COMP1_CSR_COMP1_INMSEL_Msk = 0x70
	// Position of COMP1_INPSEL field.
	COMP_COMP1_CSR_COMP1_INPSEL_Pos = 0x7
	// Bit mask of COMP1_INPSEL field.
	COMP_COMP1_CSR_COMP1_INPSEL_Msk = 0x80
	// Bit COMP1_INPSEL.
	COMP_COMP1_CSR_COMP1_INPSEL = 0x80
	// Position of COMP1_POLARITY field.
	COMP_COMP1_CSR_COMP1_POLARITY_Pos = 0xf
	// Bit mask of COMP1_POLARITY field.
	COMP_COMP1_CSR_COMP1_POLARITY_Msk = 0x8000
	// Bit COMP1_POLARITY.
	COMP_COMP1_CSR_COMP1_POLARITY = 0x8000
	// Position of COMP1_HYST field.
	COMP_COMP1_CSR_COMP1_HYST_Pos = 0x10
	// Bit mask of COMP1_HYST field.
	COMP_COMP1_CSR_COMP1_HYST_Msk = 0x30000
	// Position of COMP1_BLANKING field.
	COMP_COMP1_CSR_COMP1_BLANKING_Pos = 0x12
	// Bit mask of COMP1_BLANKING field.
	COMP_COMP1_CSR_COMP1_BLANKING_Msk = 0x1c0000
	// Position of COMP1_BRGEN field.
	COMP_COMP1_CSR_COMP1_BRGEN_Pos = 0x16
	// Bit mask of COMP1_BRGEN field.
	COMP_COMP1_CSR_COMP1_BRGEN_Msk = 0x400000
	// Bit COMP1_BRGEN.
	COMP_COMP1_CSR_COMP1_BRGEN = 0x400000
	// Position of COMP1_SCALEN field.
	COMP_COMP1_CSR_COMP1_SCALEN_Pos = 0x17
	// Bit mask of COMP1_SCALEN field.
	COMP_COMP1_CSR_COMP1_SCALEN_Msk = 0x800000
	// Bit COMP1_SCALEN.
	COMP_COMP1_CSR_COMP1_SCALEN = 0x800000
	// Position of COMP1_VALUE field.
	COMP_COMP1_CSR_COMP1_VALUE_Pos = 0x1e
	// Bit mask of COMP1_VALUE field.
	COMP_COMP1_CSR_COMP1_VALUE_Msk = 0x40000000
	// Bit COMP1_VALUE.
	COMP_COMP1_CSR_COMP1_VALUE = 0x40000000
	// Position of COMP1_LOCK field.
	COMP_COMP1_CSR_COMP1_LOCK_Pos = 0x1f
	// Bit mask of COMP1_LOCK field.
	COMP_COMP1_CSR_COMP1_LOCK_Msk = 0x80000000
	// Bit COMP1_LOCK.
	COMP_COMP1_CSR_COMP1_LOCK = 0x80000000

	// COMP2_CSR: Comparator 2 control and status register
	// Position of COMP2_EN field.
	COMP_COMP2_CSR_COMP2_EN_Pos = 0x0
	// Bit mask of COMP2_EN field.
	COMP_COMP2_CSR_COMP2_EN_Msk = 0x1
	// Bit COMP2_EN.
	COMP_COMP2_CSR_COMP2_EN = 0x1
	// Position of COMP2_PWRMODE field.
	COMP_COMP2_CSR_COMP2_PWRMODE_Pos = 0x2
	// Bit mask of COMP2_PWRMODE field.
	COMP_COMP2_CSR_COMP2_PWRMODE_Msk = 0xc
	// Position of COMP2_INMSEL field.
	COMP_COMP2_CSR_COMP2_INMSEL_Pos = 0x4
	// Bit mask of COMP2_INMSEL field.
	COMP_COMP2_CSR_COMP2_INMSEL_Msk = 0x70
	// Position of COMP2_INPSEL field.
	COMP_COMP2_CSR_COMP2_INPSEL_Pos = 0x7
	// Bit mask of COMP2_INPSEL field.
	COMP_COMP2_CSR_COMP2_INPSEL_Msk = 0x80
	// Bit COMP2_INPSEL.
	COMP_COMP2_CSR_COMP2_INPSEL = 0x80
	// Position of COMP2_WINMODE field.
	COMP_COMP2_CSR_COMP2_WINMODE_Pos = 0x9
	// Bit mask of COMP2_WINMODE field.
	COMP_COMP2_CSR_COMP2_WINMODE_Msk = 0x200
	// Bit COMP2_WINMODE.
	COMP_COMP2_CSR_COMP2_WINMODE = 0x200
	// Position of COMP2_POLARITY field.
	COMP_COMP2_CSR_COMP2_POLARITY_Pos = 0xf
	// Bit mask of COMP2_POLARITY field.
	COMP_COMP2_CSR_COMP2_POLARITY_Msk = 0x8000
	// Bit COMP2_POLARITY.
	COMP_COMP2_CSR_COMP2_POLARITY = 0x8000
	// Position of COMP2_HYST field.
	COMP_COMP2_CSR_COMP2_HYST_Pos = 0x10
	// Bit mask of COMP2_HYST field.
	COMP_COMP2_CSR_COMP2_HYST_Msk = 0x30000
	// Position of COMP2_BLANKING field.
	COMP_COMP2_CSR_COMP2_BLANKING_Pos = 0x12
	// Bit mask of COMP2_BLANKING field.
	COMP_COMP2_CSR_COMP2_BLANKING_Msk = 0x1c0000
	// Position of COMP2_BRGEN field.
	COMP_COMP2_CSR_COMP2_BRGEN_Pos = 0x16
	// Bit mask of COMP2_BRGEN field.
	COMP_COMP2_CSR_COMP2_BRGEN_Msk = 0x400000
	// Bit COMP2_BRGEN.
	COMP_COMP2_CSR_COMP2_BRGEN = 0x400000
	// Position of COMP2_SCALEN field.
	COMP_COMP2_CSR_COMP2_SCALEN_Pos = 0x17
	// Bit mask of COMP2_SCALEN field.
	COMP_COMP2_CSR_COMP2_SCALEN_Msk = 0x800000
	// Bit COMP2_SCALEN.
	COMP_COMP2_CSR_COMP2_SCALEN = 0x800000
	// Position of COMP2_VALUE field.
	COMP_COMP2_CSR_COMP2_VALUE_Pos = 0x1e
	// Bit mask of COMP2_VALUE field.
	COMP_COMP2_CSR_COMP2_VALUE_Msk = 0x40000000
	// Bit COMP2_VALUE.
	COMP_COMP2_CSR_COMP2_VALUE = 0x40000000
	// Position of COMP2_LOCK field.
	COMP_COMP2_CSR_COMP2_LOCK_Pos = 0x1f
	// Bit mask of COMP2_LOCK field.
	COMP_COMP2_CSR_COMP2_LOCK_Msk = 0x80000000
	// Bit COMP2_LOCK.
	COMP_COMP2_CSR_COMP2_LOCK = 0x80000000
)

// Constants for FIREWALL: Firewall
const (
	// CSSA: Code segment start address
	// Position of ADD field.
	Firewall_CSSA_ADD_Pos = 0x8
	// Bit mask of ADD field.
	Firewall_CSSA_ADD_Msk = 0xffff00

	// CSL: Code segment length
	// Position of LENG field.
	Firewall_CSL_LENG_Pos = 0x8
	// Bit mask of LENG field.
	Firewall_CSL_LENG_Msk = 0x3fff00

	// NVDSSA: Non-volatile data segment start address
	// Position of ADD field.
	Firewall_NVDSSA_ADD_Pos = 0x8
	// Bit mask of ADD field.
	Firewall_NVDSSA_ADD_Msk = 0xffff00

	// NVDSL: Non-volatile data segment length
	// Position of LENG field.
	Firewall_NVDSL_LENG_Pos = 0x8
	// Bit mask of LENG field.
	Firewall_NVDSL_LENG_Msk = 0x3fff00

	// VDSSA: Volatile data segment start address
	// Position of ADD field.
	Firewall_VDSSA_ADD_Pos = 0x6
	// Bit mask of ADD field.
	Firewall_VDSSA_ADD_Msk = 0xffc0

	// VDSL: Volatile data segment length
	// Position of LENG field.
	Firewall_VDSL_LENG_Pos = 0x6
	// Bit mask of LENG field.
	Firewall_VDSL_LENG_Msk = 0xffc0

	// CR: Configuration register
	// Position of VDE field.
	Firewall_CR_VDE_Pos = 0x2
	// Bit mask of VDE field.
	Firewall_CR_VDE_Msk = 0x4
	// Bit VDE.
	Firewall_CR_VDE = 0x4
	// Volatile data segment cannot be executed if VDS = 0
	Firewall_CR_VDE_NotExecutable = 0x0
	// Volatile data segment is declared executable whatever VDS bit value
	Firewall_CR_VDE_Executable = 0x1
	// Resets volatile data execution bit
	Firewall_CR_VDE_Reset = 0x0
	// Position of VDS field.
	Firewall_CR_VDS_Pos = 0x1
	// Bit mask of VDS field.
	Firewall_CR_VDS_Msk = 0x2
	// Bit VDS.
	Firewall_CR_VDS = 0x2
	// Volatile data segment is not shared and cannot be hit by a non protected executable code when the Firewall is closed
	Firewall_CR_VDS_NotShared = 0x0
	// Volatile data segment is shared with non protected application code
	Firewall_CR_VDS_Shared = 0x1
	// Resets volatile data shared bit
	Firewall_CR_VDS_Reset = 0x0
	// Position of FPA field.
	Firewall_CR_FPA_Pos = 0x0
	// Bit mask of FPA field.
	Firewall_CR_FPA_Msk = 0x1
	// Bit FPA.
	Firewall_CR_FPA = 0x1
	// Any code executed outside the protected segment when the Firewall is opened will generate a system reset
	Firewall_CR_FPA_PreArmReset = 0x0
	// Any code executed outside the protected segment will close the Firewall
	Firewall_CR_FPA_PreArmSet = 0x1
)

// Constants for I2C1: Inter-integrated circuit
const (
	// CR1: Control register 1
	// Position of PE field.
	I2C_CR1_PE_Pos = 0x0
	// Bit mask of PE field.
	I2C_CR1_PE_Msk = 0x1
	// Bit PE.
	I2C_CR1_PE = 0x1
	// Peripheral disabled
	I2C_CR1_PE_Disabled = 0x0
	// Peripheral enabled
	I2C_CR1_PE_Enabled = 0x1
	// Position of TXIE field.
	I2C_CR1_TXIE_Pos = 0x1
	// Bit mask of TXIE field.
	I2C_CR1_TXIE_Msk = 0x2
	// Bit TXIE.
	I2C_CR1_TXIE = 0x2
	// Transmit (TXIS) interrupt disabled
	I2C_CR1_TXIE_Disabled = 0x0
	// Transmit (TXIS) interrupt enabled
	I2C_CR1_TXIE_Enabled = 0x1
	// Position of RXIE field.
	I2C_CR1_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	I2C_CR1_RXIE_Msk = 0x4
	// Bit RXIE.
	I2C_CR1_RXIE = 0x4
	// Receive (RXNE) interrupt disabled
	I2C_CR1_RXIE_Disabled = 0x0
	// Receive (RXNE) interrupt enabled
	I2C_CR1_RXIE_Enabled = 0x1
	// Position of ADDRIE field.
	I2C_CR1_ADDRIE_Pos = 0x3
	// Bit mask of ADDRIE field.
	I2C_CR1_ADDRIE_Msk = 0x8
	// Bit ADDRIE.
	I2C_CR1_ADDRIE = 0x8
	// Address match (ADDR) interrupts disabled
	I2C_CR1_ADDRIE_Disabled = 0x0
	// Address match (ADDR) interrupts enabled
	I2C_CR1_ADDRIE_Enabled = 0x1
	// Position of NACKIE field.
	I2C_CR1_NACKIE_Pos = 0x4
	// Bit mask of NACKIE field.
	I2C_CR1_NACKIE_Msk = 0x10
	// Bit NACKIE.
	I2C_CR1_NACKIE = 0x10
	// Not acknowledge (NACKF) received interrupts disabled
	I2C_CR1_NACKIE_Disabled = 0x0
	// Not acknowledge (NACKF) received interrupts enabled
	I2C_CR1_NACKIE_Enabled = 0x1
	// Position of STOPIE field.
	I2C_CR1_STOPIE_Pos = 0x5
	// Bit mask of STOPIE field.
	I2C_CR1_STOPIE_Msk = 0x20
	// Bit STOPIE.
	I2C_CR1_STOPIE = 0x20
	// Stop detection (STOPF) interrupt disabled
	I2C_CR1_STOPIE_Disabled = 0x0
	// Stop detection (STOPF) interrupt enabled
	I2C_CR1_STOPIE_Enabled = 0x1
	// Position of TCIE field.
	I2C_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	I2C_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	I2C_CR1_TCIE = 0x40
	// Transfer Complete interrupt disabled
	I2C_CR1_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	I2C_CR1_TCIE_Enabled = 0x1
	// Position of ERRIE field.
	I2C_CR1_ERRIE_Pos = 0x7
	// Bit mask of ERRIE field.
	I2C_CR1_ERRIE_Msk = 0x80
	// Bit ERRIE.
	I2C_CR1_ERRIE = 0x80
	// Error detection interrupts disabled
	I2C_CR1_ERRIE_Disabled = 0x0
	// Error detection interrupts enabled
	I2C_CR1_ERRIE_Enabled = 0x1
	// Position of DNF field.
	I2C_CR1_DNF_Pos = 0x8
	// Bit mask of DNF field.
	I2C_CR1_DNF_Msk = 0xf00
	// Digital filter disabled
	I2C_CR1_DNF_NoFilter = 0x0
	// Digital filter enabled and filtering capability up to 1 tI2CCLK
	I2C_CR1_DNF_Filter1 = 0x1
	// Digital filter enabled and filtering capability up to 2 tI2CCLK
	I2C_CR1_DNF_Filter2 = 0x2
	// Digital filter enabled and filtering capability up to 3 tI2CCLK
	I2C_CR1_DNF_Filter3 = 0x3
	// Digital filter enabled and filtering capability up to 4 tI2CCLK
	I2C_CR1_DNF_Filter4 = 0x4
	// Digital filter enabled and filtering capability up to 5 tI2CCLK
	I2C_CR1_DNF_Filter5 = 0x5
	// Digital filter enabled and filtering capability up to 6 tI2CCLK
	I2C_CR1_DNF_Filter6 = 0x6
	// Digital filter enabled and filtering capability up to 7 tI2CCLK
	I2C_CR1_DNF_Filter7 = 0x7
	// Digital filter enabled and filtering capability up to 8 tI2CCLK
	I2C_CR1_DNF_Filter8 = 0x8
	// Digital filter enabled and filtering capability up to 9 tI2CCLK
	I2C_CR1_DNF_Filter9 = 0x9
	// Digital filter enabled and filtering capability up to 10 tI2CCLK
	I2C_CR1_DNF_Filter10 = 0xa
	// Digital filter enabled and filtering capability up to 11 tI2CCLK
	I2C_CR1_DNF_Filter11 = 0xb
	// Digital filter enabled and filtering capability up to 12 tI2CCLK
	I2C_CR1_DNF_Filter12 = 0xc
	// Digital filter enabled and filtering capability up to 13 tI2CCLK
	I2C_CR1_DNF_Filter13 = 0xd
	// Digital filter enabled and filtering capability up to 14 tI2CCLK
	I2C_CR1_DNF_Filter14 = 0xe
	// Digital filter enabled and filtering capability up to 15 tI2CCLK
	I2C_CR1_DNF_Filter15 = 0xf
	// Position of ANFOFF field.
	I2C_CR1_ANFOFF_Pos = 0xc
	// Bit mask of ANFOFF field.
	I2C_CR1_ANFOFF_Msk = 0x1000
	// Bit ANFOFF.
	I2C_CR1_ANFOFF = 0x1000
	// Analog noise filter enabled
	I2C_CR1_ANFOFF_Enabled = 0x0
	// Analog noise filter disabled
	I2C_CR1_ANFOFF_Disabled = 0x1
	// Position of TXDMAEN field.
	I2C_CR1_TXDMAEN_Pos = 0xe
	// Bit mask of TXDMAEN field.
	I2C_CR1_TXDMAEN_Msk = 0x4000
	// Bit TXDMAEN.
	I2C_CR1_TXDMAEN = 0x4000
	// DMA mode disabled for transmission
	I2C_CR1_TXDMAEN_Disabled = 0x0
	// DMA mode enabled for transmission
	I2C_CR1_TXDMAEN_Enabled = 0x1
	// Position of RXDMAEN field.
	I2C_CR1_RXDMAEN_Pos = 0xf
	// Bit mask of RXDMAEN field.
	I2C_CR1_RXDMAEN_Msk = 0x8000
	// Bit RXDMAEN.
	I2C_CR1_RXDMAEN = 0x8000
	// DMA mode disabled for reception
	I2C_CR1_RXDMAEN_Disabled = 0x0
	// DMA mode enabled for reception
	I2C_CR1_RXDMAEN_Enabled = 0x1
	// Position of SBC field.
	I2C_CR1_SBC_Pos = 0x10
	// Bit mask of SBC field.
	I2C_CR1_SBC_Msk = 0x10000
	// Bit SBC.
	I2C_CR1_SBC = 0x10000
	// Slave byte control disabled
	I2C_CR1_SBC_Disabled = 0x0
	// Slave byte control enabled
	I2C_CR1_SBC_Enabled = 0x1
	// Position of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Pos = 0x11
	// Bit mask of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Msk = 0x20000
	// Bit NOSTRETCH.
	I2C_CR1_NOSTRETCH = 0x20000
	// Clock stretching enabled
	I2C_CR1_NOSTRETCH_Enabled = 0x0
	// Clock stretching disabled
	I2C_CR1_NOSTRETCH_Disabled = 0x1
	// Position of WUPEN field.
	I2C_CR1_WUPEN_Pos = 0x12
	// Bit mask of WUPEN field.
	I2C_CR1_WUPEN_Msk = 0x40000
	// Bit WUPEN.
	I2C_CR1_WUPEN = 0x40000
	// Wakeup from Stop mode disabled
	I2C_CR1_WUPEN_Disabled = 0x0
	// Wakeup from Stop mode enabled
	I2C_CR1_WUPEN_Enabled = 0x1
	// Position of GCEN field.
	I2C_CR1_GCEN_Pos = 0x13
	// Bit mask of GCEN field.
	I2C_CR1_GCEN_Msk = 0x80000
	// Bit GCEN.
	I2C_CR1_GCEN = 0x80000
	// General call disabled. Address 0b00000000 is NACKed
	I2C_CR1_GCEN_Disabled = 0x0
	// General call enabled. Address 0b00000000 is ACKed
	I2C_CR1_GCEN_Enabled = 0x1
	// Position of SMBHEN field.
	I2C_CR1_SMBHEN_Pos = 0x14
	// Bit mask of SMBHEN field.
	I2C_CR1_SMBHEN_Msk = 0x100000
	// Bit SMBHEN.
	I2C_CR1_SMBHEN = 0x100000
	// Host address disabled. Address 0b0001000x is NACKed
	I2C_CR1_SMBHEN_Disabled = 0x0
	// Host address enabled. Address 0b0001000x is ACKed
	I2C_CR1_SMBHEN_Enabled = 0x1
	// Position of SMBDEN field.
	I2C_CR1_SMBDEN_Pos = 0x15
	// Bit mask of SMBDEN field.
	I2C_CR1_SMBDEN_Msk = 0x200000
	// Bit SMBDEN.
	I2C_CR1_SMBDEN = 0x200000
	// Device default address disabled. Address 0b1100001x is NACKed
	I2C_CR1_SMBDEN_Disabled = 0x0
	// Device default address enabled. Address 0b1100001x is ACKed
	I2C_CR1_SMBDEN_Enabled = 0x1
	// Position of ALERTEN field.
	I2C_CR1_ALERTEN_Pos = 0x16
	// Bit mask of ALERTEN field.
	I2C_CR1_ALERTEN_Msk = 0x400000
	// Bit ALERTEN.
	I2C_CR1_ALERTEN = 0x400000
	// In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported
	I2C_CR1_ALERTEN_Disabled = 0x0
	// In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported
	I2C_CR1_ALERTEN_Enabled = 0x1
	// Position of PECEN field.
	I2C_CR1_PECEN_Pos = 0x17
	// Bit mask of PECEN field.
	I2C_CR1_PECEN_Msk = 0x800000
	// Bit PECEN.
	I2C_CR1_PECEN = 0x800000
	// PEC calculation disabled
	I2C_CR1_PECEN_Disabled = 0x0
	// PEC calculation enabled
	I2C_CR1_PECEN_Enabled = 0x1

	// CR2: Control register 2
	// Position of PECBYTE field.
	I2C_CR2_PECBYTE_Pos = 0x1a
	// Bit mask of PECBYTE field.
	I2C_CR2_PECBYTE_Msk = 0x4000000
	// Bit PECBYTE.
	I2C_CR2_PECBYTE = 0x4000000
	// No PEC transfer
	I2C_CR2_PECBYTE_NoPec = 0x0
	// PEC transmission/reception is requested
	I2C_CR2_PECBYTE_Pec = 0x1
	// Position of AUTOEND field.
	I2C_CR2_AUTOEND_Pos = 0x19
	// Bit mask of AUTOEND field.
	I2C_CR2_AUTOEND_Msk = 0x2000000
	// Bit AUTOEND.
	I2C_CR2_AUTOEND = 0x2000000
	// Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low
	I2C_CR2_AUTOEND_Software = 0x0
	// Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred
	I2C_CR2_AUTOEND_Automatic = 0x1
	// Position of RELOAD field.
	I2C_CR2_RELOAD_Pos = 0x18
	// Bit mask of RELOAD field.
	I2C_CR2_RELOAD_Msk = 0x1000000
	// Bit RELOAD.
	I2C_CR2_RELOAD = 0x1000000
	// The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)
	I2C_CR2_RELOAD_Completed = 0x0
	// The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)
	I2C_CR2_RELOAD_NotCompleted = 0x1
	// Position of NBYTES field.
	I2C_CR2_NBYTES_Pos = 0x10
	// Bit mask of NBYTES field.
	I2C_CR2_NBYTES_Msk = 0xff0000
	// Position of NACK field.
	I2C_CR2_NACK_Pos = 0xf
	// Bit mask of NACK field.
	I2C_CR2_NACK_Msk = 0x8000
	// Bit NACK.
	I2C_CR2_NACK = 0x8000
	// an ACK is sent after current received byte
	I2C_CR2_NACK_Ack = 0x0
	// a NACK is sent after current received byte
	I2C_CR2_NACK_Nack = 0x1
	// Position of STOP field.
	I2C_CR2_STOP_Pos = 0xe
	// Bit mask of STOP field.
	I2C_CR2_STOP_Msk = 0x4000
	// Bit STOP.
	I2C_CR2_STOP = 0x4000
	// No Stop generation
	I2C_CR2_STOP_NoStop = 0x0
	// Stop generation after current byte transfer
	I2C_CR2_STOP_Stop = 0x1
	// Position of START field.
	I2C_CR2_START_Pos = 0xd
	// Bit mask of START field.
	I2C_CR2_START_Msk = 0x2000
	// Bit START.
	I2C_CR2_START = 0x2000
	// No Start generation
	I2C_CR2_START_NoStart = 0x0
	// Restart/Start generation
	I2C_CR2_START_Start = 0x1
	// Position of HEAD10R field.
	I2C_CR2_HEAD10R_Pos = 0xc
	// Bit mask of HEAD10R field.
	I2C_CR2_HEAD10R_Msk = 0x1000
	// Bit HEAD10R.
	I2C_CR2_HEAD10R = 0x1000
	// The master sends the complete 10 bit slave address read sequence
	I2C_CR2_HEAD10R_Complete = 0x0
	// The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction
	I2C_CR2_HEAD10R_Partial = 0x1
	// Position of ADD10 field.
	I2C_CR2_ADD10_Pos = 0xb
	// Bit mask of ADD10 field.
	I2C_CR2_ADD10_Msk = 0x800
	// Bit ADD10.
	I2C_CR2_ADD10 = 0x800
	// The master operates in 7-bit addressing mode
	I2C_CR2_ADD10_Bit7 = 0x0
	// The master operates in 10-bit addressing mode
	I2C_CR2_ADD10_Bit10 = 0x1
	// Position of RD_WRN field.
	I2C_CR2_RD_WRN_Pos = 0xa
	// Bit mask of RD_WRN field.
	I2C_CR2_RD_WRN_Msk = 0x400
	// Bit RD_WRN.
	I2C_CR2_RD_WRN = 0x400
	// Master requests a write transfer
	I2C_CR2_RD_WRN_Write = 0x0
	// Master requests a read transfer
	I2C_CR2_RD_WRN_Read = 0x1
	// Position of SADD field.
	I2C_CR2_SADD_Pos = 0x0
	// Bit mask of SADD field.
	I2C_CR2_SADD_Msk = 0x3ff

	// OAR1: Own address register 1
	// Position of OA1 field.
	I2C_OAR1_OA1_Pos = 0x0
	// Bit mask of OA1 field.
	I2C_OAR1_OA1_Msk = 0x3ff
	// Position of OA1MODE field.
	I2C_OAR1_OA1MODE_Pos = 0xa
	// Bit mask of OA1MODE field.
	I2C_OAR1_OA1MODE_Msk = 0x400
	// Bit OA1MODE.
	I2C_OAR1_OA1MODE = 0x400
	// Own address 1 is a 7-bit address
	I2C_OAR1_OA1MODE_Bit7 = 0x0
	// Own address 1 is a 10-bit address
	I2C_OAR1_OA1MODE_Bit10 = 0x1
	// Position of OA1EN field.
	I2C_OAR1_OA1EN_Pos = 0xf
	// Bit mask of OA1EN field.
	I2C_OAR1_OA1EN_Msk = 0x8000
	// Bit OA1EN.
	I2C_OAR1_OA1EN = 0x8000
	// Own address 1 disabled. The received slave address OA1 is NACKed
	I2C_OAR1_OA1EN_Disabled = 0x0
	// Own address 1 enabled. The received slave address OA1 is ACKed
	I2C_OAR1_OA1EN_Enabled = 0x1

	// OAR2: Own address register 2
	// Position of OA2 field.
	I2C_OAR2_OA2_Pos = 0x1
	// Bit mask of OA2 field.
	I2C_OAR2_OA2_Msk = 0xfe
	// Position of OA2MSK field.
	I2C_OAR2_OA2MSK_Pos = 0x8
	// Bit mask of OA2MSK field.
	I2C_OAR2_OA2MSK_Msk = 0x700
	// No mask
	I2C_OAR2_OA2MSK_NoMask = 0x0
	// OA2[1] is masked and don’t care. Only OA2[7:2] are compared
	I2C_OAR2_OA2MSK_Mask1 = 0x1
	// OA2[2:1] are masked and don’t care. Only OA2[7:3] are compared
	I2C_OAR2_OA2MSK_Mask2 = 0x2
	// OA2[3:1] are masked and don’t care. Only OA2[7:4] are compared
	I2C_OAR2_OA2MSK_Mask3 = 0x3
	// OA2[4:1] are masked and don’t care. Only OA2[7:5] are compared
	I2C_OAR2_OA2MSK_Mask4 = 0x4
	// OA2[5:1] are masked and don’t care. Only OA2[7:6] are compared
	I2C_OAR2_OA2MSK_Mask5 = 0x5
	// OA2[6:1] are masked and don’t care. Only OA2[7] is compared.
	I2C_OAR2_OA2MSK_Mask6 = 0x6
	// OA2[7:1] are masked and don’t care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged
	I2C_OAR2_OA2MSK_Mask7 = 0x7
	// Position of OA2EN field.
	I2C_OAR2_OA2EN_Pos = 0xf
	// Bit mask of OA2EN field.
	I2C_OAR2_OA2EN_Msk = 0x8000
	// Bit OA2EN.
	I2C_OAR2_OA2EN = 0x8000
	// Own address 2 disabled. The received slave address OA2 is NACKed
	I2C_OAR2_OA2EN_Disabled = 0x0
	// Own address 2 enabled. The received slave address OA2 is ACKed
	I2C_OAR2_OA2EN_Enabled = 0x1

	// TIMINGR: Timing register
	// Position of SCLL field.
	I2C_TIMINGR_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_TIMINGR_SCLL_Msk = 0xff
	// Position of SCLH field.
	I2C_TIMINGR_SCLH_Pos = 0x8
	// Bit mask of SCLH field.
	I2C_TIMINGR_SCLH_Msk = 0xff00
	// Position of SDADEL field.
	I2C_TIMINGR_SDADEL_Pos = 0x10
	// Bit mask of SDADEL field.
	I2C_TIMINGR_SDADEL_Msk = 0xf0000
	// Position of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Pos = 0x14
	// Bit mask of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Msk = 0xf00000
	// Position of PRESC field.
	I2C_TIMINGR_PRESC_Pos = 0x1c
	// Bit mask of PRESC field.
	I2C_TIMINGR_PRESC_Msk = 0xf0000000

	// TIMEOUTR: Status register 1
	// Position of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Pos = 0x0
	// Bit mask of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Msk = 0xfff
	// Position of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Pos = 0xc
	// Bit mask of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Msk = 0x1000
	// Bit TIDLE.
	I2C_TIMEOUTR_TIDLE = 0x1000
	// TIMEOUTA is used to detect SCL low timeout
	I2C_TIMEOUTR_TIDLE_Disabled = 0x0
	// TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
	I2C_TIMEOUTR_TIDLE_Enabled = 0x1
	// Position of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Pos = 0xf
	// Bit mask of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Msk = 0x8000
	// Bit TIMOUTEN.
	I2C_TIMEOUTR_TIMOUTEN = 0x8000
	// SCL timeout detection is disabled
	I2C_TIMEOUTR_TIMOUTEN_Disabled = 0x0
	// SCL timeout detection is enabled
	I2C_TIMEOUTR_TIMOUTEN_Enabled = 0x1
	// Position of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Pos = 0x10
	// Bit mask of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Msk = 0xfff0000
	// Position of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Pos = 0x1f
	// Bit mask of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Msk = 0x80000000
	// Bit TEXTEN.
	I2C_TIMEOUTR_TEXTEN = 0x80000000
	// Extended clock timeout detection is disabled
	I2C_TIMEOUTR_TEXTEN_Disabled = 0x0
	// Extended clock timeout detection is enabled
	I2C_TIMEOUTR_TEXTEN_Enabled = 0x1

	// ISR: Interrupt and Status register
	// Position of ADDCODE field.
	I2C_ISR_ADDCODE_Pos = 0x11
	// Bit mask of ADDCODE field.
	I2C_ISR_ADDCODE_Msk = 0xfe0000
	// Position of DIR field.
	I2C_ISR_DIR_Pos = 0x10
	// Bit mask of DIR field.
	I2C_ISR_DIR_Msk = 0x10000
	// Bit DIR.
	I2C_ISR_DIR = 0x10000
	// Write transfer, slave enters receiver mode
	I2C_ISR_DIR_Write = 0x0
	// Read transfer, slave enters transmitter mode
	I2C_ISR_DIR_Read = 0x1
	// Position of BUSY field.
	I2C_ISR_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	I2C_ISR_BUSY_Msk = 0x8000
	// Bit BUSY.
	I2C_ISR_BUSY = 0x8000
	// No communication is in progress on the bus
	I2C_ISR_BUSY_NotBusy = 0x0
	// A communication is in progress on the bus
	I2C_ISR_BUSY_Busy = 0x1
	// Position of ALERT field.
	I2C_ISR_ALERT_Pos = 0xd
	// Bit mask of ALERT field.
	I2C_ISR_ALERT_Msk = 0x2000
	// Bit ALERT.
	I2C_ISR_ALERT = 0x2000
	// SMBA alert is not detected
	I2C_ISR_ALERT_NoAlert = 0x0
	// SMBA alert event is detected on SMBA pin
	I2C_ISR_ALERT_Alert = 0x1
	// Position of TIMEOUT field.
	I2C_ISR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	I2C_ISR_TIMEOUT_Msk = 0x1000
	// Bit TIMEOUT.
	I2C_ISR_TIMEOUT = 0x1000
	// No timeout occured
	I2C_ISR_TIMEOUT_NoTimeout = 0x0
	// Timeout occured
	I2C_ISR_TIMEOUT_Timeout = 0x1
	// Position of PECERR field.
	I2C_ISR_PECERR_Pos = 0xb
	// Bit mask of PECERR field.
	I2C_ISR_PECERR_Msk = 0x800
	// Bit PECERR.
	I2C_ISR_PECERR = 0x800
	// Received PEC does match with PEC register
	I2C_ISR_PECERR_Match = 0x0
	// Received PEC does not match with PEC register
	I2C_ISR_PECERR_NoMatch = 0x1
	// Position of OVR field.
	I2C_ISR_OVR_Pos = 0xa
	// Bit mask of OVR field.
	I2C_ISR_OVR_Msk = 0x400
	// Bit OVR.
	I2C_ISR_OVR = 0x400
	// No overrun/underrun error occurs
	I2C_ISR_OVR_NoOverrun = 0x0
	// slave mode with NOSTRETCH=1, when an overrun/underrun error occurs
	I2C_ISR_OVR_Overrun = 0x1
	// Position of ARLO field.
	I2C_ISR_ARLO_Pos = 0x9
	// Bit mask of ARLO field.
	I2C_ISR_ARLO_Msk = 0x200
	// Bit ARLO.
	I2C_ISR_ARLO = 0x200
	// No arbitration lost
	I2C_ISR_ARLO_NotLost = 0x0
	// Arbitration lost
	I2C_ISR_ARLO_Lost = 0x1
	// Position of BERR field.
	I2C_ISR_BERR_Pos = 0x8
	// Bit mask of BERR field.
	I2C_ISR_BERR_Msk = 0x100
	// Bit BERR.
	I2C_ISR_BERR = 0x100
	// No bus error
	I2C_ISR_BERR_NoError = 0x0
	// Misplaced Start and Stop condition is detected
	I2C_ISR_BERR_Error = 0x1
	// Position of TCR field.
	I2C_ISR_TCR_Pos = 0x7
	// Bit mask of TCR field.
	I2C_ISR_TCR_Msk = 0x80
	// Bit TCR.
	I2C_ISR_TCR = 0x80
	// Transfer is not complete
	I2C_ISR_TCR_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TCR_Complete = 0x1
	// Position of TC field.
	I2C_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	I2C_ISR_TC_Msk = 0x40
	// Bit TC.
	I2C_ISR_TC = 0x40
	// Transfer is not complete
	I2C_ISR_TC_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TC_Complete = 0x1
	// Position of STOPF field.
	I2C_ISR_STOPF_Pos = 0x5
	// Bit mask of STOPF field.
	I2C_ISR_STOPF_Msk = 0x20
	// Bit STOPF.
	I2C_ISR_STOPF = 0x20
	// No Stop condition detected
	I2C_ISR_STOPF_NoStop = 0x0
	// Stop condition detected
	I2C_ISR_STOPF_Stop = 0x1
	// Position of NACKF field.
	I2C_ISR_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	I2C_ISR_NACKF_Msk = 0x10
	// Bit NACKF.
	I2C_ISR_NACKF = 0x10
	// No NACK has been received
	I2C_ISR_NACKF_NoNack = 0x0
	// NACK has been received
	I2C_ISR_NACKF_Nack = 0x1
	// Position of ADDR field.
	I2C_ISR_ADDR_Pos = 0x3
	// Bit mask of ADDR field.
	I2C_ISR_ADDR_Msk = 0x8
	// Bit ADDR.
	I2C_ISR_ADDR = 0x8
	// Adress mismatched or not received
	I2C_ISR_ADDR_NotMatch = 0x0
	// Received slave address matched with one of the enabled slave addresses
	I2C_ISR_ADDR_Match = 0x1
	// Position of RXNE field.
	I2C_ISR_RXNE_Pos = 0x2
	// Bit mask of RXNE field.
	I2C_ISR_RXNE_Msk = 0x4
	// Bit RXNE.
	I2C_ISR_RXNE = 0x4
	// The RXDR register is empty
	I2C_ISR_RXNE_Empty = 0x0
	// Received data is copied into the RXDR register, and is ready to be read
	I2C_ISR_RXNE_NotEmpty = 0x1
	// Position of TXIS field.
	I2C_ISR_TXIS_Pos = 0x1
	// Bit mask of TXIS field.
	I2C_ISR_TXIS_Msk = 0x2
	// Bit TXIS.
	I2C_ISR_TXIS = 0x2
	// The TXDR register is not empty
	I2C_ISR_TXIS_NotEmpty = 0x0
	// The TXDR register is empty and the data to be transmitted must be written in the TXDR register
	I2C_ISR_TXIS_Empty = 0x1
	// Position of TXE field.
	I2C_ISR_TXE_Pos = 0x0
	// Bit mask of TXE field.
	I2C_ISR_TXE_Msk = 0x1
	// Bit TXE.
	I2C_ISR_TXE = 0x1
	// TXDR register not empty
	I2C_ISR_TXE_NotEmpty = 0x0
	// TXDR register empty
	I2C_ISR_TXE_Empty = 0x1

	// ICR: Interrupt clear register
	// Position of ALERTCF field.
	I2C_ICR_ALERTCF_Pos = 0xd
	// Bit mask of ALERTCF field.
	I2C_ICR_ALERTCF_Msk = 0x2000
	// Bit ALERTCF.
	I2C_ICR_ALERTCF = 0x2000
	// Clears the ALERT flag in ISR register
	I2C_ICR_ALERTCF_Clear = 0x1
	// Position of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Pos = 0xc
	// Bit mask of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Msk = 0x1000
	// Bit TIMOUTCF.
	I2C_ICR_TIMOUTCF = 0x1000
	// Clears the TIMOUT flag in ISR register
	I2C_ICR_TIMOUTCF_Clear = 0x1
	// Position of PECCF field.
	I2C_ICR_PECCF_Pos = 0xb
	// Bit mask of PECCF field.
	I2C_ICR_PECCF_Msk = 0x800
	// Bit PECCF.
	I2C_ICR_PECCF = 0x800
	// Clears the PEC flag in ISR register
	I2C_ICR_PECCF_Clear = 0x1
	// Position of OVRCF field.
	I2C_ICR_OVRCF_Pos = 0xa
	// Bit mask of OVRCF field.
	I2C_ICR_OVRCF_Msk = 0x400
	// Bit OVRCF.
	I2C_ICR_OVRCF = 0x400
	// Clears the OVR flag in ISR register
	I2C_ICR_OVRCF_Clear = 0x1
	// Position of ARLOCF field.
	I2C_ICR_ARLOCF_Pos = 0x9
	// Bit mask of ARLOCF field.
	I2C_ICR_ARLOCF_Msk = 0x200
	// Bit ARLOCF.
	I2C_ICR_ARLOCF = 0x200
	// Clears the ARLO flag in ISR register
	I2C_ICR_ARLOCF_Clear = 0x1
	// Position of BERRCF field.
	I2C_ICR_BERRCF_Pos = 0x8
	// Bit mask of BERRCF field.
	I2C_ICR_BERRCF_Msk = 0x100
	// Bit BERRCF.
	I2C_ICR_BERRCF = 0x100
	// Clears the BERR flag in ISR register
	I2C_ICR_BERRCF_Clear = 0x1
	// Position of STOPCF field.
	I2C_ICR_STOPCF_Pos = 0x5
	// Bit mask of STOPCF field.
	I2C_ICR_STOPCF_Msk = 0x20
	// Bit STOPCF.
	I2C_ICR_STOPCF = 0x20
	// Clears the STOP flag in ISR register
	I2C_ICR_STOPCF_Clear = 0x1
	// Position of NACKCF field.
	I2C_ICR_NACKCF_Pos = 0x4
	// Bit mask of NACKCF field.
	I2C_ICR_NACKCF_Msk = 0x10
	// Bit NACKCF.
	I2C_ICR_NACKCF = 0x10
	// Clears the NACK flag in ISR register
	I2C_ICR_NACKCF_Clear = 0x1
	// Position of ADDRCF field.
	I2C_ICR_ADDRCF_Pos = 0x3
	// Bit mask of ADDRCF field.
	I2C_ICR_ADDRCF_Msk = 0x8
	// Bit ADDRCF.
	I2C_ICR_ADDRCF = 0x8
	// Clears the ADDR flag in ISR register
	I2C_ICR_ADDRCF_Clear = 0x1

	// PECR: PEC register
	// Position of PEC field.
	I2C_PECR_PEC_Pos = 0x0
	// Bit mask of PEC field.
	I2C_PECR_PEC_Msk = 0xff

	// RXDR: Receive data register
	// Position of RXDATA field.
	I2C_RXDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	I2C_RXDR_RXDATA_Msk = 0xff

	// TXDR: Transmit data register
	// Position of TXDATA field.
	I2C_TXDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	I2C_TXDR_TXDATA_Msk = 0xff
)

// Constants for FLASH: Flash
const (
	// ACR: Access control register
	// Position of LATENCY field.
	Flash_ACR_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	Flash_ACR_LATENCY_Msk = 0x7
	// Position of PRFTEN field.
	Flash_ACR_PRFTEN_Pos = 0x8
	// Bit mask of PRFTEN field.
	Flash_ACR_PRFTEN_Msk = 0x100
	// Bit PRFTEN.
	Flash_ACR_PRFTEN = 0x100
	// Position of ICEN field.
	Flash_ACR_ICEN_Pos = 0x9
	// Bit mask of ICEN field.
	Flash_ACR_ICEN_Msk = 0x200
	// Bit ICEN.
	Flash_ACR_ICEN = 0x200
	// Position of DCEN field.
	Flash_ACR_DCEN_Pos = 0xa
	// Bit mask of DCEN field.
	Flash_ACR_DCEN_Msk = 0x400
	// Bit DCEN.
	Flash_ACR_DCEN = 0x400
	// Position of ICRST field.
	Flash_ACR_ICRST_Pos = 0xb
	// Bit mask of ICRST field.
	Flash_ACR_ICRST_Msk = 0x800
	// Bit ICRST.
	Flash_ACR_ICRST = 0x800
	// Position of DCRST field.
	Flash_ACR_DCRST_Pos = 0xc
	// Bit mask of DCRST field.
	Flash_ACR_DCRST_Msk = 0x1000
	// Bit DCRST.
	Flash_ACR_DCRST = 0x1000
	// Position of RUN_PD field.
	Flash_ACR_RUN_PD_Pos = 0xd
	// Bit mask of RUN_PD field.
	Flash_ACR_RUN_PD_Msk = 0x2000
	// Bit RUN_PD.
	Flash_ACR_RUN_PD = 0x2000
	// Position of SLEEP_PD field.
	Flash_ACR_SLEEP_PD_Pos = 0xe
	// Bit mask of SLEEP_PD field.
	Flash_ACR_SLEEP_PD_Msk = 0x4000
	// Bit SLEEP_PD.
	Flash_ACR_SLEEP_PD = 0x4000

	// PDKEYR: Power down key register
	// Position of PDKEYR field.
	Flash_PDKEYR_PDKEYR_Pos = 0x0
	// Bit mask of PDKEYR field.
	Flash_PDKEYR_PDKEYR_Msk = 0xffffffff

	// KEYR: Flash key register
	// Position of KEYR field.
	Flash_KEYR_KEYR_Pos = 0x0
	// Bit mask of KEYR field.
	Flash_KEYR_KEYR_Msk = 0xffffffff

	// OPTKEYR: Option byte key register
	// Position of OPTKEYR field.
	Flash_OPTKEYR_OPTKEYR_Pos = 0x0
	// Bit mask of OPTKEYR field.
	Flash_OPTKEYR_OPTKEYR_Msk = 0xffffffff

	// SR: Status register
	// Position of EOP field.
	Flash_SR_EOP_Pos = 0x0
	// Bit mask of EOP field.
	Flash_SR_EOP_Msk = 0x1
	// Bit EOP.
	Flash_SR_EOP = 0x1
	// Position of OPERR field.
	Flash_SR_OPERR_Pos = 0x1
	// Bit mask of OPERR field.
	Flash_SR_OPERR_Msk = 0x2
	// Bit OPERR.
	Flash_SR_OPERR = 0x2
	// Position of PROGERR field.
	Flash_SR_PROGERR_Pos = 0x3
	// Bit mask of PROGERR field.
	Flash_SR_PROGERR_Msk = 0x8
	// Bit PROGERR.
	Flash_SR_PROGERR = 0x8
	// Position of WRPERR field.
	Flash_SR_WRPERR_Pos = 0x4
	// Bit mask of WRPERR field.
	Flash_SR_WRPERR_Msk = 0x10
	// Bit WRPERR.
	Flash_SR_WRPERR = 0x10
	// Position of PGAERR field.
	Flash_SR_PGAERR_Pos = 0x5
	// Bit mask of PGAERR field.
	Flash_SR_PGAERR_Msk = 0x20
	// Bit PGAERR.
	Flash_SR_PGAERR = 0x20
	// Position of SIZERR field.
	Flash_SR_SIZERR_Pos = 0x6
	// Bit mask of SIZERR field.
	Flash_SR_SIZERR_Msk = 0x40
	// Bit SIZERR.
	Flash_SR_SIZERR = 0x40
	// Position of PGSERR field.
	Flash_SR_PGSERR_Pos = 0x7
	// Bit mask of PGSERR field.
	Flash_SR_PGSERR_Msk = 0x80
	// Bit PGSERR.
	Flash_SR_PGSERR = 0x80
	// Position of MISERR field.
	Flash_SR_MISERR_Pos = 0x8
	// Bit mask of MISERR field.
	Flash_SR_MISERR_Msk = 0x100
	// Bit MISERR.
	Flash_SR_MISERR = 0x100
	// Position of FASTERR field.
	Flash_SR_FASTERR_Pos = 0x9
	// Bit mask of FASTERR field.
	Flash_SR_FASTERR_Msk = 0x200
	// Bit FASTERR.
	Flash_SR_FASTERR = 0x200
	// Position of RDERR field.
	Flash_SR_RDERR_Pos = 0xe
	// Bit mask of RDERR field.
	Flash_SR_RDERR_Msk = 0x4000
	// Bit RDERR.
	Flash_SR_RDERR = 0x4000
	// Position of OPTVERR field.
	Flash_SR_OPTVERR_Pos = 0xf
	// Bit mask of OPTVERR field.
	Flash_SR_OPTVERR_Msk = 0x8000
	// Bit OPTVERR.
	Flash_SR_OPTVERR = 0x8000
	// Position of BSY field.
	Flash_SR_BSY_Pos = 0x10
	// Bit mask of BSY field.
	Flash_SR_BSY_Msk = 0x10000
	// Bit BSY.
	Flash_SR_BSY = 0x10000

	// CR: Flash control register
	// Position of PG field.
	Flash_CR_PG_Pos = 0x0
	// Bit mask of PG field.
	Flash_CR_PG_Msk = 0x1
	// Bit PG.
	Flash_CR_PG = 0x1
	// Position of PER field.
	Flash_CR_PER_Pos = 0x1
	// Bit mask of PER field.
	Flash_CR_PER_Msk = 0x2
	// Bit PER.
	Flash_CR_PER = 0x2
	// Position of MER1 field.
	Flash_CR_MER1_Pos = 0x2
	// Bit mask of MER1 field.
	Flash_CR_MER1_Msk = 0x4
	// Bit MER1.
	Flash_CR_MER1 = 0x4
	// Position of PNB field.
	Flash_CR_PNB_Pos = 0x3
	// Bit mask of PNB field.
	Flash_CR_PNB_Msk = 0x7f8
	// Position of BKER field.
	Flash_CR_BKER_Pos = 0xb
	// Bit mask of BKER field.
	Flash_CR_BKER_Msk = 0x800
	// Bit BKER.
	Flash_CR_BKER = 0x800
	// Position of MER2 field.
	Flash_CR_MER2_Pos = 0xf
	// Bit mask of MER2 field.
	Flash_CR_MER2_Msk = 0x8000
	// Bit MER2.
	Flash_CR_MER2 = 0x8000
	// Position of START field.
	Flash_CR_START_Pos = 0x10
	// Bit mask of START field.
	Flash_CR_START_Msk = 0x10000
	// Bit START.
	Flash_CR_START = 0x10000
	// Position of OPTSTRT field.
	Flash_CR_OPTSTRT_Pos = 0x11
	// Bit mask of OPTSTRT field.
	Flash_CR_OPTSTRT_Msk = 0x20000
	// Bit OPTSTRT.
	Flash_CR_OPTSTRT = 0x20000
	// Position of FSTPG field.
	Flash_CR_FSTPG_Pos = 0x12
	// Bit mask of FSTPG field.
	Flash_CR_FSTPG_Msk = 0x40000
	// Bit FSTPG.
	Flash_CR_FSTPG = 0x40000
	// Position of EOPIE field.
	Flash_CR_EOPIE_Pos = 0x18
	// Bit mask of EOPIE field.
	Flash_CR_EOPIE_Msk = 0x1000000
	// Bit EOPIE.
	Flash_CR_EOPIE = 0x1000000
	// Position of ERRIE field.
	Flash_CR_ERRIE_Pos = 0x19
	// Bit mask of ERRIE field.
	Flash_CR_ERRIE_Msk = 0x2000000
	// Bit ERRIE.
	Flash_CR_ERRIE = 0x2000000
	// Position of RDERRIE field.
	Flash_CR_RDERRIE_Pos = 0x1a
	// Bit mask of RDERRIE field.
	Flash_CR_RDERRIE_Msk = 0x4000000
	// Bit RDERRIE.
	Flash_CR_RDERRIE = 0x4000000
	// Position of OBL_LAUNCH field.
	Flash_CR_OBL_LAUNCH_Pos = 0x1b
	// Bit mask of OBL_LAUNCH field.
	Flash_CR_OBL_LAUNCH_Msk = 0x8000000
	// Bit OBL_LAUNCH.
	Flash_CR_OBL_LAUNCH = 0x8000000
	// Position of OPTLOCK field.
	Flash_CR_OPTLOCK_Pos = 0x1e
	// Bit mask of OPTLOCK field.
	Flash_CR_OPTLOCK_Msk = 0x40000000
	// Bit OPTLOCK.
	Flash_CR_OPTLOCK = 0x40000000
	// Position of LOCK field.
	Flash_CR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	Flash_CR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	Flash_CR_LOCK = 0x80000000

	// ECCR: Flash ECC register
	// Position of ADDR_ECC field.
	Flash_ECCR_ADDR_ECC_Pos = 0x0
	// Bit mask of ADDR_ECC field.
	Flash_ECCR_ADDR_ECC_Msk = 0x7ffff
	// Position of BK_ECC field.
	Flash_ECCR_BK_ECC_Pos = 0x13
	// Bit mask of BK_ECC field.
	Flash_ECCR_BK_ECC_Msk = 0x80000
	// Bit BK_ECC.
	Flash_ECCR_BK_ECC = 0x80000
	// Position of SYSF_ECC field.
	Flash_ECCR_SYSF_ECC_Pos = 0x14
	// Bit mask of SYSF_ECC field.
	Flash_ECCR_SYSF_ECC_Msk = 0x100000
	// Bit SYSF_ECC.
	Flash_ECCR_SYSF_ECC = 0x100000
	// Position of ECCIE field.
	Flash_ECCR_ECCIE_Pos = 0x18
	// Bit mask of ECCIE field.
	Flash_ECCR_ECCIE_Msk = 0x1000000
	// Bit ECCIE.
	Flash_ECCR_ECCIE = 0x1000000
	// Position of ECCC field.
	Flash_ECCR_ECCC_Pos = 0x1e
	// Bit mask of ECCC field.
	Flash_ECCR_ECCC_Msk = 0x40000000
	// Bit ECCC.
	Flash_ECCR_ECCC = 0x40000000
	// Position of ECCD field.
	Flash_ECCR_ECCD_Pos = 0x1f
	// Bit mask of ECCD field.
	Flash_ECCR_ECCD_Msk = 0x80000000
	// Bit ECCD.
	Flash_ECCR_ECCD = 0x80000000

	// OPTR: Flash option register
	// Position of RDP field.
	Flash_OPTR_RDP_Pos = 0x0
	// Bit mask of RDP field.
	Flash_OPTR_RDP_Msk = 0xff
	// Position of BOR_LEV field.
	Flash_OPTR_BOR_LEV_Pos = 0x8
	// Bit mask of BOR_LEV field.
	Flash_OPTR_BOR_LEV_Msk = 0x700
	// Position of NRST_STOP field.
	Flash_OPTR_NRST_STOP_Pos = 0xc
	// Bit mask of NRST_STOP field.
	Flash_OPTR_NRST_STOP_Msk = 0x1000
	// Bit NRST_STOP.
	Flash_OPTR_NRST_STOP = 0x1000
	// Position of NRST_STDBY field.
	Flash_OPTR_NRST_STDBY_Pos = 0xd
	// Bit mask of NRST_STDBY field.
	Flash_OPTR_NRST_STDBY_Msk = 0x2000
	// Bit NRST_STDBY.
	Flash_OPTR_NRST_STDBY = 0x2000
	// Position of IDWG_SW field.
	Flash_OPTR_IDWG_SW_Pos = 0x10
	// Bit mask of IDWG_SW field.
	Flash_OPTR_IDWG_SW_Msk = 0x10000
	// Bit IDWG_SW.
	Flash_OPTR_IDWG_SW = 0x10000
	// Position of IWDG_STOP field.
	Flash_OPTR_IWDG_STOP_Pos = 0x11
	// Bit mask of IWDG_STOP field.
	Flash_OPTR_IWDG_STOP_Msk = 0x20000
	// Bit IWDG_STOP.
	Flash_OPTR_IWDG_STOP = 0x20000
	// Position of IWDG_STDBY field.
	Flash_OPTR_IWDG_STDBY_Pos = 0x12
	// Bit mask of IWDG_STDBY field.
	Flash_OPTR_IWDG_STDBY_Msk = 0x40000
	// Bit IWDG_STDBY.
	Flash_OPTR_IWDG_STDBY = 0x40000
	// Position of WWDG_SW field.
	Flash_OPTR_WWDG_SW_Pos = 0x13
	// Bit mask of WWDG_SW field.
	Flash_OPTR_WWDG_SW_Msk = 0x80000
	// Bit WWDG_SW.
	Flash_OPTR_WWDG_SW = 0x80000
	// Position of BFB2 field.
	Flash_OPTR_BFB2_Pos = 0x14
	// Bit mask of BFB2 field.
	Flash_OPTR_BFB2_Msk = 0x100000
	// Bit BFB2.
	Flash_OPTR_BFB2 = 0x100000
	// Position of DUALBANK field.
	Flash_OPTR_DUALBANK_Pos = 0x15
	// Bit mask of DUALBANK field.
	Flash_OPTR_DUALBANK_Msk = 0x200000
	// Bit DUALBANK.
	Flash_OPTR_DUALBANK = 0x200000
	// Position of NBOOT1 field.
	Flash_OPTR_NBOOT1_Pos = 0x17
	// Bit mask of NBOOT1 field.
	Flash_OPTR_NBOOT1_Msk = 0x800000
	// Bit NBOOT1.
	Flash_OPTR_NBOOT1 = 0x800000
	// Position of SRAM2_PE field.
	Flash_OPTR_SRAM2_PE_Pos = 0x18
	// Bit mask of SRAM2_PE field.
	Flash_OPTR_SRAM2_PE_Msk = 0x1000000
	// Bit SRAM2_PE.
	Flash_OPTR_SRAM2_PE = 0x1000000
	// Position of SRAM2_RST field.
	Flash_OPTR_SRAM2_RST_Pos = 0x19
	// Bit mask of SRAM2_RST field.
	Flash_OPTR_SRAM2_RST_Msk = 0x2000000
	// Bit SRAM2_RST.
	Flash_OPTR_SRAM2_RST = 0x2000000
	// Position of NSWBOOT0 field.
	Flash_OPTR_NSWBOOT0_Pos = 0x1a
	// Bit mask of NSWBOOT0 field.
	Flash_OPTR_NSWBOOT0_Msk = 0x4000000
	// Bit NSWBOOT0.
	Flash_OPTR_NSWBOOT0 = 0x4000000
	// Position of NBOOT0 field.
	Flash_OPTR_NBOOT0_Pos = 0x1b
	// Bit mask of NBOOT0 field.
	Flash_OPTR_NBOOT0_Msk = 0x8000000
	// Bit NBOOT0.
	Flash_OPTR_NBOOT0 = 0x8000000

	// PCROP1SR: Flash Bank 1 PCROP Start address register
	// Position of PCROP1_STRT field.
	Flash_PCROP1SR_PCROP1_STRT_Pos = 0x0
	// Bit mask of PCROP1_STRT field.
	Flash_PCROP1SR_PCROP1_STRT_Msk = 0xffff

	// PCROP1ER: Flash Bank 1 PCROP End address register
	// Position of PCROP1_END field.
	Flash_PCROP1ER_PCROP1_END_Pos = 0x0
	// Bit mask of PCROP1_END field.
	Flash_PCROP1ER_PCROP1_END_Msk = 0xffff
	// Position of PCROP_RDP field.
	Flash_PCROP1ER_PCROP_RDP_Pos = 0x1f
	// Bit mask of PCROP_RDP field.
	Flash_PCROP1ER_PCROP_RDP_Msk = 0x80000000
	// Bit PCROP_RDP.
	Flash_PCROP1ER_PCROP_RDP = 0x80000000

	// WRP1AR: Flash Bank 1 WRP area A address register
	// Position of WRP1A_STRT field.
	Flash_WRP1AR_WRP1A_STRT_Pos = 0x0
	// Bit mask of WRP1A_STRT field.
	Flash_WRP1AR_WRP1A_STRT_Msk = 0xff
	// Position of WRP1A_END field.
	Flash_WRP1AR_WRP1A_END_Pos = 0x10
	// Bit mask of WRP1A_END field.
	Flash_WRP1AR_WRP1A_END_Msk = 0xff0000

	// WRP1BR: Flash Bank 1 WRP area B address register
	// Position of WRP1B_END field.
	Flash_WRP1BR_WRP1B_END_Pos = 0x10
	// Bit mask of WRP1B_END field.
	Flash_WRP1BR_WRP1B_END_Msk = 0xff0000
	// Position of WRP1B_STRT field.
	Flash_WRP1BR_WRP1B_STRT_Pos = 0x0
	// Bit mask of WRP1B_STRT field.
	Flash_WRP1BR_WRP1B_STRT_Msk = 0xff

	// PCROP2SR: Flash Bank 2 PCROP Start address register
	// Position of PCROP2_STRT field.
	Flash_PCROP2SR_PCROP2_STRT_Pos = 0x0
	// Bit mask of PCROP2_STRT field.
	Flash_PCROP2SR_PCROP2_STRT_Msk = 0xffff

	// PCROP2ER: Flash Bank 2 PCROP End address register
	// Position of PCROP2_END field.
	Flash_PCROP2ER_PCROP2_END_Pos = 0x0
	// Bit mask of PCROP2_END field.
	Flash_PCROP2ER_PCROP2_END_Msk = 0xffff

	// WRP2AR: Flash Bank 2 WRP area A address register
	// Position of WRP2A_STRT field.
	Flash_WRP2AR_WRP2A_STRT_Pos = 0x0
	// Bit mask of WRP2A_STRT field.
	Flash_WRP2AR_WRP2A_STRT_Msk = 0xff
	// Position of WRP2A_END field.
	Flash_WRP2AR_WRP2A_END_Pos = 0x10
	// Bit mask of WRP2A_END field.
	Flash_WRP2AR_WRP2A_END_Msk = 0xff0000

	// WRP2BR: Flash Bank 2 WRP area B address register
	// Position of WRP2B_STRT field.
	Flash_WRP2BR_WRP2B_STRT_Pos = 0x0
	// Bit mask of WRP2B_STRT field.
	Flash_WRP2BR_WRP2B_STRT_Msk = 0xff
	// Position of WRP2B_END field.
	Flash_WRP2BR_WRP2B_END_Pos = 0x10
	// Bit mask of WRP2B_END field.
	Flash_WRP2BR_WRP2B_END_Msk = 0xff0000
)

// Constants for DBGMCU: Debug support
const (
	// IDCODE: MCU Device ID Code Register
	// Position of DEV_ID field.
	DBGMCU_IDCODE_DEV_ID_Pos = 0x0
	// Bit mask of DEV_ID field.
	DBGMCU_IDCODE_DEV_ID_Msk = 0xffff
	// Position of REV_ID field.
	DBGMCU_IDCODE_REV_ID_Pos = 0x10
	// Bit mask of REV_ID field.
	DBGMCU_IDCODE_REV_ID_Msk = 0xffff0000

	// CR: Debug MCU Configuration Register
	// Position of DBG_SLEEP field.
	DBGMCU_CR_DBG_SLEEP_Pos = 0x0
	// Bit mask of DBG_SLEEP field.
	DBGMCU_CR_DBG_SLEEP_Msk = 0x1
	// Bit DBG_SLEEP.
	DBGMCU_CR_DBG_SLEEP = 0x1
	// Position of DBG_STOP field.
	DBGMCU_CR_DBG_STOP_Pos = 0x1
	// Bit mask of DBG_STOP field.
	DBGMCU_CR_DBG_STOP_Msk = 0x2
	// Bit DBG_STOP.
	DBGMCU_CR_DBG_STOP = 0x2
	// Position of DBG_STANDBY field.
	DBGMCU_CR_DBG_STANDBY_Pos = 0x2
	// Bit mask of DBG_STANDBY field.
	DBGMCU_CR_DBG_STANDBY_Msk = 0x4
	// Bit DBG_STANDBY.
	DBGMCU_CR_DBG_STANDBY = 0x4
	// Position of TRACE_IOEN field.
	DBGMCU_CR_TRACE_IOEN_Pos = 0x5
	// Bit mask of TRACE_IOEN field.
	DBGMCU_CR_TRACE_IOEN_Msk = 0x20
	// Bit TRACE_IOEN.
	DBGMCU_CR_TRACE_IOEN = 0x20
	// Position of TRACE_MODE field.
	DBGMCU_CR_TRACE_MODE_Pos = 0x6
	// Bit mask of TRACE_MODE field.
	DBGMCU_CR_TRACE_MODE_Msk = 0xc0

	// APB1_FZR1: APB Low Freeze Register 1
	// Position of DBG_TIMER2_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIMER2_STOP_Pos = 0x0
	// Bit mask of DBG_TIMER2_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIMER2_STOP_Msk = 0x1
	// Bit DBG_TIMER2_STOP.
	DBGMCU_APB1_FZR1_DBG_TIMER2_STOP = 0x1
	// Position of DBG_TIM3_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM3_STOP_Pos = 0x1
	// Bit mask of DBG_TIM3_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM3_STOP_Msk = 0x2
	// Bit DBG_TIM3_STOP.
	DBGMCU_APB1_FZR1_DBG_TIM3_STOP = 0x2
	// Position of DBG_TIM4_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM4_STOP_Pos = 0x2
	// Bit mask of DBG_TIM4_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM4_STOP_Msk = 0x4
	// Bit DBG_TIM4_STOP.
	DBGMCU_APB1_FZR1_DBG_TIM4_STOP = 0x4
	// Position of DBG_TIM5_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM5_STOP_Pos = 0x3
	// Bit mask of DBG_TIM5_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM5_STOP_Msk = 0x8
	// Bit DBG_TIM5_STOP.
	DBGMCU_APB1_FZR1_DBG_TIM5_STOP = 0x8
	// Position of DBG_TIMER6_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIMER6_STOP_Pos = 0x4
	// Bit mask of DBG_TIMER6_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIMER6_STOP_Msk = 0x10
	// Bit DBG_TIMER6_STOP.
	DBGMCU_APB1_FZR1_DBG_TIMER6_STOP = 0x10
	// Position of DBG_TIM7_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM7_STOP_Pos = 0x5
	// Bit mask of DBG_TIM7_STOP field.
	DBGMCU_APB1_FZR1_DBG_TIM7_STOP_Msk = 0x20
	// Bit DBG_TIM7_STOP.
	DBGMCU_APB1_FZR1_DBG_TIM7_STOP = 0x20
	// Position of DBG_RTC_STOP field.
	DBGMCU_APB1_FZR1_DBG_RTC_STOP_Pos = 0xa
	// Bit mask of DBG_RTC_STOP field.
	DBGMCU_APB1_FZR1_DBG_RTC_STOP_Msk = 0x400
	// Bit DBG_RTC_STOP.
	DBGMCU_APB1_FZR1_DBG_RTC_STOP = 0x400
	// Position of DBG_WWDG_STOP field.
	DBGMCU_APB1_FZR1_DBG_WWDG_STOP_Pos = 0xb
	// Bit mask of DBG_WWDG_STOP field.
	DBGMCU_APB1_FZR1_DBG_WWDG_STOP_Msk = 0x800
	// Bit DBG_WWDG_STOP.
	DBGMCU_APB1_FZR1_DBG_WWDG_STOP = 0x800
	// Position of DBG_IWDG_STOP field.
	DBGMCU_APB1_FZR1_DBG_IWDG_STOP_Pos = 0xc
	// Bit mask of DBG_IWDG_STOP field.
	DBGMCU_APB1_FZR1_DBG_IWDG_STOP_Msk = 0x1000
	// Bit DBG_IWDG_STOP.
	DBGMCU_APB1_FZR1_DBG_IWDG_STOP = 0x1000
	// Position of DBG_I2C1_STOP field.
	DBGMCU_APB1_FZR1_DBG_I2C1_STOP_Pos = 0x15
	// Bit mask of DBG_I2C1_STOP field.
	DBGMCU_APB1_FZR1_DBG_I2C1_STOP_Msk = 0x200000
	// Bit DBG_I2C1_STOP.
	DBGMCU_APB1_FZR1_DBG_I2C1_STOP = 0x200000
	// Position of DBG_I2C2_STOP field.
	DBGMCU_APB1_FZR1_DBG_I2C2_STOP_Pos = 0x16
	// Bit mask of DBG_I2C2_STOP field.
	DBGMCU_APB1_FZR1_DBG_I2C2_STOP_Msk = 0x400000
	// Bit DBG_I2C2_STOP.
	DBGMCU_APB1_FZR1_DBG_I2C2_STOP = 0x400000
	// Position of DBG_I2C3_STOP field.
	DBGMCU_APB1_FZR1_DBG_I2C3_STOP_Pos = 0x17
	// Bit mask of DBG_I2C3_STOP field.
	DBGMCU_APB1_FZR1_DBG_I2C3_STOP_Msk = 0x800000
	// Bit DBG_I2C3_STOP.
	DBGMCU_APB1_FZR1_DBG_I2C3_STOP = 0x800000
	// Position of DBG_CAN_STOP field.
	DBGMCU_APB1_FZR1_DBG_CAN_STOP_Pos = 0x19
	// Bit mask of DBG_CAN_STOP field.
	DBGMCU_APB1_FZR1_DBG_CAN_STOP_Msk = 0x2000000
	// Bit DBG_CAN_STOP.
	DBGMCU_APB1_FZR1_DBG_CAN_STOP = 0x2000000
	// Position of DBG_LPTIMER_STOP field.
	DBGMCU_APB1_FZR1_DBG_LPTIMER_STOP_Pos = 0x1f
	// Bit mask of DBG_LPTIMER_STOP field.
	DBGMCU_APB1_FZR1_DBG_LPTIMER_STOP_Msk = 0x80000000
	// Bit DBG_LPTIMER_STOP.
	DBGMCU_APB1_FZR1_DBG_LPTIMER_STOP = 0x80000000

	// APB1_FZR2: APB Low Freeze Register 2
	// Position of DBG_LPTIM2_STOP field.
	DBGMCU_APB1_FZR2_DBG_LPTIM2_STOP_Pos = 0x5
	// Bit mask of DBG_LPTIM2_STOP field.
	DBGMCU_APB1_FZR2_DBG_LPTIM2_STOP_Msk = 0x20
	// Bit DBG_LPTIM2_STOP.
	DBGMCU_APB1_FZR2_DBG_LPTIM2_STOP = 0x20

	// APB2_FZR: APB High Freeze Register
	// Position of DBG_TIM1_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM1_STOP_Pos = 0xb
	// Bit mask of DBG_TIM1_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM1_STOP_Msk = 0x800
	// Bit DBG_TIM1_STOP.
	DBGMCU_APB2_FZR_DBG_TIM1_STOP = 0x800
	// Position of DBG_TIM8_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM8_STOP_Pos = 0xd
	// Bit mask of DBG_TIM8_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM8_STOP_Msk = 0x2000
	// Bit DBG_TIM8_STOP.
	DBGMCU_APB2_FZR_DBG_TIM8_STOP = 0x2000
	// Position of DBG_TIM15_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM15_STOP_Pos = 0x10
	// Bit mask of DBG_TIM15_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM15_STOP_Msk = 0x10000
	// Bit DBG_TIM15_STOP.
	DBGMCU_APB2_FZR_DBG_TIM15_STOP = 0x10000
	// Position of DBG_TIM16_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM16_STOP_Pos = 0x11
	// Bit mask of DBG_TIM16_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM16_STOP_Msk = 0x20000
	// Bit DBG_TIM16_STOP.
	DBGMCU_APB2_FZR_DBG_TIM16_STOP = 0x20000
	// Position of DBG_TIM17_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM17_STOP_Pos = 0x12
	// Bit mask of DBG_TIM17_STOP field.
	DBGMCU_APB2_FZR_DBG_TIM17_STOP_Msk = 0x40000
	// Bit DBG_TIM17_STOP.
	DBGMCU_APB2_FZR_DBG_TIM17_STOP = 0x40000
)

// Constants for OCTOSPI1: OctoSPI
const (
	// CR: control register
	// Position of FMODE field.
	OctoSPI_CR_FMODE_Pos = 0x1c
	// Bit mask of FMODE field.
	OctoSPI_CR_FMODE_Msk = 0x30000000
	// Position of PMM field.
	OctoSPI_CR_PMM_Pos = 0x17
	// Bit mask of PMM field.
	OctoSPI_CR_PMM_Msk = 0x800000
	// Bit PMM.
	OctoSPI_CR_PMM = 0x800000
	// Position of APMS field.
	OctoSPI_CR_APMS_Pos = 0x16
	// Bit mask of APMS field.
	OctoSPI_CR_APMS_Msk = 0x400000
	// Bit APMS.
	OctoSPI_CR_APMS = 0x400000
	// Position of TOIE field.
	OctoSPI_CR_TOIE_Pos = 0x14
	// Bit mask of TOIE field.
	OctoSPI_CR_TOIE_Msk = 0x100000
	// Bit TOIE.
	OctoSPI_CR_TOIE = 0x100000
	// Position of SMIE field.
	OctoSPI_CR_SMIE_Pos = 0x13
	// Bit mask of SMIE field.
	OctoSPI_CR_SMIE_Msk = 0x80000
	// Bit SMIE.
	OctoSPI_CR_SMIE = 0x80000
	// Position of FTIE field.
	OctoSPI_CR_FTIE_Pos = 0x12
	// Bit mask of FTIE field.
	OctoSPI_CR_FTIE_Msk = 0x40000
	// Bit FTIE.
	OctoSPI_CR_FTIE = 0x40000
	// Position of TCIE field.
	OctoSPI_CR_TCIE_Pos = 0x11
	// Bit mask of TCIE field.
	OctoSPI_CR_TCIE_Msk = 0x20000
	// Bit TCIE.
	OctoSPI_CR_TCIE = 0x20000
	// Position of TEIE field.
	OctoSPI_CR_TEIE_Pos = 0x10
	// Bit mask of TEIE field.
	OctoSPI_CR_TEIE_Msk = 0x10000
	// Bit TEIE.
	OctoSPI_CR_TEIE = 0x10000
	// Position of FTHRES field.
	OctoSPI_CR_FTHRES_Pos = 0x8
	// Bit mask of FTHRES field.
	OctoSPI_CR_FTHRES_Msk = 0x1f00
	// Position of FSEL field.
	OctoSPI_CR_FSEL_Pos = 0x7
	// Bit mask of FSEL field.
	OctoSPI_CR_FSEL_Msk = 0x80
	// Bit FSEL.
	OctoSPI_CR_FSEL = 0x80
	// Position of DQM field.
	OctoSPI_CR_DQM_Pos = 0x6
	// Bit mask of DQM field.
	OctoSPI_CR_DQM_Msk = 0x40
	// Bit DQM.
	OctoSPI_CR_DQM = 0x40
	// Position of TCEN field.
	OctoSPI_CR_TCEN_Pos = 0x3
	// Bit mask of TCEN field.
	OctoSPI_CR_TCEN_Msk = 0x8
	// Bit TCEN.
	OctoSPI_CR_TCEN = 0x8
	// Position of DMAEN field.
	OctoSPI_CR_DMAEN_Pos = 0x2
	// Bit mask of DMAEN field.
	OctoSPI_CR_DMAEN_Msk = 0x4
	// Bit DMAEN.
	OctoSPI_CR_DMAEN = 0x4
	// Position of ABORT field.
	OctoSPI_CR_ABORT_Pos = 0x1
	// Bit mask of ABORT field.
	OctoSPI_CR_ABORT_Msk = 0x2
	// Bit ABORT.
	OctoSPI_CR_ABORT = 0x2
	// Position of EN field.
	OctoSPI_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	OctoSPI_CR_EN_Msk = 0x1
	// Bit EN.
	OctoSPI_CR_EN = 0x1

	// DCR1: device configuration register
	// Position of CKMODE field.
	OctoSPI_DCR1_CKMODE_Pos = 0x0
	// Bit mask of CKMODE field.
	OctoSPI_DCR1_CKMODE_Msk = 0x1
	// Bit CKMODE.
	OctoSPI_DCR1_CKMODE = 0x1
	// Position of FRCK field.
	OctoSPI_DCR1_FRCK_Pos = 0x1
	// Bit mask of FRCK field.
	OctoSPI_DCR1_FRCK_Msk = 0x2
	// Bit FRCK.
	OctoSPI_DCR1_FRCK = 0x2
	// Position of CSHT field.
	OctoSPI_DCR1_CSHT_Pos = 0x8
	// Bit mask of CSHT field.
	OctoSPI_DCR1_CSHT_Msk = 0x700
	// Position of DEVSIZE field.
	OctoSPI_DCR1_DEVSIZE_Pos = 0x10
	// Bit mask of DEVSIZE field.
	OctoSPI_DCR1_DEVSIZE_Msk = 0x1f0000
	// Position of MTYP field.
	OctoSPI_DCR1_MTYP_Pos = 0x18
	// Bit mask of MTYP field.
	OctoSPI_DCR1_MTYP_Msk = 0x3000000

	// DCR2: device configuration register 2
	// Position of PRESCALER field.
	OctoSPI_DCR2_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	OctoSPI_DCR2_PRESCALER_Msk = 0xff
	// Position of WRAPSIZE field.
	OctoSPI_DCR2_WRAPSIZE_Pos = 0x10
	// Bit mask of WRAPSIZE field.
	OctoSPI_DCR2_WRAPSIZE_Msk = 0x70000

	// DCR3: device configuration register 3
	// Position of CSBOUND field.
	OctoSPI_DCR3_CSBOUND_Pos = 0x10
	// Bit mask of CSBOUND field.
	OctoSPI_DCR3_CSBOUND_Msk = 0x1f0000

	// SR: status register
	// Position of TEF field.
	OctoSPI_SR_TEF_Pos = 0x0
	// Bit mask of TEF field.
	OctoSPI_SR_TEF_Msk = 0x1
	// Bit TEF.
	OctoSPI_SR_TEF = 0x1
	// Position of TCF field.
	OctoSPI_SR_TCF_Pos = 0x1
	// Bit mask of TCF field.
	OctoSPI_SR_TCF_Msk = 0x2
	// Bit TCF.
	OctoSPI_SR_TCF = 0x2
	// Position of FTF field.
	OctoSPI_SR_FTF_Pos = 0x2
	// Bit mask of FTF field.
	OctoSPI_SR_FTF_Msk = 0x4
	// Bit FTF.
	OctoSPI_SR_FTF = 0x4
	// Position of SMF field.
	OctoSPI_SR_SMF_Pos = 0x3
	// Bit mask of SMF field.
	OctoSPI_SR_SMF_Msk = 0x8
	// Bit SMF.
	OctoSPI_SR_SMF = 0x8
	// Position of TOF field.
	OctoSPI_SR_TOF_Pos = 0x4
	// Bit mask of TOF field.
	OctoSPI_SR_TOF_Msk = 0x10
	// Bit TOF.
	OctoSPI_SR_TOF = 0x10
	// Position of BUSY field.
	OctoSPI_SR_BUSY_Pos = 0x5
	// Bit mask of BUSY field.
	OctoSPI_SR_BUSY_Msk = 0x20
	// Bit BUSY.
	OctoSPI_SR_BUSY = 0x20
	// Position of FLEVEL field.
	OctoSPI_SR_FLEVEL_Pos = 0x8
	// Bit mask of FLEVEL field.
	OctoSPI_SR_FLEVEL_Msk = 0x3f00

	// FCR: flag clear register
	// Position of CTEF field.
	OctoSPI_FCR_CTEF_Pos = 0x0
	// Bit mask of CTEF field.
	OctoSPI_FCR_CTEF_Msk = 0x1
	// Bit CTEF.
	OctoSPI_FCR_CTEF = 0x1
	// Position of CTCF field.
	OctoSPI_FCR_CTCF_Pos = 0x1
	// Bit mask of CTCF field.
	OctoSPI_FCR_CTCF_Msk = 0x2
	// Bit CTCF.
	OctoSPI_FCR_CTCF = 0x2
	// Position of CSMF field.
	OctoSPI_FCR_CSMF_Pos = 0x3
	// Bit mask of CSMF field.
	OctoSPI_FCR_CSMF_Msk = 0x8
	// Bit CSMF.
	OctoSPI_FCR_CSMF = 0x8
	// Position of CTOF field.
	OctoSPI_FCR_CTOF_Pos = 0x4
	// Bit mask of CTOF field.
	OctoSPI_FCR_CTOF_Msk = 0x10
	// Bit CTOF.
	OctoSPI_FCR_CTOF = 0x10

	// DLR: data length register
	// Position of DL field.
	OctoSPI_DLR_DL_Pos = 0x0
	// Bit mask of DL field.
	OctoSPI_DLR_DL_Msk = 0xffffffff

	// AR: address register
	// Position of ADDRESS field.
	OctoSPI_AR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	OctoSPI_AR_ADDRESS_Msk = 0xffffffff

	// DR: data register
	// Position of DATA field.
	OctoSPI_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OctoSPI_DR_DATA_Msk = 0xffffffff

	// PSMKR: polling status mask register
	// Position of MASK field.
	OctoSPI_PSMKR_MASK_Pos = 0x0
	// Bit mask of MASK field.
	OctoSPI_PSMKR_MASK_Msk = 0xffffffff

	// PSMAR: polling status match register
	// Position of MATCH field.
	OctoSPI_PSMAR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	OctoSPI_PSMAR_MATCH_Msk = 0xffffffff

	// PIR: polling interval register
	// Position of INTERVAL field.
	OctoSPI_PIR_INTERVAL_Pos = 0x0
	// Bit mask of INTERVAL field.
	OctoSPI_PIR_INTERVAL_Msk = 0xffff

	// CCR: communication configuration register
	// Position of IMODE field.
	OctoSPI_CCR_IMODE_Pos = 0x0
	// Bit mask of IMODE field.
	OctoSPI_CCR_IMODE_Msk = 0x7
	// Position of IDTR field.
	OctoSPI_CCR_IDTR_Pos = 0x3
	// Bit mask of IDTR field.
	OctoSPI_CCR_IDTR_Msk = 0x8
	// Bit IDTR.
	OctoSPI_CCR_IDTR = 0x8
	// Position of ISIZE field.
	OctoSPI_CCR_ISIZE_Pos = 0x4
	// Bit mask of ISIZE field.
	OctoSPI_CCR_ISIZE_Msk = 0x30
	// Position of ADMODE field.
	OctoSPI_CCR_ADMODE_Pos = 0x8
	// Bit mask of ADMODE field.
	OctoSPI_CCR_ADMODE_Msk = 0x700
	// Position of ADDTR field.
	OctoSPI_CCR_ADDTR_Pos = 0xb
	// Bit mask of ADDTR field.
	OctoSPI_CCR_ADDTR_Msk = 0x800
	// Bit ADDTR.
	OctoSPI_CCR_ADDTR = 0x800
	// Position of ADSIZE field.
	OctoSPI_CCR_ADSIZE_Pos = 0xc
	// Bit mask of ADSIZE field.
	OctoSPI_CCR_ADSIZE_Msk = 0x3000
	// Position of ABMODE field.
	OctoSPI_CCR_ABMODE_Pos = 0x10
	// Bit mask of ABMODE field.
	OctoSPI_CCR_ABMODE_Msk = 0x70000
	// Position of ABDTR field.
	OctoSPI_CCR_ABDTR_Pos = 0x13
	// Bit mask of ABDTR field.
	OctoSPI_CCR_ABDTR_Msk = 0x80000
	// Bit ABDTR.
	OctoSPI_CCR_ABDTR = 0x80000
	// Position of ABSIZE field.
	OctoSPI_CCR_ABSIZE_Pos = 0x14
	// Bit mask of ABSIZE field.
	OctoSPI_CCR_ABSIZE_Msk = 0x300000
	// Position of DMODE field.
	OctoSPI_CCR_DMODE_Pos = 0x18
	// Bit mask of DMODE field.
	OctoSPI_CCR_DMODE_Msk = 0x7000000
	// Position of DDTR field.
	OctoSPI_CCR_DDTR_Pos = 0x1b
	// Bit mask of DDTR field.
	OctoSPI_CCR_DDTR_Msk = 0x8000000
	// Bit DDTR.
	OctoSPI_CCR_DDTR = 0x8000000
	// Position of DQSE field.
	OctoSPI_CCR_DQSE_Pos = 0x1d
	// Bit mask of DQSE field.
	OctoSPI_CCR_DQSE_Msk = 0x20000000
	// Bit DQSE.
	OctoSPI_CCR_DQSE = 0x20000000
	// Position of SIOO field.
	OctoSPI_CCR_SIOO_Pos = 0x1f
	// Bit mask of SIOO field.
	OctoSPI_CCR_SIOO_Msk = 0x80000000
	// Bit SIOO.
	OctoSPI_CCR_SIOO = 0x80000000

	// TCR: timing configuration register
	// Position of DCYC field.
	OctoSPI_TCR_DCYC_Pos = 0x0
	// Bit mask of DCYC field.
	OctoSPI_TCR_DCYC_Msk = 0x1f
	// Position of DHQC field.
	OctoSPI_TCR_DHQC_Pos = 0x1c
	// Bit mask of DHQC field.
	OctoSPI_TCR_DHQC_Msk = 0x10000000
	// Bit DHQC.
	OctoSPI_TCR_DHQC = 0x10000000
	// Position of SSHIFT field.
	OctoSPI_TCR_SSHIFT_Pos = 0x1e
	// Bit mask of SSHIFT field.
	OctoSPI_TCR_SSHIFT_Msk = 0x40000000
	// Bit SSHIFT.
	OctoSPI_TCR_SSHIFT = 0x40000000

	// IR: instruction register
	// Position of INSTRUCTION field.
	OctoSPI_IR_INSTRUCTION_Pos = 0x0
	// Bit mask of INSTRUCTION field.
	OctoSPI_IR_INSTRUCTION_Msk = 0xffffffff

	// ABR: alternate bytes register
	// Position of ALTERNATE field.
	OctoSPI_ABR_ALTERNATE_Pos = 0x0
	// Bit mask of ALTERNATE field.
	OctoSPI_ABR_ALTERNATE_Msk = 0xffffffff

	// LPTR: low-power timeout register
	// Position of TIMEOUT field.
	OctoSPI_LPTR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	OctoSPI_LPTR_TIMEOUT_Msk = 0xffff

	// WCCR: write communication configuration register
	// Position of IMODE field.
	OctoSPI_WCCR_IMODE_Pos = 0x0
	// Bit mask of IMODE field.
	OctoSPI_WCCR_IMODE_Msk = 0x7
	// Position of IDTR field.
	OctoSPI_WCCR_IDTR_Pos = 0x3
	// Bit mask of IDTR field.
	OctoSPI_WCCR_IDTR_Msk = 0x8
	// Bit IDTR.
	OctoSPI_WCCR_IDTR = 0x8
	// Position of ISIZE field.
	OctoSPI_WCCR_ISIZE_Pos = 0x4
	// Bit mask of ISIZE field.
	OctoSPI_WCCR_ISIZE_Msk = 0x30
	// Position of ADMODE field.
	OctoSPI_WCCR_ADMODE_Pos = 0x8
	// Bit mask of ADMODE field.
	OctoSPI_WCCR_ADMODE_Msk = 0x700
	// Position of ADDTR field.
	OctoSPI_WCCR_ADDTR_Pos = 0xb
	// Bit mask of ADDTR field.
	OctoSPI_WCCR_ADDTR_Msk = 0x800
	// Bit ADDTR.
	OctoSPI_WCCR_ADDTR = 0x800
	// Position of ADSIZE field.
	OctoSPI_WCCR_ADSIZE_Pos = 0xc
	// Bit mask of ADSIZE field.
	OctoSPI_WCCR_ADSIZE_Msk = 0x3000
	// Position of ABMODE field.
	OctoSPI_WCCR_ABMODE_Pos = 0x10
	// Bit mask of ABMODE field.
	OctoSPI_WCCR_ABMODE_Msk = 0x70000
	// Position of ABDTR field.
	OctoSPI_WCCR_ABDTR_Pos = 0x13
	// Bit mask of ABDTR field.
	OctoSPI_WCCR_ABDTR_Msk = 0x80000
	// Bit ABDTR.
	OctoSPI_WCCR_ABDTR = 0x80000
	// Position of ABSIZE field.
	OctoSPI_WCCR_ABSIZE_Pos = 0x14
	// Bit mask of ABSIZE field.
	OctoSPI_WCCR_ABSIZE_Msk = 0x300000
	// Position of DMODE field.
	OctoSPI_WCCR_DMODE_Pos = 0x18
	// Bit mask of DMODE field.
	OctoSPI_WCCR_DMODE_Msk = 0x7000000
	// Position of DDTR field.
	OctoSPI_WCCR_DDTR_Pos = 0x1b
	// Bit mask of DDTR field.
	OctoSPI_WCCR_DDTR_Msk = 0x8000000
	// Bit DDTR.
	OctoSPI_WCCR_DDTR = 0x8000000
	// Position of DQSE field.
	OctoSPI_WCCR_DQSE_Pos = 0x1d
	// Bit mask of DQSE field.
	OctoSPI_WCCR_DQSE_Msk = 0x20000000
	// Bit DQSE.
	OctoSPI_WCCR_DQSE = 0x20000000
	// Position of SIOO field.
	OctoSPI_WCCR_SIOO_Pos = 0x1f
	// Bit mask of SIOO field.
	OctoSPI_WCCR_SIOO_Msk = 0x80000000
	// Bit SIOO.
	OctoSPI_WCCR_SIOO = 0x80000000

	// WTCR: write timing configuration register
	// Position of DCYC field.
	OctoSPI_WTCR_DCYC_Pos = 0x0
	// Bit mask of DCYC field.
	OctoSPI_WTCR_DCYC_Msk = 0x1f

	// WIR: write instruction register
	// Position of INSTRUCTION field.
	OctoSPI_WIR_INSTRUCTION_Pos = 0x0
	// Bit mask of INSTRUCTION field.
	OctoSPI_WIR_INSTRUCTION_Msk = 0xffffffff

	// WABR: write alternate bytes register
	// Position of ALTERNATE field.
	OctoSPI_WABR_ALTERNATE_Pos = 0x0
	// Bit mask of ALTERNATE field.
	OctoSPI_WABR_ALTERNATE_Msk = 0xffffffff

	// HLCR: HyperBusTM latency configuration register
	// Position of LM field.
	OctoSPI_HLCR_LM_Pos = 0x0
	// Bit mask of LM field.
	OctoSPI_HLCR_LM_Msk = 0x1
	// Bit LM.
	OctoSPI_HLCR_LM = 0x1
	// Position of WZL field.
	OctoSPI_HLCR_WZL_Pos = 0x1
	// Bit mask of WZL field.
	OctoSPI_HLCR_WZL_Msk = 0x2
	// Bit WZL.
	OctoSPI_HLCR_WZL = 0x2
	// Position of TACC field.
	OctoSPI_HLCR_TACC_Pos = 0x8
	// Bit mask of TACC field.
	OctoSPI_HLCR_TACC_Msk = 0xff00
	// Position of TRWR field.
	OctoSPI_HLCR_TRWR_Pos = 0x10
	// Bit mask of TRWR field.
	OctoSPI_HLCR_TRWR_Msk = 0xff0000

	// HWCFGR: HW configuration register
	// Position of AXI field.
	OctoSPI_HWCFGR_AXI_Pos = 0x0
	// Bit mask of AXI field.
	OctoSPI_HWCFGR_AXI_Msk = 0xf
	// Position of FIFO field.
	OctoSPI_HWCFGR_FIFO_Pos = 0x4
	// Bit mask of FIFO field.
	OctoSPI_HWCFGR_FIFO_Msk = 0xff0
	// Position of PRES field.
	OctoSPI_HWCFGR_PRES_Pos = 0xc
	// Bit mask of PRES field.
	OctoSPI_HWCFGR_PRES_Msk = 0xff000
	// Position of IDL field.
	OctoSPI_HWCFGR_IDL_Pos = 0x14
	// Bit mask of IDL field.
	OctoSPI_HWCFGR_IDL_Msk = 0xf00000
	// Position of MMW field.
	OctoSPI_HWCFGR_MMW_Pos = 0x18
	// Bit mask of MMW field.
	OctoSPI_HWCFGR_MMW_Msk = 0xf000000
	// Position of MST field.
	OctoSPI_HWCFGR_MST_Pos = 0x1c
	// Bit mask of MST field.
	OctoSPI_HWCFGR_MST_Msk = 0xf0000000

	// VER: version register
	// Position of VER field.
	OctoSPI_VER_VER_Pos = 0x0
	// Bit mask of VER field.
	OctoSPI_VER_VER_Msk = 0xff

	// ID: identification
	// Position of ID field.
	OctoSPI_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	OctoSPI_ID_ID_Msk = 0xffffffff

	// MID: magic ID
	// Position of MID field.
	OctoSPI_MID_MID_Pos = 0x0
	// Bit mask of MID field.
	OctoSPI_MID_MID_Msk = 0xffffffff
)

// Constants for RCC: Reset and clock control
const (
	// CR: Clock control register
	// Position of PLLSAI2RDY field.
	RCC_CR_PLLSAI2RDY_Pos = 0x1d
	// Bit mask of PLLSAI2RDY field.
	RCC_CR_PLLSAI2RDY_Msk = 0x20000000
	// Bit PLLSAI2RDY.
	RCC_CR_PLLSAI2RDY = 0x20000000
	// Position of PLLSAI2ON field.
	RCC_CR_PLLSAI2ON_Pos = 0x1c
	// Bit mask of PLLSAI2ON field.
	RCC_CR_PLLSAI2ON_Msk = 0x10000000
	// Bit PLLSAI2ON.
	RCC_CR_PLLSAI2ON = 0x10000000
	// Position of PLLSAI1RDY field.
	RCC_CR_PLLSAI1RDY_Pos = 0x1b
	// Bit mask of PLLSAI1RDY field.
	RCC_CR_PLLSAI1RDY_Msk = 0x8000000
	// Bit PLLSAI1RDY.
	RCC_CR_PLLSAI1RDY = 0x8000000
	// Position of PLLSAI1ON field.
	RCC_CR_PLLSAI1ON_Pos = 0x1a
	// Bit mask of PLLSAI1ON field.
	RCC_CR_PLLSAI1ON_Msk = 0x4000000
	// Bit PLLSAI1ON.
	RCC_CR_PLLSAI1ON = 0x4000000
	// Position of PLLRDY field.
	RCC_CR_PLLRDY_Pos = 0x19
	// Bit mask of PLLRDY field.
	RCC_CR_PLLRDY_Msk = 0x2000000
	// Bit PLLRDY.
	RCC_CR_PLLRDY = 0x2000000
	// Position of PLLON field.
	RCC_CR_PLLON_Pos = 0x18
	// Bit mask of PLLON field.
	RCC_CR_PLLON_Msk = 0x1000000
	// Bit PLLON.
	RCC_CR_PLLON = 0x1000000
	// Position of CSSON field.
	RCC_CR_CSSON_Pos = 0x13
	// Bit mask of CSSON field.
	RCC_CR_CSSON_Msk = 0x80000
	// Bit CSSON.
	RCC_CR_CSSON = 0x80000
	// Position of HSEBYP field.
	RCC_CR_HSEBYP_Pos = 0x12
	// Bit mask of HSEBYP field.
	RCC_CR_HSEBYP_Msk = 0x40000
	// Bit HSEBYP.
	RCC_CR_HSEBYP = 0x40000
	// Position of HSERDY field.
	RCC_CR_HSERDY_Pos = 0x11
	// Bit mask of HSERDY field.
	RCC_CR_HSERDY_Msk = 0x20000
	// Bit HSERDY.
	RCC_CR_HSERDY = 0x20000
	// Position of HSEON field.
	RCC_CR_HSEON_Pos = 0x10
	// Bit mask of HSEON field.
	RCC_CR_HSEON_Msk = 0x10000
	// Bit HSEON.
	RCC_CR_HSEON = 0x10000
	// Position of HSIASFS field.
	RCC_CR_HSIASFS_Pos = 0xb
	// Bit mask of HSIASFS field.
	RCC_CR_HSIASFS_Msk = 0x800
	// Bit HSIASFS.
	RCC_CR_HSIASFS = 0x800
	// Position of HSIRDY field.
	RCC_CR_HSIRDY_Pos = 0xa
	// Bit mask of HSIRDY field.
	RCC_CR_HSIRDY_Msk = 0x400
	// Bit HSIRDY.
	RCC_CR_HSIRDY = 0x400
	// Position of HSIKERON field.
	RCC_CR_HSIKERON_Pos = 0x9
	// Bit mask of HSIKERON field.
	RCC_CR_HSIKERON_Msk = 0x200
	// Bit HSIKERON.
	RCC_CR_HSIKERON = 0x200
	// Position of HSION field.
	RCC_CR_HSION_Pos = 0x8
	// Bit mask of HSION field.
	RCC_CR_HSION_Msk = 0x100
	// Bit HSION.
	RCC_CR_HSION = 0x100
	// Position of MSIRANGE field.
	RCC_CR_MSIRANGE_Pos = 0x4
	// Bit mask of MSIRANGE field.
	RCC_CR_MSIRANGE_Msk = 0xf0
	// range 0 around 100 kHz
	RCC_CR_MSIRANGE_Range100K = 0x0
	// range 1 around 200 kHz
	RCC_CR_MSIRANGE_Range200K = 0x1
	// range 2 around 400 kHz
	RCC_CR_MSIRANGE_Range400K = 0x2
	// range 3 around 800 kHz
	RCC_CR_MSIRANGE_Range800K = 0x3
	// range 4 around 1 MHz
	RCC_CR_MSIRANGE_Range1M = 0x4
	// range 5 around 2 MHz
	RCC_CR_MSIRANGE_Range2M = 0x5
	// range 6 around 4 MHz
	RCC_CR_MSIRANGE_Range4M = 0x6
	// range 7 around 8 MHz
	RCC_CR_MSIRANGE_Range8M = 0x7
	// range 8 around 16 MHz
	RCC_CR_MSIRANGE_Range16M = 0x8
	// range 9 around 24 MHz
	RCC_CR_MSIRANGE_Range24M = 0x9
	// range 10 around 32 MHz
	RCC_CR_MSIRANGE_Range32M = 0xa
	// range 11 around 48 MHz
	RCC_CR_MSIRANGE_Range48M = 0xb
	// Position of MSIRGSEL field.
	RCC_CR_MSIRGSEL_Pos = 0x3
	// Bit mask of MSIRGSEL field.
	RCC_CR_MSIRGSEL_Msk = 0x8
	// Bit MSIRGSEL.
	RCC_CR_MSIRGSEL = 0x8
	// Position of MSIPLLEN field.
	RCC_CR_MSIPLLEN_Pos = 0x2
	// Bit mask of MSIPLLEN field.
	RCC_CR_MSIPLLEN_Msk = 0x4
	// Bit MSIPLLEN.
	RCC_CR_MSIPLLEN = 0x4
	// Position of MSIRDY field.
	RCC_CR_MSIRDY_Pos = 0x1
	// Bit mask of MSIRDY field.
	RCC_CR_MSIRDY_Msk = 0x2
	// Bit MSIRDY.
	RCC_CR_MSIRDY = 0x2
	// Position of MSION field.
	RCC_CR_MSION_Pos = 0x0
	// Bit mask of MSION field.
	RCC_CR_MSION_Msk = 0x1
	// Bit MSION.
	RCC_CR_MSION = 0x1

	// ICSCR: Internal clock sources calibration register
	// Position of HSITRIM field.
	RCC_ICSCR_HSITRIM_Pos = 0x18
	// Bit mask of HSITRIM field.
	RCC_ICSCR_HSITRIM_Msk = 0x7f000000
	// Position of HSICAL field.
	RCC_ICSCR_HSICAL_Pos = 0x10
	// Bit mask of HSICAL field.
	RCC_ICSCR_HSICAL_Msk = 0xff0000
	// Position of MSITRIM field.
	RCC_ICSCR_MSITRIM_Pos = 0x8
	// Bit mask of MSITRIM field.
	RCC_ICSCR_MSITRIM_Msk = 0xff00
	// Position of MSICAL field.
	RCC_ICSCR_MSICAL_Pos = 0x0
	// Bit mask of MSICAL field.
	RCC_ICSCR_MSICAL_Msk = 0xff

	// CFGR: Clock configuration register
	// Position of MCOPRE field.
	RCC_CFGR_MCOPRE_Pos = 0x1c
	// Bit mask of MCOPRE field.
	RCC_CFGR_MCOPRE_Msk = 0x70000000
	// Position of MCOSEL field.
	RCC_CFGR_MCOSEL_Pos = 0x18
	// Bit mask of MCOSEL field.
	RCC_CFGR_MCOSEL_Msk = 0x7000000
	// Position of STOPWUCK field.
	RCC_CFGR_STOPWUCK_Pos = 0xf
	// Bit mask of STOPWUCK field.
	RCC_CFGR_STOPWUCK_Msk = 0x8000
	// Bit STOPWUCK.
	RCC_CFGR_STOPWUCK = 0x8000
	// Position of PPRE2 field.
	RCC_CFGR_PPRE2_Pos = 0xb
	// Bit mask of PPRE2 field.
	RCC_CFGR_PPRE2_Msk = 0x3800
	// Position of PPRE1 field.
	RCC_CFGR_PPRE1_Pos = 0x8
	// Bit mask of PPRE1 field.
	RCC_CFGR_PPRE1_Msk = 0x700
	// Position of HPRE field.
	RCC_CFGR_HPRE_Pos = 0x4
	// Bit mask of HPRE field.
	RCC_CFGR_HPRE_Msk = 0xf0
	// Position of SWS field.
	RCC_CFGR_SWS_Pos = 0x2
	// Bit mask of SWS field.
	RCC_CFGR_SWS_Msk = 0xc
	// Position of SW field.
	RCC_CFGR_SW_Pos = 0x0
	// Bit mask of SW field.
	RCC_CFGR_SW_Msk = 0x3

	// PLLCFGR: PLL configuration register
	// Position of PLLPDIV field.
	RCC_PLLCFGR_PLLPDIV_Pos = 0x1b
	// Bit mask of PLLPDIV field.
	RCC_PLLCFGR_PLLPDIV_Msk = 0xf8000000
	// Position of PLLR field.
	RCC_PLLCFGR_PLLR_Pos = 0x19
	// Bit mask of PLLR field.
	RCC_PLLCFGR_PLLR_Msk = 0x6000000
	// Position of PLLREN field.
	RCC_PLLCFGR_PLLREN_Pos = 0x18
	// Bit mask of PLLREN field.
	RCC_PLLCFGR_PLLREN_Msk = 0x1000000
	// Bit PLLREN.
	RCC_PLLCFGR_PLLREN = 0x1000000
	// Position of PLLQ field.
	RCC_PLLCFGR_PLLQ_Pos = 0x15
	// Bit mask of PLLQ field.
	RCC_PLLCFGR_PLLQ_Msk = 0x600000
	// Position of PLLQEN field.
	RCC_PLLCFGR_PLLQEN_Pos = 0x14
	// Bit mask of PLLQEN field.
	RCC_PLLCFGR_PLLQEN_Msk = 0x100000
	// Bit PLLQEN.
	RCC_PLLCFGR_PLLQEN = 0x100000
	// Position of PLLP field.
	RCC_PLLCFGR_PLLP_Pos = 0x11
	// Bit mask of PLLP field.
	RCC_PLLCFGR_PLLP_Msk = 0x20000
	// Bit PLLP.
	RCC_PLLCFGR_PLLP = 0x20000
	// Position of PLLPEN field.
	RCC_PLLCFGR_PLLPEN_Pos = 0x10
	// Bit mask of PLLPEN field.
	RCC_PLLCFGR_PLLPEN_Msk = 0x10000
	// Bit PLLPEN.
	RCC_PLLCFGR_PLLPEN = 0x10000
	// Position of PLLN field.
	RCC_PLLCFGR_PLLN_Pos = 0x8
	// Bit mask of PLLN field.
	RCC_PLLCFGR_PLLN_Msk = 0x7f00
	// Position of PLLM field.
	RCC_PLLCFGR_PLLM_Pos = 0x4
	// Bit mask of PLLM field.
	RCC_PLLCFGR_PLLM_Msk = 0xf0
	// Position of PLLSRC field.
	RCC_PLLCFGR_PLLSRC_Pos = 0x0
	// Bit mask of PLLSRC field.
	RCC_PLLCFGR_PLLSRC_Msk = 0x3

	// PLLSAI1CFGR: PLLSAI1 configuration register
	// Position of PLLSAI1PDIV field.
	RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos = 0x1b
	// Bit mask of PLLSAI1PDIV field.
	RCC_PLLSAI1CFGR_PLLSAI1PDIV_Msk = 0xf8000000
	// Position of PLLSAI1R field.
	RCC_PLLSAI1CFGR_PLLSAI1R_Pos = 0x19
	// Bit mask of PLLSAI1R field.
	RCC_PLLSAI1CFGR_PLLSAI1R_Msk = 0x6000000
	// Position of PLLSAI1REN field.
	RCC_PLLSAI1CFGR_PLLSAI1REN_Pos = 0x18
	// Bit mask of PLLSAI1REN field.
	RCC_PLLSAI1CFGR_PLLSAI1REN_Msk = 0x1000000
	// Bit PLLSAI1REN.
	RCC_PLLSAI1CFGR_PLLSAI1REN = 0x1000000
	// Position of PLLSAI1Q field.
	RCC_PLLSAI1CFGR_PLLSAI1Q_Pos = 0x15
	// Bit mask of PLLSAI1Q field.
	RCC_PLLSAI1CFGR_PLLSAI1Q_Msk = 0x600000
	// Position of PLLSAI1QEN field.
	RCC_PLLSAI1CFGR_PLLSAI1QEN_Pos = 0x14
	// Bit mask of PLLSAI1QEN field.
	RCC_PLLSAI1CFGR_PLLSAI1QEN_Msk = 0x100000
	// Bit PLLSAI1QEN.
	RCC_PLLSAI1CFGR_PLLSAI1QEN = 0x100000
	// Position of PLLSAI1P field.
	RCC_PLLSAI1CFGR_PLLSAI1P_Pos = 0x11
	// Bit mask of PLLSAI1P field.
	RCC_PLLSAI1CFGR_PLLSAI1P_Msk = 0x20000
	// Bit PLLSAI1P.
	RCC_PLLSAI1CFGR_PLLSAI1P = 0x20000
	// Position of PLLSAI1PEN field.
	RCC_PLLSAI1CFGR_PLLSAI1PEN_Pos = 0x10
	// Bit mask of PLLSAI1PEN field.
	RCC_PLLSAI1CFGR_PLLSAI1PEN_Msk = 0x10000
	// Bit PLLSAI1PEN.
	RCC_PLLSAI1CFGR_PLLSAI1PEN = 0x10000
	// Position of PLLSAI1N field.
	RCC_PLLSAI1CFGR_PLLSAI1N_Pos = 0x8
	// Bit mask of PLLSAI1N field.
	RCC_PLLSAI1CFGR_PLLSAI1N_Msk = 0x7f00
	// Position of PLLSAI1M field.
	RCC_PLLSAI1CFGR_PLLSAI1M_Pos = 0x4
	// Bit mask of PLLSAI1M field.
	RCC_PLLSAI1CFGR_PLLSAI1M_Msk = 0xf0

	// PLLSAI2CFGR: PLLSAI2 configuration register
	// Position of PLLSAI2PDIV field.
	RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos = 0x1b
	// Bit mask of PLLSAI2PDIV field.
	RCC_PLLSAI2CFGR_PLLSAI2PDIV_Msk = 0xf8000000
	// Position of PLLSAI2R field.
	RCC_PLLSAI2CFGR_PLLSAI2R_Pos = 0x19
	// Bit mask of PLLSAI2R field.
	RCC_PLLSAI2CFGR_PLLSAI2R_Msk = 0x6000000
	// Position of PLLSAI2REN field.
	RCC_PLLSAI2CFGR_PLLSAI2REN_Pos = 0x18
	// Bit mask of PLLSAI2REN field.
	RCC_PLLSAI2CFGR_PLLSAI2REN_Msk = 0x1000000
	// Bit PLLSAI2REN.
	RCC_PLLSAI2CFGR_PLLSAI2REN = 0x1000000
	// Position of PLLSAI2Q field.
	RCC_PLLSAI2CFGR_PLLSAI2Q_Pos = 0x15
	// Bit mask of PLLSAI2Q field.
	RCC_PLLSAI2CFGR_PLLSAI2Q_Msk = 0x600000
	// Position of PLLSAI2QEN field.
	RCC_PLLSAI2CFGR_PLLSAI2QEN_Pos = 0x14
	// Bit mask of PLLSAI2QEN field.
	RCC_PLLSAI2CFGR_PLLSAI2QEN_Msk = 0x100000
	// Bit PLLSAI2QEN.
	RCC_PLLSAI2CFGR_PLLSAI2QEN = 0x100000
	// Position of PLLSAI2P field.
	RCC_PLLSAI2CFGR_PLLSAI2P_Pos = 0x11
	// Bit mask of PLLSAI2P field.
	RCC_PLLSAI2CFGR_PLLSAI2P_Msk = 0x20000
	// Bit PLLSAI2P.
	RCC_PLLSAI2CFGR_PLLSAI2P = 0x20000
	// Position of PLLSAI2PEN field.
	RCC_PLLSAI2CFGR_PLLSAI2PEN_Pos = 0x10
	// Bit mask of PLLSAI2PEN field.
	RCC_PLLSAI2CFGR_PLLSAI2PEN_Msk = 0x10000
	// Bit PLLSAI2PEN.
	RCC_PLLSAI2CFGR_PLLSAI2PEN = 0x10000
	// Position of PLLSAI2N field.
	RCC_PLLSAI2CFGR_PLLSAI2N_Pos = 0x8
	// Bit mask of PLLSAI2N field.
	RCC_PLLSAI2CFGR_PLLSAI2N_Msk = 0x7f00
	// Position of PLLSAI2M field.
	RCC_PLLSAI2CFGR_PLLSAI2M_Pos = 0x4
	// Bit mask of PLLSAI2M field.
	RCC_PLLSAI2CFGR_PLLSAI2M_Msk = 0xf0

	// CIER: Clock interrupt enable register
	// Position of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Pos = 0x0
	// Bit mask of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Msk = 0x1
	// Bit LSIRDYIE.
	RCC_CIER_LSIRDYIE = 0x1
	// Position of LSERDYIE field.
	RCC_CIER_LSERDYIE_Pos = 0x1
	// Bit mask of LSERDYIE field.
	RCC_CIER_LSERDYIE_Msk = 0x2
	// Bit LSERDYIE.
	RCC_CIER_LSERDYIE = 0x2
	// Position of MSIRDYIE field.
	RCC_CIER_MSIRDYIE_Pos = 0x2
	// Bit mask of MSIRDYIE field.
	RCC_CIER_MSIRDYIE_Msk = 0x4
	// Bit MSIRDYIE.
	RCC_CIER_MSIRDYIE = 0x4
	// Position of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Pos = 0x3
	// Bit mask of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Msk = 0x8
	// Bit HSIRDYIE.
	RCC_CIER_HSIRDYIE = 0x8
	// Position of HSERDYIE field.
	RCC_CIER_HSERDYIE_Pos = 0x4
	// Bit mask of HSERDYIE field.
	RCC_CIER_HSERDYIE_Msk = 0x10
	// Bit HSERDYIE.
	RCC_CIER_HSERDYIE = 0x10
	// Position of PLLRDYIE field.
	RCC_CIER_PLLRDYIE_Pos = 0x5
	// Bit mask of PLLRDYIE field.
	RCC_CIER_PLLRDYIE_Msk = 0x20
	// Bit PLLRDYIE.
	RCC_CIER_PLLRDYIE = 0x20
	// Position of PLLSAI1RDYIE field.
	RCC_CIER_PLLSAI1RDYIE_Pos = 0x6
	// Bit mask of PLLSAI1RDYIE field.
	RCC_CIER_PLLSAI1RDYIE_Msk = 0x40
	// Bit PLLSAI1RDYIE.
	RCC_CIER_PLLSAI1RDYIE = 0x40
	// Position of PLLSAI2RDYIE field.
	RCC_CIER_PLLSAI2RDYIE_Pos = 0x7
	// Bit mask of PLLSAI2RDYIE field.
	RCC_CIER_PLLSAI2RDYIE_Msk = 0x80
	// Bit PLLSAI2RDYIE.
	RCC_CIER_PLLSAI2RDYIE = 0x80
	// Position of LSECSSIE field.
	RCC_CIER_LSECSSIE_Pos = 0x9
	// Bit mask of LSECSSIE field.
	RCC_CIER_LSECSSIE_Msk = 0x200
	// Bit LSECSSIE.
	RCC_CIER_LSECSSIE = 0x200
	// Position of HSI48RDYIE field.
	RCC_CIER_HSI48RDYIE_Pos = 0xa
	// Bit mask of HSI48RDYIE field.
	RCC_CIER_HSI48RDYIE_Msk = 0x400
	// Bit HSI48RDYIE.
	RCC_CIER_HSI48RDYIE = 0x400

	// CIFR: Clock interrupt flag register
	// Position of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Pos = 0x0
	// Bit mask of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Msk = 0x1
	// Bit LSIRDYF.
	RCC_CIFR_LSIRDYF = 0x1
	// Position of LSERDYF field.
	RCC_CIFR_LSERDYF_Pos = 0x1
	// Bit mask of LSERDYF field.
	RCC_CIFR_LSERDYF_Msk = 0x2
	// Bit LSERDYF.
	RCC_CIFR_LSERDYF = 0x2
	// Position of MSIRDYF field.
	RCC_CIFR_MSIRDYF_Pos = 0x2
	// Bit mask of MSIRDYF field.
	RCC_CIFR_MSIRDYF_Msk = 0x4
	// Bit MSIRDYF.
	RCC_CIFR_MSIRDYF = 0x4
	// Position of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Pos = 0x3
	// Bit mask of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Msk = 0x8
	// Bit HSIRDYF.
	RCC_CIFR_HSIRDYF = 0x8
	// Position of HSERDYF field.
	RCC_CIFR_HSERDYF_Pos = 0x4
	// Bit mask of HSERDYF field.
	RCC_CIFR_HSERDYF_Msk = 0x10
	// Bit HSERDYF.
	RCC_CIFR_HSERDYF = 0x10
	// Position of PLLRDYF field.
	RCC_CIFR_PLLRDYF_Pos = 0x5
	// Bit mask of PLLRDYF field.
	RCC_CIFR_PLLRDYF_Msk = 0x20
	// Bit PLLRDYF.
	RCC_CIFR_PLLRDYF = 0x20
	// Position of PLLSAI1RDYF field.
	RCC_CIFR_PLLSAI1RDYF_Pos = 0x6
	// Bit mask of PLLSAI1RDYF field.
	RCC_CIFR_PLLSAI1RDYF_Msk = 0x40
	// Bit PLLSAI1RDYF.
	RCC_CIFR_PLLSAI1RDYF = 0x40
	// Position of PLLSAI2RDYF field.
	RCC_CIFR_PLLSAI2RDYF_Pos = 0x7
	// Bit mask of PLLSAI2RDYF field.
	RCC_CIFR_PLLSAI2RDYF_Msk = 0x80
	// Bit PLLSAI2RDYF.
	RCC_CIFR_PLLSAI2RDYF = 0x80
	// Position of CSSF field.
	RCC_CIFR_CSSF_Pos = 0x8
	// Bit mask of CSSF field.
	RCC_CIFR_CSSF_Msk = 0x100
	// Bit CSSF.
	RCC_CIFR_CSSF = 0x100
	// Position of LSECSSF field.
	RCC_CIFR_LSECSSF_Pos = 0x9
	// Bit mask of LSECSSF field.
	RCC_CIFR_LSECSSF_Msk = 0x200
	// Bit LSECSSF.
	RCC_CIFR_LSECSSF = 0x200
	// Position of HSI48RDYF field.
	RCC_CIFR_HSI48RDYF_Pos = 0xa
	// Bit mask of HSI48RDYF field.
	RCC_CIFR_HSI48RDYF_Msk = 0x400
	// Bit HSI48RDYF.
	RCC_CIFR_HSI48RDYF = 0x400

	// CICR: Clock interrupt clear register
	// Position of LSIRDYC field.
	RCC_CICR_LSIRDYC_Pos = 0x0
	// Bit mask of LSIRDYC field.
	RCC_CICR_LSIRDYC_Msk = 0x1
	// Bit LSIRDYC.
	RCC_CICR_LSIRDYC = 0x1
	// Position of LSERDYC field.
	RCC_CICR_LSERDYC_Pos = 0x1
	// Bit mask of LSERDYC field.
	RCC_CICR_LSERDYC_Msk = 0x2
	// Bit LSERDYC.
	RCC_CICR_LSERDYC = 0x2
	// Position of MSIRDYC field.
	RCC_CICR_MSIRDYC_Pos = 0x2
	// Bit mask of MSIRDYC field.
	RCC_CICR_MSIRDYC_Msk = 0x4
	// Bit MSIRDYC.
	RCC_CICR_MSIRDYC = 0x4
	// Position of HSIRDYC field.
	RCC_CICR_HSIRDYC_Pos = 0x3
	// Bit mask of HSIRDYC field.
	RCC_CICR_HSIRDYC_Msk = 0x8
	// Bit HSIRDYC.
	RCC_CICR_HSIRDYC = 0x8
	// Position of HSERDYC field.
	RCC_CICR_HSERDYC_Pos = 0x4
	// Bit mask of HSERDYC field.
	RCC_CICR_HSERDYC_Msk = 0x10
	// Bit HSERDYC.
	RCC_CICR_HSERDYC = 0x10
	// Position of PLLRDYC field.
	RCC_CICR_PLLRDYC_Pos = 0x5
	// Bit mask of PLLRDYC field.
	RCC_CICR_PLLRDYC_Msk = 0x20
	// Bit PLLRDYC.
	RCC_CICR_PLLRDYC = 0x20
	// Position of PLLSAI1RDYC field.
	RCC_CICR_PLLSAI1RDYC_Pos = 0x6
	// Bit mask of PLLSAI1RDYC field.
	RCC_CICR_PLLSAI1RDYC_Msk = 0x40
	// Bit PLLSAI1RDYC.
	RCC_CICR_PLLSAI1RDYC = 0x40
	// Position of PLLSAI2RDYC field.
	RCC_CICR_PLLSAI2RDYC_Pos = 0x7
	// Bit mask of PLLSAI2RDYC field.
	RCC_CICR_PLLSAI2RDYC_Msk = 0x80
	// Bit PLLSAI2RDYC.
	RCC_CICR_PLLSAI2RDYC = 0x80
	// Position of CSSC field.
	RCC_CICR_CSSC_Pos = 0x8
	// Bit mask of CSSC field.
	RCC_CICR_CSSC_Msk = 0x100
	// Bit CSSC.
	RCC_CICR_CSSC = 0x100
	// Position of LSECSSC field.
	RCC_CICR_LSECSSC_Pos = 0x9
	// Bit mask of LSECSSC field.
	RCC_CICR_LSECSSC_Msk = 0x200
	// Bit LSECSSC.
	RCC_CICR_LSECSSC = 0x200
	// Position of HSI48RDYC field.
	RCC_CICR_HSI48RDYC_Pos = 0xa
	// Bit mask of HSI48RDYC field.
	RCC_CICR_HSI48RDYC_Msk = 0x400
	// Bit HSI48RDYC.
	RCC_CICR_HSI48RDYC = 0x400

	// AHB1RSTR: AHB1 peripheral reset register
	// Position of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Pos = 0x0
	// Bit mask of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Msk = 0x1
	// Bit DMA1RST.
	RCC_AHB1RSTR_DMA1RST = 0x1
	// Position of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Pos = 0x1
	// Bit mask of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Msk = 0x2
	// Bit DMA2RST.
	RCC_AHB1RSTR_DMA2RST = 0x2
	// Position of DMAMUX1RST field.
	RCC_AHB1RSTR_DMAMUX1RST_Pos = 0x2
	// Bit mask of DMAMUX1RST field.
	RCC_AHB1RSTR_DMAMUX1RST_Msk = 0x4
	// Bit DMAMUX1RST.
	RCC_AHB1RSTR_DMAMUX1RST = 0x4
	// Position of FLASHRST field.
	RCC_AHB1RSTR_FLASHRST_Pos = 0x8
	// Bit mask of FLASHRST field.
	RCC_AHB1RSTR_FLASHRST_Msk = 0x100
	// Bit FLASHRST.
	RCC_AHB1RSTR_FLASHRST = 0x100
	// Position of CRCRST field.
	RCC_AHB1RSTR_CRCRST_Pos = 0xc
	// Bit mask of CRCRST field.
	RCC_AHB1RSTR_CRCRST_Msk = 0x1000
	// Bit CRCRST.
	RCC_AHB1RSTR_CRCRST = 0x1000
	// Position of TSCRST field.
	RCC_AHB1RSTR_TSCRST_Pos = 0x10
	// Bit mask of TSCRST field.
	RCC_AHB1RSTR_TSCRST_Msk = 0x10000
	// Bit TSCRST.
	RCC_AHB1RSTR_TSCRST = 0x10000
	// Position of DMA2DRST field.
	RCC_AHB1RSTR_DMA2DRST_Pos = 0x11
	// Bit mask of DMA2DRST field.
	RCC_AHB1RSTR_DMA2DRST_Msk = 0x20000
	// Bit DMA2DRST.
	RCC_AHB1RSTR_DMA2DRST = 0x20000
	// Position of GFXMMURST field.
	RCC_AHB1RSTR_GFXMMURST_Pos = 0x12
	// Bit mask of GFXMMURST field.
	RCC_AHB1RSTR_GFXMMURST_Msk = 0x40000
	// Bit GFXMMURST.
	RCC_AHB1RSTR_GFXMMURST = 0x40000

	// AHB2RSTR: AHB2 peripheral reset register
	// Position of GPIOARST field.
	RCC_AHB2RSTR_GPIOARST_Pos = 0x0
	// Bit mask of GPIOARST field.
	RCC_AHB2RSTR_GPIOARST_Msk = 0x1
	// Bit GPIOARST.
	RCC_AHB2RSTR_GPIOARST = 0x1
	// Position of GPIOBRST field.
	RCC_AHB2RSTR_GPIOBRST_Pos = 0x1
	// Bit mask of GPIOBRST field.
	RCC_AHB2RSTR_GPIOBRST_Msk = 0x2
	// Bit GPIOBRST.
	RCC_AHB2RSTR_GPIOBRST = 0x2
	// Position of GPIOCRST field.
	RCC_AHB2RSTR_GPIOCRST_Pos = 0x2
	// Bit mask of GPIOCRST field.
	RCC_AHB2RSTR_GPIOCRST_Msk = 0x4
	// Bit GPIOCRST.
	RCC_AHB2RSTR_GPIOCRST = 0x4
	// Position of GPIODRST field.
	RCC_AHB2RSTR_GPIODRST_Pos = 0x3
	// Bit mask of GPIODRST field.
	RCC_AHB2RSTR_GPIODRST_Msk = 0x8
	// Bit GPIODRST.
	RCC_AHB2RSTR_GPIODRST = 0x8
	// Position of GPIOERST field.
	RCC_AHB2RSTR_GPIOERST_Pos = 0x4
	// Bit mask of GPIOERST field.
	RCC_AHB2RSTR_GPIOERST_Msk = 0x10
	// Bit GPIOERST.
	RCC_AHB2RSTR_GPIOERST = 0x10
	// Position of GPIOFRST field.
	RCC_AHB2RSTR_GPIOFRST_Pos = 0x5
	// Bit mask of GPIOFRST field.
	RCC_AHB2RSTR_GPIOFRST_Msk = 0x20
	// Bit GPIOFRST.
	RCC_AHB2RSTR_GPIOFRST = 0x20
	// Position of GPIOGRST field.
	RCC_AHB2RSTR_GPIOGRST_Pos = 0x6
	// Bit mask of GPIOGRST field.
	RCC_AHB2RSTR_GPIOGRST_Msk = 0x40
	// Bit GPIOGRST.
	RCC_AHB2RSTR_GPIOGRST = 0x40
	// Position of GPIOHRST field.
	RCC_AHB2RSTR_GPIOHRST_Pos = 0x7
	// Bit mask of GPIOHRST field.
	RCC_AHB2RSTR_GPIOHRST_Msk = 0x80
	// Bit GPIOHRST.
	RCC_AHB2RSTR_GPIOHRST = 0x80
	// Position of GPIOIRST field.
	RCC_AHB2RSTR_GPIOIRST_Pos = 0x8
	// Bit mask of GPIOIRST field.
	RCC_AHB2RSTR_GPIOIRST_Msk = 0x100
	// Bit GPIOIRST.
	RCC_AHB2RSTR_GPIOIRST = 0x100
	// Position of OTGFSRST field.
	RCC_AHB2RSTR_OTGFSRST_Pos = 0xc
	// Bit mask of OTGFSRST field.
	RCC_AHB2RSTR_OTGFSRST_Msk = 0x1000
	// Bit OTGFSRST.
	RCC_AHB2RSTR_OTGFSRST = 0x1000
	// Position of ADCRST field.
	RCC_AHB2RSTR_ADCRST_Pos = 0xd
	// Bit mask of ADCRST field.
	RCC_AHB2RSTR_ADCRST_Msk = 0x2000
	// Bit ADCRST.
	RCC_AHB2RSTR_ADCRST = 0x2000
	// Position of DCMIRST field.
	RCC_AHB2RSTR_DCMIRST_Pos = 0xe
	// Bit mask of DCMIRST field.
	RCC_AHB2RSTR_DCMIRST_Msk = 0x4000
	// Bit DCMIRST.
	RCC_AHB2RSTR_DCMIRST = 0x4000
	// Position of AESRST field.
	RCC_AHB2RSTR_AESRST_Pos = 0x10
	// Bit mask of AESRST field.
	RCC_AHB2RSTR_AESRST_Msk = 0x10000
	// Bit AESRST.
	RCC_AHB2RSTR_AESRST = 0x10000
	// Position of HASHRST field.
	RCC_AHB2RSTR_HASHRST_Pos = 0x11
	// Bit mask of HASHRST field.
	RCC_AHB2RSTR_HASHRST_Msk = 0x20000
	// Bit HASHRST.
	RCC_AHB2RSTR_HASHRST = 0x20000
	// Position of RNGRST field.
	RCC_AHB2RSTR_RNGRST_Pos = 0x12
	// Bit mask of RNGRST field.
	RCC_AHB2RSTR_RNGRST_Msk = 0x40000
	// Bit RNGRST.
	RCC_AHB2RSTR_RNGRST = 0x40000
	// Position of OSPIMRST field.
	RCC_AHB2RSTR_OSPIMRST_Pos = 0x14
	// Bit mask of OSPIMRST field.
	RCC_AHB2RSTR_OSPIMRST_Msk = 0x100000
	// Bit OSPIMRST.
	RCC_AHB2RSTR_OSPIMRST = 0x100000
	// Position of SDMMC1RST field.
	RCC_AHB2RSTR_SDMMC1RST_Pos = 0x16
	// Bit mask of SDMMC1RST field.
	RCC_AHB2RSTR_SDMMC1RST_Msk = 0x400000
	// Bit SDMMC1RST.
	RCC_AHB2RSTR_SDMMC1RST = 0x400000

	// AHB3RSTR: AHB3 peripheral reset register
	// Position of FMCRST field.
	RCC_AHB3RSTR_FMCRST_Pos = 0x0
	// Bit mask of FMCRST field.
	RCC_AHB3RSTR_FMCRST_Msk = 0x1
	// Bit FMCRST.
	RCC_AHB3RSTR_FMCRST = 0x1
	// Position of OSPI2RST field.
	RCC_AHB3RSTR_OSPI2RST_Pos = 0x9
	// Bit mask of OSPI2RST field.
	RCC_AHB3RSTR_OSPI2RST_Msk = 0x200
	// Bit OSPI2RST.
	RCC_AHB3RSTR_OSPI2RST = 0x200

	// APB1RSTR1: APB1 peripheral reset register 1
	// Position of LPTIM1RST field.
	RCC_APB1RSTR1_LPTIM1RST_Pos = 0x1f
	// Bit mask of LPTIM1RST field.
	RCC_APB1RSTR1_LPTIM1RST_Msk = 0x80000000
	// Bit LPTIM1RST.
	RCC_APB1RSTR1_LPTIM1RST = 0x80000000
	// Position of OPAMPRST field.
	RCC_APB1RSTR1_OPAMPRST_Pos = 0x1e
	// Bit mask of OPAMPRST field.
	RCC_APB1RSTR1_OPAMPRST_Msk = 0x40000000
	// Bit OPAMPRST.
	RCC_APB1RSTR1_OPAMPRST = 0x40000000
	// Position of DAC1RST field.
	RCC_APB1RSTR1_DAC1RST_Pos = 0x1d
	// Bit mask of DAC1RST field.
	RCC_APB1RSTR1_DAC1RST_Msk = 0x20000000
	// Bit DAC1RST.
	RCC_APB1RSTR1_DAC1RST = 0x20000000
	// Position of PWRRST field.
	RCC_APB1RSTR1_PWRRST_Pos = 0x1c
	// Bit mask of PWRRST field.
	RCC_APB1RSTR1_PWRRST_Msk = 0x10000000
	// Bit PWRRST.
	RCC_APB1RSTR1_PWRRST = 0x10000000
	// Position of CAN1RST field.
	RCC_APB1RSTR1_CAN1RST_Pos = 0x19
	// Bit mask of CAN1RST field.
	RCC_APB1RSTR1_CAN1RST_Msk = 0x2000000
	// Bit CAN1RST.
	RCC_APB1RSTR1_CAN1RST = 0x2000000
	// Position of CRSRST field.
	RCC_APB1RSTR1_CRSRST_Pos = 0x18
	// Bit mask of CRSRST field.
	RCC_APB1RSTR1_CRSRST_Msk = 0x1000000
	// Bit CRSRST.
	RCC_APB1RSTR1_CRSRST = 0x1000000
	// Position of I2C3RST field.
	RCC_APB1RSTR1_I2C3RST_Pos = 0x17
	// Bit mask of I2C3RST field.
	RCC_APB1RSTR1_I2C3RST_Msk = 0x800000
	// Bit I2C3RST.
	RCC_APB1RSTR1_I2C3RST = 0x800000
	// Position of I2C2RST field.
	RCC_APB1RSTR1_I2C2RST_Pos = 0x16
	// Bit mask of I2C2RST field.
	RCC_APB1RSTR1_I2C2RST_Msk = 0x400000
	// Bit I2C2RST.
	RCC_APB1RSTR1_I2C2RST = 0x400000
	// Position of I2C1RST field.
	RCC_APB1RSTR1_I2C1RST_Pos = 0x15
	// Bit mask of I2C1RST field.
	RCC_APB1RSTR1_I2C1RST_Msk = 0x200000
	// Bit I2C1RST.
	RCC_APB1RSTR1_I2C1RST = 0x200000
	// Position of UART5RST field.
	RCC_APB1RSTR1_UART5RST_Pos = 0x14
	// Bit mask of UART5RST field.
	RCC_APB1RSTR1_UART5RST_Msk = 0x100000
	// Bit UART5RST.
	RCC_APB1RSTR1_UART5RST = 0x100000
	// Position of UART4RST field.
	RCC_APB1RSTR1_UART4RST_Pos = 0x13
	// Bit mask of UART4RST field.
	RCC_APB1RSTR1_UART4RST_Msk = 0x80000
	// Bit UART4RST.
	RCC_APB1RSTR1_UART4RST = 0x80000
	// Position of USART3RST field.
	RCC_APB1RSTR1_USART3RST_Pos = 0x12
	// Bit mask of USART3RST field.
	RCC_APB1RSTR1_USART3RST_Msk = 0x40000
	// Bit USART3RST.
	RCC_APB1RSTR1_USART3RST = 0x40000
	// Position of USART2RST field.
	RCC_APB1RSTR1_USART2RST_Pos = 0x11
	// Bit mask of USART2RST field.
	RCC_APB1RSTR1_USART2RST_Msk = 0x20000
	// Bit USART2RST.
	RCC_APB1RSTR1_USART2RST = 0x20000
	// Position of SPI3RST field.
	RCC_APB1RSTR1_SPI3RST_Pos = 0xf
	// Bit mask of SPI3RST field.
	RCC_APB1RSTR1_SPI3RST_Msk = 0x8000
	// Bit SPI3RST.
	RCC_APB1RSTR1_SPI3RST = 0x8000
	// Position of SPI2RST field.
	RCC_APB1RSTR1_SPI2RST_Pos = 0xe
	// Bit mask of SPI2RST field.
	RCC_APB1RSTR1_SPI2RST_Msk = 0x4000
	// Bit SPI2RST.
	RCC_APB1RSTR1_SPI2RST = 0x4000
	// Position of TIM7RST field.
	RCC_APB1RSTR1_TIM7RST_Pos = 0x5
	// Bit mask of TIM7RST field.
	RCC_APB1RSTR1_TIM7RST_Msk = 0x20
	// Bit TIM7RST.
	RCC_APB1RSTR1_TIM7RST = 0x20
	// Position of TIM6RST field.
	RCC_APB1RSTR1_TIM6RST_Pos = 0x4
	// Bit mask of TIM6RST field.
	RCC_APB1RSTR1_TIM6RST_Msk = 0x10
	// Bit TIM6RST.
	RCC_APB1RSTR1_TIM6RST = 0x10
	// Position of TIM5RST field.
	RCC_APB1RSTR1_TIM5RST_Pos = 0x3
	// Bit mask of TIM5RST field.
	RCC_APB1RSTR1_TIM5RST_Msk = 0x8
	// Bit TIM5RST.
	RCC_APB1RSTR1_TIM5RST = 0x8
	// Position of TIM4RST field.
	RCC_APB1RSTR1_TIM4RST_Pos = 0x2
	// Bit mask of TIM4RST field.
	RCC_APB1RSTR1_TIM4RST_Msk = 0x4
	// Bit TIM4RST.
	RCC_APB1RSTR1_TIM4RST = 0x4
	// Position of TIM3RST field.
	RCC_APB1RSTR1_TIM3RST_Pos = 0x1
	// Bit mask of TIM3RST field.
	RCC_APB1RSTR1_TIM3RST_Msk = 0x2
	// Bit TIM3RST.
	RCC_APB1RSTR1_TIM3RST = 0x2
	// Position of TIM2RST field.
	RCC_APB1RSTR1_TIM2RST_Pos = 0x0
	// Bit mask of TIM2RST field.
	RCC_APB1RSTR1_TIM2RST_Msk = 0x1
	// Bit TIM2RST.
	RCC_APB1RSTR1_TIM2RST = 0x1

	// APB1RSTR2: APB1 peripheral reset register 2
	// Position of LPUART1RST field.
	RCC_APB1RSTR2_LPUART1RST_Pos = 0x0
	// Bit mask of LPUART1RST field.
	RCC_APB1RSTR2_LPUART1RST_Msk = 0x1
	// Bit LPUART1RST.
	RCC_APB1RSTR2_LPUART1RST = 0x1
	// Position of I2C4RST field.
	RCC_APB1RSTR2_I2C4RST_Pos = 0x1
	// Bit mask of I2C4RST field.
	RCC_APB1RSTR2_I2C4RST_Msk = 0x2
	// Bit I2C4RST.
	RCC_APB1RSTR2_I2C4RST = 0x2
	// Position of LPTIM2RST field.
	RCC_APB1RSTR2_LPTIM2RST_Pos = 0x5
	// Bit mask of LPTIM2RST field.
	RCC_APB1RSTR2_LPTIM2RST_Msk = 0x20
	// Bit LPTIM2RST.
	RCC_APB1RSTR2_LPTIM2RST = 0x20

	// APB2RSTR: APB2 peripheral reset register
	// Position of SYSCFGRST field.
	RCC_APB2RSTR_SYSCFGRST_Pos = 0x0
	// Bit mask of SYSCFGRST field.
	RCC_APB2RSTR_SYSCFGRST_Msk = 0x1
	// Bit SYSCFGRST.
	RCC_APB2RSTR_SYSCFGRST = 0x1
	// Position of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Pos = 0xb
	// Bit mask of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Msk = 0x800
	// Bit TIM1RST.
	RCC_APB2RSTR_TIM1RST = 0x800
	// Position of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Pos = 0xc
	// Bit mask of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Msk = 0x1000
	// Bit SPI1RST.
	RCC_APB2RSTR_SPI1RST = 0x1000
	// Position of TIM8RST field.
	RCC_APB2RSTR_TIM8RST_Pos = 0xd
	// Bit mask of TIM8RST field.
	RCC_APB2RSTR_TIM8RST_Msk = 0x2000
	// Bit TIM8RST.
	RCC_APB2RSTR_TIM8RST = 0x2000
	// Position of USART1RST field.
	RCC_APB2RSTR_USART1RST_Pos = 0xe
	// Bit mask of USART1RST field.
	RCC_APB2RSTR_USART1RST_Msk = 0x4000
	// Bit USART1RST.
	RCC_APB2RSTR_USART1RST = 0x4000
	// Position of TIM15RST field.
	RCC_APB2RSTR_TIM15RST_Pos = 0x10
	// Bit mask of TIM15RST field.
	RCC_APB2RSTR_TIM15RST_Msk = 0x10000
	// Bit TIM15RST.
	RCC_APB2RSTR_TIM15RST = 0x10000
	// Position of TIM16RST field.
	RCC_APB2RSTR_TIM16RST_Pos = 0x11
	// Bit mask of TIM16RST field.
	RCC_APB2RSTR_TIM16RST_Msk = 0x20000
	// Bit TIM16RST.
	RCC_APB2RSTR_TIM16RST = 0x20000
	// Position of TIM17RST field.
	RCC_APB2RSTR_TIM17RST_Pos = 0x12
	// Bit mask of TIM17RST field.
	RCC_APB2RSTR_TIM17RST_Msk = 0x40000
	// Bit TIM17RST.
	RCC_APB2RSTR_TIM17RST = 0x40000
	// Position of SAI1RST field.
	RCC_APB2RSTR_SAI1RST_Pos = 0x15
	// Bit mask of SAI1RST field.
	RCC_APB2RSTR_SAI1RST_Msk = 0x200000
	// Bit SAI1RST.
	RCC_APB2RSTR_SAI1RST = 0x200000
	// Position of SAI2RST field.
	RCC_APB2RSTR_SAI2RST_Pos = 0x16
	// Bit mask of SAI2RST field.
	RCC_APB2RSTR_SAI2RST_Msk = 0x400000
	// Bit SAI2RST.
	RCC_APB2RSTR_SAI2RST = 0x400000
	// Position of DFSDM1RST field.
	RCC_APB2RSTR_DFSDM1RST_Pos = 0x18
	// Bit mask of DFSDM1RST field.
	RCC_APB2RSTR_DFSDM1RST_Msk = 0x1000000
	// Bit DFSDM1RST.
	RCC_APB2RSTR_DFSDM1RST = 0x1000000
	// Position of LTDCRST field.
	RCC_APB2RSTR_LTDCRST_Pos = 0x1a
	// Bit mask of LTDCRST field.
	RCC_APB2RSTR_LTDCRST_Msk = 0x4000000
	// Bit LTDCRST.
	RCC_APB2RSTR_LTDCRST = 0x4000000
	// Position of DSIRST field.
	RCC_APB2RSTR_DSIRST_Pos = 0x1b
	// Bit mask of DSIRST field.
	RCC_APB2RSTR_DSIRST_Msk = 0x8000000
	// Bit DSIRST.
	RCC_APB2RSTR_DSIRST = 0x8000000

	// AHB1ENR: AHB1 peripheral clock enable register
	// Position of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Pos = 0x0
	// Bit mask of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Msk = 0x1
	// Bit DMA1EN.
	RCC_AHB1ENR_DMA1EN = 0x1
	// Position of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Pos = 0x1
	// Bit mask of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Msk = 0x2
	// Bit DMA2EN.
	RCC_AHB1ENR_DMA2EN = 0x2
	// Position of DMAMUX1EN field.
	RCC_AHB1ENR_DMAMUX1EN_Pos = 0x2
	// Bit mask of DMAMUX1EN field.
	RCC_AHB1ENR_DMAMUX1EN_Msk = 0x4
	// Bit DMAMUX1EN.
	RCC_AHB1ENR_DMAMUX1EN = 0x4
	// Position of FLASHEN field.
	RCC_AHB1ENR_FLASHEN_Pos = 0x8
	// Bit mask of FLASHEN field.
	RCC_AHB1ENR_FLASHEN_Msk = 0x100
	// Bit FLASHEN.
	RCC_AHB1ENR_FLASHEN = 0x100
	// Position of CRCEN field.
	RCC_AHB1ENR_CRCEN_Pos = 0xc
	// Bit mask of CRCEN field.
	RCC_AHB1ENR_CRCEN_Msk = 0x1000
	// Bit CRCEN.
	RCC_AHB1ENR_CRCEN = 0x1000
	// Position of TSCEN field.
	RCC_AHB1ENR_TSCEN_Pos = 0x10
	// Bit mask of TSCEN field.
	RCC_AHB1ENR_TSCEN_Msk = 0x10000
	// Bit TSCEN.
	RCC_AHB1ENR_TSCEN = 0x10000
	// Position of DMA2DEN field.
	RCC_AHB1ENR_DMA2DEN_Pos = 0x11
	// Bit mask of DMA2DEN field.
	RCC_AHB1ENR_DMA2DEN_Msk = 0x20000
	// Bit DMA2DEN.
	RCC_AHB1ENR_DMA2DEN = 0x20000
	// Position of GFXMMUEN field.
	RCC_AHB1ENR_GFXMMUEN_Pos = 0x12
	// Bit mask of GFXMMUEN field.
	RCC_AHB1ENR_GFXMMUEN_Msk = 0x40000
	// Bit GFXMMUEN.
	RCC_AHB1ENR_GFXMMUEN = 0x40000

	// AHB2ENR: AHB2 peripheral clock enable register
	// Position of GPIOAEN field.
	RCC_AHB2ENR_GPIOAEN_Pos = 0x0
	// Bit mask of GPIOAEN field.
	RCC_AHB2ENR_GPIOAEN_Msk = 0x1
	// Bit GPIOAEN.
	RCC_AHB2ENR_GPIOAEN = 0x1
	// Position of GPIOBEN field.
	RCC_AHB2ENR_GPIOBEN_Pos = 0x1
	// Bit mask of GPIOBEN field.
	RCC_AHB2ENR_GPIOBEN_Msk = 0x2
	// Bit GPIOBEN.
	RCC_AHB2ENR_GPIOBEN = 0x2
	// Position of GPIOCEN field.
	RCC_AHB2ENR_GPIOCEN_Pos = 0x2
	// Bit mask of GPIOCEN field.
	RCC_AHB2ENR_GPIOCEN_Msk = 0x4
	// Bit GPIOCEN.
	RCC_AHB2ENR_GPIOCEN = 0x4
	// Position of GPIODEN field.
	RCC_AHB2ENR_GPIODEN_Pos = 0x3
	// Bit mask of GPIODEN field.
	RCC_AHB2ENR_GPIODEN_Msk = 0x8
	// Bit GPIODEN.
	RCC_AHB2ENR_GPIODEN = 0x8
	// Position of GPIOEEN field.
	RCC_AHB2ENR_GPIOEEN_Pos = 0x4
	// Bit mask of GPIOEEN field.
	RCC_AHB2ENR_GPIOEEN_Msk = 0x10
	// Bit GPIOEEN.
	RCC_AHB2ENR_GPIOEEN = 0x10
	// Position of GPIOFEN field.
	RCC_AHB2ENR_GPIOFEN_Pos = 0x5
	// Bit mask of GPIOFEN field.
	RCC_AHB2ENR_GPIOFEN_Msk = 0x20
	// Bit GPIOFEN.
	RCC_AHB2ENR_GPIOFEN = 0x20
	// Position of GPIOGEN field.
	RCC_AHB2ENR_GPIOGEN_Pos = 0x6
	// Bit mask of GPIOGEN field.
	RCC_AHB2ENR_GPIOGEN_Msk = 0x40
	// Bit GPIOGEN.
	RCC_AHB2ENR_GPIOGEN = 0x40
	// Position of GPIOHEN field.
	RCC_AHB2ENR_GPIOHEN_Pos = 0x7
	// Bit mask of GPIOHEN field.
	RCC_AHB2ENR_GPIOHEN_Msk = 0x80
	// Bit GPIOHEN.
	RCC_AHB2ENR_GPIOHEN = 0x80
	// Position of GPIOIEN field.
	RCC_AHB2ENR_GPIOIEN_Pos = 0x8
	// Bit mask of GPIOIEN field.
	RCC_AHB2ENR_GPIOIEN_Msk = 0x100
	// Bit GPIOIEN.
	RCC_AHB2ENR_GPIOIEN = 0x100
	// Position of OTGFSEN field.
	RCC_AHB2ENR_OTGFSEN_Pos = 0xc
	// Bit mask of OTGFSEN field.
	RCC_AHB2ENR_OTGFSEN_Msk = 0x1000
	// Bit OTGFSEN.
	RCC_AHB2ENR_OTGFSEN = 0x1000
	// Position of ADCEN field.
	RCC_AHB2ENR_ADCEN_Pos = 0xd
	// Bit mask of ADCEN field.
	RCC_AHB2ENR_ADCEN_Msk = 0x2000
	// Bit ADCEN.
	RCC_AHB2ENR_ADCEN = 0x2000
	// Position of DCMIEN field.
	RCC_AHB2ENR_DCMIEN_Pos = 0xe
	// Bit mask of DCMIEN field.
	RCC_AHB2ENR_DCMIEN_Msk = 0x4000
	// Bit DCMIEN.
	RCC_AHB2ENR_DCMIEN = 0x4000
	// Position of AESEN field.
	RCC_AHB2ENR_AESEN_Pos = 0x10
	// Bit mask of AESEN field.
	RCC_AHB2ENR_AESEN_Msk = 0x10000
	// Bit AESEN.
	RCC_AHB2ENR_AESEN = 0x10000
	// Position of HASHEN field.
	RCC_AHB2ENR_HASHEN_Pos = 0x11
	// Bit mask of HASHEN field.
	RCC_AHB2ENR_HASHEN_Msk = 0x20000
	// Bit HASHEN.
	RCC_AHB2ENR_HASHEN = 0x20000
	// Position of RNGEN field.
	RCC_AHB2ENR_RNGEN_Pos = 0x12
	// Bit mask of RNGEN field.
	RCC_AHB2ENR_RNGEN_Msk = 0x40000
	// Bit RNGEN.
	RCC_AHB2ENR_RNGEN = 0x40000
	// Position of OSPIMEN field.
	RCC_AHB2ENR_OSPIMEN_Pos = 0x14
	// Bit mask of OSPIMEN field.
	RCC_AHB2ENR_OSPIMEN_Msk = 0x100000
	// Bit OSPIMEN.
	RCC_AHB2ENR_OSPIMEN = 0x100000
	// Position of SDMMC1EN field.
	RCC_AHB2ENR_SDMMC1EN_Pos = 0x16
	// Bit mask of SDMMC1EN field.
	RCC_AHB2ENR_SDMMC1EN_Msk = 0x400000
	// Bit SDMMC1EN.
	RCC_AHB2ENR_SDMMC1EN = 0x400000

	// AHB3ENR: AHB3 peripheral clock enable register
	// Position of FMCEN field.
	RCC_AHB3ENR_FMCEN_Pos = 0x0
	// Bit mask of FMCEN field.
	RCC_AHB3ENR_FMCEN_Msk = 0x1
	// Bit FMCEN.
	RCC_AHB3ENR_FMCEN = 0x1
	// Position of OSPI2EN field.
	RCC_AHB3ENR_OSPI2EN_Pos = 0x9
	// Bit mask of OSPI2EN field.
	RCC_AHB3ENR_OSPI2EN_Msk = 0x200
	// Bit OSPI2EN.
	RCC_AHB3ENR_OSPI2EN = 0x200

	// APB1ENR1: APB1ENR1
	// Position of TIM2EN field.
	RCC_APB1ENR1_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_APB1ENR1_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_APB1ENR1_TIM2EN = 0x1
	// Position of TIM3EN field.
	RCC_APB1ENR1_TIM3EN_Pos = 0x1
	// Bit mask of TIM3EN field.
	RCC_APB1ENR1_TIM3EN_Msk = 0x2
	// Bit TIM3EN.
	RCC_APB1ENR1_TIM3EN = 0x2
	// Position of TIM4EN field.
	RCC_APB1ENR1_TIM4EN_Pos = 0x2
	// Bit mask of TIM4EN field.
	RCC_APB1ENR1_TIM4EN_Msk = 0x4
	// Bit TIM4EN.
	RCC_APB1ENR1_TIM4EN = 0x4
	// Position of TIM5EN field.
	RCC_APB1ENR1_TIM5EN_Pos = 0x3
	// Bit mask of TIM5EN field.
	RCC_APB1ENR1_TIM5EN_Msk = 0x8
	// Bit TIM5EN.
	RCC_APB1ENR1_TIM5EN = 0x8
	// Position of TIM6EN field.
	RCC_APB1ENR1_TIM6EN_Pos = 0x4
	// Bit mask of TIM6EN field.
	RCC_APB1ENR1_TIM6EN_Msk = 0x10
	// Bit TIM6EN.
	RCC_APB1ENR1_TIM6EN = 0x10
	// Position of TIM7EN field.
	RCC_APB1ENR1_TIM7EN_Pos = 0x5
	// Bit mask of TIM7EN field.
	RCC_APB1ENR1_TIM7EN_Msk = 0x20
	// Bit TIM7EN.
	RCC_APB1ENR1_TIM7EN = 0x20
	// Position of RTCAPBEN field.
	RCC_APB1ENR1_RTCAPBEN_Pos = 0xa
	// Bit mask of RTCAPBEN field.
	RCC_APB1ENR1_RTCAPBEN_Msk = 0x400
	// Bit RTCAPBEN.
	RCC_APB1ENR1_RTCAPBEN = 0x400
	// Position of WWDGEN field.
	RCC_APB1ENR1_WWDGEN_Pos = 0xb
	// Bit mask of WWDGEN field.
	RCC_APB1ENR1_WWDGEN_Msk = 0x800
	// Bit WWDGEN.
	RCC_APB1ENR1_WWDGEN = 0x800
	// Position of SPI2EN field.
	RCC_APB1ENR1_SPI2EN_Pos = 0xe
	// Bit mask of SPI2EN field.
	RCC_APB1ENR1_SPI2EN_Msk = 0x4000
	// Bit SPI2EN.
	RCC_APB1ENR1_SPI2EN = 0x4000
	// Position of SPI3EN field.
	RCC_APB1ENR1_SPI3EN_Pos = 0xf
	// Bit mask of SPI3EN field.
	RCC_APB1ENR1_SPI3EN_Msk = 0x8000
	// Bit SPI3EN.
	RCC_APB1ENR1_SPI3EN = 0x8000
	// Position of USART2EN field.
	RCC_APB1ENR1_USART2EN_Pos = 0x11
	// Bit mask of USART2EN field.
	RCC_APB1ENR1_USART2EN_Msk = 0x20000
	// Bit USART2EN.
	RCC_APB1ENR1_USART2EN = 0x20000
	// Position of USART3EN field.
	RCC_APB1ENR1_USART3EN_Pos = 0x12
	// Bit mask of USART3EN field.
	RCC_APB1ENR1_USART3EN_Msk = 0x40000
	// Bit USART3EN.
	RCC_APB1ENR1_USART3EN = 0x40000
	// Position of UART4EN field.
	RCC_APB1ENR1_UART4EN_Pos = 0x13
	// Bit mask of UART4EN field.
	RCC_APB1ENR1_UART4EN_Msk = 0x80000
	// Bit UART4EN.
	RCC_APB1ENR1_UART4EN = 0x80000
	// Position of UART5EN field.
	RCC_APB1ENR1_UART5EN_Pos = 0x14
	// Bit mask of UART5EN field.
	RCC_APB1ENR1_UART5EN_Msk = 0x100000
	// Bit UART5EN.
	RCC_APB1ENR1_UART5EN = 0x100000
	// Position of I2C1EN field.
	RCC_APB1ENR1_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_APB1ENR1_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_APB1ENR1_I2C1EN = 0x200000
	// Position of I2C2EN field.
	RCC_APB1ENR1_I2C2EN_Pos = 0x16
	// Bit mask of I2C2EN field.
	RCC_APB1ENR1_I2C2EN_Msk = 0x400000
	// Bit I2C2EN.
	RCC_APB1ENR1_I2C2EN = 0x400000
	// Position of I2C3EN field.
	RCC_APB1ENR1_I2C3EN_Pos = 0x17
	// Bit mask of I2C3EN field.
	RCC_APB1ENR1_I2C3EN_Msk = 0x800000
	// Bit I2C3EN.
	RCC_APB1ENR1_I2C3EN = 0x800000
	// Position of CRSEN field.
	RCC_APB1ENR1_CRSEN_Pos = 0x18
	// Bit mask of CRSEN field.
	RCC_APB1ENR1_CRSEN_Msk = 0x1000000
	// Bit CRSEN.
	RCC_APB1ENR1_CRSEN = 0x1000000
	// Position of CAN1EN field.
	RCC_APB1ENR1_CAN1EN_Pos = 0x19
	// Bit mask of CAN1EN field.
	RCC_APB1ENR1_CAN1EN_Msk = 0x2000000
	// Bit CAN1EN.
	RCC_APB1ENR1_CAN1EN = 0x2000000
	// Position of PWREN field.
	RCC_APB1ENR1_PWREN_Pos = 0x1c
	// Bit mask of PWREN field.
	RCC_APB1ENR1_PWREN_Msk = 0x10000000
	// Bit PWREN.
	RCC_APB1ENR1_PWREN = 0x10000000
	// Position of DAC1EN field.
	RCC_APB1ENR1_DAC1EN_Pos = 0x1d
	// Bit mask of DAC1EN field.
	RCC_APB1ENR1_DAC1EN_Msk = 0x20000000
	// Bit DAC1EN.
	RCC_APB1ENR1_DAC1EN = 0x20000000
	// Position of OPAMPEN field.
	RCC_APB1ENR1_OPAMPEN_Pos = 0x1e
	// Bit mask of OPAMPEN field.
	RCC_APB1ENR1_OPAMPEN_Msk = 0x40000000
	// Bit OPAMPEN.
	RCC_APB1ENR1_OPAMPEN = 0x40000000
	// Position of LPTIM1EN field.
	RCC_APB1ENR1_LPTIM1EN_Pos = 0x1f
	// Bit mask of LPTIM1EN field.
	RCC_APB1ENR1_LPTIM1EN_Msk = 0x80000000
	// Bit LPTIM1EN.
	RCC_APB1ENR1_LPTIM1EN = 0x80000000

	// APB1ENR2: APB1 peripheral clock enable register 2
	// Position of LPUART1EN field.
	RCC_APB1ENR2_LPUART1EN_Pos = 0x0
	// Bit mask of LPUART1EN field.
	RCC_APB1ENR2_LPUART1EN_Msk = 0x1
	// Bit LPUART1EN.
	RCC_APB1ENR2_LPUART1EN = 0x1
	// Position of I2C4EN field.
	RCC_APB1ENR2_I2C4EN_Pos = 0x1
	// Bit mask of I2C4EN field.
	RCC_APB1ENR2_I2C4EN_Msk = 0x2
	// Bit I2C4EN.
	RCC_APB1ENR2_I2C4EN = 0x2
	// Position of LPTIM2EN field.
	RCC_APB1ENR2_LPTIM2EN_Pos = 0x5
	// Bit mask of LPTIM2EN field.
	RCC_APB1ENR2_LPTIM2EN_Msk = 0x20
	// Bit LPTIM2EN.
	RCC_APB1ENR2_LPTIM2EN = 0x20

	// APB2ENR: APB2ENR
	// Position of SYSCFGEN field.
	RCC_APB2ENR_SYSCFGEN_Pos = 0x0
	// Bit mask of SYSCFGEN field.
	RCC_APB2ENR_SYSCFGEN_Msk = 0x1
	// Bit SYSCFGEN.
	RCC_APB2ENR_SYSCFGEN = 0x1
	// Position of FWEN field.
	RCC_APB2ENR_FWEN_Pos = 0x7
	// Bit mask of FWEN field.
	RCC_APB2ENR_FWEN_Msk = 0x80
	// Bit FWEN.
	RCC_APB2ENR_FWEN = 0x80
	// Position of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Pos = 0xb
	// Bit mask of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Msk = 0x800
	// Bit TIM1EN.
	RCC_APB2ENR_TIM1EN = 0x800
	// Position of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_APB2ENR_SPI1EN = 0x1000
	// Position of TIM8EN field.
	RCC_APB2ENR_TIM8EN_Pos = 0xd
	// Bit mask of TIM8EN field.
	RCC_APB2ENR_TIM8EN_Msk = 0x2000
	// Bit TIM8EN.
	RCC_APB2ENR_TIM8EN = 0x2000
	// Position of USART1EN field.
	RCC_APB2ENR_USART1EN_Pos = 0xe
	// Bit mask of USART1EN field.
	RCC_APB2ENR_USART1EN_Msk = 0x4000
	// Bit USART1EN.
	RCC_APB2ENR_USART1EN = 0x4000
	// Position of TIM15EN field.
	RCC_APB2ENR_TIM15EN_Pos = 0x10
	// Bit mask of TIM15EN field.
	RCC_APB2ENR_TIM15EN_Msk = 0x10000
	// Bit TIM15EN.
	RCC_APB2ENR_TIM15EN = 0x10000
	// Position of TIM16EN field.
	RCC_APB2ENR_TIM16EN_Pos = 0x11
	// Bit mask of TIM16EN field.
	RCC_APB2ENR_TIM16EN_Msk = 0x20000
	// Bit TIM16EN.
	RCC_APB2ENR_TIM16EN = 0x20000
	// Position of TIM17EN field.
	RCC_APB2ENR_TIM17EN_Pos = 0x12
	// Bit mask of TIM17EN field.
	RCC_APB2ENR_TIM17EN_Msk = 0x40000
	// Bit TIM17EN.
	RCC_APB2ENR_TIM17EN = 0x40000
	// Position of SAI1EN field.
	RCC_APB2ENR_SAI1EN_Pos = 0x15
	// Bit mask of SAI1EN field.
	RCC_APB2ENR_SAI1EN_Msk = 0x200000
	// Bit SAI1EN.
	RCC_APB2ENR_SAI1EN = 0x200000
	// Position of SAI2EN field.
	RCC_APB2ENR_SAI2EN_Pos = 0x16
	// Bit mask of SAI2EN field.
	RCC_APB2ENR_SAI2EN_Msk = 0x400000
	// Bit SAI2EN.
	RCC_APB2ENR_SAI2EN = 0x400000
	// Position of DFSDM1EN field.
	RCC_APB2ENR_DFSDM1EN_Pos = 0x18
	// Bit mask of DFSDM1EN field.
	RCC_APB2ENR_DFSDM1EN_Msk = 0x1000000
	// Bit DFSDM1EN.
	RCC_APB2ENR_DFSDM1EN = 0x1000000
	// Position of LTDCEN field.
	RCC_APB2ENR_LTDCEN_Pos = 0x1a
	// Bit mask of LTDCEN field.
	RCC_APB2ENR_LTDCEN_Msk = 0x4000000
	// Bit LTDCEN.
	RCC_APB2ENR_LTDCEN = 0x4000000
	// Position of DSIEN field.
	RCC_APB2ENR_DSIEN_Pos = 0x1b
	// Bit mask of DSIEN field.
	RCC_APB2ENR_DSIEN_Msk = 0x8000000
	// Bit DSIEN.
	RCC_APB2ENR_DSIEN = 0x8000000

	// AHB1SMENR: AHB1 peripheral clocks enable in Sleep and Stop modes register
	// Position of DMA1SMEN field.
	RCC_AHB1SMENR_DMA1SMEN_Pos = 0x0
	// Bit mask of DMA1SMEN field.
	RCC_AHB1SMENR_DMA1SMEN_Msk = 0x1
	// Bit DMA1SMEN.
	RCC_AHB1SMENR_DMA1SMEN = 0x1
	// Position of DMA2SMEN field.
	RCC_AHB1SMENR_DMA2SMEN_Pos = 0x1
	// Bit mask of DMA2SMEN field.
	RCC_AHB1SMENR_DMA2SMEN_Msk = 0x2
	// Bit DMA2SMEN.
	RCC_AHB1SMENR_DMA2SMEN = 0x2
	// Position of DMAMUX1SMEN field.
	RCC_AHB1SMENR_DMAMUX1SMEN_Pos = 0x2
	// Bit mask of DMAMUX1SMEN field.
	RCC_AHB1SMENR_DMAMUX1SMEN_Msk = 0x4
	// Bit DMAMUX1SMEN.
	RCC_AHB1SMENR_DMAMUX1SMEN = 0x4
	// Position of FLASHSMEN field.
	RCC_AHB1SMENR_FLASHSMEN_Pos = 0x8
	// Bit mask of FLASHSMEN field.
	RCC_AHB1SMENR_FLASHSMEN_Msk = 0x100
	// Bit FLASHSMEN.
	RCC_AHB1SMENR_FLASHSMEN = 0x100
	// Position of SRAM1SMEN field.
	RCC_AHB1SMENR_SRAM1SMEN_Pos = 0x9
	// Bit mask of SRAM1SMEN field.
	RCC_AHB1SMENR_SRAM1SMEN_Msk = 0x200
	// Bit SRAM1SMEN.
	RCC_AHB1SMENR_SRAM1SMEN = 0x200
	// Position of CRCSMEN field.
	RCC_AHB1SMENR_CRCSMEN_Pos = 0xc
	// Bit mask of CRCSMEN field.
	RCC_AHB1SMENR_CRCSMEN_Msk = 0x1000
	// Bit CRCSMEN.
	RCC_AHB1SMENR_CRCSMEN = 0x1000
	// Position of TSCSMEN field.
	RCC_AHB1SMENR_TSCSMEN_Pos = 0x10
	// Bit mask of TSCSMEN field.
	RCC_AHB1SMENR_TSCSMEN_Msk = 0x10000
	// Bit TSCSMEN.
	RCC_AHB1SMENR_TSCSMEN = 0x10000
	// Position of DMA2DSMEN field.
	RCC_AHB1SMENR_DMA2DSMEN_Pos = 0x11
	// Bit mask of DMA2DSMEN field.
	RCC_AHB1SMENR_DMA2DSMEN_Msk = 0x20000
	// Bit DMA2DSMEN.
	RCC_AHB1SMENR_DMA2DSMEN = 0x20000
	// Position of GFXMMUSMEN field.
	RCC_AHB1SMENR_GFXMMUSMEN_Pos = 0x12
	// Bit mask of GFXMMUSMEN field.
	RCC_AHB1SMENR_GFXMMUSMEN_Msk = 0x40000
	// Bit GFXMMUSMEN.
	RCC_AHB1SMENR_GFXMMUSMEN = 0x40000

	// AHB2SMENR: AHB2 peripheral clocks enable in Sleep and Stop modes register
	// Position of GPIOASMEN field.
	RCC_AHB2SMENR_GPIOASMEN_Pos = 0x0
	// Bit mask of GPIOASMEN field.
	RCC_AHB2SMENR_GPIOASMEN_Msk = 0x1
	// Bit GPIOASMEN.
	RCC_AHB2SMENR_GPIOASMEN = 0x1
	// Position of GPIOBSMEN field.
	RCC_AHB2SMENR_GPIOBSMEN_Pos = 0x1
	// Bit mask of GPIOBSMEN field.
	RCC_AHB2SMENR_GPIOBSMEN_Msk = 0x2
	// Bit GPIOBSMEN.
	RCC_AHB2SMENR_GPIOBSMEN = 0x2
	// Position of GPIOCSMEN field.
	RCC_AHB2SMENR_GPIOCSMEN_Pos = 0x2
	// Bit mask of GPIOCSMEN field.
	RCC_AHB2SMENR_GPIOCSMEN_Msk = 0x4
	// Bit GPIOCSMEN.
	RCC_AHB2SMENR_GPIOCSMEN = 0x4
	// Position of GPIODSMEN field.
	RCC_AHB2SMENR_GPIODSMEN_Pos = 0x3
	// Bit mask of GPIODSMEN field.
	RCC_AHB2SMENR_GPIODSMEN_Msk = 0x8
	// Bit GPIODSMEN.
	RCC_AHB2SMENR_GPIODSMEN = 0x8
	// Position of GPIOESMEN field.
	RCC_AHB2SMENR_GPIOESMEN_Pos = 0x4
	// Bit mask of GPIOESMEN field.
	RCC_AHB2SMENR_GPIOESMEN_Msk = 0x10
	// Bit GPIOESMEN.
	RCC_AHB2SMENR_GPIOESMEN = 0x10
	// Position of GPIOFSMEN field.
	RCC_AHB2SMENR_GPIOFSMEN_Pos = 0x5
	// Bit mask of GPIOFSMEN field.
	RCC_AHB2SMENR_GPIOFSMEN_Msk = 0x20
	// Bit GPIOFSMEN.
	RCC_AHB2SMENR_GPIOFSMEN = 0x20
	// Position of GPIOGSMEN field.
	RCC_AHB2SMENR_GPIOGSMEN_Pos = 0x6
	// Bit mask of GPIOGSMEN field.
	RCC_AHB2SMENR_GPIOGSMEN_Msk = 0x40
	// Bit GPIOGSMEN.
	RCC_AHB2SMENR_GPIOGSMEN = 0x40
	// Position of GPIOHSMEN field.
	RCC_AHB2SMENR_GPIOHSMEN_Pos = 0x7
	// Bit mask of GPIOHSMEN field.
	RCC_AHB2SMENR_GPIOHSMEN_Msk = 0x80
	// Bit GPIOHSMEN.
	RCC_AHB2SMENR_GPIOHSMEN = 0x80
	// Position of GPIOISMEN field.
	RCC_AHB2SMENR_GPIOISMEN_Pos = 0x8
	// Bit mask of GPIOISMEN field.
	RCC_AHB2SMENR_GPIOISMEN_Msk = 0x100
	// Bit GPIOISMEN.
	RCC_AHB2SMENR_GPIOISMEN = 0x100
	// Position of SRAM2SMEN field.
	RCC_AHB2SMENR_SRAM2SMEN_Pos = 0x9
	// Bit mask of SRAM2SMEN field.
	RCC_AHB2SMENR_SRAM2SMEN_Msk = 0x200
	// Bit SRAM2SMEN.
	RCC_AHB2SMENR_SRAM2SMEN = 0x200
	// Position of SRAM3SMEN field.
	RCC_AHB2SMENR_SRAM3SMEN_Pos = 0xa
	// Bit mask of SRAM3SMEN field.
	RCC_AHB2SMENR_SRAM3SMEN_Msk = 0x400
	// Bit SRAM3SMEN.
	RCC_AHB2SMENR_SRAM3SMEN = 0x400
	// Position of OTGFSSMEN field.
	RCC_AHB2SMENR_OTGFSSMEN_Pos = 0xc
	// Bit mask of OTGFSSMEN field.
	RCC_AHB2SMENR_OTGFSSMEN_Msk = 0x1000
	// Bit OTGFSSMEN.
	RCC_AHB2SMENR_OTGFSSMEN = 0x1000
	// Position of ADCFSSMEN field.
	RCC_AHB2SMENR_ADCFSSMEN_Pos = 0xd
	// Bit mask of ADCFSSMEN field.
	RCC_AHB2SMENR_ADCFSSMEN_Msk = 0x2000
	// Bit ADCFSSMEN.
	RCC_AHB2SMENR_ADCFSSMEN = 0x2000
	// Position of DCMISMEN field.
	RCC_AHB2SMENR_DCMISMEN_Pos = 0xe
	// Bit mask of DCMISMEN field.
	RCC_AHB2SMENR_DCMISMEN_Msk = 0x4000
	// Bit DCMISMEN.
	RCC_AHB2SMENR_DCMISMEN = 0x4000
	// Position of AESSMEN field.
	RCC_AHB2SMENR_AESSMEN_Pos = 0x10
	// Bit mask of AESSMEN field.
	RCC_AHB2SMENR_AESSMEN_Msk = 0x10000
	// Bit AESSMEN.
	RCC_AHB2SMENR_AESSMEN = 0x10000
	// Position of HASHSMEN field.
	RCC_AHB2SMENR_HASHSMEN_Pos = 0x11
	// Bit mask of HASHSMEN field.
	RCC_AHB2SMENR_HASHSMEN_Msk = 0x20000
	// Bit HASHSMEN.
	RCC_AHB2SMENR_HASHSMEN = 0x20000
	// Position of RNGSMEN field.
	RCC_AHB2SMENR_RNGSMEN_Pos = 0x12
	// Bit mask of RNGSMEN field.
	RCC_AHB2SMENR_RNGSMEN_Msk = 0x40000
	// Bit RNGSMEN.
	RCC_AHB2SMENR_RNGSMEN = 0x40000
	// Position of OSPIMSMEN field.
	RCC_AHB2SMENR_OSPIMSMEN_Pos = 0x14
	// Bit mask of OSPIMSMEN field.
	RCC_AHB2SMENR_OSPIMSMEN_Msk = 0x100000
	// Bit OSPIMSMEN.
	RCC_AHB2SMENR_OSPIMSMEN = 0x100000
	// Position of SDMMC1SMEN field.
	RCC_AHB2SMENR_SDMMC1SMEN_Pos = 0x16
	// Bit mask of SDMMC1SMEN field.
	RCC_AHB2SMENR_SDMMC1SMEN_Msk = 0x400000
	// Bit SDMMC1SMEN.
	RCC_AHB2SMENR_SDMMC1SMEN = 0x400000

	// AHB3SMENR: AHB3 peripheral clocks enable in Sleep and Stop modes register
	// Position of FMCSMEN field.
	RCC_AHB3SMENR_FMCSMEN_Pos = 0x0
	// Bit mask of FMCSMEN field.
	RCC_AHB3SMENR_FMCSMEN_Msk = 0x1
	// Bit FMCSMEN.
	RCC_AHB3SMENR_FMCSMEN = 0x1
	// Position of OCTOSPI2 field.
	RCC_AHB3SMENR_OCTOSPI2_Pos = 0x9
	// Bit mask of OCTOSPI2 field.
	RCC_AHB3SMENR_OCTOSPI2_Msk = 0x200
	// Bit OCTOSPI2.
	RCC_AHB3SMENR_OCTOSPI2 = 0x200

	// APB1SMENR1: APB1SMENR1
	// Position of TIM2SMEN field.
	RCC_APB1SMENR1_TIM2SMEN_Pos = 0x0
	// Bit mask of TIM2SMEN field.
	RCC_APB1SMENR1_TIM2SMEN_Msk = 0x1
	// Bit TIM2SMEN.
	RCC_APB1SMENR1_TIM2SMEN = 0x1
	// Position of TIM3SMEN field.
	RCC_APB1SMENR1_TIM3SMEN_Pos = 0x1
	// Bit mask of TIM3SMEN field.
	RCC_APB1SMENR1_TIM3SMEN_Msk = 0x2
	// Bit TIM3SMEN.
	RCC_APB1SMENR1_TIM3SMEN = 0x2
	// Position of TIM4SMEN field.
	RCC_APB1SMENR1_TIM4SMEN_Pos = 0x2
	// Bit mask of TIM4SMEN field.
	RCC_APB1SMENR1_TIM4SMEN_Msk = 0x4
	// Bit TIM4SMEN.
	RCC_APB1SMENR1_TIM4SMEN = 0x4
	// Position of TIM5SMEN field.
	RCC_APB1SMENR1_TIM5SMEN_Pos = 0x3
	// Bit mask of TIM5SMEN field.
	RCC_APB1SMENR1_TIM5SMEN_Msk = 0x8
	// Bit TIM5SMEN.
	RCC_APB1SMENR1_TIM5SMEN = 0x8
	// Position of TIM6SMEN field.
	RCC_APB1SMENR1_TIM6SMEN_Pos = 0x4
	// Bit mask of TIM6SMEN field.
	RCC_APB1SMENR1_TIM6SMEN_Msk = 0x10
	// Bit TIM6SMEN.
	RCC_APB1SMENR1_TIM6SMEN = 0x10
	// Position of TIM7SMEN field.
	RCC_APB1SMENR1_TIM7SMEN_Pos = 0x5
	// Bit mask of TIM7SMEN field.
	RCC_APB1SMENR1_TIM7SMEN_Msk = 0x20
	// Bit TIM7SMEN.
	RCC_APB1SMENR1_TIM7SMEN = 0x20
	// Position of RTCAPBSMEN field.
	RCC_APB1SMENR1_RTCAPBSMEN_Pos = 0xa
	// Bit mask of RTCAPBSMEN field.
	RCC_APB1SMENR1_RTCAPBSMEN_Msk = 0x400
	// Bit RTCAPBSMEN.
	RCC_APB1SMENR1_RTCAPBSMEN = 0x400
	// Position of WWDGSMEN field.
	RCC_APB1SMENR1_WWDGSMEN_Pos = 0xb
	// Bit mask of WWDGSMEN field.
	RCC_APB1SMENR1_WWDGSMEN_Msk = 0x800
	// Bit WWDGSMEN.
	RCC_APB1SMENR1_WWDGSMEN = 0x800
	// Position of SPI2SMEN field.
	RCC_APB1SMENR1_SPI2SMEN_Pos = 0xe
	// Bit mask of SPI2SMEN field.
	RCC_APB1SMENR1_SPI2SMEN_Msk = 0x4000
	// Bit SPI2SMEN.
	RCC_APB1SMENR1_SPI2SMEN = 0x4000
	// Position of SP3SMEN field.
	RCC_APB1SMENR1_SP3SMEN_Pos = 0xf
	// Bit mask of SP3SMEN field.
	RCC_APB1SMENR1_SP3SMEN_Msk = 0x8000
	// Bit SP3SMEN.
	RCC_APB1SMENR1_SP3SMEN = 0x8000
	// Position of USART2SMEN field.
	RCC_APB1SMENR1_USART2SMEN_Pos = 0x11
	// Bit mask of USART2SMEN field.
	RCC_APB1SMENR1_USART2SMEN_Msk = 0x20000
	// Bit USART2SMEN.
	RCC_APB1SMENR1_USART2SMEN = 0x20000
	// Position of USART3SMEN field.
	RCC_APB1SMENR1_USART3SMEN_Pos = 0x12
	// Bit mask of USART3SMEN field.
	RCC_APB1SMENR1_USART3SMEN_Msk = 0x40000
	// Bit USART3SMEN.
	RCC_APB1SMENR1_USART3SMEN = 0x40000
	// Position of UART4SMEN field.
	RCC_APB1SMENR1_UART4SMEN_Pos = 0x13
	// Bit mask of UART4SMEN field.
	RCC_APB1SMENR1_UART4SMEN_Msk = 0x80000
	// Bit UART4SMEN.
	RCC_APB1SMENR1_UART4SMEN = 0x80000
	// Position of UART5SMEN field.
	RCC_APB1SMENR1_UART5SMEN_Pos = 0x14
	// Bit mask of UART5SMEN field.
	RCC_APB1SMENR1_UART5SMEN_Msk = 0x100000
	// Bit UART5SMEN.
	RCC_APB1SMENR1_UART5SMEN = 0x100000
	// Position of I2C1SMEN field.
	RCC_APB1SMENR1_I2C1SMEN_Pos = 0x15
	// Bit mask of I2C1SMEN field.
	RCC_APB1SMENR1_I2C1SMEN_Msk = 0x200000
	// Bit I2C1SMEN.
	RCC_APB1SMENR1_I2C1SMEN = 0x200000
	// Position of I2C2SMEN field.
	RCC_APB1SMENR1_I2C2SMEN_Pos = 0x16
	// Bit mask of I2C2SMEN field.
	RCC_APB1SMENR1_I2C2SMEN_Msk = 0x400000
	// Bit I2C2SMEN.
	RCC_APB1SMENR1_I2C2SMEN = 0x400000
	// Position of I2C3SMEN field.
	RCC_APB1SMENR1_I2C3SMEN_Pos = 0x17
	// Bit mask of I2C3SMEN field.
	RCC_APB1SMENR1_I2C3SMEN_Msk = 0x800000
	// Bit I2C3SMEN.
	RCC_APB1SMENR1_I2C3SMEN = 0x800000
	// Position of CRSSMEN field.
	RCC_APB1SMENR1_CRSSMEN_Pos = 0x18
	// Bit mask of CRSSMEN field.
	RCC_APB1SMENR1_CRSSMEN_Msk = 0x1000000
	// Bit CRSSMEN.
	RCC_APB1SMENR1_CRSSMEN = 0x1000000
	// Position of CAN1SMEN field.
	RCC_APB1SMENR1_CAN1SMEN_Pos = 0x19
	// Bit mask of CAN1SMEN field.
	RCC_APB1SMENR1_CAN1SMEN_Msk = 0x2000000
	// Bit CAN1SMEN.
	RCC_APB1SMENR1_CAN1SMEN = 0x2000000
	// Position of PWRSMEN field.
	RCC_APB1SMENR1_PWRSMEN_Pos = 0x1c
	// Bit mask of PWRSMEN field.
	RCC_APB1SMENR1_PWRSMEN_Msk = 0x10000000
	// Bit PWRSMEN.
	RCC_APB1SMENR1_PWRSMEN = 0x10000000
	// Position of DAC1SMEN field.
	RCC_APB1SMENR1_DAC1SMEN_Pos = 0x1d
	// Bit mask of DAC1SMEN field.
	RCC_APB1SMENR1_DAC1SMEN_Msk = 0x20000000
	// Bit DAC1SMEN.
	RCC_APB1SMENR1_DAC1SMEN = 0x20000000
	// Position of OPAMPSMEN field.
	RCC_APB1SMENR1_OPAMPSMEN_Pos = 0x1e
	// Bit mask of OPAMPSMEN field.
	RCC_APB1SMENR1_OPAMPSMEN_Msk = 0x40000000
	// Bit OPAMPSMEN.
	RCC_APB1SMENR1_OPAMPSMEN = 0x40000000
	// Position of LPTIM1SMEN field.
	RCC_APB1SMENR1_LPTIM1SMEN_Pos = 0x1f
	// Bit mask of LPTIM1SMEN field.
	RCC_APB1SMENR1_LPTIM1SMEN_Msk = 0x80000000
	// Bit LPTIM1SMEN.
	RCC_APB1SMENR1_LPTIM1SMEN = 0x80000000

	// APB1SMENR2: APB1 peripheral clocks enable in Sleep and Stop modes register 2
	// Position of LPUART1SMEN field.
	RCC_APB1SMENR2_LPUART1SMEN_Pos = 0x0
	// Bit mask of LPUART1SMEN field.
	RCC_APB1SMENR2_LPUART1SMEN_Msk = 0x1
	// Bit LPUART1SMEN.
	RCC_APB1SMENR2_LPUART1SMEN = 0x1
	// Position of I2C4SMEN field.
	RCC_APB1SMENR2_I2C4SMEN_Pos = 0x1
	// Bit mask of I2C4SMEN field.
	RCC_APB1SMENR2_I2C4SMEN_Msk = 0x2
	// Bit I2C4SMEN.
	RCC_APB1SMENR2_I2C4SMEN = 0x2
	// Position of LPTIM2SMEN field.
	RCC_APB1SMENR2_LPTIM2SMEN_Pos = 0x5
	// Bit mask of LPTIM2SMEN field.
	RCC_APB1SMENR2_LPTIM2SMEN_Msk = 0x20
	// Bit LPTIM2SMEN.
	RCC_APB1SMENR2_LPTIM2SMEN = 0x20

	// APB2SMENR: APB2SMENR
	// Position of SYSCFGSMEN field.
	RCC_APB2SMENR_SYSCFGSMEN_Pos = 0x0
	// Bit mask of SYSCFGSMEN field.
	RCC_APB2SMENR_SYSCFGSMEN_Msk = 0x1
	// Bit SYSCFGSMEN.
	RCC_APB2SMENR_SYSCFGSMEN = 0x1
	// Position of TIM1SMEN field.
	RCC_APB2SMENR_TIM1SMEN_Pos = 0xb
	// Bit mask of TIM1SMEN field.
	RCC_APB2SMENR_TIM1SMEN_Msk = 0x800
	// Bit TIM1SMEN.
	RCC_APB2SMENR_TIM1SMEN = 0x800
	// Position of SPI1SMEN field.
	RCC_APB2SMENR_SPI1SMEN_Pos = 0xc
	// Bit mask of SPI1SMEN field.
	RCC_APB2SMENR_SPI1SMEN_Msk = 0x1000
	// Bit SPI1SMEN.
	RCC_APB2SMENR_SPI1SMEN = 0x1000
	// Position of TIM8SMEN field.
	RCC_APB2SMENR_TIM8SMEN_Pos = 0xd
	// Bit mask of TIM8SMEN field.
	RCC_APB2SMENR_TIM8SMEN_Msk = 0x2000
	// Bit TIM8SMEN.
	RCC_APB2SMENR_TIM8SMEN = 0x2000
	// Position of USART1SMEN field.
	RCC_APB2SMENR_USART1SMEN_Pos = 0xe
	// Bit mask of USART1SMEN field.
	RCC_APB2SMENR_USART1SMEN_Msk = 0x4000
	// Bit USART1SMEN.
	RCC_APB2SMENR_USART1SMEN = 0x4000
	// Position of TIM15SMEN field.
	RCC_APB2SMENR_TIM15SMEN_Pos = 0x10
	// Bit mask of TIM15SMEN field.
	RCC_APB2SMENR_TIM15SMEN_Msk = 0x10000
	// Bit TIM15SMEN.
	RCC_APB2SMENR_TIM15SMEN = 0x10000
	// Position of TIM16SMEN field.
	RCC_APB2SMENR_TIM16SMEN_Pos = 0x11
	// Bit mask of TIM16SMEN field.
	RCC_APB2SMENR_TIM16SMEN_Msk = 0x20000
	// Bit TIM16SMEN.
	RCC_APB2SMENR_TIM16SMEN = 0x20000
	// Position of TIM17SMEN field.
	RCC_APB2SMENR_TIM17SMEN_Pos = 0x12
	// Bit mask of TIM17SMEN field.
	RCC_APB2SMENR_TIM17SMEN_Msk = 0x40000
	// Bit TIM17SMEN.
	RCC_APB2SMENR_TIM17SMEN = 0x40000
	// Position of SAI1SMEN field.
	RCC_APB2SMENR_SAI1SMEN_Pos = 0x15
	// Bit mask of SAI1SMEN field.
	RCC_APB2SMENR_SAI1SMEN_Msk = 0x200000
	// Bit SAI1SMEN.
	RCC_APB2SMENR_SAI1SMEN = 0x200000
	// Position of SAI2SMEN field.
	RCC_APB2SMENR_SAI2SMEN_Pos = 0x16
	// Bit mask of SAI2SMEN field.
	RCC_APB2SMENR_SAI2SMEN_Msk = 0x400000
	// Bit SAI2SMEN.
	RCC_APB2SMENR_SAI2SMEN = 0x400000
	// Position of DFSDM1SMEN field.
	RCC_APB2SMENR_DFSDM1SMEN_Pos = 0x18
	// Bit mask of DFSDM1SMEN field.
	RCC_APB2SMENR_DFSDM1SMEN_Msk = 0x1000000
	// Bit DFSDM1SMEN.
	RCC_APB2SMENR_DFSDM1SMEN = 0x1000000
	// Position of LTDCSMEN field.
	RCC_APB2SMENR_LTDCSMEN_Pos = 0x1a
	// Bit mask of LTDCSMEN field.
	RCC_APB2SMENR_LTDCSMEN_Msk = 0x4000000
	// Bit LTDCSMEN.
	RCC_APB2SMENR_LTDCSMEN = 0x4000000
	// Position of DSISMEN field.
	RCC_APB2SMENR_DSISMEN_Pos = 0x1b
	// Bit mask of DSISMEN field.
	RCC_APB2SMENR_DSISMEN_Msk = 0x8000000
	// Bit DSISMEN.
	RCC_APB2SMENR_DSISMEN = 0x8000000

	// CCIPR: CCIPR
	// Position of ADCSEL field.
	RCC_CCIPR_ADCSEL_Pos = 0x1c
	// Bit mask of ADCSEL field.
	RCC_CCIPR_ADCSEL_Msk = 0x30000000
	// Position of CLK48SEL field.
	RCC_CCIPR_CLK48SEL_Pos = 0x1a
	// Bit mask of CLK48SEL field.
	RCC_CCIPR_CLK48SEL_Msk = 0xc000000
	// Position of SAI2SEL field.
	RCC_CCIPR_SAI2SEL_Pos = 0x18
	// Bit mask of SAI2SEL field.
	RCC_CCIPR_SAI2SEL_Msk = 0x3000000
	// Position of SAI1SEL field.
	RCC_CCIPR_SAI1SEL_Pos = 0x16
	// Bit mask of SAI1SEL field.
	RCC_CCIPR_SAI1SEL_Msk = 0xc00000
	// Position of LPTIM2SEL field.
	RCC_CCIPR_LPTIM2SEL_Pos = 0x14
	// Bit mask of LPTIM2SEL field.
	RCC_CCIPR_LPTIM2SEL_Msk = 0x300000
	// Position of LPTIM1SEL field.
	RCC_CCIPR_LPTIM1SEL_Pos = 0x12
	// Bit mask of LPTIM1SEL field.
	RCC_CCIPR_LPTIM1SEL_Msk = 0xc0000
	// Position of I2C3SEL field.
	RCC_CCIPR_I2C3SEL_Pos = 0x10
	// Bit mask of I2C3SEL field.
	RCC_CCIPR_I2C3SEL_Msk = 0x30000
	// Position of I2C2SEL field.
	RCC_CCIPR_I2C2SEL_Pos = 0xe
	// Bit mask of I2C2SEL field.
	RCC_CCIPR_I2C2SEL_Msk = 0xc000
	// Position of I2C1SEL field.
	RCC_CCIPR_I2C1SEL_Pos = 0xc
	// Bit mask of I2C1SEL field.
	RCC_CCIPR_I2C1SEL_Msk = 0x3000
	// Position of LPUART1SEL field.
	RCC_CCIPR_LPUART1SEL_Pos = 0xa
	// Bit mask of LPUART1SEL field.
	RCC_CCIPR_LPUART1SEL_Msk = 0xc00
	// Position of UART5SEL field.
	RCC_CCIPR_UART5SEL_Pos = 0x8
	// Bit mask of UART5SEL field.
	RCC_CCIPR_UART5SEL_Msk = 0x300
	// Position of UART4SEL field.
	RCC_CCIPR_UART4SEL_Pos = 0x6
	// Bit mask of UART4SEL field.
	RCC_CCIPR_UART4SEL_Msk = 0xc0
	// Position of USART3SEL field.
	RCC_CCIPR_USART3SEL_Pos = 0x4
	// Bit mask of USART3SEL field.
	RCC_CCIPR_USART3SEL_Msk = 0x30
	// Position of USART2SEL field.
	RCC_CCIPR_USART2SEL_Pos = 0x2
	// Bit mask of USART2SEL field.
	RCC_CCIPR_USART2SEL_Msk = 0xc
	// Position of USART1SEL field.
	RCC_CCIPR_USART1SEL_Pos = 0x0
	// Bit mask of USART1SEL field.
	RCC_CCIPR_USART1SEL_Msk = 0x3

	// BDCR: BDCR
	// Position of LSCOSEL field.
	RCC_BDCR_LSCOSEL_Pos = 0x19
	// Bit mask of LSCOSEL field.
	RCC_BDCR_LSCOSEL_Msk = 0x2000000
	// Bit LSCOSEL.
	RCC_BDCR_LSCOSEL = 0x2000000
	// Position of LSCOEN field.
	RCC_BDCR_LSCOEN_Pos = 0x18
	// Bit mask of LSCOEN field.
	RCC_BDCR_LSCOEN_Msk = 0x1000000
	// Bit LSCOEN.
	RCC_BDCR_LSCOEN = 0x1000000
	// Position of BDRST field.
	RCC_BDCR_BDRST_Pos = 0x10
	// Bit mask of BDRST field.
	RCC_BDCR_BDRST_Msk = 0x10000
	// Bit BDRST.
	RCC_BDCR_BDRST = 0x10000
	// Position of RTCEN field.
	RCC_BDCR_RTCEN_Pos = 0xf
	// Bit mask of RTCEN field.
	RCC_BDCR_RTCEN_Msk = 0x8000
	// Bit RTCEN.
	RCC_BDCR_RTCEN = 0x8000
	// Position of RTCSEL field.
	RCC_BDCR_RTCSEL_Pos = 0x8
	// Bit mask of RTCSEL field.
	RCC_BDCR_RTCSEL_Msk = 0x300
	// Position of LSECSSD field.
	RCC_BDCR_LSECSSD_Pos = 0x6
	// Bit mask of LSECSSD field.
	RCC_BDCR_LSECSSD_Msk = 0x40
	// Bit LSECSSD.
	RCC_BDCR_LSECSSD = 0x40
	// Position of LSECSSON field.
	RCC_BDCR_LSECSSON_Pos = 0x5
	// Bit mask of LSECSSON field.
	RCC_BDCR_LSECSSON_Msk = 0x20
	// Bit LSECSSON.
	RCC_BDCR_LSECSSON = 0x20
	// Position of LSEDRV field.
	RCC_BDCR_LSEDRV_Pos = 0x3
	// Bit mask of LSEDRV field.
	RCC_BDCR_LSEDRV_Msk = 0x18
	// Position of LSEBYP field.
	RCC_BDCR_LSEBYP_Pos = 0x2
	// Bit mask of LSEBYP field.
	RCC_BDCR_LSEBYP_Msk = 0x4
	// Bit LSEBYP.
	RCC_BDCR_LSEBYP = 0x4
	// Position of LSERDY field.
	RCC_BDCR_LSERDY_Pos = 0x1
	// Bit mask of LSERDY field.
	RCC_BDCR_LSERDY_Msk = 0x2
	// Bit LSERDY.
	RCC_BDCR_LSERDY = 0x2
	// Position of LSEON field.
	RCC_BDCR_LSEON_Pos = 0x0
	// Bit mask of LSEON field.
	RCC_BDCR_LSEON_Msk = 0x1
	// Bit LSEON.
	RCC_BDCR_LSEON = 0x1

	// CSR: CSR
	// Position of LPWRSTF field.
	RCC_CSR_LPWRSTF_Pos = 0x1f
	// Bit mask of LPWRSTF field.
	RCC_CSR_LPWRSTF_Msk = 0x80000000
	// Bit LPWRSTF.
	RCC_CSR_LPWRSTF = 0x80000000
	// Position of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Pos = 0x1e
	// Bit mask of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Msk = 0x40000000
	// Bit WWDGRSTF.
	RCC_CSR_WWDGRSTF = 0x40000000
	// Position of IWDGRSTF field.
	RCC_CSR_IWDGRSTF_Pos = 0x1d
	// Bit mask of IWDGRSTF field.
	RCC_CSR_IWDGRSTF_Msk = 0x20000000
	// Bit IWDGRSTF.
	RCC_CSR_IWDGRSTF = 0x20000000
	// Position of SFTRSTF field.
	RCC_CSR_SFTRSTF_Pos = 0x1c
	// Bit mask of SFTRSTF field.
	RCC_CSR_SFTRSTF_Msk = 0x10000000
	// Bit SFTRSTF.
	RCC_CSR_SFTRSTF = 0x10000000
	// Position of BORRSTF field.
	RCC_CSR_BORRSTF_Pos = 0x1b
	// Bit mask of BORRSTF field.
	RCC_CSR_BORRSTF_Msk = 0x8000000
	// Bit BORRSTF.
	RCC_CSR_BORRSTF = 0x8000000
	// Position of PINRSTF field.
	RCC_CSR_PINRSTF_Pos = 0x1a
	// Bit mask of PINRSTF field.
	RCC_CSR_PINRSTF_Msk = 0x4000000
	// Bit PINRSTF.
	RCC_CSR_PINRSTF = 0x4000000
	// Position of OBLRSTF field.
	RCC_CSR_OBLRSTF_Pos = 0x19
	// Bit mask of OBLRSTF field.
	RCC_CSR_OBLRSTF_Msk = 0x2000000
	// Bit OBLRSTF.
	RCC_CSR_OBLRSTF = 0x2000000
	// Position of FWRSTF field.
	RCC_CSR_FWRSTF_Pos = 0x18
	// Bit mask of FWRSTF field.
	RCC_CSR_FWRSTF_Msk = 0x1000000
	// Bit FWRSTF.
	RCC_CSR_FWRSTF = 0x1000000
	// Position of RMVF field.
	RCC_CSR_RMVF_Pos = 0x17
	// Bit mask of RMVF field.
	RCC_CSR_RMVF_Msk = 0x800000
	// Bit RMVF.
	RCC_CSR_RMVF = 0x800000
	// Position of MSISRANGE field.
	RCC_CSR_MSISRANGE_Pos = 0x8
	// Bit mask of MSISRANGE field.
	RCC_CSR_MSISRANGE_Msk = 0xf00
	// Position of LSIRDY field.
	RCC_CSR_LSIRDY_Pos = 0x1
	// Bit mask of LSIRDY field.
	RCC_CSR_LSIRDY_Msk = 0x2
	// Bit LSIRDY.
	RCC_CSR_LSIRDY = 0x2
	// Position of LSION field.
	RCC_CSR_LSION_Pos = 0x0
	// Bit mask of LSION field.
	RCC_CSR_LSION_Msk = 0x1
	// Bit LSION.
	RCC_CSR_LSION = 0x1

	// CRRCR: Clock recovery RC register
	// Position of HSI48ON field.
	RCC_CRRCR_HSI48ON_Pos = 0x0
	// Bit mask of HSI48ON field.
	RCC_CRRCR_HSI48ON_Msk = 0x1
	// Bit HSI48ON.
	RCC_CRRCR_HSI48ON = 0x1
	// Position of HSI48RDY field.
	RCC_CRRCR_HSI48RDY_Pos = 0x1
	// Bit mask of HSI48RDY field.
	RCC_CRRCR_HSI48RDY_Msk = 0x2
	// Bit HSI48RDY.
	RCC_CRRCR_HSI48RDY = 0x2
	// Position of HSI48CAL field.
	RCC_CRRCR_HSI48CAL_Pos = 0x7
	// Bit mask of HSI48CAL field.
	RCC_CRRCR_HSI48CAL_Msk = 0xff80

	// CCIPR2: Peripherals independent clock configuration register
	// Position of I2C4SEL field.
	RCC_CCIPR2_I2C4SEL_Pos = 0x0
	// Bit mask of I2C4SEL field.
	RCC_CCIPR2_I2C4SEL_Msk = 0x3
	// Position of DFSDMSEL field.
	RCC_CCIPR2_DFSDMSEL_Pos = 0x2
	// Bit mask of DFSDMSEL field.
	RCC_CCIPR2_DFSDMSEL_Msk = 0x4
	// Bit DFSDMSEL.
	RCC_CCIPR2_DFSDMSEL = 0x4
	// Position of ADFSDMSEL field.
	RCC_CCIPR2_ADFSDMSEL_Pos = 0x3
	// Bit mask of ADFSDMSEL field.
	RCC_CCIPR2_ADFSDMSEL_Msk = 0x18
	// Position of SAI1SEL field.
	RCC_CCIPR2_SAI1SEL_Pos = 0x5
	// Bit mask of SAI1SEL field.
	RCC_CCIPR2_SAI1SEL_Msk = 0xe0
	// Position of SAI2SEL field.
	RCC_CCIPR2_SAI2SEL_Pos = 0x8
	// Bit mask of SAI2SEL field.
	RCC_CCIPR2_SAI2SEL_Msk = 0x700
	// Position of DSISEL field.
	RCC_CCIPR2_DSISEL_Pos = 0xc
	// Bit mask of DSISEL field.
	RCC_CCIPR2_DSISEL_Msk = 0x1000
	// Bit DSISEL.
	RCC_CCIPR2_DSISEL = 0x1000
	// Position of SDMMCSEL field.
	RCC_CCIPR2_SDMMCSEL_Pos = 0xe
	// Bit mask of SDMMCSEL field.
	RCC_CCIPR2_SDMMCSEL_Msk = 0x4000
	// Bit SDMMCSEL.
	RCC_CCIPR2_SDMMCSEL = 0x4000
	// Position of PLLSAI2DIVR field.
	RCC_CCIPR2_PLLSAI2DIVR_Pos = 0x10
	// Bit mask of PLLSAI2DIVR field.
	RCC_CCIPR2_PLLSAI2DIVR_Msk = 0x30000
	// Position of OSPISEL field.
	RCC_CCIPR2_OSPISEL_Pos = 0x14
	// Bit mask of OSPISEL field.
	RCC_CCIPR2_OSPISEL_Msk = 0x300000
)

// Constants for PWR: Power control
const (
	// CR1: Power control register 1
	// Position of LPR field.
	PWR_CR1_LPR_Pos = 0xe
	// Bit mask of LPR field.
	PWR_CR1_LPR_Msk = 0x4000
	// Bit LPR.
	PWR_CR1_LPR = 0x4000
	// Position of VOS field.
	PWR_CR1_VOS_Pos = 0x9
	// Bit mask of VOS field.
	PWR_CR1_VOS_Msk = 0x600
	// Position of DBP field.
	PWR_CR1_DBP_Pos = 0x8
	// Bit mask of DBP field.
	PWR_CR1_DBP_Msk = 0x100
	// Bit DBP.
	PWR_CR1_DBP = 0x100
	// Position of LPMS field.
	PWR_CR1_LPMS_Pos = 0x0
	// Bit mask of LPMS field.
	PWR_CR1_LPMS_Msk = 0x7

	// CR2: Power control register 2
	// Position of USV field.
	PWR_CR2_USV_Pos = 0xa
	// Bit mask of USV field.
	PWR_CR2_USV_Msk = 0x400
	// Bit USV.
	PWR_CR2_USV = 0x400
	// Position of IOSV field.
	PWR_CR2_IOSV_Pos = 0x9
	// Bit mask of IOSV field.
	PWR_CR2_IOSV_Msk = 0x200
	// Bit IOSV.
	PWR_CR2_IOSV = 0x200
	// Position of PVME4 field.
	PWR_CR2_PVME4_Pos = 0x7
	// Bit mask of PVME4 field.
	PWR_CR2_PVME4_Msk = 0x80
	// Bit PVME4.
	PWR_CR2_PVME4 = 0x80
	// Position of PVME3 field.
	PWR_CR2_PVME3_Pos = 0x6
	// Bit mask of PVME3 field.
	PWR_CR2_PVME3_Msk = 0x40
	// Bit PVME3.
	PWR_CR2_PVME3 = 0x40
	// Position of PVME2 field.
	PWR_CR2_PVME2_Pos = 0x5
	// Bit mask of PVME2 field.
	PWR_CR2_PVME2_Msk = 0x20
	// Bit PVME2.
	PWR_CR2_PVME2 = 0x20
	// Position of PVME1 field.
	PWR_CR2_PVME1_Pos = 0x4
	// Bit mask of PVME1 field.
	PWR_CR2_PVME1_Msk = 0x10
	// Bit PVME1.
	PWR_CR2_PVME1 = 0x10
	// Position of PLS field.
	PWR_CR2_PLS_Pos = 0x1
	// Bit mask of PLS field.
	PWR_CR2_PLS_Msk = 0xe
	// Position of PVDE field.
	PWR_CR2_PVDE_Pos = 0x0
	// Bit mask of PVDE field.
	PWR_CR2_PVDE_Msk = 0x1
	// Bit PVDE.
	PWR_CR2_PVDE = 0x1

	// CR3: Power control register 3
	// Position of EWF field.
	PWR_CR3_EWF_Pos = 0xf
	// Bit mask of EWF field.
	PWR_CR3_EWF_Msk = 0x8000
	// Bit EWF.
	PWR_CR3_EWF = 0x8000
	// Position of APC field.
	PWR_CR3_APC_Pos = 0xa
	// Bit mask of APC field.
	PWR_CR3_APC_Msk = 0x400
	// Bit APC.
	PWR_CR3_APC = 0x400
	// Position of RRS field.
	PWR_CR3_RRS_Pos = 0x8
	// Bit mask of RRS field.
	PWR_CR3_RRS_Msk = 0x100
	// Bit RRS.
	PWR_CR3_RRS = 0x100
	// Position of EWUP5 field.
	PWR_CR3_EWUP5_Pos = 0x4
	// Bit mask of EWUP5 field.
	PWR_CR3_EWUP5_Msk = 0x10
	// Bit EWUP5.
	PWR_CR3_EWUP5 = 0x10
	// Position of EWUP4 field.
	PWR_CR3_EWUP4_Pos = 0x3
	// Bit mask of EWUP4 field.
	PWR_CR3_EWUP4_Msk = 0x8
	// Bit EWUP4.
	PWR_CR3_EWUP4 = 0x8
	// Position of EWUP3 field.
	PWR_CR3_EWUP3_Pos = 0x2
	// Bit mask of EWUP3 field.
	PWR_CR3_EWUP3_Msk = 0x4
	// Bit EWUP3.
	PWR_CR3_EWUP3 = 0x4
	// Position of EWUP2 field.
	PWR_CR3_EWUP2_Pos = 0x1
	// Bit mask of EWUP2 field.
	PWR_CR3_EWUP2_Msk = 0x2
	// Bit EWUP2.
	PWR_CR3_EWUP2 = 0x2
	// Position of EWUP1 field.
	PWR_CR3_EWUP1_Pos = 0x0
	// Bit mask of EWUP1 field.
	PWR_CR3_EWUP1_Msk = 0x1
	// Bit EWUP1.
	PWR_CR3_EWUP1 = 0x1

	// CR4: Power control register 4
	// Position of VBRS field.
	PWR_CR4_VBRS_Pos = 0x9
	// Bit mask of VBRS field.
	PWR_CR4_VBRS_Msk = 0x200
	// Bit VBRS.
	PWR_CR4_VBRS = 0x200
	// Position of VBE field.
	PWR_CR4_VBE_Pos = 0x8
	// Bit mask of VBE field.
	PWR_CR4_VBE_Msk = 0x100
	// Bit VBE.
	PWR_CR4_VBE = 0x100
	// Position of WP5 field.
	PWR_CR4_WP5_Pos = 0x4
	// Bit mask of WP5 field.
	PWR_CR4_WP5_Msk = 0x10
	// Bit WP5.
	PWR_CR4_WP5 = 0x10
	// Position of WP4 field.
	PWR_CR4_WP4_Pos = 0x3
	// Bit mask of WP4 field.
	PWR_CR4_WP4_Msk = 0x8
	// Bit WP4.
	PWR_CR4_WP4 = 0x8
	// Position of WP3 field.
	PWR_CR4_WP3_Pos = 0x2
	// Bit mask of WP3 field.
	PWR_CR4_WP3_Msk = 0x4
	// Bit WP3.
	PWR_CR4_WP3 = 0x4
	// Position of WP2 field.
	PWR_CR4_WP2_Pos = 0x1
	// Bit mask of WP2 field.
	PWR_CR4_WP2_Msk = 0x2
	// Bit WP2.
	PWR_CR4_WP2 = 0x2
	// Position of WP1 field.
	PWR_CR4_WP1_Pos = 0x0
	// Bit mask of WP1 field.
	PWR_CR4_WP1_Msk = 0x1
	// Bit WP1.
	PWR_CR4_WP1 = 0x1

	// SR1: Power status register 1
	// Position of WUFI field.
	PWR_SR1_WUFI_Pos = 0xf
	// Bit mask of WUFI field.
	PWR_SR1_WUFI_Msk = 0x8000
	// Bit WUFI.
	PWR_SR1_WUFI = 0x8000
	// Position of CSBF field.
	PWR_SR1_CSBF_Pos = 0x8
	// Bit mask of CSBF field.
	PWR_SR1_CSBF_Msk = 0x100
	// Bit CSBF.
	PWR_SR1_CSBF = 0x100
	// Position of CWUF5 field.
	PWR_SR1_CWUF5_Pos = 0x4
	// Bit mask of CWUF5 field.
	PWR_SR1_CWUF5_Msk = 0x10
	// Bit CWUF5.
	PWR_SR1_CWUF5 = 0x10
	// Position of CWUF4 field.
	PWR_SR1_CWUF4_Pos = 0x3
	// Bit mask of CWUF4 field.
	PWR_SR1_CWUF4_Msk = 0x8
	// Bit CWUF4.
	PWR_SR1_CWUF4 = 0x8
	// Position of CWUF3 field.
	PWR_SR1_CWUF3_Pos = 0x2
	// Bit mask of CWUF3 field.
	PWR_SR1_CWUF3_Msk = 0x4
	// Bit CWUF3.
	PWR_SR1_CWUF3 = 0x4
	// Position of CWUF2 field.
	PWR_SR1_CWUF2_Pos = 0x1
	// Bit mask of CWUF2 field.
	PWR_SR1_CWUF2_Msk = 0x2
	// Bit CWUF2.
	PWR_SR1_CWUF2 = 0x2
	// Position of CWUF1 field.
	PWR_SR1_CWUF1_Pos = 0x0
	// Bit mask of CWUF1 field.
	PWR_SR1_CWUF1_Msk = 0x1
	// Bit CWUF1.
	PWR_SR1_CWUF1 = 0x1

	// SR2: Power status register 2
	// Position of PVMO4 field.
	PWR_SR2_PVMO4_Pos = 0xf
	// Bit mask of PVMO4 field.
	PWR_SR2_PVMO4_Msk = 0x8000
	// Bit PVMO4.
	PWR_SR2_PVMO4 = 0x8000
	// Position of PVMO3 field.
	PWR_SR2_PVMO3_Pos = 0xe
	// Bit mask of PVMO3 field.
	PWR_SR2_PVMO3_Msk = 0x4000
	// Bit PVMO3.
	PWR_SR2_PVMO3 = 0x4000
	// Position of PVMO2 field.
	PWR_SR2_PVMO2_Pos = 0xd
	// Bit mask of PVMO2 field.
	PWR_SR2_PVMO2_Msk = 0x2000
	// Bit PVMO2.
	PWR_SR2_PVMO2 = 0x2000
	// Position of PVMO1 field.
	PWR_SR2_PVMO1_Pos = 0xc
	// Bit mask of PVMO1 field.
	PWR_SR2_PVMO1_Msk = 0x1000
	// Bit PVMO1.
	PWR_SR2_PVMO1 = 0x1000
	// Position of PVDO field.
	PWR_SR2_PVDO_Pos = 0xb
	// Bit mask of PVDO field.
	PWR_SR2_PVDO_Msk = 0x800
	// Bit PVDO.
	PWR_SR2_PVDO = 0x800
	// Position of VOSF field.
	PWR_SR2_VOSF_Pos = 0xa
	// Bit mask of VOSF field.
	PWR_SR2_VOSF_Msk = 0x400
	// Bit VOSF.
	PWR_SR2_VOSF = 0x400
	// Position of REGLPF field.
	PWR_SR2_REGLPF_Pos = 0x9
	// Bit mask of REGLPF field.
	PWR_SR2_REGLPF_Msk = 0x200
	// Bit REGLPF.
	PWR_SR2_REGLPF = 0x200
	// Position of REGLPS field.
	PWR_SR2_REGLPS_Pos = 0x8
	// Bit mask of REGLPS field.
	PWR_SR2_REGLPS_Msk = 0x100
	// Bit REGLPS.
	PWR_SR2_REGLPS = 0x100

	// SCR: Power status clear register
	// Position of SBF field.
	PWR_SCR_SBF_Pos = 0x8
	// Bit mask of SBF field.
	PWR_SCR_SBF_Msk = 0x100
	// Bit SBF.
	PWR_SCR_SBF = 0x100
	// Position of WUF5 field.
	PWR_SCR_WUF5_Pos = 0x4
	// Bit mask of WUF5 field.
	PWR_SCR_WUF5_Msk = 0x10
	// Bit WUF5.
	PWR_SCR_WUF5 = 0x10
	// Position of WUF4 field.
	PWR_SCR_WUF4_Pos = 0x3
	// Bit mask of WUF4 field.
	PWR_SCR_WUF4_Msk = 0x8
	// Bit WUF4.
	PWR_SCR_WUF4 = 0x8
	// Position of WUF3 field.
	PWR_SCR_WUF3_Pos = 0x2
	// Bit mask of WUF3 field.
	PWR_SCR_WUF3_Msk = 0x4
	// Bit WUF3.
	PWR_SCR_WUF3 = 0x4
	// Position of WUF2 field.
	PWR_SCR_WUF2_Pos = 0x1
	// Bit mask of WUF2 field.
	PWR_SCR_WUF2_Msk = 0x2
	// Bit WUF2.
	PWR_SCR_WUF2 = 0x2
	// Position of WUF1 field.
	PWR_SCR_WUF1_Pos = 0x0
	// Bit mask of WUF1 field.
	PWR_SCR_WUF1_Msk = 0x1
	// Bit WUF1.
	PWR_SCR_WUF1 = 0x1

	// PUCRA: Power Port A pull-up control register
	// Position of PU15 field.
	PWR_PUCRA_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRA_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRA_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRA_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRA_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRA_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRA_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRA_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRA_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRA_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRA_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRA_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRA_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRA_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRA_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRA_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRA_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRA_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRA_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRA_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRA_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRA_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRA_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRA_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRA_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRA_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRA_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRA_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRA_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRA_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRA_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRA_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRA_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRA_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRA_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRA_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRA_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRA_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRA_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRA_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRA_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRA_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRA_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRA_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRA_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRA_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRA_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRA_PU0 = 0x1

	// PDCRA: Power Port A pull-down control register
	// Position of PD15 field.
	PWR_PDCRA_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRA_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRA_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRA_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRA_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRA_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRA_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRA_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRA_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRA_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRA_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRA_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRA_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRA_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRA_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRA_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRA_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRA_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRA_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRA_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRA_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRA_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRA_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRA_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRA_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRA_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRA_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRA_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRA_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRA_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRA_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRA_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRA_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRA_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRA_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRA_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRA_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRA_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRA_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRA_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRA_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRA_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRA_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRA_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRA_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRA_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRA_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRA_PD0 = 0x1

	// PUCRB: Power Port B pull-up control register
	// Position of PU15 field.
	PWR_PUCRB_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRB_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRB_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRB_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRB_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRB_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRB_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRB_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRB_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRB_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRB_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRB_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRB_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRB_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRB_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRB_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRB_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRB_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRB_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRB_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRB_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRB_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRB_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRB_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRB_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRB_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRB_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRB_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRB_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRB_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRB_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRB_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRB_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRB_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRB_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRB_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRB_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRB_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRB_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRB_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRB_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRB_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRB_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRB_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRB_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRB_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRB_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRB_PU0 = 0x1

	// PDCRB: Power Port B pull-down control register
	// Position of PD15 field.
	PWR_PDCRB_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRB_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRB_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRB_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRB_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRB_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRB_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRB_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRB_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRB_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRB_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRB_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRB_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRB_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRB_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRB_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRB_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRB_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRB_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRB_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRB_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRB_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRB_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRB_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRB_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRB_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRB_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRB_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRB_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRB_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRB_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRB_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRB_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRB_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRB_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRB_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRB_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRB_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRB_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRB_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRB_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRB_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRB_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRB_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRB_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRB_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRB_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRB_PD0 = 0x1

	// PUCRC: Power Port C pull-up control register
	// Position of PU15 field.
	PWR_PUCRC_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRC_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRC_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRC_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRC_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRC_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRC_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRC_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRC_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRC_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRC_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRC_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRC_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRC_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRC_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRC_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRC_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRC_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRC_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRC_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRC_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRC_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRC_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRC_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRC_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRC_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRC_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRC_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRC_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRC_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRC_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRC_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRC_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRC_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRC_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRC_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRC_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRC_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRC_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRC_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRC_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRC_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRC_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRC_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRC_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRC_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRC_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRC_PU0 = 0x1

	// PDCRC: Power Port C pull-down control register
	// Position of PD15 field.
	PWR_PDCRC_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRC_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRC_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRC_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRC_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRC_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRC_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRC_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRC_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRC_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRC_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRC_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRC_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRC_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRC_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRC_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRC_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRC_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRC_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRC_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRC_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRC_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRC_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRC_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRC_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRC_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRC_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRC_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRC_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRC_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRC_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRC_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRC_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRC_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRC_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRC_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRC_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRC_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRC_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRC_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRC_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRC_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRC_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRC_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRC_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRC_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRC_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRC_PD0 = 0x1

	// PUCRD: Power Port D pull-up control register
	// Position of PU15 field.
	PWR_PUCRD_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRD_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRD_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRD_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRD_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRD_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRD_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRD_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRD_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRD_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRD_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRD_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRD_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRD_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRD_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRD_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRD_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRD_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRD_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRD_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRD_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRD_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRD_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRD_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRD_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRD_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRD_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRD_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRD_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRD_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRD_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRD_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRD_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRD_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRD_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRD_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRD_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRD_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRD_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRD_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRD_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRD_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRD_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRD_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRD_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRD_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRD_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRD_PU0 = 0x1

	// PDCRD: Power Port D pull-down control register
	// Position of PD15 field.
	PWR_PDCRD_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRD_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRD_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRD_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRD_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRD_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRD_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRD_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRD_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRD_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRD_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRD_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRD_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRD_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRD_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRD_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRD_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRD_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRD_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRD_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRD_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRD_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRD_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRD_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRD_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRD_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRD_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRD_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRD_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRD_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRD_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRD_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRD_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRD_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRD_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRD_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRD_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRD_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRD_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRD_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRD_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRD_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRD_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRD_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRD_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRD_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRD_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRD_PD0 = 0x1

	// PUCRE: Power Port E pull-up control register
	// Position of PU15 field.
	PWR_PUCRE_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRE_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRE_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRE_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRE_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRE_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRE_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRE_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRE_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRE_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRE_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRE_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRE_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRE_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRE_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRE_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRE_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRE_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRE_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRE_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRE_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRE_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRE_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRE_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRE_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRE_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRE_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRE_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRE_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRE_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRE_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRE_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRE_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRE_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRE_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRE_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRE_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRE_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRE_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRE_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRE_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRE_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRE_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRE_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRE_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRE_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRE_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRE_PU0 = 0x1

	// PDCRE: Power Port E pull-down control register
	// Position of PD15 field.
	PWR_PDCRE_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRE_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRE_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRE_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRE_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRE_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRE_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRE_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRE_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRE_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRE_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRE_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRE_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRE_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRE_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRE_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRE_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRE_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRE_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRE_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRE_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRE_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRE_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRE_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRE_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRE_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRE_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRE_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRE_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRE_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRE_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRE_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRE_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRE_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRE_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRE_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRE_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRE_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRE_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRE_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRE_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRE_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRE_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRE_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRE_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRE_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRE_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRE_PD0 = 0x1

	// PUCRF: Power Port F pull-up control register
	// Position of PU15 field.
	PWR_PUCRF_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRF_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRF_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRF_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRF_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRF_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRF_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRF_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRF_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRF_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRF_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRF_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRF_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRF_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRF_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRF_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRF_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRF_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRF_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRF_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRF_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRF_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRF_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRF_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRF_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRF_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRF_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRF_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRF_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRF_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRF_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRF_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRF_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRF_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRF_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRF_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRF_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRF_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRF_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRF_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRF_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRF_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRF_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRF_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRF_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRF_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRF_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRF_PU0 = 0x1

	// PDCRF: Power Port F pull-down control register
	// Position of PD15 field.
	PWR_PDCRF_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRF_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRF_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRF_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRF_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRF_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRF_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRF_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRF_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRF_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRF_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRF_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRF_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRF_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRF_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRF_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRF_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRF_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRF_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRF_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRF_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRF_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRF_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRF_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRF_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRF_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRF_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRF_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRF_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRF_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRF_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRF_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRF_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRF_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRF_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRF_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRF_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRF_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRF_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRF_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRF_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRF_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRF_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRF_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRF_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRF_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRF_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRF_PD0 = 0x1

	// PUCRG: Power Port G pull-up control register
	// Position of PU15 field.
	PWR_PUCRG_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRG_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRG_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRG_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRG_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRG_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRG_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRG_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRG_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRG_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRG_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRG_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRG_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRG_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRG_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRG_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRG_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRG_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRG_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRG_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRG_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRG_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRG_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRG_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRG_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRG_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRG_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRG_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRG_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRG_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRG_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRG_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRG_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRG_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRG_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRG_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRG_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRG_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRG_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRG_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRG_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRG_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRG_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRG_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRG_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRG_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRG_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRG_PU0 = 0x1

	// PDCRG: Power Port G pull-down control register
	// Position of PD15 field.
	PWR_PDCRG_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRG_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRG_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRG_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRG_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRG_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRG_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRG_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRG_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRG_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRG_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRG_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRG_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRG_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRG_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRG_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRG_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRG_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRG_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRG_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRG_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRG_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRG_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRG_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRG_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRG_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRG_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRG_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRG_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRG_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRG_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRG_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRG_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRG_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRG_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRG_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRG_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRG_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRG_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRG_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRG_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRG_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRG_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRG_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRG_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRG_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRG_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRG_PD0 = 0x1

	// PUCRH: Power Port H pull-up control register
	// Position of PU1 field.
	PWR_PUCRH_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRH_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRH_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRH_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRH_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRH_PU0 = 0x1

	// PDCRH: Power Port H pull-down control register
	// Position of PD1 field.
	PWR_PDCRH_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRH_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRH_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRH_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRH_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRH_PD0 = 0x1
)

// Constants for SYSCFG: System configuration controller
const (
	// MEMRMP: memory remap register
	// Position of FB_MODE field.
	SYSCFG_MEMRMP_FB_MODE_Pos = 0x8
	// Bit mask of FB_MODE field.
	SYSCFG_MEMRMP_FB_MODE_Msk = 0x100
	// Bit FB_MODE.
	SYSCFG_MEMRMP_FB_MODE = 0x100
	// Position of QFS field.
	SYSCFG_MEMRMP_QFS_Pos = 0x3
	// Bit mask of QFS field.
	SYSCFG_MEMRMP_QFS_Msk = 0x8
	// Bit QFS.
	SYSCFG_MEMRMP_QFS = 0x8
	// Position of MEM_MODE field.
	SYSCFG_MEMRMP_MEM_MODE_Pos = 0x0
	// Bit mask of MEM_MODE field.
	SYSCFG_MEMRMP_MEM_MODE_Msk = 0x7

	// CFGR1: configuration register 1
	// Position of FPU_IE field.
	SYSCFG_CFGR1_FPU_IE_Pos = 0x1a
	// Bit mask of FPU_IE field.
	SYSCFG_CFGR1_FPU_IE_Msk = 0xfc000000
	// Position of I2C3_FMP field.
	SYSCFG_CFGR1_I2C3_FMP_Pos = 0x16
	// Bit mask of I2C3_FMP field.
	SYSCFG_CFGR1_I2C3_FMP_Msk = 0x400000
	// Bit I2C3_FMP.
	SYSCFG_CFGR1_I2C3_FMP = 0x400000
	// Position of I2C2_FMP field.
	SYSCFG_CFGR1_I2C2_FMP_Pos = 0x15
	// Bit mask of I2C2_FMP field.
	SYSCFG_CFGR1_I2C2_FMP_Msk = 0x200000
	// Bit I2C2_FMP.
	SYSCFG_CFGR1_I2C2_FMP = 0x200000
	// Position of I2C1_FMP field.
	SYSCFG_CFGR1_I2C1_FMP_Pos = 0x14
	// Bit mask of I2C1_FMP field.
	SYSCFG_CFGR1_I2C1_FMP_Msk = 0x100000
	// Bit I2C1_FMP.
	SYSCFG_CFGR1_I2C1_FMP = 0x100000
	// Position of I2C_PB9_FMP field.
	SYSCFG_CFGR1_I2C_PB9_FMP_Pos = 0x13
	// Bit mask of I2C_PB9_FMP field.
	SYSCFG_CFGR1_I2C_PB9_FMP_Msk = 0x80000
	// Bit I2C_PB9_FMP.
	SYSCFG_CFGR1_I2C_PB9_FMP = 0x80000
	// Position of I2C_PB8_FMP field.
	SYSCFG_CFGR1_I2C_PB8_FMP_Pos = 0x12
	// Bit mask of I2C_PB8_FMP field.
	SYSCFG_CFGR1_I2C_PB8_FMP_Msk = 0x40000
	// Bit I2C_PB8_FMP.
	SYSCFG_CFGR1_I2C_PB8_FMP = 0x40000
	// Position of I2C_PB7_FMP field.
	SYSCFG_CFGR1_I2C_PB7_FMP_Pos = 0x11
	// Bit mask of I2C_PB7_FMP field.
	SYSCFG_CFGR1_I2C_PB7_FMP_Msk = 0x20000
	// Bit I2C_PB7_FMP.
	SYSCFG_CFGR1_I2C_PB7_FMP = 0x20000
	// Position of I2C_PB6_FMP field.
	SYSCFG_CFGR1_I2C_PB6_FMP_Pos = 0x10
	// Bit mask of I2C_PB6_FMP field.
	SYSCFG_CFGR1_I2C_PB6_FMP_Msk = 0x10000
	// Bit I2C_PB6_FMP.
	SYSCFG_CFGR1_I2C_PB6_FMP = 0x10000
	// Position of BOOSTEN field.
	SYSCFG_CFGR1_BOOSTEN_Pos = 0x8
	// Bit mask of BOOSTEN field.
	SYSCFG_CFGR1_BOOSTEN_Msk = 0x100
	// Bit BOOSTEN.
	SYSCFG_CFGR1_BOOSTEN = 0x100
	// Position of FWDIS field.
	SYSCFG_CFGR1_FWDIS_Pos = 0x0
	// Bit mask of FWDIS field.
	SYSCFG_CFGR1_FWDIS_Msk = 0x1
	// Bit FWDIS.
	SYSCFG_CFGR1_FWDIS = 0x1

	// EXTICR1: external interrupt configuration register 1
	// Position of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Pos = 0xc
	// Bit mask of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Msk = 0x7000
	// Position of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Pos = 0x8
	// Bit mask of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Msk = 0x700
	// Position of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Pos = 0x4
	// Bit mask of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Msk = 0x70
	// Position of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Pos = 0x0
	// Bit mask of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Msk = 0x7

	// EXTICR2: external interrupt configuration register 2
	// Position of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Pos = 0xc
	// Bit mask of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Msk = 0x7000
	// Position of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Pos = 0x8
	// Bit mask of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Msk = 0x700
	// Position of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Pos = 0x4
	// Bit mask of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Msk = 0x70
	// Position of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Pos = 0x0
	// Bit mask of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Msk = 0x7

	// EXTICR3: external interrupt configuration register 3
	// Position of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Pos = 0xc
	// Bit mask of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Msk = 0x7000
	// Position of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Pos = 0x8
	// Bit mask of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Msk = 0x700
	// Position of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Pos = 0x4
	// Bit mask of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Msk = 0x70
	// Position of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Pos = 0x0
	// Bit mask of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Msk = 0x7

	// EXTICR4: external interrupt configuration register 4
	// Position of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Pos = 0xc
	// Bit mask of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Msk = 0x7000
	// Position of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Pos = 0x8
	// Bit mask of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Msk = 0x700
	// Position of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Pos = 0x4
	// Bit mask of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Msk = 0x70
	// Position of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Pos = 0x0
	// Bit mask of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Msk = 0x7

	// SCSR: SCSR
	// Position of SRAM2BSY field.
	SYSCFG_SCSR_SRAM2BSY_Pos = 0x1
	// Bit mask of SRAM2BSY field.
	SYSCFG_SCSR_SRAM2BSY_Msk = 0x2
	// Bit SRAM2BSY.
	SYSCFG_SCSR_SRAM2BSY = 0x2
	// Position of SRAM2ER field.
	SYSCFG_SCSR_SRAM2ER_Pos = 0x0
	// Bit mask of SRAM2ER field.
	SYSCFG_SCSR_SRAM2ER_Msk = 0x1
	// Bit SRAM2ER.
	SYSCFG_SCSR_SRAM2ER = 0x1

	// CFGR2: CFGR2
	// Position of SPF field.
	SYSCFG_CFGR2_SPF_Pos = 0x8
	// Bit mask of SPF field.
	SYSCFG_CFGR2_SPF_Msk = 0x100
	// Bit SPF.
	SYSCFG_CFGR2_SPF = 0x100
	// Position of ECCL field.
	SYSCFG_CFGR2_ECCL_Pos = 0x3
	// Bit mask of ECCL field.
	SYSCFG_CFGR2_ECCL_Msk = 0x8
	// Bit ECCL.
	SYSCFG_CFGR2_ECCL = 0x8
	// Position of PVDL field.
	SYSCFG_CFGR2_PVDL_Pos = 0x2
	// Bit mask of PVDL field.
	SYSCFG_CFGR2_PVDL_Msk = 0x4
	// Bit PVDL.
	SYSCFG_CFGR2_PVDL = 0x4
	// Position of SPL field.
	SYSCFG_CFGR2_SPL_Pos = 0x1
	// Bit mask of SPL field.
	SYSCFG_CFGR2_SPL_Msk = 0x2
	// Bit SPL.
	SYSCFG_CFGR2_SPL = 0x2
	// Position of CLL field.
	SYSCFG_CFGR2_CLL_Pos = 0x0
	// Bit mask of CLL field.
	SYSCFG_CFGR2_CLL_Msk = 0x1
	// Bit CLL.
	SYSCFG_CFGR2_CLL = 0x1

	// SWPR: SWPR
	// Position of P31WP field.
	SYSCFG_SWPR_P31WP_Pos = 0x1f
	// Bit mask of P31WP field.
	SYSCFG_SWPR_P31WP_Msk = 0x80000000
	// Bit P31WP.
	SYSCFG_SWPR_P31WP = 0x80000000
	// Position of P30WP field.
	SYSCFG_SWPR_P30WP_Pos = 0x1e
	// Bit mask of P30WP field.
	SYSCFG_SWPR_P30WP_Msk = 0x40000000
	// Bit P30WP.
	SYSCFG_SWPR_P30WP = 0x40000000
	// Position of P29WP field.
	SYSCFG_SWPR_P29WP_Pos = 0x1d
	// Bit mask of P29WP field.
	SYSCFG_SWPR_P29WP_Msk = 0x20000000
	// Bit P29WP.
	SYSCFG_SWPR_P29WP = 0x20000000
	// Position of P28WP field.
	SYSCFG_SWPR_P28WP_Pos = 0x1c
	// Bit mask of P28WP field.
	SYSCFG_SWPR_P28WP_Msk = 0x10000000
	// Bit P28WP.
	SYSCFG_SWPR_P28WP = 0x10000000
	// Position of P27WP field.
	SYSCFG_SWPR_P27WP_Pos = 0x1b
	// Bit mask of P27WP field.
	SYSCFG_SWPR_P27WP_Msk = 0x8000000
	// Bit P27WP.
	SYSCFG_SWPR_P27WP = 0x8000000
	// Position of P26WP field.
	SYSCFG_SWPR_P26WP_Pos = 0x1a
	// Bit mask of P26WP field.
	SYSCFG_SWPR_P26WP_Msk = 0x4000000
	// Bit P26WP.
	SYSCFG_SWPR_P26WP = 0x4000000
	// Position of P25WP field.
	SYSCFG_SWPR_P25WP_Pos = 0x19
	// Bit mask of P25WP field.
	SYSCFG_SWPR_P25WP_Msk = 0x2000000
	// Bit P25WP.
	SYSCFG_SWPR_P25WP = 0x2000000
	// Position of P24WP field.
	SYSCFG_SWPR_P24WP_Pos = 0x18
	// Bit mask of P24WP field.
	SYSCFG_SWPR_P24WP_Msk = 0x1000000
	// Bit P24WP.
	SYSCFG_SWPR_P24WP = 0x1000000
	// Position of P23WP field.
	SYSCFG_SWPR_P23WP_Pos = 0x17
	// Bit mask of P23WP field.
	SYSCFG_SWPR_P23WP_Msk = 0x800000
	// Bit P23WP.
	SYSCFG_SWPR_P23WP = 0x800000
	// Position of P22WP field.
	SYSCFG_SWPR_P22WP_Pos = 0x16
	// Bit mask of P22WP field.
	SYSCFG_SWPR_P22WP_Msk = 0x400000
	// Bit P22WP.
	SYSCFG_SWPR_P22WP = 0x400000
	// Position of P21WP field.
	SYSCFG_SWPR_P21WP_Pos = 0x15
	// Bit mask of P21WP field.
	SYSCFG_SWPR_P21WP_Msk = 0x200000
	// Bit P21WP.
	SYSCFG_SWPR_P21WP = 0x200000
	// Position of P20WP field.
	SYSCFG_SWPR_P20WP_Pos = 0x14
	// Bit mask of P20WP field.
	SYSCFG_SWPR_P20WP_Msk = 0x100000
	// Bit P20WP.
	SYSCFG_SWPR_P20WP = 0x100000
	// Position of P19WP field.
	SYSCFG_SWPR_P19WP_Pos = 0x13
	// Bit mask of P19WP field.
	SYSCFG_SWPR_P19WP_Msk = 0x80000
	// Bit P19WP.
	SYSCFG_SWPR_P19WP = 0x80000
	// Position of P18WP field.
	SYSCFG_SWPR_P18WP_Pos = 0x12
	// Bit mask of P18WP field.
	SYSCFG_SWPR_P18WP_Msk = 0x40000
	// Bit P18WP.
	SYSCFG_SWPR_P18WP = 0x40000
	// Position of P17WP field.
	SYSCFG_SWPR_P17WP_Pos = 0x11
	// Bit mask of P17WP field.
	SYSCFG_SWPR_P17WP_Msk = 0x20000
	// Bit P17WP.
	SYSCFG_SWPR_P17WP = 0x20000
	// Position of P16WP field.
	SYSCFG_SWPR_P16WP_Pos = 0x10
	// Bit mask of P16WP field.
	SYSCFG_SWPR_P16WP_Msk = 0x10000
	// Bit P16WP.
	SYSCFG_SWPR_P16WP = 0x10000
	// Position of P15WP field.
	SYSCFG_SWPR_P15WP_Pos = 0xf
	// Bit mask of P15WP field.
	SYSCFG_SWPR_P15WP_Msk = 0x8000
	// Bit P15WP.
	SYSCFG_SWPR_P15WP = 0x8000
	// Position of P14WP field.
	SYSCFG_SWPR_P14WP_Pos = 0xe
	// Bit mask of P14WP field.
	SYSCFG_SWPR_P14WP_Msk = 0x4000
	// Bit P14WP.
	SYSCFG_SWPR_P14WP = 0x4000
	// Position of P13WP field.
	SYSCFG_SWPR_P13WP_Pos = 0xd
	// Bit mask of P13WP field.
	SYSCFG_SWPR_P13WP_Msk = 0x2000
	// Bit P13WP.
	SYSCFG_SWPR_P13WP = 0x2000
	// Position of P12WP field.
	SYSCFG_SWPR_P12WP_Pos = 0xc
	// Bit mask of P12WP field.
	SYSCFG_SWPR_P12WP_Msk = 0x1000
	// Bit P12WP.
	SYSCFG_SWPR_P12WP = 0x1000
	// Position of P11WP field.
	SYSCFG_SWPR_P11WP_Pos = 0xb
	// Bit mask of P11WP field.
	SYSCFG_SWPR_P11WP_Msk = 0x800
	// Bit P11WP.
	SYSCFG_SWPR_P11WP = 0x800
	// Position of P10WP field.
	SYSCFG_SWPR_P10WP_Pos = 0xa
	// Bit mask of P10WP field.
	SYSCFG_SWPR_P10WP_Msk = 0x400
	// Bit P10WP.
	SYSCFG_SWPR_P10WP = 0x400
	// Position of P9WP field.
	SYSCFG_SWPR_P9WP_Pos = 0x9
	// Bit mask of P9WP field.
	SYSCFG_SWPR_P9WP_Msk = 0x200
	// Bit P9WP.
	SYSCFG_SWPR_P9WP = 0x200
	// Position of P8WP field.
	SYSCFG_SWPR_P8WP_Pos = 0x8
	// Bit mask of P8WP field.
	SYSCFG_SWPR_P8WP_Msk = 0x100
	// Bit P8WP.
	SYSCFG_SWPR_P8WP = 0x100
	// Position of P7WP field.
	SYSCFG_SWPR_P7WP_Pos = 0x7
	// Bit mask of P7WP field.
	SYSCFG_SWPR_P7WP_Msk = 0x80
	// Bit P7WP.
	SYSCFG_SWPR_P7WP = 0x80
	// Position of P6WP field.
	SYSCFG_SWPR_P6WP_Pos = 0x6
	// Bit mask of P6WP field.
	SYSCFG_SWPR_P6WP_Msk = 0x40
	// Bit P6WP.
	SYSCFG_SWPR_P6WP = 0x40
	// Position of P5WP field.
	SYSCFG_SWPR_P5WP_Pos = 0x5
	// Bit mask of P5WP field.
	SYSCFG_SWPR_P5WP_Msk = 0x20
	// Bit P5WP.
	SYSCFG_SWPR_P5WP = 0x20
	// Position of P4WP field.
	SYSCFG_SWPR_P4WP_Pos = 0x4
	// Bit mask of P4WP field.
	SYSCFG_SWPR_P4WP_Msk = 0x10
	// Bit P4WP.
	SYSCFG_SWPR_P4WP = 0x10
	// Position of P3WP field.
	SYSCFG_SWPR_P3WP_Pos = 0x3
	// Bit mask of P3WP field.
	SYSCFG_SWPR_P3WP_Msk = 0x8
	// Bit P3WP.
	SYSCFG_SWPR_P3WP = 0x8
	// Position of P2WP field.
	SYSCFG_SWPR_P2WP_Pos = 0x2
	// Bit mask of P2WP field.
	SYSCFG_SWPR_P2WP_Msk = 0x4
	// Bit P2WP.
	SYSCFG_SWPR_P2WP = 0x4
	// Position of P1WP field.
	SYSCFG_SWPR_P1WP_Pos = 0x1
	// Bit mask of P1WP field.
	SYSCFG_SWPR_P1WP_Msk = 0x2
	// Bit P1WP.
	SYSCFG_SWPR_P1WP = 0x2
	// Position of P0WP field.
	SYSCFG_SWPR_P0WP_Pos = 0x0
	// Bit mask of P0WP field.
	SYSCFG_SWPR_P0WP_Msk = 0x1
	// Bit P0WP.
	SYSCFG_SWPR_P0WP = 0x1

	// SKR: SKR
	// Position of KEY field.
	SYSCFG_SKR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	SYSCFG_SKR_KEY_Msk = 0xff
)

// Constants for DFSDM1: Digital filter for sigma delta modulators
const (
	// CH0CFGR1: channel configuration y register
	// Position of DFSDMEN field.
	DFSDM_CH0CFGR1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CH0CFGR1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CH0CFGR1_DFSDMEN = 0x80000000
	// Position of CKOUTSRC field.
	DFSDM_CH0CFGR1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CH0CFGR1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CH0CFGR1_CKOUTSRC = 0x40000000
	// Position of CKOUTDIV field.
	DFSDM_CH0CFGR1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CH0CFGR1_CKOUTDIV_Msk = 0xff0000
	// Position of DATPACK field.
	DFSDM_CH0CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH0CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH0CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH0CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH0CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH0CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH0CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH0CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH0CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH0CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH0CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH0CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH0CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH0CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH0CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH0CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH0CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH0CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH0CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH0CFGR1_SITP_Msk = 0x3

	// CH0CFGR2: channel configuration y register
	// Position of OFFSET field.
	DFSDM_CH0CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH0CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH0CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH0CFGR2_DTRBS_Msk = 0xf8

	// CH0AWSCDR: analog watchdog and short-circuit detector register
	// Position of AWFORD field.
	DFSDM_CH0AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH0AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH0AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH0AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH0AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH0AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH0AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH0AWSCDR_SCDT_Msk = 0xff

	// CH0WDATR: channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CH0WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH0WDATR_WDATA_Msk = 0xffff

	// CH0DATINR: channel data input register
	// Position of INDAT1 field.
	DFSDM_CH0DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH0DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH0DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH0DATINR_INDAT0_Msk = 0xffff

	// CH0DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH0DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH0DLYR_PLSSKP_Msk = 0x3f

	// CH1CFGR1: CH1CFGR1
	// Position of DATPACK field.
	DFSDM_CH1CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH1CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH1CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH1CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH1CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH1CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH1CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH1CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH1CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH1CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH1CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH1CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH1CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH1CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH1CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH1CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH1CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH1CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH1CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH1CFGR1_SITP_Msk = 0x3

	// CH1CFGR2: CH1CFGR2
	// Position of OFFSET field.
	DFSDM_CH1CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH1CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH1CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH1CFGR2_DTRBS_Msk = 0xf8

	// CH1AWSCDR: CH1AWSCDR
	// Position of AWFORD field.
	DFSDM_CH1AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH1AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH1AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH1AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH1AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH1AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH1AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH1AWSCDR_SCDT_Msk = 0xff

	// CH1WDATR: CH1WDATR
	// Position of WDATA field.
	DFSDM_CH1WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH1WDATR_WDATA_Msk = 0xffff

	// CH1DATINR: CH1DATINR
	// Position of INDAT1 field.
	DFSDM_CH1DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH1DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH1DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH1DATINR_INDAT0_Msk = 0xffff

	// CH1DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH1DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH1DLYR_PLSSKP_Msk = 0x3f

	// CH2CFGR1: CH2CFGR1
	// Position of DATPACK field.
	DFSDM_CH2CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH2CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH2CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH2CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH2CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH2CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH2CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH2CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH2CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH2CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH2CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH2CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH2CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH2CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH2CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH2CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH2CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH2CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH2CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH2CFGR1_SITP_Msk = 0x3

	// CH2CFGR2: CH2CFGR2
	// Position of OFFSET field.
	DFSDM_CH2CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH2CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH2CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH2CFGR2_DTRBS_Msk = 0xf8

	// CH2AWSCDR: CH2AWSCDR
	// Position of AWFORD field.
	DFSDM_CH2AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH2AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH2AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH2AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH2AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH2AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH2AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH2AWSCDR_SCDT_Msk = 0xff

	// CH2WDATR: CH2WDATR
	// Position of WDATA field.
	DFSDM_CH2WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH2WDATR_WDATA_Msk = 0xffff

	// CH2DATINR: CH2DATINR
	// Position of INDAT1 field.
	DFSDM_CH2DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH2DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH2DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH2DATINR_INDAT0_Msk = 0xffff

	// CH2DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH2DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH2DLYR_PLSSKP_Msk = 0x3f

	// CH3CFGR1: CH3CFGR1
	// Position of DATPACK field.
	DFSDM_CH3CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH3CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH3CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH3CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH3CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH3CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH3CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH3CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH3CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH3CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH3CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH3CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH3CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH3CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH3CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH3CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH3CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH3CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH3CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH3CFGR1_SITP_Msk = 0x3

	// CH3CFGR2: CH3CFGR2
	// Position of OFFSET field.
	DFSDM_CH3CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH3CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH3CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH3CFGR2_DTRBS_Msk = 0xf8

	// CH3AWSCDR: CH3AWSCDR
	// Position of AWFORD field.
	DFSDM_CH3AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH3AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH3AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH3AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH3AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH3AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH3AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH3AWSCDR_SCDT_Msk = 0xff

	// CH3WDATR: CH3WDATR
	// Position of WDATA field.
	DFSDM_CH3WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH3WDATR_WDATA_Msk = 0xffff

	// CH3DATINR: CH3DATINR
	// Position of INDAT1 field.
	DFSDM_CH3DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH3DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH3DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH3DATINR_INDAT0_Msk = 0xffff

	// CH3DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH3DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH3DLYR_PLSSKP_Msk = 0x3f

	// CH4CFGR1: CH4CFGR1
	// Position of DATPACK field.
	DFSDM_CH4CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH4CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH4CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH4CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH4CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH4CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH4CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH4CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH4CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH4CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH4CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH4CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH4CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH4CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH4CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH4CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH4CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH4CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH4CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH4CFGR1_SITP_Msk = 0x3

	// CH4CFGR2: CH4CFGR2
	// Position of OFFSET field.
	DFSDM_CH4CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH4CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH4CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH4CFGR2_DTRBS_Msk = 0xf8

	// CH4AWSCDR: CH4AWSCDR
	// Position of AWFORD field.
	DFSDM_CH4AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH4AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH4AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH4AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH4AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH4AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH4AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH4AWSCDR_SCDT_Msk = 0xff

	// CH4WDATR: CH4WDATR
	// Position of WDATA field.
	DFSDM_CH4WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH4WDATR_WDATA_Msk = 0xffff

	// CH4DATINR: CH4DATINR
	// Position of INDAT1 field.
	DFSDM_CH4DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH4DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH4DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH4DATINR_INDAT0_Msk = 0xffff

	// CH4DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH4DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH4DLYR_PLSSKP_Msk = 0x3f

	// CH5CFGR1: CH5CFGR1
	// Position of DATPACK field.
	DFSDM_CH5CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH5CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH5CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH5CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH5CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH5CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH5CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH5CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH5CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH5CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH5CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH5CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH5CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH5CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH5CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH5CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH5CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH5CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH5CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH5CFGR1_SITP_Msk = 0x3

	// CH5CFGR2: CH5CFGR2
	// Position of OFFSET field.
	DFSDM_CH5CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH5CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH5CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH5CFGR2_DTRBS_Msk = 0xf8

	// CH5AWSCDR: CH5AWSCDR
	// Position of AWFORD field.
	DFSDM_CH5AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH5AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH5AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH5AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH5AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH5AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH5AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH5AWSCDR_SCDT_Msk = 0xff

	// CH5WDATR: CH5WDATR
	// Position of WDATA field.
	DFSDM_CH5WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH5WDATR_WDATA_Msk = 0xffff

	// CH5DATINR: CH5DATINR
	// Position of INDAT1 field.
	DFSDM_CH5DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH5DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH5DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH5DATINR_INDAT0_Msk = 0xffff

	// CH5DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH5DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH5DLYR_PLSSKP_Msk = 0x3f

	// CH6CFGR1: CH6CFGR1
	// Position of DATPACK field.
	DFSDM_CH6CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH6CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH6CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH6CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH6CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH6CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH6CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH6CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH6CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH6CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH6CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH6CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH6CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH6CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH6CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH6CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH6CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH6CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH6CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH6CFGR1_SITP_Msk = 0x3

	// CH6CFGR2: CH6CFGR2
	// Position of OFFSET field.
	DFSDM_CH6CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH6CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH6CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH6CFGR2_DTRBS_Msk = 0xf8

	// CH6AWSCDR: CH6AWSCDR
	// Position of AWFORD field.
	DFSDM_CH6AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH6AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH6AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH6AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH6AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH6AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH6AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH6AWSCDR_SCDT_Msk = 0xff

	// CH6WDATR: CH6WDATR
	// Position of WDATA field.
	DFSDM_CH6WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH6WDATR_WDATA_Msk = 0xffff

	// CH6DATINR: CH6DATINR
	// Position of INDAT1 field.
	DFSDM_CH6DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH6DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH6DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH6DATINR_INDAT0_Msk = 0xffff

	// CH6DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH6DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH6DLYR_PLSSKP_Msk = 0x3f

	// CH7CFGR1: CH7CFGR1
	// Position of DATPACK field.
	DFSDM_CH7CFGR1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CH7CFGR1_DATPACK_Msk = 0xc000
	// Position of DATMPX field.
	DFSDM_CH7CFGR1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CH7CFGR1_DATMPX_Msk = 0x3000
	// Position of CHINSEL field.
	DFSDM_CH7CFGR1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CH7CFGR1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CH7CFGR1_CHINSEL = 0x100
	// Position of CHEN field.
	DFSDM_CH7CFGR1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CH7CFGR1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CH7CFGR1_CHEN = 0x80
	// Position of CKABEN field.
	DFSDM_CH7CFGR1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CH7CFGR1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CH7CFGR1_CKABEN = 0x40
	// Position of SCDEN field.
	DFSDM_CH7CFGR1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CH7CFGR1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CH7CFGR1_SCDEN = 0x20
	// Position of SPICKSEL field.
	DFSDM_CH7CFGR1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CH7CFGR1_SPICKSEL_Msk = 0xc
	// Position of SITP field.
	DFSDM_CH7CFGR1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CH7CFGR1_SITP_Msk = 0x3

	// CH7CFGR2: CH7CFGR2
	// Position of OFFSET field.
	DFSDM_CH7CFGR2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CH7CFGR2_OFFSET_Msk = 0xffffff00
	// Position of DTRBS field.
	DFSDM_CH7CFGR2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CH7CFGR2_DTRBS_Msk = 0xf8

	// CH7AWSCDR: CH7AWSCDR
	// Position of AWFORD field.
	DFSDM_CH7AWSCDR_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_CH7AWSCDR_AWFORD_Msk = 0xc00000
	// Position of AWFOSR field.
	DFSDM_CH7AWSCDR_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_CH7AWSCDR_AWFOSR_Msk = 0x1f0000
	// Position of BKSCD field.
	DFSDM_CH7AWSCDR_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_CH7AWSCDR_BKSCD_Msk = 0xf000
	// Position of SCDT field.
	DFSDM_CH7AWSCDR_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_CH7AWSCDR_SCDT_Msk = 0xff

	// CH7WDATR: CH7WDATR
	// Position of WDATA field.
	DFSDM_CH7WDATR_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CH7WDATR_WDATA_Msk = 0xffff

	// CH7DATINR: CH7DATINR
	// Position of INDAT1 field.
	DFSDM_CH7DATINR_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CH7DATINR_INDAT1_Msk = 0xffff0000
	// Position of INDAT0 field.
	DFSDM_CH7DATINR_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CH7DATINR_INDAT0_Msk = 0xffff

	// CH7DLYR: channel y delay register
	// Position of PLSSKP field.
	DFSDM_CH7DLYR_PLSSKP_Pos = 0x0
	// Bit mask of PLSSKP field.
	DFSDM_CH7DLYR_PLSSKP_Msk = 0x3f

	// DFSDM_FLT0CR1: control register 1
	// Position of AWFSEL field.
	DFSDM_DFSDM_FLT0CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM_FLT0CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM_FLT0CR1_AWFSEL = 0x40000000
	// Position of FAST field.
	DFSDM_DFSDM_FLT0CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM_FLT0CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM_FLT0CR1_FAST = 0x20000000
	// Position of RCH field.
	DFSDM_DFSDM_FLT0CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM_FLT0CR1_RCH_Msk = 0x7000000
	// Position of RDMAEN field.
	DFSDM_DFSDM_FLT0CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM_FLT0CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM_FLT0CR1_RDMAEN = 0x200000
	// Position of RSYNC field.
	DFSDM_DFSDM_FLT0CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM_FLT0CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM_FLT0CR1_RSYNC = 0x80000
	// Position of RCONT field.
	DFSDM_DFSDM_FLT0CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM_FLT0CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM_FLT0CR1_RCONT = 0x40000
	// Position of RSWSTART field.
	DFSDM_DFSDM_FLT0CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM_FLT0CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM_FLT0CR1_RSWSTART = 0x20000
	// Position of JEXTEN field.
	DFSDM_DFSDM_FLT0CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM_FLT0CR1_JEXTEN_Msk = 0x6000
	// Position of JEXTSEL field.
	DFSDM_DFSDM_FLT0CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM_FLT0CR1_JEXTSEL_Msk = 0x700
	// Position of JDMAEN field.
	DFSDM_DFSDM_FLT0CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM_FLT0CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM_FLT0CR1_JDMAEN = 0x20
	// Position of JSCAN field.
	DFSDM_DFSDM_FLT0CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM_FLT0CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM_FLT0CR1_JSCAN = 0x10
	// Position of JSYNC field.
	DFSDM_DFSDM_FLT0CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM_FLT0CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM_FLT0CR1_JSYNC = 0x8
	// Position of JSWSTART field.
	DFSDM_DFSDM_FLT0CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM_FLT0CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM_FLT0CR1_JSWSTART = 0x2
	// Position of DFEN field.
	DFSDM_DFSDM_FLT0CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM_FLT0CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM_FLT0CR1_DFEN = 0x1

	// DFSDM_FLT0CR2: control register 2
	// Position of AWDCH field.
	DFSDM_DFSDM_FLT0CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM_FLT0CR2_AWDCH_Msk = 0xff0000
	// Position of EXCH field.
	DFSDM_DFSDM_FLT0CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM_FLT0CR2_EXCH_Msk = 0xff00
	// Position of CKABIE field.
	DFSDM_DFSDM_FLT0CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM_FLT0CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM_FLT0CR2_CKABIE = 0x40
	// Position of SCDIE field.
	DFSDM_DFSDM_FLT0CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM_FLT0CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM_FLT0CR2_SCDIE = 0x20
	// Position of AWDIE field.
	DFSDM_DFSDM_FLT0CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM_FLT0CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM_FLT0CR2_AWDIE = 0x10
	// Position of ROVRIE field.
	DFSDM_DFSDM_FLT0CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM_FLT0CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM_FLT0CR2_ROVRIE = 0x8
	// Position of JOVRIE field.
	DFSDM_DFSDM_FLT0CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM_FLT0CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM_FLT0CR2_JOVRIE = 0x4
	// Position of REOCIE field.
	DFSDM_DFSDM_FLT0CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM_FLT0CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM_FLT0CR2_REOCIE = 0x2
	// Position of JEOCIE field.
	DFSDM_DFSDM_FLT0CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM_FLT0CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM_FLT0CR2_JEOCIE = 0x1

	// DFSDM_FLT0ISR: interrupt and status register
	// Position of SCDF field.
	DFSDM_DFSDM_FLT0ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM_FLT0ISR_SCDF_Msk = 0xff000000
	// Position of CKABF field.
	DFSDM_DFSDM_FLT0ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM_FLT0ISR_CKABF_Msk = 0xff0000
	// Position of RCIP field.
	DFSDM_DFSDM_FLT0ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM_FLT0ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM_FLT0ISR_RCIP = 0x4000
	// Position of JCIP field.
	DFSDM_DFSDM_FLT0ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM_FLT0ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM_FLT0ISR_JCIP = 0x2000
	// Position of AWDF field.
	DFSDM_DFSDM_FLT0ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM_FLT0ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM_FLT0ISR_AWDF = 0x10
	// Position of ROVRF field.
	DFSDM_DFSDM_FLT0ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM_FLT0ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM_FLT0ISR_ROVRF = 0x8
	// Position of JOVRF field.
	DFSDM_DFSDM_FLT0ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM_FLT0ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM_FLT0ISR_JOVRF = 0x4
	// Position of REOCF field.
	DFSDM_DFSDM_FLT0ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM_FLT0ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM_FLT0ISR_REOCF = 0x2
	// Position of JEOCF field.
	DFSDM_DFSDM_FLT0ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM_FLT0ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM_FLT0ISR_JEOCF = 0x1

	// DFSDM_FLT0ICR: interrupt flag clear register
	// Position of CLRSCDF field.
	DFSDM_DFSDM_FLT0ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM_FLT0ICR_CLRSCDF_Msk = 0xff000000
	// Position of CLRCKABF field.
	DFSDM_DFSDM_FLT0ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM_FLT0ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRROVRF field.
	DFSDM_DFSDM_FLT0ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM_FLT0ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM_FLT0ICR_CLRROVRF = 0x8
	// Position of CLRJOVRF field.
	DFSDM_DFSDM_FLT0ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM_FLT0ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM_FLT0ICR_CLRJOVRF = 0x4

	// DFSDM_FLT0JCHGR: injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM_FLT0JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM_FLT0JCHGR_JCHG_Msk = 0xff

	// DFSDM_FLT0FCR: filter control register
	// Position of FORD field.
	DFSDM_DFSDM_FLT0FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM_FLT0FCR_FORD_Msk = 0xe0000000
	// Position of FOSR field.
	DFSDM_DFSDM_FLT0FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM_FLT0FCR_FOSR_Msk = 0x3ff0000
	// Position of IOSR field.
	DFSDM_DFSDM_FLT0FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM_FLT0FCR_IOSR_Msk = 0xff

	// DFSDM_FLT0JDATAR: data register for injected group
	// Position of JDATA field.
	DFSDM_DFSDM_FLT0JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM_FLT0JDATAR_JDATA_Msk = 0xffffff00
	// Position of JDATACH field.
	DFSDM_DFSDM_FLT0JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM_FLT0JDATAR_JDATACH_Msk = 0x7

	// DFSDM_FLT0RDATAR: data register for the regular channel
	// Position of RDATA field.
	DFSDM_DFSDM_FLT0RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM_FLT0RDATAR_RDATA_Msk = 0xffffff00
	// Position of RPEND field.
	DFSDM_DFSDM_FLT0RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM_FLT0RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM_FLT0RDATAR_RPEND = 0x10
	// Position of RDATACH field.
	DFSDM_DFSDM_FLT0RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM_FLT0RDATAR_RDATACH_Msk = 0x7

	// DFSDM_FLT0AWHTR: analog watchdog high threshold register
	// Position of AWHT field.
	DFSDM_DFSDM_FLT0AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM_FLT0AWHTR_AWHT_Msk = 0xffffff00
	// Position of BKAWH field.
	DFSDM_DFSDM_FLT0AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM_FLT0AWHTR_BKAWH_Msk = 0xf

	// DFSDM_FLT0AWLTR: analog watchdog low threshold register
	// Position of AWLT field.
	DFSDM_DFSDM_FLT0AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM_FLT0AWLTR_AWLT_Msk = 0xffffff00
	// Position of BKAWL field.
	DFSDM_DFSDM_FLT0AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM_FLT0AWLTR_BKAWL_Msk = 0xf

	// DFSDM_FLT0AWSR: analog watchdog status register
	// Position of AWHTF field.
	DFSDM_DFSDM_FLT0AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM_FLT0AWSR_AWHTF_Msk = 0xff00
	// Position of AWLTF field.
	DFSDM_DFSDM_FLT0AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM_FLT0AWSR_AWLTF_Msk = 0xff

	// DFSDM_FLT0AWCFR: analog watchdog clear flag register
	// Position of CLRAWHTF field.
	DFSDM_DFSDM_FLT0AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM_FLT0AWCFR_CLRAWHTF_Msk = 0xff00
	// Position of CLRAWLTF field.
	DFSDM_DFSDM_FLT0AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM_FLT0AWCFR_CLRAWLTF_Msk = 0xff

	// DFSDM_FLT0EXMAX: Extremes detector maximum register
	// Position of EXMAX field.
	DFSDM_DFSDM_FLT0EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM_FLT0EXMAX_EXMAX_Msk = 0xffffff00
	// Position of EXMAXCH field.
	DFSDM_DFSDM_FLT0EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM_FLT0EXMAX_EXMAXCH_Msk = 0x7

	// DFSDM_FLT0EXMIN: Extremes detector minimum register
	// Position of EXMIN field.
	DFSDM_DFSDM_FLT0EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM_FLT0EXMIN_EXMIN_Msk = 0xffffff00
	// Position of EXMINCH field.
	DFSDM_DFSDM_FLT0EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM_FLT0EXMIN_EXMINCH_Msk = 0x7

	// DFSDM_FLT0CNVTIMR: conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM_FLT0CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM_FLT0CNVTIMR_CNVCNT_Msk = 0xfffffff0

	// DFSDM_FLT1CR1: control register 1
	// Position of AWFSEL field.
	DFSDM_DFSDM_FLT1CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM_FLT1CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM_FLT1CR1_AWFSEL = 0x40000000
	// Position of FAST field.
	DFSDM_DFSDM_FLT1CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM_FLT1CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM_FLT1CR1_FAST = 0x20000000
	// Position of RCH field.
	DFSDM_DFSDM_FLT1CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM_FLT1CR1_RCH_Msk = 0x7000000
	// Position of RDMAEN field.
	DFSDM_DFSDM_FLT1CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM_FLT1CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM_FLT1CR1_RDMAEN = 0x200000
	// Position of RSYNC field.
	DFSDM_DFSDM_FLT1CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM_FLT1CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM_FLT1CR1_RSYNC = 0x80000
	// Position of RCONT field.
	DFSDM_DFSDM_FLT1CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM_FLT1CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM_FLT1CR1_RCONT = 0x40000
	// Position of RSWSTART field.
	DFSDM_DFSDM_FLT1CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM_FLT1CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM_FLT1CR1_RSWSTART = 0x20000
	// Position of JEXTEN field.
	DFSDM_DFSDM_FLT1CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM_FLT1CR1_JEXTEN_Msk = 0x6000
	// Position of JEXTSEL field.
	DFSDM_DFSDM_FLT1CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM_FLT1CR1_JEXTSEL_Msk = 0x700
	// Position of JDMAEN field.
	DFSDM_DFSDM_FLT1CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM_FLT1CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM_FLT1CR1_JDMAEN = 0x20
	// Position of JSCAN field.
	DFSDM_DFSDM_FLT1CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM_FLT1CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM_FLT1CR1_JSCAN = 0x10
	// Position of JSYNC field.
	DFSDM_DFSDM_FLT1CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM_FLT1CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM_FLT1CR1_JSYNC = 0x8
	// Position of JSWSTART field.
	DFSDM_DFSDM_FLT1CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM_FLT1CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM_FLT1CR1_JSWSTART = 0x2
	// Position of DFEN field.
	DFSDM_DFSDM_FLT1CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM_FLT1CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM_FLT1CR1_DFEN = 0x1

	// DFSDM_FLT1CR2: control register 2
	// Position of AWDCH field.
	DFSDM_DFSDM_FLT1CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM_FLT1CR2_AWDCH_Msk = 0xff0000
	// Position of EXCH field.
	DFSDM_DFSDM_FLT1CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM_FLT1CR2_EXCH_Msk = 0xff00
	// Position of CKABIE field.
	DFSDM_DFSDM_FLT1CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM_FLT1CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM_FLT1CR2_CKABIE = 0x40
	// Position of SCDIE field.
	DFSDM_DFSDM_FLT1CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM_FLT1CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM_FLT1CR2_SCDIE = 0x20
	// Position of AWDIE field.
	DFSDM_DFSDM_FLT1CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM_FLT1CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM_FLT1CR2_AWDIE = 0x10
	// Position of ROVRIE field.
	DFSDM_DFSDM_FLT1CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM_FLT1CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM_FLT1CR2_ROVRIE = 0x8
	// Position of JOVRIE field.
	DFSDM_DFSDM_FLT1CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM_FLT1CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM_FLT1CR2_JOVRIE = 0x4
	// Position of REOCIE field.
	DFSDM_DFSDM_FLT1CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM_FLT1CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM_FLT1CR2_REOCIE = 0x2
	// Position of JEOCIE field.
	DFSDM_DFSDM_FLT1CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM_FLT1CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM_FLT1CR2_JEOCIE = 0x1

	// DFSDM_FLT1ISR: interrupt and status register
	// Position of SCDF field.
	DFSDM_DFSDM_FLT1ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM_FLT1ISR_SCDF_Msk = 0xff000000
	// Position of CKABF field.
	DFSDM_DFSDM_FLT1ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM_FLT1ISR_CKABF_Msk = 0xff0000
	// Position of RCIP field.
	DFSDM_DFSDM_FLT1ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM_FLT1ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM_FLT1ISR_RCIP = 0x4000
	// Position of JCIP field.
	DFSDM_DFSDM_FLT1ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM_FLT1ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM_FLT1ISR_JCIP = 0x2000
	// Position of AWDF field.
	DFSDM_DFSDM_FLT1ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM_FLT1ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM_FLT1ISR_AWDF = 0x10
	// Position of ROVRF field.
	DFSDM_DFSDM_FLT1ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM_FLT1ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM_FLT1ISR_ROVRF = 0x8
	// Position of JOVRF field.
	DFSDM_DFSDM_FLT1ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM_FLT1ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM_FLT1ISR_JOVRF = 0x4
	// Position of REOCF field.
	DFSDM_DFSDM_FLT1ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM_FLT1ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM_FLT1ISR_REOCF = 0x2
	// Position of JEOCF field.
	DFSDM_DFSDM_FLT1ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM_FLT1ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM_FLT1ISR_JEOCF = 0x1

	// DFSDM_FLT1ICR: interrupt flag clear register
	// Position of CLRSCDF field.
	DFSDM_DFSDM_FLT1ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM_FLT1ICR_CLRSCDF_Msk = 0xff000000
	// Position of CLRCKABF field.
	DFSDM_DFSDM_FLT1ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM_FLT1ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRROVRF field.
	DFSDM_DFSDM_FLT1ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM_FLT1ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM_FLT1ICR_CLRROVRF = 0x8
	// Position of CLRJOVRF field.
	DFSDM_DFSDM_FLT1ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM_FLT1ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM_FLT1ICR_CLRJOVRF = 0x4

	// DFSDM_FLT1CHGR: injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM_FLT1CHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM_FLT1CHGR_JCHG_Msk = 0xff

	// DFSDM_FLT1FCR: filter control register
	// Position of FORD field.
	DFSDM_DFSDM_FLT1FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM_FLT1FCR_FORD_Msk = 0xe0000000
	// Position of FOSR field.
	DFSDM_DFSDM_FLT1FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM_FLT1FCR_FOSR_Msk = 0x3ff0000
	// Position of IOSR field.
	DFSDM_DFSDM_FLT1FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM_FLT1FCR_IOSR_Msk = 0xff

	// DFSDM_FLT1JDATAR: data register for injected group
	// Position of JDATA field.
	DFSDM_DFSDM_FLT1JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM_FLT1JDATAR_JDATA_Msk = 0xffffff00
	// Position of JDATACH field.
	DFSDM_DFSDM_FLT1JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM_FLT1JDATAR_JDATACH_Msk = 0x7

	// DFSDM_FLT1RDATAR: data register for the regular channel
	// Position of RDATA field.
	DFSDM_DFSDM_FLT1RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM_FLT1RDATAR_RDATA_Msk = 0xffffff00
	// Position of RPEND field.
	DFSDM_DFSDM_FLT1RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM_FLT1RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM_FLT1RDATAR_RPEND = 0x10
	// Position of RDATACH field.
	DFSDM_DFSDM_FLT1RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM_FLT1RDATAR_RDATACH_Msk = 0x7

	// DFSDM_FLT1AWHTR: analog watchdog high threshold register
	// Position of AWHT field.
	DFSDM_DFSDM_FLT1AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM_FLT1AWHTR_AWHT_Msk = 0xffffff00
	// Position of BKAWH field.
	DFSDM_DFSDM_FLT1AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM_FLT1AWHTR_BKAWH_Msk = 0xf

	// DFSDM_FLT1AWLTR: analog watchdog low threshold register
	// Position of AWLT field.
	DFSDM_DFSDM_FLT1AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM_FLT1AWLTR_AWLT_Msk = 0xffffff00
	// Position of BKAWL field.
	DFSDM_DFSDM_FLT1AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM_FLT1AWLTR_BKAWL_Msk = 0xf

	// DFSDM_FLT1AWSR: analog watchdog status register
	// Position of AWHTF field.
	DFSDM_DFSDM_FLT1AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM_FLT1AWSR_AWHTF_Msk = 0xff00
	// Position of AWLTF field.
	DFSDM_DFSDM_FLT1AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM_FLT1AWSR_AWLTF_Msk = 0xff

	// DFSDM_FLT1AWCFR: analog watchdog clear flag register
	// Position of CLRAWHTF field.
	DFSDM_DFSDM_FLT1AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM_FLT1AWCFR_CLRAWHTF_Msk = 0xff00
	// Position of CLRAWLTF field.
	DFSDM_DFSDM_FLT1AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM_FLT1AWCFR_CLRAWLTF_Msk = 0xff

	// DFSDM_FLT1EXMAX: Extremes detector maximum register
	// Position of EXMAX field.
	DFSDM_DFSDM_FLT1EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM_FLT1EXMAX_EXMAX_Msk = 0xffffff00
	// Position of EXMAXCH field.
	DFSDM_DFSDM_FLT1EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM_FLT1EXMAX_EXMAXCH_Msk = 0x7

	// DFSDM_FLT1EXMIN: Extremes detector minimum register
	// Position of EXMIN field.
	DFSDM_DFSDM_FLT1EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM_FLT1EXMIN_EXMIN_Msk = 0xffffff00
	// Position of EXMINCH field.
	DFSDM_DFSDM_FLT1EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM_FLT1EXMIN_EXMINCH_Msk = 0x7

	// DFSDM_FLT1CNVTIMR: conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM_FLT1CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM_FLT1CNVTIMR_CNVCNT_Msk = 0xfffffff0

	// DFSDM_FLT2CR1: control register 1
	// Position of AWFSEL field.
	DFSDM_DFSDM_FLT2CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM_FLT2CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM_FLT2CR1_AWFSEL = 0x40000000
	// Position of FAST field.
	DFSDM_DFSDM_FLT2CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM_FLT2CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM_FLT2CR1_FAST = 0x20000000
	// Position of RCH field.
	DFSDM_DFSDM_FLT2CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM_FLT2CR1_RCH_Msk = 0x7000000
	// Position of RDMAEN field.
	DFSDM_DFSDM_FLT2CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM_FLT2CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM_FLT2CR1_RDMAEN = 0x200000
	// Position of RSYNC field.
	DFSDM_DFSDM_FLT2CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM_FLT2CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM_FLT2CR1_RSYNC = 0x80000
	// Position of RCONT field.
	DFSDM_DFSDM_FLT2CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM_FLT2CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM_FLT2CR1_RCONT = 0x40000
	// Position of RSWSTART field.
	DFSDM_DFSDM_FLT2CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM_FLT2CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM_FLT2CR1_RSWSTART = 0x20000
	// Position of JEXTEN field.
	DFSDM_DFSDM_FLT2CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM_FLT2CR1_JEXTEN_Msk = 0x6000
	// Position of JEXTSEL field.
	DFSDM_DFSDM_FLT2CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM_FLT2CR1_JEXTSEL_Msk = 0x700
	// Position of JDMAEN field.
	DFSDM_DFSDM_FLT2CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM_FLT2CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM_FLT2CR1_JDMAEN = 0x20
	// Position of JSCAN field.
	DFSDM_DFSDM_FLT2CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM_FLT2CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM_FLT2CR1_JSCAN = 0x10
	// Position of JSYNC field.
	DFSDM_DFSDM_FLT2CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM_FLT2CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM_FLT2CR1_JSYNC = 0x8
	// Position of JSWSTART field.
	DFSDM_DFSDM_FLT2CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM_FLT2CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM_FLT2CR1_JSWSTART = 0x2
	// Position of DFEN field.
	DFSDM_DFSDM_FLT2CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM_FLT2CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM_FLT2CR1_DFEN = 0x1

	// DFSDM_FLT2CR2: control register 2
	// Position of AWDCH field.
	DFSDM_DFSDM_FLT2CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM_FLT2CR2_AWDCH_Msk = 0xff0000
	// Position of EXCH field.
	DFSDM_DFSDM_FLT2CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM_FLT2CR2_EXCH_Msk = 0xff00
	// Position of CKABIE field.
	DFSDM_DFSDM_FLT2CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM_FLT2CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM_FLT2CR2_CKABIE = 0x40
	// Position of SCDIE field.
	DFSDM_DFSDM_FLT2CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM_FLT2CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM_FLT2CR2_SCDIE = 0x20
	// Position of AWDIE field.
	DFSDM_DFSDM_FLT2CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM_FLT2CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM_FLT2CR2_AWDIE = 0x10
	// Position of ROVRIE field.
	DFSDM_DFSDM_FLT2CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM_FLT2CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM_FLT2CR2_ROVRIE = 0x8
	// Position of JOVRIE field.
	DFSDM_DFSDM_FLT2CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM_FLT2CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM_FLT2CR2_JOVRIE = 0x4
	// Position of REOCIE field.
	DFSDM_DFSDM_FLT2CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM_FLT2CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM_FLT2CR2_REOCIE = 0x2
	// Position of JEOCIE field.
	DFSDM_DFSDM_FLT2CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM_FLT2CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM_FLT2CR2_JEOCIE = 0x1

	// DFSDM_FLT2ISR: interrupt and status register
	// Position of SCDF field.
	DFSDM_DFSDM_FLT2ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM_FLT2ISR_SCDF_Msk = 0xff000000
	// Position of CKABF field.
	DFSDM_DFSDM_FLT2ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM_FLT2ISR_CKABF_Msk = 0xff0000
	// Position of RCIP field.
	DFSDM_DFSDM_FLT2ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM_FLT2ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM_FLT2ISR_RCIP = 0x4000
	// Position of JCIP field.
	DFSDM_DFSDM_FLT2ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM_FLT2ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM_FLT2ISR_JCIP = 0x2000
	// Position of AWDF field.
	DFSDM_DFSDM_FLT2ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM_FLT2ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM_FLT2ISR_AWDF = 0x10
	// Position of ROVRF field.
	DFSDM_DFSDM_FLT2ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM_FLT2ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM_FLT2ISR_ROVRF = 0x8
	// Position of JOVRF field.
	DFSDM_DFSDM_FLT2ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM_FLT2ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM_FLT2ISR_JOVRF = 0x4
	// Position of REOCF field.
	DFSDM_DFSDM_FLT2ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM_FLT2ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM_FLT2ISR_REOCF = 0x2
	// Position of JEOCF field.
	DFSDM_DFSDM_FLT2ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM_FLT2ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM_FLT2ISR_JEOCF = 0x1

	// DFSDM_FLT2ICR: interrupt flag clear register
	// Position of CLRSCDF field.
	DFSDM_DFSDM_FLT2ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM_FLT2ICR_CLRSCDF_Msk = 0xff000000
	// Position of CLRCKABF field.
	DFSDM_DFSDM_FLT2ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM_FLT2ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRROVRF field.
	DFSDM_DFSDM_FLT2ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM_FLT2ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM_FLT2ICR_CLRROVRF = 0x8
	// Position of CLRJOVRF field.
	DFSDM_DFSDM_FLT2ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM_FLT2ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM_FLT2ICR_CLRJOVRF = 0x4

	// DFSDM_FLT2JCHGR: injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM_FLT2JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM_FLT2JCHGR_JCHG_Msk = 0xff

	// DFSDM_FLT2FCR: filter control register
	// Position of FORD field.
	DFSDM_DFSDM_FLT2FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM_FLT2FCR_FORD_Msk = 0xe0000000
	// Position of FOSR field.
	DFSDM_DFSDM_FLT2FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM_FLT2FCR_FOSR_Msk = 0x3ff0000
	// Position of IOSR field.
	DFSDM_DFSDM_FLT2FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM_FLT2FCR_IOSR_Msk = 0xff

	// DFSDM_FLT2JDATAR: data register for injected group
	// Position of JDATA field.
	DFSDM_DFSDM_FLT2JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM_FLT2JDATAR_JDATA_Msk = 0xffffff00
	// Position of JDATACH field.
	DFSDM_DFSDM_FLT2JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM_FLT2JDATAR_JDATACH_Msk = 0x7

	// DFSDM_FLT2RDATAR: data register for the regular channel
	// Position of RDATA field.
	DFSDM_DFSDM_FLT2RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM_FLT2RDATAR_RDATA_Msk = 0xffffff00
	// Position of RPEND field.
	DFSDM_DFSDM_FLT2RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM_FLT2RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM_FLT2RDATAR_RPEND = 0x10
	// Position of RDATACH field.
	DFSDM_DFSDM_FLT2RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM_FLT2RDATAR_RDATACH_Msk = 0x7

	// DFSDM_FLT2AWHTR: analog watchdog high threshold register
	// Position of AWHT field.
	DFSDM_DFSDM_FLT2AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM_FLT2AWHTR_AWHT_Msk = 0xffffff00
	// Position of BKAWH field.
	DFSDM_DFSDM_FLT2AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM_FLT2AWHTR_BKAWH_Msk = 0xf

	// DFSDM_FLT2AWLTR: analog watchdog low threshold register
	// Position of AWLT field.
	DFSDM_DFSDM_FLT2AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM_FLT2AWLTR_AWLT_Msk = 0xffffff00
	// Position of BKAWL field.
	DFSDM_DFSDM_FLT2AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM_FLT2AWLTR_BKAWL_Msk = 0xf

	// DFSDM_FLT2AWSR: analog watchdog status register
	// Position of AWHTF field.
	DFSDM_DFSDM_FLT2AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM_FLT2AWSR_AWHTF_Msk = 0xff00
	// Position of AWLTF field.
	DFSDM_DFSDM_FLT2AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM_FLT2AWSR_AWLTF_Msk = 0xff

	// DFSDM_FLT2AWCFR: analog watchdog clear flag register
	// Position of CLRAWHTF field.
	DFSDM_DFSDM_FLT2AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM_FLT2AWCFR_CLRAWHTF_Msk = 0xff00
	// Position of CLRAWLTF field.
	DFSDM_DFSDM_FLT2AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM_FLT2AWCFR_CLRAWLTF_Msk = 0xff

	// DFSDM_FLT2EXMAX: Extremes detector maximum register
	// Position of EXMAX field.
	DFSDM_DFSDM_FLT2EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM_FLT2EXMAX_EXMAX_Msk = 0xffffff00
	// Position of EXMAXCH field.
	DFSDM_DFSDM_FLT2EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM_FLT2EXMAX_EXMAXCH_Msk = 0x7

	// DFSDM_FLT2EXMIN: Extremes detector minimum register
	// Position of EXMIN field.
	DFSDM_DFSDM_FLT2EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM_FLT2EXMIN_EXMIN_Msk = 0xffffff00
	// Position of EXMINCH field.
	DFSDM_DFSDM_FLT2EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM_FLT2EXMIN_EXMINCH_Msk = 0x7

	// DFSDM_FLT2CNVTIMR: conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM_FLT2CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM_FLT2CNVTIMR_CNVCNT_Msk = 0xfffffff0

	// DFSDM_FLT3CR1: control register 1
	// Position of AWFSEL field.
	DFSDM_DFSDM_FLT3CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM_FLT3CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM_FLT3CR1_AWFSEL = 0x40000000
	// Position of FAST field.
	DFSDM_DFSDM_FLT3CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM_FLT3CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM_FLT3CR1_FAST = 0x20000000
	// Position of RCH field.
	DFSDM_DFSDM_FLT3CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM_FLT3CR1_RCH_Msk = 0x7000000
	// Position of RDMAEN field.
	DFSDM_DFSDM_FLT3CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM_FLT3CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM_FLT3CR1_RDMAEN = 0x200000
	// Position of RSYNC field.
	DFSDM_DFSDM_FLT3CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM_FLT3CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM_FLT3CR1_RSYNC = 0x80000
	// Position of RCONT field.
	DFSDM_DFSDM_FLT3CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM_FLT3CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM_FLT3CR1_RCONT = 0x40000
	// Position of RSWSTART field.
	DFSDM_DFSDM_FLT3CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM_FLT3CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM_FLT3CR1_RSWSTART = 0x20000
	// Position of JEXTEN field.
	DFSDM_DFSDM_FLT3CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM_FLT3CR1_JEXTEN_Msk = 0x6000
	// Position of JEXTSEL field.
	DFSDM_DFSDM_FLT3CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM_FLT3CR1_JEXTSEL_Msk = 0x700
	// Position of JDMAEN field.
	DFSDM_DFSDM_FLT3CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM_FLT3CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM_FLT3CR1_JDMAEN = 0x20
	// Position of JSCAN field.
	DFSDM_DFSDM_FLT3CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM_FLT3CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM_FLT3CR1_JSCAN = 0x10
	// Position of JSYNC field.
	DFSDM_DFSDM_FLT3CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM_FLT3CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM_FLT3CR1_JSYNC = 0x8
	// Position of JSWSTART field.
	DFSDM_DFSDM_FLT3CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM_FLT3CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM_FLT3CR1_JSWSTART = 0x2
	// Position of DFEN field.
	DFSDM_DFSDM_FLT3CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM_FLT3CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM_FLT3CR1_DFEN = 0x1

	// DFSDM_FLT3CR2: control register 2
	// Position of AWDCH field.
	DFSDM_DFSDM_FLT3CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM_FLT3CR2_AWDCH_Msk = 0xff0000
	// Position of EXCH field.
	DFSDM_DFSDM_FLT3CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM_FLT3CR2_EXCH_Msk = 0xff00
	// Position of CKABIE field.
	DFSDM_DFSDM_FLT3CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM_FLT3CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM_FLT3CR2_CKABIE = 0x40
	// Position of SCDIE field.
	DFSDM_DFSDM_FLT3CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM_FLT3CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM_FLT3CR2_SCDIE = 0x20
	// Position of AWDIE field.
	DFSDM_DFSDM_FLT3CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM_FLT3CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM_FLT3CR2_AWDIE = 0x10
	// Position of ROVRIE field.
	DFSDM_DFSDM_FLT3CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM_FLT3CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM_FLT3CR2_ROVRIE = 0x8
	// Position of JOVRIE field.
	DFSDM_DFSDM_FLT3CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM_FLT3CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM_FLT3CR2_JOVRIE = 0x4
	// Position of REOCIE field.
	DFSDM_DFSDM_FLT3CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM_FLT3CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM_FLT3CR2_REOCIE = 0x2
	// Position of JEOCIE field.
	DFSDM_DFSDM_FLT3CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM_FLT3CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM_FLT3CR2_JEOCIE = 0x1

	// DFSDM_FLT3ISR: interrupt and status register
	// Position of SCDF field.
	DFSDM_DFSDM_FLT3ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM_FLT3ISR_SCDF_Msk = 0xff000000
	// Position of CKABF field.
	DFSDM_DFSDM_FLT3ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM_FLT3ISR_CKABF_Msk = 0xff0000
	// Position of RCIP field.
	DFSDM_DFSDM_FLT3ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM_FLT3ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM_FLT3ISR_RCIP = 0x4000
	// Position of JCIP field.
	DFSDM_DFSDM_FLT3ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM_FLT3ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM_FLT3ISR_JCIP = 0x2000
	// Position of AWDF field.
	DFSDM_DFSDM_FLT3ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM_FLT3ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM_FLT3ISR_AWDF = 0x10
	// Position of ROVRF field.
	DFSDM_DFSDM_FLT3ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM_FLT3ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM_FLT3ISR_ROVRF = 0x8
	// Position of JOVRF field.
	DFSDM_DFSDM_FLT3ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM_FLT3ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM_FLT3ISR_JOVRF = 0x4
	// Position of REOCF field.
	DFSDM_DFSDM_FLT3ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM_FLT3ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM_FLT3ISR_REOCF = 0x2
	// Position of JEOCF field.
	DFSDM_DFSDM_FLT3ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM_FLT3ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM_FLT3ISR_JEOCF = 0x1

	// DFSDM_FLT3ICR: interrupt flag clear register
	// Position of CLRSCDF field.
	DFSDM_DFSDM_FLT3ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM_FLT3ICR_CLRSCDF_Msk = 0xff000000
	// Position of CLRCKABF field.
	DFSDM_DFSDM_FLT3ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM_FLT3ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRROVRF field.
	DFSDM_DFSDM_FLT3ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM_FLT3ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM_FLT3ICR_CLRROVRF = 0x8
	// Position of CLRJOVRF field.
	DFSDM_DFSDM_FLT3ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM_FLT3ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM_FLT3ICR_CLRJOVRF = 0x4

	// DFSDM_FLT3JCHGR: injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM_FLT3JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM_FLT3JCHGR_JCHG_Msk = 0xff

	// DFSDM_FLT3FCR: filter control register
	// Position of FORD field.
	DFSDM_DFSDM_FLT3FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM_FLT3FCR_FORD_Msk = 0xe0000000
	// Position of FOSR field.
	DFSDM_DFSDM_FLT3FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM_FLT3FCR_FOSR_Msk = 0x3ff0000
	// Position of IOSR field.
	DFSDM_DFSDM_FLT3FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM_FLT3FCR_IOSR_Msk = 0xff

	// DFSDM_FLT3JDATAR: data register for injected group
	// Position of JDATA field.
	DFSDM_DFSDM_FLT3JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM_FLT3JDATAR_JDATA_Msk = 0xffffff00
	// Position of JDATACH field.
	DFSDM_DFSDM_FLT3JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM_FLT3JDATAR_JDATACH_Msk = 0x7

	// DFSDM_FLT3RDATAR: data register for the regular channel
	// Position of RDATA field.
	DFSDM_DFSDM_FLT3RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM_FLT3RDATAR_RDATA_Msk = 0xffffff00
	// Position of RPEND field.
	DFSDM_DFSDM_FLT3RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM_FLT3RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM_FLT3RDATAR_RPEND = 0x10
	// Position of RDATACH field.
	DFSDM_DFSDM_FLT3RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM_FLT3RDATAR_RDATACH_Msk = 0x7

	// DFSDM_FLT3AWHTR: analog watchdog high threshold register
	// Position of AWHT field.
	DFSDM_DFSDM_FLT3AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM_FLT3AWHTR_AWHT_Msk = 0xffffff00
	// Position of BKAWH field.
	DFSDM_DFSDM_FLT3AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM_FLT3AWHTR_BKAWH_Msk = 0xf

	// DFSDM_FLT3AWLTR: analog watchdog low threshold register
	// Position of AWLT field.
	DFSDM_DFSDM_FLT3AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM_FLT3AWLTR_AWLT_Msk = 0xffffff00
	// Position of BKAWL field.
	DFSDM_DFSDM_FLT3AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM_FLT3AWLTR_BKAWL_Msk = 0xf

	// DFSDM_FLT3AWSR: analog watchdog status register
	// Position of AWHTF field.
	DFSDM_DFSDM_FLT3AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM_FLT3AWSR_AWHTF_Msk = 0xff00
	// Position of AWLTF field.
	DFSDM_DFSDM_FLT3AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM_FLT3AWSR_AWLTF_Msk = 0xff

	// DFSDM_FLT3AWCFR: analog watchdog clear flag register
	// Position of CLRAWHTF field.
	DFSDM_DFSDM_FLT3AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM_FLT3AWCFR_CLRAWHTF_Msk = 0xff00
	// Position of CLRAWLTF field.
	DFSDM_DFSDM_FLT3AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM_FLT3AWCFR_CLRAWLTF_Msk = 0xff

	// DFSDM_FLT3EXMAX: Extremes detector maximum register
	// Position of EXMAX field.
	DFSDM_DFSDM_FLT3EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM_FLT3EXMAX_EXMAX_Msk = 0xffffff00
	// Position of EXMAXCH field.
	DFSDM_DFSDM_FLT3EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM_FLT3EXMAX_EXMAXCH_Msk = 0x7

	// DFSDM_FLT3EXMIN: Extremes detector minimum register
	// Position of EXMIN field.
	DFSDM_DFSDM_FLT3EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM_FLT3EXMIN_EXMIN_Msk = 0xffffff00
	// Position of EXMINCH field.
	DFSDM_DFSDM_FLT3EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM_FLT3EXMIN_EXMINCH_Msk = 0x7

	// DFSDM_FLT3CNVTIMR: conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM_FLT3CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM_FLT3CNVTIMR_CNVCNT_Msk = 0xfffffff0
)

// Constants for RNG: Random number generator
const (
	// CR: control register
	// Position of IE field.
	RNG_CR_IE_Pos = 0x3
	// Bit mask of IE field.
	RNG_CR_IE_Msk = 0x8
	// Bit IE.
	RNG_CR_IE = 0x8
	// Position of RNGEN field.
	RNG_CR_RNGEN_Pos = 0x2
	// Bit mask of RNGEN field.
	RNG_CR_RNGEN_Msk = 0x4
	// Bit RNGEN.
	RNG_CR_RNGEN = 0x4

	// SR: status register
	// Position of SEIS field.
	RNG_SR_SEIS_Pos = 0x6
	// Bit mask of SEIS field.
	RNG_SR_SEIS_Msk = 0x40
	// Bit SEIS.
	RNG_SR_SEIS = 0x40
	// Position of CEIS field.
	RNG_SR_CEIS_Pos = 0x5
	// Bit mask of CEIS field.
	RNG_SR_CEIS_Msk = 0x20
	// Bit CEIS.
	RNG_SR_CEIS = 0x20
	// Position of SECS field.
	RNG_SR_SECS_Pos = 0x2
	// Bit mask of SECS field.
	RNG_SR_SECS_Msk = 0x4
	// Bit SECS.
	RNG_SR_SECS = 0x4
	// Position of CECS field.
	RNG_SR_CECS_Pos = 0x1
	// Bit mask of CECS field.
	RNG_SR_CECS_Msk = 0x2
	// Bit CECS.
	RNG_SR_CECS = 0x2
	// Position of DRDY field.
	RNG_SR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	RNG_SR_DRDY_Msk = 0x1
	// Bit DRDY.
	RNG_SR_DRDY = 0x1

	// DR: data register
	// Position of RNDATA field.
	RNG_DR_RNDATA_Pos = 0x0
	// Bit mask of RNDATA field.
	RNG_DR_RNDATA_Msk = 0xffffffff
)

// Constants for AES: Advanced encryption standard hardware accelerator
const (
	// CR: control register
	// Position of DMAOUTEN field.
	AES_CR_DMAOUTEN_Pos = 0xc
	// Bit mask of DMAOUTEN field.
	AES_CR_DMAOUTEN_Msk = 0x1000
	// Bit DMAOUTEN.
	AES_CR_DMAOUTEN = 0x1000
	// Position of DMAINEN field.
	AES_CR_DMAINEN_Pos = 0xb
	// Bit mask of DMAINEN field.
	AES_CR_DMAINEN_Msk = 0x800
	// Bit DMAINEN.
	AES_CR_DMAINEN = 0x800
	// Position of ERRIE field.
	AES_CR_ERRIE_Pos = 0xa
	// Bit mask of ERRIE field.
	AES_CR_ERRIE_Msk = 0x400
	// Bit ERRIE.
	AES_CR_ERRIE = 0x400
	// Position of CCFIE field.
	AES_CR_CCFIE_Pos = 0x9
	// Bit mask of CCFIE field.
	AES_CR_CCFIE_Msk = 0x200
	// Bit CCFIE.
	AES_CR_CCFIE = 0x200
	// Position of ERRC field.
	AES_CR_ERRC_Pos = 0x8
	// Bit mask of ERRC field.
	AES_CR_ERRC_Msk = 0x100
	// Bit ERRC.
	AES_CR_ERRC = 0x100
	// Position of CCFC field.
	AES_CR_CCFC_Pos = 0x7
	// Bit mask of CCFC field.
	AES_CR_CCFC_Msk = 0x80
	// Bit CCFC.
	AES_CR_CCFC = 0x80
	// Position of CHMOD field.
	AES_CR_CHMOD_Pos = 0x5
	// Bit mask of CHMOD field.
	AES_CR_CHMOD_Msk = 0x60
	// Position of MODE field.
	AES_CR_MODE_Pos = 0x3
	// Bit mask of MODE field.
	AES_CR_MODE_Msk = 0x18
	// Position of DATATYPE field.
	AES_CR_DATATYPE_Pos = 0x1
	// Bit mask of DATATYPE field.
	AES_CR_DATATYPE_Msk = 0x6
	// Position of EN field.
	AES_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	AES_CR_EN_Msk = 0x1
	// Bit EN.
	AES_CR_EN = 0x1

	// SR: status register
	// Position of WRERR field.
	AES_SR_WRERR_Pos = 0x2
	// Bit mask of WRERR field.
	AES_SR_WRERR_Msk = 0x4
	// Bit WRERR.
	AES_SR_WRERR = 0x4
	// Position of RDERR field.
	AES_SR_RDERR_Pos = 0x1
	// Bit mask of RDERR field.
	AES_SR_RDERR_Msk = 0x2
	// Bit RDERR.
	AES_SR_RDERR = 0x2
	// Position of CCF field.
	AES_SR_CCF_Pos = 0x0
	// Bit mask of CCF field.
	AES_SR_CCF_Msk = 0x1
	// Bit CCF.
	AES_SR_CCF = 0x1

	// DINR: data input register
	// Position of AES_DINR field.
	AES_DINR_AES_DINR_Pos = 0x0
	// Bit mask of AES_DINR field.
	AES_DINR_AES_DINR_Msk = 0xffffffff

	// DOUTR: data output register
	// Position of AES_DOUTR field.
	AES_DOUTR_AES_DOUTR_Pos = 0x0
	// Bit mask of AES_DOUTR field.
	AES_DOUTR_AES_DOUTR_Msk = 0xffffffff

	// KEYR0: key register 0
	// Position of AES_KEYR0 field.
	AES_KEYR0_AES_KEYR0_Pos = 0x0
	// Bit mask of AES_KEYR0 field.
	AES_KEYR0_AES_KEYR0_Msk = 0xffffffff

	// KEYR1: key register 1
	// Position of AES_KEYR1 field.
	AES_KEYR1_AES_KEYR1_Pos = 0x0
	// Bit mask of AES_KEYR1 field.
	AES_KEYR1_AES_KEYR1_Msk = 0xffffffff

	// KEYR2: key register 2
	// Position of AES_KEYR2 field.
	AES_KEYR2_AES_KEYR2_Pos = 0x0
	// Bit mask of AES_KEYR2 field.
	AES_KEYR2_AES_KEYR2_Msk = 0xffffffff

	// KEYR3: key register 3
	// Position of AES_KEYR3 field.
	AES_KEYR3_AES_KEYR3_Pos = 0x0
	// Bit mask of AES_KEYR3 field.
	AES_KEYR3_AES_KEYR3_Msk = 0xffffffff

	// IVR0: initialization vector register 0
	// Position of AES_IVR0 field.
	AES_IVR0_AES_IVR0_Pos = 0x0
	// Bit mask of AES_IVR0 field.
	AES_IVR0_AES_IVR0_Msk = 0xffffffff

	// IVR1: initialization vector register 1
	// Position of AES_IVR1 field.
	AES_IVR1_AES_IVR1_Pos = 0x0
	// Bit mask of AES_IVR1 field.
	AES_IVR1_AES_IVR1_Msk = 0xffffffff

	// IVR2: initialization vector register 2
	// Position of AES_IVR2 field.
	AES_IVR2_AES_IVR2_Pos = 0x0
	// Bit mask of AES_IVR2 field.
	AES_IVR2_AES_IVR2_Msk = 0xffffffff

	// IVR3: initialization vector register 3
	// Position of AES_IVR3 field.
	AES_IVR3_AES_IVR3_Pos = 0x0
	// Bit mask of AES_IVR3 field.
	AES_IVR3_AES_IVR3_Msk = 0xffffffff
)

// Constants for ADC: Analog-to-Digital Converter
const (
	// ISR: interrupt and status register
	// Position of JQOVF field.
	ADC_ISR_JQOVF_Pos = 0xa
	// Bit mask of JQOVF field.
	ADC_ISR_JQOVF_Msk = 0x400
	// Bit JQOVF.
	ADC_ISR_JQOVF = 0x400
	// Position of AWD3 field.
	ADC_ISR_AWD3_Pos = 0x9
	// Bit mask of AWD3 field.
	ADC_ISR_AWD3_Msk = 0x200
	// Bit AWD3.
	ADC_ISR_AWD3 = 0x200
	// Position of AWD2 field.
	ADC_ISR_AWD2_Pos = 0x8
	// Bit mask of AWD2 field.
	ADC_ISR_AWD2_Msk = 0x100
	// Bit AWD2.
	ADC_ISR_AWD2 = 0x100
	// Position of AWD1 field.
	ADC_ISR_AWD1_Pos = 0x7
	// Bit mask of AWD1 field.
	ADC_ISR_AWD1_Msk = 0x80
	// Bit AWD1.
	ADC_ISR_AWD1 = 0x80
	// Position of JEOS field.
	ADC_ISR_JEOS_Pos = 0x6
	// Bit mask of JEOS field.
	ADC_ISR_JEOS_Msk = 0x40
	// Bit JEOS.
	ADC_ISR_JEOS = 0x40
	// Position of JEOC field.
	ADC_ISR_JEOC_Pos = 0x5
	// Bit mask of JEOC field.
	ADC_ISR_JEOC_Msk = 0x20
	// Bit JEOC.
	ADC_ISR_JEOC = 0x20
	// Position of OVR field.
	ADC_ISR_OVR_Pos = 0x4
	// Bit mask of OVR field.
	ADC_ISR_OVR_Msk = 0x10
	// Bit OVR.
	ADC_ISR_OVR = 0x10
	// Position of EOS field.
	ADC_ISR_EOS_Pos = 0x3
	// Bit mask of EOS field.
	ADC_ISR_EOS_Msk = 0x8
	// Bit EOS.
	ADC_ISR_EOS = 0x8
	// Position of EOC field.
	ADC_ISR_EOC_Pos = 0x2
	// Bit mask of EOC field.
	ADC_ISR_EOC_Msk = 0x4
	// Bit EOC.
	ADC_ISR_EOC = 0x4
	// Position of EOSMP field.
	ADC_ISR_EOSMP_Pos = 0x1
	// Bit mask of EOSMP field.
	ADC_ISR_EOSMP_Msk = 0x2
	// Bit EOSMP.
	ADC_ISR_EOSMP = 0x2
	// Position of ADRDY field.
	ADC_ISR_ADRDY_Pos = 0x0
	// Bit mask of ADRDY field.
	ADC_ISR_ADRDY_Msk = 0x1
	// Bit ADRDY.
	ADC_ISR_ADRDY = 0x1

	// IER: interrupt enable register
	// Position of JQOVFIE field.
	ADC_IER_JQOVFIE_Pos = 0xa
	// Bit mask of JQOVFIE field.
	ADC_IER_JQOVFIE_Msk = 0x400
	// Bit JQOVFIE.
	ADC_IER_JQOVFIE = 0x400
	// Position of AWD3IE field.
	ADC_IER_AWD3IE_Pos = 0x9
	// Bit mask of AWD3IE field.
	ADC_IER_AWD3IE_Msk = 0x200
	// Bit AWD3IE.
	ADC_IER_AWD3IE = 0x200
	// Position of AWD2IE field.
	ADC_IER_AWD2IE_Pos = 0x8
	// Bit mask of AWD2IE field.
	ADC_IER_AWD2IE_Msk = 0x100
	// Bit AWD2IE.
	ADC_IER_AWD2IE = 0x100
	// Position of AWD1IE field.
	ADC_IER_AWD1IE_Pos = 0x7
	// Bit mask of AWD1IE field.
	ADC_IER_AWD1IE_Msk = 0x80
	// Bit AWD1IE.
	ADC_IER_AWD1IE = 0x80
	// Position of JEOSIE field.
	ADC_IER_JEOSIE_Pos = 0x6
	// Bit mask of JEOSIE field.
	ADC_IER_JEOSIE_Msk = 0x40
	// Bit JEOSIE.
	ADC_IER_JEOSIE = 0x40
	// Position of JEOCIE field.
	ADC_IER_JEOCIE_Pos = 0x5
	// Bit mask of JEOCIE field.
	ADC_IER_JEOCIE_Msk = 0x20
	// Bit JEOCIE.
	ADC_IER_JEOCIE = 0x20
	// Position of OVRIE field.
	ADC_IER_OVRIE_Pos = 0x4
	// Bit mask of OVRIE field.
	ADC_IER_OVRIE_Msk = 0x10
	// Bit OVRIE.
	ADC_IER_OVRIE = 0x10
	// Position of EOSIE field.
	ADC_IER_EOSIE_Pos = 0x3
	// Bit mask of EOSIE field.
	ADC_IER_EOSIE_Msk = 0x8
	// Bit EOSIE.
	ADC_IER_EOSIE = 0x8
	// Position of EOCIE field.
	ADC_IER_EOCIE_Pos = 0x2
	// Bit mask of EOCIE field.
	ADC_IER_EOCIE_Msk = 0x4
	// Bit EOCIE.
	ADC_IER_EOCIE = 0x4
	// Position of EOSMPIE field.
	ADC_IER_EOSMPIE_Pos = 0x1
	// Bit mask of EOSMPIE field.
	ADC_IER_EOSMPIE_Msk = 0x2
	// Bit EOSMPIE.
	ADC_IER_EOSMPIE = 0x2
	// Position of ADRDYIE field.
	ADC_IER_ADRDYIE_Pos = 0x0
	// Bit mask of ADRDYIE field.
	ADC_IER_ADRDYIE_Msk = 0x1
	// Bit ADRDYIE.
	ADC_IER_ADRDYIE = 0x1

	// CR: control register
	// Position of ADCAL field.
	ADC_CR_ADCAL_Pos = 0x1f
	// Bit mask of ADCAL field.
	ADC_CR_ADCAL_Msk = 0x80000000
	// Bit ADCAL.
	ADC_CR_ADCAL = 0x80000000
	// Position of ADCALDIF field.
	ADC_CR_ADCALDIF_Pos = 0x1e
	// Bit mask of ADCALDIF field.
	ADC_CR_ADCALDIF_Msk = 0x40000000
	// Bit ADCALDIF.
	ADC_CR_ADCALDIF = 0x40000000
	// Position of DEEPPWD field.
	ADC_CR_DEEPPWD_Pos = 0x1d
	// Bit mask of DEEPPWD field.
	ADC_CR_DEEPPWD_Msk = 0x20000000
	// Bit DEEPPWD.
	ADC_CR_DEEPPWD = 0x20000000
	// Position of ADVREGEN field.
	ADC_CR_ADVREGEN_Pos = 0x1c
	// Bit mask of ADVREGEN field.
	ADC_CR_ADVREGEN_Msk = 0x10000000
	// Bit ADVREGEN.
	ADC_CR_ADVREGEN = 0x10000000
	// Position of JADSTP field.
	ADC_CR_JADSTP_Pos = 0x5
	// Bit mask of JADSTP field.
	ADC_CR_JADSTP_Msk = 0x20
	// Bit JADSTP.
	ADC_CR_JADSTP = 0x20
	// Position of ADSTP field.
	ADC_CR_ADSTP_Pos = 0x4
	// Bit mask of ADSTP field.
	ADC_CR_ADSTP_Msk = 0x10
	// Bit ADSTP.
	ADC_CR_ADSTP = 0x10
	// Position of JADSTART field.
	ADC_CR_JADSTART_Pos = 0x3
	// Bit mask of JADSTART field.
	ADC_CR_JADSTART_Msk = 0x8
	// Bit JADSTART.
	ADC_CR_JADSTART = 0x8
	// Position of ADSTART field.
	ADC_CR_ADSTART_Pos = 0x2
	// Bit mask of ADSTART field.
	ADC_CR_ADSTART_Msk = 0x4
	// Bit ADSTART.
	ADC_CR_ADSTART = 0x4
	// Position of ADDIS field.
	ADC_CR_ADDIS_Pos = 0x1
	// Bit mask of ADDIS field.
	ADC_CR_ADDIS_Msk = 0x2
	// Bit ADDIS.
	ADC_CR_ADDIS = 0x2
	// Position of ADEN field.
	ADC_CR_ADEN_Pos = 0x0
	// Bit mask of ADEN field.
	ADC_CR_ADEN_Msk = 0x1
	// Bit ADEN.
	ADC_CR_ADEN = 0x1

	// CFGR: configuration register
	// Position of AWDCH1CH field.
	ADC_CFGR_AWDCH1CH_Pos = 0x1a
	// Bit mask of AWDCH1CH field.
	ADC_CFGR_AWDCH1CH_Msk = 0x7c000000
	// Position of JAUTO field.
	ADC_CFGR_JAUTO_Pos = 0x19
	// Bit mask of JAUTO field.
	ADC_CFGR_JAUTO_Msk = 0x2000000
	// Bit JAUTO.
	ADC_CFGR_JAUTO = 0x2000000
	// Position of JAWD1EN field.
	ADC_CFGR_JAWD1EN_Pos = 0x18
	// Bit mask of JAWD1EN field.
	ADC_CFGR_JAWD1EN_Msk = 0x1000000
	// Bit JAWD1EN.
	ADC_CFGR_JAWD1EN = 0x1000000
	// Position of AWD1EN field.
	ADC_CFGR_AWD1EN_Pos = 0x17
	// Bit mask of AWD1EN field.
	ADC_CFGR_AWD1EN_Msk = 0x800000
	// Bit AWD1EN.
	ADC_CFGR_AWD1EN = 0x800000
	// Position of AWD1SGL field.
	ADC_CFGR_AWD1SGL_Pos = 0x16
	// Bit mask of AWD1SGL field.
	ADC_CFGR_AWD1SGL_Msk = 0x400000
	// Bit AWD1SGL.
	ADC_CFGR_AWD1SGL = 0x400000
	// Position of JQM field.
	ADC_CFGR_JQM_Pos = 0x15
	// Bit mask of JQM field.
	ADC_CFGR_JQM_Msk = 0x200000
	// Bit JQM.
	ADC_CFGR_JQM = 0x200000
	// Position of JDISCEN field.
	ADC_CFGR_JDISCEN_Pos = 0x14
	// Bit mask of JDISCEN field.
	ADC_CFGR_JDISCEN_Msk = 0x100000
	// Bit JDISCEN.
	ADC_CFGR_JDISCEN = 0x100000
	// Position of DISCNUM field.
	ADC_CFGR_DISCNUM_Pos = 0x11
	// Bit mask of DISCNUM field.
	ADC_CFGR_DISCNUM_Msk = 0xe0000
	// Position of DISCEN field.
	ADC_CFGR_DISCEN_Pos = 0x10
	// Bit mask of DISCEN field.
	ADC_CFGR_DISCEN_Msk = 0x10000
	// Bit DISCEN.
	ADC_CFGR_DISCEN = 0x10000
	// Position of AUTDLY field.
	ADC_CFGR_AUTDLY_Pos = 0xe
	// Bit mask of AUTDLY field.
	ADC_CFGR_AUTDLY_Msk = 0x4000
	// Bit AUTDLY.
	ADC_CFGR_AUTDLY = 0x4000
	// Position of CONT field.
	ADC_CFGR_CONT_Pos = 0xd
	// Bit mask of CONT field.
	ADC_CFGR_CONT_Msk = 0x2000
	// Bit CONT.
	ADC_CFGR_CONT = 0x2000
	// Position of OVRMOD field.
	ADC_CFGR_OVRMOD_Pos = 0xc
	// Bit mask of OVRMOD field.
	ADC_CFGR_OVRMOD_Msk = 0x1000
	// Bit OVRMOD.
	ADC_CFGR_OVRMOD = 0x1000
	// Position of EXTEN field.
	ADC_CFGR_EXTEN_Pos = 0xa
	// Bit mask of EXTEN field.
	ADC_CFGR_EXTEN_Msk = 0xc00
	// Position of EXTSEL field.
	ADC_CFGR_EXTSEL_Pos = 0x6
	// Bit mask of EXTSEL field.
	ADC_CFGR_EXTSEL_Msk = 0x3c0
	// Position of ALIGN field.
	ADC_CFGR_ALIGN_Pos = 0x5
	// Bit mask of ALIGN field.
	ADC_CFGR_ALIGN_Msk = 0x20
	// Bit ALIGN.
	ADC_CFGR_ALIGN = 0x20
	// Position of RES field.
	ADC_CFGR_RES_Pos = 0x3
	// Bit mask of RES field.
	ADC_CFGR_RES_Msk = 0x18
	// Position of DMACFG field.
	ADC_CFGR_DMACFG_Pos = 0x1
	// Bit mask of DMACFG field.
	ADC_CFGR_DMACFG_Msk = 0x2
	// Bit DMACFG.
	ADC_CFGR_DMACFG = 0x2
	// Position of DMAEN field.
	ADC_CFGR_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	ADC_CFGR_DMAEN_Msk = 0x1
	// Bit DMAEN.
	ADC_CFGR_DMAEN = 0x1
	// Position of JQDIS field.
	ADC_CFGR_JQDIS_Pos = 0x1f
	// Bit mask of JQDIS field.
	ADC_CFGR_JQDIS_Msk = 0x80000000
	// Bit JQDIS.
	ADC_CFGR_JQDIS = 0x80000000

	// CFGR2: configuration register
	// Position of ROVSM field.
	ADC_CFGR2_ROVSM_Pos = 0xa
	// Bit mask of ROVSM field.
	ADC_CFGR2_ROVSM_Msk = 0x400
	// Bit ROVSM.
	ADC_CFGR2_ROVSM = 0x400
	// Position of TROVS field.
	ADC_CFGR2_TROVS_Pos = 0x9
	// Bit mask of TROVS field.
	ADC_CFGR2_TROVS_Msk = 0x200
	// Bit TROVS.
	ADC_CFGR2_TROVS = 0x200
	// Position of OVSS field.
	ADC_CFGR2_OVSS_Pos = 0x5
	// Bit mask of OVSS field.
	ADC_CFGR2_OVSS_Msk = 0x1e0
	// Position of OVSR field.
	ADC_CFGR2_OVSR_Pos = 0x2
	// Bit mask of OVSR field.
	ADC_CFGR2_OVSR_Msk = 0x1c
	// Position of JOVSE field.
	ADC_CFGR2_JOVSE_Pos = 0x1
	// Bit mask of JOVSE field.
	ADC_CFGR2_JOVSE_Msk = 0x2
	// Bit JOVSE.
	ADC_CFGR2_JOVSE = 0x2
	// Position of ROVSE field.
	ADC_CFGR2_ROVSE_Pos = 0x0
	// Bit mask of ROVSE field.
	ADC_CFGR2_ROVSE_Msk = 0x1
	// Bit ROVSE.
	ADC_CFGR2_ROVSE = 0x1

	// SMPR1: sample time register 1
	// Position of SMP9 field.
	ADC_SMPR1_SMP9_Pos = 0x1b
	// Bit mask of SMP9 field.
	ADC_SMPR1_SMP9_Msk = 0x38000000
	// Position of SMP8 field.
	ADC_SMPR1_SMP8_Pos = 0x18
	// Bit mask of SMP8 field.
	ADC_SMPR1_SMP8_Msk = 0x7000000
	// Position of SMP7 field.
	ADC_SMPR1_SMP7_Pos = 0x15
	// Bit mask of SMP7 field.
	ADC_SMPR1_SMP7_Msk = 0xe00000
	// Position of SMP6 field.
	ADC_SMPR1_SMP6_Pos = 0x12
	// Bit mask of SMP6 field.
	ADC_SMPR1_SMP6_Msk = 0x1c0000
	// Position of SMP5 field.
	ADC_SMPR1_SMP5_Pos = 0xf
	// Bit mask of SMP5 field.
	ADC_SMPR1_SMP5_Msk = 0x38000
	// Position of SMP4 field.
	ADC_SMPR1_SMP4_Pos = 0xc
	// Bit mask of SMP4 field.
	ADC_SMPR1_SMP4_Msk = 0x7000
	// Position of SMP3 field.
	ADC_SMPR1_SMP3_Pos = 0x9
	// Bit mask of SMP3 field.
	ADC_SMPR1_SMP3_Msk = 0xe00
	// Position of SMP2 field.
	ADC_SMPR1_SMP2_Pos = 0x6
	// Bit mask of SMP2 field.
	ADC_SMPR1_SMP2_Msk = 0x1c0
	// Position of SMP1 field.
	ADC_SMPR1_SMP1_Pos = 0x3
	// Bit mask of SMP1 field.
	ADC_SMPR1_SMP1_Msk = 0x38
	// Position of SMPPLUS field.
	ADC_SMPR1_SMPPLUS_Pos = 0x1f
	// Bit mask of SMPPLUS field.
	ADC_SMPR1_SMPPLUS_Msk = 0x80000000
	// Bit SMPPLUS.
	ADC_SMPR1_SMPPLUS = 0x80000000
	// Position of SMP0 field.
	ADC_SMPR1_SMP0_Pos = 0x0
	// Bit mask of SMP0 field.
	ADC_SMPR1_SMP0_Msk = 0x7

	// SMPR2: sample time register 2
	// Position of SMP18 field.
	ADC_SMPR2_SMP18_Pos = 0x18
	// Bit mask of SMP18 field.
	ADC_SMPR2_SMP18_Msk = 0x7000000
	// Position of SMP17 field.
	ADC_SMPR2_SMP17_Pos = 0x15
	// Bit mask of SMP17 field.
	ADC_SMPR2_SMP17_Msk = 0xe00000
	// Position of SMP16 field.
	ADC_SMPR2_SMP16_Pos = 0x12
	// Bit mask of SMP16 field.
	ADC_SMPR2_SMP16_Msk = 0x1c0000
	// Position of SMP15 field.
	ADC_SMPR2_SMP15_Pos = 0xf
	// Bit mask of SMP15 field.
	ADC_SMPR2_SMP15_Msk = 0x38000
	// Position of SMP14 field.
	ADC_SMPR2_SMP14_Pos = 0xc
	// Bit mask of SMP14 field.
	ADC_SMPR2_SMP14_Msk = 0x7000
	// Position of SMP13 field.
	ADC_SMPR2_SMP13_Pos = 0x9
	// Bit mask of SMP13 field.
	ADC_SMPR2_SMP13_Msk = 0xe00
	// Position of SMP12 field.
	ADC_SMPR2_SMP12_Pos = 0x6
	// Bit mask of SMP12 field.
	ADC_SMPR2_SMP12_Msk = 0x1c0
	// Position of SMP11 field.
	ADC_SMPR2_SMP11_Pos = 0x3
	// Bit mask of SMP11 field.
	ADC_SMPR2_SMP11_Msk = 0x38
	// Position of SMP10 field.
	ADC_SMPR2_SMP10_Pos = 0x0
	// Bit mask of SMP10 field.
	ADC_SMPR2_SMP10_Msk = 0x7

	// TR1: watchdog threshold register 1
	// Position of HT1 field.
	ADC_TR1_HT1_Pos = 0x10
	// Bit mask of HT1 field.
	ADC_TR1_HT1_Msk = 0xfff0000
	// Position of LT1 field.
	ADC_TR1_LT1_Pos = 0x0
	// Bit mask of LT1 field.
	ADC_TR1_LT1_Msk = 0xfff

	// TR2: watchdog threshold register
	// Position of HT2 field.
	ADC_TR2_HT2_Pos = 0x10
	// Bit mask of HT2 field.
	ADC_TR2_HT2_Msk = 0xff0000
	// Position of LT2 field.
	ADC_TR2_LT2_Pos = 0x0
	// Bit mask of LT2 field.
	ADC_TR2_LT2_Msk = 0xff

	// TR3: watchdog threshold register 3
	// Position of HT3 field.
	ADC_TR3_HT3_Pos = 0x10
	// Bit mask of HT3 field.
	ADC_TR3_HT3_Msk = 0xff0000
	// Position of LT3 field.
	ADC_TR3_LT3_Pos = 0x0
	// Bit mask of LT3 field.
	ADC_TR3_LT3_Msk = 0xff

	// SQR1: regular sequence register 1
	// Position of SQ4 field.
	ADC_SQR1_SQ4_Pos = 0x18
	// Bit mask of SQ4 field.
	ADC_SQR1_SQ4_Msk = 0x1f000000
	// Position of SQ3 field.
	ADC_SQR1_SQ3_Pos = 0x12
	// Bit mask of SQ3 field.
	ADC_SQR1_SQ3_Msk = 0x7c0000
	// Position of SQ2 field.
	ADC_SQR1_SQ2_Pos = 0xc
	// Bit mask of SQ2 field.
	ADC_SQR1_SQ2_Msk = 0x1f000
	// Position of SQ1 field.
	ADC_SQR1_SQ1_Pos = 0x6
	// Bit mask of SQ1 field.
	ADC_SQR1_SQ1_Msk = 0x7c0
	// Position of L field.
	ADC_SQR1_L_Pos = 0x0
	// Bit mask of L field.
	ADC_SQR1_L_Msk = 0xf

	// SQR2: regular sequence register 2
	// Position of SQ9 field.
	ADC_SQR2_SQ9_Pos = 0x18
	// Bit mask of SQ9 field.
	ADC_SQR2_SQ9_Msk = 0x1f000000
	// Position of SQ8 field.
	ADC_SQR2_SQ8_Pos = 0x12
	// Bit mask of SQ8 field.
	ADC_SQR2_SQ8_Msk = 0x7c0000
	// Position of SQ7 field.
	ADC_SQR2_SQ7_Pos = 0xc
	// Bit mask of SQ7 field.
	ADC_SQR2_SQ7_Msk = 0x1f000
	// Position of SQ6 field.
	ADC_SQR2_SQ6_Pos = 0x6
	// Bit mask of SQ6 field.
	ADC_SQR2_SQ6_Msk = 0x7c0
	// Position of SQ5 field.
	ADC_SQR2_SQ5_Pos = 0x0
	// Bit mask of SQ5 field.
	ADC_SQR2_SQ5_Msk = 0x1f

	// SQR3: regular sequence register 3
	// Position of SQ14 field.
	ADC_SQR3_SQ14_Pos = 0x18
	// Bit mask of SQ14 field.
	ADC_SQR3_SQ14_Msk = 0x1f000000
	// Position of SQ13 field.
	ADC_SQR3_SQ13_Pos = 0x12
	// Bit mask of SQ13 field.
	ADC_SQR3_SQ13_Msk = 0x7c0000
	// Position of SQ12 field.
	ADC_SQR3_SQ12_Pos = 0xc
	// Bit mask of SQ12 field.
	ADC_SQR3_SQ12_Msk = 0x1f000
	// Position of SQ11 field.
	ADC_SQR3_SQ11_Pos = 0x6
	// Bit mask of SQ11 field.
	ADC_SQR3_SQ11_Msk = 0x7c0
	// Position of SQ10 field.
	ADC_SQR3_SQ10_Pos = 0x0
	// Bit mask of SQ10 field.
	ADC_SQR3_SQ10_Msk = 0x1f

	// SQR4: regular sequence register 4
	// Position of SQ16 field.
	ADC_SQR4_SQ16_Pos = 0x6
	// Bit mask of SQ16 field.
	ADC_SQR4_SQ16_Msk = 0x7c0
	// Position of SQ15 field.
	ADC_SQR4_SQ15_Pos = 0x0
	// Bit mask of SQ15 field.
	ADC_SQR4_SQ15_Msk = 0x1f

	// DR: regular Data Register
	// Position of RDATA field.
	ADC_DR_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	ADC_DR_RDATA_Msk = 0xffff

	// JSQR: injected sequence register
	// Position of JSQ4 field.
	ADC_JSQR_JSQ4_Pos = 0x1a
	// Bit mask of JSQ4 field.
	ADC_JSQR_JSQ4_Msk = 0x7c000000
	// Position of JSQ3 field.
	ADC_JSQR_JSQ3_Pos = 0x14
	// Bit mask of JSQ3 field.
	ADC_JSQR_JSQ3_Msk = 0x1f00000
	// Position of JSQ2 field.
	ADC_JSQR_JSQ2_Pos = 0xe
	// Bit mask of JSQ2 field.
	ADC_JSQR_JSQ2_Msk = 0x7c000
	// Position of JSQ1 field.
	ADC_JSQR_JSQ1_Pos = 0x8
	// Bit mask of JSQ1 field.
	ADC_JSQR_JSQ1_Msk = 0x1f00
	// Position of JEXTEN field.
	ADC_JSQR_JEXTEN_Pos = 0x6
	// Bit mask of JEXTEN field.
	ADC_JSQR_JEXTEN_Msk = 0xc0
	// Position of JEXTSEL field.
	ADC_JSQR_JEXTSEL_Pos = 0x2
	// Bit mask of JEXTSEL field.
	ADC_JSQR_JEXTSEL_Msk = 0x3c
	// Position of JL field.
	ADC_JSQR_JL_Pos = 0x0
	// Bit mask of JL field.
	ADC_JSQR_JL_Msk = 0x3

	// OFR1: offset register 1
	// Position of OFFSET1_EN field.
	ADC_OFR1_OFFSET1_EN_Pos = 0x1f
	// Bit mask of OFFSET1_EN field.
	ADC_OFR1_OFFSET1_EN_Msk = 0x80000000
	// Bit OFFSET1_EN.
	ADC_OFR1_OFFSET1_EN = 0x80000000
	// Position of OFFSET1_CH field.
	ADC_OFR1_OFFSET1_CH_Pos = 0x1a
	// Bit mask of OFFSET1_CH field.
	ADC_OFR1_OFFSET1_CH_Msk = 0x7c000000
	// Position of OFFSET1 field.
	ADC_OFR1_OFFSET1_Pos = 0x0
	// Bit mask of OFFSET1 field.
	ADC_OFR1_OFFSET1_Msk = 0xfff

	// OFR2: offset register 2
	// Position of OFFSET2_EN field.
	ADC_OFR2_OFFSET2_EN_Pos = 0x1f
	// Bit mask of OFFSET2_EN field.
	ADC_OFR2_OFFSET2_EN_Msk = 0x80000000
	// Bit OFFSET2_EN.
	ADC_OFR2_OFFSET2_EN = 0x80000000
	// Position of OFFSET2_CH field.
	ADC_OFR2_OFFSET2_CH_Pos = 0x1a
	// Bit mask of OFFSET2_CH field.
	ADC_OFR2_OFFSET2_CH_Msk = 0x7c000000
	// Position of OFFSET2 field.
	ADC_OFR2_OFFSET2_Pos = 0x0
	// Bit mask of OFFSET2 field.
	ADC_OFR2_OFFSET2_Msk = 0xfff

	// OFR3: offset register 3
	// Position of OFFSET3_EN field.
	ADC_OFR3_OFFSET3_EN_Pos = 0x1f
	// Bit mask of OFFSET3_EN field.
	ADC_OFR3_OFFSET3_EN_Msk = 0x80000000
	// Bit OFFSET3_EN.
	ADC_OFR3_OFFSET3_EN = 0x80000000
	// Position of OFFSET3_CH field.
	ADC_OFR3_OFFSET3_CH_Pos = 0x1a
	// Bit mask of OFFSET3_CH field.
	ADC_OFR3_OFFSET3_CH_Msk = 0x7c000000
	// Position of OFFSET3 field.
	ADC_OFR3_OFFSET3_Pos = 0x0
	// Bit mask of OFFSET3 field.
	ADC_OFR3_OFFSET3_Msk = 0xfff

	// OFR4: offset register 4
	// Position of OFFSET4_EN field.
	ADC_OFR4_OFFSET4_EN_Pos = 0x1f
	// Bit mask of OFFSET4_EN field.
	ADC_OFR4_OFFSET4_EN_Msk = 0x80000000
	// Bit OFFSET4_EN.
	ADC_OFR4_OFFSET4_EN = 0x80000000
	// Position of OFFSET4_CH field.
	ADC_OFR4_OFFSET4_CH_Pos = 0x1a
	// Bit mask of OFFSET4_CH field.
	ADC_OFR4_OFFSET4_CH_Msk = 0x7c000000
	// Position of OFFSET4 field.
	ADC_OFR4_OFFSET4_Pos = 0x0
	// Bit mask of OFFSET4 field.
	ADC_OFR4_OFFSET4_Msk = 0xfff

	// JDR1: injected data register 1
	// Position of JDATA1 field.
	ADC_JDR1_JDATA1_Pos = 0x0
	// Bit mask of JDATA1 field.
	ADC_JDR1_JDATA1_Msk = 0xffff

	// JDR2: injected data register 2
	// Position of JDATA2 field.
	ADC_JDR2_JDATA2_Pos = 0x0
	// Bit mask of JDATA2 field.
	ADC_JDR2_JDATA2_Msk = 0xffff

	// JDR3: injected data register 3
	// Position of JDATA3 field.
	ADC_JDR3_JDATA3_Pos = 0x0
	// Bit mask of JDATA3 field.
	ADC_JDR3_JDATA3_Msk = 0xffff

	// JDR4: injected data register 4
	// Position of JDATA4 field.
	ADC_JDR4_JDATA4_Pos = 0x0
	// Bit mask of JDATA4 field.
	ADC_JDR4_JDATA4_Msk = 0xffff

	// AWD2CR: Analog Watchdog 2 Configuration Register
	// Position of AWD2CH field.
	ADC_AWD2CR_AWD2CH_Pos = 0x0
	// Bit mask of AWD2CH field.
	ADC_AWD2CR_AWD2CH_Msk = 0x3ffff

	// AWD3CR: Analog Watchdog 3 Configuration Register
	// Position of AWD3CH field.
	ADC_AWD3CR_AWD3CH_Pos = 0x0
	// Bit mask of AWD3CH field.
	ADC_AWD3CR_AWD3CH_Msk = 0x3ffff

	// DIFSEL: Differential Mode Selection Register 2
	// Position of DIFSEL_1_15 field.
	ADC_DIFSEL_DIFSEL_1_15_Pos = 0x1
	// Bit mask of DIFSEL_1_15 field.
	ADC_DIFSEL_DIFSEL_1_15_Msk = 0xfffe
	// Position of DIFSEL_16_18 field.
	ADC_DIFSEL_DIFSEL_16_18_Pos = 0x10
	// Bit mask of DIFSEL_16_18 field.
	ADC_DIFSEL_DIFSEL_16_18_Msk = 0x70000

	// CALFACT: Calibration Factors
	// Position of CALFACT_D field.
	ADC_CALFACT_CALFACT_D_Pos = 0x10
	// Bit mask of CALFACT_D field.
	ADC_CALFACT_CALFACT_D_Msk = 0x7f0000
	// Position of CALFACT_S field.
	ADC_CALFACT_CALFACT_S_Pos = 0x0
	// Bit mask of CALFACT_S field.
	ADC_CALFACT_CALFACT_S_Msk = 0x7f
)

// Constants for GPIOA: General-purpose I/Os
const (
	// MODER: GPIO port mode register
	// Position of MODER15 field.
	GPIO_MODER_MODER15_Pos = 0x1e
	// Bit mask of MODER15 field.
	GPIO_MODER_MODER15_Msk = 0xc0000000
	// Input mode (reset state)
	GPIO_MODER_MODER15_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER15_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER15_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER15_Analog = 0x3
	// Position of MODER14 field.
	GPIO_MODER_MODER14_Pos = 0x1c
	// Bit mask of MODER14 field.
	GPIO_MODER_MODER14_Msk = 0x30000000
	// Input mode (reset state)
	GPIO_MODER_MODER14_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER14_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER14_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER14_Analog = 0x3
	// Position of MODER13 field.
	GPIO_MODER_MODER13_Pos = 0x1a
	// Bit mask of MODER13 field.
	GPIO_MODER_MODER13_Msk = 0xc000000
	// Input mode (reset state)
	GPIO_MODER_MODER13_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER13_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER13_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER13_Analog = 0x3
	// Position of MODER12 field.
	GPIO_MODER_MODER12_Pos = 0x18
	// Bit mask of MODER12 field.
	GPIO_MODER_MODER12_Msk = 0x3000000
	// Input mode (reset state)
	GPIO_MODER_MODER12_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER12_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER12_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER12_Analog = 0x3
	// Position of MODER11 field.
	GPIO_MODER_MODER11_Pos = 0x16
	// Bit mask of MODER11 field.
	GPIO_MODER_MODER11_Msk = 0xc00000
	// Input mode (reset state)
	GPIO_MODER_MODER11_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER11_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER11_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER11_Analog = 0x3
	// Position of MODER10 field.
	GPIO_MODER_MODER10_Pos = 0x14
	// Bit mask of MODER10 field.
	GPIO_MODER_MODER10_Msk = 0x300000
	// Input mode (reset state)
	GPIO_MODER_MODER10_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER10_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER10_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER10_Analog = 0x3
	// Position of MODER9 field.
	GPIO_MODER_MODER9_Pos = 0x12
	// Bit mask of MODER9 field.
	GPIO_MODER_MODER9_Msk = 0xc0000
	// Input mode (reset state)
	GPIO_MODER_MODER9_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER9_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER9_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER9_Analog = 0x3
	// Position of MODER8 field.
	GPIO_MODER_MODER8_Pos = 0x10
	// Bit mask of MODER8 field.
	GPIO_MODER_MODER8_Msk = 0x30000
	// Input mode (reset state)
	GPIO_MODER_MODER8_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER8_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER8_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER8_Analog = 0x3
	// Position of MODER7 field.
	GPIO_MODER_MODER7_Pos = 0xe
	// Bit mask of MODER7 field.
	GPIO_MODER_MODER7_Msk = 0xc000
	// Input mode (reset state)
	GPIO_MODER_MODER7_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER7_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER7_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER7_Analog = 0x3
	// Position of MODER6 field.
	GPIO_MODER_MODER6_Pos = 0xc
	// Bit mask of MODER6 field.
	GPIO_MODER_MODER6_Msk = 0x3000
	// Input mode (reset state)
	GPIO_MODER_MODER6_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER6_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER6_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER6_Analog = 0x3
	// Position of MODER5 field.
	GPIO_MODER_MODER5_Pos = 0xa
	// Bit mask of MODER5 field.
	GPIO_MODER_MODER5_Msk = 0xc00
	// Input mode (reset state)
	GPIO_MODER_MODER5_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER5_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER5_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER5_Analog = 0x3
	// Position of MODER4 field.
	GPIO_MODER_MODER4_Pos = 0x8
	// Bit mask of MODER4 field.
	GPIO_MODER_MODER4_Msk = 0x300
	// Input mode (reset state)
	GPIO_MODER_MODER4_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER4_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER4_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER4_Analog = 0x3
	// Position of MODER3 field.
	GPIO_MODER_MODER3_Pos = 0x6
	// Bit mask of MODER3 field.
	GPIO_MODER_MODER3_Msk = 0xc0
	// Input mode (reset state)
	GPIO_MODER_MODER3_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER3_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER3_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER3_Analog = 0x3
	// Position of MODER2 field.
	GPIO_MODER_MODER2_Pos = 0x4
	// Bit mask of MODER2 field.
	GPIO_MODER_MODER2_Msk = 0x30
	// Input mode (reset state)
	GPIO_MODER_MODER2_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER2_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER2_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER2_Analog = 0x3
	// Position of MODER1 field.
	GPIO_MODER_MODER1_Pos = 0x2
	// Bit mask of MODER1 field.
	GPIO_MODER_MODER1_Msk = 0xc
	// Input mode (reset state)
	GPIO_MODER_MODER1_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER1_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER1_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER1_Analog = 0x3
	// Position of MODER0 field.
	GPIO_MODER_MODER0_Pos = 0x0
	// Bit mask of MODER0 field.
	GPIO_MODER_MODER0_Msk = 0x3
	// Input mode (reset state)
	GPIO_MODER_MODER0_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER0_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER0_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER0_Analog = 0x3

	// OTYPER: GPIO port output type register
	// Position of OT15 field.
	GPIO_OTYPER_OT15_Pos = 0xf
	// Bit mask of OT15 field.
	GPIO_OTYPER_OT15_Msk = 0x8000
	// Bit OT15.
	GPIO_OTYPER_OT15 = 0x8000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT15_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT15_OpenDrain = 0x1
	// Position of OT14 field.
	GPIO_OTYPER_OT14_Pos = 0xe
	// Bit mask of OT14 field.
	GPIO_OTYPER_OT14_Msk = 0x4000
	// Bit OT14.
	GPIO_OTYPER_OT14 = 0x4000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT14_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT14_OpenDrain = 0x1
	// Position of OT13 field.
	GPIO_OTYPER_OT13_Pos = 0xd
	// Bit mask of OT13 field.
	GPIO_OTYPER_OT13_Msk = 0x2000
	// Bit OT13.
	GPIO_OTYPER_OT13 = 0x2000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT13_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT13_OpenDrain = 0x1
	// Position of OT12 field.
	GPIO_OTYPER_OT12_Pos = 0xc
	// Bit mask of OT12 field.
	GPIO_OTYPER_OT12_Msk = 0x1000
	// Bit OT12.
	GPIO_OTYPER_OT12 = 0x1000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT12_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT12_OpenDrain = 0x1
	// Position of OT11 field.
	GPIO_OTYPER_OT11_Pos = 0xb
	// Bit mask of OT11 field.
	GPIO_OTYPER_OT11_Msk = 0x800
	// Bit OT11.
	GPIO_OTYPER_OT11 = 0x800
	// Output push-pull (reset state)
	GPIO_OTYPER_OT11_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT11_OpenDrain = 0x1
	// Position of OT10 field.
	GPIO_OTYPER_OT10_Pos = 0xa
	// Bit mask of OT10 field.
	GPIO_OTYPER_OT10_Msk = 0x400
	// Bit OT10.
	GPIO_OTYPER_OT10 = 0x400
	// Output push-pull (reset state)
	GPIO_OTYPER_OT10_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT10_OpenDrain = 0x1
	// Position of OT9 field.
	GPIO_OTYPER_OT9_Pos = 0x9
	// Bit mask of OT9 field.
	GPIO_OTYPER_OT9_Msk = 0x200
	// Bit OT9.
	GPIO_OTYPER_OT9 = 0x200
	// Output push-pull (reset state)
	GPIO_OTYPER_OT9_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT9_OpenDrain = 0x1
	// Position of OT8 field.
	GPIO_OTYPER_OT8_Pos = 0x8
	// Bit mask of OT8 field.
	GPIO_OTYPER_OT8_Msk = 0x100
	// Bit OT8.
	GPIO_OTYPER_OT8 = 0x100
	// Output push-pull (reset state)
	GPIO_OTYPER_OT8_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT8_OpenDrain = 0x1
	// Position of OT7 field.
	GPIO_OTYPER_OT7_Pos = 0x7
	// Bit mask of OT7 field.
	GPIO_OTYPER_OT7_Msk = 0x80
	// Bit OT7.
	GPIO_OTYPER_OT7 = 0x80
	// Output push-pull (reset state)
	GPIO_OTYPER_OT7_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT7_OpenDrain = 0x1
	// Position of OT6 field.
	GPIO_OTYPER_OT6_Pos = 0x6
	// Bit mask of OT6 field.
	GPIO_OTYPER_OT6_Msk = 0x40
	// Bit OT6.
	GPIO_OTYPER_OT6 = 0x40
	// Output push-pull (reset state)
	GPIO_OTYPER_OT6_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT6_OpenDrain = 0x1
	// Position of OT5 field.
	GPIO_OTYPER_OT5_Pos = 0x5
	// Bit mask of OT5 field.
	GPIO_OTYPER_OT5_Msk = 0x20
	// Bit OT5.
	GPIO_OTYPER_OT5 = 0x20
	// Output push-pull (reset state)
	GPIO_OTYPER_OT5_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT5_OpenDrain = 0x1
	// Position of OT4 field.
	GPIO_OTYPER_OT4_Pos = 0x4
	// Bit mask of OT4 field.
	GPIO_OTYPER_OT4_Msk = 0x10
	// Bit OT4.
	GPIO_OTYPER_OT4 = 0x10
	// Output push-pull (reset state)
	GPIO_OTYPER_OT4_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT4_OpenDrain = 0x1
	// Position of OT3 field.
	GPIO_OTYPER_OT3_Pos = 0x3
	// Bit mask of OT3 field.
	GPIO_OTYPER_OT3_Msk = 0x8
	// Bit OT3.
	GPIO_OTYPER_OT3 = 0x8
	// Output push-pull (reset state)
	GPIO_OTYPER_OT3_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT3_OpenDrain = 0x1
	// Position of OT2 field.
	GPIO_OTYPER_OT2_Pos = 0x2
	// Bit mask of OT2 field.
	GPIO_OTYPER_OT2_Msk = 0x4
	// Bit OT2.
	GPIO_OTYPER_OT2 = 0x4
	// Output push-pull (reset state)
	GPIO_OTYPER_OT2_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT2_OpenDrain = 0x1
	// Position of OT1 field.
	GPIO_OTYPER_OT1_Pos = 0x1
	// Bit mask of OT1 field.
	GPIO_OTYPER_OT1_Msk = 0x2
	// Bit OT1.
	GPIO_OTYPER_OT1 = 0x2
	// Output push-pull (reset state)
	GPIO_OTYPER_OT1_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT1_OpenDrain = 0x1
	// Position of OT0 field.
	GPIO_OTYPER_OT0_Pos = 0x0
	// Bit mask of OT0 field.
	GPIO_OTYPER_OT0_Msk = 0x1
	// Bit OT0.
	GPIO_OTYPER_OT0 = 0x1
	// Output push-pull (reset state)
	GPIO_OTYPER_OT0_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT0_OpenDrain = 0x1

	// OSPEEDR: GPIO port output speed register
	// Position of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Pos = 0x1e
	// Bit mask of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Msk = 0xc0000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR15_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR15_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR15_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR15_VeryHighSpeed = 0x3
	// Position of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Pos = 0x1c
	// Bit mask of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Msk = 0x30000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR14_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR14_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR14_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR14_VeryHighSpeed = 0x3
	// Position of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Pos = 0x1a
	// Bit mask of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Msk = 0xc000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR13_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR13_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR13_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR13_VeryHighSpeed = 0x3
	// Position of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Pos = 0x18
	// Bit mask of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Msk = 0x3000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR12_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR12_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR12_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR12_VeryHighSpeed = 0x3
	// Position of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Pos = 0x16
	// Bit mask of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Msk = 0xc00000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR11_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR11_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR11_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR11_VeryHighSpeed = 0x3
	// Position of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Pos = 0x14
	// Bit mask of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Msk = 0x300000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR10_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR10_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR10_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR10_VeryHighSpeed = 0x3
	// Position of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Pos = 0x12
	// Bit mask of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Msk = 0xc0000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR9_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR9_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR9_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR9_VeryHighSpeed = 0x3
	// Position of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Pos = 0x10
	// Bit mask of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Msk = 0x30000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR8_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR8_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR8_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR8_VeryHighSpeed = 0x3
	// Position of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Pos = 0xe
	// Bit mask of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Msk = 0xc000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR7_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR7_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR7_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR7_VeryHighSpeed = 0x3
	// Position of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Pos = 0xc
	// Bit mask of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Msk = 0x3000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR6_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR6_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR6_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR6_VeryHighSpeed = 0x3
	// Position of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Pos = 0xa
	// Bit mask of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Msk = 0xc00
	// Low speed
	GPIO_OSPEEDR_OSPEEDR5_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR5_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR5_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR5_VeryHighSpeed = 0x3
	// Position of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Pos = 0x8
	// Bit mask of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Msk = 0x300
	// Low speed
	GPIO_OSPEEDR_OSPEEDR4_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR4_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR4_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR4_VeryHighSpeed = 0x3
	// Position of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Pos = 0x6
	// Bit mask of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Msk = 0xc0
	// Low speed
	GPIO_OSPEEDR_OSPEEDR3_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR3_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR3_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR3_VeryHighSpeed = 0x3
	// Position of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Pos = 0x4
	// Bit mask of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Msk = 0x30
	// Low speed
	GPIO_OSPEEDR_OSPEEDR2_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR2_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR2_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR2_VeryHighSpeed = 0x3
	// Position of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Pos = 0x2
	// Bit mask of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Msk = 0xc
	// Low speed
	GPIO_OSPEEDR_OSPEEDR1_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR1_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR1_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR1_VeryHighSpeed = 0x3
	// Position of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Pos = 0x0
	// Bit mask of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Msk = 0x3
	// Low speed
	GPIO_OSPEEDR_OSPEEDR0_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR0_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR0_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR0_VeryHighSpeed = 0x3

	// PUPDR: GPIO port pull-up/pull-down register
	// Position of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Pos = 0x1e
	// Bit mask of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Msk = 0xc0000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR15_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR15_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR15_PullDown = 0x2
	// Position of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Pos = 0x1c
	// Bit mask of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Msk = 0x30000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR14_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR14_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR14_PullDown = 0x2
	// Position of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Pos = 0x1a
	// Bit mask of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Msk = 0xc000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR13_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR13_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR13_PullDown = 0x2
	// Position of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Pos = 0x18
	// Bit mask of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Msk = 0x3000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR12_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR12_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR12_PullDown = 0x2
	// Position of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Pos = 0x16
	// Bit mask of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Msk = 0xc00000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR11_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR11_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR11_PullDown = 0x2
	// Position of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Pos = 0x14
	// Bit mask of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Msk = 0x300000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR10_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR10_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR10_PullDown = 0x2
	// Position of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Pos = 0x12
	// Bit mask of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Msk = 0xc0000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR9_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR9_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR9_PullDown = 0x2
	// Position of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Pos = 0x10
	// Bit mask of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Msk = 0x30000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR8_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR8_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR8_PullDown = 0x2
	// Position of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Pos = 0xe
	// Bit mask of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Msk = 0xc000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR7_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR7_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR7_PullDown = 0x2
	// Position of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Pos = 0xc
	// Bit mask of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Msk = 0x3000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR6_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR6_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR6_PullDown = 0x2
	// Position of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Pos = 0xa
	// Bit mask of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Msk = 0xc00
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR5_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR5_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR5_PullDown = 0x2
	// Position of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Pos = 0x8
	// Bit mask of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Msk = 0x300
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR4_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR4_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR4_PullDown = 0x2
	// Position of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Pos = 0x6
	// Bit mask of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Msk = 0xc0
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR3_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR3_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR3_PullDown = 0x2
	// Position of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Pos = 0x4
	// Bit mask of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Msk = 0x30
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR2_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR2_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR2_PullDown = 0x2
	// Position of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Pos = 0x2
	// Bit mask of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Msk = 0xc
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR1_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR1_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR1_PullDown = 0x2
	// Position of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Pos = 0x0
	// Bit mask of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Msk = 0x3
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR0_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR0_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR0_PullDown = 0x2

	// IDR: GPIO port input data register
	// Position of IDR15 field.
	GPIO_IDR_IDR15_Pos = 0xf
	// Bit mask of IDR15 field.
	GPIO_IDR_IDR15_Msk = 0x8000
	// Bit IDR15.
	GPIO_IDR_IDR15 = 0x8000
	// Input is logic high
	GPIO_IDR_IDR15_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR15_Low = 0x0
	// Position of IDR14 field.
	GPIO_IDR_IDR14_Pos = 0xe
	// Bit mask of IDR14 field.
	GPIO_IDR_IDR14_Msk = 0x4000
	// Bit IDR14.
	GPIO_IDR_IDR14 = 0x4000
	// Input is logic high
	GPIO_IDR_IDR14_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR14_Low = 0x0
	// Position of IDR13 field.
	GPIO_IDR_IDR13_Pos = 0xd
	// Bit mask of IDR13 field.
	GPIO_IDR_IDR13_Msk = 0x2000
	// Bit IDR13.
	GPIO_IDR_IDR13 = 0x2000
	// Input is logic high
	GPIO_IDR_IDR13_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR13_Low = 0x0
	// Position of IDR12 field.
	GPIO_IDR_IDR12_Pos = 0xc
	// Bit mask of IDR12 field.
	GPIO_IDR_IDR12_Msk = 0x1000
	// Bit IDR12.
	GPIO_IDR_IDR12 = 0x1000
	// Input is logic high
	GPIO_IDR_IDR12_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR12_Low = 0x0
	// Position of IDR11 field.
	GPIO_IDR_IDR11_Pos = 0xb
	// Bit mask of IDR11 field.
	GPIO_IDR_IDR11_Msk = 0x800
	// Bit IDR11.
	GPIO_IDR_IDR11 = 0x800
	// Input is logic high
	GPIO_IDR_IDR11_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR11_Low = 0x0
	// Position of IDR10 field.
	GPIO_IDR_IDR10_Pos = 0xa
	// Bit mask of IDR10 field.
	GPIO_IDR_IDR10_Msk = 0x400
	// Bit IDR10.
	GPIO_IDR_IDR10 = 0x400
	// Input is logic high
	GPIO_IDR_IDR10_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR10_Low = 0x0
	// Position of IDR9 field.
	GPIO_IDR_IDR9_Pos = 0x9
	// Bit mask of IDR9 field.
	GPIO_IDR_IDR9_Msk = 0x200
	// Bit IDR9.
	GPIO_IDR_IDR9 = 0x200
	// Input is logic high
	GPIO_IDR_IDR9_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR9_Low = 0x0
	// Position of IDR8 field.
	GPIO_IDR_IDR8_Pos = 0x8
	// Bit mask of IDR8 field.
	GPIO_IDR_IDR8_Msk = 0x100
	// Bit IDR8.
	GPIO_IDR_IDR8 = 0x100
	// Input is logic high
	GPIO_IDR_IDR8_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR8_Low = 0x0
	// Position of IDR7 field.
	GPIO_IDR_IDR7_Pos = 0x7
	// Bit mask of IDR7 field.
	GPIO_IDR_IDR7_Msk = 0x80
	// Bit IDR7.
	GPIO_IDR_IDR7 = 0x80
	// Input is logic high
	GPIO_IDR_IDR7_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR7_Low = 0x0
	// Position of IDR6 field.
	GPIO_IDR_IDR6_Pos = 0x6
	// Bit mask of IDR6 field.
	GPIO_IDR_IDR6_Msk = 0x40
	// Bit IDR6.
	GPIO_IDR_IDR6 = 0x40
	// Input is logic high
	GPIO_IDR_IDR6_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR6_Low = 0x0
	// Position of IDR5 field.
	GPIO_IDR_IDR5_Pos = 0x5
	// Bit mask of IDR5 field.
	GPIO_IDR_IDR5_Msk = 0x20
	// Bit IDR5.
	GPIO_IDR_IDR5 = 0x20
	// Input is logic high
	GPIO_IDR_IDR5_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR5_Low = 0x0
	// Position of IDR4 field.
	GPIO_IDR_IDR4_Pos = 0x4
	// Bit mask of IDR4 field.
	GPIO_IDR_IDR4_Msk = 0x10
	// Bit IDR4.
	GPIO_IDR_IDR4 = 0x10
	// Input is logic high
	GPIO_IDR_IDR4_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR4_Low = 0x0
	// Position of IDR3 field.
	GPIO_IDR_IDR3_Pos = 0x3
	// Bit mask of IDR3 field.
	GPIO_IDR_IDR3_Msk = 0x8
	// Bit IDR3.
	GPIO_IDR_IDR3 = 0x8
	// Input is logic high
	GPIO_IDR_IDR3_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR3_Low = 0x0
	// Position of IDR2 field.
	GPIO_IDR_IDR2_Pos = 0x2
	// Bit mask of IDR2 field.
	GPIO_IDR_IDR2_Msk = 0x4
	// Bit IDR2.
	GPIO_IDR_IDR2 = 0x4
	// Input is logic high
	GPIO_IDR_IDR2_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR2_Low = 0x0
	// Position of IDR1 field.
	GPIO_IDR_IDR1_Pos = 0x1
	// Bit mask of IDR1 field.
	GPIO_IDR_IDR1_Msk = 0x2
	// Bit IDR1.
	GPIO_IDR_IDR1 = 0x2
	// Input is logic high
	GPIO_IDR_IDR1_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR1_Low = 0x0
	// Position of IDR0 field.
	GPIO_IDR_IDR0_Pos = 0x0
	// Bit mask of IDR0 field.
	GPIO_IDR_IDR0_Msk = 0x1
	// Bit IDR0.
	GPIO_IDR_IDR0 = 0x1
	// Input is logic high
	GPIO_IDR_IDR0_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR0_Low = 0x0

	// ODR: GPIO port output data register
	// Position of ODR15 field.
	GPIO_ODR_ODR15_Pos = 0xf
	// Bit mask of ODR15 field.
	GPIO_ODR_ODR15_Msk = 0x8000
	// Bit ODR15.
	GPIO_ODR_ODR15 = 0x8000
	// Set output to logic high
	GPIO_ODR_ODR15_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR15_Low = 0x0
	// Position of ODR14 field.
	GPIO_ODR_ODR14_Pos = 0xe
	// Bit mask of ODR14 field.
	GPIO_ODR_ODR14_Msk = 0x4000
	// Bit ODR14.
	GPIO_ODR_ODR14 = 0x4000
	// Set output to logic high
	GPIO_ODR_ODR14_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR14_Low = 0x0
	// Position of ODR13 field.
	GPIO_ODR_ODR13_Pos = 0xd
	// Bit mask of ODR13 field.
	GPIO_ODR_ODR13_Msk = 0x2000
	// Bit ODR13.
	GPIO_ODR_ODR13 = 0x2000
	// Set output to logic high
	GPIO_ODR_ODR13_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR13_Low = 0x0
	// Position of ODR12 field.
	GPIO_ODR_ODR12_Pos = 0xc
	// Bit mask of ODR12 field.
	GPIO_ODR_ODR12_Msk = 0x1000
	// Bit ODR12.
	GPIO_ODR_ODR12 = 0x1000
	// Set output to logic high
	GPIO_ODR_ODR12_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR12_Low = 0x0
	// Position of ODR11 field.
	GPIO_ODR_ODR11_Pos = 0xb
	// Bit mask of ODR11 field.
	GPIO_ODR_ODR11_Msk = 0x800
	// Bit ODR11.
	GPIO_ODR_ODR11 = 0x800
	// Set output to logic high
	GPIO_ODR_ODR11_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR11_Low = 0x0
	// Position of ODR10 field.
	GPIO_ODR_ODR10_Pos = 0xa
	// Bit mask of ODR10 field.
	GPIO_ODR_ODR10_Msk = 0x400
	// Bit ODR10.
	GPIO_ODR_ODR10 = 0x400
	// Set output to logic high
	GPIO_ODR_ODR10_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR10_Low = 0x0
	// Position of ODR9 field.
	GPIO_ODR_ODR9_Pos = 0x9
	// Bit mask of ODR9 field.
	GPIO_ODR_ODR9_Msk = 0x200
	// Bit ODR9.
	GPIO_ODR_ODR9 = 0x200
	// Set output to logic high
	GPIO_ODR_ODR9_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR9_Low = 0x0
	// Position of ODR8 field.
	GPIO_ODR_ODR8_Pos = 0x8
	// Bit mask of ODR8 field.
	GPIO_ODR_ODR8_Msk = 0x100
	// Bit ODR8.
	GPIO_ODR_ODR8 = 0x100
	// Set output to logic high
	GPIO_ODR_ODR8_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR8_Low = 0x0
	// Position of ODR7 field.
	GPIO_ODR_ODR7_Pos = 0x7
	// Bit mask of ODR7 field.
	GPIO_ODR_ODR7_Msk = 0x80
	// Bit ODR7.
	GPIO_ODR_ODR7 = 0x80
	// Set output to logic high
	GPIO_ODR_ODR7_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR7_Low = 0x0
	// Position of ODR6 field.
	GPIO_ODR_ODR6_Pos = 0x6
	// Bit mask of ODR6 field.
	GPIO_ODR_ODR6_Msk = 0x40
	// Bit ODR6.
	GPIO_ODR_ODR6 = 0x40
	// Set output to logic high
	GPIO_ODR_ODR6_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR6_Low = 0x0
	// Position of ODR5 field.
	GPIO_ODR_ODR5_Pos = 0x5
	// Bit mask of ODR5 field.
	GPIO_ODR_ODR5_Msk = 0x20
	// Bit ODR5.
	GPIO_ODR_ODR5 = 0x20
	// Set output to logic high
	GPIO_ODR_ODR5_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR5_Low = 0x0
	// Position of ODR4 field.
	GPIO_ODR_ODR4_Pos = 0x4
	// Bit mask of ODR4 field.
	GPIO_ODR_ODR4_Msk = 0x10
	// Bit ODR4.
	GPIO_ODR_ODR4 = 0x10
	// Set output to logic high
	GPIO_ODR_ODR4_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR4_Low = 0x0
	// Position of ODR3 field.
	GPIO_ODR_ODR3_Pos = 0x3
	// Bit mask of ODR3 field.
	GPIO_ODR_ODR3_Msk = 0x8
	// Bit ODR3.
	GPIO_ODR_ODR3 = 0x8
	// Set output to logic high
	GPIO_ODR_ODR3_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR3_Low = 0x0
	// Position of ODR2 field.
	GPIO_ODR_ODR2_Pos = 0x2
	// Bit mask of ODR2 field.
	GPIO_ODR_ODR2_Msk = 0x4
	// Bit ODR2.
	GPIO_ODR_ODR2 = 0x4
	// Set output to logic high
	GPIO_ODR_ODR2_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR2_Low = 0x0
	// Position of ODR1 field.
	GPIO_ODR_ODR1_Pos = 0x1
	// Bit mask of ODR1 field.
	GPIO_ODR_ODR1_Msk = 0x2
	// Bit ODR1.
	GPIO_ODR_ODR1 = 0x2
	// Set output to logic high
	GPIO_ODR_ODR1_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR1_Low = 0x0
	// Position of ODR0 field.
	GPIO_ODR_ODR0_Pos = 0x0
	// Bit mask of ODR0 field.
	GPIO_ODR_ODR0_Msk = 0x1
	// Bit ODR0.
	GPIO_ODR_ODR0 = 0x1
	// Set output to logic high
	GPIO_ODR_ODR0_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR0_Low = 0x0

	// BSRR: GPIO port bit set/reset register
	// Position of BR15 field.
	GPIO_BSRR_BR15_Pos = 0x1f
	// Bit mask of BR15 field.
	GPIO_BSRR_BR15_Msk = 0x80000000
	// Bit BR15.
	GPIO_BSRR_BR15 = 0x80000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR15_Reset = 0x1
	// Position of BR14 field.
	GPIO_BSRR_BR14_Pos = 0x1e
	// Bit mask of BR14 field.
	GPIO_BSRR_BR14_Msk = 0x40000000
	// Bit BR14.
	GPIO_BSRR_BR14 = 0x40000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR14_Reset = 0x1
	// Position of BR13 field.
	GPIO_BSRR_BR13_Pos = 0x1d
	// Bit mask of BR13 field.
	GPIO_BSRR_BR13_Msk = 0x20000000
	// Bit BR13.
	GPIO_BSRR_BR13 = 0x20000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR13_Reset = 0x1
	// Position of BR12 field.
	GPIO_BSRR_BR12_Pos = 0x1c
	// Bit mask of BR12 field.
	GPIO_BSRR_BR12_Msk = 0x10000000
	// Bit BR12.
	GPIO_BSRR_BR12 = 0x10000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR12_Reset = 0x1
	// Position of BR11 field.
	GPIO_BSRR_BR11_Pos = 0x1b
	// Bit mask of BR11 field.
	GPIO_BSRR_BR11_Msk = 0x8000000
	// Bit BR11.
	GPIO_BSRR_BR11 = 0x8000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR11_Reset = 0x1
	// Position of BR10 field.
	GPIO_BSRR_BR10_Pos = 0x1a
	// Bit mask of BR10 field.
	GPIO_BSRR_BR10_Msk = 0x4000000
	// Bit BR10.
	GPIO_BSRR_BR10 = 0x4000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR10_Reset = 0x1
	// Position of BR9 field.
	GPIO_BSRR_BR9_Pos = 0x19
	// Bit mask of BR9 field.
	GPIO_BSRR_BR9_Msk = 0x2000000
	// Bit BR9.
	GPIO_BSRR_BR9 = 0x2000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR9_Reset = 0x1
	// Position of BR8 field.
	GPIO_BSRR_BR8_Pos = 0x18
	// Bit mask of BR8 field.
	GPIO_BSRR_BR8_Msk = 0x1000000
	// Bit BR8.
	GPIO_BSRR_BR8 = 0x1000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR8_Reset = 0x1
	// Position of BR7 field.
	GPIO_BSRR_BR7_Pos = 0x17
	// Bit mask of BR7 field.
	GPIO_BSRR_BR7_Msk = 0x800000
	// Bit BR7.
	GPIO_BSRR_BR7 = 0x800000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR7_Reset = 0x1
	// Position of BR6 field.
	GPIO_BSRR_BR6_Pos = 0x16
	// Bit mask of BR6 field.
	GPIO_BSRR_BR6_Msk = 0x400000
	// Bit BR6.
	GPIO_BSRR_BR6 = 0x400000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR6_Reset = 0x1
	// Position of BR5 field.
	GPIO_BSRR_BR5_Pos = 0x15
	// Bit mask of BR5 field.
	GPIO_BSRR_BR5_Msk = 0x200000
	// Bit BR5.
	GPIO_BSRR_BR5 = 0x200000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR5_Reset = 0x1
	// Position of BR4 field.
	GPIO_BSRR_BR4_Pos = 0x14
	// Bit mask of BR4 field.
	GPIO_BSRR_BR4_Msk = 0x100000
	// Bit BR4.
	GPIO_BSRR_BR4 = 0x100000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR4_Reset = 0x1
	// Position of BR3 field.
	GPIO_BSRR_BR3_Pos = 0x13
	// Bit mask of BR3 field.
	GPIO_BSRR_BR3_Msk = 0x80000
	// Bit BR3.
	GPIO_BSRR_BR3 = 0x80000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR3_Reset = 0x1
	// Position of BR2 field.
	GPIO_BSRR_BR2_Pos = 0x12
	// Bit mask of BR2 field.
	GPIO_BSRR_BR2_Msk = 0x40000
	// Bit BR2.
	GPIO_BSRR_BR2 = 0x40000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR2_Reset = 0x1
	// Position of BR1 field.
	GPIO_BSRR_BR1_Pos = 0x11
	// Bit mask of BR1 field.
	GPIO_BSRR_BR1_Msk = 0x20000
	// Bit BR1.
	GPIO_BSRR_BR1 = 0x20000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR1_Reset = 0x1
	// Position of BR0 field.
	GPIO_BSRR_BR0_Pos = 0x10
	// Bit mask of BR0 field.
	GPIO_BSRR_BR0_Msk = 0x10000
	// Bit BR0.
	GPIO_BSRR_BR0 = 0x10000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR0_Reset = 0x1
	// Position of BS15 field.
	GPIO_BSRR_BS15_Pos = 0xf
	// Bit mask of BS15 field.
	GPIO_BSRR_BS15_Msk = 0x8000
	// Bit BS15.
	GPIO_BSRR_BS15 = 0x8000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS15_Set = 0x1
	// Position of BS14 field.
	GPIO_BSRR_BS14_Pos = 0xe
	// Bit mask of BS14 field.
	GPIO_BSRR_BS14_Msk = 0x4000
	// Bit BS14.
	GPIO_BSRR_BS14 = 0x4000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS14_Set = 0x1
	// Position of BS13 field.
	GPIO_BSRR_BS13_Pos = 0xd
	// Bit mask of BS13 field.
	GPIO_BSRR_BS13_Msk = 0x2000
	// Bit BS13.
	GPIO_BSRR_BS13 = 0x2000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS13_Set = 0x1
	// Position of BS12 field.
	GPIO_BSRR_BS12_Pos = 0xc
	// Bit mask of BS12 field.
	GPIO_BSRR_BS12_Msk = 0x1000
	// Bit BS12.
	GPIO_BSRR_BS12 = 0x1000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS12_Set = 0x1
	// Position of BS11 field.
	GPIO_BSRR_BS11_Pos = 0xb
	// Bit mask of BS11 field.
	GPIO_BSRR_BS11_Msk = 0x800
	// Bit BS11.
	GPIO_BSRR_BS11 = 0x800
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS11_Set = 0x1
	// Position of BS10 field.
	GPIO_BSRR_BS10_Pos = 0xa
	// Bit mask of BS10 field.
	GPIO_BSRR_BS10_Msk = 0x400
	// Bit BS10.
	GPIO_BSRR_BS10 = 0x400
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS10_Set = 0x1
	// Position of BS9 field.
	GPIO_BSRR_BS9_Pos = 0x9
	// Bit mask of BS9 field.
	GPIO_BSRR_BS9_Msk = 0x200
	// Bit BS9.
	GPIO_BSRR_BS9 = 0x200
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS9_Set = 0x1
	// Position of BS8 field.
	GPIO_BSRR_BS8_Pos = 0x8
	// Bit mask of BS8 field.
	GPIO_BSRR_BS8_Msk = 0x100
	// Bit BS8.
	GPIO_BSRR_BS8 = 0x100
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS8_Set = 0x1
	// Position of BS7 field.
	GPIO_BSRR_BS7_Pos = 0x7
	// Bit mask of BS7 field.
	GPIO_BSRR_BS7_Msk = 0x80
	// Bit BS7.
	GPIO_BSRR_BS7 = 0x80
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS7_Set = 0x1
	// Position of BS6 field.
	GPIO_BSRR_BS6_Pos = 0x6
	// Bit mask of BS6 field.
	GPIO_BSRR_BS6_Msk = 0x40
	// Bit BS6.
	GPIO_BSRR_BS6 = 0x40
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS6_Set = 0x1
	// Position of BS5 field.
	GPIO_BSRR_BS5_Pos = 0x5
	// Bit mask of BS5 field.
	GPIO_BSRR_BS5_Msk = 0x20
	// Bit BS5.
	GPIO_BSRR_BS5 = 0x20
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS5_Set = 0x1
	// Position of BS4 field.
	GPIO_BSRR_BS4_Pos = 0x4
	// Bit mask of BS4 field.
	GPIO_BSRR_BS4_Msk = 0x10
	// Bit BS4.
	GPIO_BSRR_BS4 = 0x10
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS4_Set = 0x1
	// Position of BS3 field.
	GPIO_BSRR_BS3_Pos = 0x3
	// Bit mask of BS3 field.
	GPIO_BSRR_BS3_Msk = 0x8
	// Bit BS3.
	GPIO_BSRR_BS3 = 0x8
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS3_Set = 0x1
	// Position of BS2 field.
	GPIO_BSRR_BS2_Pos = 0x2
	// Bit mask of BS2 field.
	GPIO_BSRR_BS2_Msk = 0x4
	// Bit BS2.
	GPIO_BSRR_BS2 = 0x4
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS2_Set = 0x1
	// Position of BS1 field.
	GPIO_BSRR_BS1_Pos = 0x1
	// Bit mask of BS1 field.
	GPIO_BSRR_BS1_Msk = 0x2
	// Bit BS1.
	GPIO_BSRR_BS1 = 0x2
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS1_Set = 0x1
	// Position of BS0 field.
	GPIO_BSRR_BS0_Pos = 0x0
	// Bit mask of BS0 field.
	GPIO_BSRR_BS0_Msk = 0x1
	// Bit BS0.
	GPIO_BSRR_BS0 = 0x1
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS0_Set = 0x1

	// LCKR: GPIO port configuration lock register
	// Position of LCKK field.
	GPIO_LCKR_LCKK_Pos = 0x10
	// Bit mask of LCKK field.
	GPIO_LCKR_LCKK_Msk = 0x10000
	// Bit LCKK.
	GPIO_LCKR_LCKK = 0x10000
	// Port configuration lock key not active
	GPIO_LCKR_LCKK_NotActive = 0x0
	// Port configuration lock key active
	GPIO_LCKR_LCKK_Active = 0x1
	// Position of LCK15 field.
	GPIO_LCKR_LCK15_Pos = 0xf
	// Bit mask of LCK15 field.
	GPIO_LCKR_LCK15_Msk = 0x8000
	// Bit LCK15.
	GPIO_LCKR_LCK15 = 0x8000
	// Port configuration not locked
	GPIO_LCKR_LCK15_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK15_Locked = 0x1
	// Position of LCK14 field.
	GPIO_LCKR_LCK14_Pos = 0xe
	// Bit mask of LCK14 field.
	GPIO_LCKR_LCK14_Msk = 0x4000
	// Bit LCK14.
	GPIO_LCKR_LCK14 = 0x4000
	// Port configuration not locked
	GPIO_LCKR_LCK14_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK14_Locked = 0x1
	// Position of LCK13 field.
	GPIO_LCKR_LCK13_Pos = 0xd
	// Bit mask of LCK13 field.
	GPIO_LCKR_LCK13_Msk = 0x2000
	// Bit LCK13.
	GPIO_LCKR_LCK13 = 0x2000
	// Port configuration not locked
	GPIO_LCKR_LCK13_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK13_Locked = 0x1
	// Position of LCK12 field.
	GPIO_LCKR_LCK12_Pos = 0xc
	// Bit mask of LCK12 field.
	GPIO_LCKR_LCK12_Msk = 0x1000
	// Bit LCK12.
	GPIO_LCKR_LCK12 = 0x1000
	// Port configuration not locked
	GPIO_LCKR_LCK12_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK12_Locked = 0x1
	// Position of LCK11 field.
	GPIO_LCKR_LCK11_Pos = 0xb
	// Bit mask of LCK11 field.
	GPIO_LCKR_LCK11_Msk = 0x800
	// Bit LCK11.
	GPIO_LCKR_LCK11 = 0x800
	// Port configuration not locked
	GPIO_LCKR_LCK11_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK11_Locked = 0x1
	// Position of LCK10 field.
	GPIO_LCKR_LCK10_Pos = 0xa
	// Bit mask of LCK10 field.
	GPIO_LCKR_LCK10_Msk = 0x400
	// Bit LCK10.
	GPIO_LCKR_LCK10 = 0x400
	// Port configuration not locked
	GPIO_LCKR_LCK10_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK10_Locked = 0x1
	// Position of LCK9 field.
	GPIO_LCKR_LCK9_Pos = 0x9
	// Bit mask of LCK9 field.
	GPIO_LCKR_LCK9_Msk = 0x200
	// Bit LCK9.
	GPIO_LCKR_LCK9 = 0x200
	// Port configuration not locked
	GPIO_LCKR_LCK9_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK9_Locked = 0x1
	// Position of LCK8 field.
	GPIO_LCKR_LCK8_Pos = 0x8
	// Bit mask of LCK8 field.
	GPIO_LCKR_LCK8_Msk = 0x100
	// Bit LCK8.
	GPIO_LCKR_LCK8 = 0x100
	// Port configuration not locked
	GPIO_LCKR_LCK8_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK8_Locked = 0x1
	// Position of LCK7 field.
	GPIO_LCKR_LCK7_Pos = 0x7
	// Bit mask of LCK7 field.
	GPIO_LCKR_LCK7_Msk = 0x80
	// Bit LCK7.
	GPIO_LCKR_LCK7 = 0x80
	// Port configuration not locked
	GPIO_LCKR_LCK7_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK7_Locked = 0x1
	// Position of LCK6 field.
	GPIO_LCKR_LCK6_Pos = 0x6
	// Bit mask of LCK6 field.
	GPIO_LCKR_LCK6_Msk = 0x40
	// Bit LCK6.
	GPIO_LCKR_LCK6 = 0x40
	// Port configuration not locked
	GPIO_LCKR_LCK6_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK6_Locked = 0x1
	// Position of LCK5 field.
	GPIO_LCKR_LCK5_Pos = 0x5
	// Bit mask of LCK5 field.
	GPIO_LCKR_LCK5_Msk = 0x20
	// Bit LCK5.
	GPIO_LCKR_LCK5 = 0x20
	// Port configuration not locked
	GPIO_LCKR_LCK5_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK5_Locked = 0x1
	// Position of LCK4 field.
	GPIO_LCKR_LCK4_Pos = 0x4
	// Bit mask of LCK4 field.
	GPIO_LCKR_LCK4_Msk = 0x10
	// Bit LCK4.
	GPIO_LCKR_LCK4 = 0x10
	// Port configuration not locked
	GPIO_LCKR_LCK4_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK4_Locked = 0x1
	// Position of LCK3 field.
	GPIO_LCKR_LCK3_Pos = 0x3
	// Bit mask of LCK3 field.
	GPIO_LCKR_LCK3_Msk = 0x8
	// Bit LCK3.
	GPIO_LCKR_LCK3 = 0x8
	// Port configuration not locked
	GPIO_LCKR_LCK3_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK3_Locked = 0x1
	// Position of LCK2 field.
	GPIO_LCKR_LCK2_Pos = 0x2
	// Bit mask of LCK2 field.
	GPIO_LCKR_LCK2_Msk = 0x4
	// Bit LCK2.
	GPIO_LCKR_LCK2 = 0x4
	// Port configuration not locked
	GPIO_LCKR_LCK2_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK2_Locked = 0x1
	// Position of LCK1 field.
	GPIO_LCKR_LCK1_Pos = 0x1
	// Bit mask of LCK1 field.
	GPIO_LCKR_LCK1_Msk = 0x2
	// Bit LCK1.
	GPIO_LCKR_LCK1 = 0x2
	// Port configuration not locked
	GPIO_LCKR_LCK1_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK1_Locked = 0x1
	// Position of LCK0 field.
	GPIO_LCKR_LCK0_Pos = 0x0
	// Bit mask of LCK0 field.
	GPIO_LCKR_LCK0_Msk = 0x1
	// Bit LCK0.
	GPIO_LCKR_LCK0 = 0x1
	// Port configuration not locked
	GPIO_LCKR_LCK0_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK0_Locked = 0x1

	// AFRL: GPIO alternate function low register
	// Position of AFRL7 field.
	GPIO_AFRL_AFRL7_Pos = 0x1c
	// Bit mask of AFRL7 field.
	GPIO_AFRL_AFRL7_Msk = 0xf0000000
	// AF0
	GPIO_AFRL_AFRL7_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL7_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL7_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL7_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL7_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL7_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL7_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL7_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL7_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL7_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL7_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL7_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL7_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL7_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL7_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL7_AF15 = 0xf
	// Position of AFRL6 field.
	GPIO_AFRL_AFRL6_Pos = 0x18
	// Bit mask of AFRL6 field.
	GPIO_AFRL_AFRL6_Msk = 0xf000000
	// AF0
	GPIO_AFRL_AFRL6_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL6_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL6_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL6_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL6_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL6_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL6_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL6_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL6_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL6_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL6_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL6_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL6_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL6_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL6_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL6_AF15 = 0xf
	// Position of AFRL5 field.
	GPIO_AFRL_AFRL5_Pos = 0x14
	// Bit mask of AFRL5 field.
	GPIO_AFRL_AFRL5_Msk = 0xf00000
	// AF0
	GPIO_AFRL_AFRL5_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL5_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL5_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL5_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL5_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL5_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL5_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL5_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL5_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL5_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL5_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL5_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL5_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL5_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL5_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL5_AF15 = 0xf
	// Position of AFRL4 field.
	GPIO_AFRL_AFRL4_Pos = 0x10
	// Bit mask of AFRL4 field.
	GPIO_AFRL_AFRL4_Msk = 0xf0000
	// AF0
	GPIO_AFRL_AFRL4_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL4_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL4_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL4_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL4_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL4_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL4_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL4_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL4_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL4_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL4_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL4_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL4_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL4_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL4_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL4_AF15 = 0xf
	// Position of AFRL3 field.
	GPIO_AFRL_AFRL3_Pos = 0xc
	// Bit mask of AFRL3 field.
	GPIO_AFRL_AFRL3_Msk = 0xf000
	// AF0
	GPIO_AFRL_AFRL3_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL3_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL3_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL3_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL3_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL3_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL3_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL3_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL3_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL3_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL3_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL3_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL3_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL3_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL3_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL3_AF15 = 0xf
	// Position of AFRL2 field.
	GPIO_AFRL_AFRL2_Pos = 0x8
	// Bit mask of AFRL2 field.
	GPIO_AFRL_AFRL2_Msk = 0xf00
	// AF0
	GPIO_AFRL_AFRL2_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL2_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL2_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL2_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL2_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL2_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL2_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL2_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL2_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL2_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL2_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL2_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL2_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL2_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL2_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL2_AF15 = 0xf
	// Position of AFRL1 field.
	GPIO_AFRL_AFRL1_Pos = 0x4
	// Bit mask of AFRL1 field.
	GPIO_AFRL_AFRL1_Msk = 0xf0
	// AF0
	GPIO_AFRL_AFRL1_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL1_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL1_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL1_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL1_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL1_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL1_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL1_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL1_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL1_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL1_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL1_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL1_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL1_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL1_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL1_AF15 = 0xf
	// Position of AFRL0 field.
	GPIO_AFRL_AFRL0_Pos = 0x0
	// Bit mask of AFRL0 field.
	GPIO_AFRL_AFRL0_Msk = 0xf
	// AF0
	GPIO_AFRL_AFRL0_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL0_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL0_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL0_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL0_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL0_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL0_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL0_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL0_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL0_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL0_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL0_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL0_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL0_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL0_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL0_AF15 = 0xf

	// AFRH: GPIO alternate function high register
	// Position of AFRH15 field.
	GPIO_AFRH_AFRH15_Pos = 0x1c
	// Bit mask of AFRH15 field.
	GPIO_AFRH_AFRH15_Msk = 0xf0000000
	// AF0
	GPIO_AFRH_AFRH15_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH15_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH15_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH15_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH15_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH15_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH15_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH15_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH15_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH15_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH15_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH15_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH15_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH15_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH15_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH15_AF15 = 0xf
	// Position of AFRH14 field.
	GPIO_AFRH_AFRH14_Pos = 0x18
	// Bit mask of AFRH14 field.
	GPIO_AFRH_AFRH14_Msk = 0xf000000
	// AF0
	GPIO_AFRH_AFRH14_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH14_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH14_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH14_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH14_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH14_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH14_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH14_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH14_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH14_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH14_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH14_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH14_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH14_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH14_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH14_AF15 = 0xf
	// Position of AFRH13 field.
	GPIO_AFRH_AFRH13_Pos = 0x14
	// Bit mask of AFRH13 field.
	GPIO_AFRH_AFRH13_Msk = 0xf00000
	// AF0
	GPIO_AFRH_AFRH13_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH13_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH13_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH13_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH13_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH13_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH13_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH13_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH13_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH13_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH13_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH13_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH13_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH13_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH13_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH13_AF15 = 0xf
	// Position of AFRH12 field.
	GPIO_AFRH_AFRH12_Pos = 0x10
	// Bit mask of AFRH12 field.
	GPIO_AFRH_AFRH12_Msk = 0xf0000
	// AF0
	GPIO_AFRH_AFRH12_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH12_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH12_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH12_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH12_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH12_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH12_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH12_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH12_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH12_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH12_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH12_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH12_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH12_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH12_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH12_AF15 = 0xf
	// Position of AFRH11 field.
	GPIO_AFRH_AFRH11_Pos = 0xc
	// Bit mask of AFRH11 field.
	GPIO_AFRH_AFRH11_Msk = 0xf000
	// AF0
	GPIO_AFRH_AFRH11_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH11_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH11_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH11_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH11_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH11_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH11_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH11_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH11_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH11_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH11_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH11_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH11_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH11_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH11_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH11_AF15 = 0xf
	// Position of AFRH10 field.
	GPIO_AFRH_AFRH10_Pos = 0x8
	// Bit mask of AFRH10 field.
	GPIO_AFRH_AFRH10_Msk = 0xf00
	// AF0
	GPIO_AFRH_AFRH10_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH10_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH10_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH10_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH10_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH10_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH10_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH10_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH10_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH10_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH10_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH10_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH10_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH10_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH10_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH10_AF15 = 0xf
	// Position of AFRH9 field.
	GPIO_AFRH_AFRH9_Pos = 0x4
	// Bit mask of AFRH9 field.
	GPIO_AFRH_AFRH9_Msk = 0xf0
	// AF0
	GPIO_AFRH_AFRH9_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH9_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH9_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH9_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH9_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH9_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH9_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH9_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH9_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH9_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH9_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH9_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH9_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH9_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH9_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH9_AF15 = 0xf
	// Position of AFRH8 field.
	GPIO_AFRH_AFRH8_Pos = 0x0
	// Bit mask of AFRH8 field.
	GPIO_AFRH_AFRH8_Msk = 0xf
	// AF0
	GPIO_AFRH_AFRH8_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH8_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH8_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH8_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH8_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH8_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH8_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH8_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH8_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH8_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH8_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH8_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH8_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH8_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH8_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH8_AF15 = 0xf

	// BRR: GPIO port bit reset register
	// Position of BR0 field.
	GPIO_BRR_BR0_Pos = 0x0
	// Bit mask of BR0 field.
	GPIO_BRR_BR0_Msk = 0x1
	// Bit BR0.
	GPIO_BRR_BR0 = 0x1
	// No action on the corresponding ODx bit
	GPIO_BRR_BR0_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR0_Reset = 0x1
	// Position of BR1 field.
	GPIO_BRR_BR1_Pos = 0x1
	// Bit mask of BR1 field.
	GPIO_BRR_BR1_Msk = 0x2
	// Bit BR1.
	GPIO_BRR_BR1 = 0x2
	// No action on the corresponding ODx bit
	GPIO_BRR_BR1_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR1_Reset = 0x1
	// Position of BR2 field.
	GPIO_BRR_BR2_Pos = 0x2
	// Bit mask of BR2 field.
	GPIO_BRR_BR2_Msk = 0x4
	// Bit BR2.
	GPIO_BRR_BR2 = 0x4
	// No action on the corresponding ODx bit
	GPIO_BRR_BR2_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR2_Reset = 0x1
	// Position of BR3 field.
	GPIO_BRR_BR3_Pos = 0x3
	// Bit mask of BR3 field.
	GPIO_BRR_BR3_Msk = 0x8
	// Bit BR3.
	GPIO_BRR_BR3 = 0x8
	// No action on the corresponding ODx bit
	GPIO_BRR_BR3_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR3_Reset = 0x1
	// Position of BR4 field.
	GPIO_BRR_BR4_Pos = 0x4
	// Bit mask of BR4 field.
	GPIO_BRR_BR4_Msk = 0x10
	// Bit BR4.
	GPIO_BRR_BR4 = 0x10
	// No action on the corresponding ODx bit
	GPIO_BRR_BR4_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR4_Reset = 0x1
	// Position of BR5 field.
	GPIO_BRR_BR5_Pos = 0x5
	// Bit mask of BR5 field.
	GPIO_BRR_BR5_Msk = 0x20
	// Bit BR5.
	GPIO_BRR_BR5 = 0x20
	// No action on the corresponding ODx bit
	GPIO_BRR_BR5_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR5_Reset = 0x1
	// Position of BR6 field.
	GPIO_BRR_BR6_Pos = 0x6
	// Bit mask of BR6 field.
	GPIO_BRR_BR6_Msk = 0x40
	// Bit BR6.
	GPIO_BRR_BR6 = 0x40
	// No action on the corresponding ODx bit
	GPIO_BRR_BR6_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR6_Reset = 0x1
	// Position of BR7 field.
	GPIO_BRR_BR7_Pos = 0x7
	// Bit mask of BR7 field.
	GPIO_BRR_BR7_Msk = 0x80
	// Bit BR7.
	GPIO_BRR_BR7 = 0x80
	// No action on the corresponding ODx bit
	GPIO_BRR_BR7_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR7_Reset = 0x1
	// Position of BR8 field.
	GPIO_BRR_BR8_Pos = 0x8
	// Bit mask of BR8 field.
	GPIO_BRR_BR8_Msk = 0x100
	// Bit BR8.
	GPIO_BRR_BR8 = 0x100
	// No action on the corresponding ODx bit
	GPIO_BRR_BR8_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR8_Reset = 0x1
	// Position of BR9 field.
	GPIO_BRR_BR9_Pos = 0x9
	// Bit mask of BR9 field.
	GPIO_BRR_BR9_Msk = 0x200
	// Bit BR9.
	GPIO_BRR_BR9 = 0x200
	// No action on the corresponding ODx bit
	GPIO_BRR_BR9_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR9_Reset = 0x1
	// Position of BR10 field.
	GPIO_BRR_BR10_Pos = 0xa
	// Bit mask of BR10 field.
	GPIO_BRR_BR10_Msk = 0x400
	// Bit BR10.
	GPIO_BRR_BR10 = 0x400
	// No action on the corresponding ODx bit
	GPIO_BRR_BR10_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR10_Reset = 0x1
	// Position of BR11 field.
	GPIO_BRR_BR11_Pos = 0xb
	// Bit mask of BR11 field.
	GPIO_BRR_BR11_Msk = 0x800
	// Bit BR11.
	GPIO_BRR_BR11 = 0x800
	// No action on the corresponding ODx bit
	GPIO_BRR_BR11_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR11_Reset = 0x1
	// Position of BR12 field.
	GPIO_BRR_BR12_Pos = 0xc
	// Bit mask of BR12 field.
	GPIO_BRR_BR12_Msk = 0x1000
	// Bit BR12.
	GPIO_BRR_BR12 = 0x1000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR12_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR12_Reset = 0x1
	// Position of BR13 field.
	GPIO_BRR_BR13_Pos = 0xd
	// Bit mask of BR13 field.
	GPIO_BRR_BR13_Msk = 0x2000
	// Bit BR13.
	GPIO_BRR_BR13 = 0x2000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR13_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR13_Reset = 0x1
	// Position of BR14 field.
	GPIO_BRR_BR14_Pos = 0xe
	// Bit mask of BR14 field.
	GPIO_BRR_BR14_Msk = 0x4000
	// Bit BR14.
	GPIO_BRR_BR14 = 0x4000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR14_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR14_Reset = 0x1
	// Position of BR15 field.
	GPIO_BRR_BR15_Pos = 0xf
	// Bit mask of BR15 field.
	GPIO_BRR_BR15_Msk = 0x8000
	// Bit BR15.
	GPIO_BRR_BR15 = 0x8000
	// No action on the corresponding ODx bit
	GPIO_BRR_BR15_NoAction = 0x0
	// Reset the ODx bit
	GPIO_BRR_BR15_Reset = 0x1

	// ASCR: GPIO port analog switch control register
	// Position of ASC0 field.
	GPIO_ASCR_ASC0_Pos = 0x0
	// Bit mask of ASC0 field.
	GPIO_ASCR_ASC0_Msk = 0x1
	// Bit ASC0.
	GPIO_ASCR_ASC0 = 0x1
	// Position of ASC1 field.
	GPIO_ASCR_ASC1_Pos = 0x1
	// Bit mask of ASC1 field.
	GPIO_ASCR_ASC1_Msk = 0x2
	// Bit ASC1.
	GPIO_ASCR_ASC1 = 0x2
	// Position of ASC2 field.
	GPIO_ASCR_ASC2_Pos = 0x2
	// Bit mask of ASC2 field.
	GPIO_ASCR_ASC2_Msk = 0x4
	// Bit ASC2.
	GPIO_ASCR_ASC2 = 0x4
	// Position of ASC3 field.
	GPIO_ASCR_ASC3_Pos = 0x3
	// Bit mask of ASC3 field.
	GPIO_ASCR_ASC3_Msk = 0x8
	// Bit ASC3.
	GPIO_ASCR_ASC3 = 0x8
	// Position of ASC4 field.
	GPIO_ASCR_ASC4_Pos = 0x4
	// Bit mask of ASC4 field.
	GPIO_ASCR_ASC4_Msk = 0x10
	// Bit ASC4.
	GPIO_ASCR_ASC4 = 0x10
	// Position of ASC5 field.
	GPIO_ASCR_ASC5_Pos = 0x5
	// Bit mask of ASC5 field.
	GPIO_ASCR_ASC5_Msk = 0x20
	// Bit ASC5.
	GPIO_ASCR_ASC5 = 0x20
	// Position of ASC6 field.
	GPIO_ASCR_ASC6_Pos = 0x6
	// Bit mask of ASC6 field.
	GPIO_ASCR_ASC6_Msk = 0x40
	// Bit ASC6.
	GPIO_ASCR_ASC6 = 0x40
	// Position of ASC7 field.
	GPIO_ASCR_ASC7_Pos = 0x7
	// Bit mask of ASC7 field.
	GPIO_ASCR_ASC7_Msk = 0x80
	// Bit ASC7.
	GPIO_ASCR_ASC7 = 0x80
	// Position of ASC8 field.
	GPIO_ASCR_ASC8_Pos = 0x8
	// Bit mask of ASC8 field.
	GPIO_ASCR_ASC8_Msk = 0x100
	// Bit ASC8.
	GPIO_ASCR_ASC8 = 0x100
	// Position of ASC9 field.
	GPIO_ASCR_ASC9_Pos = 0x9
	// Bit mask of ASC9 field.
	GPIO_ASCR_ASC9_Msk = 0x200
	// Bit ASC9.
	GPIO_ASCR_ASC9 = 0x200
	// Position of ASC10 field.
	GPIO_ASCR_ASC10_Pos = 0xa
	// Bit mask of ASC10 field.
	GPIO_ASCR_ASC10_Msk = 0x400
	// Bit ASC10.
	GPIO_ASCR_ASC10 = 0x400
	// Position of ASC11 field.
	GPIO_ASCR_ASC11_Pos = 0xb
	// Bit mask of ASC11 field.
	GPIO_ASCR_ASC11_Msk = 0x800
	// Bit ASC11.
	GPIO_ASCR_ASC11 = 0x800
	// Position of ASC12 field.
	GPIO_ASCR_ASC12_Pos = 0xc
	// Bit mask of ASC12 field.
	GPIO_ASCR_ASC12_Msk = 0x1000
	// Bit ASC12.
	GPIO_ASCR_ASC12 = 0x1000
	// Position of ASC13 field.
	GPIO_ASCR_ASC13_Pos = 0xd
	// Bit mask of ASC13 field.
	GPIO_ASCR_ASC13_Msk = 0x2000
	// Bit ASC13.
	GPIO_ASCR_ASC13 = 0x2000
	// Position of ASC14 field.
	GPIO_ASCR_ASC14_Pos = 0xe
	// Bit mask of ASC14 field.
	GPIO_ASCR_ASC14_Msk = 0x4000
	// Bit ASC14.
	GPIO_ASCR_ASC14 = 0x4000
	// Position of ASC15 field.
	GPIO_ASCR_ASC15_Pos = 0xf
	// Bit mask of ASC15 field.
	GPIO_ASCR_ASC15_Msk = 0x8000
	// Bit ASC15.
	GPIO_ASCR_ASC15 = 0x8000
)

// Constants for SAI1: Serial audio interface
const (
	// CH.CR1: AConfiguration register 1
	// Position of MCKDIV field.
	SAI_CH_CR1_MCKDIV_Pos = 0x14
	// Bit mask of MCKDIV field.
	SAI_CH_CR1_MCKDIV_Msk = 0xf00000
	// Position of NODIV field.
	SAI_CH_CR1_NODIV_Pos = 0x13
	// Bit mask of NODIV field.
	SAI_CH_CR1_NODIV_Msk = 0x80000
	// Bit NODIV.
	SAI_CH_CR1_NODIV = 0x80000
	// MCLK output is enabled. Forces the ratio between FS and MCLK to 256 or 512 according to the OSR value
	SAI_CH_CR1_NODIV_MasterClock = 0x0
	// MCLK output enable set by the MCKEN bit (where present, else 0). Ratio between FS and MCLK depends on FRL.
	SAI_CH_CR1_NODIV_NoDiv = 0x1
	// Position of DMAEN field.
	SAI_CH_CR1_DMAEN_Pos = 0x11
	// Bit mask of DMAEN field.
	SAI_CH_CR1_DMAEN_Msk = 0x20000
	// Bit DMAEN.
	SAI_CH_CR1_DMAEN = 0x20000
	// DMA disabled
	SAI_CH_CR1_DMAEN_Disabled = 0x0
	// DMA enabled
	SAI_CH_CR1_DMAEN_Enabled = 0x1
	// Position of SAIEN field.
	SAI_CH_CR1_SAIEN_Pos = 0x10
	// Bit mask of SAIEN field.
	SAI_CH_CR1_SAIEN_Msk = 0x10000
	// Bit SAIEN.
	SAI_CH_CR1_SAIEN = 0x10000
	// SAI audio block disabled
	SAI_CH_CR1_SAIEN_Disabled = 0x0
	// SAI audio block enabled
	SAI_CH_CR1_SAIEN_Enabled = 0x1
	// Position of OUTDRIV field.
	SAI_CH_CR1_OUTDRIV_Pos = 0xd
	// Bit mask of OUTDRIV field.
	SAI_CH_CR1_OUTDRIV_Msk = 0x2000
	// Bit OUTDRIV.
	SAI_CH_CR1_OUTDRIV = 0x2000
	// Audio block output driven when SAIEN is set
	SAI_CH_CR1_OUTDRIV_OnStart = 0x0
	// Audio block output driven immediately after the setting of this bit
	SAI_CH_CR1_OUTDRIV_Immediately = 0x1
	// Position of MONO field.
	SAI_CH_CR1_MONO_Pos = 0xc
	// Bit mask of MONO field.
	SAI_CH_CR1_MONO_Msk = 0x1000
	// Bit MONO.
	SAI_CH_CR1_MONO = 0x1000
	// Stereo mode
	SAI_CH_CR1_MONO_Stereo = 0x0
	// Mono mode
	SAI_CH_CR1_MONO_Mono = 0x1
	// Position of SYNCEN field.
	SAI_CH_CR1_SYNCEN_Pos = 0xa
	// Bit mask of SYNCEN field.
	SAI_CH_CR1_SYNCEN_Msk = 0xc00
	// audio sub-block in asynchronous mode
	SAI_CH_CR1_SYNCEN_Asynchronous = 0x0
	// audio sub-block is synchronous with the other internal audio sub-block. In this case, the audio sub-block must be configured in slave mode
	SAI_CH_CR1_SYNCEN_Internal = 0x1
	// audio sub-block is synchronous with an external SAI embedded peripheral. In this case the audio sub-block should be configured in Slave mode
	SAI_CH_CR1_SYNCEN_External = 0x2
	// Position of CKSTR field.
	SAI_CH_CR1_CKSTR_Pos = 0x9
	// Bit mask of CKSTR field.
	SAI_CH_CR1_CKSTR_Msk = 0x200
	// Bit CKSTR.
	SAI_CH_CR1_CKSTR = 0x200
	// Data strobing edge is falling edge of SCK
	SAI_CH_CR1_CKSTR_FallingEdge = 0x0
	// Data strobing edge is rising edge of SCK
	SAI_CH_CR1_CKSTR_RisingEdge = 0x1
	// Position of LSBFIRST field.
	SAI_CH_CR1_LSBFIRST_Pos = 0x8
	// Bit mask of LSBFIRST field.
	SAI_CH_CR1_LSBFIRST_Msk = 0x100
	// Bit LSBFIRST.
	SAI_CH_CR1_LSBFIRST = 0x100
	// Data are transferred with MSB first
	SAI_CH_CR1_LSBFIRST_MsbFirst = 0x0
	// Data are transferred with LSB first
	SAI_CH_CR1_LSBFIRST_LsbFirst = 0x1
	// Position of DS field.
	SAI_CH_CR1_DS_Pos = 0x5
	// Bit mask of DS field.
	SAI_CH_CR1_DS_Msk = 0xe0
	// 8 bits
	SAI_CH_CR1_DS_Bit8 = 0x2
	// 10 bits
	SAI_CH_CR1_DS_Bit10 = 0x3
	// 16 bits
	SAI_CH_CR1_DS_Bit16 = 0x4
	// 20 bits
	SAI_CH_CR1_DS_Bit20 = 0x5
	// 24 bits
	SAI_CH_CR1_DS_Bit24 = 0x6
	// 32 bits
	SAI_CH_CR1_DS_Bit32 = 0x7
	// Position of PRTCFG field.
	SAI_CH_CR1_PRTCFG_Pos = 0x2
	// Bit mask of PRTCFG field.
	SAI_CH_CR1_PRTCFG_Msk = 0xc
	// Free protocol. Free protocol allows to use the powerful configuration of the audio block to address a specific audio protocol
	SAI_CH_CR1_PRTCFG_Free = 0x0
	// SPDIF protocol
	SAI_CH_CR1_PRTCFG_Spdif = 0x1
	// AC’97 protocol
	SAI_CH_CR1_PRTCFG_Ac97 = 0x2
	// Position of MODE field.
	SAI_CH_CR1_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SAI_CH_CR1_MODE_Msk = 0x3
	// Master transmitter
	SAI_CH_CR1_MODE_MasterTx = 0x0
	// Master receiver
	SAI_CH_CR1_MODE_MasterRx = 0x1
	// Slave transmitter
	SAI_CH_CR1_MODE_SlaveTx = 0x2
	// Slave receiver
	SAI_CH_CR1_MODE_SlaveRx = 0x3

	// CH.CR2: AConfiguration register 2
	// Position of COMP field.
	SAI_CH_CR2_COMP_Pos = 0xe
	// Bit mask of COMP field.
	SAI_CH_CR2_COMP_Msk = 0xc000
	// No companding algorithm
	SAI_CH_CR2_COMP_NoCompanding = 0x0
	// μ-Law algorithm
	SAI_CH_CR2_COMP_MuLaw = 0x2
	// A-Law algorithm
	SAI_CH_CR2_COMP_ALaw = 0x3
	// Position of CPL field.
	SAI_CH_CR2_CPL_Pos = 0xd
	// Bit mask of CPL field.
	SAI_CH_CR2_CPL_Msk = 0x2000
	// Bit CPL.
	SAI_CH_CR2_CPL = 0x2000
	// 1’s complement representation
	SAI_CH_CR2_CPL_OnesComplement = 0x0
	// 2’s complement representation
	SAI_CH_CR2_CPL_TwosComplement = 0x1
	// Position of MUTECN field.
	SAI_CH_CR2_MUTECN_Pos = 0x7
	// Bit mask of MUTECN field.
	SAI_CH_CR2_MUTECN_Msk = 0x1f80
	// Position of MUTEVAL field.
	SAI_CH_CR2_MUTEVAL_Pos = 0x6
	// Bit mask of MUTEVAL field.
	SAI_CH_CR2_MUTEVAL_Msk = 0x40
	// Bit MUTEVAL.
	SAI_CH_CR2_MUTEVAL = 0x40
	// Bit value 0 is sent during the mute mode
	SAI_CH_CR2_MUTEVAL_SendZero = 0x0
	// Last values are sent during the mute mode
	SAI_CH_CR2_MUTEVAL_SendLast = 0x1
	// Position of MUTE field.
	SAI_CH_CR2_MUTE_Pos = 0x5
	// Bit mask of MUTE field.
	SAI_CH_CR2_MUTE_Msk = 0x20
	// Bit MUTE.
	SAI_CH_CR2_MUTE = 0x20
	// No mute mode
	SAI_CH_CR2_MUTE_Disabled = 0x0
	// Mute mode enabled
	SAI_CH_CR2_MUTE_Enabled = 0x1
	// Position of TRIS field.
	SAI_CH_CR2_TRIS_Pos = 0x4
	// Bit mask of TRIS field.
	SAI_CH_CR2_TRIS_Msk = 0x10
	// Bit TRIS.
	SAI_CH_CR2_TRIS = 0x10
	// Position of FFLUSH field.
	SAI_CH_CR2_FFLUSH_Pos = 0x3
	// Bit mask of FFLUSH field.
	SAI_CH_CR2_FFLUSH_Msk = 0x8
	// Bit FFLUSH.
	SAI_CH_CR2_FFLUSH = 0x8
	// No FIFO flush
	SAI_CH_CR2_FFLUSH_NoFlush = 0x0
	// FIFO flush. Programming this bit to 1 triggers the FIFO Flush. All the internal FIFO pointers (read and write) are cleared
	SAI_CH_CR2_FFLUSH_Flush = 0x1
	// Position of FTH field.
	SAI_CH_CR2_FTH_Pos = 0x0
	// Bit mask of FTH field.
	SAI_CH_CR2_FTH_Msk = 0x7
	// FIFO empty
	SAI_CH_CR2_FTH_Empty = 0x0
	// 1⁄4 FIFO
	SAI_CH_CR2_FTH_Quarter1 = 0x1
	// 1⁄2 FIFO
	SAI_CH_CR2_FTH_Quarter2 = 0x2
	// 3⁄4 FIFO
	SAI_CH_CR2_FTH_Quarter3 = 0x3
	// FIFO full
	SAI_CH_CR2_FTH_Full = 0x4

	// CH.FRCR: AFRCR
	// Position of FSOFF field.
	SAI_CH_FRCR_FSOFF_Pos = 0x12
	// Bit mask of FSOFF field.
	SAI_CH_FRCR_FSOFF_Msk = 0x40000
	// Bit FSOFF.
	SAI_CH_FRCR_FSOFF = 0x40000
	// FS is asserted on the first bit of the slot 0
	SAI_CH_FRCR_FSOFF_OnFirst = 0x0
	// FS is asserted one bit before the first bit of the slot 0
	SAI_CH_FRCR_FSOFF_BeforeFirst = 0x1
	// Position of FSPOL field.
	SAI_CH_FRCR_FSPOL_Pos = 0x11
	// Bit mask of FSPOL field.
	SAI_CH_FRCR_FSPOL_Msk = 0x20000
	// Bit FSPOL.
	SAI_CH_FRCR_FSPOL = 0x20000
	// FS is active low (falling edge)
	SAI_CH_FRCR_FSPOL_FallingEdge = 0x0
	// FS is active high (rising edge)
	SAI_CH_FRCR_FSPOL_RisingEdge = 0x1
	// Position of FSDEF field.
	SAI_CH_FRCR_FSDEF_Pos = 0x10
	// Bit mask of FSDEF field.
	SAI_CH_FRCR_FSDEF_Msk = 0x10000
	// Bit FSDEF.
	SAI_CH_FRCR_FSDEF = 0x10000
	// Position of FSALL field.
	SAI_CH_FRCR_FSALL_Pos = 0x8
	// Bit mask of FSALL field.
	SAI_CH_FRCR_FSALL_Msk = 0x7f00
	// Position of FRL field.
	SAI_CH_FRCR_FRL_Pos = 0x0
	// Bit mask of FRL field.
	SAI_CH_FRCR_FRL_Msk = 0xff

	// CH.SLOTR: ASlot register
	// Position of SLOTEN field.
	SAI_CH_SLOTR_SLOTEN_Pos = 0x10
	// Bit mask of SLOTEN field.
	SAI_CH_SLOTR_SLOTEN_Msk = 0xffff0000
	// Inactive slot
	SAI_CH_SLOTR_SLOTEN_Inactive = 0x0
	// Active slot
	SAI_CH_SLOTR_SLOTEN_Active = 0x1
	// Position of NBSLOT field.
	SAI_CH_SLOTR_NBSLOT_Pos = 0x8
	// Bit mask of NBSLOT field.
	SAI_CH_SLOTR_NBSLOT_Msk = 0xf00
	// Position of SLOTSZ field.
	SAI_CH_SLOTR_SLOTSZ_Pos = 0x6
	// Bit mask of SLOTSZ field.
	SAI_CH_SLOTR_SLOTSZ_Msk = 0xc0
	// The slot size is equivalent to the data size (specified in DS[3:0] in the SAI_xCR1 register)
	SAI_CH_SLOTR_SLOTSZ_DataSize = 0x0
	// 16-bit
	SAI_CH_SLOTR_SLOTSZ_Bit16 = 0x1
	// 32-bit
	SAI_CH_SLOTR_SLOTSZ_Bit32 = 0x2
	// Position of FBOFF field.
	SAI_CH_SLOTR_FBOFF_Pos = 0x0
	// Bit mask of FBOFF field.
	SAI_CH_SLOTR_FBOFF_Msk = 0x1f

	// CH.IM: AInterrupt mask register2
	// Position of LFSDETIE field.
	SAI_CH_IM_LFSDETIE_Pos = 0x6
	// Bit mask of LFSDETIE field.
	SAI_CH_IM_LFSDETIE_Msk = 0x40
	// Bit LFSDETIE.
	SAI_CH_IM_LFSDETIE = 0x40
	// Interrupt is disabled
	SAI_CH_IM_LFSDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_LFSDETIE_Enabled = 0x1
	// Position of AFSDETIE field.
	SAI_CH_IM_AFSDETIE_Pos = 0x5
	// Bit mask of AFSDETIE field.
	SAI_CH_IM_AFSDETIE_Msk = 0x20
	// Bit AFSDETIE.
	SAI_CH_IM_AFSDETIE = 0x20
	// Interrupt is disabled
	SAI_CH_IM_AFSDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_AFSDETIE_Enabled = 0x1
	// Position of CNRDYIE field.
	SAI_CH_IM_CNRDYIE_Pos = 0x4
	// Bit mask of CNRDYIE field.
	SAI_CH_IM_CNRDYIE_Msk = 0x10
	// Bit CNRDYIE.
	SAI_CH_IM_CNRDYIE = 0x10
	// Interrupt is disabled
	SAI_CH_IM_CNRDYIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_CNRDYIE_Enabled = 0x1
	// Position of FREQIE field.
	SAI_CH_IM_FREQIE_Pos = 0x3
	// Bit mask of FREQIE field.
	SAI_CH_IM_FREQIE_Msk = 0x8
	// Bit FREQIE.
	SAI_CH_IM_FREQIE = 0x8
	// Interrupt is disabled
	SAI_CH_IM_FREQIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_FREQIE_Enabled = 0x1
	// Position of WCKCFGIE field.
	SAI_CH_IM_WCKCFGIE_Pos = 0x2
	// Bit mask of WCKCFGIE field.
	SAI_CH_IM_WCKCFGIE_Msk = 0x4
	// Bit WCKCFGIE.
	SAI_CH_IM_WCKCFGIE = 0x4
	// Interrupt is disabled
	SAI_CH_IM_WCKCFGIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_WCKCFGIE_Enabled = 0x1
	// Position of MUTEDETIE field.
	SAI_CH_IM_MUTEDETIE_Pos = 0x1
	// Bit mask of MUTEDETIE field.
	SAI_CH_IM_MUTEDETIE_Msk = 0x2
	// Bit MUTEDETIE.
	SAI_CH_IM_MUTEDETIE = 0x2
	// Interrupt is disabled
	SAI_CH_IM_MUTEDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_MUTEDETIE_Enabled = 0x1
	// Position of OVRUDRIE field.
	SAI_CH_IM_OVRUDRIE_Pos = 0x0
	// Bit mask of OVRUDRIE field.
	SAI_CH_IM_OVRUDRIE_Msk = 0x1
	// Bit OVRUDRIE.
	SAI_CH_IM_OVRUDRIE = 0x1
	// Interrupt is disabled
	SAI_CH_IM_OVRUDRIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_OVRUDRIE_Enabled = 0x1

	// CH.SR: AStatus register
	// Position of FLVL field.
	SAI_CH_SR_FLVL_Pos = 0x10
	// Bit mask of FLVL field.
	SAI_CH_SR_FLVL_Msk = 0x70000
	// FIFO empty
	SAI_CH_SR_FLVL_Empty = 0x0
	// FIFO <= 1⁄4 but not empty
	SAI_CH_SR_FLVL_Quarter1 = 0x1
	// 1⁄4 < FIFO <= 1⁄2
	SAI_CH_SR_FLVL_Quarter2 = 0x2
	// 1⁄2 < FIFO <= 3⁄4
	SAI_CH_SR_FLVL_Quarter3 = 0x3
	// 3⁄4 < FIFO but not full
	SAI_CH_SR_FLVL_Quarter4 = 0x4
	// FIFO full
	SAI_CH_SR_FLVL_Full = 0x5
	// Position of LFSDET field.
	SAI_CH_SR_LFSDET_Pos = 0x6
	// Bit mask of LFSDET field.
	SAI_CH_SR_LFSDET_Msk = 0x40
	// Bit LFSDET.
	SAI_CH_SR_LFSDET = 0x40
	// No error
	SAI_CH_SR_LFSDET_NoError = 0x0
	// Frame synchronization signal is not present at the right time
	SAI_CH_SR_LFSDET_NoSync = 0x1
	// Position of AFSDET field.
	SAI_CH_SR_AFSDET_Pos = 0x5
	// Bit mask of AFSDET field.
	SAI_CH_SR_AFSDET_Msk = 0x20
	// Bit AFSDET.
	SAI_CH_SR_AFSDET = 0x20
	// No error
	SAI_CH_SR_AFSDET_NoError = 0x0
	// Frame synchronization signal is detected earlier than expected
	SAI_CH_SR_AFSDET_EarlySync = 0x1
	// Position of CNRDY field.
	SAI_CH_SR_CNRDY_Pos = 0x4
	// Bit mask of CNRDY field.
	SAI_CH_SR_CNRDY_Msk = 0x10
	// Bit CNRDY.
	SAI_CH_SR_CNRDY = 0x10
	// External AC’97 Codec is ready
	SAI_CH_SR_CNRDY_Ready = 0x0
	// External AC’97 Codec is not ready
	SAI_CH_SR_CNRDY_NotReady = 0x1
	// Position of FREQ field.
	SAI_CH_SR_FREQ_Pos = 0x3
	// Bit mask of FREQ field.
	SAI_CH_SR_FREQ_Msk = 0x8
	// Bit FREQ.
	SAI_CH_SR_FREQ = 0x8
	// No FIFO request
	SAI_CH_SR_FREQ_NoRequest = 0x0
	// FIFO request to read or to write the SAI_xDR
	SAI_CH_SR_FREQ_Request = 0x1
	// Position of WCKCFG field.
	SAI_CH_SR_WCKCFG_Pos = 0x2
	// Bit mask of WCKCFG field.
	SAI_CH_SR_WCKCFG_Msk = 0x4
	// Bit WCKCFG.
	SAI_CH_SR_WCKCFG = 0x4
	// Clock configuration is correct
	SAI_CH_SR_WCKCFG_Correct = 0x0
	// Clock configuration does not respect the rule concerning the frame length specification
	SAI_CH_SR_WCKCFG_Wrong = 0x1
	// Position of MUTEDET field.
	SAI_CH_SR_MUTEDET_Pos = 0x1
	// Bit mask of MUTEDET field.
	SAI_CH_SR_MUTEDET_Msk = 0x2
	// Bit MUTEDET.
	SAI_CH_SR_MUTEDET = 0x2
	// No MUTE detection on the SD input line
	SAI_CH_SR_MUTEDET_NoMute = 0x0
	// MUTE value detected on the SD input line (0 value) for a specified number of consecutive audio frame
	SAI_CH_SR_MUTEDET_Mute = 0x1
	// Position of OVRUDR field.
	SAI_CH_SR_OVRUDR_Pos = 0x0
	// Bit mask of OVRUDR field.
	SAI_CH_SR_OVRUDR_Msk = 0x1
	// Bit OVRUDR.
	SAI_CH_SR_OVRUDR = 0x1
	// No overrun/underrun error
	SAI_CH_SR_OVRUDR_NoError = 0x0
	// Overrun/underrun error detection
	SAI_CH_SR_OVRUDR_Overrun = 0x1

	// CH.CLRFR: AClear flag register
	// Position of CLFSDET field.
	SAI_CH_CLRFR_CLFSDET_Pos = 0x6
	// Bit mask of CLFSDET field.
	SAI_CH_CLRFR_CLFSDET_Msk = 0x40
	// Bit CLFSDET.
	SAI_CH_CLRFR_CLFSDET = 0x40
	// Clears the LFSDET flag
	SAI_CH_CLRFR_CLFSDET_Clear = 0x1
	// Position of CAFSDET field.
	SAI_CH_CLRFR_CAFSDET_Pos = 0x5
	// Bit mask of CAFSDET field.
	SAI_CH_CLRFR_CAFSDET_Msk = 0x20
	// Bit CAFSDET.
	SAI_CH_CLRFR_CAFSDET = 0x20
	// Clears the AFSDET flag
	SAI_CH_CLRFR_CAFSDET_Clear = 0x1
	// Position of CCNRDY field.
	SAI_CH_CLRFR_CCNRDY_Pos = 0x4
	// Bit mask of CCNRDY field.
	SAI_CH_CLRFR_CCNRDY_Msk = 0x10
	// Bit CCNRDY.
	SAI_CH_CLRFR_CCNRDY = 0x10
	// Clears the CNRDY flag
	SAI_CH_CLRFR_CCNRDY_Clear = 0x1
	// Position of CWCKCFG field.
	SAI_CH_CLRFR_CWCKCFG_Pos = 0x2
	// Bit mask of CWCKCFG field.
	SAI_CH_CLRFR_CWCKCFG_Msk = 0x4
	// Bit CWCKCFG.
	SAI_CH_CLRFR_CWCKCFG = 0x4
	// Clears the WCKCFG flag
	SAI_CH_CLRFR_CWCKCFG_Clear = 0x1
	// Position of CMUTEDET field.
	SAI_CH_CLRFR_CMUTEDET_Pos = 0x1
	// Bit mask of CMUTEDET field.
	SAI_CH_CLRFR_CMUTEDET_Msk = 0x2
	// Bit CMUTEDET.
	SAI_CH_CLRFR_CMUTEDET = 0x2
	// Clears the MUTEDET flag
	SAI_CH_CLRFR_CMUTEDET_Clear = 0x1
	// Position of COVRUDR field.
	SAI_CH_CLRFR_COVRUDR_Pos = 0x0
	// Bit mask of COVRUDR field.
	SAI_CH_CLRFR_COVRUDR_Msk = 0x1
	// Bit COVRUDR.
	SAI_CH_CLRFR_COVRUDR = 0x1
	// Clears the OVRUDR flag
	SAI_CH_CLRFR_COVRUDR_Clear = 0x1

	// CH.DR: AData register
	// Position of DATA field.
	SAI_CH_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SAI_CH_DR_DATA_Msk = 0xffffffff
)

// Constants for TIM2: General-purpose-timers
const (
	// CR1: control register 1
	// Position of CKD field.
	TIM_CR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIM_CR1_CKD_Msk = 0x300
	// t_DTS = t_CK_INT
	TIM_CR1_CKD_Div1 = 0x0
	// t_DTS = 2 × t_CK_INT
	TIM_CR1_CKD_Div2 = 0x1
	// t_DTS = 4 × t_CK_INT
	TIM_CR1_CKD_Div4 = 0x2
	// Position of ARPE field.
	TIM_CR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIM_CR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIM_CR1_ARPE = 0x80
	// TIMx_APRR register is not buffered
	TIM_CR1_ARPE_Disabled = 0x0
	// TIMx_APRR register is buffered
	TIM_CR1_ARPE_Enabled = 0x1
	// Position of CMS field.
	TIM_CR1_CMS_Pos = 0x5
	// Bit mask of CMS field.
	TIM_CR1_CMS_Msk = 0x60
	// The counter counts up or down depending on the direction bit
	TIM_CR1_CMS_EdgeAligned = 0x0
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
	TIM_CR1_CMS_CenterAligned1 = 0x1
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
	TIM_CR1_CMS_CenterAligned2 = 0x2
	// The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
	TIM_CR1_CMS_CenterAligned3 = 0x3
	// Position of DIR field.
	TIM_CR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	TIM_CR1_DIR_Msk = 0x10
	// Bit DIR.
	TIM_CR1_DIR = 0x10
	// Counter used as upcounter
	TIM_CR1_DIR_Up = 0x0
	// Counter used as downcounter
	TIM_CR1_DIR_Down = 0x1
	// Position of OPM field.
	TIM_CR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIM_CR1_OPM_Msk = 0x8
	// Bit OPM.
	TIM_CR1_OPM = 0x8
	// Counter is not stopped at update event
	TIM_CR1_OPM_Disabled = 0x0
	// Counter stops counting at the next update event (clearing the CEN bit)
	TIM_CR1_OPM_Enabled = 0x1
	// Position of URS field.
	TIM_CR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIM_CR1_URS_Msk = 0x4
	// Bit URS.
	TIM_CR1_URS = 0x4
	// Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
	TIM_CR1_URS_AnyEvent = 0x0
	// Only counter overflow/underflow generates an update interrupt or DMA request
	TIM_CR1_URS_CounterOnly = 0x1
	// Position of UDIS field.
	TIM_CR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIM_CR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIM_CR1_UDIS = 0x2
	// Update event enabled
	TIM_CR1_UDIS_Enabled = 0x0
	// Update event disabled
	TIM_CR1_UDIS_Disabled = 0x1
	// Position of CEN field.
	TIM_CR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIM_CR1_CEN_Msk = 0x1
	// Bit CEN.
	TIM_CR1_CEN = 0x1
	// Counter disabled
	TIM_CR1_CEN_Disabled = 0x0
	// Counter enabled
	TIM_CR1_CEN_Enabled = 0x1

	// CR2: control register 2
	// Position of TI1S field.
	TIM_CR2_TI1S_Pos = 0x7
	// Bit mask of TI1S field.
	TIM_CR2_TI1S_Msk = 0x80
	// Bit TI1S.
	TIM_CR2_TI1S = 0x80
	// The TIMx_CH1 pin is connected to TI1 input
	TIM_CR2_TI1S_Normal = 0x0
	// The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
	TIM_CR2_TI1S_XOR = 0x1
	// Position of MMS field.
	TIM_CR2_MMS_Pos = 0x4
	// Bit mask of MMS field.
	TIM_CR2_MMS_Msk = 0x70
	// The UG bit from the TIMx_EGR register is used as trigger output
	TIM_CR2_MMS_Reset = 0x0
	// The counter enable signal, CNT_EN, is used as trigger output
	TIM_CR2_MMS_Enable = 0x1
	// The update event is selected as trigger output
	TIM_CR2_MMS_Update = 0x2
	// The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
	TIM_CR2_MMS_ComparePulse = 0x3
	// OC1REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC1 = 0x4
	// OC2REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC2 = 0x5
	// OC3REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC3 = 0x6
	// OC4REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC4 = 0x7
	// Position of CCDS field.
	TIM_CR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIM_CR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIM_CR2_CCDS = 0x8
	// CCx DMA request sent when CCx event occurs
	TIM_CR2_CCDS_OnCompare = 0x0
	// CCx DMA request sent when update event occurs
	TIM_CR2_CCDS_OnUpdate = 0x1

	// SMCR: slave mode control register
	// Position of ETP field.
	TIM_SMCR_ETP_Pos = 0xf
	// Bit mask of ETP field.
	TIM_SMCR_ETP_Msk = 0x8000
	// Bit ETP.
	TIM_SMCR_ETP = 0x8000
	// ETR is noninverted, active at high level or rising edge
	TIM_SMCR_ETP_NotInverted = 0x0
	// ETR is inverted, active at low level or falling edge
	TIM_SMCR_ETP_Inverted = 0x1
	// Position of ECE field.
	TIM_SMCR_ECE_Pos = 0xe
	// Bit mask of ECE field.
	TIM_SMCR_ECE_Msk = 0x4000
	// Bit ECE.
	TIM_SMCR_ECE = 0x4000
	// External clock mode 2 disabled
	TIM_SMCR_ECE_Disabled = 0x0
	// External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
	TIM_SMCR_ECE_Enabled = 0x1
	// Position of ETPS field.
	TIM_SMCR_ETPS_Pos = 0xc
	// Bit mask of ETPS field.
	TIM_SMCR_ETPS_Msk = 0x3000
	// Prescaler OFF
	TIM_SMCR_ETPS_Div1 = 0x0
	// ETRP frequency divided by 2
	TIM_SMCR_ETPS_Div2 = 0x1
	// ETRP frequency divided by 4
	TIM_SMCR_ETPS_Div4 = 0x2
	// ETRP frequency divided by 8
	TIM_SMCR_ETPS_Div8 = 0x3
	// Position of ETF field.
	TIM_SMCR_ETF_Pos = 0x8
	// Bit mask of ETF field.
	TIM_SMCR_ETF_Msk = 0xf00
	// No filter, sampling is done at fDTS
	TIM_SMCR_ETF_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_SMCR_ETF_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_SMCR_ETF_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_SMCR_ETF_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_SMCR_ETF_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_SMCR_ETF_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_SMCR_ETF_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_SMCR_ETF_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_SMCR_ETF_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_SMCR_ETF_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_SMCR_ETF_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_SMCR_ETF_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_SMCR_ETF_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_SMCR_ETF_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_SMCR_ETF_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_SMCR_ETF_FDTS_Div32_N8 = 0xf
	// Position of MSM field.
	TIM_SMCR_MSM_Pos = 0x7
	// Bit mask of MSM field.
	TIM_SMCR_MSM_Msk = 0x80
	// Bit MSM.
	TIM_SMCR_MSM = 0x80
	// No action
	TIM_SMCR_MSM_NoSync = 0x0
	// The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
	TIM_SMCR_MSM_Sync = 0x1
	// Position of TS field.
	TIM_SMCR_TS_Pos = 0x4
	// Bit mask of TS field.
	TIM_SMCR_TS_Msk = 0x70
	// Internal Trigger 0 (ITR0)
	TIM_SMCR_TS_ITR0 = 0x0
	// Internal Trigger 1 (ITR1)
	TIM_SMCR_TS_ITR1 = 0x1
	// Internal Trigger 2 (ITR2)
	TIM_SMCR_TS_ITR2 = 0x2
	// TI1 Edge Detector (TI1F_ED)
	TIM_SMCR_TS_TI1F_ED = 0x4
	// Filtered Timer Input 1 (TI1FP1)
	TIM_SMCR_TS_TI1FP1 = 0x5
	// Filtered Timer Input 2 (TI2FP2)
	TIM_SMCR_TS_TI2FP2 = 0x6
	// External Trigger input (ETRF)
	TIM_SMCR_TS_ETRF = 0x7
	// Position of SMS field.
	TIM_SMCR_SMS_Pos = 0x0
	// Bit mask of SMS field.
	TIM_SMCR_SMS_Msk = 0x7
	// Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.
	TIM_SMCR_SMS_Disabled = 0x0
	// Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
	TIM_SMCR_SMS_Encoder_Mode_1 = 0x1
	// Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
	TIM_SMCR_SMS_Encoder_Mode_2 = 0x2
	// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
	TIM_SMCR_SMS_Encoder_Mode_3 = 0x3
	// Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
	TIM_SMCR_SMS_Reset_Mode = 0x4
	// Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
	TIM_SMCR_SMS_Gated_Mode = 0x5
	// Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
	TIM_SMCR_SMS_Trigger_Mode = 0x6
	// External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
	TIM_SMCR_SMS_Ext_Clock_Mode = 0x7

	// DIER: DMA/Interrupt enable register
	// Position of TDE field.
	TIM_DIER_TDE_Pos = 0xe
	// Bit mask of TDE field.
	TIM_DIER_TDE_Msk = 0x4000
	// Bit TDE.
	TIM_DIER_TDE = 0x4000
	// Trigger DMA request disabled
	TIM_DIER_TDE_Disabled = 0x0
	// Trigger DMA request enabled
	TIM_DIER_TDE_Enabled = 0x1
	// Position of COMDE field.
	TIM_DIER_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIM_DIER_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIM_DIER_COMDE = 0x2000
	// Position of CC4DE field.
	TIM_DIER_CC4DE_Pos = 0xc
	// Bit mask of CC4DE field.
	TIM_DIER_CC4DE_Msk = 0x1000
	// Bit CC4DE.
	TIM_DIER_CC4DE = 0x1000
	// CCx DMA request disabled
	TIM_DIER_CC4DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC4DE_Enabled = 0x1
	// Position of CC3DE field.
	TIM_DIER_CC3DE_Pos = 0xb
	// Bit mask of CC3DE field.
	TIM_DIER_CC3DE_Msk = 0x800
	// Bit CC3DE.
	TIM_DIER_CC3DE = 0x800
	// CCx DMA request disabled
	TIM_DIER_CC3DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC3DE_Enabled = 0x1
	// Position of CC2DE field.
	TIM_DIER_CC2DE_Pos = 0xa
	// Bit mask of CC2DE field.
	TIM_DIER_CC2DE_Msk = 0x400
	// Bit CC2DE.
	TIM_DIER_CC2DE = 0x400
	// CCx DMA request disabled
	TIM_DIER_CC2DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC2DE_Enabled = 0x1
	// Position of CC1DE field.
	TIM_DIER_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIM_DIER_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIM_DIER_CC1DE = 0x200
	// CCx DMA request disabled
	TIM_DIER_CC1DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC1DE_Enabled = 0x1
	// Position of UDE field.
	TIM_DIER_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIM_DIER_UDE_Msk = 0x100
	// Bit UDE.
	TIM_DIER_UDE = 0x100
	// Update DMA request disabled
	TIM_DIER_UDE_Disabled = 0x0
	// Update DMA request enabled
	TIM_DIER_UDE_Enabled = 0x1
	// Position of TIE field.
	TIM_DIER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	TIM_DIER_TIE_Msk = 0x40
	// Bit TIE.
	TIM_DIER_TIE = 0x40
	// Trigger interrupt disabled
	TIM_DIER_TIE_Disabled = 0x0
	// Trigger interrupt enabled
	TIM_DIER_TIE_Enabled = 0x1
	// Position of CC4IE field.
	TIM_DIER_CC4IE_Pos = 0x4
	// Bit mask of CC4IE field.
	TIM_DIER_CC4IE_Msk = 0x10
	// Bit CC4IE.
	TIM_DIER_CC4IE = 0x10
	// CCx interrupt disabled
	TIM_DIER_CC4IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC4IE_Enabled = 0x1
	// Position of CC3IE field.
	TIM_DIER_CC3IE_Pos = 0x3
	// Bit mask of CC3IE field.
	TIM_DIER_CC3IE_Msk = 0x8
	// Bit CC3IE.
	TIM_DIER_CC3IE = 0x8
	// CCx interrupt disabled
	TIM_DIER_CC3IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC3IE_Enabled = 0x1
	// Position of CC2IE field.
	TIM_DIER_CC2IE_Pos = 0x2
	// Bit mask of CC2IE field.
	TIM_DIER_CC2IE_Msk = 0x4
	// Bit CC2IE.
	TIM_DIER_CC2IE = 0x4
	// CCx interrupt disabled
	TIM_DIER_CC2IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC2IE_Enabled = 0x1
	// Position of CC1IE field.
	TIM_DIER_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIM_DIER_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIM_DIER_CC1IE = 0x2
	// CCx interrupt disabled
	TIM_DIER_CC1IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC1IE_Enabled = 0x1
	// Position of UIE field.
	TIM_DIER_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIM_DIER_UIE_Msk = 0x1
	// Bit UIE.
	TIM_DIER_UIE = 0x1
	// Update interrupt disabled
	TIM_DIER_UIE_Disabled = 0x0
	// Update interrupt enabled
	TIM_DIER_UIE_Enabled = 0x1

	// SR: status register
	// Position of CC4OF field.
	TIM_SR_CC4OF_Pos = 0xc
	// Bit mask of CC4OF field.
	TIM_SR_CC4OF_Msk = 0x1000
	// Bit CC4OF.
	TIM_SR_CC4OF = 0x1000
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC4OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC4OF_Clear = 0x0
	// Position of CC3OF field.
	TIM_SR_CC3OF_Pos = 0xb
	// Bit mask of CC3OF field.
	TIM_SR_CC3OF_Msk = 0x800
	// Bit CC3OF.
	TIM_SR_CC3OF = 0x800
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC3OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC3OF_Clear = 0x0
	// Position of CC2OF field.
	TIM_SR_CC2OF_Pos = 0xa
	// Bit mask of CC2OF field.
	TIM_SR_CC2OF_Msk = 0x400
	// Bit CC2OF.
	TIM_SR_CC2OF = 0x400
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC2OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC2OF_Clear = 0x0
	// Position of CC1OF field.
	TIM_SR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIM_SR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIM_SR_CC1OF = 0x200
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC1OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC1OF_Clear = 0x0
	// Position of TIF field.
	TIM_SR_TIF_Pos = 0x6
	// Bit mask of TIF field.
	TIM_SR_TIF_Msk = 0x40
	// Bit TIF.
	TIM_SR_TIF = 0x40
	// No trigger event occurred
	TIM_SR_TIF_NoTrigger = 0x0
	// Trigger interrupt pending
	TIM_SR_TIF_Trigger = 0x1
	// Clear flag
	TIM_SR_TIF_Clear = 0x0
	// Position of CC4IF field.
	TIM_SR_CC4IF_Pos = 0x4
	// Bit mask of CC4IF field.
	TIM_SR_CC4IF_Msk = 0x10
	// Bit CC4IF.
	TIM_SR_CC4IF = 0x10
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC4IF_Match = 0x1
	// Clear flag
	TIM_SR_CC4IF_Clear = 0x0
	// Position of CC3IF field.
	TIM_SR_CC3IF_Pos = 0x3
	// Bit mask of CC3IF field.
	TIM_SR_CC3IF_Msk = 0x8
	// Bit CC3IF.
	TIM_SR_CC3IF = 0x8
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC3IF_Match = 0x1
	// Clear flag
	TIM_SR_CC3IF_Clear = 0x0
	// Position of CC2IF field.
	TIM_SR_CC2IF_Pos = 0x2
	// Bit mask of CC2IF field.
	TIM_SR_CC2IF_Msk = 0x4
	// Bit CC2IF.
	TIM_SR_CC2IF = 0x4
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC2IF_Match = 0x1
	// Clear flag
	TIM_SR_CC2IF_Clear = 0x0
	// Position of CC1IF field.
	TIM_SR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIM_SR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIM_SR_CC1IF = 0x2
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC1IF_Match = 0x1
	// Clear flag
	TIM_SR_CC1IF_Clear = 0x0
	// Position of UIF field.
	TIM_SR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIM_SR_UIF_Msk = 0x1
	// Bit UIF.
	TIM_SR_UIF = 0x1
	// No update occurred
	TIM_SR_UIF_Clear = 0x0
	// Update interrupt pending.
	TIM_SR_UIF_UpdatePending = 0x1

	// EGR: event generation register
	// Position of TG field.
	TIM_EGR_TG_Pos = 0x6
	// Bit mask of TG field.
	TIM_EGR_TG_Msk = 0x40
	// Bit TG.
	TIM_EGR_TG = 0x40
	// The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
	TIM_EGR_TG_Trigger = 0x1
	// Position of CC4G field.
	TIM_EGR_CC4G_Pos = 0x4
	// Bit mask of CC4G field.
	TIM_EGR_CC4G_Msk = 0x10
	// Bit CC4G.
	TIM_EGR_CC4G = 0x10
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC4G_Trigger = 0x1
	// Position of CC3G field.
	TIM_EGR_CC3G_Pos = 0x3
	// Bit mask of CC3G field.
	TIM_EGR_CC3G_Msk = 0x8
	// Bit CC3G.
	TIM_EGR_CC3G = 0x8
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC3G_Trigger = 0x1
	// Position of CC2G field.
	TIM_EGR_CC2G_Pos = 0x2
	// Bit mask of CC2G field.
	TIM_EGR_CC2G_Msk = 0x4
	// Bit CC2G.
	TIM_EGR_CC2G = 0x4
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC2G_Trigger = 0x1
	// Position of CC1G field.
	TIM_EGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIM_EGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIM_EGR_CC1G = 0x2
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC1G_Trigger = 0x1
	// Position of UG field.
	TIM_EGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIM_EGR_UG_Msk = 0x1
	// Bit UG.
	TIM_EGR_UG = 0x1
	// Re-initializes the timer counter and generates an update of the registers.
	TIM_EGR_UG_Update = 0x1

	// CCMR1_Output: capture/compare mode register 1 (output mode)
	// Position of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Pos = 0xf
	// Bit mask of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Msk = 0x8000
	// Bit OC2CE.
	TIM_CCMR1_Output_OC2CE = 0x8000
	// Position of OC2M field.
	TIM_CCMR1_Output_OC2M_Pos = 0xc
	// Bit mask of OC2M field.
	TIM_CCMR1_Output_OC2M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC2M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC2M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC2M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC2M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC2M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC2M_PwmMode2 = 0x7
	// Position of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Pos = 0xb
	// Bit mask of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Msk = 0x800
	// Bit OC2PE.
	TIM_CCMR1_Output_OC2PE = 0x800
	// Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
	TIM_CCMR1_Output_OC2PE_Disabled = 0x0
	// Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC2PE_Enabled = 0x1
	// Position of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Pos = 0xa
	// Bit mask of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Msk = 0x400
	// Bit OC2FE.
	TIM_CCMR1_Output_OC2FE = 0x400
	// Position of CC2S field.
	TIM_CCMR1_Output_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Output_CC2S_Msk = 0x300
	// CC2 channel is configured as output
	TIM_CCMR1_Output_CC2S_Output = 0x0
	// Position of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Pos = 0x7
	// Bit mask of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Msk = 0x80
	// Bit OC1CE.
	TIM_CCMR1_Output_OC1CE = 0x80
	// Position of OC1M field.
	TIM_CCMR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIM_CCMR1_Output_OC1M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC1M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC1M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC1M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC1M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC1M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC1M_PwmMode2 = 0x7
	// Position of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIM_CCMR1_Output_OC1PE = 0x8
	// Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
	TIM_CCMR1_Output_OC1PE_Disabled = 0x0
	// Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC1PE_Enabled = 0x1
	// Position of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIM_CCMR1_Output_OC1FE = 0x4
	// Position of CC1S field.
	TIM_CCMR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Output_CC1S_Msk = 0x3
	// CC1 channel is configured as output
	TIM_CCMR1_Output_CC1S_Output = 0x0
	// Position of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Pos = 0x10
	// Bit mask of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Msk = 0x10000
	// Bit OC1M_3.
	TIM_CCMR1_Output_OC1M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC1M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC1M_3_Extended = 0x1
	// Position of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Pos = 0x18
	// Bit mask of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Msk = 0x1000000
	// Bit OC2M_3.
	TIM_CCMR1_Output_OC2M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC2M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC2M_3_Extended = 0x1

	// CCMR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC2F field.
	TIM_CCMR1_Input_IC2F_Pos = 0xc
	// Bit mask of IC2F field.
	TIM_CCMR1_Input_IC2F_Msk = 0xf000
	// Position of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Pos = 0xa
	// Bit mask of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Msk = 0xc00
	// Position of CC2S field.
	TIM_CCMR1_Input_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Input_CC2S_Msk = 0x300
	// CC2 channel is configured as input, IC2 is mapped on TI2
	TIM_CCMR1_Input_CC2S_TI2 = 0x1
	// CC2 channel is configured as input, IC2 is mapped on TI1
	TIM_CCMR1_Input_CC2S_TI1 = 0x2
	// CC2 channel is configured as input, IC2 is mapped on TRC
	TIM_CCMR1_Input_CC2S_TRC = 0x3
	// Position of IC1F field.
	TIM_CCMR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIM_CCMR1_Input_IC1F_Msk = 0xf0
	// No filter, sampling is done at fDTS
	TIM_CCMR1_Input_IC1F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR1_Input_IC1F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR1_Input_IC1F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR1_Input_IC1F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N8 = 0xf
	// Position of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Msk = 0xc
	// Position of CC1S field.
	TIM_CCMR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Input_CC1S_Msk = 0x3
	// CC1 channel is configured as input, IC1 is mapped on TI1
	TIM_CCMR1_Input_CC1S_TI1 = 0x1
	// CC1 channel is configured as input, IC1 is mapped on TI2
	TIM_CCMR1_Input_CC1S_TI2 = 0x2
	// CC1 channel is configured as input, IC1 is mapped on TRC
	TIM_CCMR1_Input_CC1S_TRC = 0x3

	// CCMR2_Output: capture/compare mode register 2 (output mode)
	// Position of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Pos = 0xf
	// Bit mask of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Msk = 0x8000
	// Bit OC4CE.
	TIM_CCMR2_Output_OC4CE = 0x8000
	// Position of OC4M field.
	TIM_CCMR2_Output_OC4M_Pos = 0xc
	// Bit mask of OC4M field.
	TIM_CCMR2_Output_OC4M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC4M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC4M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC4M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC4M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC4M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC4M_PwmMode2 = 0x7
	// Position of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Pos = 0xb
	// Bit mask of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Msk = 0x800
	// Bit OC4PE.
	TIM_CCMR2_Output_OC4PE = 0x800
	// Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
	TIM_CCMR2_Output_OC4PE_Disabled = 0x0
	// Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC4PE_Enabled = 0x1
	// Position of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Pos = 0xa
	// Bit mask of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Msk = 0x400
	// Bit OC4FE.
	TIM_CCMR2_Output_OC4FE = 0x400
	// Position of CC4S field.
	TIM_CCMR2_Output_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Output_CC4S_Msk = 0x300
	// CC4 channel is configured as output
	TIM_CCMR2_Output_CC4S_Output = 0x0
	// Position of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Pos = 0x7
	// Bit mask of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Msk = 0x80
	// Bit OC3CE.
	TIM_CCMR2_Output_OC3CE = 0x80
	// Position of OC3M field.
	TIM_CCMR2_Output_OC3M_Pos = 0x4
	// Bit mask of OC3M field.
	TIM_CCMR2_Output_OC3M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC3M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC3M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC3M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC3M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC3M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC3M_PwmMode2 = 0x7
	// Position of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Pos = 0x3
	// Bit mask of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Msk = 0x8
	// Bit OC3PE.
	TIM_CCMR2_Output_OC3PE = 0x8
	// Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
	TIM_CCMR2_Output_OC3PE_Disabled = 0x0
	// Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC3PE_Enabled = 0x1
	// Position of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Pos = 0x2
	// Bit mask of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Msk = 0x4
	// Bit OC3FE.
	TIM_CCMR2_Output_OC3FE = 0x4
	// Position of CC3S field.
	TIM_CCMR2_Output_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Output_CC3S_Msk = 0x3
	// CC3 channel is configured as output
	TIM_CCMR2_Output_CC3S_Output = 0x0
	// Position of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Pos = 0x10
	// Bit mask of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Msk = 0x10000
	// Bit OC3M_3.
	TIM_CCMR2_Output_OC3M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC3M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC3M_3_Extended = 0x1
	// Position of OC4M_3 field.
	TIM_CCMR2_Output_OC4M_3_Pos = 0x18
	// Bit mask of OC4M_3 field.
	TIM_CCMR2_Output_OC4M_3_Msk = 0x1000000
	// Bit OC4M_3.
	TIM_CCMR2_Output_OC4M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC4M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC4M_3_Extended = 0x1

	// CCMR2_Input: capture/compare mode register 2 (input mode)
	// Position of IC4F field.
	TIM_CCMR2_Input_IC4F_Pos = 0xc
	// Bit mask of IC4F field.
	TIM_CCMR2_Input_IC4F_Msk = 0xf000
	// Position of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Pos = 0xa
	// Bit mask of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Msk = 0xc00
	// Position of CC4S field.
	TIM_CCMR2_Input_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Input_CC4S_Msk = 0x300
	// CC4 channel is configured as input, IC4 is mapped on TI4
	TIM_CCMR2_Input_CC4S_TI4 = 0x1
	// CC4 channel is configured as input, IC4 is mapped on TI3
	TIM_CCMR2_Input_CC4S_TI3 = 0x2
	// CC4 channel is configured as input, IC4 is mapped on TRC
	TIM_CCMR2_Input_CC4S_TRC = 0x3
	// Position of IC3F field.
	TIM_CCMR2_Input_IC3F_Pos = 0x4
	// Bit mask of IC3F field.
	TIM_CCMR2_Input_IC3F_Msk = 0xf0
	// Position of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Pos = 0x2
	// Bit mask of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Msk = 0xc
	// Position of CC3S field.
	TIM_CCMR2_Input_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Input_CC3S_Msk = 0x3
	// CC3 channel is configured as input, IC3 is mapped on TI3
	TIM_CCMR2_Input_CC3S_TI3 = 0x1
	// CC3 channel is configured as input, IC3 is mapped on TI4
	TIM_CCMR2_Input_CC3S_TI4 = 0x2
	// CC3 channel is configured as input, IC3 is mapped on TRC
	TIM_CCMR2_Input_CC3S_TRC = 0x3

	// CCER: capture/compare enable register
	// Position of CC4NP field.
	TIM_CCER_CC4NP_Pos = 0xf
	// Bit mask of CC4NP field.
	TIM_CCER_CC4NP_Msk = 0x8000
	// Bit CC4NP.
	TIM_CCER_CC4NP = 0x8000
	// Position of CC4P field.
	TIM_CCER_CC4P_Pos = 0xd
	// Bit mask of CC4P field.
	TIM_CCER_CC4P_Msk = 0x2000
	// Bit CC4P.
	TIM_CCER_CC4P = 0x2000
	// Position of CC4E field.
	TIM_CCER_CC4E_Pos = 0xc
	// Bit mask of CC4E field.
	TIM_CCER_CC4E_Msk = 0x1000
	// Bit CC4E.
	TIM_CCER_CC4E = 0x1000
	// Position of CC3NP field.
	TIM_CCER_CC3NP_Pos = 0xb
	// Bit mask of CC3NP field.
	TIM_CCER_CC3NP_Msk = 0x800
	// Bit CC3NP.
	TIM_CCER_CC3NP = 0x800
	// Position of CC3P field.
	TIM_CCER_CC3P_Pos = 0x9
	// Bit mask of CC3P field.
	TIM_CCER_CC3P_Msk = 0x200
	// Bit CC3P.
	TIM_CCER_CC3P = 0x200
	// Position of CC3E field.
	TIM_CCER_CC3E_Pos = 0x8
	// Bit mask of CC3E field.
	TIM_CCER_CC3E_Msk = 0x100
	// Bit CC3E.
	TIM_CCER_CC3E = 0x100
	// Position of CC2NP field.
	TIM_CCER_CC2NP_Pos = 0x7
	// Bit mask of CC2NP field.
	TIM_CCER_CC2NP_Msk = 0x80
	// Bit CC2NP.
	TIM_CCER_CC2NP = 0x80
	// Position of CC2P field.
	TIM_CCER_CC2P_Pos = 0x5
	// Bit mask of CC2P field.
	TIM_CCER_CC2P_Msk = 0x20
	// Bit CC2P.
	TIM_CCER_CC2P = 0x20
	// Position of CC2E field.
	TIM_CCER_CC2E_Pos = 0x4
	// Bit mask of CC2E field.
	TIM_CCER_CC2E_Msk = 0x10
	// Bit CC2E.
	TIM_CCER_CC2E = 0x10
	// Position of CC1NP field.
	TIM_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIM_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIM_CCER_CC1NP = 0x8
	// Position of CC1P field.
	TIM_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIM_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIM_CCER_CC1P = 0x2
	// Position of CC1E field.
	TIM_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIM_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIM_CCER_CC1E = 0x1

	// CNT: counter
	// Position of CNT field.
	TIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIM_CNT_CNT_Msk = 0xffffffff

	// PSC: prescaler
	// Position of PSC field.
	TIM_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIM_PSC_PSC_Msk = 0xffff

	// ARR: auto-reload register
	// Position of ARR field.
	TIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	TIM_ARR_ARR_Msk = 0xffffffff

	// CCR1: capture/compare register
	// Position of CCR field.
	TIM_CCR_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIM_CCR_CCR_Msk = 0xffffffff

	// DCR: DMA control register
	// Position of DBL field.
	TIM_DCR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIM_DCR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIM_DCR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIM_DCR_DBA_Msk = 0x1f

	// DMAR: DMA address for full transfer
	// Position of DMAB field.
	TIM_DMAR_DMAB_Pos = 0x0
	// Bit mask of DMAB field.
	TIM_DMAR_DMAB_Msk = 0xffff

	// OR: TIM2 option register
	// Position of ETR_RMP field.
	TIM_OR_ETR_RMP_Pos = 0x0
	// Bit mask of ETR_RMP field.
	TIM_OR_ETR_RMP_Msk = 0x7
	// Position of TI4_RMP field.
	TIM_OR_TI4_RMP_Pos = 0x3
	// Bit mask of TI4_RMP field.
	TIM_OR_TI4_RMP_Msk = 0x18
)

// Constants for LPTIM1: Low power timer
const (
	// ISR: Interrupt and Status Register
	// Position of DOWN field.
	LPTIM_ISR_DOWN_Pos = 0x6
	// Bit mask of DOWN field.
	LPTIM_ISR_DOWN_Msk = 0x40
	// Bit DOWN.
	LPTIM_ISR_DOWN = 0x40
	// Position of UP field.
	LPTIM_ISR_UP_Pos = 0x5
	// Bit mask of UP field.
	LPTIM_ISR_UP_Msk = 0x20
	// Bit UP.
	LPTIM_ISR_UP = 0x20
	// Position of ARROK field.
	LPTIM_ISR_ARROK_Pos = 0x4
	// Bit mask of ARROK field.
	LPTIM_ISR_ARROK_Msk = 0x10
	// Bit ARROK.
	LPTIM_ISR_ARROK = 0x10
	// Position of CMPOK field.
	LPTIM_ISR_CMPOK_Pos = 0x3
	// Bit mask of CMPOK field.
	LPTIM_ISR_CMPOK_Msk = 0x8
	// Bit CMPOK.
	LPTIM_ISR_CMPOK = 0x8
	// Position of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Pos = 0x2
	// Bit mask of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Msk = 0x4
	// Bit EXTTRIG.
	LPTIM_ISR_EXTTRIG = 0x4
	// Position of ARRM field.
	LPTIM_ISR_ARRM_Pos = 0x1
	// Bit mask of ARRM field.
	LPTIM_ISR_ARRM_Msk = 0x2
	// Bit ARRM.
	LPTIM_ISR_ARRM = 0x2
	// Position of CMPM field.
	LPTIM_ISR_CMPM_Pos = 0x0
	// Bit mask of CMPM field.
	LPTIM_ISR_CMPM_Msk = 0x1
	// Bit CMPM.
	LPTIM_ISR_CMPM = 0x1

	// ICR: Interrupt Clear Register
	// Position of DOWNCF field.
	LPTIM_ICR_DOWNCF_Pos = 0x6
	// Bit mask of DOWNCF field.
	LPTIM_ICR_DOWNCF_Msk = 0x40
	// Bit DOWNCF.
	LPTIM_ICR_DOWNCF = 0x40
	// Position of UPCF field.
	LPTIM_ICR_UPCF_Pos = 0x5
	// Bit mask of UPCF field.
	LPTIM_ICR_UPCF_Msk = 0x20
	// Bit UPCF.
	LPTIM_ICR_UPCF = 0x20
	// Position of ARROKCF field.
	LPTIM_ICR_ARROKCF_Pos = 0x4
	// Bit mask of ARROKCF field.
	LPTIM_ICR_ARROKCF_Msk = 0x10
	// Bit ARROKCF.
	LPTIM_ICR_ARROKCF = 0x10
	// Position of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Pos = 0x3
	// Bit mask of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Msk = 0x8
	// Bit CMPOKCF.
	LPTIM_ICR_CMPOKCF = 0x8
	// Position of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Pos = 0x2
	// Bit mask of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Msk = 0x4
	// Bit EXTTRIGCF.
	LPTIM_ICR_EXTTRIGCF = 0x4
	// Position of ARRMCF field.
	LPTIM_ICR_ARRMCF_Pos = 0x1
	// Bit mask of ARRMCF field.
	LPTIM_ICR_ARRMCF_Msk = 0x2
	// Bit ARRMCF.
	LPTIM_ICR_ARRMCF = 0x2
	// Position of CMPMCF field.
	LPTIM_ICR_CMPMCF_Pos = 0x0
	// Bit mask of CMPMCF field.
	LPTIM_ICR_CMPMCF_Msk = 0x1
	// Bit CMPMCF.
	LPTIM_ICR_CMPMCF = 0x1

	// IER: Interrupt Enable Register
	// Position of DOWNIE field.
	LPTIM_IER_DOWNIE_Pos = 0x6
	// Bit mask of DOWNIE field.
	LPTIM_IER_DOWNIE_Msk = 0x40
	// Bit DOWNIE.
	LPTIM_IER_DOWNIE = 0x40
	// Position of UPIE field.
	LPTIM_IER_UPIE_Pos = 0x5
	// Bit mask of UPIE field.
	LPTIM_IER_UPIE_Msk = 0x20
	// Bit UPIE.
	LPTIM_IER_UPIE = 0x20
	// Position of ARROKIE field.
	LPTIM_IER_ARROKIE_Pos = 0x4
	// Bit mask of ARROKIE field.
	LPTIM_IER_ARROKIE_Msk = 0x10
	// Bit ARROKIE.
	LPTIM_IER_ARROKIE = 0x10
	// Position of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Pos = 0x3
	// Bit mask of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Msk = 0x8
	// Bit CMPOKIE.
	LPTIM_IER_CMPOKIE = 0x8
	// Position of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Pos = 0x2
	// Bit mask of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Msk = 0x4
	// Bit EXTTRIGIE.
	LPTIM_IER_EXTTRIGIE = 0x4
	// Position of ARRMIE field.
	LPTIM_IER_ARRMIE_Pos = 0x1
	// Bit mask of ARRMIE field.
	LPTIM_IER_ARRMIE_Msk = 0x2
	// Bit ARRMIE.
	LPTIM_IER_ARRMIE = 0x2
	// Position of CMPMIE field.
	LPTIM_IER_CMPMIE_Pos = 0x0
	// Bit mask of CMPMIE field.
	LPTIM_IER_CMPMIE_Msk = 0x1
	// Bit CMPMIE.
	LPTIM_IER_CMPMIE = 0x1

	// CFGR: Configuration Register
	// Position of ENC field.
	LPTIM_CFGR_ENC_Pos = 0x18
	// Bit mask of ENC field.
	LPTIM_CFGR_ENC_Msk = 0x1000000
	// Bit ENC.
	LPTIM_CFGR_ENC = 0x1000000
	// Position of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Pos = 0x17
	// Bit mask of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Msk = 0x800000
	// Bit COUNTMODE.
	LPTIM_CFGR_COUNTMODE = 0x800000
	// Position of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Pos = 0x16
	// Bit mask of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Msk = 0x400000
	// Bit PRELOAD.
	LPTIM_CFGR_PRELOAD = 0x400000
	// Position of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Pos = 0x15
	// Bit mask of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Msk = 0x200000
	// Bit WAVPOL.
	LPTIM_CFGR_WAVPOL = 0x200000
	// Position of WAVE field.
	LPTIM_CFGR_WAVE_Pos = 0x14
	// Bit mask of WAVE field.
	LPTIM_CFGR_WAVE_Msk = 0x100000
	// Bit WAVE.
	LPTIM_CFGR_WAVE = 0x100000
	// Position of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Pos = 0x13
	// Bit mask of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Msk = 0x80000
	// Bit TIMOUT.
	LPTIM_CFGR_TIMOUT = 0x80000
	// Position of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Pos = 0x11
	// Bit mask of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Msk = 0x60000
	// Position of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Pos = 0xd
	// Bit mask of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Msk = 0xe000
	// Position of PRESC field.
	LPTIM_CFGR_PRESC_Pos = 0x9
	// Bit mask of PRESC field.
	LPTIM_CFGR_PRESC_Msk = 0xe00
	// Position of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Pos = 0x6
	// Bit mask of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Msk = 0xc0
	// Position of CKFLT field.
	LPTIM_CFGR_CKFLT_Pos = 0x3
	// Bit mask of CKFLT field.
	LPTIM_CFGR_CKFLT_Msk = 0x18
	// Position of CKPOL field.
	LPTIM_CFGR_CKPOL_Pos = 0x1
	// Bit mask of CKPOL field.
	LPTIM_CFGR_CKPOL_Msk = 0x6
	// Position of CKSEL field.
	LPTIM_CFGR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	LPTIM_CFGR_CKSEL_Msk = 0x1
	// Bit CKSEL.
	LPTIM_CFGR_CKSEL = 0x1

	// CR: Control Register
	// Position of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Pos = 0x2
	// Bit mask of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Msk = 0x4
	// Bit CNTSTRT.
	LPTIM_CR_CNTSTRT = 0x4
	// Position of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Pos = 0x1
	// Bit mask of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Msk = 0x2
	// Bit SNGSTRT.
	LPTIM_CR_SNGSTRT = 0x2
	// Position of ENABLE field.
	LPTIM_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPTIM_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	LPTIM_CR_ENABLE = 0x1

	// CMP: Compare Register
	// Position of CMP field.
	LPTIM_CMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	LPTIM_CMP_CMP_Msk = 0xffff

	// ARR: Autoreload Register
	// Position of ARR field.
	LPTIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	LPTIM_ARR_ARR_Msk = 0xffff

	// CNT: Counter Register
	// Position of CNT field.
	LPTIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	LPTIM_CNT_CNT_Msk = 0xffff
)

// Constants for USART1: Universal synchronous asynchronous receiver transmitter
const (
	// CR1: Control register 1
	// Position of M1 field.
	USART_CR1_M1_Pos = 0x1c
	// Bit mask of M1 field.
	USART_CR1_M1_Msk = 0x10000000
	// Bit M1.
	USART_CR1_M1 = 0x10000000
	// Use M0 to set the data bits
	USART_CR1_M1_M0 = 0x0
	// 1 start bit, 7 data bits, n stop bits
	USART_CR1_M1_Bit7 = 0x1
	// Position of EOBIE field.
	USART_CR1_EOBIE_Pos = 0x1b
	// Bit mask of EOBIE field.
	USART_CR1_EOBIE_Msk = 0x8000000
	// Bit EOBIE.
	USART_CR1_EOBIE = 0x8000000
	// Interrupt is inhibited
	USART_CR1_EOBIE_Disabled = 0x0
	// A USART interrupt is generated when the EOBF flag is set in the ISR register
	USART_CR1_EOBIE_Enabled = 0x1
	// Position of RTOIE field.
	USART_CR1_RTOIE_Pos = 0x1a
	// Bit mask of RTOIE field.
	USART_CR1_RTOIE_Msk = 0x4000000
	// Bit RTOIE.
	USART_CR1_RTOIE = 0x4000000
	// Interrupt is inhibited
	USART_CR1_RTOIE_Disabled = 0x0
	// An USART interrupt is generated when the RTOF bit is set in the ISR register
	USART_CR1_RTOIE_Enabled = 0x1
	// Position of OVER8 field.
	USART_CR1_OVER8_Pos = 0xf
	// Bit mask of OVER8 field.
	USART_CR1_OVER8_Msk = 0x8000
	// Bit OVER8.
	USART_CR1_OVER8 = 0x8000
	// Oversampling by 16
	USART_CR1_OVER8_Oversampling16 = 0x0
	// Oversampling by 8
	USART_CR1_OVER8_Oversampling8 = 0x1
	// Position of CMIE field.
	USART_CR1_CMIE_Pos = 0xe
	// Bit mask of CMIE field.
	USART_CR1_CMIE_Msk = 0x4000
	// Bit CMIE.
	USART_CR1_CMIE = 0x4000
	// Interrupt is disabled
	USART_CR1_CMIE_Disabled = 0x0
	// Interrupt is generated when the CMF bit is set in the ISR register
	USART_CR1_CMIE_Enabled = 0x1
	// Position of MME field.
	USART_CR1_MME_Pos = 0xd
	// Bit mask of MME field.
	USART_CR1_MME_Msk = 0x2000
	// Bit MME.
	USART_CR1_MME = 0x2000
	// Receiver in active mode permanently
	USART_CR1_MME_Disabled = 0x0
	// Receiver can switch between mute mode and active mode
	USART_CR1_MME_Enabled = 0x1
	// Position of M0 field.
	USART_CR1_M0_Pos = 0xc
	// Bit mask of M0 field.
	USART_CR1_M0_Msk = 0x1000
	// Bit M0.
	USART_CR1_M0 = 0x1000
	// 1 start bit, 8 data bits, n stop bits
	USART_CR1_M0_Bit8 = 0x0
	// 1 start bit, 9 data bits, n stop bits
	USART_CR1_M0_Bit9 = 0x1
	// Position of WAKE field.
	USART_CR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	USART_CR1_WAKE_Msk = 0x800
	// Bit WAKE.
	USART_CR1_WAKE = 0x800
	// Idle line
	USART_CR1_WAKE_Idle = 0x0
	// Address mask
	USART_CR1_WAKE_Address = 0x1
	// Position of PCE field.
	USART_CR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	USART_CR1_PCE_Msk = 0x400
	// Bit PCE.
	USART_CR1_PCE = 0x400
	// Parity control disabled
	USART_CR1_PCE_Disabled = 0x0
	// Parity control enabled
	USART_CR1_PCE_Enabled = 0x1
	// Position of PS field.
	USART_CR1_PS_Pos = 0x9
	// Bit mask of PS field.
	USART_CR1_PS_Msk = 0x200
	// Bit PS.
	USART_CR1_PS = 0x200
	// Even parity
	USART_CR1_PS_Even = 0x0
	// Odd parity
	USART_CR1_PS_Odd = 0x1
	// Position of PEIE field.
	USART_CR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	USART_CR1_PEIE_Msk = 0x100
	// Bit PEIE.
	USART_CR1_PEIE = 0x100
	// Interrupt is disabled
	USART_CR1_PEIE_Disabled = 0x0
	// Interrupt is generated whenever PE=1 in the ISR register
	USART_CR1_PEIE_Enabled = 0x1
	// Position of TXEIE field.
	USART_CR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	USART_CR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	USART_CR1_TXEIE = 0x80
	// Interrupt is disabled
	USART_CR1_TXEIE_Disabled = 0x0
	// Interrupt is generated whenever TXE=1 in the ISR register
	USART_CR1_TXEIE_Enabled = 0x1
	// Position of TCIE field.
	USART_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	USART_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	USART_CR1_TCIE = 0x40
	// Interrupt is disabled
	USART_CR1_TCIE_Disabled = 0x0
	// Interrupt is generated whenever TC=1 in the ISR register
	USART_CR1_TCIE_Enabled = 0x1
	// Position of RXNEIE field.
	USART_CR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	USART_CR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	USART_CR1_RXNEIE = 0x20
	// Interrupt is disabled
	USART_CR1_RXNEIE_Disabled = 0x0
	// Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register
	USART_CR1_RXNEIE_Enabled = 0x1
	// Position of IDLEIE field.
	USART_CR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	USART_CR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	USART_CR1_IDLEIE = 0x10
	// Interrupt is disabled
	USART_CR1_IDLEIE_Disabled = 0x0
	// Interrupt is generated whenever IDLE=1 in the ISR register
	USART_CR1_IDLEIE_Enabled = 0x1
	// Position of TE field.
	USART_CR1_TE_Pos = 0x3
	// Bit mask of TE field.
	USART_CR1_TE_Msk = 0x8
	// Bit TE.
	USART_CR1_TE = 0x8
	// Transmitter is disabled
	USART_CR1_TE_Disabled = 0x0
	// Transmitter is enabled
	USART_CR1_TE_Enabled = 0x1
	// Position of RE field.
	USART_CR1_RE_Pos = 0x2
	// Bit mask of RE field.
	USART_CR1_RE_Msk = 0x4
	// Bit RE.
	USART_CR1_RE = 0x4
	// Receiver is disabled
	USART_CR1_RE_Disabled = 0x0
	// Receiver is enabled
	USART_CR1_RE_Enabled = 0x1
	// Position of UESM field.
	USART_CR1_UESM_Pos = 0x1
	// Bit mask of UESM field.
	USART_CR1_UESM_Msk = 0x2
	// Bit UESM.
	USART_CR1_UESM = 0x2
	// USART not able to wake up the MCU from Stop mode
	USART_CR1_UESM_Disabled = 0x0
	// USART able to wake up the MCU from Stop mode
	USART_CR1_UESM_Enabled = 0x1
	// Position of UE field.
	USART_CR1_UE_Pos = 0x0
	// Bit mask of UE field.
	USART_CR1_UE_Msk = 0x1
	// Bit UE.
	USART_CR1_UE = 0x1
	// UART is disabled
	USART_CR1_UE_Disabled = 0x0
	// UART is enabled
	USART_CR1_UE_Enabled = 0x1
	// Position of DEDT field.
	USART_CR1_DEDT_Pos = 0x10
	// Bit mask of DEDT field.
	USART_CR1_DEDT_Msk = 0x1f0000
	// Position of DEAT field.
	USART_CR1_DEAT_Pos = 0x15
	// Bit mask of DEAT field.
	USART_CR1_DEAT_Msk = 0x3e00000

	// CR2: Control register 2
	// Position of RTOEN field.
	USART_CR2_RTOEN_Pos = 0x17
	// Bit mask of RTOEN field.
	USART_CR2_RTOEN_Msk = 0x800000
	// Bit RTOEN.
	USART_CR2_RTOEN = 0x800000
	// Receiver timeout feature disabled
	USART_CR2_RTOEN_Disabled = 0x0
	// Receiver timeout feature enabled
	USART_CR2_RTOEN_Enabled = 0x1
	// Position of ABREN field.
	USART_CR2_ABREN_Pos = 0x14
	// Bit mask of ABREN field.
	USART_CR2_ABREN_Msk = 0x100000
	// Bit ABREN.
	USART_CR2_ABREN = 0x100000
	// Auto baud rate detection is disabled
	USART_CR2_ABREN_Disabled = 0x0
	// Auto baud rate detection is enabled
	USART_CR2_ABREN_Enabled = 0x1
	// Position of MSBFIRST field.
	USART_CR2_MSBFIRST_Pos = 0x13
	// Bit mask of MSBFIRST field.
	USART_CR2_MSBFIRST_Msk = 0x80000
	// Bit MSBFIRST.
	USART_CR2_MSBFIRST = 0x80000
	// data is transmitted/received with data bit 0 first, following the start bit
	USART_CR2_MSBFIRST_LSB = 0x0
	// data is transmitted/received with MSB (bit 7/8/9) first, following the start bit
	USART_CR2_MSBFIRST_MSB = 0x1
	// Position of DATAINV field.
	USART_CR2_DATAINV_Pos = 0x12
	// Bit mask of DATAINV field.
	USART_CR2_DATAINV_Msk = 0x40000
	// Bit DATAINV.
	USART_CR2_DATAINV = 0x40000
	// Logical data from the data register are send/received in positive/direct logic
	USART_CR2_DATAINV_Positive = 0x0
	// Logical data from the data register are send/received in negative/inverse logic
	USART_CR2_DATAINV_Negative = 0x1
	// Position of TXINV field.
	USART_CR2_TXINV_Pos = 0x11
	// Bit mask of TXINV field.
	USART_CR2_TXINV_Msk = 0x20000
	// Bit TXINV.
	USART_CR2_TXINV = 0x20000
	// TX pin signal works using the standard logic levels
	USART_CR2_TXINV_Standard = 0x0
	// TX pin signal values are inverted
	USART_CR2_TXINV_Inverted = 0x1
	// Position of RXINV field.
	USART_CR2_RXINV_Pos = 0x10
	// Bit mask of RXINV field.
	USART_CR2_RXINV_Msk = 0x10000
	// Bit RXINV.
	USART_CR2_RXINV = 0x10000
	// RX pin signal works using the standard logic levels
	USART_CR2_RXINV_Standard = 0x0
	// RX pin signal values are inverted
	USART_CR2_RXINV_Inverted = 0x1
	// Position of SWAP field.
	USART_CR2_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	USART_CR2_SWAP_Msk = 0x8000
	// Bit SWAP.
	USART_CR2_SWAP = 0x8000
	// TX/RX pins are used as defined in standard pinout
	USART_CR2_SWAP_Standard = 0x0
	// The TX and RX pins functions are swapped
	USART_CR2_SWAP_Swapped = 0x1
	// Position of LINEN field.
	USART_CR2_LINEN_Pos = 0xe
	// Bit mask of LINEN field.
	USART_CR2_LINEN_Msk = 0x4000
	// Bit LINEN.
	USART_CR2_LINEN = 0x4000
	// LIN mode disabled
	USART_CR2_LINEN_Disabled = 0x0
	// LIN mode enabled
	USART_CR2_LINEN_Enabled = 0x1
	// Position of STOP field.
	USART_CR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	USART_CR2_STOP_Msk = 0x3000
	// 1 stop bit
	USART_CR2_STOP_Stop1 = 0x0
	// 0.5 stop bit
	USART_CR2_STOP_Stop0p5 = 0x1
	// 2 stop bit
	USART_CR2_STOP_Stop2 = 0x2
	// 1.5 stop bit
	USART_CR2_STOP_Stop1p5 = 0x3
	// Position of CLKEN field.
	USART_CR2_CLKEN_Pos = 0xb
	// Bit mask of CLKEN field.
	USART_CR2_CLKEN_Msk = 0x800
	// Bit CLKEN.
	USART_CR2_CLKEN = 0x800
	// CK pin disabled
	USART_CR2_CLKEN_Disabled = 0x0
	// CK pin enabled
	USART_CR2_CLKEN_Enabled = 0x1
	// Position of CPOL field.
	USART_CR2_CPOL_Pos = 0xa
	// Bit mask of CPOL field.
	USART_CR2_CPOL_Msk = 0x400
	// Bit CPOL.
	USART_CR2_CPOL = 0x400
	// Steady low value on CK pin outside transmission window
	USART_CR2_CPOL_Low = 0x0
	// Steady high value on CK pin outside transmission window
	USART_CR2_CPOL_High = 0x1
	// Position of CPHA field.
	USART_CR2_CPHA_Pos = 0x9
	// Bit mask of CPHA field.
	USART_CR2_CPHA_Msk = 0x200
	// Bit CPHA.
	USART_CR2_CPHA = 0x200
	// The first clock transition is the first data capture edge
	USART_CR2_CPHA_First = 0x0
	// The second clock transition is the first data capture edge
	USART_CR2_CPHA_Second = 0x1
	// Position of LBCL field.
	USART_CR2_LBCL_Pos = 0x8
	// Bit mask of LBCL field.
	USART_CR2_LBCL_Msk = 0x100
	// Bit LBCL.
	USART_CR2_LBCL = 0x100
	// The clock pulse of the last data bit is not output to the CK pin
	USART_CR2_LBCL_NotOutput = 0x0
	// The clock pulse of the last data bit is output to the CK pin
	USART_CR2_LBCL_Output = 0x1
	// Position of LBDIE field.
	USART_CR2_LBDIE_Pos = 0x6
	// Bit mask of LBDIE field.
	USART_CR2_LBDIE_Msk = 0x40
	// Bit LBDIE.
	USART_CR2_LBDIE = 0x40
	// Interrupt is inhibited
	USART_CR2_LBDIE_Disabled = 0x0
	// An interrupt is generated whenever LBDF=1 in the ISR register
	USART_CR2_LBDIE_Enabled = 0x1
	// Position of LBDL field.
	USART_CR2_LBDL_Pos = 0x5
	// Bit mask of LBDL field.
	USART_CR2_LBDL_Msk = 0x20
	// Bit LBDL.
	USART_CR2_LBDL = 0x20
	// 10-bit break detection
	USART_CR2_LBDL_Bit10 = 0x0
	// 11-bit break detection
	USART_CR2_LBDL_Bit11 = 0x1
	// Position of ADDM7 field.
	USART_CR2_ADDM7_Pos = 0x4
	// Bit mask of ADDM7 field.
	USART_CR2_ADDM7_Msk = 0x10
	// Bit ADDM7.
	USART_CR2_ADDM7 = 0x10
	// 4-bit address detection
	USART_CR2_ADDM7_Bit4 = 0x0
	// 7-bit address detection
	USART_CR2_ADDM7_Bit7 = 0x1
	// Position of ADD field.
	USART_CR2_ADD_Pos = 0x18
	// Bit mask of ADD field.
	USART_CR2_ADD_Msk = 0xff000000
	// Position of ABRMOD field.
	USART_CR2_ABRMOD_Pos = 0x15
	// Bit mask of ABRMOD field.
	USART_CR2_ABRMOD_Msk = 0x600000
	// Measurement of the start bit is used to detect the baud rate
	USART_CR2_ABRMOD_Start = 0x0
	// Falling edge to falling edge measurement
	USART_CR2_ABRMOD_Edge = 0x1
	// 0x7F frame detection
	USART_CR2_ABRMOD_Frame7F = 0x2
	// 0x55 frame detection
	USART_CR2_ABRMOD_Frame55 = 0x3

	// CR3: Control register 3
	// Position of WUFIE field.
	USART_CR3_WUFIE_Pos = 0x16
	// Bit mask of WUFIE field.
	USART_CR3_WUFIE_Msk = 0x400000
	// Bit WUFIE.
	USART_CR3_WUFIE = 0x400000
	// Interrupt is inhibited
	USART_CR3_WUFIE_Disabled = 0x0
	// An USART interrupt is generated whenever WUF=1 in the ISR register
	USART_CR3_WUFIE_Enabled = 0x1
	// Position of WUS field.
	USART_CR3_WUS_Pos = 0x14
	// Bit mask of WUS field.
	USART_CR3_WUS_Msk = 0x300000
	// WUF active on address match
	USART_CR3_WUS_Address = 0x0
	// WuF active on Start bit detection
	USART_CR3_WUS_Start = 0x2
	// WUF active on RXNE
	USART_CR3_WUS_RXNE = 0x3
	// Position of SCARCNT field.
	USART_CR3_SCARCNT_Pos = 0x11
	// Bit mask of SCARCNT field.
	USART_CR3_SCARCNT_Msk = 0xe0000
	// Position of DEP field.
	USART_CR3_DEP_Pos = 0xf
	// Bit mask of DEP field.
	USART_CR3_DEP_Msk = 0x8000
	// Bit DEP.
	USART_CR3_DEP = 0x8000
	// DE signal is active high
	USART_CR3_DEP_High = 0x0
	// DE signal is active low
	USART_CR3_DEP_Low = 0x1
	// Position of DEM field.
	USART_CR3_DEM_Pos = 0xe
	// Bit mask of DEM field.
	USART_CR3_DEM_Msk = 0x4000
	// Bit DEM.
	USART_CR3_DEM = 0x4000
	// DE function is disabled
	USART_CR3_DEM_Disabled = 0x0
	// The DE signal is output on the RTS pin
	USART_CR3_DEM_Enabled = 0x1
	// Position of DDRE field.
	USART_CR3_DDRE_Pos = 0xd
	// Bit mask of DDRE field.
	USART_CR3_DDRE_Msk = 0x2000
	// Bit DDRE.
	USART_CR3_DDRE = 0x2000
	// DMA is not disabled in case of reception error
	USART_CR3_DDRE_NotDisabled = 0x0
	// DMA is disabled following a reception error
	USART_CR3_DDRE_Disabled = 0x1
	// Position of OVRDIS field.
	USART_CR3_OVRDIS_Pos = 0xc
	// Bit mask of OVRDIS field.
	USART_CR3_OVRDIS_Msk = 0x1000
	// Bit OVRDIS.
	USART_CR3_OVRDIS = 0x1000
	// Overrun Error Flag, ORE, is set when received data is not read before receiving new data
	USART_CR3_OVRDIS_Enabled = 0x0
	// Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register
	USART_CR3_OVRDIS_Disabled = 0x1
	// Position of ONEBIT field.
	USART_CR3_ONEBIT_Pos = 0xb
	// Bit mask of ONEBIT field.
	USART_CR3_ONEBIT_Msk = 0x800
	// Bit ONEBIT.
	USART_CR3_ONEBIT = 0x800
	// Three sample bit method
	USART_CR3_ONEBIT_Sample3 = 0x0
	// One sample bit method
	USART_CR3_ONEBIT_Sample1 = 0x1
	// Position of CTSIE field.
	USART_CR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	USART_CR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	USART_CR3_CTSIE = 0x400
	// Interrupt is inhibited
	USART_CR3_CTSIE_Disabled = 0x0
	// An interrupt is generated whenever CTSIF=1 in the ISR register
	USART_CR3_CTSIE_Enabled = 0x1
	// Position of CTSE field.
	USART_CR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	USART_CR3_CTSE_Msk = 0x200
	// Bit CTSE.
	USART_CR3_CTSE = 0x200
	// CTS hardware flow control disabled
	USART_CR3_CTSE_Disabled = 0x0
	// CTS mode enabled, data is only transmitted when the CTS input is asserted
	USART_CR3_CTSE_Enabled = 0x1
	// Position of RTSE field.
	USART_CR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	USART_CR3_RTSE_Msk = 0x100
	// Bit RTSE.
	USART_CR3_RTSE = 0x100
	// RTS hardware flow control disabled
	USART_CR3_RTSE_Disabled = 0x0
	// RTS output enabled, data is only requested when there is space in the receive buffer
	USART_CR3_RTSE_Enabled = 0x1
	// Position of DMAT field.
	USART_CR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	USART_CR3_DMAT_Msk = 0x80
	// Bit DMAT.
	USART_CR3_DMAT = 0x80
	// DMA mode is disabled for transmission
	USART_CR3_DMAT_Disabled = 0x0
	// DMA mode is enabled for transmission
	USART_CR3_DMAT_Enabled = 0x1
	// Position of DMAR field.
	USART_CR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	USART_CR3_DMAR_Msk = 0x40
	// Bit DMAR.
	USART_CR3_DMAR = 0x40
	// DMA mode is disabled for reception
	USART_CR3_DMAR_Disabled = 0x0
	// DMA mode is enabled for reception
	USART_CR3_DMAR_Enabled = 0x1
	// Position of SCEN field.
	USART_CR3_SCEN_Pos = 0x5
	// Bit mask of SCEN field.
	USART_CR3_SCEN_Msk = 0x20
	// Bit SCEN.
	USART_CR3_SCEN = 0x20
	// Smartcard Mode disabled
	USART_CR3_SCEN_Disabled = 0x0
	// Smartcard Mode enabled
	USART_CR3_SCEN_Enabled = 0x1
	// Position of NACK field.
	USART_CR3_NACK_Pos = 0x4
	// Bit mask of NACK field.
	USART_CR3_NACK_Msk = 0x10
	// Bit NACK.
	USART_CR3_NACK = 0x10
	// NACK transmission in case of parity error is disabled
	USART_CR3_NACK_Disabled = 0x0
	// NACK transmission during parity error is enabled
	USART_CR3_NACK_Enabled = 0x1
	// Position of HDSEL field.
	USART_CR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	USART_CR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	USART_CR3_HDSEL = 0x8
	// Half duplex mode is not selected
	USART_CR3_HDSEL_NotSelected = 0x0
	// Half duplex mode is selected
	USART_CR3_HDSEL_Selected = 0x1
	// Position of IRLP field.
	USART_CR3_IRLP_Pos = 0x2
	// Bit mask of IRLP field.
	USART_CR3_IRLP_Msk = 0x4
	// Bit IRLP.
	USART_CR3_IRLP = 0x4
	// Normal mode
	USART_CR3_IRLP_Normal = 0x0
	// Low-power mode
	USART_CR3_IRLP_LowPower = 0x1
	// Position of IREN field.
	USART_CR3_IREN_Pos = 0x1
	// Bit mask of IREN field.
	USART_CR3_IREN_Msk = 0x2
	// Bit IREN.
	USART_CR3_IREN = 0x2
	// IrDA disabled
	USART_CR3_IREN_Disabled = 0x0
	// IrDA enabled
	USART_CR3_IREN_Enabled = 0x1
	// Position of EIE field.
	USART_CR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	USART_CR3_EIE_Msk = 0x1
	// Bit EIE.
	USART_CR3_EIE = 0x1
	// Interrupt is inhibited
	USART_CR3_EIE_Disabled = 0x0
	// An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register
	USART_CR3_EIE_Enabled = 0x1

	// BRR: Baud rate register
	// Position of BRR field.
	USART_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	USART_BRR_BRR_Msk = 0xffff

	// GTPR: Guard time and prescaler register
	// Position of GT field.
	USART_GTPR_GT_Pos = 0x8
	// Bit mask of GT field.
	USART_GTPR_GT_Msk = 0xff00
	// Position of PSC field.
	USART_GTPR_PSC_Pos = 0x0
	// Bit mask of PSC field.
	USART_GTPR_PSC_Msk = 0xff

	// RTOR: Receiver timeout register
	// Position of BLEN field.
	USART_RTOR_BLEN_Pos = 0x18
	// Bit mask of BLEN field.
	USART_RTOR_BLEN_Msk = 0xff000000
	// Position of RTO field.
	USART_RTOR_RTO_Pos = 0x0
	// Bit mask of RTO field.
	USART_RTOR_RTO_Msk = 0xffffff

	// RQR: Request register
	// Position of TXFRQ field.
	USART_RQR_TXFRQ_Pos = 0x4
	// Bit mask of TXFRQ field.
	USART_RQR_TXFRQ_Msk = 0x10
	// Bit TXFRQ.
	USART_RQR_TXFRQ = 0x10
	// Set the TXE flags. This allows to discard the transmit data
	USART_RQR_TXFRQ_Discard = 0x1
	// Position of RXFRQ field.
	USART_RQR_RXFRQ_Pos = 0x3
	// Bit mask of RXFRQ field.
	USART_RQR_RXFRQ_Msk = 0x8
	// Bit RXFRQ.
	USART_RQR_RXFRQ = 0x8
	// clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition
	USART_RQR_RXFRQ_Discard = 0x1
	// Position of MMRQ field.
	USART_RQR_MMRQ_Pos = 0x2
	// Bit mask of MMRQ field.
	USART_RQR_MMRQ_Msk = 0x4
	// Bit MMRQ.
	USART_RQR_MMRQ = 0x4
	// Puts the USART in mute mode and sets the RWU flag
	USART_RQR_MMRQ_Mute = 0x1
	// Position of SBKRQ field.
	USART_RQR_SBKRQ_Pos = 0x1
	// Bit mask of SBKRQ field.
	USART_RQR_SBKRQ_Msk = 0x2
	// Bit SBKRQ.
	USART_RQR_SBKRQ = 0x2
	// sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available
	USART_RQR_SBKRQ_Break = 0x1
	// Position of ABRRQ field.
	USART_RQR_ABRRQ_Pos = 0x0
	// Bit mask of ABRRQ field.
	USART_RQR_ABRRQ_Msk = 0x1
	// Bit ABRRQ.
	USART_RQR_ABRRQ = 0x1
	// resets the ABRF flag in the USART_ISR and request an automatic baud rate measurement on the next received data frame
	USART_RQR_ABRRQ_Request = 0x1

	// ISR: Interrupt & status register
	// Position of REACK field.
	USART_ISR_REACK_Pos = 0x16
	// Bit mask of REACK field.
	USART_ISR_REACK_Msk = 0x400000
	// Bit REACK.
	USART_ISR_REACK = 0x400000
	// Position of TEACK field.
	USART_ISR_TEACK_Pos = 0x15
	// Bit mask of TEACK field.
	USART_ISR_TEACK_Msk = 0x200000
	// Bit TEACK.
	USART_ISR_TEACK = 0x200000
	// Position of WUF field.
	USART_ISR_WUF_Pos = 0x14
	// Bit mask of WUF field.
	USART_ISR_WUF_Msk = 0x100000
	// Bit WUF.
	USART_ISR_WUF = 0x100000
	// Position of RWU field.
	USART_ISR_RWU_Pos = 0x13
	// Bit mask of RWU field.
	USART_ISR_RWU_Msk = 0x80000
	// Bit RWU.
	USART_ISR_RWU = 0x80000
	// Position of SBKF field.
	USART_ISR_SBKF_Pos = 0x12
	// Bit mask of SBKF field.
	USART_ISR_SBKF_Msk = 0x40000
	// Bit SBKF.
	USART_ISR_SBKF = 0x40000
	// Position of CMF field.
	USART_ISR_CMF_Pos = 0x11
	// Bit mask of CMF field.
	USART_ISR_CMF_Msk = 0x20000
	// Bit CMF.
	USART_ISR_CMF = 0x20000
	// Position of BUSY field.
	USART_ISR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	USART_ISR_BUSY_Msk = 0x10000
	// Bit BUSY.
	USART_ISR_BUSY = 0x10000
	// Position of ABRF field.
	USART_ISR_ABRF_Pos = 0xf
	// Bit mask of ABRF field.
	USART_ISR_ABRF_Msk = 0x8000
	// Bit ABRF.
	USART_ISR_ABRF = 0x8000
	// Position of ABRE field.
	USART_ISR_ABRE_Pos = 0xe
	// Bit mask of ABRE field.
	USART_ISR_ABRE_Msk = 0x4000
	// Bit ABRE.
	USART_ISR_ABRE = 0x4000
	// Position of EOBF field.
	USART_ISR_EOBF_Pos = 0xc
	// Bit mask of EOBF field.
	USART_ISR_EOBF_Msk = 0x1000
	// Bit EOBF.
	USART_ISR_EOBF = 0x1000
	// Position of RTOF field.
	USART_ISR_RTOF_Pos = 0xb
	// Bit mask of RTOF field.
	USART_ISR_RTOF_Msk = 0x800
	// Bit RTOF.
	USART_ISR_RTOF = 0x800
	// Position of CTS field.
	USART_ISR_CTS_Pos = 0xa
	// Bit mask of CTS field.
	USART_ISR_CTS_Msk = 0x400
	// Bit CTS.
	USART_ISR_CTS = 0x400
	// Position of CTSIF field.
	USART_ISR_CTSIF_Pos = 0x9
	// Bit mask of CTSIF field.
	USART_ISR_CTSIF_Msk = 0x200
	// Bit CTSIF.
	USART_ISR_CTSIF = 0x200
	// Position of LBDF field.
	USART_ISR_LBDF_Pos = 0x8
	// Bit mask of LBDF field.
	USART_ISR_LBDF_Msk = 0x100
	// Bit LBDF.
	USART_ISR_LBDF = 0x100
	// Position of TXE field.
	USART_ISR_TXE_Pos = 0x7
	// Bit mask of TXE field.
	USART_ISR_TXE_Msk = 0x80
	// Bit TXE.
	USART_ISR_TXE = 0x80
	// Position of TC field.
	USART_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	USART_ISR_TC_Msk = 0x40
	// Bit TC.
	USART_ISR_TC = 0x40
	// Position of RXNE field.
	USART_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	USART_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	USART_ISR_RXNE = 0x20
	// Position of IDLE field.
	USART_ISR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	USART_ISR_IDLE_Msk = 0x10
	// Bit IDLE.
	USART_ISR_IDLE = 0x10
	// Position of ORE field.
	USART_ISR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	USART_ISR_ORE_Msk = 0x8
	// Bit ORE.
	USART_ISR_ORE = 0x8
	// Position of NF field.
	USART_ISR_NF_Pos = 0x2
	// Bit mask of NF field.
	USART_ISR_NF_Msk = 0x4
	// Bit NF.
	USART_ISR_NF = 0x4
	// Position of FE field.
	USART_ISR_FE_Pos = 0x1
	// Bit mask of FE field.
	USART_ISR_FE_Msk = 0x2
	// Bit FE.
	USART_ISR_FE = 0x2
	// Position of PE field.
	USART_ISR_PE_Pos = 0x0
	// Bit mask of PE field.
	USART_ISR_PE_Msk = 0x1
	// Bit PE.
	USART_ISR_PE = 0x1

	// ICR: Interrupt flag clear register
	// Position of WUCF field.
	USART_ICR_WUCF_Pos = 0x14
	// Bit mask of WUCF field.
	USART_ICR_WUCF_Msk = 0x100000
	// Bit WUCF.
	USART_ICR_WUCF = 0x100000
	// Clears the WUF flag in the ISR register
	USART_ICR_WUCF_Clear = 0x1
	// Position of CMCF field.
	USART_ICR_CMCF_Pos = 0x11
	// Bit mask of CMCF field.
	USART_ICR_CMCF_Msk = 0x20000
	// Bit CMCF.
	USART_ICR_CMCF = 0x20000
	// Clears the CMF flag in the ISR register
	USART_ICR_CMCF_Clear = 0x1
	// Position of EOBCF field.
	USART_ICR_EOBCF_Pos = 0xc
	// Bit mask of EOBCF field.
	USART_ICR_EOBCF_Msk = 0x1000
	// Bit EOBCF.
	USART_ICR_EOBCF = 0x1000
	// Clears the EOBF flag in the ISR register
	USART_ICR_EOBCF_Clear = 0x1
	// Position of RTOCF field.
	USART_ICR_RTOCF_Pos = 0xb
	// Bit mask of RTOCF field.
	USART_ICR_RTOCF_Msk = 0x800
	// Bit RTOCF.
	USART_ICR_RTOCF = 0x800
	// Clears the RTOF flag in the ISR register
	USART_ICR_RTOCF_Clear = 0x1
	// Position of CTSCF field.
	USART_ICR_CTSCF_Pos = 0x9
	// Bit mask of CTSCF field.
	USART_ICR_CTSCF_Msk = 0x200
	// Bit CTSCF.
	USART_ICR_CTSCF = 0x200
	// Clears the CTSIF flag in the ISR register
	USART_ICR_CTSCF_Clear = 0x1
	// Position of LBDCF field.
	USART_ICR_LBDCF_Pos = 0x8
	// Bit mask of LBDCF field.
	USART_ICR_LBDCF_Msk = 0x100
	// Bit LBDCF.
	USART_ICR_LBDCF = 0x100
	// Clears the LBDF flag in the ISR register
	USART_ICR_LBDCF_Clear = 0x1
	// Position of TCCF field.
	USART_ICR_TCCF_Pos = 0x6
	// Bit mask of TCCF field.
	USART_ICR_TCCF_Msk = 0x40
	// Bit TCCF.
	USART_ICR_TCCF = 0x40
	// Clears the TC flag in the ISR register
	USART_ICR_TCCF_Clear = 0x1
	// Position of IDLECF field.
	USART_ICR_IDLECF_Pos = 0x4
	// Bit mask of IDLECF field.
	USART_ICR_IDLECF_Msk = 0x10
	// Bit IDLECF.
	USART_ICR_IDLECF = 0x10
	// Clears the IDLE flag in the ISR register
	USART_ICR_IDLECF_Clear = 0x1
	// Position of ORECF field.
	USART_ICR_ORECF_Pos = 0x3
	// Bit mask of ORECF field.
	USART_ICR_ORECF_Msk = 0x8
	// Bit ORECF.
	USART_ICR_ORECF = 0x8
	// Clears the ORE flag in the ISR register
	USART_ICR_ORECF_Clear = 0x1
	// Position of NCF field.
	USART_ICR_NCF_Pos = 0x2
	// Bit mask of NCF field.
	USART_ICR_NCF_Msk = 0x4
	// Bit NCF.
	USART_ICR_NCF = 0x4
	// Clears the NF flag in the ISR register
	USART_ICR_NCF_Clear = 0x1
	// Position of FECF field.
	USART_ICR_FECF_Pos = 0x1
	// Bit mask of FECF field.
	USART_ICR_FECF_Msk = 0x2
	// Bit FECF.
	USART_ICR_FECF = 0x2
	// Clears the FE flag in the ISR register
	USART_ICR_FECF_Clear = 0x1
	// Position of PECF field.
	USART_ICR_PECF_Pos = 0x0
	// Bit mask of PECF field.
	USART_ICR_PECF_Msk = 0x1
	// Bit PECF.
	USART_ICR_PECF = 0x1
	// Clears the PE flag in the ISR register
	USART_ICR_PECF_Clear = 0x1

	// RDR: Receive data register
	// Position of RDR field.
	USART_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	USART_RDR_RDR_Msk = 0x1ff

	// TDR: Transmit data register
	// Position of TDR field.
	USART_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	USART_TDR_TDR_Msk = 0x1ff
)

// Constants for SPI1: Serial peripheral interface/Inter-IC sound
const (
	// CR1: control register 1
	// Position of BIDIMODE field.
	SPI_CR1_BIDIMODE_Pos = 0xf
	// Bit mask of BIDIMODE field.
	SPI_CR1_BIDIMODE_Msk = 0x8000
	// Bit BIDIMODE.
	SPI_CR1_BIDIMODE = 0x8000
	// Position of BIDIOE field.
	SPI_CR1_BIDIOE_Pos = 0xe
	// Bit mask of BIDIOE field.
	SPI_CR1_BIDIOE_Msk = 0x4000
	// Bit BIDIOE.
	SPI_CR1_BIDIOE = 0x4000
	// Position of CRCEN field.
	SPI_CR1_CRCEN_Pos = 0xd
	// Bit mask of CRCEN field.
	SPI_CR1_CRCEN_Msk = 0x2000
	// Bit CRCEN.
	SPI_CR1_CRCEN = 0x2000
	// Position of CRCNEXT field.
	SPI_CR1_CRCNEXT_Pos = 0xc
	// Bit mask of CRCNEXT field.
	SPI_CR1_CRCNEXT_Msk = 0x1000
	// Bit CRCNEXT.
	SPI_CR1_CRCNEXT = 0x1000
	// Position of DFF field.
	SPI_CR1_DFF_Pos = 0xb
	// Bit mask of DFF field.
	SPI_CR1_DFF_Msk = 0x800
	// Bit DFF.
	SPI_CR1_DFF = 0x800
	// Position of RXONLY field.
	SPI_CR1_RXONLY_Pos = 0xa
	// Bit mask of RXONLY field.
	SPI_CR1_RXONLY_Msk = 0x400
	// Bit RXONLY.
	SPI_CR1_RXONLY = 0x400
	// Position of SSM field.
	SPI_CR1_SSM_Pos = 0x9
	// Bit mask of SSM field.
	SPI_CR1_SSM_Msk = 0x200
	// Bit SSM.
	SPI_CR1_SSM = 0x200
	// Position of SSI field.
	SPI_CR1_SSI_Pos = 0x8
	// Bit mask of SSI field.
	SPI_CR1_SSI_Msk = 0x100
	// Bit SSI.
	SPI_CR1_SSI = 0x100
	// Position of LSBFIRST field.
	SPI_CR1_LSBFIRST_Pos = 0x7
	// Bit mask of LSBFIRST field.
	SPI_CR1_LSBFIRST_Msk = 0x80
	// Bit LSBFIRST.
	SPI_CR1_LSBFIRST = 0x80
	// Position of SPE field.
	SPI_CR1_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI_CR1_SPE_Msk = 0x40
	// Bit SPE.
	SPI_CR1_SPE = 0x40
	// Position of BR field.
	SPI_CR1_BR_Pos = 0x3
	// Bit mask of BR field.
	SPI_CR1_BR_Msk = 0x38
	// Position of MSTR field.
	SPI_CR1_MSTR_Pos = 0x2
	// Bit mask of MSTR field.
	SPI_CR1_MSTR_Msk = 0x4
	// Bit MSTR.
	SPI_CR1_MSTR = 0x4
	// Position of CPOL field.
	SPI_CR1_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI_CR1_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI_CR1_CPOL = 0x2
	// Position of CPHA field.
	SPI_CR1_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI_CR1_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI_CR1_CPHA = 0x1

	// CR2: control register 2
	// Position of RXDMAEN field.
	SPI_CR2_RXDMAEN_Pos = 0x0
	// Bit mask of RXDMAEN field.
	SPI_CR2_RXDMAEN_Msk = 0x1
	// Bit RXDMAEN.
	SPI_CR2_RXDMAEN = 0x1
	// Position of TXDMAEN field.
	SPI_CR2_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	SPI_CR2_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	SPI_CR2_TXDMAEN = 0x2
	// Position of SSOE field.
	SPI_CR2_SSOE_Pos = 0x2
	// Bit mask of SSOE field.
	SPI_CR2_SSOE_Msk = 0x4
	// Bit SSOE.
	SPI_CR2_SSOE = 0x4
	// Position of NSSP field.
	SPI_CR2_NSSP_Pos = 0x3
	// Bit mask of NSSP field.
	SPI_CR2_NSSP_Msk = 0x8
	// Bit NSSP.
	SPI_CR2_NSSP = 0x8
	// Position of FRF field.
	SPI_CR2_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SPI_CR2_FRF_Msk = 0x10
	// Bit FRF.
	SPI_CR2_FRF = 0x10
	// Position of ERRIE field.
	SPI_CR2_ERRIE_Pos = 0x5
	// Bit mask of ERRIE field.
	SPI_CR2_ERRIE_Msk = 0x20
	// Bit ERRIE.
	SPI_CR2_ERRIE = 0x20
	// Position of RXNEIE field.
	SPI_CR2_RXNEIE_Pos = 0x6
	// Bit mask of RXNEIE field.
	SPI_CR2_RXNEIE_Msk = 0x40
	// Bit RXNEIE.
	SPI_CR2_RXNEIE = 0x40
	// Position of TXEIE field.
	SPI_CR2_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	SPI_CR2_TXEIE_Msk = 0x80
	// Bit TXEIE.
	SPI_CR2_TXEIE = 0x80
	// Position of DS field.
	SPI_CR2_DS_Pos = 0x8
	// Bit mask of DS field.
	SPI_CR2_DS_Msk = 0xf00
	// Position of FRXTH field.
	SPI_CR2_FRXTH_Pos = 0xc
	// Bit mask of FRXTH field.
	SPI_CR2_FRXTH_Msk = 0x1000
	// Bit FRXTH.
	SPI_CR2_FRXTH = 0x1000
	// Position of LDMA_RX field.
	SPI_CR2_LDMA_RX_Pos = 0xd
	// Bit mask of LDMA_RX field.
	SPI_CR2_LDMA_RX_Msk = 0x2000
	// Bit LDMA_RX.
	SPI_CR2_LDMA_RX = 0x2000
	// Position of LDMA_TX field.
	SPI_CR2_LDMA_TX_Pos = 0xe
	// Bit mask of LDMA_TX field.
	SPI_CR2_LDMA_TX_Msk = 0x4000
	// Bit LDMA_TX.
	SPI_CR2_LDMA_TX = 0x4000

	// SR: status register
	// Position of RXNE field.
	SPI_SR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPI_SR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPI_SR_RXNE = 0x1
	// Position of TXE field.
	SPI_SR_TXE_Pos = 0x1
	// Bit mask of TXE field.
	SPI_SR_TXE_Msk = 0x2
	// Bit TXE.
	SPI_SR_TXE = 0x2
	// Position of CRCERR field.
	SPI_SR_CRCERR_Pos = 0x4
	// Bit mask of CRCERR field.
	SPI_SR_CRCERR_Msk = 0x10
	// Bit CRCERR.
	SPI_SR_CRCERR = 0x10
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x5
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x20
	// Bit MODF.
	SPI_SR_MODF = 0x20
	// Position of OVR field.
	SPI_SR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	SPI_SR_OVR_Msk = 0x40
	// Bit OVR.
	SPI_SR_OVR = 0x40
	// Position of BSY field.
	SPI_SR_BSY_Pos = 0x7
	// Bit mask of BSY field.
	SPI_SR_BSY_Msk = 0x80
	// Bit BSY.
	SPI_SR_BSY = 0x80
	// Position of TIFRFE field.
	SPI_SR_TIFRFE_Pos = 0x8
	// Bit mask of TIFRFE field.
	SPI_SR_TIFRFE_Msk = 0x100
	// Bit TIFRFE.
	SPI_SR_TIFRFE = 0x100
	// Position of FRLVL field.
	SPI_SR_FRLVL_Pos = 0x9
	// Bit mask of FRLVL field.
	SPI_SR_FRLVL_Msk = 0x600
	// Position of FTLVL field.
	SPI_SR_FTLVL_Pos = 0xb
	// Bit mask of FTLVL field.
	SPI_SR_FTLVL_Msk = 0x1800

	// DR: data register
	// Position of DR field.
	SPI_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	SPI_DR_DR_Msk = 0xffff

	// CRCPR: CRC polynomial register
	// Position of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Msk = 0xffff

	// RXCRCR: RX CRC register
	// Position of RxCRC field.
	SPI_RXCRCR_RxCRC_Pos = 0x0
	// Bit mask of RxCRC field.
	SPI_RXCRCR_RxCRC_Msk = 0xffff

	// TXCRCR: TX CRC register
	// Position of TxCRC field.
	SPI_TXCRCR_TxCRC_Pos = 0x0
	// Bit mask of TxCRC field.
	SPI_TXCRCR_TxCRC_Msk = 0xffff
)

// Constants for SDMMC1: Secure digital input/output interface
const (
	// POWER: power control register
	// Position of PWRCTRL field.
	SDIO_POWER_PWRCTRL_Pos = 0x0
	// Bit mask of PWRCTRL field.
	SDIO_POWER_PWRCTRL_Msk = 0x3

	// CLKCR: SDI clock control register
	// Position of HWFC_EN field.
	SDIO_CLKCR_HWFC_EN_Pos = 0xe
	// Bit mask of HWFC_EN field.
	SDIO_CLKCR_HWFC_EN_Msk = 0x4000
	// Bit HWFC_EN.
	SDIO_CLKCR_HWFC_EN = 0x4000
	// Position of NEGEDGE field.
	SDIO_CLKCR_NEGEDGE_Pos = 0xd
	// Bit mask of NEGEDGE field.
	SDIO_CLKCR_NEGEDGE_Msk = 0x2000
	// Bit NEGEDGE.
	SDIO_CLKCR_NEGEDGE = 0x2000
	// Position of WIDBUS field.
	SDIO_CLKCR_WIDBUS_Pos = 0xb
	// Bit mask of WIDBUS field.
	SDIO_CLKCR_WIDBUS_Msk = 0x1800
	// Position of BYPASS field.
	SDIO_CLKCR_BYPASS_Pos = 0xa
	// Bit mask of BYPASS field.
	SDIO_CLKCR_BYPASS_Msk = 0x400
	// Bit BYPASS.
	SDIO_CLKCR_BYPASS = 0x400
	// Position of PWRSAV field.
	SDIO_CLKCR_PWRSAV_Pos = 0x9
	// Bit mask of PWRSAV field.
	SDIO_CLKCR_PWRSAV_Msk = 0x200
	// Bit PWRSAV.
	SDIO_CLKCR_PWRSAV = 0x200
	// Position of CLKEN field.
	SDIO_CLKCR_CLKEN_Pos = 0x8
	// Bit mask of CLKEN field.
	SDIO_CLKCR_CLKEN_Msk = 0x100
	// Bit CLKEN.
	SDIO_CLKCR_CLKEN = 0x100
	// Position of CLKDIV field.
	SDIO_CLKCR_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	SDIO_CLKCR_CLKDIV_Msk = 0xff

	// ARG: argument register
	// Position of CMDARG field.
	SDIO_ARG_CMDARG_Pos = 0x0
	// Bit mask of CMDARG field.
	SDIO_ARG_CMDARG_Msk = 0xffffffff

	// CMD: command register
	// Position of CE_ATACMD field.
	SDIO_CMD_CE_ATACMD_Pos = 0xe
	// Bit mask of CE_ATACMD field.
	SDIO_CMD_CE_ATACMD_Msk = 0x4000
	// Bit CE_ATACMD.
	SDIO_CMD_CE_ATACMD = 0x4000
	// Position of NIEN field.
	SDIO_CMD_NIEN_Pos = 0xd
	// Bit mask of NIEN field.
	SDIO_CMD_NIEN_Msk = 0x2000
	// Bit NIEN.
	SDIO_CMD_NIEN = 0x2000
	// Position of ENCMDcompl field.
	SDIO_CMD_ENCMDcompl_Pos = 0xc
	// Bit mask of ENCMDcompl field.
	SDIO_CMD_ENCMDcompl_Msk = 0x1000
	// Bit ENCMDcompl.
	SDIO_CMD_ENCMDcompl = 0x1000
	// Position of SDIOSuspend field.
	SDIO_CMD_SDIOSuspend_Pos = 0xb
	// Bit mask of SDIOSuspend field.
	SDIO_CMD_SDIOSuspend_Msk = 0x800
	// Bit SDIOSuspend.
	SDIO_CMD_SDIOSuspend = 0x800
	// Position of CPSMEN field.
	SDIO_CMD_CPSMEN_Pos = 0xa
	// Bit mask of CPSMEN field.
	SDIO_CMD_CPSMEN_Msk = 0x400
	// Bit CPSMEN.
	SDIO_CMD_CPSMEN = 0x400
	// Position of WAITPEND field.
	SDIO_CMD_WAITPEND_Pos = 0x9
	// Bit mask of WAITPEND field.
	SDIO_CMD_WAITPEND_Msk = 0x200
	// Bit WAITPEND.
	SDIO_CMD_WAITPEND = 0x200
	// Position of WAITINT field.
	SDIO_CMD_WAITINT_Pos = 0x8
	// Bit mask of WAITINT field.
	SDIO_CMD_WAITINT_Msk = 0x100
	// Bit WAITINT.
	SDIO_CMD_WAITINT = 0x100
	// Position of WAITRESP field.
	SDIO_CMD_WAITRESP_Pos = 0x6
	// Bit mask of WAITRESP field.
	SDIO_CMD_WAITRESP_Msk = 0xc0
	// Position of CMDINDEX field.
	SDIO_CMD_CMDINDEX_Pos = 0x0
	// Bit mask of CMDINDEX field.
	SDIO_CMD_CMDINDEX_Msk = 0x3f

	// RESPCMD: command response register
	// Position of RESPCMD field.
	SDIO_RESPCMD_RESPCMD_Pos = 0x0
	// Bit mask of RESPCMD field.
	SDIO_RESPCMD_RESPCMD_Msk = 0x3f

	// RESP1: response 1..4 register
	// Position of CARDSTATUS1 field.
	SDIO_RESP1_CARDSTATUS1_Pos = 0x0
	// Bit mask of CARDSTATUS1 field.
	SDIO_RESP1_CARDSTATUS1_Msk = 0xffffffff

	// RESP2: response 1..4 register
	// Position of CARDSTATUS2 field.
	SDIO_RESP2_CARDSTATUS2_Pos = 0x0
	// Bit mask of CARDSTATUS2 field.
	SDIO_RESP2_CARDSTATUS2_Msk = 0xffffffff

	// RESP3: response 1..4 register
	// Position of CARDSTATUS3 field.
	SDIO_RESP3_CARDSTATUS3_Pos = 0x0
	// Bit mask of CARDSTATUS3 field.
	SDIO_RESP3_CARDSTATUS3_Msk = 0xffffffff

	// RESP4: response 1..4 register
	// Position of CARDSTATUS4 field.
	SDIO_RESP4_CARDSTATUS4_Pos = 0x0
	// Bit mask of CARDSTATUS4 field.
	SDIO_RESP4_CARDSTATUS4_Msk = 0xffffffff

	// DTIMER: data timer register
	// Position of DATATIME field.
	SDIO_DTIMER_DATATIME_Pos = 0x0
	// Bit mask of DATATIME field.
	SDIO_DTIMER_DATATIME_Msk = 0xffffffff

	// DLEN: data length register
	// Position of DATALENGTH field.
	SDIO_DLEN_DATALENGTH_Pos = 0x0
	// Bit mask of DATALENGTH field.
	SDIO_DLEN_DATALENGTH_Msk = 0x1ffffff

	// DCTRL: data control register
	// Position of SDIOEN field.
	SDIO_DCTRL_SDIOEN_Pos = 0xb
	// Bit mask of SDIOEN field.
	SDIO_DCTRL_SDIOEN_Msk = 0x800
	// Bit SDIOEN.
	SDIO_DCTRL_SDIOEN = 0x800
	// Position of RWMOD field.
	SDIO_DCTRL_RWMOD_Pos = 0xa
	// Bit mask of RWMOD field.
	SDIO_DCTRL_RWMOD_Msk = 0x400
	// Bit RWMOD.
	SDIO_DCTRL_RWMOD = 0x400
	// Position of RWSTOP field.
	SDIO_DCTRL_RWSTOP_Pos = 0x9
	// Bit mask of RWSTOP field.
	SDIO_DCTRL_RWSTOP_Msk = 0x200
	// Bit RWSTOP.
	SDIO_DCTRL_RWSTOP = 0x200
	// Position of RWSTART field.
	SDIO_DCTRL_RWSTART_Pos = 0x8
	// Bit mask of RWSTART field.
	SDIO_DCTRL_RWSTART_Msk = 0x100
	// Bit RWSTART.
	SDIO_DCTRL_RWSTART = 0x100
	// Position of DBLOCKSIZE field.
	SDIO_DCTRL_DBLOCKSIZE_Pos = 0x4
	// Bit mask of DBLOCKSIZE field.
	SDIO_DCTRL_DBLOCKSIZE_Msk = 0xf0
	// Position of DMAEN field.
	SDIO_DCTRL_DMAEN_Pos = 0x3
	// Bit mask of DMAEN field.
	SDIO_DCTRL_DMAEN_Msk = 0x8
	// Bit DMAEN.
	SDIO_DCTRL_DMAEN = 0x8
	// Position of DTMODE field.
	SDIO_DCTRL_DTMODE_Pos = 0x2
	// Bit mask of DTMODE field.
	SDIO_DCTRL_DTMODE_Msk = 0x4
	// Bit DTMODE.
	SDIO_DCTRL_DTMODE = 0x4
	// Position of DTDIR field.
	SDIO_DCTRL_DTDIR_Pos = 0x1
	// Bit mask of DTDIR field.
	SDIO_DCTRL_DTDIR_Msk = 0x2
	// Bit DTDIR.
	SDIO_DCTRL_DTDIR = 0x2
	// Position of DTEN field.
	SDIO_DCTRL_DTEN_Pos = 0x0
	// Bit mask of DTEN field.
	SDIO_DCTRL_DTEN_Msk = 0x1
	// Bit DTEN.
	SDIO_DCTRL_DTEN = 0x1

	// DCOUNT: data counter register
	// Position of DATACOUNT field.
	SDIO_DCOUNT_DATACOUNT_Pos = 0x0
	// Bit mask of DATACOUNT field.
	SDIO_DCOUNT_DATACOUNT_Msk = 0x1ffffff

	// STA: status register
	// Position of CEATAEND field.
	SDIO_STA_CEATAEND_Pos = 0x17
	// Bit mask of CEATAEND field.
	SDIO_STA_CEATAEND_Msk = 0x800000
	// Bit CEATAEND.
	SDIO_STA_CEATAEND = 0x800000
	// Position of SDIOIT field.
	SDIO_STA_SDIOIT_Pos = 0x16
	// Bit mask of SDIOIT field.
	SDIO_STA_SDIOIT_Msk = 0x400000
	// Bit SDIOIT.
	SDIO_STA_SDIOIT = 0x400000
	// Position of RXDAVL field.
	SDIO_STA_RXDAVL_Pos = 0x15
	// Bit mask of RXDAVL field.
	SDIO_STA_RXDAVL_Msk = 0x200000
	// Bit RXDAVL.
	SDIO_STA_RXDAVL = 0x200000
	// Position of TXDAVL field.
	SDIO_STA_TXDAVL_Pos = 0x14
	// Bit mask of TXDAVL field.
	SDIO_STA_TXDAVL_Msk = 0x100000
	// Bit TXDAVL.
	SDIO_STA_TXDAVL = 0x100000
	// Position of RXFIFOE field.
	SDIO_STA_RXFIFOE_Pos = 0x13
	// Bit mask of RXFIFOE field.
	SDIO_STA_RXFIFOE_Msk = 0x80000
	// Bit RXFIFOE.
	SDIO_STA_RXFIFOE = 0x80000
	// Position of TXFIFOE field.
	SDIO_STA_TXFIFOE_Pos = 0x12
	// Bit mask of TXFIFOE field.
	SDIO_STA_TXFIFOE_Msk = 0x40000
	// Bit TXFIFOE.
	SDIO_STA_TXFIFOE = 0x40000
	// Position of RXFIFOF field.
	SDIO_STA_RXFIFOF_Pos = 0x11
	// Bit mask of RXFIFOF field.
	SDIO_STA_RXFIFOF_Msk = 0x20000
	// Bit RXFIFOF.
	SDIO_STA_RXFIFOF = 0x20000
	// Position of TXFIFOF field.
	SDIO_STA_TXFIFOF_Pos = 0x10
	// Bit mask of TXFIFOF field.
	SDIO_STA_TXFIFOF_Msk = 0x10000
	// Bit TXFIFOF.
	SDIO_STA_TXFIFOF = 0x10000
	// Position of RXFIFOHF field.
	SDIO_STA_RXFIFOHF_Pos = 0xf
	// Bit mask of RXFIFOHF field.
	SDIO_STA_RXFIFOHF_Msk = 0x8000
	// Bit RXFIFOHF.
	SDIO_STA_RXFIFOHF = 0x8000
	// Position of TXFIFOHE field.
	SDIO_STA_TXFIFOHE_Pos = 0xe
	// Bit mask of TXFIFOHE field.
	SDIO_STA_TXFIFOHE_Msk = 0x4000
	// Bit TXFIFOHE.
	SDIO_STA_TXFIFOHE = 0x4000
	// Position of RXACT field.
	SDIO_STA_RXACT_Pos = 0xd
	// Bit mask of RXACT field.
	SDIO_STA_RXACT_Msk = 0x2000
	// Bit RXACT.
	SDIO_STA_RXACT = 0x2000
	// Position of TXACT field.
	SDIO_STA_TXACT_Pos = 0xc
	// Bit mask of TXACT field.
	SDIO_STA_TXACT_Msk = 0x1000
	// Bit TXACT.
	SDIO_STA_TXACT = 0x1000
	// Position of CMDACT field.
	SDIO_STA_CMDACT_Pos = 0xb
	// Bit mask of CMDACT field.
	SDIO_STA_CMDACT_Msk = 0x800
	// Bit CMDACT.
	SDIO_STA_CMDACT = 0x800
	// Position of DBCKEND field.
	SDIO_STA_DBCKEND_Pos = 0xa
	// Bit mask of DBCKEND field.
	SDIO_STA_DBCKEND_Msk = 0x400
	// Bit DBCKEND.
	SDIO_STA_DBCKEND = 0x400
	// Position of STBITERR field.
	SDIO_STA_STBITERR_Pos = 0x9
	// Bit mask of STBITERR field.
	SDIO_STA_STBITERR_Msk = 0x200
	// Bit STBITERR.
	SDIO_STA_STBITERR = 0x200
	// Position of DATAEND field.
	SDIO_STA_DATAEND_Pos = 0x8
	// Bit mask of DATAEND field.
	SDIO_STA_DATAEND_Msk = 0x100
	// Bit DATAEND.
	SDIO_STA_DATAEND = 0x100
	// Position of CMDSENT field.
	SDIO_STA_CMDSENT_Pos = 0x7
	// Bit mask of CMDSENT field.
	SDIO_STA_CMDSENT_Msk = 0x80
	// Bit CMDSENT.
	SDIO_STA_CMDSENT = 0x80
	// Position of CMDREND field.
	SDIO_STA_CMDREND_Pos = 0x6
	// Bit mask of CMDREND field.
	SDIO_STA_CMDREND_Msk = 0x40
	// Bit CMDREND.
	SDIO_STA_CMDREND = 0x40
	// Position of RXOVERR field.
	SDIO_STA_RXOVERR_Pos = 0x5
	// Bit mask of RXOVERR field.
	SDIO_STA_RXOVERR_Msk = 0x20
	// Bit RXOVERR.
	SDIO_STA_RXOVERR = 0x20
	// Position of TXUNDERR field.
	SDIO_STA_TXUNDERR_Pos = 0x4
	// Bit mask of TXUNDERR field.
	SDIO_STA_TXUNDERR_Msk = 0x10
	// Bit TXUNDERR.
	SDIO_STA_TXUNDERR = 0x10
	// Position of DTIMEOUT field.
	SDIO_STA_DTIMEOUT_Pos = 0x3
	// Bit mask of DTIMEOUT field.
	SDIO_STA_DTIMEOUT_Msk = 0x8
	// Bit DTIMEOUT.
	SDIO_STA_DTIMEOUT = 0x8
	// Position of CTIMEOUT field.
	SDIO_STA_CTIMEOUT_Pos = 0x2
	// Bit mask of CTIMEOUT field.
	SDIO_STA_CTIMEOUT_Msk = 0x4
	// Bit CTIMEOUT.
	SDIO_STA_CTIMEOUT = 0x4
	// Position of DCRCFAIL field.
	SDIO_STA_DCRCFAIL_Pos = 0x1
	// Bit mask of DCRCFAIL field.
	SDIO_STA_DCRCFAIL_Msk = 0x2
	// Bit DCRCFAIL.
	SDIO_STA_DCRCFAIL = 0x2
	// Position of CCRCFAIL field.
	SDIO_STA_CCRCFAIL_Pos = 0x0
	// Bit mask of CCRCFAIL field.
	SDIO_STA_CCRCFAIL_Msk = 0x1
	// Bit CCRCFAIL.
	SDIO_STA_CCRCFAIL = 0x1

	// ICR: interrupt clear register
	// Position of CEATAENDC field.
	SDIO_ICR_CEATAENDC_Pos = 0x17
	// Bit mask of CEATAENDC field.
	SDIO_ICR_CEATAENDC_Msk = 0x800000
	// Bit CEATAENDC.
	SDIO_ICR_CEATAENDC = 0x800000
	// Position of SDIOITC field.
	SDIO_ICR_SDIOITC_Pos = 0x16
	// Bit mask of SDIOITC field.
	SDIO_ICR_SDIOITC_Msk = 0x400000
	// Bit SDIOITC.
	SDIO_ICR_SDIOITC = 0x400000
	// Position of DBCKENDC field.
	SDIO_ICR_DBCKENDC_Pos = 0xa
	// Bit mask of DBCKENDC field.
	SDIO_ICR_DBCKENDC_Msk = 0x400
	// Bit DBCKENDC.
	SDIO_ICR_DBCKENDC = 0x400
	// Position of STBITERRC field.
	SDIO_ICR_STBITERRC_Pos = 0x9
	// Bit mask of STBITERRC field.
	SDIO_ICR_STBITERRC_Msk = 0x200
	// Bit STBITERRC.
	SDIO_ICR_STBITERRC = 0x200
	// Position of DATAENDC field.
	SDIO_ICR_DATAENDC_Pos = 0x8
	// Bit mask of DATAENDC field.
	SDIO_ICR_DATAENDC_Msk = 0x100
	// Bit DATAENDC.
	SDIO_ICR_DATAENDC = 0x100
	// Position of CMDSENTC field.
	SDIO_ICR_CMDSENTC_Pos = 0x7
	// Bit mask of CMDSENTC field.
	SDIO_ICR_CMDSENTC_Msk = 0x80
	// Bit CMDSENTC.
	SDIO_ICR_CMDSENTC = 0x80
	// Position of CMDRENDC field.
	SDIO_ICR_CMDRENDC_Pos = 0x6
	// Bit mask of CMDRENDC field.
	SDIO_ICR_CMDRENDC_Msk = 0x40
	// Bit CMDRENDC.
	SDIO_ICR_CMDRENDC = 0x40
	// Position of RXOVERRC field.
	SDIO_ICR_RXOVERRC_Pos = 0x5
	// Bit mask of RXOVERRC field.
	SDIO_ICR_RXOVERRC_Msk = 0x20
	// Bit RXOVERRC.
	SDIO_ICR_RXOVERRC = 0x20
	// Position of TXUNDERRC field.
	SDIO_ICR_TXUNDERRC_Pos = 0x4
	// Bit mask of TXUNDERRC field.
	SDIO_ICR_TXUNDERRC_Msk = 0x10
	// Bit TXUNDERRC.
	SDIO_ICR_TXUNDERRC = 0x10
	// Position of DTIMEOUTC field.
	SDIO_ICR_DTIMEOUTC_Pos = 0x3
	// Bit mask of DTIMEOUTC field.
	SDIO_ICR_DTIMEOUTC_Msk = 0x8
	// Bit DTIMEOUTC.
	SDIO_ICR_DTIMEOUTC = 0x8
	// Position of CTIMEOUTC field.
	SDIO_ICR_CTIMEOUTC_Pos = 0x2
	// Bit mask of CTIMEOUTC field.
	SDIO_ICR_CTIMEOUTC_Msk = 0x4
	// Bit CTIMEOUTC.
	SDIO_ICR_CTIMEOUTC = 0x4
	// Position of DCRCFAILC field.
	SDIO_ICR_DCRCFAILC_Pos = 0x1
	// Bit mask of DCRCFAILC field.
	SDIO_ICR_DCRCFAILC_Msk = 0x2
	// Bit DCRCFAILC.
	SDIO_ICR_DCRCFAILC = 0x2
	// Position of CCRCFAILC field.
	SDIO_ICR_CCRCFAILC_Pos = 0x0
	// Bit mask of CCRCFAILC field.
	SDIO_ICR_CCRCFAILC_Msk = 0x1
	// Bit CCRCFAILC.
	SDIO_ICR_CCRCFAILC = 0x1

	// MASK: mask register
	// Position of CEATAENDIE field.
	SDIO_MASK_CEATAENDIE_Pos = 0x17
	// Bit mask of CEATAENDIE field.
	SDIO_MASK_CEATAENDIE_Msk = 0x800000
	// Bit CEATAENDIE.
	SDIO_MASK_CEATAENDIE = 0x800000
	// Position of SDIOITIE field.
	SDIO_MASK_SDIOITIE_Pos = 0x16
	// Bit mask of SDIOITIE field.
	SDIO_MASK_SDIOITIE_Msk = 0x400000
	// Bit SDIOITIE.
	SDIO_MASK_SDIOITIE = 0x400000
	// Position of RXDAVLIE field.
	SDIO_MASK_RXDAVLIE_Pos = 0x15
	// Bit mask of RXDAVLIE field.
	SDIO_MASK_RXDAVLIE_Msk = 0x200000
	// Bit RXDAVLIE.
	SDIO_MASK_RXDAVLIE = 0x200000
	// Position of TXDAVLIE field.
	SDIO_MASK_TXDAVLIE_Pos = 0x14
	// Bit mask of TXDAVLIE field.
	SDIO_MASK_TXDAVLIE_Msk = 0x100000
	// Bit TXDAVLIE.
	SDIO_MASK_TXDAVLIE = 0x100000
	// Position of RXFIFOEIE field.
	SDIO_MASK_RXFIFOEIE_Pos = 0x13
	// Bit mask of RXFIFOEIE field.
	SDIO_MASK_RXFIFOEIE_Msk = 0x80000
	// Bit RXFIFOEIE.
	SDIO_MASK_RXFIFOEIE = 0x80000
	// Position of TXFIFOEIE field.
	SDIO_MASK_TXFIFOEIE_Pos = 0x12
	// Bit mask of TXFIFOEIE field.
	SDIO_MASK_TXFIFOEIE_Msk = 0x40000
	// Bit TXFIFOEIE.
	SDIO_MASK_TXFIFOEIE = 0x40000
	// Position of RXFIFOFIE field.
	SDIO_MASK_RXFIFOFIE_Pos = 0x11
	// Bit mask of RXFIFOFIE field.
	SDIO_MASK_RXFIFOFIE_Msk = 0x20000
	// Bit RXFIFOFIE.
	SDIO_MASK_RXFIFOFIE = 0x20000
	// Position of TXFIFOFIE field.
	SDIO_MASK_TXFIFOFIE_Pos = 0x10
	// Bit mask of TXFIFOFIE field.
	SDIO_MASK_TXFIFOFIE_Msk = 0x10000
	// Bit TXFIFOFIE.
	SDIO_MASK_TXFIFOFIE = 0x10000
	// Position of RXFIFOHFIE field.
	SDIO_MASK_RXFIFOHFIE_Pos = 0xf
	// Bit mask of RXFIFOHFIE field.
	SDIO_MASK_RXFIFOHFIE_Msk = 0x8000
	// Bit RXFIFOHFIE.
	SDIO_MASK_RXFIFOHFIE = 0x8000
	// Position of TXFIFOHEIE field.
	SDIO_MASK_TXFIFOHEIE_Pos = 0xe
	// Bit mask of TXFIFOHEIE field.
	SDIO_MASK_TXFIFOHEIE_Msk = 0x4000
	// Bit TXFIFOHEIE.
	SDIO_MASK_TXFIFOHEIE = 0x4000
	// Position of RXACTIE field.
	SDIO_MASK_RXACTIE_Pos = 0xd
	// Bit mask of RXACTIE field.
	SDIO_MASK_RXACTIE_Msk = 0x2000
	// Bit RXACTIE.
	SDIO_MASK_RXACTIE = 0x2000
	// Position of TXACTIE field.
	SDIO_MASK_TXACTIE_Pos = 0xc
	// Bit mask of TXACTIE field.
	SDIO_MASK_TXACTIE_Msk = 0x1000
	// Bit TXACTIE.
	SDIO_MASK_TXACTIE = 0x1000
	// Position of CMDACTIE field.
	SDIO_MASK_CMDACTIE_Pos = 0xb
	// Bit mask of CMDACTIE field.
	SDIO_MASK_CMDACTIE_Msk = 0x800
	// Bit CMDACTIE.
	SDIO_MASK_CMDACTIE = 0x800
	// Position of DBCKENDIE field.
	SDIO_MASK_DBCKENDIE_Pos = 0xa
	// Bit mask of DBCKENDIE field.
	SDIO_MASK_DBCKENDIE_Msk = 0x400
	// Bit DBCKENDIE.
	SDIO_MASK_DBCKENDIE = 0x400
	// Position of STBITERRIE field.
	SDIO_MASK_STBITERRIE_Pos = 0x9
	// Bit mask of STBITERRIE field.
	SDIO_MASK_STBITERRIE_Msk = 0x200
	// Bit STBITERRIE.
	SDIO_MASK_STBITERRIE = 0x200
	// Position of DATAENDIE field.
	SDIO_MASK_DATAENDIE_Pos = 0x8
	// Bit mask of DATAENDIE field.
	SDIO_MASK_DATAENDIE_Msk = 0x100
	// Bit DATAENDIE.
	SDIO_MASK_DATAENDIE = 0x100
	// Position of CMDSENTIE field.
	SDIO_MASK_CMDSENTIE_Pos = 0x7
	// Bit mask of CMDSENTIE field.
	SDIO_MASK_CMDSENTIE_Msk = 0x80
	// Bit CMDSENTIE.
	SDIO_MASK_CMDSENTIE = 0x80
	// Position of CMDRENDIE field.
	SDIO_MASK_CMDRENDIE_Pos = 0x6
	// Bit mask of CMDRENDIE field.
	SDIO_MASK_CMDRENDIE_Msk = 0x40
	// Bit CMDRENDIE.
	SDIO_MASK_CMDRENDIE = 0x40
	// Position of RXOVERRIE field.
	SDIO_MASK_RXOVERRIE_Pos = 0x5
	// Bit mask of RXOVERRIE field.
	SDIO_MASK_RXOVERRIE_Msk = 0x20
	// Bit RXOVERRIE.
	SDIO_MASK_RXOVERRIE = 0x20
	// Position of TXUNDERRIE field.
	SDIO_MASK_TXUNDERRIE_Pos = 0x4
	// Bit mask of TXUNDERRIE field.
	SDIO_MASK_TXUNDERRIE_Msk = 0x10
	// Bit TXUNDERRIE.
	SDIO_MASK_TXUNDERRIE = 0x10
	// Position of DTIMEOUTIE field.
	SDIO_MASK_DTIMEOUTIE_Pos = 0x3
	// Bit mask of DTIMEOUTIE field.
	SDIO_MASK_DTIMEOUTIE_Msk = 0x8
	// Bit DTIMEOUTIE.
	SDIO_MASK_DTIMEOUTIE = 0x8
	// Position of CTIMEOUTIE field.
	SDIO_MASK_CTIMEOUTIE_Pos = 0x2
	// Bit mask of CTIMEOUTIE field.
	SDIO_MASK_CTIMEOUTIE_Msk = 0x4
	// Bit CTIMEOUTIE.
	SDIO_MASK_CTIMEOUTIE = 0x4
	// Position of DCRCFAILIE field.
	SDIO_MASK_DCRCFAILIE_Pos = 0x1
	// Bit mask of DCRCFAILIE field.
	SDIO_MASK_DCRCFAILIE_Msk = 0x2
	// Bit DCRCFAILIE.
	SDIO_MASK_DCRCFAILIE = 0x2
	// Position of CCRCFAILIE field.
	SDIO_MASK_CCRCFAILIE_Pos = 0x0
	// Bit mask of CCRCFAILIE field.
	SDIO_MASK_CCRCFAILIE_Msk = 0x1
	// Bit CCRCFAILIE.
	SDIO_MASK_CCRCFAILIE = 0x1

	// FIFOCNT: FIFO counter register
	// Position of FIFOCOUNT field.
	SDIO_FIFOCNT_FIFOCOUNT_Pos = 0x0
	// Bit mask of FIFOCOUNT field.
	SDIO_FIFOCNT_FIFOCOUNT_Msk = 0xffffff

	// FIFO: data FIFO register
	// Position of FIFOData field.
	SDIO_FIFO_FIFOData_Pos = 0x0
	// Bit mask of FIFOData field.
	SDIO_FIFO_FIFOData_Msk = 0xffffffff
)

// Constants for EXTI: External interrupt/event controller
const (
	// IMR1: Interrupt mask register
	// Position of MR0 field.
	EXTI_IMR1_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_IMR1_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_IMR1_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_IMR1_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_IMR1_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_IMR1_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_IMR1_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_IMR1_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_IMR1_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_IMR1_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_IMR1_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_IMR1_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_IMR1_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_IMR1_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_IMR1_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_IMR1_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_IMR1_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_IMR1_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_IMR1_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_IMR1_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_IMR1_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_IMR1_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_IMR1_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_IMR1_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_IMR1_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_IMR1_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_IMR1_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_IMR1_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_IMR1_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_IMR1_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_IMR1_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_IMR1_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_IMR1_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_IMR1_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_IMR1_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_IMR1_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_IMR1_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_IMR1_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_IMR1_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_IMR1_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_IMR1_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_IMR1_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_IMR1_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_IMR1_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_IMR1_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_IMR1_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_IMR1_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_IMR1_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_IMR1_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_IMR1_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_IMR1_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_IMR1_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_IMR1_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_IMR1_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_IMR1_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_IMR1_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_IMR1_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_IMR1_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_IMR1_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_IMR1_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_IMR1_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_IMR1_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_IMR1_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_IMR1_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_IMR1_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_IMR1_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_IMR1_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_IMR1_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_IMR1_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_IMR1_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_IMR1_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_IMR1_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_IMR1_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_IMR1_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_IMR1_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_IMR1_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_IMR1_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_IMR1_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_IMR1_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_IMR1_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_IMR1_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_IMR1_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_IMR1_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_IMR1_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_IMR1_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_IMR1_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_IMR1_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_IMR1_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_IMR1_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_IMR1_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_IMR1_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_IMR1_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR22_Unmasked = 0x1
	// Position of MR23 field.
	EXTI_IMR1_MR23_Pos = 0x17
	// Bit mask of MR23 field.
	EXTI_IMR1_MR23_Msk = 0x800000
	// Bit MR23.
	EXTI_IMR1_MR23 = 0x800000
	// Interrupt request line is masked
	EXTI_IMR1_MR23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR23_Unmasked = 0x1
	// Position of MR24 field.
	EXTI_IMR1_MR24_Pos = 0x18
	// Bit mask of MR24 field.
	EXTI_IMR1_MR24_Msk = 0x1000000
	// Bit MR24.
	EXTI_IMR1_MR24 = 0x1000000
	// Interrupt request line is masked
	EXTI_IMR1_MR24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR24_Unmasked = 0x1
	// Position of MR25 field.
	EXTI_IMR1_MR25_Pos = 0x19
	// Bit mask of MR25 field.
	EXTI_IMR1_MR25_Msk = 0x2000000
	// Bit MR25.
	EXTI_IMR1_MR25 = 0x2000000
	// Interrupt request line is masked
	EXTI_IMR1_MR25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR25_Unmasked = 0x1
	// Position of MR26 field.
	EXTI_IMR1_MR26_Pos = 0x1a
	// Bit mask of MR26 field.
	EXTI_IMR1_MR26_Msk = 0x4000000
	// Bit MR26.
	EXTI_IMR1_MR26 = 0x4000000
	// Interrupt request line is masked
	EXTI_IMR1_MR26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR26_Unmasked = 0x1
	// Position of MR27 field.
	EXTI_IMR1_MR27_Pos = 0x1b
	// Bit mask of MR27 field.
	EXTI_IMR1_MR27_Msk = 0x8000000
	// Bit MR27.
	EXTI_IMR1_MR27 = 0x8000000
	// Interrupt request line is masked
	EXTI_IMR1_MR27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR27_Unmasked = 0x1
	// Position of MR28 field.
	EXTI_IMR1_MR28_Pos = 0x1c
	// Bit mask of MR28 field.
	EXTI_IMR1_MR28_Msk = 0x10000000
	// Bit MR28.
	EXTI_IMR1_MR28 = 0x10000000
	// Interrupt request line is masked
	EXTI_IMR1_MR28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR28_Unmasked = 0x1
	// Position of MR29 field.
	EXTI_IMR1_MR29_Pos = 0x1d
	// Bit mask of MR29 field.
	EXTI_IMR1_MR29_Msk = 0x20000000
	// Bit MR29.
	EXTI_IMR1_MR29 = 0x20000000
	// Interrupt request line is masked
	EXTI_IMR1_MR29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR29_Unmasked = 0x1
	// Position of MR30 field.
	EXTI_IMR1_MR30_Pos = 0x1e
	// Bit mask of MR30 field.
	EXTI_IMR1_MR30_Msk = 0x40000000
	// Bit MR30.
	EXTI_IMR1_MR30 = 0x40000000
	// Interrupt request line is masked
	EXTI_IMR1_MR30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR30_Unmasked = 0x1
	// Position of MR31 field.
	EXTI_IMR1_MR31_Pos = 0x1f
	// Bit mask of MR31 field.
	EXTI_IMR1_MR31_Msk = 0x80000000
	// Bit MR31.
	EXTI_IMR1_MR31 = 0x80000000
	// Interrupt request line is masked
	EXTI_IMR1_MR31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_MR31_Unmasked = 0x1

	// EMR1: Event mask register
	// Position of MR0 field.
	EXTI_EMR1_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_EMR1_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_EMR1_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_EMR1_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_EMR1_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_EMR1_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_EMR1_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_EMR1_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_EMR1_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_EMR1_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_EMR1_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_EMR1_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_EMR1_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_EMR1_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_EMR1_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_EMR1_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_EMR1_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_EMR1_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_EMR1_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_EMR1_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_EMR1_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_EMR1_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_EMR1_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_EMR1_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_EMR1_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_EMR1_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_EMR1_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_EMR1_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_EMR1_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_EMR1_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_EMR1_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_EMR1_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_EMR1_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_EMR1_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_EMR1_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_EMR1_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_EMR1_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_EMR1_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_EMR1_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_EMR1_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_EMR1_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_EMR1_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_EMR1_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_EMR1_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_EMR1_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_EMR1_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_EMR1_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_EMR1_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_EMR1_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_EMR1_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_EMR1_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_EMR1_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_EMR1_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_EMR1_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_EMR1_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_EMR1_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_EMR1_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_EMR1_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_EMR1_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_EMR1_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_EMR1_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_EMR1_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_EMR1_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_EMR1_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_EMR1_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_EMR1_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_EMR1_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_EMR1_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_EMR1_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_EMR1_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_EMR1_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_EMR1_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_EMR1_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_EMR1_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_EMR1_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_EMR1_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_EMR1_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_EMR1_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_EMR1_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_EMR1_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_EMR1_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_EMR1_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_EMR1_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_EMR1_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_EMR1_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_EMR1_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_EMR1_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_EMR1_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_EMR1_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_EMR1_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_EMR1_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_EMR1_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR22_Unmasked = 0x1
	// Position of MR23 field.
	EXTI_EMR1_MR23_Pos = 0x17
	// Bit mask of MR23 field.
	EXTI_EMR1_MR23_Msk = 0x800000
	// Bit MR23.
	EXTI_EMR1_MR23 = 0x800000
	// Interrupt request line is masked
	EXTI_EMR1_MR23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR23_Unmasked = 0x1
	// Position of MR24 field.
	EXTI_EMR1_MR24_Pos = 0x18
	// Bit mask of MR24 field.
	EXTI_EMR1_MR24_Msk = 0x1000000
	// Bit MR24.
	EXTI_EMR1_MR24 = 0x1000000
	// Interrupt request line is masked
	EXTI_EMR1_MR24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR24_Unmasked = 0x1
	// Position of MR25 field.
	EXTI_EMR1_MR25_Pos = 0x19
	// Bit mask of MR25 field.
	EXTI_EMR1_MR25_Msk = 0x2000000
	// Bit MR25.
	EXTI_EMR1_MR25 = 0x2000000
	// Interrupt request line is masked
	EXTI_EMR1_MR25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR25_Unmasked = 0x1
	// Position of MR26 field.
	EXTI_EMR1_MR26_Pos = 0x1a
	// Bit mask of MR26 field.
	EXTI_EMR1_MR26_Msk = 0x4000000
	// Bit MR26.
	EXTI_EMR1_MR26 = 0x4000000
	// Interrupt request line is masked
	EXTI_EMR1_MR26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR26_Unmasked = 0x1
	// Position of MR27 field.
	EXTI_EMR1_MR27_Pos = 0x1b
	// Bit mask of MR27 field.
	EXTI_EMR1_MR27_Msk = 0x8000000
	// Bit MR27.
	EXTI_EMR1_MR27 = 0x8000000
	// Interrupt request line is masked
	EXTI_EMR1_MR27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR27_Unmasked = 0x1
	// Position of MR28 field.
	EXTI_EMR1_MR28_Pos = 0x1c
	// Bit mask of MR28 field.
	EXTI_EMR1_MR28_Msk = 0x10000000
	// Bit MR28.
	EXTI_EMR1_MR28 = 0x10000000
	// Interrupt request line is masked
	EXTI_EMR1_MR28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR28_Unmasked = 0x1
	// Position of MR29 field.
	EXTI_EMR1_MR29_Pos = 0x1d
	// Bit mask of MR29 field.
	EXTI_EMR1_MR29_Msk = 0x20000000
	// Bit MR29.
	EXTI_EMR1_MR29 = 0x20000000
	// Interrupt request line is masked
	EXTI_EMR1_MR29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR29_Unmasked = 0x1
	// Position of MR30 field.
	EXTI_EMR1_MR30_Pos = 0x1e
	// Bit mask of MR30 field.
	EXTI_EMR1_MR30_Msk = 0x40000000
	// Bit MR30.
	EXTI_EMR1_MR30 = 0x40000000
	// Interrupt request line is masked
	EXTI_EMR1_MR30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR30_Unmasked = 0x1
	// Position of MR31 field.
	EXTI_EMR1_MR31_Pos = 0x1f
	// Bit mask of MR31 field.
	EXTI_EMR1_MR31_Msk = 0x80000000
	// Bit MR31.
	EXTI_EMR1_MR31 = 0x80000000
	// Interrupt request line is masked
	EXTI_EMR1_MR31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_MR31_Unmasked = 0x1

	// RTSR1: Rising Trigger selection register
	// Position of TR0 field.
	EXTI_RTSR1_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_RTSR1_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_RTSR1_TR0 = 0x1
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR0_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_RTSR1_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_RTSR1_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_RTSR1_TR1 = 0x2
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR1_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_RTSR1_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_RTSR1_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_RTSR1_TR2 = 0x4
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR2_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_RTSR1_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_RTSR1_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_RTSR1_TR3 = 0x8
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR3_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_RTSR1_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_RTSR1_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_RTSR1_TR4 = 0x10
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR4_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_RTSR1_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_RTSR1_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_RTSR1_TR5 = 0x20
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR5_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_RTSR1_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_RTSR1_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_RTSR1_TR6 = 0x40
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR6_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_RTSR1_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_RTSR1_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_RTSR1_TR7 = 0x80
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR7_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_RTSR1_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_RTSR1_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_RTSR1_TR8 = 0x100
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR8_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_RTSR1_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_RTSR1_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_RTSR1_TR9 = 0x200
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR9_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_RTSR1_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_RTSR1_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_RTSR1_TR10 = 0x400
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR10_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_RTSR1_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_RTSR1_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_RTSR1_TR11 = 0x800
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR11_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_RTSR1_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_RTSR1_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_RTSR1_TR12 = 0x1000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR12_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_RTSR1_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_RTSR1_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_RTSR1_TR13 = 0x2000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR13_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_RTSR1_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_RTSR1_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_RTSR1_TR14 = 0x4000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR14_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_RTSR1_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_RTSR1_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_RTSR1_TR15 = 0x8000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR15_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_RTSR1_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_RTSR1_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_RTSR1_TR16 = 0x10000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR16_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR16_Enabled = 0x1
	// Position of TR18 field.
	EXTI_RTSR1_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_RTSR1_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_RTSR1_TR18 = 0x40000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR18_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR18_Enabled = 0x1
	// Position of TR19 field.
	EXTI_RTSR1_TR19_Pos = 0x13
	// Bit mask of TR19 field.
	EXTI_RTSR1_TR19_Msk = 0x80000
	// Bit TR19.
	EXTI_RTSR1_TR19 = 0x80000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR19_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR19_Enabled = 0x1
	// Position of TR20 field.
	EXTI_RTSR1_TR20_Pos = 0x14
	// Bit mask of TR20 field.
	EXTI_RTSR1_TR20_Msk = 0x100000
	// Bit TR20.
	EXTI_RTSR1_TR20 = 0x100000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR20_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR20_Enabled = 0x1
	// Position of TR21 field.
	EXTI_RTSR1_TR21_Pos = 0x15
	// Bit mask of TR21 field.
	EXTI_RTSR1_TR21_Msk = 0x200000
	// Bit TR21.
	EXTI_RTSR1_TR21 = 0x200000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR21_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR21_Enabled = 0x1
	// Position of TR22 field.
	EXTI_RTSR1_TR22_Pos = 0x16
	// Bit mask of TR22 field.
	EXTI_RTSR1_TR22_Msk = 0x400000
	// Bit TR22.
	EXTI_RTSR1_TR22 = 0x400000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR22_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR22_Enabled = 0x1

	// FTSR1: Falling Trigger selection register
	// Position of TR0 field.
	EXTI_FTSR1_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_FTSR1_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_FTSR1_TR0 = 0x1
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR0_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_FTSR1_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_FTSR1_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_FTSR1_TR1 = 0x2
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR1_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_FTSR1_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_FTSR1_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_FTSR1_TR2 = 0x4
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR2_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_FTSR1_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_FTSR1_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_FTSR1_TR3 = 0x8
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR3_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_FTSR1_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_FTSR1_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_FTSR1_TR4 = 0x10
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR4_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_FTSR1_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_FTSR1_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_FTSR1_TR5 = 0x20
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR5_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_FTSR1_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_FTSR1_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_FTSR1_TR6 = 0x40
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR6_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_FTSR1_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_FTSR1_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_FTSR1_TR7 = 0x80
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR7_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_FTSR1_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_FTSR1_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_FTSR1_TR8 = 0x100
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR8_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_FTSR1_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_FTSR1_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_FTSR1_TR9 = 0x200
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR9_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_FTSR1_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_FTSR1_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_FTSR1_TR10 = 0x400
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR10_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_FTSR1_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_FTSR1_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_FTSR1_TR11 = 0x800
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR11_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_FTSR1_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_FTSR1_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_FTSR1_TR12 = 0x1000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR12_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_FTSR1_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_FTSR1_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_FTSR1_TR13 = 0x2000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR13_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_FTSR1_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_FTSR1_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_FTSR1_TR14 = 0x4000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR14_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_FTSR1_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_FTSR1_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_FTSR1_TR15 = 0x8000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR15_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_FTSR1_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_FTSR1_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_FTSR1_TR16 = 0x10000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR16_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR16_Enabled = 0x1
	// Position of TR18 field.
	EXTI_FTSR1_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_FTSR1_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_FTSR1_TR18 = 0x40000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR18_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR18_Enabled = 0x1
	// Position of TR19 field.
	EXTI_FTSR1_TR19_Pos = 0x13
	// Bit mask of TR19 field.
	EXTI_FTSR1_TR19_Msk = 0x80000
	// Bit TR19.
	EXTI_FTSR1_TR19 = 0x80000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR19_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR19_Enabled = 0x1
	// Position of TR20 field.
	EXTI_FTSR1_TR20_Pos = 0x14
	// Bit mask of TR20 field.
	EXTI_FTSR1_TR20_Msk = 0x100000
	// Bit TR20.
	EXTI_FTSR1_TR20 = 0x100000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR20_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR20_Enabled = 0x1
	// Position of TR21 field.
	EXTI_FTSR1_TR21_Pos = 0x15
	// Bit mask of TR21 field.
	EXTI_FTSR1_TR21_Msk = 0x200000
	// Bit TR21.
	EXTI_FTSR1_TR21 = 0x200000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR21_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR21_Enabled = 0x1
	// Position of TR22 field.
	EXTI_FTSR1_TR22_Pos = 0x16
	// Bit mask of TR22 field.
	EXTI_FTSR1_TR22_Msk = 0x400000
	// Bit TR22.
	EXTI_FTSR1_TR22 = 0x400000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR22_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR22_Enabled = 0x1

	// SWIER1: Software interrupt event register
	// Position of SWIER0 field.
	EXTI_SWIER1_SWIER0_Pos = 0x0
	// Bit mask of SWIER0 field.
	EXTI_SWIER1_SWIER0_Msk = 0x1
	// Bit SWIER0.
	EXTI_SWIER1_SWIER0 = 0x1
	// Generates an interrupt request
	EXTI_SWIER1_SWIER0_Pend = 0x1
	// Position of SWIER1 field.
	EXTI_SWIER1_SWIER1_Pos = 0x1
	// Bit mask of SWIER1 field.
	EXTI_SWIER1_SWIER1_Msk = 0x2
	// Bit SWIER1.
	EXTI_SWIER1_SWIER1 = 0x2
	// Generates an interrupt request
	EXTI_SWIER1_SWIER1_Pend = 0x1
	// Position of SWIER2 field.
	EXTI_SWIER1_SWIER2_Pos = 0x2
	// Bit mask of SWIER2 field.
	EXTI_SWIER1_SWIER2_Msk = 0x4
	// Bit SWIER2.
	EXTI_SWIER1_SWIER2 = 0x4
	// Generates an interrupt request
	EXTI_SWIER1_SWIER2_Pend = 0x1
	// Position of SWIER3 field.
	EXTI_SWIER1_SWIER3_Pos = 0x3
	// Bit mask of SWIER3 field.
	EXTI_SWIER1_SWIER3_Msk = 0x8
	// Bit SWIER3.
	EXTI_SWIER1_SWIER3 = 0x8
	// Generates an interrupt request
	EXTI_SWIER1_SWIER3_Pend = 0x1
	// Position of SWIER4 field.
	EXTI_SWIER1_SWIER4_Pos = 0x4
	// Bit mask of SWIER4 field.
	EXTI_SWIER1_SWIER4_Msk = 0x10
	// Bit SWIER4.
	EXTI_SWIER1_SWIER4 = 0x10
	// Generates an interrupt request
	EXTI_SWIER1_SWIER4_Pend = 0x1
	// Position of SWIER5 field.
	EXTI_SWIER1_SWIER5_Pos = 0x5
	// Bit mask of SWIER5 field.
	EXTI_SWIER1_SWIER5_Msk = 0x20
	// Bit SWIER5.
	EXTI_SWIER1_SWIER5 = 0x20
	// Generates an interrupt request
	EXTI_SWIER1_SWIER5_Pend = 0x1
	// Position of SWIER6 field.
	EXTI_SWIER1_SWIER6_Pos = 0x6
	// Bit mask of SWIER6 field.
	EXTI_SWIER1_SWIER6_Msk = 0x40
	// Bit SWIER6.
	EXTI_SWIER1_SWIER6 = 0x40
	// Generates an interrupt request
	EXTI_SWIER1_SWIER6_Pend = 0x1
	// Position of SWIER7 field.
	EXTI_SWIER1_SWIER7_Pos = 0x7
	// Bit mask of SWIER7 field.
	EXTI_SWIER1_SWIER7_Msk = 0x80
	// Bit SWIER7.
	EXTI_SWIER1_SWIER7 = 0x80
	// Generates an interrupt request
	EXTI_SWIER1_SWIER7_Pend = 0x1
	// Position of SWIER8 field.
	EXTI_SWIER1_SWIER8_Pos = 0x8
	// Bit mask of SWIER8 field.
	EXTI_SWIER1_SWIER8_Msk = 0x100
	// Bit SWIER8.
	EXTI_SWIER1_SWIER8 = 0x100
	// Generates an interrupt request
	EXTI_SWIER1_SWIER8_Pend = 0x1
	// Position of SWIER9 field.
	EXTI_SWIER1_SWIER9_Pos = 0x9
	// Bit mask of SWIER9 field.
	EXTI_SWIER1_SWIER9_Msk = 0x200
	// Bit SWIER9.
	EXTI_SWIER1_SWIER9 = 0x200
	// Generates an interrupt request
	EXTI_SWIER1_SWIER9_Pend = 0x1
	// Position of SWIER10 field.
	EXTI_SWIER1_SWIER10_Pos = 0xa
	// Bit mask of SWIER10 field.
	EXTI_SWIER1_SWIER10_Msk = 0x400
	// Bit SWIER10.
	EXTI_SWIER1_SWIER10 = 0x400
	// Generates an interrupt request
	EXTI_SWIER1_SWIER10_Pend = 0x1
	// Position of SWIER11 field.
	EXTI_SWIER1_SWIER11_Pos = 0xb
	// Bit mask of SWIER11 field.
	EXTI_SWIER1_SWIER11_Msk = 0x800
	// Bit SWIER11.
	EXTI_SWIER1_SWIER11 = 0x800
	// Generates an interrupt request
	EXTI_SWIER1_SWIER11_Pend = 0x1
	// Position of SWIER12 field.
	EXTI_SWIER1_SWIER12_Pos = 0xc
	// Bit mask of SWIER12 field.
	EXTI_SWIER1_SWIER12_Msk = 0x1000
	// Bit SWIER12.
	EXTI_SWIER1_SWIER12 = 0x1000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER12_Pend = 0x1
	// Position of SWIER13 field.
	EXTI_SWIER1_SWIER13_Pos = 0xd
	// Bit mask of SWIER13 field.
	EXTI_SWIER1_SWIER13_Msk = 0x2000
	// Bit SWIER13.
	EXTI_SWIER1_SWIER13 = 0x2000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER13_Pend = 0x1
	// Position of SWIER14 field.
	EXTI_SWIER1_SWIER14_Pos = 0xe
	// Bit mask of SWIER14 field.
	EXTI_SWIER1_SWIER14_Msk = 0x4000
	// Bit SWIER14.
	EXTI_SWIER1_SWIER14 = 0x4000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER14_Pend = 0x1
	// Position of SWIER15 field.
	EXTI_SWIER1_SWIER15_Pos = 0xf
	// Bit mask of SWIER15 field.
	EXTI_SWIER1_SWIER15_Msk = 0x8000
	// Bit SWIER15.
	EXTI_SWIER1_SWIER15 = 0x8000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER15_Pend = 0x1
	// Position of SWIER16 field.
	EXTI_SWIER1_SWIER16_Pos = 0x10
	// Bit mask of SWIER16 field.
	EXTI_SWIER1_SWIER16_Msk = 0x10000
	// Bit SWIER16.
	EXTI_SWIER1_SWIER16 = 0x10000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER16_Pend = 0x1
	// Position of SWIER18 field.
	EXTI_SWIER1_SWIER18_Pos = 0x12
	// Bit mask of SWIER18 field.
	EXTI_SWIER1_SWIER18_Msk = 0x40000
	// Bit SWIER18.
	EXTI_SWIER1_SWIER18 = 0x40000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER18_Pend = 0x1
	// Position of SWIER19 field.
	EXTI_SWIER1_SWIER19_Pos = 0x13
	// Bit mask of SWIER19 field.
	EXTI_SWIER1_SWIER19_Msk = 0x80000
	// Bit SWIER19.
	EXTI_SWIER1_SWIER19 = 0x80000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER19_Pend = 0x1
	// Position of SWIER20 field.
	EXTI_SWIER1_SWIER20_Pos = 0x14
	// Bit mask of SWIER20 field.
	EXTI_SWIER1_SWIER20_Msk = 0x100000
	// Bit SWIER20.
	EXTI_SWIER1_SWIER20 = 0x100000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER20_Pend = 0x1
	// Position of SWIER21 field.
	EXTI_SWIER1_SWIER21_Pos = 0x15
	// Bit mask of SWIER21 field.
	EXTI_SWIER1_SWIER21_Msk = 0x200000
	// Bit SWIER21.
	EXTI_SWIER1_SWIER21 = 0x200000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER21_Pend = 0x1
	// Position of SWIER22 field.
	EXTI_SWIER1_SWIER22_Pos = 0x16
	// Bit mask of SWIER22 field.
	EXTI_SWIER1_SWIER22_Msk = 0x400000
	// Bit SWIER22.
	EXTI_SWIER1_SWIER22 = 0x400000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER22_Pend = 0x1

	// PR1: Pending register
	// Position of PR0 field.
	EXTI_PR1_PR0_Pos = 0x0
	// Bit mask of PR0 field.
	EXTI_PR1_PR0_Msk = 0x1
	// Bit PR0.
	EXTI_PR1_PR0 = 0x1
	// No trigger request occurred
	EXTI_PR1_PR0_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR0_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR0_Clear = 0x1
	// Position of PR1 field.
	EXTI_PR1_PR1_Pos = 0x1
	// Bit mask of PR1 field.
	EXTI_PR1_PR1_Msk = 0x2
	// Bit PR1.
	EXTI_PR1_PR1 = 0x2
	// No trigger request occurred
	EXTI_PR1_PR1_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR1_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR1_Clear = 0x1
	// Position of PR2 field.
	EXTI_PR1_PR2_Pos = 0x2
	// Bit mask of PR2 field.
	EXTI_PR1_PR2_Msk = 0x4
	// Bit PR2.
	EXTI_PR1_PR2 = 0x4
	// No trigger request occurred
	EXTI_PR1_PR2_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR2_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR2_Clear = 0x1
	// Position of PR3 field.
	EXTI_PR1_PR3_Pos = 0x3
	// Bit mask of PR3 field.
	EXTI_PR1_PR3_Msk = 0x8
	// Bit PR3.
	EXTI_PR1_PR3 = 0x8
	// No trigger request occurred
	EXTI_PR1_PR3_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR3_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR3_Clear = 0x1
	// Position of PR4 field.
	EXTI_PR1_PR4_Pos = 0x4
	// Bit mask of PR4 field.
	EXTI_PR1_PR4_Msk = 0x10
	// Bit PR4.
	EXTI_PR1_PR4 = 0x10
	// No trigger request occurred
	EXTI_PR1_PR4_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR4_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR4_Clear = 0x1
	// Position of PR5 field.
	EXTI_PR1_PR5_Pos = 0x5
	// Bit mask of PR5 field.
	EXTI_PR1_PR5_Msk = 0x20
	// Bit PR5.
	EXTI_PR1_PR5 = 0x20
	// No trigger request occurred
	EXTI_PR1_PR5_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR5_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR5_Clear = 0x1
	// Position of PR6 field.
	EXTI_PR1_PR6_Pos = 0x6
	// Bit mask of PR6 field.
	EXTI_PR1_PR6_Msk = 0x40
	// Bit PR6.
	EXTI_PR1_PR6 = 0x40
	// No trigger request occurred
	EXTI_PR1_PR6_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR6_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR6_Clear = 0x1
	// Position of PR7 field.
	EXTI_PR1_PR7_Pos = 0x7
	// Bit mask of PR7 field.
	EXTI_PR1_PR7_Msk = 0x80
	// Bit PR7.
	EXTI_PR1_PR7 = 0x80
	// No trigger request occurred
	EXTI_PR1_PR7_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR7_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR7_Clear = 0x1
	// Position of PR8 field.
	EXTI_PR1_PR8_Pos = 0x8
	// Bit mask of PR8 field.
	EXTI_PR1_PR8_Msk = 0x100
	// Bit PR8.
	EXTI_PR1_PR8 = 0x100
	// No trigger request occurred
	EXTI_PR1_PR8_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR8_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR8_Clear = 0x1
	// Position of PR9 field.
	EXTI_PR1_PR9_Pos = 0x9
	// Bit mask of PR9 field.
	EXTI_PR1_PR9_Msk = 0x200
	// Bit PR9.
	EXTI_PR1_PR9 = 0x200
	// No trigger request occurred
	EXTI_PR1_PR9_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR9_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR9_Clear = 0x1
	// Position of PR10 field.
	EXTI_PR1_PR10_Pos = 0xa
	// Bit mask of PR10 field.
	EXTI_PR1_PR10_Msk = 0x400
	// Bit PR10.
	EXTI_PR1_PR10 = 0x400
	// No trigger request occurred
	EXTI_PR1_PR10_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR10_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR10_Clear = 0x1
	// Position of PR11 field.
	EXTI_PR1_PR11_Pos = 0xb
	// Bit mask of PR11 field.
	EXTI_PR1_PR11_Msk = 0x800
	// Bit PR11.
	EXTI_PR1_PR11 = 0x800
	// No trigger request occurred
	EXTI_PR1_PR11_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR11_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR11_Clear = 0x1
	// Position of PR12 field.
	EXTI_PR1_PR12_Pos = 0xc
	// Bit mask of PR12 field.
	EXTI_PR1_PR12_Msk = 0x1000
	// Bit PR12.
	EXTI_PR1_PR12 = 0x1000
	// No trigger request occurred
	EXTI_PR1_PR12_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR12_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR12_Clear = 0x1
	// Position of PR13 field.
	EXTI_PR1_PR13_Pos = 0xd
	// Bit mask of PR13 field.
	EXTI_PR1_PR13_Msk = 0x2000
	// Bit PR13.
	EXTI_PR1_PR13 = 0x2000
	// No trigger request occurred
	EXTI_PR1_PR13_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR13_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR13_Clear = 0x1
	// Position of PR14 field.
	EXTI_PR1_PR14_Pos = 0xe
	// Bit mask of PR14 field.
	EXTI_PR1_PR14_Msk = 0x4000
	// Bit PR14.
	EXTI_PR1_PR14 = 0x4000
	// No trigger request occurred
	EXTI_PR1_PR14_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR14_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR14_Clear = 0x1
	// Position of PR15 field.
	EXTI_PR1_PR15_Pos = 0xf
	// Bit mask of PR15 field.
	EXTI_PR1_PR15_Msk = 0x8000
	// Bit PR15.
	EXTI_PR1_PR15 = 0x8000
	// No trigger request occurred
	EXTI_PR1_PR15_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR15_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR15_Clear = 0x1
	// Position of PR16 field.
	EXTI_PR1_PR16_Pos = 0x10
	// Bit mask of PR16 field.
	EXTI_PR1_PR16_Msk = 0x10000
	// Bit PR16.
	EXTI_PR1_PR16 = 0x10000
	// No trigger request occurred
	EXTI_PR1_PR16_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR16_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR16_Clear = 0x1
	// Position of PR18 field.
	EXTI_PR1_PR18_Pos = 0x12
	// Bit mask of PR18 field.
	EXTI_PR1_PR18_Msk = 0x40000
	// Bit PR18.
	EXTI_PR1_PR18 = 0x40000
	// No trigger request occurred
	EXTI_PR1_PR18_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR18_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR18_Clear = 0x1
	// Position of PR19 field.
	EXTI_PR1_PR19_Pos = 0x13
	// Bit mask of PR19 field.
	EXTI_PR1_PR19_Msk = 0x80000
	// Bit PR19.
	EXTI_PR1_PR19 = 0x80000
	// No trigger request occurred
	EXTI_PR1_PR19_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR19_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR19_Clear = 0x1
	// Position of PR20 field.
	EXTI_PR1_PR20_Pos = 0x14
	// Bit mask of PR20 field.
	EXTI_PR1_PR20_Msk = 0x100000
	// Bit PR20.
	EXTI_PR1_PR20 = 0x100000
	// No trigger request occurred
	EXTI_PR1_PR20_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR20_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR20_Clear = 0x1
	// Position of PR21 field.
	EXTI_PR1_PR21_Pos = 0x15
	// Bit mask of PR21 field.
	EXTI_PR1_PR21_Msk = 0x200000
	// Bit PR21.
	EXTI_PR1_PR21 = 0x200000
	// No trigger request occurred
	EXTI_PR1_PR21_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR21_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR21_Clear = 0x1
	// Position of PR22 field.
	EXTI_PR1_PR22_Pos = 0x16
	// Bit mask of PR22 field.
	EXTI_PR1_PR22_Msk = 0x400000
	// Bit PR22.
	EXTI_PR1_PR22 = 0x400000
	// No trigger request occurred
	EXTI_PR1_PR22_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR1_PR22_Pending = 0x1
	// Clears pending bit
	EXTI_PR1_PR22_Clear = 0x1

	// IMR2: Interrupt mask register
	// Position of MR32 field.
	EXTI_IMR2_MR32_Pos = 0x0
	// Bit mask of MR32 field.
	EXTI_IMR2_MR32_Msk = 0x1
	// Bit MR32.
	EXTI_IMR2_MR32 = 0x1
	// Interrupt request line is masked
	EXTI_IMR2_MR32_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR32_Unmasked = 0x1
	// Position of MR33 field.
	EXTI_IMR2_MR33_Pos = 0x1
	// Bit mask of MR33 field.
	EXTI_IMR2_MR33_Msk = 0x2
	// Bit MR33.
	EXTI_IMR2_MR33 = 0x2
	// Interrupt request line is masked
	EXTI_IMR2_MR33_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR33_Unmasked = 0x1
	// Position of MR34 field.
	EXTI_IMR2_MR34_Pos = 0x2
	// Bit mask of MR34 field.
	EXTI_IMR2_MR34_Msk = 0x4
	// Bit MR34.
	EXTI_IMR2_MR34 = 0x4
	// Interrupt request line is masked
	EXTI_IMR2_MR34_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR34_Unmasked = 0x1
	// Position of MR35 field.
	EXTI_IMR2_MR35_Pos = 0x3
	// Bit mask of MR35 field.
	EXTI_IMR2_MR35_Msk = 0x8
	// Bit MR35.
	EXTI_IMR2_MR35 = 0x8
	// Interrupt request line is masked
	EXTI_IMR2_MR35_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR35_Unmasked = 0x1
	// Position of MR36 field.
	EXTI_IMR2_MR36_Pos = 0x4
	// Bit mask of MR36 field.
	EXTI_IMR2_MR36_Msk = 0x10
	// Bit MR36.
	EXTI_IMR2_MR36 = 0x10
	// Interrupt request line is masked
	EXTI_IMR2_MR36_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR36_Unmasked = 0x1
	// Position of MR37 field.
	EXTI_IMR2_MR37_Pos = 0x5
	// Bit mask of MR37 field.
	EXTI_IMR2_MR37_Msk = 0x20
	// Bit MR37.
	EXTI_IMR2_MR37 = 0x20
	// Interrupt request line is masked
	EXTI_IMR2_MR37_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR37_Unmasked = 0x1
	// Position of MR38 field.
	EXTI_IMR2_MR38_Pos = 0x6
	// Bit mask of MR38 field.
	EXTI_IMR2_MR38_Msk = 0x40
	// Bit MR38.
	EXTI_IMR2_MR38 = 0x40
	// Interrupt request line is masked
	EXTI_IMR2_MR38_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR38_Unmasked = 0x1
	// Position of MR39 field.
	EXTI_IMR2_MR39_Pos = 0x7
	// Bit mask of MR39 field.
	EXTI_IMR2_MR39_Msk = 0x80
	// Bit MR39.
	EXTI_IMR2_MR39 = 0x80
	// Interrupt request line is masked
	EXTI_IMR2_MR39_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_MR39_Unmasked = 0x1

	// EMR2: Event mask register
	// Position of MR32 field.
	EXTI_EMR2_MR32_Pos = 0x0
	// Bit mask of MR32 field.
	EXTI_EMR2_MR32_Msk = 0x1
	// Bit MR32.
	EXTI_EMR2_MR32 = 0x1
	// Interrupt request line is masked
	EXTI_EMR2_MR32_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR32_Unmasked = 0x1
	// Position of MR33 field.
	EXTI_EMR2_MR33_Pos = 0x1
	// Bit mask of MR33 field.
	EXTI_EMR2_MR33_Msk = 0x2
	// Bit MR33.
	EXTI_EMR2_MR33 = 0x2
	// Interrupt request line is masked
	EXTI_EMR2_MR33_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR33_Unmasked = 0x1
	// Position of MR34 field.
	EXTI_EMR2_MR34_Pos = 0x2
	// Bit mask of MR34 field.
	EXTI_EMR2_MR34_Msk = 0x4
	// Bit MR34.
	EXTI_EMR2_MR34 = 0x4
	// Interrupt request line is masked
	EXTI_EMR2_MR34_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR34_Unmasked = 0x1
	// Position of MR35 field.
	EXTI_EMR2_MR35_Pos = 0x3
	// Bit mask of MR35 field.
	EXTI_EMR2_MR35_Msk = 0x8
	// Bit MR35.
	EXTI_EMR2_MR35 = 0x8
	// Interrupt request line is masked
	EXTI_EMR2_MR35_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR35_Unmasked = 0x1
	// Position of MR36 field.
	EXTI_EMR2_MR36_Pos = 0x4
	// Bit mask of MR36 field.
	EXTI_EMR2_MR36_Msk = 0x10
	// Bit MR36.
	EXTI_EMR2_MR36 = 0x10
	// Interrupt request line is masked
	EXTI_EMR2_MR36_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR36_Unmasked = 0x1
	// Position of MR37 field.
	EXTI_EMR2_MR37_Pos = 0x5
	// Bit mask of MR37 field.
	EXTI_EMR2_MR37_Msk = 0x20
	// Bit MR37.
	EXTI_EMR2_MR37 = 0x20
	// Interrupt request line is masked
	EXTI_EMR2_MR37_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR37_Unmasked = 0x1
	// Position of MR38 field.
	EXTI_EMR2_MR38_Pos = 0x6
	// Bit mask of MR38 field.
	EXTI_EMR2_MR38_Msk = 0x40
	// Bit MR38.
	EXTI_EMR2_MR38 = 0x40
	// Interrupt request line is masked
	EXTI_EMR2_MR38_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR38_Unmasked = 0x1
	// Position of MR39 field.
	EXTI_EMR2_MR39_Pos = 0x7
	// Bit mask of MR39 field.
	EXTI_EMR2_MR39_Msk = 0x80
	// Bit MR39.
	EXTI_EMR2_MR39 = 0x80
	// Interrupt request line is masked
	EXTI_EMR2_MR39_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_MR39_Unmasked = 0x1

	// RTSR2: Rising Trigger selection register
	// Position of RT35 field.
	EXTI_RTSR2_RT35_Pos = 0x3
	// Bit mask of RT35 field.
	EXTI_RTSR2_RT35_Msk = 0x8
	// Bit RT35.
	EXTI_RTSR2_RT35 = 0x8
	// Rising edge trigger is disabled
	EXTI_RTSR2_RT35_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_RT35_Enabled = 0x1
	// Position of RT36 field.
	EXTI_RTSR2_RT36_Pos = 0x4
	// Bit mask of RT36 field.
	EXTI_RTSR2_RT36_Msk = 0x10
	// Bit RT36.
	EXTI_RTSR2_RT36 = 0x10
	// Rising edge trigger is disabled
	EXTI_RTSR2_RT36_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_RT36_Enabled = 0x1
	// Position of RT37 field.
	EXTI_RTSR2_RT37_Pos = 0x5
	// Bit mask of RT37 field.
	EXTI_RTSR2_RT37_Msk = 0x20
	// Bit RT37.
	EXTI_RTSR2_RT37 = 0x20
	// Rising edge trigger is disabled
	EXTI_RTSR2_RT37_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_RT37_Enabled = 0x1
	// Position of RT38 field.
	EXTI_RTSR2_RT38_Pos = 0x6
	// Bit mask of RT38 field.
	EXTI_RTSR2_RT38_Msk = 0x40
	// Bit RT38.
	EXTI_RTSR2_RT38 = 0x40
	// Rising edge trigger is disabled
	EXTI_RTSR2_RT38_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR2_RT38_Enabled = 0x1

	// FTSR2: Falling Trigger selection register
	// Position of FT35 field.
	EXTI_FTSR2_FT35_Pos = 0x3
	// Bit mask of FT35 field.
	EXTI_FTSR2_FT35_Msk = 0x8
	// Bit FT35.
	EXTI_FTSR2_FT35 = 0x8
	// Falling edge trigger is disabled
	EXTI_FTSR2_FT35_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_FT35_Enabled = 0x1
	// Position of FT36 field.
	EXTI_FTSR2_FT36_Pos = 0x4
	// Bit mask of FT36 field.
	EXTI_FTSR2_FT36_Msk = 0x10
	// Bit FT36.
	EXTI_FTSR2_FT36 = 0x10
	// Falling edge trigger is disabled
	EXTI_FTSR2_FT36_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_FT36_Enabled = 0x1
	// Position of FT37 field.
	EXTI_FTSR2_FT37_Pos = 0x5
	// Bit mask of FT37 field.
	EXTI_FTSR2_FT37_Msk = 0x20
	// Bit FT37.
	EXTI_FTSR2_FT37 = 0x20
	// Falling edge trigger is disabled
	EXTI_FTSR2_FT37_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_FT37_Enabled = 0x1
	// Position of FT38 field.
	EXTI_FTSR2_FT38_Pos = 0x6
	// Bit mask of FT38 field.
	EXTI_FTSR2_FT38_Msk = 0x40
	// Bit FT38.
	EXTI_FTSR2_FT38 = 0x40
	// Falling edge trigger is disabled
	EXTI_FTSR2_FT38_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR2_FT38_Enabled = 0x1

	// SWIER2: Software interrupt event register
	// Position of SWI35 field.
	EXTI_SWIER2_SWI35_Pos = 0x3
	// Bit mask of SWI35 field.
	EXTI_SWIER2_SWI35_Msk = 0x8
	// Bit SWI35.
	EXTI_SWIER2_SWI35 = 0x8
	// Generates an interrupt request
	EXTI_SWIER2_SWI35_Pend = 0x1
	// Position of SWI36 field.
	EXTI_SWIER2_SWI36_Pos = 0x4
	// Bit mask of SWI36 field.
	EXTI_SWIER2_SWI36_Msk = 0x10
	// Bit SWI36.
	EXTI_SWIER2_SWI36 = 0x10
	// Generates an interrupt request
	EXTI_SWIER2_SWI36_Pend = 0x1
	// Position of SWI37 field.
	EXTI_SWIER2_SWI37_Pos = 0x5
	// Bit mask of SWI37 field.
	EXTI_SWIER2_SWI37_Msk = 0x20
	// Bit SWI37.
	EXTI_SWIER2_SWI37 = 0x20
	// Generates an interrupt request
	EXTI_SWIER2_SWI37_Pend = 0x1
	// Position of SWI38 field.
	EXTI_SWIER2_SWI38_Pos = 0x6
	// Bit mask of SWI38 field.
	EXTI_SWIER2_SWI38_Msk = 0x40
	// Bit SWI38.
	EXTI_SWIER2_SWI38 = 0x40
	// Generates an interrupt request
	EXTI_SWIER2_SWI38_Pend = 0x1

	// PR2: Pending register
	// Position of PIF35 field.
	EXTI_PR2_PIF35_Pos = 0x3
	// Bit mask of PIF35 field.
	EXTI_PR2_PIF35_Msk = 0x8
	// Bit PIF35.
	EXTI_PR2_PIF35 = 0x8
	// No trigger request occurred
	EXTI_PR2_PIF35_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR2_PIF35_Pending = 0x1
	// Clears pending bit
	EXTI_PR2_PIF35_Clear = 0x1
	// Position of PIF36 field.
	EXTI_PR2_PIF36_Pos = 0x4
	// Bit mask of PIF36 field.
	EXTI_PR2_PIF36_Msk = 0x10
	// Bit PIF36.
	EXTI_PR2_PIF36 = 0x10
	// No trigger request occurred
	EXTI_PR2_PIF36_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR2_PIF36_Pending = 0x1
	// Clears pending bit
	EXTI_PR2_PIF36_Clear = 0x1
	// Position of PIF37 field.
	EXTI_PR2_PIF37_Pos = 0x5
	// Bit mask of PIF37 field.
	EXTI_PR2_PIF37_Msk = 0x20
	// Bit PIF37.
	EXTI_PR2_PIF37 = 0x20
	// No trigger request occurred
	EXTI_PR2_PIF37_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR2_PIF37_Pending = 0x1
	// Clears pending bit
	EXTI_PR2_PIF37_Clear = 0x1
	// Position of PIF38 field.
	EXTI_PR2_PIF38_Pos = 0x6
	// Bit mask of PIF38 field.
	EXTI_PR2_PIF38_Msk = 0x40
	// Bit PIF38.
	EXTI_PR2_PIF38 = 0x40
	// No trigger request occurred
	EXTI_PR2_PIF38_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR2_PIF38_Pending = 0x1
	// Clears pending bit
	EXTI_PR2_PIF38_Clear = 0x1
)

// Constants for VREFBUF: Voltage reference buffer
const (
	// CSR: VREF control and status register
	// Position of ENVR field.
	VREF_CSR_ENVR_Pos = 0x0
	// Bit mask of ENVR field.
	VREF_CSR_ENVR_Msk = 0x1
	// Bit ENVR.
	VREF_CSR_ENVR = 0x1
	// Position of HIZ field.
	VREF_CSR_HIZ_Pos = 0x1
	// Bit mask of HIZ field.
	VREF_CSR_HIZ_Msk = 0x2
	// Bit HIZ.
	VREF_CSR_HIZ = 0x2
	// Position of VRS field.
	VREF_CSR_VRS_Pos = 0x2
	// Bit mask of VRS field.
	VREF_CSR_VRS_Msk = 0x4
	// Bit VRS.
	VREF_CSR_VRS = 0x4
	// Position of VRR field.
	VREF_CSR_VRR_Pos = 0x3
	// Bit mask of VRR field.
	VREF_CSR_VRR_Msk = 0x8
	// Bit VRR.
	VREF_CSR_VRR = 0x8

	// CCR: calibration control register
	// Position of TRIM field.
	VREF_CCR_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	VREF_CCR_TRIM_Msk = 0x3f
)

// Constants for CAN1: Controller area network
const (
	// MCR: master control register
	// Position of DBF field.
	CAN_MCR_DBF_Pos = 0x10
	// Bit mask of DBF field.
	CAN_MCR_DBF_Msk = 0x10000
	// Bit DBF.
	CAN_MCR_DBF = 0x10000
	// Position of RESET field.
	CAN_MCR_RESET_Pos = 0xf
	// Bit mask of RESET field.
	CAN_MCR_RESET_Msk = 0x8000
	// Bit RESET.
	CAN_MCR_RESET = 0x8000
	// Position of TTCM field.
	CAN_MCR_TTCM_Pos = 0x7
	// Bit mask of TTCM field.
	CAN_MCR_TTCM_Msk = 0x80
	// Bit TTCM.
	CAN_MCR_TTCM = 0x80
	// Position of ABOM field.
	CAN_MCR_ABOM_Pos = 0x6
	// Bit mask of ABOM field.
	CAN_MCR_ABOM_Msk = 0x40
	// Bit ABOM.
	CAN_MCR_ABOM = 0x40
	// Position of AWUM field.
	CAN_MCR_AWUM_Pos = 0x5
	// Bit mask of AWUM field.
	CAN_MCR_AWUM_Msk = 0x20
	// Bit AWUM.
	CAN_MCR_AWUM = 0x20
	// Position of NART field.
	CAN_MCR_NART_Pos = 0x4
	// Bit mask of NART field.
	CAN_MCR_NART_Msk = 0x10
	// Bit NART.
	CAN_MCR_NART = 0x10
	// Position of RFLM field.
	CAN_MCR_RFLM_Pos = 0x3
	// Bit mask of RFLM field.
	CAN_MCR_RFLM_Msk = 0x8
	// Bit RFLM.
	CAN_MCR_RFLM = 0x8
	// Position of TXFP field.
	CAN_MCR_TXFP_Pos = 0x2
	// Bit mask of TXFP field.
	CAN_MCR_TXFP_Msk = 0x4
	// Bit TXFP.
	CAN_MCR_TXFP = 0x4
	// Position of SLEEP field.
	CAN_MCR_SLEEP_Pos = 0x1
	// Bit mask of SLEEP field.
	CAN_MCR_SLEEP_Msk = 0x2
	// Bit SLEEP.
	CAN_MCR_SLEEP = 0x2
	// Position of INRQ field.
	CAN_MCR_INRQ_Pos = 0x0
	// Bit mask of INRQ field.
	CAN_MCR_INRQ_Msk = 0x1
	// Bit INRQ.
	CAN_MCR_INRQ = 0x1

	// MSR: master status register
	// Position of RX field.
	CAN_MSR_RX_Pos = 0xb
	// Bit mask of RX field.
	CAN_MSR_RX_Msk = 0x800
	// Bit RX.
	CAN_MSR_RX = 0x800
	// Position of SAMP field.
	CAN_MSR_SAMP_Pos = 0xa
	// Bit mask of SAMP field.
	CAN_MSR_SAMP_Msk = 0x400
	// Bit SAMP.
	CAN_MSR_SAMP = 0x400
	// Position of RXM field.
	CAN_MSR_RXM_Pos = 0x9
	// Bit mask of RXM field.
	CAN_MSR_RXM_Msk = 0x200
	// Bit RXM.
	CAN_MSR_RXM = 0x200
	// Position of TXM field.
	CAN_MSR_TXM_Pos = 0x8
	// Bit mask of TXM field.
	CAN_MSR_TXM_Msk = 0x100
	// Bit TXM.
	CAN_MSR_TXM = 0x100
	// Position of SLAKI field.
	CAN_MSR_SLAKI_Pos = 0x4
	// Bit mask of SLAKI field.
	CAN_MSR_SLAKI_Msk = 0x10
	// Bit SLAKI.
	CAN_MSR_SLAKI = 0x10
	// Position of WKUI field.
	CAN_MSR_WKUI_Pos = 0x3
	// Bit mask of WKUI field.
	CAN_MSR_WKUI_Msk = 0x8
	// Bit WKUI.
	CAN_MSR_WKUI = 0x8
	// Position of ERRI field.
	CAN_MSR_ERRI_Pos = 0x2
	// Bit mask of ERRI field.
	CAN_MSR_ERRI_Msk = 0x4
	// Bit ERRI.
	CAN_MSR_ERRI = 0x4
	// Position of SLAK field.
	CAN_MSR_SLAK_Pos = 0x1
	// Bit mask of SLAK field.
	CAN_MSR_SLAK_Msk = 0x2
	// Bit SLAK.
	CAN_MSR_SLAK = 0x2
	// Position of INAK field.
	CAN_MSR_INAK_Pos = 0x0
	// Bit mask of INAK field.
	CAN_MSR_INAK_Msk = 0x1
	// Bit INAK.
	CAN_MSR_INAK = 0x1

	// TSR: transmit status register
	// Position of LOW2 field.
	CAN_TSR_LOW2_Pos = 0x1f
	// Bit mask of LOW2 field.
	CAN_TSR_LOW2_Msk = 0x80000000
	// Bit LOW2.
	CAN_TSR_LOW2 = 0x80000000
	// Position of LOW1 field.
	CAN_TSR_LOW1_Pos = 0x1e
	// Bit mask of LOW1 field.
	CAN_TSR_LOW1_Msk = 0x40000000
	// Bit LOW1.
	CAN_TSR_LOW1 = 0x40000000
	// Position of LOW0 field.
	CAN_TSR_LOW0_Pos = 0x1d
	// Bit mask of LOW0 field.
	CAN_TSR_LOW0_Msk = 0x20000000
	// Bit LOW0.
	CAN_TSR_LOW0 = 0x20000000
	// Position of TME2 field.
	CAN_TSR_TME2_Pos = 0x1c
	// Bit mask of TME2 field.
	CAN_TSR_TME2_Msk = 0x10000000
	// Bit TME2.
	CAN_TSR_TME2 = 0x10000000
	// Position of TME1 field.
	CAN_TSR_TME1_Pos = 0x1b
	// Bit mask of TME1 field.
	CAN_TSR_TME1_Msk = 0x8000000
	// Bit TME1.
	CAN_TSR_TME1 = 0x8000000
	// Position of TME0 field.
	CAN_TSR_TME0_Pos = 0x1a
	// Bit mask of TME0 field.
	CAN_TSR_TME0_Msk = 0x4000000
	// Bit TME0.
	CAN_TSR_TME0 = 0x4000000
	// Position of CODE field.
	CAN_TSR_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_TSR_CODE_Msk = 0x3000000
	// Position of ABRQ2 field.
	CAN_TSR_ABRQ2_Pos = 0x17
	// Bit mask of ABRQ2 field.
	CAN_TSR_ABRQ2_Msk = 0x800000
	// Bit ABRQ2.
	CAN_TSR_ABRQ2 = 0x800000
	// Position of TERR2 field.
	CAN_TSR_TERR2_Pos = 0x13
	// Bit mask of TERR2 field.
	CAN_TSR_TERR2_Msk = 0x80000
	// Bit TERR2.
	CAN_TSR_TERR2 = 0x80000
	// Position of ALST2 field.
	CAN_TSR_ALST2_Pos = 0x12
	// Bit mask of ALST2 field.
	CAN_TSR_ALST2_Msk = 0x40000
	// Bit ALST2.
	CAN_TSR_ALST2 = 0x40000
	// Position of TXOK2 field.
	CAN_TSR_TXOK2_Pos = 0x11
	// Bit mask of TXOK2 field.
	CAN_TSR_TXOK2_Msk = 0x20000
	// Bit TXOK2.
	CAN_TSR_TXOK2 = 0x20000
	// Position of RQCP2 field.
	CAN_TSR_RQCP2_Pos = 0x10
	// Bit mask of RQCP2 field.
	CAN_TSR_RQCP2_Msk = 0x10000
	// Bit RQCP2.
	CAN_TSR_RQCP2 = 0x10000
	// Position of ABRQ1 field.
	CAN_TSR_ABRQ1_Pos = 0xf
	// Bit mask of ABRQ1 field.
	CAN_TSR_ABRQ1_Msk = 0x8000
	// Bit ABRQ1.
	CAN_TSR_ABRQ1 = 0x8000
	// Position of TERR1 field.
	CAN_TSR_TERR1_Pos = 0xb
	// Bit mask of TERR1 field.
	CAN_TSR_TERR1_Msk = 0x800
	// Bit TERR1.
	CAN_TSR_TERR1 = 0x800
	// Position of ALST1 field.
	CAN_TSR_ALST1_Pos = 0xa
	// Bit mask of ALST1 field.
	CAN_TSR_ALST1_Msk = 0x400
	// Bit ALST1.
	CAN_TSR_ALST1 = 0x400
	// Position of TXOK1 field.
	CAN_TSR_TXOK1_Pos = 0x9
	// Bit mask of TXOK1 field.
	CAN_TSR_TXOK1_Msk = 0x200
	// Bit TXOK1.
	CAN_TSR_TXOK1 = 0x200
	// Position of RQCP1 field.
	CAN_TSR_RQCP1_Pos = 0x8
	// Bit mask of RQCP1 field.
	CAN_TSR_RQCP1_Msk = 0x100
	// Bit RQCP1.
	CAN_TSR_RQCP1 = 0x100
	// Position of ABRQ0 field.
	CAN_TSR_ABRQ0_Pos = 0x7
	// Bit mask of ABRQ0 field.
	CAN_TSR_ABRQ0_Msk = 0x80
	// Bit ABRQ0.
	CAN_TSR_ABRQ0 = 0x80
	// Position of TERR0 field.
	CAN_TSR_TERR0_Pos = 0x3
	// Bit mask of TERR0 field.
	CAN_TSR_TERR0_Msk = 0x8
	// Bit TERR0.
	CAN_TSR_TERR0 = 0x8
	// Position of ALST0 field.
	CAN_TSR_ALST0_Pos = 0x2
	// Bit mask of ALST0 field.
	CAN_TSR_ALST0_Msk = 0x4
	// Bit ALST0.
	CAN_TSR_ALST0 = 0x4
	// Position of TXOK0 field.
	CAN_TSR_TXOK0_Pos = 0x1
	// Bit mask of TXOK0 field.
	CAN_TSR_TXOK0_Msk = 0x2
	// Bit TXOK0.
	CAN_TSR_TXOK0 = 0x2
	// Position of RQCP0 field.
	CAN_TSR_RQCP0_Pos = 0x0
	// Bit mask of RQCP0 field.
	CAN_TSR_RQCP0_Msk = 0x1
	// Bit RQCP0.
	CAN_TSR_RQCP0 = 0x1

	// RF0R: receive FIFO %s register
	// Position of RFOM field.
	CAN_RFR_RFOM_Pos = 0x5
	// Bit mask of RFOM field.
	CAN_RFR_RFOM_Msk = 0x20
	// Bit RFOM.
	CAN_RFR_RFOM = 0x20
	// Set by software to release the output mailbox of the FIFO
	CAN_RFR_RFOM_Release = 0x1
	// Position of FOVR field.
	CAN_RFR_FOVR_Pos = 0x4
	// Bit mask of FOVR field.
	CAN_RFR_FOVR_Msk = 0x10
	// Bit FOVR.
	CAN_RFR_FOVR = 0x10
	// No FIFO x overrun
	CAN_RFR_FOVR_NoOverrun = 0x0
	// FIFO x overrun
	CAN_RFR_FOVR_Overrun = 0x1
	// Clear flag
	CAN_RFR_FOVR_Clear = 0x1
	// Position of FULL field.
	CAN_RFR_FULL_Pos = 0x3
	// Bit mask of FULL field.
	CAN_RFR_FULL_Msk = 0x8
	// Bit FULL.
	CAN_RFR_FULL = 0x8
	// FIFO x is not full
	CAN_RFR_FULL_NotFull = 0x0
	// FIFO x is full
	CAN_RFR_FULL_Full = 0x1
	// Clear flag
	CAN_RFR_FULL_Clear = 0x1
	// Position of FMP field.
	CAN_RFR_FMP_Pos = 0x0
	// Bit mask of FMP field.
	CAN_RFR_FMP_Msk = 0x3

	// IER: interrupt enable register
	// Position of SLKIE field.
	CAN_IER_SLKIE_Pos = 0x11
	// Bit mask of SLKIE field.
	CAN_IER_SLKIE_Msk = 0x20000
	// Bit SLKIE.
	CAN_IER_SLKIE = 0x20000
	// No interrupt when SLAKI bit is set
	CAN_IER_SLKIE_Disabled = 0x0
	// Interrupt generated when SLAKI bit is set
	CAN_IER_SLKIE_Enabled = 0x1
	// Position of WKUIE field.
	CAN_IER_WKUIE_Pos = 0x10
	// Bit mask of WKUIE field.
	CAN_IER_WKUIE_Msk = 0x10000
	// Bit WKUIE.
	CAN_IER_WKUIE = 0x10000
	// No interrupt when WKUI is set
	CAN_IER_WKUIE_Disabled = 0x0
	// Interrupt generated when WKUI bit is set
	CAN_IER_WKUIE_Enabled = 0x1
	// Position of ERRIE field.
	CAN_IER_ERRIE_Pos = 0xf
	// Bit mask of ERRIE field.
	CAN_IER_ERRIE_Msk = 0x8000
	// Bit ERRIE.
	CAN_IER_ERRIE = 0x8000
	// No interrupt will be generated when an error condition is pending in the CAN_ESR
	CAN_IER_ERRIE_Disabled = 0x0
	// An interrupt will be generation when an error condition is pending in the CAN_ESR
	CAN_IER_ERRIE_Enabled = 0x1
	// Position of LECIE field.
	CAN_IER_LECIE_Pos = 0xb
	// Bit mask of LECIE field.
	CAN_IER_LECIE_Msk = 0x800
	// Bit LECIE.
	CAN_IER_LECIE = 0x800
	// ERRI bit will not be set when the error code in LEC[2:0] is set by hardware on error detection
	CAN_IER_LECIE_Disabled = 0x0
	// ERRI bit will be set when the error code in LEC[2:0] is set by hardware on error detection
	CAN_IER_LECIE_Enabled = 0x1
	// Position of BOFIE field.
	CAN_IER_BOFIE_Pos = 0xa
	// Bit mask of BOFIE field.
	CAN_IER_BOFIE_Msk = 0x400
	// Bit BOFIE.
	CAN_IER_BOFIE = 0x400
	// ERRI bit will not be set when BOFF is set
	CAN_IER_BOFIE_Disabled = 0x0
	// ERRI bit will be set when BOFF is set
	CAN_IER_BOFIE_Enabled = 0x1
	// Position of EPVIE field.
	CAN_IER_EPVIE_Pos = 0x9
	// Bit mask of EPVIE field.
	CAN_IER_EPVIE_Msk = 0x200
	// Bit EPVIE.
	CAN_IER_EPVIE = 0x200
	// ERRI bit will not be set when EPVF is set
	CAN_IER_EPVIE_Disabled = 0x0
	// ERRI bit will be set when EPVF is set
	CAN_IER_EPVIE_Enabled = 0x1
	// Position of EWGIE field.
	CAN_IER_EWGIE_Pos = 0x8
	// Bit mask of EWGIE field.
	CAN_IER_EWGIE_Msk = 0x100
	// Bit EWGIE.
	CAN_IER_EWGIE = 0x100
	// ERRI bit will not be set when EWGF is set
	CAN_IER_EWGIE_Disabled = 0x0
	// ERRI bit will be set when EWGF is set
	CAN_IER_EWGIE_Enabled = 0x1
	// Position of FOVIE1 field.
	CAN_IER_FOVIE1_Pos = 0x6
	// Bit mask of FOVIE1 field.
	CAN_IER_FOVIE1_Msk = 0x40
	// Bit FOVIE1.
	CAN_IER_FOVIE1 = 0x40
	// No interrupt when FOVR is set
	CAN_IER_FOVIE1_Disabled = 0x0
	// Interrupt generation when FOVR is set
	CAN_IER_FOVIE1_Enabled = 0x1
	// Position of FFIE1 field.
	CAN_IER_FFIE1_Pos = 0x5
	// Bit mask of FFIE1 field.
	CAN_IER_FFIE1_Msk = 0x20
	// Bit FFIE1.
	CAN_IER_FFIE1 = 0x20
	// No interrupt when FULL bit is set
	CAN_IER_FFIE1_Disabled = 0x0
	// Interrupt generated when FULL bit is set
	CAN_IER_FFIE1_Enabled = 0x1
	// Position of FMPIE1 field.
	CAN_IER_FMPIE1_Pos = 0x4
	// Bit mask of FMPIE1 field.
	CAN_IER_FMPIE1_Msk = 0x10
	// Bit FMPIE1.
	CAN_IER_FMPIE1 = 0x10
	// No interrupt generated when state of FMP[1:0] bits are not 00b
	CAN_IER_FMPIE1_Disabled = 0x0
	// Interrupt generated when state of FMP[1:0] bits are not 00b
	CAN_IER_FMPIE1_Enabled = 0x1
	// Position of FOVIE0 field.
	CAN_IER_FOVIE0_Pos = 0x3
	// Bit mask of FOVIE0 field.
	CAN_IER_FOVIE0_Msk = 0x8
	// Bit FOVIE0.
	CAN_IER_FOVIE0 = 0x8
	// No interrupt when FOVR bit is set
	CAN_IER_FOVIE0_Disabled = 0x0
	// Interrupt generated when FOVR bit is set
	CAN_IER_FOVIE0_Enabled = 0x1
	// Position of FFIE0 field.
	CAN_IER_FFIE0_Pos = 0x2
	// Bit mask of FFIE0 field.
	CAN_IER_FFIE0_Msk = 0x4
	// Bit FFIE0.
	CAN_IER_FFIE0 = 0x4
	// No interrupt when FULL bit is set
	CAN_IER_FFIE0_Disabled = 0x0
	// Interrupt generated when FULL bit is set
	CAN_IER_FFIE0_Enabled = 0x1
	// Position of FMPIE0 field.
	CAN_IER_FMPIE0_Pos = 0x1
	// Bit mask of FMPIE0 field.
	CAN_IER_FMPIE0_Msk = 0x2
	// Bit FMPIE0.
	CAN_IER_FMPIE0 = 0x2
	// No interrupt generated when state of FMP[1:0] bits are not 00
	CAN_IER_FMPIE0_Disabled = 0x0
	// Interrupt generated when state of FMP[1:0] bits are not 00b
	CAN_IER_FMPIE0_Enabled = 0x1
	// Position of TMEIE field.
	CAN_IER_TMEIE_Pos = 0x0
	// Bit mask of TMEIE field.
	CAN_IER_TMEIE_Msk = 0x1
	// Bit TMEIE.
	CAN_IER_TMEIE = 0x1
	// No interrupt when RQCPx bit is set
	CAN_IER_TMEIE_Disabled = 0x0
	// Interrupt generated when RQCPx bit is set
	CAN_IER_TMEIE_Enabled = 0x1

	// ESR: interrupt enable register
	// Position of REC field.
	CAN_ESR_REC_Pos = 0x18
	// Bit mask of REC field.
	CAN_ESR_REC_Msk = 0xff000000
	// Position of TEC field.
	CAN_ESR_TEC_Pos = 0x10
	// Bit mask of TEC field.
	CAN_ESR_TEC_Msk = 0xff0000
	// Position of LEC field.
	CAN_ESR_LEC_Pos = 0x4
	// Bit mask of LEC field.
	CAN_ESR_LEC_Msk = 0x70
	// No Error
	CAN_ESR_LEC_NoError = 0x0
	// Stuff Error
	CAN_ESR_LEC_Stuff = 0x1
	// Form Error
	CAN_ESR_LEC_Form = 0x2
	// Acknowledgment Error
	CAN_ESR_LEC_Ack = 0x3
	// Bit recessive Error
	CAN_ESR_LEC_BitRecessive = 0x4
	// Bit dominant Error
	CAN_ESR_LEC_BitDominant = 0x5
	// CRC Error
	CAN_ESR_LEC_Crc = 0x6
	// Set by software
	CAN_ESR_LEC_Custom = 0x7
	// Position of BOFF field.
	CAN_ESR_BOFF_Pos = 0x2
	// Bit mask of BOFF field.
	CAN_ESR_BOFF_Msk = 0x4
	// Bit BOFF.
	CAN_ESR_BOFF = 0x4
	// Position of EPVF field.
	CAN_ESR_EPVF_Pos = 0x1
	// Bit mask of EPVF field.
	CAN_ESR_EPVF_Msk = 0x2
	// Bit EPVF.
	CAN_ESR_EPVF = 0x2
	// Position of EWGF field.
	CAN_ESR_EWGF_Pos = 0x0
	// Bit mask of EWGF field.
	CAN_ESR_EWGF_Msk = 0x1
	// Bit EWGF.
	CAN_ESR_EWGF = 0x1

	// BTR: bit timing register
	// Position of SILM field.
	CAN_BTR_SILM_Pos = 0x1f
	// Bit mask of SILM field.
	CAN_BTR_SILM_Msk = 0x80000000
	// Bit SILM.
	CAN_BTR_SILM = 0x80000000
	// Normal operation
	CAN_BTR_SILM_Normal = 0x0
	// Silent Mode
	CAN_BTR_SILM_Silent = 0x1
	// Position of LBKM field.
	CAN_BTR_LBKM_Pos = 0x1e
	// Bit mask of LBKM field.
	CAN_BTR_LBKM_Msk = 0x40000000
	// Bit LBKM.
	CAN_BTR_LBKM = 0x40000000
	// Loop Back Mode disabled
	CAN_BTR_LBKM_Disabled = 0x0
	// Loop Back Mode enabled
	CAN_BTR_LBKM_Enabled = 0x1
	// Position of SJW field.
	CAN_BTR_SJW_Pos = 0x18
	// Bit mask of SJW field.
	CAN_BTR_SJW_Msk = 0x3000000
	// Position of TS2 field.
	CAN_BTR_TS2_Pos = 0x14
	// Bit mask of TS2 field.
	CAN_BTR_TS2_Msk = 0x700000
	// Position of TS1 field.
	CAN_BTR_TS1_Pos = 0x10
	// Bit mask of TS1 field.
	CAN_BTR_TS1_Msk = 0xf0000
	// Position of BRP field.
	CAN_BTR_BRP_Pos = 0x0
	// Bit mask of BRP field.
	CAN_BTR_BRP_Msk = 0x3ff

	// TX.TIR: TX mailbox identifier register
	// Position of STID field.
	CAN_TX_TIR_STID_Pos = 0x15
	// Bit mask of STID field.
	CAN_TX_TIR_STID_Msk = 0xffe00000
	// Position of EXID field.
	CAN_TX_TIR_EXID_Pos = 0x3
	// Bit mask of EXID field.
	CAN_TX_TIR_EXID_Msk = 0x1ffff8
	// Position of IDE field.
	CAN_TX_TIR_IDE_Pos = 0x2
	// Bit mask of IDE field.
	CAN_TX_TIR_IDE_Msk = 0x4
	// Bit IDE.
	CAN_TX_TIR_IDE = 0x4
	// Standard identifier
	CAN_TX_TIR_IDE_Standard = 0x0
	// Extended identifier
	CAN_TX_TIR_IDE_Extended = 0x1
	// Position of RTR field.
	CAN_TX_TIR_RTR_Pos = 0x1
	// Bit mask of RTR field.
	CAN_TX_TIR_RTR_Msk = 0x2
	// Bit RTR.
	CAN_TX_TIR_RTR = 0x2
	// Data frame
	CAN_TX_TIR_RTR_Data = 0x0
	// Remote frame
	CAN_TX_TIR_RTR_Remote = 0x1
	// Position of TXRQ field.
	CAN_TX_TIR_TXRQ_Pos = 0x0
	// Bit mask of TXRQ field.
	CAN_TX_TIR_TXRQ_Msk = 0x1
	// Bit TXRQ.
	CAN_TX_TIR_TXRQ = 0x1

	// TX.TDTR: mailbox data length control and time stamp register
	// Position of TIME field.
	CAN_TX_TDTR_TIME_Pos = 0x10
	// Bit mask of TIME field.
	CAN_TX_TDTR_TIME_Msk = 0xffff0000
	// Position of TGT field.
	CAN_TX_TDTR_TGT_Pos = 0x8
	// Bit mask of TGT field.
	CAN_TX_TDTR_TGT_Msk = 0x100
	// Bit TGT.
	CAN_TX_TDTR_TGT = 0x100
	// Position of DLC field.
	CAN_TX_TDTR_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN_TX_TDTR_DLC_Msk = 0xf

	// TX.TDLR: mailbox data low register
	// Position of DATA3 field.
	CAN_TX_TDLR_DATA3_Pos = 0x18
	// Bit mask of DATA3 field.
	CAN_TX_TDLR_DATA3_Msk = 0xff000000
	// Position of DATA2 field.
	CAN_TX_TDLR_DATA2_Pos = 0x10
	// Bit mask of DATA2 field.
	CAN_TX_TDLR_DATA2_Msk = 0xff0000
	// Position of DATA1 field.
	CAN_TX_TDLR_DATA1_Pos = 0x8
	// Bit mask of DATA1 field.
	CAN_TX_TDLR_DATA1_Msk = 0xff00
	// Position of DATA0 field.
	CAN_TX_TDLR_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN_TX_TDLR_DATA0_Msk = 0xff

	// TX.TDHR: mailbox data high register
	// Position of DATA7 field.
	CAN_TX_TDHR_DATA7_Pos = 0x18
	// Bit mask of DATA7 field.
	CAN_TX_TDHR_DATA7_Msk = 0xff000000
	// Position of DATA6 field.
	CAN_TX_TDHR_DATA6_Pos = 0x10
	// Bit mask of DATA6 field.
	CAN_TX_TDHR_DATA6_Msk = 0xff0000
	// Position of DATA5 field.
	CAN_TX_TDHR_DATA5_Pos = 0x8
	// Bit mask of DATA5 field.
	CAN_TX_TDHR_DATA5_Msk = 0xff00
	// Position of DATA4 field.
	CAN_TX_TDHR_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN_TX_TDHR_DATA4_Msk = 0xff

	// RX.RIR: receive FIFO mailbox identifier register
	// Position of STID field.
	CAN_RX_RIR_STID_Pos = 0x15
	// Bit mask of STID field.
	CAN_RX_RIR_STID_Msk = 0xffe00000
	// Position of EXID field.
	CAN_RX_RIR_EXID_Pos = 0x3
	// Bit mask of EXID field.
	CAN_RX_RIR_EXID_Msk = 0x1ffff8
	// Position of IDE field.
	CAN_RX_RIR_IDE_Pos = 0x2
	// Bit mask of IDE field.
	CAN_RX_RIR_IDE_Msk = 0x4
	// Bit IDE.
	CAN_RX_RIR_IDE = 0x4
	// Standard identifier
	CAN_RX_RIR_IDE_Standard = 0x0
	// Extended identifier
	CAN_RX_RIR_IDE_Extended = 0x1
	// Position of RTR field.
	CAN_RX_RIR_RTR_Pos = 0x1
	// Bit mask of RTR field.
	CAN_RX_RIR_RTR_Msk = 0x2
	// Bit RTR.
	CAN_RX_RIR_RTR = 0x2
	// Data frame
	CAN_RX_RIR_RTR_Data = 0x0
	// Remote frame
	CAN_RX_RIR_RTR_Remote = 0x1

	// RX.RDTR: mailbox data high register
	// Position of TIME field.
	CAN_RX_RDTR_TIME_Pos = 0x10
	// Bit mask of TIME field.
	CAN_RX_RDTR_TIME_Msk = 0xffff0000
	// Position of FMI field.
	CAN_RX_RDTR_FMI_Pos = 0x8
	// Bit mask of FMI field.
	CAN_RX_RDTR_FMI_Msk = 0xff00
	// Position of DLC field.
	CAN_RX_RDTR_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN_RX_RDTR_DLC_Msk = 0xf

	// RX.RDLR: mailbox data high register
	// Position of DATA3 field.
	CAN_RX_RDLR_DATA3_Pos = 0x18
	// Bit mask of DATA3 field.
	CAN_RX_RDLR_DATA3_Msk = 0xff000000
	// Position of DATA2 field.
	CAN_RX_RDLR_DATA2_Pos = 0x10
	// Bit mask of DATA2 field.
	CAN_RX_RDLR_DATA2_Msk = 0xff0000
	// Position of DATA1 field.
	CAN_RX_RDLR_DATA1_Pos = 0x8
	// Bit mask of DATA1 field.
	CAN_RX_RDLR_DATA1_Msk = 0xff00
	// Position of DATA0 field.
	CAN_RX_RDLR_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN_RX_RDLR_DATA0_Msk = 0xff

	// RX.RDHR: receive FIFO mailbox data high register
	// Position of DATA7 field.
	CAN_RX_RDHR_DATA7_Pos = 0x18
	// Bit mask of DATA7 field.
	CAN_RX_RDHR_DATA7_Msk = 0xff000000
	// Position of DATA6 field.
	CAN_RX_RDHR_DATA6_Pos = 0x10
	// Bit mask of DATA6 field.
	CAN_RX_RDHR_DATA6_Msk = 0xff0000
	// Position of DATA5 field.
	CAN_RX_RDHR_DATA5_Pos = 0x8
	// Bit mask of DATA5 field.
	CAN_RX_RDHR_DATA5_Msk = 0xff00
	// Position of DATA4 field.
	CAN_RX_RDHR_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN_RX_RDHR_DATA4_Msk = 0xff

	// FMR: filter master register
	// Position of FINIT field.
	CAN_FMR_FINIT_Pos = 0x0
	// Bit mask of FINIT field.
	CAN_FMR_FINIT_Msk = 0x1
	// Bit FINIT.
	CAN_FMR_FINIT = 0x1
	// Position of CANSB field.
	CAN_FMR_CANSB_Pos = 0x8
	// Bit mask of CANSB field.
	CAN_FMR_CANSB_Msk = 0x3f00

	// FM1R: filter mode register
	// Position of FBM0 field.
	CAN_FM1R_FBM0_Pos = 0x0
	// Bit mask of FBM0 field.
	CAN_FM1R_FBM0_Msk = 0x1
	// Bit FBM0.
	CAN_FM1R_FBM0 = 0x1
	// Position of FBM1 field.
	CAN_FM1R_FBM1_Pos = 0x1
	// Bit mask of FBM1 field.
	CAN_FM1R_FBM1_Msk = 0x2
	// Bit FBM1.
	CAN_FM1R_FBM1 = 0x2
	// Position of FBM2 field.
	CAN_FM1R_FBM2_Pos = 0x2
	// Bit mask of FBM2 field.
	CAN_FM1R_FBM2_Msk = 0x4
	// Bit FBM2.
	CAN_FM1R_FBM2 = 0x4
	// Position of FBM3 field.
	CAN_FM1R_FBM3_Pos = 0x3
	// Bit mask of FBM3 field.
	CAN_FM1R_FBM3_Msk = 0x8
	// Bit FBM3.
	CAN_FM1R_FBM3 = 0x8
	// Position of FBM4 field.
	CAN_FM1R_FBM4_Pos = 0x4
	// Bit mask of FBM4 field.
	CAN_FM1R_FBM4_Msk = 0x10
	// Bit FBM4.
	CAN_FM1R_FBM4 = 0x10
	// Position of FBM5 field.
	CAN_FM1R_FBM5_Pos = 0x5
	// Bit mask of FBM5 field.
	CAN_FM1R_FBM5_Msk = 0x20
	// Bit FBM5.
	CAN_FM1R_FBM5 = 0x20
	// Position of FBM6 field.
	CAN_FM1R_FBM6_Pos = 0x6
	// Bit mask of FBM6 field.
	CAN_FM1R_FBM6_Msk = 0x40
	// Bit FBM6.
	CAN_FM1R_FBM6 = 0x40
	// Position of FBM7 field.
	CAN_FM1R_FBM7_Pos = 0x7
	// Bit mask of FBM7 field.
	CAN_FM1R_FBM7_Msk = 0x80
	// Bit FBM7.
	CAN_FM1R_FBM7 = 0x80
	// Position of FBM8 field.
	CAN_FM1R_FBM8_Pos = 0x8
	// Bit mask of FBM8 field.
	CAN_FM1R_FBM8_Msk = 0x100
	// Bit FBM8.
	CAN_FM1R_FBM8 = 0x100
	// Position of FBM9 field.
	CAN_FM1R_FBM9_Pos = 0x9
	// Bit mask of FBM9 field.
	CAN_FM1R_FBM9_Msk = 0x200
	// Bit FBM9.
	CAN_FM1R_FBM9 = 0x200
	// Position of FBM10 field.
	CAN_FM1R_FBM10_Pos = 0xa
	// Bit mask of FBM10 field.
	CAN_FM1R_FBM10_Msk = 0x400
	// Bit FBM10.
	CAN_FM1R_FBM10 = 0x400
	// Position of FBM11 field.
	CAN_FM1R_FBM11_Pos = 0xb
	// Bit mask of FBM11 field.
	CAN_FM1R_FBM11_Msk = 0x800
	// Bit FBM11.
	CAN_FM1R_FBM11 = 0x800
	// Position of FBM12 field.
	CAN_FM1R_FBM12_Pos = 0xc
	// Bit mask of FBM12 field.
	CAN_FM1R_FBM12_Msk = 0x1000
	// Bit FBM12.
	CAN_FM1R_FBM12 = 0x1000
	// Position of FBM13 field.
	CAN_FM1R_FBM13_Pos = 0xd
	// Bit mask of FBM13 field.
	CAN_FM1R_FBM13_Msk = 0x2000
	// Bit FBM13.
	CAN_FM1R_FBM13 = 0x2000
	// Position of FBM14 field.
	CAN_FM1R_FBM14_Pos = 0xe
	// Bit mask of FBM14 field.
	CAN_FM1R_FBM14_Msk = 0x4000
	// Bit FBM14.
	CAN_FM1R_FBM14 = 0x4000
	// Position of FBM15 field.
	CAN_FM1R_FBM15_Pos = 0xf
	// Bit mask of FBM15 field.
	CAN_FM1R_FBM15_Msk = 0x8000
	// Bit FBM15.
	CAN_FM1R_FBM15 = 0x8000
	// Position of FBM16 field.
	CAN_FM1R_FBM16_Pos = 0x10
	// Bit mask of FBM16 field.
	CAN_FM1R_FBM16_Msk = 0x10000
	// Bit FBM16.
	CAN_FM1R_FBM16 = 0x10000
	// Position of FBM17 field.
	CAN_FM1R_FBM17_Pos = 0x11
	// Bit mask of FBM17 field.
	CAN_FM1R_FBM17_Msk = 0x20000
	// Bit FBM17.
	CAN_FM1R_FBM17 = 0x20000
	// Position of FBM18 field.
	CAN_FM1R_FBM18_Pos = 0x12
	// Bit mask of FBM18 field.
	CAN_FM1R_FBM18_Msk = 0x40000
	// Bit FBM18.
	CAN_FM1R_FBM18 = 0x40000
	// Position of FBM19 field.
	CAN_FM1R_FBM19_Pos = 0x13
	// Bit mask of FBM19 field.
	CAN_FM1R_FBM19_Msk = 0x80000
	// Bit FBM19.
	CAN_FM1R_FBM19 = 0x80000
	// Position of FBM20 field.
	CAN_FM1R_FBM20_Pos = 0x14
	// Bit mask of FBM20 field.
	CAN_FM1R_FBM20_Msk = 0x100000
	// Bit FBM20.
	CAN_FM1R_FBM20 = 0x100000
	// Position of FBM21 field.
	CAN_FM1R_FBM21_Pos = 0x15
	// Bit mask of FBM21 field.
	CAN_FM1R_FBM21_Msk = 0x200000
	// Bit FBM21.
	CAN_FM1R_FBM21 = 0x200000
	// Position of FBM22 field.
	CAN_FM1R_FBM22_Pos = 0x16
	// Bit mask of FBM22 field.
	CAN_FM1R_FBM22_Msk = 0x400000
	// Bit FBM22.
	CAN_FM1R_FBM22 = 0x400000
	// Position of FBM23 field.
	CAN_FM1R_FBM23_Pos = 0x17
	// Bit mask of FBM23 field.
	CAN_FM1R_FBM23_Msk = 0x800000
	// Bit FBM23.
	CAN_FM1R_FBM23 = 0x800000
	// Position of FBM24 field.
	CAN_FM1R_FBM24_Pos = 0x18
	// Bit mask of FBM24 field.
	CAN_FM1R_FBM24_Msk = 0x1000000
	// Bit FBM24.
	CAN_FM1R_FBM24 = 0x1000000
	// Position of FBM25 field.
	CAN_FM1R_FBM25_Pos = 0x19
	// Bit mask of FBM25 field.
	CAN_FM1R_FBM25_Msk = 0x2000000
	// Bit FBM25.
	CAN_FM1R_FBM25 = 0x2000000
	// Position of FBM26 field.
	CAN_FM1R_FBM26_Pos = 0x1a
	// Bit mask of FBM26 field.
	CAN_FM1R_FBM26_Msk = 0x4000000
	// Bit FBM26.
	CAN_FM1R_FBM26 = 0x4000000
	// Position of FBM27 field.
	CAN_FM1R_FBM27_Pos = 0x1b
	// Bit mask of FBM27 field.
	CAN_FM1R_FBM27_Msk = 0x8000000
	// Bit FBM27.
	CAN_FM1R_FBM27 = 0x8000000

	// FS1R: filter scale register
	// Position of FSC0 field.
	CAN_FS1R_FSC0_Pos = 0x0
	// Bit mask of FSC0 field.
	CAN_FS1R_FSC0_Msk = 0x1
	// Bit FSC0.
	CAN_FS1R_FSC0 = 0x1
	// Position of FSC1 field.
	CAN_FS1R_FSC1_Pos = 0x1
	// Bit mask of FSC1 field.
	CAN_FS1R_FSC1_Msk = 0x2
	// Bit FSC1.
	CAN_FS1R_FSC1 = 0x2
	// Position of FSC2 field.
	CAN_FS1R_FSC2_Pos = 0x2
	// Bit mask of FSC2 field.
	CAN_FS1R_FSC2_Msk = 0x4
	// Bit FSC2.
	CAN_FS1R_FSC2 = 0x4
	// Position of FSC3 field.
	CAN_FS1R_FSC3_Pos = 0x3
	// Bit mask of FSC3 field.
	CAN_FS1R_FSC3_Msk = 0x8
	// Bit FSC3.
	CAN_FS1R_FSC3 = 0x8
	// Position of FSC4 field.
	CAN_FS1R_FSC4_Pos = 0x4
	// Bit mask of FSC4 field.
	CAN_FS1R_FSC4_Msk = 0x10
	// Bit FSC4.
	CAN_FS1R_FSC4 = 0x10
	// Position of FSC5 field.
	CAN_FS1R_FSC5_Pos = 0x5
	// Bit mask of FSC5 field.
	CAN_FS1R_FSC5_Msk = 0x20
	// Bit FSC5.
	CAN_FS1R_FSC5 = 0x20
	// Position of FSC6 field.
	CAN_FS1R_FSC6_Pos = 0x6
	// Bit mask of FSC6 field.
	CAN_FS1R_FSC6_Msk = 0x40
	// Bit FSC6.
	CAN_FS1R_FSC6 = 0x40
	// Position of FSC7 field.
	CAN_FS1R_FSC7_Pos = 0x7
	// Bit mask of FSC7 field.
	CAN_FS1R_FSC7_Msk = 0x80
	// Bit FSC7.
	CAN_FS1R_FSC7 = 0x80
	// Position of FSC8 field.
	CAN_FS1R_FSC8_Pos = 0x8
	// Bit mask of FSC8 field.
	CAN_FS1R_FSC8_Msk = 0x100
	// Bit FSC8.
	CAN_FS1R_FSC8 = 0x100
	// Position of FSC9 field.
	CAN_FS1R_FSC9_Pos = 0x9
	// Bit mask of FSC9 field.
	CAN_FS1R_FSC9_Msk = 0x200
	// Bit FSC9.
	CAN_FS1R_FSC9 = 0x200
	// Position of FSC10 field.
	CAN_FS1R_FSC10_Pos = 0xa
	// Bit mask of FSC10 field.
	CAN_FS1R_FSC10_Msk = 0x400
	// Bit FSC10.
	CAN_FS1R_FSC10 = 0x400
	// Position of FSC11 field.
	CAN_FS1R_FSC11_Pos = 0xb
	// Bit mask of FSC11 field.
	CAN_FS1R_FSC11_Msk = 0x800
	// Bit FSC11.
	CAN_FS1R_FSC11 = 0x800
	// Position of FSC12 field.
	CAN_FS1R_FSC12_Pos = 0xc
	// Bit mask of FSC12 field.
	CAN_FS1R_FSC12_Msk = 0x1000
	// Bit FSC12.
	CAN_FS1R_FSC12 = 0x1000
	// Position of FSC13 field.
	CAN_FS1R_FSC13_Pos = 0xd
	// Bit mask of FSC13 field.
	CAN_FS1R_FSC13_Msk = 0x2000
	// Bit FSC13.
	CAN_FS1R_FSC13 = 0x2000
	// Position of FSC14 field.
	CAN_FS1R_FSC14_Pos = 0xe
	// Bit mask of FSC14 field.
	CAN_FS1R_FSC14_Msk = 0x4000
	// Bit FSC14.
	CAN_FS1R_FSC14 = 0x4000
	// Position of FSC15 field.
	CAN_FS1R_FSC15_Pos = 0xf
	// Bit mask of FSC15 field.
	CAN_FS1R_FSC15_Msk = 0x8000
	// Bit FSC15.
	CAN_FS1R_FSC15 = 0x8000
	// Position of FSC16 field.
	CAN_FS1R_FSC16_Pos = 0x10
	// Bit mask of FSC16 field.
	CAN_FS1R_FSC16_Msk = 0x10000
	// Bit FSC16.
	CAN_FS1R_FSC16 = 0x10000
	// Position of FSC17 field.
	CAN_FS1R_FSC17_Pos = 0x11
	// Bit mask of FSC17 field.
	CAN_FS1R_FSC17_Msk = 0x20000
	// Bit FSC17.
	CAN_FS1R_FSC17 = 0x20000
	// Position of FSC18 field.
	CAN_FS1R_FSC18_Pos = 0x12
	// Bit mask of FSC18 field.
	CAN_FS1R_FSC18_Msk = 0x40000
	// Bit FSC18.
	CAN_FS1R_FSC18 = 0x40000
	// Position of FSC19 field.
	CAN_FS1R_FSC19_Pos = 0x13
	// Bit mask of FSC19 field.
	CAN_FS1R_FSC19_Msk = 0x80000
	// Bit FSC19.
	CAN_FS1R_FSC19 = 0x80000
	// Position of FSC20 field.
	CAN_FS1R_FSC20_Pos = 0x14
	// Bit mask of FSC20 field.
	CAN_FS1R_FSC20_Msk = 0x100000
	// Bit FSC20.
	CAN_FS1R_FSC20 = 0x100000
	// Position of FSC21 field.
	CAN_FS1R_FSC21_Pos = 0x15
	// Bit mask of FSC21 field.
	CAN_FS1R_FSC21_Msk = 0x200000
	// Bit FSC21.
	CAN_FS1R_FSC21 = 0x200000
	// Position of FSC22 field.
	CAN_FS1R_FSC22_Pos = 0x16
	// Bit mask of FSC22 field.
	CAN_FS1R_FSC22_Msk = 0x400000
	// Bit FSC22.
	CAN_FS1R_FSC22 = 0x400000
	// Position of FSC23 field.
	CAN_FS1R_FSC23_Pos = 0x17
	// Bit mask of FSC23 field.
	CAN_FS1R_FSC23_Msk = 0x800000
	// Bit FSC23.
	CAN_FS1R_FSC23 = 0x800000
	// Position of FSC24 field.
	CAN_FS1R_FSC24_Pos = 0x18
	// Bit mask of FSC24 field.
	CAN_FS1R_FSC24_Msk = 0x1000000
	// Bit FSC24.
	CAN_FS1R_FSC24 = 0x1000000
	// Position of FSC25 field.
	CAN_FS1R_FSC25_Pos = 0x19
	// Bit mask of FSC25 field.
	CAN_FS1R_FSC25_Msk = 0x2000000
	// Bit FSC25.
	CAN_FS1R_FSC25 = 0x2000000
	// Position of FSC26 field.
	CAN_FS1R_FSC26_Pos = 0x1a
	// Bit mask of FSC26 field.
	CAN_FS1R_FSC26_Msk = 0x4000000
	// Bit FSC26.
	CAN_FS1R_FSC26 = 0x4000000
	// Position of FSC27 field.
	CAN_FS1R_FSC27_Pos = 0x1b
	// Bit mask of FSC27 field.
	CAN_FS1R_FSC27_Msk = 0x8000000
	// Bit FSC27.
	CAN_FS1R_FSC27 = 0x8000000

	// FFA1R: filter FIFO assignment register
	// Position of FFA0 field.
	CAN_FFA1R_FFA0_Pos = 0x0
	// Bit mask of FFA0 field.
	CAN_FFA1R_FFA0_Msk = 0x1
	// Bit FFA0.
	CAN_FFA1R_FFA0 = 0x1
	// Position of FFA1 field.
	CAN_FFA1R_FFA1_Pos = 0x1
	// Bit mask of FFA1 field.
	CAN_FFA1R_FFA1_Msk = 0x2
	// Bit FFA1.
	CAN_FFA1R_FFA1 = 0x2
	// Position of FFA2 field.
	CAN_FFA1R_FFA2_Pos = 0x2
	// Bit mask of FFA2 field.
	CAN_FFA1R_FFA2_Msk = 0x4
	// Bit FFA2.
	CAN_FFA1R_FFA2 = 0x4
	// Position of FFA3 field.
	CAN_FFA1R_FFA3_Pos = 0x3
	// Bit mask of FFA3 field.
	CAN_FFA1R_FFA3_Msk = 0x8
	// Bit FFA3.
	CAN_FFA1R_FFA3 = 0x8
	// Position of FFA4 field.
	CAN_FFA1R_FFA4_Pos = 0x4
	// Bit mask of FFA4 field.
	CAN_FFA1R_FFA4_Msk = 0x10
	// Bit FFA4.
	CAN_FFA1R_FFA4 = 0x10
	// Position of FFA5 field.
	CAN_FFA1R_FFA5_Pos = 0x5
	// Bit mask of FFA5 field.
	CAN_FFA1R_FFA5_Msk = 0x20
	// Bit FFA5.
	CAN_FFA1R_FFA5 = 0x20
	// Position of FFA6 field.
	CAN_FFA1R_FFA6_Pos = 0x6
	// Bit mask of FFA6 field.
	CAN_FFA1R_FFA6_Msk = 0x40
	// Bit FFA6.
	CAN_FFA1R_FFA6 = 0x40
	// Position of FFA7 field.
	CAN_FFA1R_FFA7_Pos = 0x7
	// Bit mask of FFA7 field.
	CAN_FFA1R_FFA7_Msk = 0x80
	// Bit FFA7.
	CAN_FFA1R_FFA7 = 0x80
	// Position of FFA8 field.
	CAN_FFA1R_FFA8_Pos = 0x8
	// Bit mask of FFA8 field.
	CAN_FFA1R_FFA8_Msk = 0x100
	// Bit FFA8.
	CAN_FFA1R_FFA8 = 0x100
	// Position of FFA9 field.
	CAN_FFA1R_FFA9_Pos = 0x9
	// Bit mask of FFA9 field.
	CAN_FFA1R_FFA9_Msk = 0x200
	// Bit FFA9.
	CAN_FFA1R_FFA9 = 0x200
	// Position of FFA10 field.
	CAN_FFA1R_FFA10_Pos = 0xa
	// Bit mask of FFA10 field.
	CAN_FFA1R_FFA10_Msk = 0x400
	// Bit FFA10.
	CAN_FFA1R_FFA10 = 0x400
	// Position of FFA11 field.
	CAN_FFA1R_FFA11_Pos = 0xb
	// Bit mask of FFA11 field.
	CAN_FFA1R_FFA11_Msk = 0x800
	// Bit FFA11.
	CAN_FFA1R_FFA11 = 0x800
	// Position of FFA12 field.
	CAN_FFA1R_FFA12_Pos = 0xc
	// Bit mask of FFA12 field.
	CAN_FFA1R_FFA12_Msk = 0x1000
	// Bit FFA12.
	CAN_FFA1R_FFA12 = 0x1000
	// Position of FFA13 field.
	CAN_FFA1R_FFA13_Pos = 0xd
	// Bit mask of FFA13 field.
	CAN_FFA1R_FFA13_Msk = 0x2000
	// Bit FFA13.
	CAN_FFA1R_FFA13 = 0x2000
	// Position of FFA14 field.
	CAN_FFA1R_FFA14_Pos = 0xe
	// Bit mask of FFA14 field.
	CAN_FFA1R_FFA14_Msk = 0x4000
	// Bit FFA14.
	CAN_FFA1R_FFA14 = 0x4000
	// Position of FFA15 field.
	CAN_FFA1R_FFA15_Pos = 0xf
	// Bit mask of FFA15 field.
	CAN_FFA1R_FFA15_Msk = 0x8000
	// Bit FFA15.
	CAN_FFA1R_FFA15 = 0x8000
	// Position of FFA16 field.
	CAN_FFA1R_FFA16_Pos = 0x10
	// Bit mask of FFA16 field.
	CAN_FFA1R_FFA16_Msk = 0x10000
	// Bit FFA16.
	CAN_FFA1R_FFA16 = 0x10000
	// Position of FFA17 field.
	CAN_FFA1R_FFA17_Pos = 0x11
	// Bit mask of FFA17 field.
	CAN_FFA1R_FFA17_Msk = 0x20000
	// Bit FFA17.
	CAN_FFA1R_FFA17 = 0x20000
	// Position of FFA18 field.
	CAN_FFA1R_FFA18_Pos = 0x12
	// Bit mask of FFA18 field.
	CAN_FFA1R_FFA18_Msk = 0x40000
	// Bit FFA18.
	CAN_FFA1R_FFA18 = 0x40000
	// Position of FFA19 field.
	CAN_FFA1R_FFA19_Pos = 0x13
	// Bit mask of FFA19 field.
	CAN_FFA1R_FFA19_Msk = 0x80000
	// Bit FFA19.
	CAN_FFA1R_FFA19 = 0x80000
	// Position of FFA20 field.
	CAN_FFA1R_FFA20_Pos = 0x14
	// Bit mask of FFA20 field.
	CAN_FFA1R_FFA20_Msk = 0x100000
	// Bit FFA20.
	CAN_FFA1R_FFA20 = 0x100000
	// Position of FFA21 field.
	CAN_FFA1R_FFA21_Pos = 0x15
	// Bit mask of FFA21 field.
	CAN_FFA1R_FFA21_Msk = 0x200000
	// Bit FFA21.
	CAN_FFA1R_FFA21 = 0x200000
	// Position of FFA22 field.
	CAN_FFA1R_FFA22_Pos = 0x16
	// Bit mask of FFA22 field.
	CAN_FFA1R_FFA22_Msk = 0x400000
	// Bit FFA22.
	CAN_FFA1R_FFA22 = 0x400000
	// Position of FFA23 field.
	CAN_FFA1R_FFA23_Pos = 0x17
	// Bit mask of FFA23 field.
	CAN_FFA1R_FFA23_Msk = 0x800000
	// Bit FFA23.
	CAN_FFA1R_FFA23 = 0x800000
	// Position of FFA24 field.
	CAN_FFA1R_FFA24_Pos = 0x18
	// Bit mask of FFA24 field.
	CAN_FFA1R_FFA24_Msk = 0x1000000
	// Bit FFA24.
	CAN_FFA1R_FFA24 = 0x1000000
	// Position of FFA25 field.
	CAN_FFA1R_FFA25_Pos = 0x19
	// Bit mask of FFA25 field.
	CAN_FFA1R_FFA25_Msk = 0x2000000
	// Bit FFA25.
	CAN_FFA1R_FFA25 = 0x2000000
	// Position of FFA26 field.
	CAN_FFA1R_FFA26_Pos = 0x1a
	// Bit mask of FFA26 field.
	CAN_FFA1R_FFA26_Msk = 0x4000000
	// Bit FFA26.
	CAN_FFA1R_FFA26 = 0x4000000
	// Position of FFA27 field.
	CAN_FFA1R_FFA27_Pos = 0x1b
	// Bit mask of FFA27 field.
	CAN_FFA1R_FFA27_Msk = 0x8000000
	// Bit FFA27.
	CAN_FFA1R_FFA27 = 0x8000000

	// FA1R: filter activation register
	// Position of FACT0 field.
	CAN_FA1R_FACT0_Pos = 0x0
	// Bit mask of FACT0 field.
	CAN_FA1R_FACT0_Msk = 0x1
	// Bit FACT0.
	CAN_FA1R_FACT0 = 0x1
	// Position of FACT1 field.
	CAN_FA1R_FACT1_Pos = 0x1
	// Bit mask of FACT1 field.
	CAN_FA1R_FACT1_Msk = 0x2
	// Bit FACT1.
	CAN_FA1R_FACT1 = 0x2
	// Position of FACT2 field.
	CAN_FA1R_FACT2_Pos = 0x2
	// Bit mask of FACT2 field.
	CAN_FA1R_FACT2_Msk = 0x4
	// Bit FACT2.
	CAN_FA1R_FACT2 = 0x4
	// Position of FACT3 field.
	CAN_FA1R_FACT3_Pos = 0x3
	// Bit mask of FACT3 field.
	CAN_FA1R_FACT3_Msk = 0x8
	// Bit FACT3.
	CAN_FA1R_FACT3 = 0x8
	// Position of FACT4 field.
	CAN_FA1R_FACT4_Pos = 0x4
	// Bit mask of FACT4 field.
	CAN_FA1R_FACT4_Msk = 0x10
	// Bit FACT4.
	CAN_FA1R_FACT4 = 0x10
	// Position of FACT5 field.
	CAN_FA1R_FACT5_Pos = 0x5
	// Bit mask of FACT5 field.
	CAN_FA1R_FACT5_Msk = 0x20
	// Bit FACT5.
	CAN_FA1R_FACT5 = 0x20
	// Position of FACT6 field.
	CAN_FA1R_FACT6_Pos = 0x6
	// Bit mask of FACT6 field.
	CAN_FA1R_FACT6_Msk = 0x40
	// Bit FACT6.
	CAN_FA1R_FACT6 = 0x40
	// Position of FACT7 field.
	CAN_FA1R_FACT7_Pos = 0x7
	// Bit mask of FACT7 field.
	CAN_FA1R_FACT7_Msk = 0x80
	// Bit FACT7.
	CAN_FA1R_FACT7 = 0x80
	// Position of FACT8 field.
	CAN_FA1R_FACT8_Pos = 0x8
	// Bit mask of FACT8 field.
	CAN_FA1R_FACT8_Msk = 0x100
	// Bit FACT8.
	CAN_FA1R_FACT8 = 0x100
	// Position of FACT9 field.
	CAN_FA1R_FACT9_Pos = 0x9
	// Bit mask of FACT9 field.
	CAN_FA1R_FACT9_Msk = 0x200
	// Bit FACT9.
	CAN_FA1R_FACT9 = 0x200
	// Position of FACT10 field.
	CAN_FA1R_FACT10_Pos = 0xa
	// Bit mask of FACT10 field.
	CAN_FA1R_FACT10_Msk = 0x400
	// Bit FACT10.
	CAN_FA1R_FACT10 = 0x400
	// Position of FACT11 field.
	CAN_FA1R_FACT11_Pos = 0xb
	// Bit mask of FACT11 field.
	CAN_FA1R_FACT11_Msk = 0x800
	// Bit FACT11.
	CAN_FA1R_FACT11 = 0x800
	// Position of FACT12 field.
	CAN_FA1R_FACT12_Pos = 0xc
	// Bit mask of FACT12 field.
	CAN_FA1R_FACT12_Msk = 0x1000
	// Bit FACT12.
	CAN_FA1R_FACT12 = 0x1000
	// Position of FACT13 field.
	CAN_FA1R_FACT13_Pos = 0xd
	// Bit mask of FACT13 field.
	CAN_FA1R_FACT13_Msk = 0x2000
	// Bit FACT13.
	CAN_FA1R_FACT13 = 0x2000
	// Position of FACT14 field.
	CAN_FA1R_FACT14_Pos = 0xe
	// Bit mask of FACT14 field.
	CAN_FA1R_FACT14_Msk = 0x4000
	// Bit FACT14.
	CAN_FA1R_FACT14 = 0x4000
	// Position of FACT15 field.
	CAN_FA1R_FACT15_Pos = 0xf
	// Bit mask of FACT15 field.
	CAN_FA1R_FACT15_Msk = 0x8000
	// Bit FACT15.
	CAN_FA1R_FACT15 = 0x8000
	// Position of FACT16 field.
	CAN_FA1R_FACT16_Pos = 0x10
	// Bit mask of FACT16 field.
	CAN_FA1R_FACT16_Msk = 0x10000
	// Bit FACT16.
	CAN_FA1R_FACT16 = 0x10000
	// Position of FACT17 field.
	CAN_FA1R_FACT17_Pos = 0x11
	// Bit mask of FACT17 field.
	CAN_FA1R_FACT17_Msk = 0x20000
	// Bit FACT17.
	CAN_FA1R_FACT17 = 0x20000
	// Position of FACT18 field.
	CAN_FA1R_FACT18_Pos = 0x12
	// Bit mask of FACT18 field.
	CAN_FA1R_FACT18_Msk = 0x40000
	// Bit FACT18.
	CAN_FA1R_FACT18 = 0x40000
	// Position of FACT19 field.
	CAN_FA1R_FACT19_Pos = 0x13
	// Bit mask of FACT19 field.
	CAN_FA1R_FACT19_Msk = 0x80000
	// Bit FACT19.
	CAN_FA1R_FACT19 = 0x80000
	// Position of FACT20 field.
	CAN_FA1R_FACT20_Pos = 0x14
	// Bit mask of FACT20 field.
	CAN_FA1R_FACT20_Msk = 0x100000
	// Bit FACT20.
	CAN_FA1R_FACT20 = 0x100000
	// Position of FACT21 field.
	CAN_FA1R_FACT21_Pos = 0x15
	// Bit mask of FACT21 field.
	CAN_FA1R_FACT21_Msk = 0x200000
	// Bit FACT21.
	CAN_FA1R_FACT21 = 0x200000
	// Position of FACT22 field.
	CAN_FA1R_FACT22_Pos = 0x16
	// Bit mask of FACT22 field.
	CAN_FA1R_FACT22_Msk = 0x400000
	// Bit FACT22.
	CAN_FA1R_FACT22 = 0x400000
	// Position of FACT23 field.
	CAN_FA1R_FACT23_Pos = 0x17
	// Bit mask of FACT23 field.
	CAN_FA1R_FACT23_Msk = 0x800000
	// Bit FACT23.
	CAN_FA1R_FACT23 = 0x800000
	// Position of FACT24 field.
	CAN_FA1R_FACT24_Pos = 0x18
	// Bit mask of FACT24 field.
	CAN_FA1R_FACT24_Msk = 0x1000000
	// Bit FACT24.
	CAN_FA1R_FACT24 = 0x1000000
	// Position of FACT25 field.
	CAN_FA1R_FACT25_Pos = 0x19
	// Bit mask of FACT25 field.
	CAN_FA1R_FACT25_Msk = 0x2000000
	// Bit FACT25.
	CAN_FA1R_FACT25 = 0x2000000
	// Position of FACT26 field.
	CAN_FA1R_FACT26_Pos = 0x1a
	// Bit mask of FACT26 field.
	CAN_FA1R_FACT26_Msk = 0x4000000
	// Bit FACT26.
	CAN_FA1R_FACT26 = 0x4000000
	// Position of FACT27 field.
	CAN_FA1R_FACT27_Pos = 0x1b
	// Bit mask of FACT27 field.
	CAN_FA1R_FACT27_Msk = 0x8000000
	// Bit FACT27.
	CAN_FA1R_FACT27 = 0x8000000

	// FB.FR1: Filter bank 0 register 1
	// Position of FB field.
	CAN_FB_FR1_FB_Pos = 0x0
	// Bit mask of FB field.
	CAN_FB_FR1_FB_Msk = 0xffffffff

	// FB.FR2: Filter bank 0 register 2
	// Position of FB field.
	CAN_FB_FR2_FB_Pos = 0x0
	// Bit mask of FB field.
	CAN_FB_FR2_FB_Msk = 0xffffffff
)

// Constants for RTC: Real-time clock
const (
	// TR: time register
	// Position of PM field.
	RTC_TR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TR_PM = 0x400000
	// Position of HT field.
	RTC_TR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_TR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TR_HU_Msk = 0xf0000
	// Position of MNT field.
	RTC_TR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_TR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TR_MNU_Msk = 0xf00
	// Position of ST field.
	RTC_TR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TR_ST_Msk = 0x70
	// Position of SU field.
	RTC_TR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TR_SU_Msk = 0xf

	// DR: date register
	// Position of YT field.
	RTC_DR_YT_Pos = 0x14
	// Bit mask of YT field.
	RTC_DR_YT_Msk = 0xf00000
	// Position of YU field.
	RTC_DR_YU_Pos = 0x10
	// Bit mask of YU field.
	RTC_DR_YU_Msk = 0xf0000
	// Position of WDU field.
	RTC_DR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_DR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_DR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_DR_MT_Msk = 0x1000
	// Bit MT.
	RTC_DR_MT = 0x1000
	// Position of MU field.
	RTC_DR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_DR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_DR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_DR_DT_Msk = 0x30
	// Position of DU field.
	RTC_DR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_DR_DU_Msk = 0xf

	// CR: control register
	// Position of WUCKSEL field.
	RTC_CR_WUCKSEL_Pos = 0x0
	// Bit mask of WUCKSEL field.
	RTC_CR_WUCKSEL_Msk = 0x7
	// Position of TSEDGE field.
	RTC_CR_TSEDGE_Pos = 0x3
	// Bit mask of TSEDGE field.
	RTC_CR_TSEDGE_Msk = 0x8
	// Bit TSEDGE.
	RTC_CR_TSEDGE = 0x8
	// Position of REFCKON field.
	RTC_CR_REFCKON_Pos = 0x4
	// Bit mask of REFCKON field.
	RTC_CR_REFCKON_Msk = 0x10
	// Bit REFCKON.
	RTC_CR_REFCKON = 0x10
	// Position of BYPSHAD field.
	RTC_CR_BYPSHAD_Pos = 0x5
	// Bit mask of BYPSHAD field.
	RTC_CR_BYPSHAD_Msk = 0x20
	// Bit BYPSHAD.
	RTC_CR_BYPSHAD = 0x20
	// Position of FMT field.
	RTC_CR_FMT_Pos = 0x6
	// Bit mask of FMT field.
	RTC_CR_FMT_Msk = 0x40
	// Bit FMT.
	RTC_CR_FMT = 0x40
	// Position of ALRAE field.
	RTC_CR_ALRAE_Pos = 0x8
	// Bit mask of ALRAE field.
	RTC_CR_ALRAE_Msk = 0x100
	// Bit ALRAE.
	RTC_CR_ALRAE = 0x100
	// Position of ALRBE field.
	RTC_CR_ALRBE_Pos = 0x9
	// Bit mask of ALRBE field.
	RTC_CR_ALRBE_Msk = 0x200
	// Bit ALRBE.
	RTC_CR_ALRBE = 0x200
	// Position of WUTE field.
	RTC_CR_WUTE_Pos = 0xa
	// Bit mask of WUTE field.
	RTC_CR_WUTE_Msk = 0x400
	// Bit WUTE.
	RTC_CR_WUTE = 0x400
	// Position of TSE field.
	RTC_CR_TSE_Pos = 0xb
	// Bit mask of TSE field.
	RTC_CR_TSE_Msk = 0x800
	// Bit TSE.
	RTC_CR_TSE = 0x800
	// Position of ALRAIE field.
	RTC_CR_ALRAIE_Pos = 0xc
	// Bit mask of ALRAIE field.
	RTC_CR_ALRAIE_Msk = 0x1000
	// Bit ALRAIE.
	RTC_CR_ALRAIE = 0x1000
	// Position of ALRBIE field.
	RTC_CR_ALRBIE_Pos = 0xd
	// Bit mask of ALRBIE field.
	RTC_CR_ALRBIE_Msk = 0x2000
	// Bit ALRBIE.
	RTC_CR_ALRBIE = 0x2000
	// Position of WUTIE field.
	RTC_CR_WUTIE_Pos = 0xe
	// Bit mask of WUTIE field.
	RTC_CR_WUTIE_Msk = 0x4000
	// Bit WUTIE.
	RTC_CR_WUTIE = 0x4000
	// Position of TSIE field.
	RTC_CR_TSIE_Pos = 0xf
	// Bit mask of TSIE field.
	RTC_CR_TSIE_Msk = 0x8000
	// Bit TSIE.
	RTC_CR_TSIE = 0x8000
	// Position of ADD1H field.
	RTC_CR_ADD1H_Pos = 0x10
	// Bit mask of ADD1H field.
	RTC_CR_ADD1H_Msk = 0x10000
	// Bit ADD1H.
	RTC_CR_ADD1H = 0x10000
	// Position of SUB1H field.
	RTC_CR_SUB1H_Pos = 0x11
	// Bit mask of SUB1H field.
	RTC_CR_SUB1H_Msk = 0x20000
	// Bit SUB1H.
	RTC_CR_SUB1H = 0x20000
	// Position of BKP field.
	RTC_CR_BKP_Pos = 0x12
	// Bit mask of BKP field.
	RTC_CR_BKP_Msk = 0x40000
	// Bit BKP.
	RTC_CR_BKP = 0x40000
	// Position of COSEL field.
	RTC_CR_COSEL_Pos = 0x13
	// Bit mask of COSEL field.
	RTC_CR_COSEL_Msk = 0x80000
	// Bit COSEL.
	RTC_CR_COSEL = 0x80000
	// Position of POL field.
	RTC_CR_POL_Pos = 0x14
	// Bit mask of POL field.
	RTC_CR_POL_Msk = 0x100000
	// Bit POL.
	RTC_CR_POL = 0x100000
	// Position of OSEL field.
	RTC_CR_OSEL_Pos = 0x15
	// Bit mask of OSEL field.
	RTC_CR_OSEL_Msk = 0x600000
	// Position of COE field.
	RTC_CR_COE_Pos = 0x17
	// Bit mask of COE field.
	RTC_CR_COE_Msk = 0x800000
	// Bit COE.
	RTC_CR_COE = 0x800000
	// Position of ITSE field.
	RTC_CR_ITSE_Pos = 0x18
	// Bit mask of ITSE field.
	RTC_CR_ITSE_Msk = 0x1000000
	// Bit ITSE.
	RTC_CR_ITSE = 0x1000000

	// ISR: initialization and status register
	// Position of ALRAWF field.
	RTC_ISR_ALRAWF_Pos = 0x0
	// Bit mask of ALRAWF field.
	RTC_ISR_ALRAWF_Msk = 0x1
	// Bit ALRAWF.
	RTC_ISR_ALRAWF = 0x1
	// Position of ALRBWF field.
	RTC_ISR_ALRBWF_Pos = 0x1
	// Bit mask of ALRBWF field.
	RTC_ISR_ALRBWF_Msk = 0x2
	// Bit ALRBWF.
	RTC_ISR_ALRBWF = 0x2
	// Position of WUTWF field.
	RTC_ISR_WUTWF_Pos = 0x2
	// Bit mask of WUTWF field.
	RTC_ISR_WUTWF_Msk = 0x4
	// Bit WUTWF.
	RTC_ISR_WUTWF = 0x4
	// Position of SHPF field.
	RTC_ISR_SHPF_Pos = 0x3
	// Bit mask of SHPF field.
	RTC_ISR_SHPF_Msk = 0x8
	// Bit SHPF.
	RTC_ISR_SHPF = 0x8
	// Position of INITS field.
	RTC_ISR_INITS_Pos = 0x4
	// Bit mask of INITS field.
	RTC_ISR_INITS_Msk = 0x10
	// Bit INITS.
	RTC_ISR_INITS = 0x10
	// Position of RSF field.
	RTC_ISR_RSF_Pos = 0x5
	// Bit mask of RSF field.
	RTC_ISR_RSF_Msk = 0x20
	// Bit RSF.
	RTC_ISR_RSF = 0x20
	// Position of INITF field.
	RTC_ISR_INITF_Pos = 0x6
	// Bit mask of INITF field.
	RTC_ISR_INITF_Msk = 0x40
	// Bit INITF.
	RTC_ISR_INITF = 0x40
	// Position of INIT field.
	RTC_ISR_INIT_Pos = 0x7
	// Bit mask of INIT field.
	RTC_ISR_INIT_Msk = 0x80
	// Bit INIT.
	RTC_ISR_INIT = 0x80
	// Position of ALRAF field.
	RTC_ISR_ALRAF_Pos = 0x8
	// Bit mask of ALRAF field.
	RTC_ISR_ALRAF_Msk = 0x100
	// Bit ALRAF.
	RTC_ISR_ALRAF = 0x100
	// Position of ALRBF field.
	RTC_ISR_ALRBF_Pos = 0x9
	// Bit mask of ALRBF field.
	RTC_ISR_ALRBF_Msk = 0x200
	// Bit ALRBF.
	RTC_ISR_ALRBF = 0x200
	// Position of WUTF field.
	RTC_ISR_WUTF_Pos = 0xa
	// Bit mask of WUTF field.
	RTC_ISR_WUTF_Msk = 0x400
	// Bit WUTF.
	RTC_ISR_WUTF = 0x400
	// Position of TSF field.
	RTC_ISR_TSF_Pos = 0xb
	// Bit mask of TSF field.
	RTC_ISR_TSF_Msk = 0x800
	// Bit TSF.
	RTC_ISR_TSF = 0x800
	// Position of TSOVF field.
	RTC_ISR_TSOVF_Pos = 0xc
	// Bit mask of TSOVF field.
	RTC_ISR_TSOVF_Msk = 0x1000
	// Bit TSOVF.
	RTC_ISR_TSOVF = 0x1000
	// Position of TAMP1F field.
	RTC_ISR_TAMP1F_Pos = 0xd
	// Bit mask of TAMP1F field.
	RTC_ISR_TAMP1F_Msk = 0x2000
	// Bit TAMP1F.
	RTC_ISR_TAMP1F = 0x2000
	// Position of TAMP2F field.
	RTC_ISR_TAMP2F_Pos = 0xe
	// Bit mask of TAMP2F field.
	RTC_ISR_TAMP2F_Msk = 0x4000
	// Bit TAMP2F.
	RTC_ISR_TAMP2F = 0x4000
	// Position of TAMP3F field.
	RTC_ISR_TAMP3F_Pos = 0xf
	// Bit mask of TAMP3F field.
	RTC_ISR_TAMP3F_Msk = 0x8000
	// Bit TAMP3F.
	RTC_ISR_TAMP3F = 0x8000
	// Position of RECALPF field.
	RTC_ISR_RECALPF_Pos = 0x10
	// Bit mask of RECALPF field.
	RTC_ISR_RECALPF_Msk = 0x10000
	// Bit RECALPF.
	RTC_ISR_RECALPF = 0x10000

	// PRER: prescaler register
	// Position of PREDIV_A field.
	RTC_PRER_PREDIV_A_Pos = 0x10
	// Bit mask of PREDIV_A field.
	RTC_PRER_PREDIV_A_Msk = 0x7f0000
	// Position of PREDIV_S field.
	RTC_PRER_PREDIV_S_Pos = 0x0
	// Bit mask of PREDIV_S field.
	RTC_PRER_PREDIV_S_Msk = 0x7fff

	// WUTR: wakeup timer register
	// Position of WUT field.
	RTC_WUTR_WUT_Pos = 0x0
	// Bit mask of WUT field.
	RTC_WUTR_WUT_Msk = 0xffff

	// ALRMAR: alarm A register
	// Position of MSK4 field.
	RTC_ALRMAR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMAR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMAR_MSK4 = 0x80000000
	// Position of WDSEL field.
	RTC_ALRMAR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMAR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMAR_WDSEL = 0x40000000
	// Position of DT field.
	RTC_ALRMAR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMAR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMAR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMAR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMAR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMAR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMAR_MSK3 = 0x800000
	// Position of PM field.
	RTC_ALRMAR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMAR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMAR_PM = 0x400000
	// Position of HT field.
	RTC_ALRMAR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMAR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMAR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMAR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMAR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMAR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMAR_MSK2 = 0x8000
	// Position of MNT field.
	RTC_ALRMAR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMAR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMAR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMAR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMAR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMAR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMAR_MSK1 = 0x80
	// Position of ST field.
	RTC_ALRMAR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMAR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMAR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMAR_SU_Msk = 0xf

	// ALRMBR: alarm B register
	// Position of MSK4 field.
	RTC_ALRMBR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMBR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMBR_MSK4 = 0x80000000
	// Position of WDSEL field.
	RTC_ALRMBR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMBR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMBR_WDSEL = 0x40000000
	// Position of DT field.
	RTC_ALRMBR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMBR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMBR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMBR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMBR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMBR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMBR_MSK3 = 0x800000
	// Position of PM field.
	RTC_ALRMBR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMBR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMBR_PM = 0x400000
	// Position of HT field.
	RTC_ALRMBR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMBR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMBR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMBR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMBR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMBR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMBR_MSK2 = 0x8000
	// Position of MNT field.
	RTC_ALRMBR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMBR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMBR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMBR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMBR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMBR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMBR_MSK1 = 0x80
	// Position of ST field.
	RTC_ALRMBR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMBR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMBR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMBR_SU_Msk = 0xf

	// WPR: write protection register
	// Position of KEY field.
	RTC_WPR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	RTC_WPR_KEY_Msk = 0xff

	// SSR: sub second register
	// Position of SS field.
	RTC_SSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_SSR_SS_Msk = 0xffff

	// SHIFTR: shift control register
	// Position of ADD1S field.
	RTC_SHIFTR_ADD1S_Pos = 0x1f
	// Bit mask of ADD1S field.
	RTC_SHIFTR_ADD1S_Msk = 0x80000000
	// Bit ADD1S.
	RTC_SHIFTR_ADD1S = 0x80000000
	// Position of SUBFS field.
	RTC_SHIFTR_SUBFS_Pos = 0x0
	// Bit mask of SUBFS field.
	RTC_SHIFTR_SUBFS_Msk = 0x7fff

	// TSTR: time stamp time register
	// Position of SU field.
	RTC_TSTR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TSTR_SU_Msk = 0xf
	// Position of ST field.
	RTC_TSTR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TSTR_ST_Msk = 0x70
	// Position of MNU field.
	RTC_TSTR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TSTR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_TSTR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TSTR_MNT_Msk = 0x7000
	// Position of HU field.
	RTC_TSTR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TSTR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_TSTR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TSTR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_TSTR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TSTR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TSTR_PM = 0x400000

	// TSDR: time stamp date register
	// Position of WDU field.
	RTC_TSDR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_TSDR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_TSDR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_TSDR_MT_Msk = 0x1000
	// Bit MT.
	RTC_TSDR_MT = 0x1000
	// Position of MU field.
	RTC_TSDR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_TSDR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_TSDR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_TSDR_DT_Msk = 0x30
	// Position of DU field.
	RTC_TSDR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_TSDR_DU_Msk = 0xf

	// TSSSR: timestamp sub second register
	// Position of SS field.
	RTC_TSSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_TSSSR_SS_Msk = 0xffff

	// CALR: calibration register
	// Position of CALP field.
	RTC_CALR_CALP_Pos = 0xf
	// Bit mask of CALP field.
	RTC_CALR_CALP_Msk = 0x8000
	// Bit CALP.
	RTC_CALR_CALP = 0x8000
	// Position of CALW8 field.
	RTC_CALR_CALW8_Pos = 0xe
	// Bit mask of CALW8 field.
	RTC_CALR_CALW8_Msk = 0x4000
	// Bit CALW8.
	RTC_CALR_CALW8 = 0x4000
	// Position of CALW16 field.
	RTC_CALR_CALW16_Pos = 0xd
	// Bit mask of CALW16 field.
	RTC_CALR_CALW16_Msk = 0x2000
	// Bit CALW16.
	RTC_CALR_CALW16 = 0x2000
	// Position of CALM field.
	RTC_CALR_CALM_Pos = 0x0
	// Bit mask of CALM field.
	RTC_CALR_CALM_Msk = 0x1ff

	// TAMPCR: tamper configuration register
	// Position of TAMP1E field.
	RTC_TAMPCR_TAMP1E_Pos = 0x0
	// Bit mask of TAMP1E field.
	RTC_TAMPCR_TAMP1E_Msk = 0x1
	// Bit TAMP1E.
	RTC_TAMPCR_TAMP1E = 0x1
	// Position of TAMP1TRG field.
	RTC_TAMPCR_TAMP1TRG_Pos = 0x1
	// Bit mask of TAMP1TRG field.
	RTC_TAMPCR_TAMP1TRG_Msk = 0x2
	// Bit TAMP1TRG.
	RTC_TAMPCR_TAMP1TRG = 0x2
	// Position of TAMPIE field.
	RTC_TAMPCR_TAMPIE_Pos = 0x2
	// Bit mask of TAMPIE field.
	RTC_TAMPCR_TAMPIE_Msk = 0x4
	// Bit TAMPIE.
	RTC_TAMPCR_TAMPIE = 0x4
	// Position of TAMP2E field.
	RTC_TAMPCR_TAMP2E_Pos = 0x3
	// Bit mask of TAMP2E field.
	RTC_TAMPCR_TAMP2E_Msk = 0x8
	// Bit TAMP2E.
	RTC_TAMPCR_TAMP2E = 0x8
	// Position of TAMP2TRG field.
	RTC_TAMPCR_TAMP2TRG_Pos = 0x4
	// Bit mask of TAMP2TRG field.
	RTC_TAMPCR_TAMP2TRG_Msk = 0x10
	// Bit TAMP2TRG.
	RTC_TAMPCR_TAMP2TRG = 0x10
	// Position of TAMP3E field.
	RTC_TAMPCR_TAMP3E_Pos = 0x5
	// Bit mask of TAMP3E field.
	RTC_TAMPCR_TAMP3E_Msk = 0x20
	// Bit TAMP3E.
	RTC_TAMPCR_TAMP3E = 0x20
	// Position of TAMP3TRG field.
	RTC_TAMPCR_TAMP3TRG_Pos = 0x6
	// Bit mask of TAMP3TRG field.
	RTC_TAMPCR_TAMP3TRG_Msk = 0x40
	// Bit TAMP3TRG.
	RTC_TAMPCR_TAMP3TRG = 0x40
	// Position of TAMPTS field.
	RTC_TAMPCR_TAMPTS_Pos = 0x7
	// Bit mask of TAMPTS field.
	RTC_TAMPCR_TAMPTS_Msk = 0x80
	// Bit TAMPTS.
	RTC_TAMPCR_TAMPTS = 0x80
	// Position of TAMPFREQ field.
	RTC_TAMPCR_TAMPFREQ_Pos = 0x8
	// Bit mask of TAMPFREQ field.
	RTC_TAMPCR_TAMPFREQ_Msk = 0x700
	// Position of TAMPFLT field.
	RTC_TAMPCR_TAMPFLT_Pos = 0xb
	// Bit mask of TAMPFLT field.
	RTC_TAMPCR_TAMPFLT_Msk = 0x1800
	// Position of TAMPPRCH field.
	RTC_TAMPCR_TAMPPRCH_Pos = 0xd
	// Bit mask of TAMPPRCH field.
	RTC_TAMPCR_TAMPPRCH_Msk = 0x6000
	// Position of TAMPPUDIS field.
	RTC_TAMPCR_TAMPPUDIS_Pos = 0xf
	// Bit mask of TAMPPUDIS field.
	RTC_TAMPCR_TAMPPUDIS_Msk = 0x8000
	// Bit TAMPPUDIS.
	RTC_TAMPCR_TAMPPUDIS = 0x8000
	// Position of TAMP1IE field.
	RTC_TAMPCR_TAMP1IE_Pos = 0x10
	// Bit mask of TAMP1IE field.
	RTC_TAMPCR_TAMP1IE_Msk = 0x10000
	// Bit TAMP1IE.
	RTC_TAMPCR_TAMP1IE = 0x10000
	// Position of TAMP1NOERASE field.
	RTC_TAMPCR_TAMP1NOERASE_Pos = 0x11
	// Bit mask of TAMP1NOERASE field.
	RTC_TAMPCR_TAMP1NOERASE_Msk = 0x20000
	// Bit TAMP1NOERASE.
	RTC_TAMPCR_TAMP1NOERASE = 0x20000
	// Position of TAMP1MF field.
	RTC_TAMPCR_TAMP1MF_Pos = 0x12
	// Bit mask of TAMP1MF field.
	RTC_TAMPCR_TAMP1MF_Msk = 0x40000
	// Bit TAMP1MF.
	RTC_TAMPCR_TAMP1MF = 0x40000
	// Position of TAMP2IE field.
	RTC_TAMPCR_TAMP2IE_Pos = 0x13
	// Bit mask of TAMP2IE field.
	RTC_TAMPCR_TAMP2IE_Msk = 0x80000
	// Bit TAMP2IE.
	RTC_TAMPCR_TAMP2IE = 0x80000
	// Position of TAMP2NOERASE field.
	RTC_TAMPCR_TAMP2NOERASE_Pos = 0x14
	// Bit mask of TAMP2NOERASE field.
	RTC_TAMPCR_TAMP2NOERASE_Msk = 0x100000
	// Bit TAMP2NOERASE.
	RTC_TAMPCR_TAMP2NOERASE = 0x100000
	// Position of TAMP2MF field.
	RTC_TAMPCR_TAMP2MF_Pos = 0x15
	// Bit mask of TAMP2MF field.
	RTC_TAMPCR_TAMP2MF_Msk = 0x200000
	// Bit TAMP2MF.
	RTC_TAMPCR_TAMP2MF = 0x200000
	// Position of TAMP3IE field.
	RTC_TAMPCR_TAMP3IE_Pos = 0x16
	// Bit mask of TAMP3IE field.
	RTC_TAMPCR_TAMP3IE_Msk = 0x400000
	// Bit TAMP3IE.
	RTC_TAMPCR_TAMP3IE = 0x400000
	// Position of TAMP3NOERASE field.
	RTC_TAMPCR_TAMP3NOERASE_Pos = 0x17
	// Bit mask of TAMP3NOERASE field.
	RTC_TAMPCR_TAMP3NOERASE_Msk = 0x800000
	// Bit TAMP3NOERASE.
	RTC_TAMPCR_TAMP3NOERASE = 0x800000
	// Position of TAMP3MF field.
	RTC_TAMPCR_TAMP3MF_Pos = 0x18
	// Bit mask of TAMP3MF field.
	RTC_TAMPCR_TAMP3MF_Msk = 0x1000000
	// Bit TAMP3MF.
	RTC_TAMPCR_TAMP3MF = 0x1000000

	// ALRMASSR: alarm A sub second register
	// Position of MASKSS field.
	RTC_ALRMASSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMASSR_MASKSS_Msk = 0xf000000
	// Position of SS field.
	RTC_ALRMASSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMASSR_SS_Msk = 0x7fff

	// ALRMBSSR: alarm B sub second register
	// Position of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Msk = 0xf000000
	// Position of SS field.
	RTC_ALRMBSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMBSSR_SS_Msk = 0x7fff

	// OR: option register
	// Position of RTC_ALARM_TYPE field.
	RTC_OR_RTC_ALARM_TYPE_Pos = 0x0
	// Bit mask of RTC_ALARM_TYPE field.
	RTC_OR_RTC_ALARM_TYPE_Msk = 0x1
	// Bit RTC_ALARM_TYPE.
	RTC_OR_RTC_ALARM_TYPE = 0x1
	// Position of RTC_OUT_RMP field.
	RTC_OR_RTC_OUT_RMP_Pos = 0x1
	// Bit mask of RTC_OUT_RMP field.
	RTC_OR_RTC_OUT_RMP_Msk = 0x2
	// Bit RTC_OUT_RMP.
	RTC_OR_RTC_OUT_RMP = 0x2

	// BKP0R: backup register
	// Position of BKP field.
	RTC_BKPR_BKP_Pos = 0x0
	// Bit mask of BKP field.
	RTC_BKPR_BKP_Msk = 0xffffffff
)

// Constants for OTG_FS_GLOBAL: USB on the go full speed
const (
	// GOTGCTL: OTG_FS control and status register (OTG_FS_GOTGCTL)
	// Position of SRQSCS field.
	USB_OTG_FS_GOTGCTL_SRQSCS_Pos = 0x0
	// Bit mask of SRQSCS field.
	USB_OTG_FS_GOTGCTL_SRQSCS_Msk = 0x1
	// Bit SRQSCS.
	USB_OTG_FS_GOTGCTL_SRQSCS = 0x1
	// Position of SRQ field.
	USB_OTG_FS_GOTGCTL_SRQ_Pos = 0x1
	// Bit mask of SRQ field.
	USB_OTG_FS_GOTGCTL_SRQ_Msk = 0x2
	// Bit SRQ.
	USB_OTG_FS_GOTGCTL_SRQ = 0x2
	// Position of HNGSCS field.
	USB_OTG_FS_GOTGCTL_HNGSCS_Pos = 0x8
	// Bit mask of HNGSCS field.
	USB_OTG_FS_GOTGCTL_HNGSCS_Msk = 0x100
	// Bit HNGSCS.
	USB_OTG_FS_GOTGCTL_HNGSCS = 0x100
	// Position of HNPRQ field.
	USB_OTG_FS_GOTGCTL_HNPRQ_Pos = 0x9
	// Bit mask of HNPRQ field.
	USB_OTG_FS_GOTGCTL_HNPRQ_Msk = 0x200
	// Bit HNPRQ.
	USB_OTG_FS_GOTGCTL_HNPRQ = 0x200
	// Position of HSHNPEN field.
	USB_OTG_FS_GOTGCTL_HSHNPEN_Pos = 0xa
	// Bit mask of HSHNPEN field.
	USB_OTG_FS_GOTGCTL_HSHNPEN_Msk = 0x400
	// Bit HSHNPEN.
	USB_OTG_FS_GOTGCTL_HSHNPEN = 0x400
	// Position of DHNPEN field.
	USB_OTG_FS_GOTGCTL_DHNPEN_Pos = 0xb
	// Bit mask of DHNPEN field.
	USB_OTG_FS_GOTGCTL_DHNPEN_Msk = 0x800
	// Bit DHNPEN.
	USB_OTG_FS_GOTGCTL_DHNPEN = 0x800
	// Position of CIDSTS field.
	USB_OTG_FS_GOTGCTL_CIDSTS_Pos = 0x10
	// Bit mask of CIDSTS field.
	USB_OTG_FS_GOTGCTL_CIDSTS_Msk = 0x10000
	// Bit CIDSTS.
	USB_OTG_FS_GOTGCTL_CIDSTS = 0x10000
	// Position of DBCT field.
	USB_OTG_FS_GOTGCTL_DBCT_Pos = 0x11
	// Bit mask of DBCT field.
	USB_OTG_FS_GOTGCTL_DBCT_Msk = 0x20000
	// Bit DBCT.
	USB_OTG_FS_GOTGCTL_DBCT = 0x20000
	// Position of ASVLD field.
	USB_OTG_FS_GOTGCTL_ASVLD_Pos = 0x12
	// Bit mask of ASVLD field.
	USB_OTG_FS_GOTGCTL_ASVLD_Msk = 0x40000
	// Bit ASVLD.
	USB_OTG_FS_GOTGCTL_ASVLD = 0x40000
	// Position of BSVLD field.
	USB_OTG_FS_GOTGCTL_BSVLD_Pos = 0x13
	// Bit mask of BSVLD field.
	USB_OTG_FS_GOTGCTL_BSVLD_Msk = 0x80000
	// Bit BSVLD.
	USB_OTG_FS_GOTGCTL_BSVLD = 0x80000

	// GOTGINT: OTG_FS interrupt register (OTG_FS_GOTGINT)
	// Position of SEDET field.
	USB_OTG_FS_GOTGINT_SEDET_Pos = 0x2
	// Bit mask of SEDET field.
	USB_OTG_FS_GOTGINT_SEDET_Msk = 0x4
	// Bit SEDET.
	USB_OTG_FS_GOTGINT_SEDET = 0x4
	// Position of SRSSCHG field.
	USB_OTG_FS_GOTGINT_SRSSCHG_Pos = 0x8
	// Bit mask of SRSSCHG field.
	USB_OTG_FS_GOTGINT_SRSSCHG_Msk = 0x100
	// Bit SRSSCHG.
	USB_OTG_FS_GOTGINT_SRSSCHG = 0x100
	// Position of HNSSCHG field.
	USB_OTG_FS_GOTGINT_HNSSCHG_Pos = 0x9
	// Bit mask of HNSSCHG field.
	USB_OTG_FS_GOTGINT_HNSSCHG_Msk = 0x200
	// Bit HNSSCHG.
	USB_OTG_FS_GOTGINT_HNSSCHG = 0x200
	// Position of HNGDET field.
	USB_OTG_FS_GOTGINT_HNGDET_Pos = 0x11
	// Bit mask of HNGDET field.
	USB_OTG_FS_GOTGINT_HNGDET_Msk = 0x20000
	// Bit HNGDET.
	USB_OTG_FS_GOTGINT_HNGDET = 0x20000
	// Position of ADTOCHG field.
	USB_OTG_FS_GOTGINT_ADTOCHG_Pos = 0x12
	// Bit mask of ADTOCHG field.
	USB_OTG_FS_GOTGINT_ADTOCHG_Msk = 0x40000
	// Bit ADTOCHG.
	USB_OTG_FS_GOTGINT_ADTOCHG = 0x40000
	// Position of DBCDNE field.
	USB_OTG_FS_GOTGINT_DBCDNE_Pos = 0x13
	// Bit mask of DBCDNE field.
	USB_OTG_FS_GOTGINT_DBCDNE_Msk = 0x80000
	// Bit DBCDNE.
	USB_OTG_FS_GOTGINT_DBCDNE = 0x80000

	// GAHBCFG: OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
	// Position of GINT field.
	USB_OTG_FS_GAHBCFG_GINT_Pos = 0x0
	// Bit mask of GINT field.
	USB_OTG_FS_GAHBCFG_GINT_Msk = 0x1
	// Bit GINT.
	USB_OTG_FS_GAHBCFG_GINT = 0x1
	// Position of TXFELVL field.
	USB_OTG_FS_GAHBCFG_TXFELVL_Pos = 0x7
	// Bit mask of TXFELVL field.
	USB_OTG_FS_GAHBCFG_TXFELVL_Msk = 0x80
	// Bit TXFELVL.
	USB_OTG_FS_GAHBCFG_TXFELVL = 0x80
	// Position of PTXFELVL field.
	USB_OTG_FS_GAHBCFG_PTXFELVL_Pos = 0x8
	// Bit mask of PTXFELVL field.
	USB_OTG_FS_GAHBCFG_PTXFELVL_Msk = 0x100
	// Bit PTXFELVL.
	USB_OTG_FS_GAHBCFG_PTXFELVL = 0x100

	// GUSBCFG: OTG_FS USB configuration register (OTG_FS_GUSBCFG)
	// Position of TOCAL field.
	USB_OTG_FS_GUSBCFG_TOCAL_Pos = 0x0
	// Bit mask of TOCAL field.
	USB_OTG_FS_GUSBCFG_TOCAL_Msk = 0x7
	// Position of PHYSEL field.
	USB_OTG_FS_GUSBCFG_PHYSEL_Pos = 0x6
	// Bit mask of PHYSEL field.
	USB_OTG_FS_GUSBCFG_PHYSEL_Msk = 0x40
	// Bit PHYSEL.
	USB_OTG_FS_GUSBCFG_PHYSEL = 0x40
	// Position of SRPCAP field.
	USB_OTG_FS_GUSBCFG_SRPCAP_Pos = 0x8
	// Bit mask of SRPCAP field.
	USB_OTG_FS_GUSBCFG_SRPCAP_Msk = 0x100
	// Bit SRPCAP.
	USB_OTG_FS_GUSBCFG_SRPCAP = 0x100
	// Position of HNPCAP field.
	USB_OTG_FS_GUSBCFG_HNPCAP_Pos = 0x9
	// Bit mask of HNPCAP field.
	USB_OTG_FS_GUSBCFG_HNPCAP_Msk = 0x200
	// Bit HNPCAP.
	USB_OTG_FS_GUSBCFG_HNPCAP = 0x200
	// Position of TRDT field.
	USB_OTG_FS_GUSBCFG_TRDT_Pos = 0xa
	// Bit mask of TRDT field.
	USB_OTG_FS_GUSBCFG_TRDT_Msk = 0x3c00
	// Position of FHMOD field.
	USB_OTG_FS_GUSBCFG_FHMOD_Pos = 0x1d
	// Bit mask of FHMOD field.
	USB_OTG_FS_GUSBCFG_FHMOD_Msk = 0x20000000
	// Bit FHMOD.
	USB_OTG_FS_GUSBCFG_FHMOD = 0x20000000
	// Position of FDMOD field.
	USB_OTG_FS_GUSBCFG_FDMOD_Pos = 0x1e
	// Bit mask of FDMOD field.
	USB_OTG_FS_GUSBCFG_FDMOD_Msk = 0x40000000
	// Bit FDMOD.
	USB_OTG_FS_GUSBCFG_FDMOD = 0x40000000
	// Position of CTXPKT field.
	USB_OTG_FS_GUSBCFG_CTXPKT_Pos = 0x1f
	// Bit mask of CTXPKT field.
	USB_OTG_FS_GUSBCFG_CTXPKT_Msk = 0x80000000
	// Bit CTXPKT.
	USB_OTG_FS_GUSBCFG_CTXPKT = 0x80000000

	// GRSTCTL: OTG_FS reset register (OTG_FS_GRSTCTL)
	// Position of CSRST field.
	USB_OTG_FS_GRSTCTL_CSRST_Pos = 0x0
	// Bit mask of CSRST field.
	USB_OTG_FS_GRSTCTL_CSRST_Msk = 0x1
	// Bit CSRST.
	USB_OTG_FS_GRSTCTL_CSRST = 0x1
	// Position of HSRST field.
	USB_OTG_FS_GRSTCTL_HSRST_Pos = 0x1
	// Bit mask of HSRST field.
	USB_OTG_FS_GRSTCTL_HSRST_Msk = 0x2
	// Bit HSRST.
	USB_OTG_FS_GRSTCTL_HSRST = 0x2
	// Position of FCRST field.
	USB_OTG_FS_GRSTCTL_FCRST_Pos = 0x2
	// Bit mask of FCRST field.
	USB_OTG_FS_GRSTCTL_FCRST_Msk = 0x4
	// Bit FCRST.
	USB_OTG_FS_GRSTCTL_FCRST = 0x4
	// Position of RXFFLSH field.
	USB_OTG_FS_GRSTCTL_RXFFLSH_Pos = 0x4
	// Bit mask of RXFFLSH field.
	USB_OTG_FS_GRSTCTL_RXFFLSH_Msk = 0x10
	// Bit RXFFLSH.
	USB_OTG_FS_GRSTCTL_RXFFLSH = 0x10
	// Position of TXFFLSH field.
	USB_OTG_FS_GRSTCTL_TXFFLSH_Pos = 0x5
	// Bit mask of TXFFLSH field.
	USB_OTG_FS_GRSTCTL_TXFFLSH_Msk = 0x20
	// Bit TXFFLSH.
	USB_OTG_FS_GRSTCTL_TXFFLSH = 0x20
	// Position of TXFNUM field.
	USB_OTG_FS_GRSTCTL_TXFNUM_Pos = 0x6
	// Bit mask of TXFNUM field.
	USB_OTG_FS_GRSTCTL_TXFNUM_Msk = 0x7c0
	// Position of AHBIDL field.
	USB_OTG_FS_GRSTCTL_AHBIDL_Pos = 0x1f
	// Bit mask of AHBIDL field.
	USB_OTG_FS_GRSTCTL_AHBIDL_Msk = 0x80000000
	// Bit AHBIDL.
	USB_OTG_FS_GRSTCTL_AHBIDL = 0x80000000

	// GINTSTS: OTG_FS core interrupt register (OTG_FS_GINTSTS)
	// Position of CMOD field.
	USB_OTG_FS_GINTSTS_CMOD_Pos = 0x0
	// Bit mask of CMOD field.
	USB_OTG_FS_GINTSTS_CMOD_Msk = 0x1
	// Bit CMOD.
	USB_OTG_FS_GINTSTS_CMOD = 0x1
	// Position of MMIS field.
	USB_OTG_FS_GINTSTS_MMIS_Pos = 0x1
	// Bit mask of MMIS field.
	USB_OTG_FS_GINTSTS_MMIS_Msk = 0x2
	// Bit MMIS.
	USB_OTG_FS_GINTSTS_MMIS = 0x2
	// Position of OTGINT field.
	USB_OTG_FS_GINTSTS_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_OTG_FS_GINTSTS_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_OTG_FS_GINTSTS_OTGINT = 0x4
	// Position of SOF field.
	USB_OTG_FS_GINTSTS_SOF_Pos = 0x3
	// Bit mask of SOF field.
	USB_OTG_FS_GINTSTS_SOF_Msk = 0x8
	// Bit SOF.
	USB_OTG_FS_GINTSTS_SOF = 0x8
	// Position of RXFLVL field.
	USB_OTG_FS_GINTSTS_RXFLVL_Pos = 0x4
	// Bit mask of RXFLVL field.
	USB_OTG_FS_GINTSTS_RXFLVL_Msk = 0x10
	// Bit RXFLVL.
	USB_OTG_FS_GINTSTS_RXFLVL = 0x10
	// Position of NPTXFE field.
	USB_OTG_FS_GINTSTS_NPTXFE_Pos = 0x5
	// Bit mask of NPTXFE field.
	USB_OTG_FS_GINTSTS_NPTXFE_Msk = 0x20
	// Bit NPTXFE.
	USB_OTG_FS_GINTSTS_NPTXFE = 0x20
	// Position of GINAKEFF field.
	USB_OTG_FS_GINTSTS_GINAKEFF_Pos = 0x6
	// Bit mask of GINAKEFF field.
	USB_OTG_FS_GINTSTS_GINAKEFF_Msk = 0x40
	// Bit GINAKEFF.
	USB_OTG_FS_GINTSTS_GINAKEFF = 0x40
	// Position of GOUTNAKEFF field.
	USB_OTG_FS_GINTSTS_GOUTNAKEFF_Pos = 0x7
	// Bit mask of GOUTNAKEFF field.
	USB_OTG_FS_GINTSTS_GOUTNAKEFF_Msk = 0x80
	// Bit GOUTNAKEFF.
	USB_OTG_FS_GINTSTS_GOUTNAKEFF = 0x80
	// Position of ESUSP field.
	USB_OTG_FS_GINTSTS_ESUSP_Pos = 0xa
	// Bit mask of ESUSP field.
	USB_OTG_FS_GINTSTS_ESUSP_Msk = 0x400
	// Bit ESUSP.
	USB_OTG_FS_GINTSTS_ESUSP = 0x400
	// Position of USBSUSP field.
	USB_OTG_FS_GINTSTS_USBSUSP_Pos = 0xb
	// Bit mask of USBSUSP field.
	USB_OTG_FS_GINTSTS_USBSUSP_Msk = 0x800
	// Bit USBSUSP.
	USB_OTG_FS_GINTSTS_USBSUSP = 0x800
	// Position of USBRST field.
	USB_OTG_FS_GINTSTS_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_OTG_FS_GINTSTS_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_OTG_FS_GINTSTS_USBRST = 0x1000
	// Position of ENUMDNE field.
	USB_OTG_FS_GINTSTS_ENUMDNE_Pos = 0xd
	// Bit mask of ENUMDNE field.
	USB_OTG_FS_GINTSTS_ENUMDNE_Msk = 0x2000
	// Bit ENUMDNE.
	USB_OTG_FS_GINTSTS_ENUMDNE = 0x2000
	// Position of ISOODRP field.
	USB_OTG_FS_GINTSTS_ISOODRP_Pos = 0xe
	// Bit mask of ISOODRP field.
	USB_OTG_FS_GINTSTS_ISOODRP_Msk = 0x4000
	// Bit ISOODRP.
	USB_OTG_FS_GINTSTS_ISOODRP = 0x4000
	// Position of EOPF field.
	USB_OTG_FS_GINTSTS_EOPF_Pos = 0xf
	// Bit mask of EOPF field.
	USB_OTG_FS_GINTSTS_EOPF_Msk = 0x8000
	// Bit EOPF.
	USB_OTG_FS_GINTSTS_EOPF = 0x8000
	// Position of IEPINT field.
	USB_OTG_FS_GINTSTS_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_OTG_FS_GINTSTS_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_OTG_FS_GINTSTS_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_OTG_FS_GINTSTS_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_OTG_FS_GINTSTS_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_OTG_FS_GINTSTS_OEPINT = 0x80000
	// Position of IISOIXFR field.
	USB_OTG_FS_GINTSTS_IISOIXFR_Pos = 0x14
	// Bit mask of IISOIXFR field.
	USB_OTG_FS_GINTSTS_IISOIXFR_Msk = 0x100000
	// Bit IISOIXFR.
	USB_OTG_FS_GINTSTS_IISOIXFR = 0x100000
	// Position of IPXFR_INCOMPISOOUT field.
	USB_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT_Pos = 0x15
	// Bit mask of IPXFR_INCOMPISOOUT field.
	USB_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT_Msk = 0x200000
	// Bit IPXFR_INCOMPISOOUT.
	USB_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT = 0x200000
	// Position of HPRTINT field.
	USB_OTG_FS_GINTSTS_HPRTINT_Pos = 0x18
	// Bit mask of HPRTINT field.
	USB_OTG_FS_GINTSTS_HPRTINT_Msk = 0x1000000
	// Bit HPRTINT.
	USB_OTG_FS_GINTSTS_HPRTINT = 0x1000000
	// Position of HCINT field.
	USB_OTG_FS_GINTSTS_HCINT_Pos = 0x19
	// Bit mask of HCINT field.
	USB_OTG_FS_GINTSTS_HCINT_Msk = 0x2000000
	// Bit HCINT.
	USB_OTG_FS_GINTSTS_HCINT = 0x2000000
	// Position of PTXFE field.
	USB_OTG_FS_GINTSTS_PTXFE_Pos = 0x1a
	// Bit mask of PTXFE field.
	USB_OTG_FS_GINTSTS_PTXFE_Msk = 0x4000000
	// Bit PTXFE.
	USB_OTG_FS_GINTSTS_PTXFE = 0x4000000
	// Position of CIDSCHG field.
	USB_OTG_FS_GINTSTS_CIDSCHG_Pos = 0x1c
	// Bit mask of CIDSCHG field.
	USB_OTG_FS_GINTSTS_CIDSCHG_Msk = 0x10000000
	// Bit CIDSCHG.
	USB_OTG_FS_GINTSTS_CIDSCHG = 0x10000000
	// Position of DISCINT field.
	USB_OTG_FS_GINTSTS_DISCINT_Pos = 0x1d
	// Bit mask of DISCINT field.
	USB_OTG_FS_GINTSTS_DISCINT_Msk = 0x20000000
	// Bit DISCINT.
	USB_OTG_FS_GINTSTS_DISCINT = 0x20000000
	// Position of SRQINT field.
	USB_OTG_FS_GINTSTS_SRQINT_Pos = 0x1e
	// Bit mask of SRQINT field.
	USB_OTG_FS_GINTSTS_SRQINT_Msk = 0x40000000
	// Bit SRQINT.
	USB_OTG_FS_GINTSTS_SRQINT = 0x40000000
	// Position of WKUPINT field.
	USB_OTG_FS_GINTSTS_WKUPINT_Pos = 0x1f
	// Bit mask of WKUPINT field.
	USB_OTG_FS_GINTSTS_WKUPINT_Msk = 0x80000000
	// Bit WKUPINT.
	USB_OTG_FS_GINTSTS_WKUPINT = 0x80000000

	// GINTMSK: OTG_FS interrupt mask register (OTG_FS_GINTMSK)
	// Position of MMISM field.
	USB_OTG_FS_GINTMSK_MMISM_Pos = 0x1
	// Bit mask of MMISM field.
	USB_OTG_FS_GINTMSK_MMISM_Msk = 0x2
	// Bit MMISM.
	USB_OTG_FS_GINTMSK_MMISM = 0x2
	// Position of OTGINT field.
	USB_OTG_FS_GINTMSK_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_OTG_FS_GINTMSK_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_OTG_FS_GINTMSK_OTGINT = 0x4
	// Position of SOFM field.
	USB_OTG_FS_GINTMSK_SOFM_Pos = 0x3
	// Bit mask of SOFM field.
	USB_OTG_FS_GINTMSK_SOFM_Msk = 0x8
	// Bit SOFM.
	USB_OTG_FS_GINTMSK_SOFM = 0x8
	// Position of RXFLVLM field.
	USB_OTG_FS_GINTMSK_RXFLVLM_Pos = 0x4
	// Bit mask of RXFLVLM field.
	USB_OTG_FS_GINTMSK_RXFLVLM_Msk = 0x10
	// Bit RXFLVLM.
	USB_OTG_FS_GINTMSK_RXFLVLM = 0x10
	// Position of NPTXFEM field.
	USB_OTG_FS_GINTMSK_NPTXFEM_Pos = 0x5
	// Bit mask of NPTXFEM field.
	USB_OTG_FS_GINTMSK_NPTXFEM_Msk = 0x20
	// Bit NPTXFEM.
	USB_OTG_FS_GINTMSK_NPTXFEM = 0x20
	// Position of GINAKEFFM field.
	USB_OTG_FS_GINTMSK_GINAKEFFM_Pos = 0x6
	// Bit mask of GINAKEFFM field.
	USB_OTG_FS_GINTMSK_GINAKEFFM_Msk = 0x40
	// Bit GINAKEFFM.
	USB_OTG_FS_GINTMSK_GINAKEFFM = 0x40
	// Position of GONAKEFFM field.
	USB_OTG_FS_GINTMSK_GONAKEFFM_Pos = 0x7
	// Bit mask of GONAKEFFM field.
	USB_OTG_FS_GINTMSK_GONAKEFFM_Msk = 0x80
	// Bit GONAKEFFM.
	USB_OTG_FS_GINTMSK_GONAKEFFM = 0x80
	// Position of ESUSPM field.
	USB_OTG_FS_GINTMSK_ESUSPM_Pos = 0xa
	// Bit mask of ESUSPM field.
	USB_OTG_FS_GINTMSK_ESUSPM_Msk = 0x400
	// Bit ESUSPM.
	USB_OTG_FS_GINTMSK_ESUSPM = 0x400
	// Position of USBSUSPM field.
	USB_OTG_FS_GINTMSK_USBSUSPM_Pos = 0xb
	// Bit mask of USBSUSPM field.
	USB_OTG_FS_GINTMSK_USBSUSPM_Msk = 0x800
	// Bit USBSUSPM.
	USB_OTG_FS_GINTMSK_USBSUSPM = 0x800
	// Position of USBRST field.
	USB_OTG_FS_GINTMSK_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_OTG_FS_GINTMSK_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_OTG_FS_GINTMSK_USBRST = 0x1000
	// Position of ENUMDNEM field.
	USB_OTG_FS_GINTMSK_ENUMDNEM_Pos = 0xd
	// Bit mask of ENUMDNEM field.
	USB_OTG_FS_GINTMSK_ENUMDNEM_Msk = 0x2000
	// Bit ENUMDNEM.
	USB_OTG_FS_GINTMSK_ENUMDNEM = 0x2000
	// Position of ISOODRPM field.
	USB_OTG_FS_GINTMSK_ISOODRPM_Pos = 0xe
	// Bit mask of ISOODRPM field.
	USB_OTG_FS_GINTMSK_ISOODRPM_Msk = 0x4000
	// Bit ISOODRPM.
	USB_OTG_FS_GINTMSK_ISOODRPM = 0x4000
	// Position of EOPFM field.
	USB_OTG_FS_GINTMSK_EOPFM_Pos = 0xf
	// Bit mask of EOPFM field.
	USB_OTG_FS_GINTMSK_EOPFM_Msk = 0x8000
	// Bit EOPFM.
	USB_OTG_FS_GINTMSK_EOPFM = 0x8000
	// Position of EPMISM field.
	USB_OTG_FS_GINTMSK_EPMISM_Pos = 0x11
	// Bit mask of EPMISM field.
	USB_OTG_FS_GINTMSK_EPMISM_Msk = 0x20000
	// Bit EPMISM.
	USB_OTG_FS_GINTMSK_EPMISM = 0x20000
	// Position of IEPINT field.
	USB_OTG_FS_GINTMSK_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_OTG_FS_GINTMSK_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_OTG_FS_GINTMSK_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_OTG_FS_GINTMSK_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_OTG_FS_GINTMSK_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_OTG_FS_GINTMSK_OEPINT = 0x80000
	// Position of IISOIXFRM field.
	USB_OTG_FS_GINTMSK_IISOIXFRM_Pos = 0x14
	// Bit mask of IISOIXFRM field.
	USB_OTG_FS_GINTMSK_IISOIXFRM_Msk = 0x100000
	// Bit IISOIXFRM.
	USB_OTG_FS_GINTMSK_IISOIXFRM = 0x100000
	// Position of IPXFRM_IISOOXFRM field.
	USB_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM_Pos = 0x15
	// Bit mask of IPXFRM_IISOOXFRM field.
	USB_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM_Msk = 0x200000
	// Bit IPXFRM_IISOOXFRM.
	USB_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM = 0x200000
	// Position of PRTIM field.
	USB_OTG_FS_GINTMSK_PRTIM_Pos = 0x18
	// Bit mask of PRTIM field.
	USB_OTG_FS_GINTMSK_PRTIM_Msk = 0x1000000
	// Bit PRTIM.
	USB_OTG_FS_GINTMSK_PRTIM = 0x1000000
	// Position of HCIM field.
	USB_OTG_FS_GINTMSK_HCIM_Pos = 0x19
	// Bit mask of HCIM field.
	USB_OTG_FS_GINTMSK_HCIM_Msk = 0x2000000
	// Bit HCIM.
	USB_OTG_FS_GINTMSK_HCIM = 0x2000000
	// Position of PTXFEM field.
	USB_OTG_FS_GINTMSK_PTXFEM_Pos = 0x1a
	// Bit mask of PTXFEM field.
	USB_OTG_FS_GINTMSK_PTXFEM_Msk = 0x4000000
	// Bit PTXFEM.
	USB_OTG_FS_GINTMSK_PTXFEM = 0x4000000
	// Position of CIDSCHGM field.
	USB_OTG_FS_GINTMSK_CIDSCHGM_Pos = 0x1c
	// Bit mask of CIDSCHGM field.
	USB_OTG_FS_GINTMSK_CIDSCHGM_Msk = 0x10000000
	// Bit CIDSCHGM.
	USB_OTG_FS_GINTMSK_CIDSCHGM = 0x10000000
	// Position of DISCINT field.
	USB_OTG_FS_GINTMSK_DISCINT_Pos = 0x1d
	// Bit mask of DISCINT field.
	USB_OTG_FS_GINTMSK_DISCINT_Msk = 0x20000000
	// Bit DISCINT.
	USB_OTG_FS_GINTMSK_DISCINT = 0x20000000
	// Position of SRQIM field.
	USB_OTG_FS_GINTMSK_SRQIM_Pos = 0x1e
	// Bit mask of SRQIM field.
	USB_OTG_FS_GINTMSK_SRQIM_Msk = 0x40000000
	// Bit SRQIM.
	USB_OTG_FS_GINTMSK_SRQIM = 0x40000000
	// Position of WUIM field.
	USB_OTG_FS_GINTMSK_WUIM_Pos = 0x1f
	// Bit mask of WUIM field.
	USB_OTG_FS_GINTMSK_WUIM_Msk = 0x80000000
	// Bit WUIM.
	USB_OTG_FS_GINTMSK_WUIM = 0x80000000

	// GRXSTSR_Device: OTG_FS Receive status debug read(Device mode)
	// Position of EPNUM field.
	USB_OTG_FS_GRXSTSR_Device_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_FS_GRXSTSR_Device_EPNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_FS_GRXSTSR_Device_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_GRXSTSR_Device_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_FS_GRXSTSR_Device_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_GRXSTSR_Device_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_FS_GRXSTSR_Device_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_GRXSTSR_Device_PKTSTS_Msk = 0x1e0000
	// Position of FRMNUM field.
	USB_OTG_FS_GRXSTSR_Device_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_FS_GRXSTSR_Device_FRMNUM_Msk = 0x1e00000

	// GRXSTSR_Host: OTG_FS Receive status debug read(Host mode)
	// Position of EPNUM field.
	USB_OTG_FS_GRXSTSR_Host_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_FS_GRXSTSR_Host_EPNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_FS_GRXSTSR_Host_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_GRXSTSR_Host_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_FS_GRXSTSR_Host_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_GRXSTSR_Host_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_FS_GRXSTSR_Host_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_GRXSTSR_Host_PKTSTS_Msk = 0x1e0000
	// Position of FRMNUM field.
	USB_OTG_FS_GRXSTSR_Host_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_FS_GRXSTSR_Host_FRMNUM_Msk = 0x1e00000

	// GRXSTSP_Device: OTG status read and pop (device mode)
	// Position of STSPHST field.
	USB_OTG_FS_GRXSTSP_Device_STSPHST_Pos = 0x1b
	// Bit mask of STSPHST field.
	USB_OTG_FS_GRXSTSP_Device_STSPHST_Msk = 0x8000000
	// Bit STSPHST.
	USB_OTG_FS_GRXSTSP_Device_STSPHST = 0x8000000
	// Position of FRMNUM field.
	USB_OTG_FS_GRXSTSP_Device_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_FS_GRXSTSP_Device_FRMNUM_Msk = 0x1e00000
	// Position of PKTSTS field.
	USB_OTG_FS_GRXSTSP_Device_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_GRXSTSP_Device_PKTSTS_Msk = 0x1e0000
	// Position of DPID field.
	USB_OTG_FS_GRXSTSP_Device_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_GRXSTSP_Device_DPID_Msk = 0x18000
	// Position of BCNT field.
	USB_OTG_FS_GRXSTSP_Device_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_GRXSTSP_Device_BCNT_Msk = 0x7ff0
	// Position of EPNUM field.
	USB_OTG_FS_GRXSTSP_Device_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_FS_GRXSTSP_Device_EPNUM_Msk = 0xf

	// GRXSTSP_Host: OTG status read and pop (host mode)
	// Position of PKTSTS field.
	USB_OTG_FS_GRXSTSP_Host_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_GRXSTSP_Host_PKTSTS_Msk = 0x1e0000
	// Position of DPID field.
	USB_OTG_FS_GRXSTSP_Host_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_GRXSTSP_Host_DPID_Msk = 0x18000
	// Position of BCNT field.
	USB_OTG_FS_GRXSTSP_Host_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_GRXSTSP_Host_BCNT_Msk = 0x7ff0
	// Position of CHNUM field.
	USB_OTG_FS_GRXSTSP_Host_CHNUM_Pos = 0x0
	// Bit mask of CHNUM field.
	USB_OTG_FS_GRXSTSP_Host_CHNUM_Msk = 0xf

	// GRXFSIZ: OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
	// Position of RXFD field.
	USB_OTG_FS_GRXFSIZ_RXFD_Pos = 0x0
	// Bit mask of RXFD field.
	USB_OTG_FS_GRXFSIZ_RXFD_Msk = 0xffff

	// DIEPTXF0: OTG_FS non-periodic transmit FIFO size register (Device mode)
	// Position of TX0FSA field.
	USB_OTG_FS_DIEPTXF0_TX0FSA_Pos = 0x0
	// Bit mask of TX0FSA field.
	USB_OTG_FS_DIEPTXF0_TX0FSA_Msk = 0xffff
	// Position of TX0FD field.
	USB_OTG_FS_DIEPTXF0_TX0FD_Pos = 0x10
	// Bit mask of TX0FD field.
	USB_OTG_FS_DIEPTXF0_TX0FD_Msk = 0xffff0000

	// HNPTXFSIZ: OTG_FS non-periodic transmit FIFO size register (Host mode)
	// Position of NPTXFSA field.
	USB_OTG_FS_HNPTXFSIZ_NPTXFSA_Pos = 0x0
	// Bit mask of NPTXFSA field.
	USB_OTG_FS_HNPTXFSIZ_NPTXFSA_Msk = 0xffff
	// Position of NPTXFD field.
	USB_OTG_FS_HNPTXFSIZ_NPTXFD_Pos = 0x10
	// Bit mask of NPTXFD field.
	USB_OTG_FS_HNPTXFSIZ_NPTXFD_Msk = 0xffff0000

	// GNPTXSTS: OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
	// Position of NPTXFSAV field.
	USB_OTG_FS_GNPTXSTS_NPTXFSAV_Pos = 0x0
	// Bit mask of NPTXFSAV field.
	USB_OTG_FS_GNPTXSTS_NPTXFSAV_Msk = 0xffff
	// Position of NPTQXSAV field.
	USB_OTG_FS_GNPTXSTS_NPTQXSAV_Pos = 0x10
	// Bit mask of NPTQXSAV field.
	USB_OTG_FS_GNPTXSTS_NPTQXSAV_Msk = 0xff0000
	// Position of NPTXQTOP field.
	USB_OTG_FS_GNPTXSTS_NPTXQTOP_Pos = 0x18
	// Bit mask of NPTXQTOP field.
	USB_OTG_FS_GNPTXSTS_NPTXQTOP_Msk = 0x7f000000

	// GCCFG: OTG_FS general core configuration register (OTG_FS_GCCFG)
	// Position of PWRDWN field.
	USB_OTG_FS_GCCFG_PWRDWN_Pos = 0x10
	// Bit mask of PWRDWN field.
	USB_OTG_FS_GCCFG_PWRDWN_Msk = 0x10000
	// Bit PWRDWN.
	USB_OTG_FS_GCCFG_PWRDWN = 0x10000
	// Position of VBUSASEN field.
	USB_OTG_FS_GCCFG_VBUSASEN_Pos = 0x12
	// Bit mask of VBUSASEN field.
	USB_OTG_FS_GCCFG_VBUSASEN_Msk = 0x40000
	// Bit VBUSASEN.
	USB_OTG_FS_GCCFG_VBUSASEN = 0x40000
	// Position of VBUSBSEN field.
	USB_OTG_FS_GCCFG_VBUSBSEN_Pos = 0x13
	// Bit mask of VBUSBSEN field.
	USB_OTG_FS_GCCFG_VBUSBSEN_Msk = 0x80000
	// Bit VBUSBSEN.
	USB_OTG_FS_GCCFG_VBUSBSEN = 0x80000
	// Position of SOFOUTEN field.
	USB_OTG_FS_GCCFG_SOFOUTEN_Pos = 0x14
	// Bit mask of SOFOUTEN field.
	USB_OTG_FS_GCCFG_SOFOUTEN_Msk = 0x100000
	// Bit SOFOUTEN.
	USB_OTG_FS_GCCFG_SOFOUTEN = 0x100000

	// CID: core ID register
	// Position of PRODUCT_ID field.
	USB_OTG_FS_CID_PRODUCT_ID_Pos = 0x0
	// Bit mask of PRODUCT_ID field.
	USB_OTG_FS_CID_PRODUCT_ID_Msk = 0xffffffff

	// HPTXFSIZ: OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
	// Position of PTXSA field.
	USB_OTG_FS_HPTXFSIZ_PTXSA_Pos = 0x0
	// Bit mask of PTXSA field.
	USB_OTG_FS_HPTXFSIZ_PTXSA_Msk = 0xffff
	// Position of PTXFSIZ field.
	USB_OTG_FS_HPTXFSIZ_PTXFSIZ_Pos = 0x10
	// Bit mask of PTXFSIZ field.
	USB_OTG_FS_HPTXFSIZ_PTXFSIZ_Msk = 0xffff0000

	// DIEPTXF1: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
	// Position of INEPTXSA field.
	USB_OTG_FS_DIEPTXF_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_FS_DIEPTXF_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_FS_DIEPTXF_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_FS_DIEPTXF_INEPTXFD_Msk = 0xffff0000
)

// Constants for SWPMI1: Single Wire Protocol Master Interface
const (
	// CR: SWPMI Configuration/Control register
	// Position of RXDMA field.
	SWPMI_CR_RXDMA_Pos = 0x0
	// Bit mask of RXDMA field.
	SWPMI_CR_RXDMA_Msk = 0x1
	// Bit RXDMA.
	SWPMI_CR_RXDMA = 0x1
	// Position of TXDMA field.
	SWPMI_CR_TXDMA_Pos = 0x1
	// Bit mask of TXDMA field.
	SWPMI_CR_TXDMA_Msk = 0x2
	// Bit TXDMA.
	SWPMI_CR_TXDMA = 0x2
	// Position of RXMODE field.
	SWPMI_CR_RXMODE_Pos = 0x2
	// Bit mask of RXMODE field.
	SWPMI_CR_RXMODE_Msk = 0x4
	// Bit RXMODE.
	SWPMI_CR_RXMODE = 0x4
	// Position of TXMODE field.
	SWPMI_CR_TXMODE_Pos = 0x3
	// Bit mask of TXMODE field.
	SWPMI_CR_TXMODE_Msk = 0x8
	// Bit TXMODE.
	SWPMI_CR_TXMODE = 0x8
	// Position of LPBK field.
	SWPMI_CR_LPBK_Pos = 0x4
	// Bit mask of LPBK field.
	SWPMI_CR_LPBK_Msk = 0x10
	// Bit LPBK.
	SWPMI_CR_LPBK = 0x10
	// Position of SWPME field.
	SWPMI_CR_SWPME_Pos = 0x5
	// Bit mask of SWPME field.
	SWPMI_CR_SWPME_Msk = 0x20
	// Bit SWPME.
	SWPMI_CR_SWPME = 0x20
	// Position of DEACT field.
	SWPMI_CR_DEACT_Pos = 0xa
	// Bit mask of DEACT field.
	SWPMI_CR_DEACT_Msk = 0x400
	// Bit DEACT.
	SWPMI_CR_DEACT = 0x400

	// BRR: SWPMI Bitrate register
	// Position of BR field.
	SWPMI_BRR_BR_Pos = 0x0
	// Bit mask of BR field.
	SWPMI_BRR_BR_Msk = 0x3f

	// ISR: SWPMI Interrupt and Status register
	// Position of RXBFF field.
	SWPMI_ISR_RXBFF_Pos = 0x0
	// Bit mask of RXBFF field.
	SWPMI_ISR_RXBFF_Msk = 0x1
	// Bit RXBFF.
	SWPMI_ISR_RXBFF = 0x1
	// Position of TXBEF field.
	SWPMI_ISR_TXBEF_Pos = 0x1
	// Bit mask of TXBEF field.
	SWPMI_ISR_TXBEF_Msk = 0x2
	// Bit TXBEF.
	SWPMI_ISR_TXBEF = 0x2
	// Position of RXBERF field.
	SWPMI_ISR_RXBERF_Pos = 0x2
	// Bit mask of RXBERF field.
	SWPMI_ISR_RXBERF_Msk = 0x4
	// Bit RXBERF.
	SWPMI_ISR_RXBERF = 0x4
	// Position of RXOVRF field.
	SWPMI_ISR_RXOVRF_Pos = 0x3
	// Bit mask of RXOVRF field.
	SWPMI_ISR_RXOVRF_Msk = 0x8
	// Bit RXOVRF.
	SWPMI_ISR_RXOVRF = 0x8
	// Position of TXUNRF field.
	SWPMI_ISR_TXUNRF_Pos = 0x4
	// Bit mask of TXUNRF field.
	SWPMI_ISR_TXUNRF_Msk = 0x10
	// Bit TXUNRF.
	SWPMI_ISR_TXUNRF = 0x10
	// Position of RXNE field.
	SWPMI_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	SWPMI_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	SWPMI_ISR_RXNE = 0x20
	// Position of TXE field.
	SWPMI_ISR_TXE_Pos = 0x6
	// Bit mask of TXE field.
	SWPMI_ISR_TXE_Msk = 0x40
	// Bit TXE.
	SWPMI_ISR_TXE = 0x40
	// Position of TCF field.
	SWPMI_ISR_TCF_Pos = 0x7
	// Bit mask of TCF field.
	SWPMI_ISR_TCF_Msk = 0x80
	// Bit TCF.
	SWPMI_ISR_TCF = 0x80
	// Position of SRF field.
	SWPMI_ISR_SRF_Pos = 0x8
	// Bit mask of SRF field.
	SWPMI_ISR_SRF_Msk = 0x100
	// Bit SRF.
	SWPMI_ISR_SRF = 0x100
	// Position of SUSP field.
	SWPMI_ISR_SUSP_Pos = 0x9
	// Bit mask of SUSP field.
	SWPMI_ISR_SUSP_Msk = 0x200
	// Bit SUSP.
	SWPMI_ISR_SUSP = 0x200
	// Position of DEACTF field.
	SWPMI_ISR_DEACTF_Pos = 0xa
	// Bit mask of DEACTF field.
	SWPMI_ISR_DEACTF_Msk = 0x400
	// Bit DEACTF.
	SWPMI_ISR_DEACTF = 0x400

	// ICR: SWPMI Interrupt Flag Clear register
	// Position of CRXBFF field.
	SWPMI_ICR_CRXBFF_Pos = 0x0
	// Bit mask of CRXBFF field.
	SWPMI_ICR_CRXBFF_Msk = 0x1
	// Bit CRXBFF.
	SWPMI_ICR_CRXBFF = 0x1
	// Position of CTXBEF field.
	SWPMI_ICR_CTXBEF_Pos = 0x1
	// Bit mask of CTXBEF field.
	SWPMI_ICR_CTXBEF_Msk = 0x2
	// Bit CTXBEF.
	SWPMI_ICR_CTXBEF = 0x2
	// Position of CRXBERF field.
	SWPMI_ICR_CRXBERF_Pos = 0x2
	// Bit mask of CRXBERF field.
	SWPMI_ICR_CRXBERF_Msk = 0x4
	// Bit CRXBERF.
	SWPMI_ICR_CRXBERF = 0x4
	// Position of CRXOVRF field.
	SWPMI_ICR_CRXOVRF_Pos = 0x3
	// Bit mask of CRXOVRF field.
	SWPMI_ICR_CRXOVRF_Msk = 0x8
	// Bit CRXOVRF.
	SWPMI_ICR_CRXOVRF = 0x8
	// Position of CTXUNRF field.
	SWPMI_ICR_CTXUNRF_Pos = 0x4
	// Bit mask of CTXUNRF field.
	SWPMI_ICR_CTXUNRF_Msk = 0x10
	// Bit CTXUNRF.
	SWPMI_ICR_CTXUNRF = 0x10
	// Position of CTCF field.
	SWPMI_ICR_CTCF_Pos = 0x7
	// Bit mask of CTCF field.
	SWPMI_ICR_CTCF_Msk = 0x80
	// Bit CTCF.
	SWPMI_ICR_CTCF = 0x80
	// Position of CSRF field.
	SWPMI_ICR_CSRF_Pos = 0x8
	// Bit mask of CSRF field.
	SWPMI_ICR_CSRF_Msk = 0x100
	// Bit CSRF.
	SWPMI_ICR_CSRF = 0x100

	// IER: SWPMI Interrupt Enable register
	// Position of RXBFIE field.
	SWPMI_IER_RXBFIE_Pos = 0x0
	// Bit mask of RXBFIE field.
	SWPMI_IER_RXBFIE_Msk = 0x1
	// Bit RXBFIE.
	SWPMI_IER_RXBFIE = 0x1
	// Position of TXBEIE field.
	SWPMI_IER_TXBEIE_Pos = 0x1
	// Bit mask of TXBEIE field.
	SWPMI_IER_TXBEIE_Msk = 0x2
	// Bit TXBEIE.
	SWPMI_IER_TXBEIE = 0x2
	// Position of RXBERIE field.
	SWPMI_IER_RXBERIE_Pos = 0x2
	// Bit mask of RXBERIE field.
	SWPMI_IER_RXBERIE_Msk = 0x4
	// Bit RXBERIE.
	SWPMI_IER_RXBERIE = 0x4
	// Position of RXOVRIE field.
	SWPMI_IER_RXOVRIE_Pos = 0x3
	// Bit mask of RXOVRIE field.
	SWPMI_IER_RXOVRIE_Msk = 0x8
	// Bit RXOVRIE.
	SWPMI_IER_RXOVRIE = 0x8
	// Position of TXUNRIE field.
	SWPMI_IER_TXUNRIE_Pos = 0x4
	// Bit mask of TXUNRIE field.
	SWPMI_IER_TXUNRIE_Msk = 0x10
	// Bit TXUNRIE.
	SWPMI_IER_TXUNRIE = 0x10
	// Position of RIE field.
	SWPMI_IER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	SWPMI_IER_RIE_Msk = 0x20
	// Bit RIE.
	SWPMI_IER_RIE = 0x20
	// Position of TIE field.
	SWPMI_IER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	SWPMI_IER_TIE_Msk = 0x40
	// Bit TIE.
	SWPMI_IER_TIE = 0x40
	// Position of TCIE field.
	SWPMI_IER_TCIE_Pos = 0x7
	// Bit mask of TCIE field.
	SWPMI_IER_TCIE_Msk = 0x80
	// Bit TCIE.
	SWPMI_IER_TCIE = 0x80
	// Position of SRIE field.
	SWPMI_IER_SRIE_Pos = 0x8
	// Bit mask of SRIE field.
	SWPMI_IER_SRIE_Msk = 0x100
	// Bit SRIE.
	SWPMI_IER_SRIE = 0x100

	// RFL: SWPMI Receive Frame Length register
	// Position of RFL field.
	SWPMI_RFL_RFL_Pos = 0x0
	// Bit mask of RFL field.
	SWPMI_RFL_RFL_Msk = 0x1f

	// TDR: SWPMI Transmit data register
	// Position of TD field.
	SWPMI_TDR_TD_Pos = 0x0
	// Bit mask of TD field.
	SWPMI_TDR_TD_Msk = 0xffffffff

	// RDR: SWPMI Receive data register
	// Position of RD field.
	SWPMI_RDR_RD_Pos = 0x0
	// Bit mask of RD field.
	SWPMI_RDR_RD_Msk = 0xffffffff
)

// Constants for OPAMP: Operational amplifiers
const (
	// OPAMP1_CSR: OPAMP1 control/status register
	// Position of OPAEN field.
	OPAMP_OPAMP1_CSR_OPAEN_Pos = 0x0
	// Bit mask of OPAEN field.
	OPAMP_OPAMP1_CSR_OPAEN_Msk = 0x1
	// Bit OPAEN.
	OPAMP_OPAMP1_CSR_OPAEN = 0x1
	// Position of OPALPM field.
	OPAMP_OPAMP1_CSR_OPALPM_Pos = 0x1
	// Bit mask of OPALPM field.
	OPAMP_OPAMP1_CSR_OPALPM_Msk = 0x2
	// Bit OPALPM.
	OPAMP_OPAMP1_CSR_OPALPM = 0x2
	// Position of OPAMODE field.
	OPAMP_OPAMP1_CSR_OPAMODE_Pos = 0x2
	// Bit mask of OPAMODE field.
	OPAMP_OPAMP1_CSR_OPAMODE_Msk = 0xc
	// Position of PGA_GAIN field.
	OPAMP_OPAMP1_CSR_PGA_GAIN_Pos = 0x4
	// Bit mask of PGA_GAIN field.
	OPAMP_OPAMP1_CSR_PGA_GAIN_Msk = 0x30
	// Position of VM_SEL field.
	OPAMP_OPAMP1_CSR_VM_SEL_Pos = 0x8
	// Bit mask of VM_SEL field.
	OPAMP_OPAMP1_CSR_VM_SEL_Msk = 0x300
	// Position of VP_SEL field.
	OPAMP_OPAMP1_CSR_VP_SEL_Pos = 0xa
	// Bit mask of VP_SEL field.
	OPAMP_OPAMP1_CSR_VP_SEL_Msk = 0x400
	// Bit VP_SEL.
	OPAMP_OPAMP1_CSR_VP_SEL = 0x400
	// Position of CALON field.
	OPAMP_OPAMP1_CSR_CALON_Pos = 0xc
	// Bit mask of CALON field.
	OPAMP_OPAMP1_CSR_CALON_Msk = 0x1000
	// Bit CALON.
	OPAMP_OPAMP1_CSR_CALON = 0x1000
	// Position of CALSEL field.
	OPAMP_OPAMP1_CSR_CALSEL_Pos = 0xd
	// Bit mask of CALSEL field.
	OPAMP_OPAMP1_CSR_CALSEL_Msk = 0x2000
	// Bit CALSEL.
	OPAMP_OPAMP1_CSR_CALSEL = 0x2000
	// Position of USERTRIM field.
	OPAMP_OPAMP1_CSR_USERTRIM_Pos = 0xe
	// Bit mask of USERTRIM field.
	OPAMP_OPAMP1_CSR_USERTRIM_Msk = 0x4000
	// Bit USERTRIM.
	OPAMP_OPAMP1_CSR_USERTRIM = 0x4000
	// Position of CALOUT field.
	OPAMP_OPAMP1_CSR_CALOUT_Pos = 0xf
	// Bit mask of CALOUT field.
	OPAMP_OPAMP1_CSR_CALOUT_Msk = 0x8000
	// Bit CALOUT.
	OPAMP_OPAMP1_CSR_CALOUT = 0x8000
	// Position of OPA_RANGE field.
	OPAMP_OPAMP1_CSR_OPA_RANGE_Pos = 0x1f
	// Bit mask of OPA_RANGE field.
	OPAMP_OPAMP1_CSR_OPA_RANGE_Msk = 0x80000000
	// Bit OPA_RANGE.
	OPAMP_OPAMP1_CSR_OPA_RANGE = 0x80000000

	// OPAMP1_OTR: OPAMP1 offset trimming register in normal mode
	// Position of TRIMOFFSETN field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETN_Pos = 0x0
	// Bit mask of TRIMOFFSETN field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETN_Msk = 0x1f
	// Position of TRIMOFFSETP field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETP_Pos = 0x8
	// Bit mask of TRIMOFFSETP field.
	OPAMP_OPAMP1_OTR_TRIMOFFSETP_Msk = 0x1f00

	// OPAMP1_LPOTR: OPAMP1 offset trimming register in low-power mode
	// Position of TRIMLPOFFSETN field.
	OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETN_Pos = 0x0
	// Bit mask of TRIMLPOFFSETN field.
	OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETN_Msk = 0x1f
	// Position of TRIMLPOFFSETP field.
	OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETP_Pos = 0x8
	// Bit mask of TRIMLPOFFSETP field.
	OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETP_Msk = 0x1f00

	// OPAMP2_CSR: OPAMP2 control/status register
	// Position of OPAEN field.
	OPAMP_OPAMP2_CSR_OPAEN_Pos = 0x0
	// Bit mask of OPAEN field.
	OPAMP_OPAMP2_CSR_OPAEN_Msk = 0x1
	// Bit OPAEN.
	OPAMP_OPAMP2_CSR_OPAEN = 0x1
	// Position of OPALPM field.
	OPAMP_OPAMP2_CSR_OPALPM_Pos = 0x1
	// Bit mask of OPALPM field.
	OPAMP_OPAMP2_CSR_OPALPM_Msk = 0x2
	// Bit OPALPM.
	OPAMP_OPAMP2_CSR_OPALPM = 0x2
	// Position of OPAMODE field.
	OPAMP_OPAMP2_CSR_OPAMODE_Pos = 0x2
	// Bit mask of OPAMODE field.
	OPAMP_OPAMP2_CSR_OPAMODE_Msk = 0xc
	// Position of PGA_GAIN field.
	OPAMP_OPAMP2_CSR_PGA_GAIN_Pos = 0x4
	// Bit mask of PGA_GAIN field.
	OPAMP_OPAMP2_CSR_PGA_GAIN_Msk = 0x30
	// Position of VM_SEL field.
	OPAMP_OPAMP2_CSR_VM_SEL_Pos = 0x8
	// Bit mask of VM_SEL field.
	OPAMP_OPAMP2_CSR_VM_SEL_Msk = 0x300
	// Position of VP_SEL field.
	OPAMP_OPAMP2_CSR_VP_SEL_Pos = 0xa
	// Bit mask of VP_SEL field.
	OPAMP_OPAMP2_CSR_VP_SEL_Msk = 0x400
	// Bit VP_SEL.
	OPAMP_OPAMP2_CSR_VP_SEL = 0x400
	// Position of CALON field.
	OPAMP_OPAMP2_CSR_CALON_Pos = 0xc
	// Bit mask of CALON field.
	OPAMP_OPAMP2_CSR_CALON_Msk = 0x1000
	// Bit CALON.
	OPAMP_OPAMP2_CSR_CALON = 0x1000
	// Position of CALSEL field.
	OPAMP_OPAMP2_CSR_CALSEL_Pos = 0xd
	// Bit mask of CALSEL field.
	OPAMP_OPAMP2_CSR_CALSEL_Msk = 0x2000
	// Bit CALSEL.
	OPAMP_OPAMP2_CSR_CALSEL = 0x2000
	// Position of USERTRIM field.
	OPAMP_OPAMP2_CSR_USERTRIM_Pos = 0xe
	// Bit mask of USERTRIM field.
	OPAMP_OPAMP2_CSR_USERTRIM_Msk = 0x4000
	// Bit USERTRIM.
	OPAMP_OPAMP2_CSR_USERTRIM = 0x4000
	// Position of CALOUT field.
	OPAMP_OPAMP2_CSR_CALOUT_Pos = 0xf
	// Bit mask of CALOUT field.
	OPAMP_OPAMP2_CSR_CALOUT_Msk = 0x8000
	// Bit CALOUT.
	OPAMP_OPAMP2_CSR_CALOUT = 0x8000

	// OPAMP2_OTR: OPAMP2 offset trimming register in normal mode
	// Position of TRIMOFFSETN field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETN_Pos = 0x0
	// Bit mask of TRIMOFFSETN field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETN_Msk = 0x1f
	// Position of TRIMOFFSETP field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETP_Pos = 0x8
	// Bit mask of TRIMOFFSETP field.
	OPAMP_OPAMP2_OTR_TRIMOFFSETP_Msk = 0x1f00

	// OPAMP2_LPOTR: OPAMP2 offset trimming register in low-power mode
	// Position of TRIMLPOFFSETN field.
	OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETN_Pos = 0x0
	// Bit mask of TRIMLPOFFSETN field.
	OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETN_Msk = 0x1f
	// Position of TRIMLPOFFSETP field.
	OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETP_Pos = 0x8
	// Bit mask of TRIMLPOFFSETP field.
	OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETP_Msk = 0x1f00
)

// Constants for FMC: Flexible memory controller
const (
	// BCR1: SRAM/NOR-Flash chip-select control register 1
	// Position of MBKEN field.
	FMC_BCR1_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR1_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR1_MBKEN = 0x1
	// Position of MUXEN field.
	FMC_BCR1_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR1_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR1_MUXEN = 0x2
	// Position of MTYP field.
	FMC_BCR1_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR1_MTYP_Msk = 0xc
	// Position of MWID field.
	FMC_BCR1_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR1_MWID_Msk = 0x30
	// Position of FACCEN field.
	FMC_BCR1_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR1_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR1_FACCEN = 0x40
	// Position of BURSTEN field.
	FMC_BCR1_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR1_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR1_BURSTEN = 0x100
	// Position of WAITPOL field.
	FMC_BCR1_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR1_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR1_WAITPOL = 0x200
	// Position of WAITCFG field.
	FMC_BCR1_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR1_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR1_WAITCFG = 0x800
	// Position of WREN field.
	FMC_BCR1_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR1_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR1_WREN = 0x1000
	// Position of WAITEN field.
	FMC_BCR1_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR1_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR1_WAITEN = 0x2000
	// Position of EXTMOD field.
	FMC_BCR1_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR1_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR1_EXTMOD = 0x4000
	// Position of ASYNCWAIT field.
	FMC_BCR1_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR1_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR1_ASYNCWAIT = 0x8000
	// Position of CBURSTRW field.
	FMC_BCR1_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR1_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR1_CBURSTRW = 0x80000
	// Position of CCLKEN field.
	FMC_BCR1_CCLKEN_Pos = 0x14
	// Bit mask of CCLKEN field.
	FMC_BCR1_CCLKEN_Msk = 0x100000
	// Bit CCLKEN.
	FMC_BCR1_CCLKEN = 0x100000
	// Position of WFDIS field.
	FMC_BCR1_WFDIS_Pos = 0x15
	// Bit mask of WFDIS field.
	FMC_BCR1_WFDIS_Msk = 0x200000
	// Bit WFDIS.
	FMC_BCR1_WFDIS = 0x200000

	// BTR1: SRAM/NOR-Flash chip-select timing register 1
	// Position of ACCMOD field.
	FMC_BTR1_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR1_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BTR1_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR1_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BTR1_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR1_CLKDIV_Msk = 0xf00000
	// Position of BUSTURN field.
	FMC_BTR1_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR1_BUSTURN_Msk = 0xf0000
	// Position of DATAST field.
	FMC_BTR1_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR1_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BTR1_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR1_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BTR1_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR1_ADDSET_Msk = 0xf

	// BCR2: SRAM/NOR-Flash chip-select control register 2
	// Position of CBURSTRW field.
	FMC_BCR2_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR2_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR2_CBURSTRW = 0x80000
	// Position of ASYNCWAIT field.
	FMC_BCR2_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR2_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR2_ASYNCWAIT = 0x8000
	// Position of EXTMOD field.
	FMC_BCR2_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR2_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR2_EXTMOD = 0x4000
	// Position of WAITEN field.
	FMC_BCR2_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR2_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR2_WAITEN = 0x2000
	// Position of WREN field.
	FMC_BCR2_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR2_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR2_WREN = 0x1000
	// Position of WAITCFG field.
	FMC_BCR2_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR2_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR2_WAITCFG = 0x800
	// Position of WRAPMOD field.
	FMC_BCR2_WRAPMOD_Pos = 0xa
	// Bit mask of WRAPMOD field.
	FMC_BCR2_WRAPMOD_Msk = 0x400
	// Bit WRAPMOD.
	FMC_BCR2_WRAPMOD = 0x400
	// Position of WAITPOL field.
	FMC_BCR2_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR2_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR2_WAITPOL = 0x200
	// Position of BURSTEN field.
	FMC_BCR2_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR2_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR2_BURSTEN = 0x100
	// Position of FACCEN field.
	FMC_BCR2_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR2_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR2_FACCEN = 0x40
	// Position of MWID field.
	FMC_BCR2_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR2_MWID_Msk = 0x30
	// Position of MTYP field.
	FMC_BCR2_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR2_MTYP_Msk = 0xc
	// Position of MUXEN field.
	FMC_BCR2_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR2_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR2_MUXEN = 0x2
	// Position of MBKEN field.
	FMC_BCR2_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR2_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR2_MBKEN = 0x1

	// BTR2: SRAM/NOR-Flash chip-select timing register 2
	// Position of ACCMOD field.
	FMC_BTR2_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR2_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BTR2_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR2_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BTR2_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR2_CLKDIV_Msk = 0xf00000
	// Position of BUSTURN field.
	FMC_BTR2_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR2_BUSTURN_Msk = 0xf0000
	// Position of DATAST field.
	FMC_BTR2_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR2_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BTR2_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR2_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BTR2_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR2_ADDSET_Msk = 0xf

	// BCR3: SRAM/NOR-Flash chip-select control register 3
	// Position of CBURSTRW field.
	FMC_BCR3_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR3_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR3_CBURSTRW = 0x80000
	// Position of ASYNCWAIT field.
	FMC_BCR3_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR3_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR3_ASYNCWAIT = 0x8000
	// Position of EXTMOD field.
	FMC_BCR3_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR3_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR3_EXTMOD = 0x4000
	// Position of WAITEN field.
	FMC_BCR3_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR3_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR3_WAITEN = 0x2000
	// Position of WREN field.
	FMC_BCR3_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR3_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR3_WREN = 0x1000
	// Position of WAITCFG field.
	FMC_BCR3_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR3_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR3_WAITCFG = 0x800
	// Position of WRAPMOD field.
	FMC_BCR3_WRAPMOD_Pos = 0xa
	// Bit mask of WRAPMOD field.
	FMC_BCR3_WRAPMOD_Msk = 0x400
	// Bit WRAPMOD.
	FMC_BCR3_WRAPMOD = 0x400
	// Position of WAITPOL field.
	FMC_BCR3_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR3_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR3_WAITPOL = 0x200
	// Position of BURSTEN field.
	FMC_BCR3_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR3_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR3_BURSTEN = 0x100
	// Position of FACCEN field.
	FMC_BCR3_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR3_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR3_FACCEN = 0x40
	// Position of MWID field.
	FMC_BCR3_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR3_MWID_Msk = 0x30
	// Position of MTYP field.
	FMC_BCR3_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR3_MTYP_Msk = 0xc
	// Position of MUXEN field.
	FMC_BCR3_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR3_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR3_MUXEN = 0x2
	// Position of MBKEN field.
	FMC_BCR3_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR3_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR3_MBKEN = 0x1

	// BTR3: SRAM/NOR-Flash chip-select timing register 3
	// Position of ACCMOD field.
	FMC_BTR3_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR3_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BTR3_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR3_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BTR3_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR3_CLKDIV_Msk = 0xf00000
	// Position of BUSTURN field.
	FMC_BTR3_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR3_BUSTURN_Msk = 0xf0000
	// Position of DATAST field.
	FMC_BTR3_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR3_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BTR3_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR3_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BTR3_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR3_ADDSET_Msk = 0xf

	// BCR4: SRAM/NOR-Flash chip-select control register 4
	// Position of CBURSTRW field.
	FMC_BCR4_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FMC_BCR4_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FMC_BCR4_CBURSTRW = 0x80000
	// Position of ASYNCWAIT field.
	FMC_BCR4_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FMC_BCR4_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FMC_BCR4_ASYNCWAIT = 0x8000
	// Position of EXTMOD field.
	FMC_BCR4_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FMC_BCR4_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FMC_BCR4_EXTMOD = 0x4000
	// Position of WAITEN field.
	FMC_BCR4_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FMC_BCR4_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FMC_BCR4_WAITEN = 0x2000
	// Position of WREN field.
	FMC_BCR4_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FMC_BCR4_WREN_Msk = 0x1000
	// Bit WREN.
	FMC_BCR4_WREN = 0x1000
	// Position of WAITCFG field.
	FMC_BCR4_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FMC_BCR4_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FMC_BCR4_WAITCFG = 0x800
	// Position of WRAPMOD field.
	FMC_BCR4_WRAPMOD_Pos = 0xa
	// Bit mask of WRAPMOD field.
	FMC_BCR4_WRAPMOD_Msk = 0x400
	// Bit WRAPMOD.
	FMC_BCR4_WRAPMOD = 0x400
	// Position of WAITPOL field.
	FMC_BCR4_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FMC_BCR4_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FMC_BCR4_WAITPOL = 0x200
	// Position of BURSTEN field.
	FMC_BCR4_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FMC_BCR4_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FMC_BCR4_BURSTEN = 0x100
	// Position of FACCEN field.
	FMC_BCR4_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FMC_BCR4_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FMC_BCR4_FACCEN = 0x40
	// Position of MWID field.
	FMC_BCR4_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FMC_BCR4_MWID_Msk = 0x30
	// Position of MTYP field.
	FMC_BCR4_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FMC_BCR4_MTYP_Msk = 0xc
	// Position of MUXEN field.
	FMC_BCR4_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FMC_BCR4_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FMC_BCR4_MUXEN = 0x2
	// Position of MBKEN field.
	FMC_BCR4_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FMC_BCR4_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FMC_BCR4_MBKEN = 0x1

	// BTR4: SRAM/NOR-Flash chip-select timing register 4
	// Position of ACCMOD field.
	FMC_BTR4_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BTR4_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BTR4_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BTR4_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BTR4_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BTR4_CLKDIV_Msk = 0xf00000
	// Position of BUSTURN field.
	FMC_BTR4_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FMC_BTR4_BUSTURN_Msk = 0xf0000
	// Position of DATAST field.
	FMC_BTR4_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BTR4_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BTR4_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BTR4_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BTR4_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BTR4_ADDSET_Msk = 0xf

	// PCR: PC Card/NAND Flash control register 3
	// Position of ECCPS field.
	FMC_PCR_ECCPS_Pos = 0x11
	// Bit mask of ECCPS field.
	FMC_PCR_ECCPS_Msk = 0xe0000
	// Position of TAR field.
	FMC_PCR_TAR_Pos = 0xd
	// Bit mask of TAR field.
	FMC_PCR_TAR_Msk = 0x1e000
	// Position of TCLR field.
	FMC_PCR_TCLR_Pos = 0x9
	// Bit mask of TCLR field.
	FMC_PCR_TCLR_Msk = 0x1e00
	// Position of ECCEN field.
	FMC_PCR_ECCEN_Pos = 0x6
	// Bit mask of ECCEN field.
	FMC_PCR_ECCEN_Msk = 0x40
	// Bit ECCEN.
	FMC_PCR_ECCEN = 0x40
	// Position of PWID field.
	FMC_PCR_PWID_Pos = 0x4
	// Bit mask of PWID field.
	FMC_PCR_PWID_Msk = 0x30
	// Position of PTYP field.
	FMC_PCR_PTYP_Pos = 0x3
	// Bit mask of PTYP field.
	FMC_PCR_PTYP_Msk = 0x8
	// Bit PTYP.
	FMC_PCR_PTYP = 0x8
	// Position of PBKEN field.
	FMC_PCR_PBKEN_Pos = 0x2
	// Bit mask of PBKEN field.
	FMC_PCR_PBKEN_Msk = 0x4
	// Bit PBKEN.
	FMC_PCR_PBKEN = 0x4
	// Position of PWAITEN field.
	FMC_PCR_PWAITEN_Pos = 0x1
	// Bit mask of PWAITEN field.
	FMC_PCR_PWAITEN_Msk = 0x2
	// Bit PWAITEN.
	FMC_PCR_PWAITEN = 0x2

	// SR: FIFO status and interrupt register 3
	// Position of FEMPT field.
	FMC_SR_FEMPT_Pos = 0x6
	// Bit mask of FEMPT field.
	FMC_SR_FEMPT_Msk = 0x40
	// Bit FEMPT.
	FMC_SR_FEMPT = 0x40
	// Position of IFEN field.
	FMC_SR_IFEN_Pos = 0x5
	// Bit mask of IFEN field.
	FMC_SR_IFEN_Msk = 0x20
	// Bit IFEN.
	FMC_SR_IFEN = 0x20
	// Position of ILEN field.
	FMC_SR_ILEN_Pos = 0x4
	// Bit mask of ILEN field.
	FMC_SR_ILEN_Msk = 0x10
	// Bit ILEN.
	FMC_SR_ILEN = 0x10
	// Position of IREN field.
	FMC_SR_IREN_Pos = 0x3
	// Bit mask of IREN field.
	FMC_SR_IREN_Msk = 0x8
	// Bit IREN.
	FMC_SR_IREN = 0x8
	// Position of IFS field.
	FMC_SR_IFS_Pos = 0x2
	// Bit mask of IFS field.
	FMC_SR_IFS_Msk = 0x4
	// Bit IFS.
	FMC_SR_IFS = 0x4
	// Position of ILS field.
	FMC_SR_ILS_Pos = 0x1
	// Bit mask of ILS field.
	FMC_SR_ILS_Msk = 0x2
	// Bit ILS.
	FMC_SR_ILS = 0x2
	// Position of IRS field.
	FMC_SR_IRS_Pos = 0x0
	// Bit mask of IRS field.
	FMC_SR_IRS_Msk = 0x1
	// Bit IRS.
	FMC_SR_IRS = 0x1

	// PMEM: Common memory space timing register 3
	// Position of MEMHIZx field.
	FMC_PMEM_MEMHIZx_Pos = 0x18
	// Bit mask of MEMHIZx field.
	FMC_PMEM_MEMHIZx_Msk = 0xff000000
	// Position of MEMHOLDx field.
	FMC_PMEM_MEMHOLDx_Pos = 0x10
	// Bit mask of MEMHOLDx field.
	FMC_PMEM_MEMHOLDx_Msk = 0xff0000
	// Position of MEMWAITx field.
	FMC_PMEM_MEMWAITx_Pos = 0x8
	// Bit mask of MEMWAITx field.
	FMC_PMEM_MEMWAITx_Msk = 0xff00
	// Position of MEMSETx field.
	FMC_PMEM_MEMSETx_Pos = 0x0
	// Bit mask of MEMSETx field.
	FMC_PMEM_MEMSETx_Msk = 0xff

	// PATT: Attribute memory space timing register 3
	// Position of ATTHIZx field.
	FMC_PATT_ATTHIZx_Pos = 0x18
	// Bit mask of ATTHIZx field.
	FMC_PATT_ATTHIZx_Msk = 0xff000000
	// Position of ATTHOLDx field.
	FMC_PATT_ATTHOLDx_Pos = 0x10
	// Bit mask of ATTHOLDx field.
	FMC_PATT_ATTHOLDx_Msk = 0xff0000
	// Position of ATTWAITx field.
	FMC_PATT_ATTWAITx_Pos = 0x8
	// Bit mask of ATTWAITx field.
	FMC_PATT_ATTWAITx_Msk = 0xff00
	// Position of ATTSETx field.
	FMC_PATT_ATTSETx_Pos = 0x0
	// Bit mask of ATTSETx field.
	FMC_PATT_ATTSETx_Msk = 0xff

	// ECCR: ECC result register 3
	// Position of ECCx field.
	FMC_ECCR_ECCx_Pos = 0x0
	// Bit mask of ECCx field.
	FMC_ECCR_ECCx_Msk = 0xffffffff

	// BWTR1: SRAM/NOR-Flash write timing registers 1
	// Position of ACCMOD field.
	FMC_BWTR1_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR1_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BWTR1_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BWTR1_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BWTR1_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BWTR1_CLKDIV_Msk = 0xf00000
	// Position of DATAST field.
	FMC_BWTR1_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR1_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BWTR1_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR1_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BWTR1_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR1_ADDSET_Msk = 0xf

	// BWTR2: SRAM/NOR-Flash write timing registers 2
	// Position of ACCMOD field.
	FMC_BWTR2_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR2_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BWTR2_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BWTR2_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BWTR2_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BWTR2_CLKDIV_Msk = 0xf00000
	// Position of DATAST field.
	FMC_BWTR2_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR2_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BWTR2_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR2_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BWTR2_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR2_ADDSET_Msk = 0xf

	// BWTR3: SRAM/NOR-Flash write timing registers 3
	// Position of ACCMOD field.
	FMC_BWTR3_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR3_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BWTR3_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BWTR3_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BWTR3_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BWTR3_CLKDIV_Msk = 0xf00000
	// Position of DATAST field.
	FMC_BWTR3_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR3_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BWTR3_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR3_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BWTR3_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR3_ADDSET_Msk = 0xf

	// BWTR4: SRAM/NOR-Flash write timing registers 4
	// Position of ACCMOD field.
	FMC_BWTR4_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FMC_BWTR4_ACCMOD_Msk = 0x30000000
	// Position of DATLAT field.
	FMC_BWTR4_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FMC_BWTR4_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FMC_BWTR4_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FMC_BWTR4_CLKDIV_Msk = 0xf00000
	// Position of DATAST field.
	FMC_BWTR4_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FMC_BWTR4_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FMC_BWTR4_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FMC_BWTR4_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FMC_BWTR4_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FMC_BWTR4_ADDSET_Msk = 0xf
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER0: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER0_SETENA_Msk = 0xffffffff

	// ISER1: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER1_SETENA_Msk = 0xffffffff

	// ISER2: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER2_SETENA_Msk = 0xffffffff

	// ICER0: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER0_CLRENA_Msk = 0xffffffff

	// ICER1: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER1_CLRENA_Msk = 0xffffffff

	// ICER2: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER2_CLRENA_Msk = 0xffffffff

	// ISPR0: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR0_SETPEND_Msk = 0xffffffff

	// ISPR1: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR1_SETPEND_Msk = 0xffffffff

	// ISPR2: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR2_SETPEND_Msk = 0xffffffff

	// ICPR0: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Msk = 0xffffffff

	// ICPR1: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Msk = 0xffffffff

	// ICPR2: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR2_CLRPEND_Msk = 0xffffffff

	// IABR0: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR0_ACTIVE_Msk = 0xffffffff

	// IABR1: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR1_ACTIVE_Msk = 0xffffffff

	// IABR2: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR2_ACTIVE_Msk = 0xffffffff

	// IPR0: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Msk = 0xff000000

	// IPR1: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Msk = 0xff000000

	// IPR2: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Msk = 0xff000000

	// IPR3: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Msk = 0xff000000

	// IPR4: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Msk = 0xff000000

	// IPR5: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Msk = 0xff000000

	// IPR6: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Msk = 0xff000000

	// IPR7: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Msk = 0xff000000

	// IPR8: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Msk = 0xff000000

	// IPR9: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Msk = 0xff000000

	// IPR10: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Msk = 0xff000000

	// IPR11: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Msk = 0xff000000

	// IPR12: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Msk = 0xff000000

	// IPR13: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Msk = 0xff000000

	// IPR14: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Msk = 0xff000000

	// IPR15: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Msk = 0xff000000

	// IPR16: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Msk = 0xff000000

	// IPR17: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Msk = 0xff000000

	// IPR18: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR18_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR18_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR18_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR18_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR18_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR18_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR18_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR18_IPR_N3_Msk = 0xff000000

	// IPR19: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR19_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR19_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR19_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR19_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR19_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR19_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR19_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR19_IPR_N3_Msk = 0xff000000

	// IPR20: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR20_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR20_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR20_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR20_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR20_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR20_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR20_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR20_IPR_N3_Msk = 0xff000000
)

// Constants for CRS: Clock recovery system
const (
	// CR: control register
	// Position of TRIM field.
	CRS_CR_TRIM_Pos = 0x8
	// Bit mask of TRIM field.
	CRS_CR_TRIM_Msk = 0x3f00
	// Position of SWSYNC field.
	CRS_CR_SWSYNC_Pos = 0x7
	// Bit mask of SWSYNC field.
	CRS_CR_SWSYNC_Msk = 0x80
	// Bit SWSYNC.
	CRS_CR_SWSYNC = 0x80
	// Position of AUTOTRIMEN field.
	CRS_CR_AUTOTRIMEN_Pos = 0x6
	// Bit mask of AUTOTRIMEN field.
	CRS_CR_AUTOTRIMEN_Msk = 0x40
	// Bit AUTOTRIMEN.
	CRS_CR_AUTOTRIMEN = 0x40
	// Position of CEN field.
	CRS_CR_CEN_Pos = 0x5
	// Bit mask of CEN field.
	CRS_CR_CEN_Msk = 0x20
	// Bit CEN.
	CRS_CR_CEN = 0x20
	// Position of ESYNCIE field.
	CRS_CR_ESYNCIE_Pos = 0x3
	// Bit mask of ESYNCIE field.
	CRS_CR_ESYNCIE_Msk = 0x8
	// Bit ESYNCIE.
	CRS_CR_ESYNCIE = 0x8
	// Position of ERRIE field.
	CRS_CR_ERRIE_Pos = 0x2
	// Bit mask of ERRIE field.
	CRS_CR_ERRIE_Msk = 0x4
	// Bit ERRIE.
	CRS_CR_ERRIE = 0x4
	// Position of SYNCWARNIE field.
	CRS_CR_SYNCWARNIE_Pos = 0x1
	// Bit mask of SYNCWARNIE field.
	CRS_CR_SYNCWARNIE_Msk = 0x2
	// Bit SYNCWARNIE.
	CRS_CR_SYNCWARNIE = 0x2
	// Position of SYNCOKIE field.
	CRS_CR_SYNCOKIE_Pos = 0x0
	// Bit mask of SYNCOKIE field.
	CRS_CR_SYNCOKIE_Msk = 0x1
	// Bit SYNCOKIE.
	CRS_CR_SYNCOKIE = 0x1

	// CFGR: configuration register
	// Position of SYNCPOL field.
	CRS_CFGR_SYNCPOL_Pos = 0x1f
	// Bit mask of SYNCPOL field.
	CRS_CFGR_SYNCPOL_Msk = 0x80000000
	// Bit SYNCPOL.
	CRS_CFGR_SYNCPOL = 0x80000000
	// Position of SYNCSRC field.
	CRS_CFGR_SYNCSRC_Pos = 0x1c
	// Bit mask of SYNCSRC field.
	CRS_CFGR_SYNCSRC_Msk = 0x30000000
	// Position of SYNCDIV field.
	CRS_CFGR_SYNCDIV_Pos = 0x18
	// Bit mask of SYNCDIV field.
	CRS_CFGR_SYNCDIV_Msk = 0x7000000
	// Position of FELIM field.
	CRS_CFGR_FELIM_Pos = 0x10
	// Bit mask of FELIM field.
	CRS_CFGR_FELIM_Msk = 0xff0000
	// Position of RELOAD field.
	CRS_CFGR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	CRS_CFGR_RELOAD_Msk = 0xffff

	// ISR: interrupt and status register
	// Position of FECAP field.
	CRS_ISR_FECAP_Pos = 0x10
	// Bit mask of FECAP field.
	CRS_ISR_FECAP_Msk = 0xffff0000
	// Position of FEDIR field.
	CRS_ISR_FEDIR_Pos = 0xf
	// Bit mask of FEDIR field.
	CRS_ISR_FEDIR_Msk = 0x8000
	// Bit FEDIR.
	CRS_ISR_FEDIR = 0x8000
	// Position of TRIMOVF field.
	CRS_ISR_TRIMOVF_Pos = 0xa
	// Bit mask of TRIMOVF field.
	CRS_ISR_TRIMOVF_Msk = 0x400
	// Bit TRIMOVF.
	CRS_ISR_TRIMOVF = 0x400
	// Position of SYNCMISS field.
	CRS_ISR_SYNCMISS_Pos = 0x9
	// Bit mask of SYNCMISS field.
	CRS_ISR_SYNCMISS_Msk = 0x200
	// Bit SYNCMISS.
	CRS_ISR_SYNCMISS = 0x200
	// Position of SYNCERR field.
	CRS_ISR_SYNCERR_Pos = 0x8
	// Bit mask of SYNCERR field.
	CRS_ISR_SYNCERR_Msk = 0x100
	// Bit SYNCERR.
	CRS_ISR_SYNCERR = 0x100
	// Position of ESYNCF field.
	CRS_ISR_ESYNCF_Pos = 0x3
	// Bit mask of ESYNCF field.
	CRS_ISR_ESYNCF_Msk = 0x8
	// Bit ESYNCF.
	CRS_ISR_ESYNCF = 0x8
	// Position of ERRF field.
	CRS_ISR_ERRF_Pos = 0x2
	// Bit mask of ERRF field.
	CRS_ISR_ERRF_Msk = 0x4
	// Bit ERRF.
	CRS_ISR_ERRF = 0x4
	// Position of SYNCWARNF field.
	CRS_ISR_SYNCWARNF_Pos = 0x1
	// Bit mask of SYNCWARNF field.
	CRS_ISR_SYNCWARNF_Msk = 0x2
	// Bit SYNCWARNF.
	CRS_ISR_SYNCWARNF = 0x2
	// Position of SYNCOKF field.
	CRS_ISR_SYNCOKF_Pos = 0x0
	// Bit mask of SYNCOKF field.
	CRS_ISR_SYNCOKF_Msk = 0x1
	// Bit SYNCOKF.
	CRS_ISR_SYNCOKF = 0x1

	// ICR: interrupt flag clear register
	// Position of ESYNCC field.
	CRS_ICR_ESYNCC_Pos = 0x3
	// Bit mask of ESYNCC field.
	CRS_ICR_ESYNCC_Msk = 0x8
	// Bit ESYNCC.
	CRS_ICR_ESYNCC = 0x8
	// Position of ERRC field.
	CRS_ICR_ERRC_Pos = 0x2
	// Bit mask of ERRC field.
	CRS_ICR_ERRC_Msk = 0x4
	// Bit ERRC.
	CRS_ICR_ERRC = 0x4
	// Position of SYNCWARNC field.
	CRS_ICR_SYNCWARNC_Pos = 0x1
	// Bit mask of SYNCWARNC field.
	CRS_ICR_SYNCWARNC_Msk = 0x2
	// Bit SYNCWARNC.
	CRS_ICR_SYNCWARNC = 0x2
	// Position of SYNCOKC field.
	CRS_ICR_SYNCOKC_Pos = 0x0
	// Bit mask of SYNCOKC field.
	CRS_ICR_SYNCOKC_Msk = 0x1
	// Bit SYNCOKC.
	CRS_ICR_SYNCOKC = 0x1
)

// Constants for DCMI: Digital camera interface
const (
	// CR: control register 1
	// Position of ENABLE field.
	DCMI_CR_ENABLE_Pos = 0xe
	// Bit mask of ENABLE field.
	DCMI_CR_ENABLE_Msk = 0x4000
	// Bit ENABLE.
	DCMI_CR_ENABLE = 0x4000
	// Position of EDM field.
	DCMI_CR_EDM_Pos = 0xa
	// Bit mask of EDM field.
	DCMI_CR_EDM_Msk = 0xc00
	// Position of FCRC field.
	DCMI_CR_FCRC_Pos = 0x8
	// Bit mask of FCRC field.
	DCMI_CR_FCRC_Msk = 0x300
	// Position of VSPOL field.
	DCMI_CR_VSPOL_Pos = 0x7
	// Bit mask of VSPOL field.
	DCMI_CR_VSPOL_Msk = 0x80
	// Bit VSPOL.
	DCMI_CR_VSPOL = 0x80
	// Position of HSPOL field.
	DCMI_CR_HSPOL_Pos = 0x6
	// Bit mask of HSPOL field.
	DCMI_CR_HSPOL_Msk = 0x40
	// Bit HSPOL.
	DCMI_CR_HSPOL = 0x40
	// Position of PCKPOL field.
	DCMI_CR_PCKPOL_Pos = 0x5
	// Bit mask of PCKPOL field.
	DCMI_CR_PCKPOL_Msk = 0x20
	// Bit PCKPOL.
	DCMI_CR_PCKPOL = 0x20
	// Position of ESS field.
	DCMI_CR_ESS_Pos = 0x4
	// Bit mask of ESS field.
	DCMI_CR_ESS_Msk = 0x10
	// Bit ESS.
	DCMI_CR_ESS = 0x10
	// Position of JPEG field.
	DCMI_CR_JPEG_Pos = 0x3
	// Bit mask of JPEG field.
	DCMI_CR_JPEG_Msk = 0x8
	// Bit JPEG.
	DCMI_CR_JPEG = 0x8
	// Position of CROP field.
	DCMI_CR_CROP_Pos = 0x2
	// Bit mask of CROP field.
	DCMI_CR_CROP_Msk = 0x4
	// Bit CROP.
	DCMI_CR_CROP = 0x4
	// Position of CM field.
	DCMI_CR_CM_Pos = 0x1
	// Bit mask of CM field.
	DCMI_CR_CM_Msk = 0x2
	// Bit CM.
	DCMI_CR_CM = 0x2
	// Position of CAPTURE field.
	DCMI_CR_CAPTURE_Pos = 0x0
	// Bit mask of CAPTURE field.
	DCMI_CR_CAPTURE_Msk = 0x1
	// Bit CAPTURE.
	DCMI_CR_CAPTURE = 0x1
	// Position of OELS field.
	DCMI_CR_OELS_Pos = 0x14
	// Bit mask of OELS field.
	DCMI_CR_OELS_Msk = 0x100000
	// Bit OELS.
	DCMI_CR_OELS = 0x100000
	// Position of LSM field.
	DCMI_CR_LSM_Pos = 0x13
	// Bit mask of LSM field.
	DCMI_CR_LSM_Msk = 0x80000
	// Bit LSM.
	DCMI_CR_LSM = 0x80000
	// Position of OEBS field.
	DCMI_CR_OEBS_Pos = 0x12
	// Bit mask of OEBS field.
	DCMI_CR_OEBS_Msk = 0x40000
	// Bit OEBS.
	DCMI_CR_OEBS = 0x40000
	// Position of BSM field.
	DCMI_CR_BSM_Pos = 0x10
	// Bit mask of BSM field.
	DCMI_CR_BSM_Msk = 0x30000

	// SR: status register
	// Position of FNE field.
	DCMI_SR_FNE_Pos = 0x2
	// Bit mask of FNE field.
	DCMI_SR_FNE_Msk = 0x4
	// Bit FNE.
	DCMI_SR_FNE = 0x4
	// Position of VSYNC field.
	DCMI_SR_VSYNC_Pos = 0x1
	// Bit mask of VSYNC field.
	DCMI_SR_VSYNC_Msk = 0x2
	// Bit VSYNC.
	DCMI_SR_VSYNC = 0x2
	// Position of HSYNC field.
	DCMI_SR_HSYNC_Pos = 0x0
	// Bit mask of HSYNC field.
	DCMI_SR_HSYNC_Msk = 0x1
	// Bit HSYNC.
	DCMI_SR_HSYNC = 0x1

	// RIS: raw interrupt status register
	// Position of LINE_RIS field.
	DCMI_RIS_LINE_RIS_Pos = 0x4
	// Bit mask of LINE_RIS field.
	DCMI_RIS_LINE_RIS_Msk = 0x10
	// Bit LINE_RIS.
	DCMI_RIS_LINE_RIS = 0x10
	// Position of VSYNC_RIS field.
	DCMI_RIS_VSYNC_RIS_Pos = 0x3
	// Bit mask of VSYNC_RIS field.
	DCMI_RIS_VSYNC_RIS_Msk = 0x8
	// Bit VSYNC_RIS.
	DCMI_RIS_VSYNC_RIS = 0x8
	// Position of ERR_RIS field.
	DCMI_RIS_ERR_RIS_Pos = 0x2
	// Bit mask of ERR_RIS field.
	DCMI_RIS_ERR_RIS_Msk = 0x4
	// Bit ERR_RIS.
	DCMI_RIS_ERR_RIS = 0x4
	// Position of OVR_RIS field.
	DCMI_RIS_OVR_RIS_Pos = 0x1
	// Bit mask of OVR_RIS field.
	DCMI_RIS_OVR_RIS_Msk = 0x2
	// Bit OVR_RIS.
	DCMI_RIS_OVR_RIS = 0x2
	// Position of FRAME_RIS field.
	DCMI_RIS_FRAME_RIS_Pos = 0x0
	// Bit mask of FRAME_RIS field.
	DCMI_RIS_FRAME_RIS_Msk = 0x1
	// Bit FRAME_RIS.
	DCMI_RIS_FRAME_RIS = 0x1

	// IER: interrupt enable register
	// Position of LINE_IE field.
	DCMI_IER_LINE_IE_Pos = 0x4
	// Bit mask of LINE_IE field.
	DCMI_IER_LINE_IE_Msk = 0x10
	// Bit LINE_IE.
	DCMI_IER_LINE_IE = 0x10
	// Position of VSYNC_IE field.
	DCMI_IER_VSYNC_IE_Pos = 0x3
	// Bit mask of VSYNC_IE field.
	DCMI_IER_VSYNC_IE_Msk = 0x8
	// Bit VSYNC_IE.
	DCMI_IER_VSYNC_IE = 0x8
	// Position of ERR_IE field.
	DCMI_IER_ERR_IE_Pos = 0x2
	// Bit mask of ERR_IE field.
	DCMI_IER_ERR_IE_Msk = 0x4
	// Bit ERR_IE.
	DCMI_IER_ERR_IE = 0x4
	// Position of OVR_IE field.
	DCMI_IER_OVR_IE_Pos = 0x1
	// Bit mask of OVR_IE field.
	DCMI_IER_OVR_IE_Msk = 0x2
	// Bit OVR_IE.
	DCMI_IER_OVR_IE = 0x2
	// Position of FRAME_IE field.
	DCMI_IER_FRAME_IE_Pos = 0x0
	// Bit mask of FRAME_IE field.
	DCMI_IER_FRAME_IE_Msk = 0x1
	// Bit FRAME_IE.
	DCMI_IER_FRAME_IE = 0x1

	// MIS: masked interrupt status register
	// Position of LINE_MIS field.
	DCMI_MIS_LINE_MIS_Pos = 0x4
	// Bit mask of LINE_MIS field.
	DCMI_MIS_LINE_MIS_Msk = 0x10
	// Bit LINE_MIS.
	DCMI_MIS_LINE_MIS = 0x10
	// Position of VSYNC_MIS field.
	DCMI_MIS_VSYNC_MIS_Pos = 0x3
	// Bit mask of VSYNC_MIS field.
	DCMI_MIS_VSYNC_MIS_Msk = 0x8
	// Bit VSYNC_MIS.
	DCMI_MIS_VSYNC_MIS = 0x8
	// Position of ERR_MIS field.
	DCMI_MIS_ERR_MIS_Pos = 0x2
	// Bit mask of ERR_MIS field.
	DCMI_MIS_ERR_MIS_Msk = 0x4
	// Bit ERR_MIS.
	DCMI_MIS_ERR_MIS = 0x4
	// Position of OVR_MIS field.
	DCMI_MIS_OVR_MIS_Pos = 0x1
	// Bit mask of OVR_MIS field.
	DCMI_MIS_OVR_MIS_Msk = 0x2
	// Bit OVR_MIS.
	DCMI_MIS_OVR_MIS = 0x2
	// Position of FRAME_MIS field.
	DCMI_MIS_FRAME_MIS_Pos = 0x0
	// Bit mask of FRAME_MIS field.
	DCMI_MIS_FRAME_MIS_Msk = 0x1
	// Bit FRAME_MIS.
	DCMI_MIS_FRAME_MIS = 0x1

	// ICR: interrupt clear register
	// Position of LINE_ISC field.
	DCMI_ICR_LINE_ISC_Pos = 0x4
	// Bit mask of LINE_ISC field.
	DCMI_ICR_LINE_ISC_Msk = 0x10
	// Bit LINE_ISC.
	DCMI_ICR_LINE_ISC = 0x10
	// Position of VSYNC_ISC field.
	DCMI_ICR_VSYNC_ISC_Pos = 0x3
	// Bit mask of VSYNC_ISC field.
	DCMI_ICR_VSYNC_ISC_Msk = 0x8
	// Bit VSYNC_ISC.
	DCMI_ICR_VSYNC_ISC = 0x8
	// Position of ERR_ISC field.
	DCMI_ICR_ERR_ISC_Pos = 0x2
	// Bit mask of ERR_ISC field.
	DCMI_ICR_ERR_ISC_Msk = 0x4
	// Bit ERR_ISC.
	DCMI_ICR_ERR_ISC = 0x4
	// Position of OVR_ISC field.
	DCMI_ICR_OVR_ISC_Pos = 0x1
	// Bit mask of OVR_ISC field.
	DCMI_ICR_OVR_ISC_Msk = 0x2
	// Bit OVR_ISC.
	DCMI_ICR_OVR_ISC = 0x2
	// Position of FRAME_ISC field.
	DCMI_ICR_FRAME_ISC_Pos = 0x0
	// Bit mask of FRAME_ISC field.
	DCMI_ICR_FRAME_ISC_Msk = 0x1
	// Bit FRAME_ISC.
	DCMI_ICR_FRAME_ISC = 0x1

	// ESCR: embedded synchronization code register
	// Position of FEC field.
	DCMI_ESCR_FEC_Pos = 0x18
	// Bit mask of FEC field.
	DCMI_ESCR_FEC_Msk = 0xff000000
	// Position of LEC field.
	DCMI_ESCR_LEC_Pos = 0x10
	// Bit mask of LEC field.
	DCMI_ESCR_LEC_Msk = 0xff0000
	// Position of LSC field.
	DCMI_ESCR_LSC_Pos = 0x8
	// Bit mask of LSC field.
	DCMI_ESCR_LSC_Msk = 0xff00
	// Position of FSC field.
	DCMI_ESCR_FSC_Pos = 0x0
	// Bit mask of FSC field.
	DCMI_ESCR_FSC_Msk = 0xff

	// ESUR: embedded synchronization unmask register
	// Position of FEU field.
	DCMI_ESUR_FEU_Pos = 0x18
	// Bit mask of FEU field.
	DCMI_ESUR_FEU_Msk = 0xff000000
	// Position of LEU field.
	DCMI_ESUR_LEU_Pos = 0x10
	// Bit mask of LEU field.
	DCMI_ESUR_LEU_Msk = 0xff0000
	// Position of LSU field.
	DCMI_ESUR_LSU_Pos = 0x8
	// Bit mask of LSU field.
	DCMI_ESUR_LSU_Msk = 0xff00
	// Position of FSU field.
	DCMI_ESUR_FSU_Pos = 0x0
	// Bit mask of FSU field.
	DCMI_ESUR_FSU_Msk = 0xff

	// CWSTRT: crop window start
	// Position of VST field.
	DCMI_CWSTRT_VST_Pos = 0x10
	// Bit mask of VST field.
	DCMI_CWSTRT_VST_Msk = 0x1fff0000
	// Position of HOFFCNT field.
	DCMI_CWSTRT_HOFFCNT_Pos = 0x0
	// Bit mask of HOFFCNT field.
	DCMI_CWSTRT_HOFFCNT_Msk = 0x3fff

	// CWSIZE: crop window size
	// Position of VLINE field.
	DCMI_CWSIZE_VLINE_Pos = 0x10
	// Bit mask of VLINE field.
	DCMI_CWSIZE_VLINE_Msk = 0x3fff0000
	// Position of CAPCNT field.
	DCMI_CWSIZE_CAPCNT_Pos = 0x0
	// Bit mask of CAPCNT field.
	DCMI_CWSIZE_CAPCNT_Msk = 0x3fff

	// DR: data register
	// Position of Byte3 field.
	DCMI_DR_Byte3_Pos = 0x18
	// Bit mask of Byte3 field.
	DCMI_DR_Byte3_Msk = 0xff000000
	// Position of Byte2 field.
	DCMI_DR_Byte2_Pos = 0x10
	// Bit mask of Byte2 field.
	DCMI_DR_Byte2_Msk = 0xff0000
	// Position of Byte1 field.
	DCMI_DR_Byte1_Pos = 0x8
	// Bit mask of Byte1 field.
	DCMI_DR_Byte1_Msk = 0xff00
	// Position of Byte0 field.
	DCMI_DR_Byte0_Pos = 0x0
	// Bit mask of Byte0 field.
	DCMI_DR_Byte0_Msk = 0xff
)

// Constants for HASH: Hash processor
const (
	// CR: control register
	// Position of INIT field.
	HASH_CR_INIT_Pos = 0x2
	// Bit mask of INIT field.
	HASH_CR_INIT_Msk = 0x4
	// Bit INIT.
	HASH_CR_INIT = 0x4
	// Position of DMAE field.
	HASH_CR_DMAE_Pos = 0x3
	// Bit mask of DMAE field.
	HASH_CR_DMAE_Msk = 0x8
	// Bit DMAE.
	HASH_CR_DMAE = 0x8
	// Position of DATATYPE field.
	HASH_CR_DATATYPE_Pos = 0x4
	// Bit mask of DATATYPE field.
	HASH_CR_DATATYPE_Msk = 0x30
	// Position of MODE field.
	HASH_CR_MODE_Pos = 0x6
	// Bit mask of MODE field.
	HASH_CR_MODE_Msk = 0x40
	// Bit MODE.
	HASH_CR_MODE = 0x40
	// Position of ALGO0 field.
	HASH_CR_ALGO0_Pos = 0x7
	// Bit mask of ALGO0 field.
	HASH_CR_ALGO0_Msk = 0x80
	// Bit ALGO0.
	HASH_CR_ALGO0 = 0x80
	// Position of NBW field.
	HASH_CR_NBW_Pos = 0x8
	// Bit mask of NBW field.
	HASH_CR_NBW_Msk = 0xf00
	// Position of DINNE field.
	HASH_CR_DINNE_Pos = 0xc
	// Bit mask of DINNE field.
	HASH_CR_DINNE_Msk = 0x1000
	// Bit DINNE.
	HASH_CR_DINNE = 0x1000
	// Position of MDMAT field.
	HASH_CR_MDMAT_Pos = 0xd
	// Bit mask of MDMAT field.
	HASH_CR_MDMAT_Msk = 0x2000
	// Bit MDMAT.
	HASH_CR_MDMAT = 0x2000
	// Position of LKEY field.
	HASH_CR_LKEY_Pos = 0x10
	// Bit mask of LKEY field.
	HASH_CR_LKEY_Msk = 0x10000
	// Bit LKEY.
	HASH_CR_LKEY = 0x10000
	// Position of ALGO1 field.
	HASH_CR_ALGO1_Pos = 0x12
	// Bit mask of ALGO1 field.
	HASH_CR_ALGO1_Msk = 0x40000
	// Bit ALGO1.
	HASH_CR_ALGO1 = 0x40000

	// DIN: data input register
	// Position of DATAIN field.
	HASH_DIN_DATAIN_Pos = 0x0
	// Bit mask of DATAIN field.
	HASH_DIN_DATAIN_Msk = 0xffffffff

	// STR: start register
	// Position of DCAL field.
	HASH_STR_DCAL_Pos = 0x8
	// Bit mask of DCAL field.
	HASH_STR_DCAL_Msk = 0x100
	// Bit DCAL.
	HASH_STR_DCAL = 0x100
	// Position of NBLW field.
	HASH_STR_NBLW_Pos = 0x0
	// Bit mask of NBLW field.
	HASH_STR_NBLW_Msk = 0x1f

	// HR0: digest registers
	// Position of H field.
	HASH_HR_H_Pos = 0x0
	// Bit mask of H field.
	HASH_HR_H_Msk = 0xffffffff

	// IMR: interrupt enable register
	// Position of DCIE field.
	HASH_IMR_DCIE_Pos = 0x1
	// Bit mask of DCIE field.
	HASH_IMR_DCIE_Msk = 0x2
	// Bit DCIE.
	HASH_IMR_DCIE = 0x2
	// Position of DINIE field.
	HASH_IMR_DINIE_Pos = 0x0
	// Bit mask of DINIE field.
	HASH_IMR_DINIE_Msk = 0x1
	// Bit DINIE.
	HASH_IMR_DINIE = 0x1

	// SR: status register
	// Position of BUSY field.
	HASH_SR_BUSY_Pos = 0x3
	// Bit mask of BUSY field.
	HASH_SR_BUSY_Msk = 0x8
	// Bit BUSY.
	HASH_SR_BUSY = 0x8
	// Position of DMAS field.
	HASH_SR_DMAS_Pos = 0x2
	// Bit mask of DMAS field.
	HASH_SR_DMAS_Msk = 0x4
	// Bit DMAS.
	HASH_SR_DMAS = 0x4
	// Position of DCIS field.
	HASH_SR_DCIS_Pos = 0x1
	// Bit mask of DCIS field.
	HASH_SR_DCIS_Msk = 0x2
	// Bit DCIS.
	HASH_SR_DCIS = 0x2
	// Position of DINIS field.
	HASH_SR_DINIS_Pos = 0x0
	// Bit mask of DINIS field.
	HASH_SR_DINIS_Msk = 0x1
	// Bit DINIS.
	HASH_SR_DINIS = 0x1

	// CSR0: context swap registers
	// Position of CSR field.
	HASH_CSR_CSR_Pos = 0x0
	// Bit mask of CSR field.
	HASH_CSR_CSR_Msk = 0xffffffff

	// HASH_HR0: HASH digest register
	// Position of H field.
	HASH_HASH_HR_H_Pos = 0x0
	// Bit mask of H field.
	HASH_HASH_HR_H_Msk = 0xffffffff
)

// Constants for DMA2D: DMA2D controller
const (
	// CR: control register
	// Position of MODE field.
	DMA2D_CR_MODE_Pos = 0x10
	// Bit mask of MODE field.
	DMA2D_CR_MODE_Msk = 0x30000
	// Memory-to-memory (FG fetch only)
	DMA2D_CR_MODE_MemoryToMemory = 0x0
	// Memory-to-memory with PFC (FG fetch only with FG PFC active)
	DMA2D_CR_MODE_MemoryToMemoryPFC = 0x1
	// Memory-to-memory with blending (FG and BG fetch with PFC and blending)
	DMA2D_CR_MODE_MemoryToMemoryPFCBlending = 0x2
	// Register-to-memory
	DMA2D_CR_MODE_RegisterToMemory = 0x3
	// Position of CEIE field.
	DMA2D_CR_CEIE_Pos = 0xd
	// Bit mask of CEIE field.
	DMA2D_CR_CEIE_Msk = 0x2000
	// Bit CEIE.
	DMA2D_CR_CEIE = 0x2000
	// CE interrupt disabled
	DMA2D_CR_CEIE_Disabled = 0x0
	// CE interrupt enabled
	DMA2D_CR_CEIE_Enabled = 0x1
	// Position of CTCIE field.
	DMA2D_CR_CTCIE_Pos = 0xc
	// Bit mask of CTCIE field.
	DMA2D_CR_CTCIE_Msk = 0x1000
	// Bit CTCIE.
	DMA2D_CR_CTCIE = 0x1000
	// CTC interrupt disabled
	DMA2D_CR_CTCIE_Disabled = 0x0
	// CTC interrupt enabled
	DMA2D_CR_CTCIE_Enabled = 0x1
	// Position of CAEIE field.
	DMA2D_CR_CAEIE_Pos = 0xb
	// Bit mask of CAEIE field.
	DMA2D_CR_CAEIE_Msk = 0x800
	// Bit CAEIE.
	DMA2D_CR_CAEIE = 0x800
	// CAE interrupt disabled
	DMA2D_CR_CAEIE_Disabled = 0x0
	// CAE interrupt enabled
	DMA2D_CR_CAEIE_Enabled = 0x1
	// Position of TWIE field.
	DMA2D_CR_TWIE_Pos = 0xa
	// Bit mask of TWIE field.
	DMA2D_CR_TWIE_Msk = 0x400
	// Bit TWIE.
	DMA2D_CR_TWIE = 0x400
	// TW interrupt disabled
	DMA2D_CR_TWIE_Disabled = 0x0
	// TW interrupt enabled
	DMA2D_CR_TWIE_Enabled = 0x1
	// Position of TCIE field.
	DMA2D_CR_TCIE_Pos = 0x9
	// Bit mask of TCIE field.
	DMA2D_CR_TCIE_Msk = 0x200
	// Bit TCIE.
	DMA2D_CR_TCIE = 0x200
	// TC interrupt disabled
	DMA2D_CR_TCIE_Disabled = 0x0
	// TC interrupt enabled
	DMA2D_CR_TCIE_Enabled = 0x1
	// Position of TEIE field.
	DMA2D_CR_TEIE_Pos = 0x8
	// Bit mask of TEIE field.
	DMA2D_CR_TEIE_Msk = 0x100
	// Bit TEIE.
	DMA2D_CR_TEIE = 0x100
	// TE interrupt disabled
	DMA2D_CR_TEIE_Disabled = 0x0
	// TE interrupt enabled
	DMA2D_CR_TEIE_Enabled = 0x1
	// Position of ABORT field.
	DMA2D_CR_ABORT_Pos = 0x2
	// Bit mask of ABORT field.
	DMA2D_CR_ABORT_Msk = 0x4
	// Bit ABORT.
	DMA2D_CR_ABORT = 0x4
	// Transfer abort requested
	DMA2D_CR_ABORT_AbortRequest = 0x1
	// Position of SUSP field.
	DMA2D_CR_SUSP_Pos = 0x1
	// Bit mask of SUSP field.
	DMA2D_CR_SUSP_Msk = 0x2
	// Bit SUSP.
	DMA2D_CR_SUSP = 0x2
	// Transfer not suspended
	DMA2D_CR_SUSP_NotSuspended = 0x0
	// Transfer suspended
	DMA2D_CR_SUSP_Suspended = 0x1
	// Position of START field.
	DMA2D_CR_START_Pos = 0x0
	// Bit mask of START field.
	DMA2D_CR_START_Msk = 0x1
	// Bit START.
	DMA2D_CR_START = 0x1
	// Launch the DMA2D
	DMA2D_CR_START_Start = 0x1

	// ISR: Interrupt Status Register
	// Position of CEIF field.
	DMA2D_ISR_CEIF_Pos = 0x5
	// Bit mask of CEIF field.
	DMA2D_ISR_CEIF_Msk = 0x20
	// Bit CEIF.
	DMA2D_ISR_CEIF = 0x20
	// Position of CTCIF field.
	DMA2D_ISR_CTCIF_Pos = 0x4
	// Bit mask of CTCIF field.
	DMA2D_ISR_CTCIF_Msk = 0x10
	// Bit CTCIF.
	DMA2D_ISR_CTCIF = 0x10
	// Position of CAEIF field.
	DMA2D_ISR_CAEIF_Pos = 0x3
	// Bit mask of CAEIF field.
	DMA2D_ISR_CAEIF_Msk = 0x8
	// Bit CAEIF.
	DMA2D_ISR_CAEIF = 0x8
	// Position of TWIF field.
	DMA2D_ISR_TWIF_Pos = 0x2
	// Bit mask of TWIF field.
	DMA2D_ISR_TWIF_Msk = 0x4
	// Bit TWIF.
	DMA2D_ISR_TWIF = 0x4
	// Position of TCIF field.
	DMA2D_ISR_TCIF_Pos = 0x1
	// Bit mask of TCIF field.
	DMA2D_ISR_TCIF_Msk = 0x2
	// Bit TCIF.
	DMA2D_ISR_TCIF = 0x2
	// Position of TEIF field.
	DMA2D_ISR_TEIF_Pos = 0x0
	// Bit mask of TEIF field.
	DMA2D_ISR_TEIF_Msk = 0x1
	// Bit TEIF.
	DMA2D_ISR_TEIF = 0x1

	// IFCR: interrupt flag clear register
	// Position of CCEIF field.
	DMA2D_IFCR_CCEIF_Pos = 0x5
	// Bit mask of CCEIF field.
	DMA2D_IFCR_CCEIF_Msk = 0x20
	// Bit CCEIF.
	DMA2D_IFCR_CCEIF = 0x20
	// Clear the CEIF flag in the ISR register
	DMA2D_IFCR_CCEIF_Clear = 0x1
	// Position of CCTCIF field.
	DMA2D_IFCR_CCTCIF_Pos = 0x4
	// Bit mask of CCTCIF field.
	DMA2D_IFCR_CCTCIF_Msk = 0x10
	// Bit CCTCIF.
	DMA2D_IFCR_CCTCIF = 0x10
	// Clear the CTCIF flag in the ISR register
	DMA2D_IFCR_CCTCIF_Clear = 0x1
	// Position of CAECIF field.
	DMA2D_IFCR_CAECIF_Pos = 0x3
	// Bit mask of CAECIF field.
	DMA2D_IFCR_CAECIF_Msk = 0x8
	// Bit CAECIF.
	DMA2D_IFCR_CAECIF = 0x8
	// Clear the CAEIF flag in the ISR register
	DMA2D_IFCR_CAECIF_Clear = 0x1
	// Position of CTWIF field.
	DMA2D_IFCR_CTWIF_Pos = 0x2
	// Bit mask of CTWIF field.
	DMA2D_IFCR_CTWIF_Msk = 0x4
	// Bit CTWIF.
	DMA2D_IFCR_CTWIF = 0x4
	// Clear the TWIF flag in the ISR register
	DMA2D_IFCR_CTWIF_Clear = 0x1
	// Position of CTCIF field.
	DMA2D_IFCR_CTCIF_Pos = 0x1
	// Bit mask of CTCIF field.
	DMA2D_IFCR_CTCIF_Msk = 0x2
	// Bit CTCIF.
	DMA2D_IFCR_CTCIF = 0x2
	// Clear the TCIF flag in the ISR register
	DMA2D_IFCR_CTCIF_Clear = 0x1
	// Position of CTEIF field.
	DMA2D_IFCR_CTEIF_Pos = 0x0
	// Bit mask of CTEIF field.
	DMA2D_IFCR_CTEIF_Msk = 0x1
	// Bit CTEIF.
	DMA2D_IFCR_CTEIF = 0x1
	// Clear the TEIF flag in the ISR register
	DMA2D_IFCR_CTEIF_Clear = 0x1

	// FGMAR: foreground memory address register
	// Position of MA field.
	DMA2D_FGMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_FGMAR_MA_Msk = 0xffffffff

	// FGOR: foreground offset register
	// Position of LO field.
	DMA2D_FGOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_FGOR_LO_Msk = 0x3fff

	// BGMAR: background memory address register
	// Position of MA field.
	DMA2D_BGMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_BGMAR_MA_Msk = 0xffffffff

	// BGOR: background offset register
	// Position of LO field.
	DMA2D_BGOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_BGOR_LO_Msk = 0x3fff

	// FGPFCCR: foreground PFC control register
	// Position of ALPHA field.
	DMA2D_FGPFCCR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_FGPFCCR_ALPHA_Msk = 0xff000000
	// Position of AM field.
	DMA2D_FGPFCCR_AM_Pos = 0x10
	// Bit mask of AM field.
	DMA2D_FGPFCCR_AM_Msk = 0x30000
	// No modification of alpha channel
	DMA2D_FGPFCCR_AM_NoModify = 0x0
	// Replace with value in ALPHA[7:0]
	DMA2D_FGPFCCR_AM_Replace = 0x1
	// Multiply with value in ALPHA[7:0]
	DMA2D_FGPFCCR_AM_Multiply = 0x2
	// Position of CS field.
	DMA2D_FGPFCCR_CS_Pos = 0x8
	// Bit mask of CS field.
	DMA2D_FGPFCCR_CS_Msk = 0xff00
	// Position of START field.
	DMA2D_FGPFCCR_START_Pos = 0x5
	// Bit mask of START field.
	DMA2D_FGPFCCR_START_Msk = 0x20
	// Bit START.
	DMA2D_FGPFCCR_START = 0x20
	// Start the automatic loading of the CLUT
	DMA2D_FGPFCCR_START_Start = 0x1
	// Position of CCM field.
	DMA2D_FGPFCCR_CCM_Pos = 0x4
	// Bit mask of CCM field.
	DMA2D_FGPFCCR_CCM_Msk = 0x10
	// Bit CCM.
	DMA2D_FGPFCCR_CCM = 0x10
	// CLUT color format ARGB8888
	DMA2D_FGPFCCR_CCM_ARGB8888 = 0x0
	// CLUT color format RGB888
	DMA2D_FGPFCCR_CCM_RGB888 = 0x1
	// Position of CM field.
	DMA2D_FGPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_FGPFCCR_CM_Msk = 0xf
	// Color mode ARGB8888
	DMA2D_FGPFCCR_CM_ARGB8888 = 0x0
	// Color mode RGB888
	DMA2D_FGPFCCR_CM_RGB888 = 0x1
	// Color mode RGB565
	DMA2D_FGPFCCR_CM_RGB565 = 0x2
	// Color mode ARGB1555
	DMA2D_FGPFCCR_CM_ARGB1555 = 0x3
	// Color mode ARGB4444
	DMA2D_FGPFCCR_CM_ARGB4444 = 0x4
	// Color mode L8
	DMA2D_FGPFCCR_CM_L8 = 0x5
	// Color mode AL44
	DMA2D_FGPFCCR_CM_AL44 = 0x6
	// Color mode AL88
	DMA2D_FGPFCCR_CM_AL88 = 0x7
	// Color mode L4
	DMA2D_FGPFCCR_CM_L4 = 0x8
	// Color mode A8
	DMA2D_FGPFCCR_CM_A8 = 0x9
	// Color mode A4
	DMA2D_FGPFCCR_CM_A4 = 0xa
	// Position of RBS field.
	DMA2D_FGPFCCR_RBS_Pos = 0x15
	// Bit mask of RBS field.
	DMA2D_FGPFCCR_RBS_Msk = 0x200000
	// Bit RBS.
	DMA2D_FGPFCCR_RBS = 0x200000
	// Position of AI field.
	DMA2D_FGPFCCR_AI_Pos = 0x14
	// Bit mask of AI field.
	DMA2D_FGPFCCR_AI_Msk = 0x100000
	// Bit AI.
	DMA2D_FGPFCCR_AI = 0x100000

	// FGCOLR: foreground color register
	// Position of RED field.
	DMA2D_FGCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_FGCOLR_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_FGCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_FGCOLR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_FGCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_FGCOLR_BLUE_Msk = 0xff

	// BGPFCCR: background PFC control register
	// Position of ALPHA field.
	DMA2D_BGPFCCR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_BGPFCCR_ALPHA_Msk = 0xff000000
	// Position of AM field.
	DMA2D_BGPFCCR_AM_Pos = 0x10
	// Bit mask of AM field.
	DMA2D_BGPFCCR_AM_Msk = 0x30000
	// No modification of alpha channel
	DMA2D_BGPFCCR_AM_NoModify = 0x0
	// Replace with value in ALPHA[7:0]
	DMA2D_BGPFCCR_AM_Replace = 0x1
	// Multiply with value in ALPHA[7:0]
	DMA2D_BGPFCCR_AM_Multiply = 0x2
	// Position of CS field.
	DMA2D_BGPFCCR_CS_Pos = 0x8
	// Bit mask of CS field.
	DMA2D_BGPFCCR_CS_Msk = 0xff00
	// Position of START field.
	DMA2D_BGPFCCR_START_Pos = 0x5
	// Bit mask of START field.
	DMA2D_BGPFCCR_START_Msk = 0x20
	// Bit START.
	DMA2D_BGPFCCR_START = 0x20
	// Start the automatic loading of the CLUT
	DMA2D_BGPFCCR_START_Start = 0x1
	// Position of CCM field.
	DMA2D_BGPFCCR_CCM_Pos = 0x4
	// Bit mask of CCM field.
	DMA2D_BGPFCCR_CCM_Msk = 0x10
	// Bit CCM.
	DMA2D_BGPFCCR_CCM = 0x10
	// CLUT color format ARGB8888
	DMA2D_BGPFCCR_CCM_ARGB8888 = 0x0
	// CLUT color format RGB888
	DMA2D_BGPFCCR_CCM_RGB888 = 0x1
	// Position of CM field.
	DMA2D_BGPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_BGPFCCR_CM_Msk = 0xf
	// Color mode ARGB8888
	DMA2D_BGPFCCR_CM_ARGB8888 = 0x0
	// Color mode RGB888
	DMA2D_BGPFCCR_CM_RGB888 = 0x1
	// Color mode RGB565
	DMA2D_BGPFCCR_CM_RGB565 = 0x2
	// Color mode ARGB1555
	DMA2D_BGPFCCR_CM_ARGB1555 = 0x3
	// Color mode ARGB4444
	DMA2D_BGPFCCR_CM_ARGB4444 = 0x4
	// Color mode L8
	DMA2D_BGPFCCR_CM_L8 = 0x5
	// Color mode AL44
	DMA2D_BGPFCCR_CM_AL44 = 0x6
	// Color mode AL88
	DMA2D_BGPFCCR_CM_AL88 = 0x7
	// Color mode L4
	DMA2D_BGPFCCR_CM_L4 = 0x8
	// Color mode A8
	DMA2D_BGPFCCR_CM_A8 = 0x9
	// Color mode A4
	DMA2D_BGPFCCR_CM_A4 = 0xa
	// Position of RBS field.
	DMA2D_BGPFCCR_RBS_Pos = 0x15
	// Bit mask of RBS field.
	DMA2D_BGPFCCR_RBS_Msk = 0x200000
	// Bit RBS.
	DMA2D_BGPFCCR_RBS = 0x200000
	// Position of AI field.
	DMA2D_BGPFCCR_AI_Pos = 0x14
	// Bit mask of AI field.
	DMA2D_BGPFCCR_AI_Msk = 0x100000
	// Bit AI.
	DMA2D_BGPFCCR_AI = 0x100000

	// BGCOLR: background color register
	// Position of RED field.
	DMA2D_BGCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_BGCOLR_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_BGCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_BGCOLR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_BGCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_BGCOLR_BLUE_Msk = 0xff

	// FGCMAR: foreground CLUT memory address register
	// Position of MA field.
	DMA2D_FGCMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_FGCMAR_MA_Msk = 0xffffffff

	// BGCMAR: background CLUT memory address register
	// Position of MA field.
	DMA2D_BGCMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_BGCMAR_MA_Msk = 0xffffffff

	// OPFCCR: output PFC control register
	// Position of CM field.
	DMA2D_OPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_OPFCCR_CM_Msk = 0x7
	// ARGB8888
	DMA2D_OPFCCR_CM_ARGB8888 = 0x0
	// RGB888
	DMA2D_OPFCCR_CM_RGB888 = 0x1
	// RGB565
	DMA2D_OPFCCR_CM_RGB565 = 0x2
	// ARGB1555
	DMA2D_OPFCCR_CM_ARGB1555 = 0x3
	// ARGB4444
	DMA2D_OPFCCR_CM_ARGB4444 = 0x4
	// Position of RBS field.
	DMA2D_OPFCCR_RBS_Pos = 0x15
	// Bit mask of RBS field.
	DMA2D_OPFCCR_RBS_Msk = 0x200000
	// Bit RBS.
	DMA2D_OPFCCR_RBS = 0x200000
	// Position of AI field.
	DMA2D_OPFCCR_AI_Pos = 0x14
	// Bit mask of AI field.
	DMA2D_OPFCCR_AI_Msk = 0x100000
	// Bit AI.
	DMA2D_OPFCCR_AI = 0x100000

	// OCOLR: output color register
	// Position of APLHA field.
	DMA2D_OCOLR_APLHA_Pos = 0x18
	// Bit mask of APLHA field.
	DMA2D_OCOLR_APLHA_Msk = 0xff000000
	// Position of RED field.
	DMA2D_OCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_OCOLR_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_OCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_OCOLR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_OCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_OCOLR_BLUE_Msk = 0xff

	// OMAR: output memory address register
	// Position of MA field.
	DMA2D_OMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_OMAR_MA_Msk = 0xffffffff

	// OOR: output offset register
	// Position of LO field.
	DMA2D_OOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_OOR_LO_Msk = 0x3fff

	// NLR: number of line register
	// Position of PL field.
	DMA2D_NLR_PL_Pos = 0x10
	// Bit mask of PL field.
	DMA2D_NLR_PL_Msk = 0x3fff0000
	// Position of NL field.
	DMA2D_NLR_NL_Pos = 0x0
	// Bit mask of NL field.
	DMA2D_NLR_NL_Msk = 0xffff

	// LWR: line watermark register
	// Position of LW field.
	DMA2D_LWR_LW_Pos = 0x0
	// Bit mask of LW field.
	DMA2D_LWR_LW_Msk = 0xffff

	// AMTCR: AHB master timer configuration register
	// Position of DT field.
	DMA2D_AMTCR_DT_Pos = 0x8
	// Bit mask of DT field.
	DMA2D_AMTCR_DT_Msk = 0xff00
	// Position of EN field.
	DMA2D_AMTCR_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA2D_AMTCR_EN_Msk = 0x1
	// Bit EN.
	DMA2D_AMTCR_EN = 0x1
	// Disabled AHB/AXI dead-time functionality
	DMA2D_AMTCR_EN_Disabled = 0x0
	// Enabled AHB/AXI dead-time functionality
	DMA2D_AMTCR_EN_Enabled = 0x1

	// FGCLUT: FGCLUT
	// Position of APLHA field.
	DMA2D_FGCLUT_APLHA_Pos = 0x18
	// Bit mask of APLHA field.
	DMA2D_FGCLUT_APLHA_Msk = 0xff000000
	// Position of RED field.
	DMA2D_FGCLUT_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_FGCLUT_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_FGCLUT_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_FGCLUT_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_FGCLUT_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_FGCLUT_BLUE_Msk = 0xff

	// BGCLUT: BGCLUT
	// Position of APLHA field.
	DMA2D_BGCLUT_APLHA_Pos = 0x18
	// Bit mask of APLHA field.
	DMA2D_BGCLUT_APLHA_Msk = 0xff000000
	// Position of RED field.
	DMA2D_BGCLUT_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_BGCLUT_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_BGCLUT_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_BGCLUT_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_BGCLUT_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_BGCLUT_BLUE_Msk = 0xff
)

// Constants for DSI: DSI Host
const (
	// VR: DSI Host Version Register
	// Position of VERSION field.
	DSI_VR_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	DSI_VR_VERSION_Msk = 0xffffffff

	// CR: DSI Host Control Register
	// Position of EN field.
	DSI_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	DSI_CR_EN_Msk = 0x1
	// Bit EN.
	DSI_CR_EN = 0x1

	// CCR: DSI HOST Clock Control Register
	// Position of TXECKDIV field.
	DSI_CCR_TXECKDIV_Pos = 0x0
	// Bit mask of TXECKDIV field.
	DSI_CCR_TXECKDIV_Msk = 0xff
	// Position of TOCKDIV field.
	DSI_CCR_TOCKDIV_Pos = 0x8
	// Bit mask of TOCKDIV field.
	DSI_CCR_TOCKDIV_Msk = 0xff00

	// LVCIDR: DSI Host LTDC VCID Register
	// Position of VCID field.
	DSI_LVCIDR_VCID_Pos = 0x0
	// Bit mask of VCID field.
	DSI_LVCIDR_VCID_Msk = 0x3

	// LCOLCR: DSI Host LTDC Color Coding Register
	// Position of COLC field.
	DSI_LCOLCR_COLC_Pos = 0x0
	// Bit mask of COLC field.
	DSI_LCOLCR_COLC_Msk = 0xf
	// Position of LPE field.
	DSI_LCOLCR_LPE_Pos = 0x8
	// Bit mask of LPE field.
	DSI_LCOLCR_LPE_Msk = 0x100
	// Bit LPE.
	DSI_LCOLCR_LPE = 0x100

	// LPCR: DSI Host LTDC Polarity Configuration Register
	// Position of DEP field.
	DSI_LPCR_DEP_Pos = 0x0
	// Bit mask of DEP field.
	DSI_LPCR_DEP_Msk = 0x1
	// Bit DEP.
	DSI_LPCR_DEP = 0x1
	// Position of VSP field.
	DSI_LPCR_VSP_Pos = 0x1
	// Bit mask of VSP field.
	DSI_LPCR_VSP_Msk = 0x2
	// Bit VSP.
	DSI_LPCR_VSP = 0x2
	// Position of HSP field.
	DSI_LPCR_HSP_Pos = 0x2
	// Bit mask of HSP field.
	DSI_LPCR_HSP_Msk = 0x4
	// Bit HSP.
	DSI_LPCR_HSP = 0x4

	// LPMCR: DSI Host Low-Power mode Configuration Register
	// Position of VLPSIZE field.
	DSI_LPMCR_VLPSIZE_Pos = 0x0
	// Bit mask of VLPSIZE field.
	DSI_LPMCR_VLPSIZE_Msk = 0xff
	// Position of LPSIZE field.
	DSI_LPMCR_LPSIZE_Pos = 0x10
	// Bit mask of LPSIZE field.
	DSI_LPMCR_LPSIZE_Msk = 0xff0000

	// PCR: DSI Host Protocol Configuration Register
	// Position of ETTXE field.
	DSI_PCR_ETTXE_Pos = 0x0
	// Bit mask of ETTXE field.
	DSI_PCR_ETTXE_Msk = 0x1
	// Bit ETTXE.
	DSI_PCR_ETTXE = 0x1
	// Position of ETRXE field.
	DSI_PCR_ETRXE_Pos = 0x1
	// Bit mask of ETRXE field.
	DSI_PCR_ETRXE_Msk = 0x2
	// Bit ETRXE.
	DSI_PCR_ETRXE = 0x2
	// Position of BTAE field.
	DSI_PCR_BTAE_Pos = 0x2
	// Bit mask of BTAE field.
	DSI_PCR_BTAE_Msk = 0x4
	// Bit BTAE.
	DSI_PCR_BTAE = 0x4
	// Position of ECCRXE field.
	DSI_PCR_ECCRXE_Pos = 0x3
	// Bit mask of ECCRXE field.
	DSI_PCR_ECCRXE_Msk = 0x8
	// Bit ECCRXE.
	DSI_PCR_ECCRXE = 0x8
	// Position of CRCRXE field.
	DSI_PCR_CRCRXE_Pos = 0x4
	// Bit mask of CRCRXE field.
	DSI_PCR_CRCRXE_Msk = 0x10
	// Bit CRCRXE.
	DSI_PCR_CRCRXE = 0x10

	// GVCIDR: DSI Host Generic VCID Register
	// Position of VCID field.
	DSI_GVCIDR_VCID_Pos = 0x0
	// Bit mask of VCID field.
	DSI_GVCIDR_VCID_Msk = 0x3

	// MCR: DSI Host mode Configuration Register
	// Position of CMDM field.
	DSI_MCR_CMDM_Pos = 0x0
	// Bit mask of CMDM field.
	DSI_MCR_CMDM_Msk = 0x1
	// Bit CMDM.
	DSI_MCR_CMDM = 0x1

	// VMCR: DSI Host Video mode Configuration Register
	// Position of VMT field.
	DSI_VMCR_VMT_Pos = 0x0
	// Bit mask of VMT field.
	DSI_VMCR_VMT_Msk = 0x3
	// Position of LPVSAE field.
	DSI_VMCR_LPVSAE_Pos = 0x8
	// Bit mask of LPVSAE field.
	DSI_VMCR_LPVSAE_Msk = 0x100
	// Bit LPVSAE.
	DSI_VMCR_LPVSAE = 0x100
	// Position of LPVBPE field.
	DSI_VMCR_LPVBPE_Pos = 0x9
	// Bit mask of LPVBPE field.
	DSI_VMCR_LPVBPE_Msk = 0x200
	// Bit LPVBPE.
	DSI_VMCR_LPVBPE = 0x200
	// Position of LPVFPE field.
	DSI_VMCR_LPVFPE_Pos = 0xa
	// Bit mask of LPVFPE field.
	DSI_VMCR_LPVFPE_Msk = 0x400
	// Bit LPVFPE.
	DSI_VMCR_LPVFPE = 0x400
	// Position of LPVAE field.
	DSI_VMCR_LPVAE_Pos = 0xb
	// Bit mask of LPVAE field.
	DSI_VMCR_LPVAE_Msk = 0x800
	// Bit LPVAE.
	DSI_VMCR_LPVAE = 0x800
	// Position of LPHBPE field.
	DSI_VMCR_LPHBPE_Pos = 0xc
	// Bit mask of LPHBPE field.
	DSI_VMCR_LPHBPE_Msk = 0x1000
	// Bit LPHBPE.
	DSI_VMCR_LPHBPE = 0x1000
	// Position of LPHFPE field.
	DSI_VMCR_LPHFPE_Pos = 0xd
	// Bit mask of LPHFPE field.
	DSI_VMCR_LPHFPE_Msk = 0x2000
	// Bit LPHFPE.
	DSI_VMCR_LPHFPE = 0x2000
	// Position of FBTAAE field.
	DSI_VMCR_FBTAAE_Pos = 0xe
	// Bit mask of FBTAAE field.
	DSI_VMCR_FBTAAE_Msk = 0x4000
	// Bit FBTAAE.
	DSI_VMCR_FBTAAE = 0x4000
	// Position of LPCE field.
	DSI_VMCR_LPCE_Pos = 0xf
	// Bit mask of LPCE field.
	DSI_VMCR_LPCE_Msk = 0x8000
	// Bit LPCE.
	DSI_VMCR_LPCE = 0x8000
	// Position of PGE field.
	DSI_VMCR_PGE_Pos = 0x10
	// Bit mask of PGE field.
	DSI_VMCR_PGE_Msk = 0x10000
	// Bit PGE.
	DSI_VMCR_PGE = 0x10000
	// Position of PGM field.
	DSI_VMCR_PGM_Pos = 0x14
	// Bit mask of PGM field.
	DSI_VMCR_PGM_Msk = 0x100000
	// Bit PGM.
	DSI_VMCR_PGM = 0x100000
	// Position of PGO field.
	DSI_VMCR_PGO_Pos = 0x18
	// Bit mask of PGO field.
	DSI_VMCR_PGO_Msk = 0x1000000
	// Bit PGO.
	DSI_VMCR_PGO = 0x1000000

	// VPCR: DSI Host Video Packet Configuration Register
	// Position of VPSIZE field.
	DSI_VPCR_VPSIZE_Pos = 0x0
	// Bit mask of VPSIZE field.
	DSI_VPCR_VPSIZE_Msk = 0x3fff

	// VCCR: DSI Host Video Chunks Configuration Register
	// Position of NUMC field.
	DSI_VCCR_NUMC_Pos = 0x0
	// Bit mask of NUMC field.
	DSI_VCCR_NUMC_Msk = 0x1fff

	// VNPCR: DSI Host Video Null Packet Configuration Register
	// Position of NPSIZE field.
	DSI_VNPCR_NPSIZE_Pos = 0x0
	// Bit mask of NPSIZE field.
	DSI_VNPCR_NPSIZE_Msk = 0x1fff

	// VHSACR: DSI Host Video HSA Configuration Register
	// Position of HSA field.
	DSI_VHSACR_HSA_Pos = 0x0
	// Bit mask of HSA field.
	DSI_VHSACR_HSA_Msk = 0xfff

	// VHBPCR: DSI Host Video HBP Configuration Register
	// Position of HBP field.
	DSI_VHBPCR_HBP_Pos = 0x0
	// Bit mask of HBP field.
	DSI_VHBPCR_HBP_Msk = 0xfff

	// VLCR: DSI Host Video Line Configuration Register
	// Position of HLINE field.
	DSI_VLCR_HLINE_Pos = 0x0
	// Bit mask of HLINE field.
	DSI_VLCR_HLINE_Msk = 0x7fff

	// VVSACR: DSI Host Video VSA Configuration Register
	// Position of VSA field.
	DSI_VVSACR_VSA_Pos = 0x0
	// Bit mask of VSA field.
	DSI_VVSACR_VSA_Msk = 0x3ff

	// VVBPCR: DSI Host Video VBP Configuration Register
	// Position of VBP field.
	DSI_VVBPCR_VBP_Pos = 0x0
	// Bit mask of VBP field.
	DSI_VVBPCR_VBP_Msk = 0x3ff

	// VVFPCR: DSI Host Video VFP Configuration Register
	// Position of VFP field.
	DSI_VVFPCR_VFP_Pos = 0x0
	// Bit mask of VFP field.
	DSI_VVFPCR_VFP_Msk = 0x3ff

	// VVACR: DSI Host Video VA Configuration Register
	// Position of VA field.
	DSI_VVACR_VA_Pos = 0x0
	// Bit mask of VA field.
	DSI_VVACR_VA_Msk = 0x3fff

	// LCCR: DSI Host LTDC Command Configuration Register
	// Position of CMDSIZE field.
	DSI_LCCR_CMDSIZE_Pos = 0x0
	// Bit mask of CMDSIZE field.
	DSI_LCCR_CMDSIZE_Msk = 0xffff

	// CMCR: DSI Host Command mode Configuration Register
	// Position of TEARE field.
	DSI_CMCR_TEARE_Pos = 0x0
	// Bit mask of TEARE field.
	DSI_CMCR_TEARE_Msk = 0x1
	// Bit TEARE.
	DSI_CMCR_TEARE = 0x1
	// Position of ARE field.
	DSI_CMCR_ARE_Pos = 0x1
	// Bit mask of ARE field.
	DSI_CMCR_ARE_Msk = 0x2
	// Bit ARE.
	DSI_CMCR_ARE = 0x2
	// Position of GSW0TX field.
	DSI_CMCR_GSW0TX_Pos = 0x8
	// Bit mask of GSW0TX field.
	DSI_CMCR_GSW0TX_Msk = 0x100
	// Bit GSW0TX.
	DSI_CMCR_GSW0TX = 0x100
	// Position of GSW1TX field.
	DSI_CMCR_GSW1TX_Pos = 0x9
	// Bit mask of GSW1TX field.
	DSI_CMCR_GSW1TX_Msk = 0x200
	// Bit GSW1TX.
	DSI_CMCR_GSW1TX = 0x200
	// Position of GSW2TX field.
	DSI_CMCR_GSW2TX_Pos = 0xa
	// Bit mask of GSW2TX field.
	DSI_CMCR_GSW2TX_Msk = 0x400
	// Bit GSW2TX.
	DSI_CMCR_GSW2TX = 0x400
	// Position of GSR0TX field.
	DSI_CMCR_GSR0TX_Pos = 0xb
	// Bit mask of GSR0TX field.
	DSI_CMCR_GSR0TX_Msk = 0x800
	// Bit GSR0TX.
	DSI_CMCR_GSR0TX = 0x800
	// Position of GSR1TX field.
	DSI_CMCR_GSR1TX_Pos = 0xc
	// Bit mask of GSR1TX field.
	DSI_CMCR_GSR1TX_Msk = 0x1000
	// Bit GSR1TX.
	DSI_CMCR_GSR1TX = 0x1000
	// Position of GSR2TX field.
	DSI_CMCR_GSR2TX_Pos = 0xd
	// Bit mask of GSR2TX field.
	DSI_CMCR_GSR2TX_Msk = 0x2000
	// Bit GSR2TX.
	DSI_CMCR_GSR2TX = 0x2000
	// Position of GLWTX field.
	DSI_CMCR_GLWTX_Pos = 0xe
	// Bit mask of GLWTX field.
	DSI_CMCR_GLWTX_Msk = 0x4000
	// Bit GLWTX.
	DSI_CMCR_GLWTX = 0x4000
	// Position of DSW0TX field.
	DSI_CMCR_DSW0TX_Pos = 0x10
	// Bit mask of DSW0TX field.
	DSI_CMCR_DSW0TX_Msk = 0x10000
	// Bit DSW0TX.
	DSI_CMCR_DSW0TX = 0x10000
	// Position of DSW1TX field.
	DSI_CMCR_DSW1TX_Pos = 0x11
	// Bit mask of DSW1TX field.
	DSI_CMCR_DSW1TX_Msk = 0x20000
	// Bit DSW1TX.
	DSI_CMCR_DSW1TX = 0x20000
	// Position of DSR0TX field.
	DSI_CMCR_DSR0TX_Pos = 0x12
	// Bit mask of DSR0TX field.
	DSI_CMCR_DSR0TX_Msk = 0x40000
	// Bit DSR0TX.
	DSI_CMCR_DSR0TX = 0x40000
	// Position of DLWTX field.
	DSI_CMCR_DLWTX_Pos = 0x13
	// Bit mask of DLWTX field.
	DSI_CMCR_DLWTX_Msk = 0x80000
	// Bit DLWTX.
	DSI_CMCR_DLWTX = 0x80000
	// Position of MRDPS field.
	DSI_CMCR_MRDPS_Pos = 0x18
	// Bit mask of MRDPS field.
	DSI_CMCR_MRDPS_Msk = 0x1000000
	// Bit MRDPS.
	DSI_CMCR_MRDPS = 0x1000000

	// GHCR: DSI Host Generic Header Configuration Register
	// Position of DT field.
	DSI_GHCR_DT_Pos = 0x0
	// Bit mask of DT field.
	DSI_GHCR_DT_Msk = 0x3f
	// Position of VCID field.
	DSI_GHCR_VCID_Pos = 0x6
	// Bit mask of VCID field.
	DSI_GHCR_VCID_Msk = 0xc0
	// Position of WCLSB field.
	DSI_GHCR_WCLSB_Pos = 0x8
	// Bit mask of WCLSB field.
	DSI_GHCR_WCLSB_Msk = 0xff00
	// Position of WCMSB field.
	DSI_GHCR_WCMSB_Pos = 0x10
	// Bit mask of WCMSB field.
	DSI_GHCR_WCMSB_Msk = 0xff0000

	// GPDR: DSI Host Generic Payload Data Register
	// Position of DATA1 field.
	DSI_GPDR_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	DSI_GPDR_DATA1_Msk = 0xff
	// Position of DATA2 field.
	DSI_GPDR_DATA2_Pos = 0x8
	// Bit mask of DATA2 field.
	DSI_GPDR_DATA2_Msk = 0xff00
	// Position of DATA3 field.
	DSI_GPDR_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	DSI_GPDR_DATA3_Msk = 0xff0000
	// Position of DATA4 field.
	DSI_GPDR_DATA4_Pos = 0x18
	// Bit mask of DATA4 field.
	DSI_GPDR_DATA4_Msk = 0xff000000

	// GPSR: DSI Host Generic Packet Status Register
	// Position of CMDFE field.
	DSI_GPSR_CMDFE_Pos = 0x0
	// Bit mask of CMDFE field.
	DSI_GPSR_CMDFE_Msk = 0x1
	// Bit CMDFE.
	DSI_GPSR_CMDFE = 0x1
	// Position of CMDFF field.
	DSI_GPSR_CMDFF_Pos = 0x1
	// Bit mask of CMDFF field.
	DSI_GPSR_CMDFF_Msk = 0x2
	// Bit CMDFF.
	DSI_GPSR_CMDFF = 0x2
	// Position of PWRFE field.
	DSI_GPSR_PWRFE_Pos = 0x2
	// Bit mask of PWRFE field.
	DSI_GPSR_PWRFE_Msk = 0x4
	// Bit PWRFE.
	DSI_GPSR_PWRFE = 0x4
	// Position of PWRFF field.
	DSI_GPSR_PWRFF_Pos = 0x3
	// Bit mask of PWRFF field.
	DSI_GPSR_PWRFF_Msk = 0x8
	// Bit PWRFF.
	DSI_GPSR_PWRFF = 0x8
	// Position of PRDFE field.
	DSI_GPSR_PRDFE_Pos = 0x4
	// Bit mask of PRDFE field.
	DSI_GPSR_PRDFE_Msk = 0x10
	// Bit PRDFE.
	DSI_GPSR_PRDFE = 0x10
	// Position of PRDFF field.
	DSI_GPSR_PRDFF_Pos = 0x5
	// Bit mask of PRDFF field.
	DSI_GPSR_PRDFF_Msk = 0x20
	// Bit PRDFF.
	DSI_GPSR_PRDFF = 0x20
	// Position of RCB field.
	DSI_GPSR_RCB_Pos = 0x6
	// Bit mask of RCB field.
	DSI_GPSR_RCB_Msk = 0x40
	// Bit RCB.
	DSI_GPSR_RCB = 0x40

	// TCCR0: DSI Host Timeout Counter Configuration Register 0
	// Position of LPRX_TOCNT field.
	DSI_TCCR0_LPRX_TOCNT_Pos = 0x0
	// Bit mask of LPRX_TOCNT field.
	DSI_TCCR0_LPRX_TOCNT_Msk = 0xffff
	// Position of HSTX_TOCNT field.
	DSI_TCCR0_HSTX_TOCNT_Pos = 0x10
	// Bit mask of HSTX_TOCNT field.
	DSI_TCCR0_HSTX_TOCNT_Msk = 0xffff0000

	// TCCR1: DSI Host Timeout Counter Configuration Register 1
	// Position of HSRD_TOCNT field.
	DSI_TCCR1_HSRD_TOCNT_Pos = 0x0
	// Bit mask of HSRD_TOCNT field.
	DSI_TCCR1_HSRD_TOCNT_Msk = 0xffff

	// TCCR2: DSI Host Timeout Counter Configuration Register 2
	// Position of LPRD_TOCNT field.
	DSI_TCCR2_LPRD_TOCNT_Pos = 0x0
	// Bit mask of LPRD_TOCNT field.
	DSI_TCCR2_LPRD_TOCNT_Msk = 0xffff

	// TCCR3: DSI Host Timeout Counter Configuration Register 3
	// Position of HSWR_TOCNT field.
	DSI_TCCR3_HSWR_TOCNT_Pos = 0x0
	// Bit mask of HSWR_TOCNT field.
	DSI_TCCR3_HSWR_TOCNT_Msk = 0xffff
	// Position of PM field.
	DSI_TCCR3_PM_Pos = 0x18
	// Bit mask of PM field.
	DSI_TCCR3_PM_Msk = 0x1000000
	// Bit PM.
	DSI_TCCR3_PM = 0x1000000

	// TCCR4: DSI Host Timeout Counter Configuration Register 4
	// Position of LSWR_TOCNT field.
	DSI_TCCR4_LSWR_TOCNT_Pos = 0x0
	// Bit mask of LSWR_TOCNT field.
	DSI_TCCR4_LSWR_TOCNT_Msk = 0xffff

	// TCCR5: DSI Host Timeout Counter Configuration Register 5
	// Position of BTA_TOCNT field.
	DSI_TCCR5_BTA_TOCNT_Pos = 0x0
	// Bit mask of BTA_TOCNT field.
	DSI_TCCR5_BTA_TOCNT_Msk = 0xffff

	// CLCR: DSI Host Clock Lane Configuration Register
	// Position of DPCC field.
	DSI_CLCR_DPCC_Pos = 0x0
	// Bit mask of DPCC field.
	DSI_CLCR_DPCC_Msk = 0x1
	// Bit DPCC.
	DSI_CLCR_DPCC = 0x1
	// Position of ACR field.
	DSI_CLCR_ACR_Pos = 0x1
	// Bit mask of ACR field.
	DSI_CLCR_ACR_Msk = 0x2
	// Bit ACR.
	DSI_CLCR_ACR = 0x2

	// CLTCR: DSI Host Clock Lane Timer Configuration Register
	// Position of LP2HS_TIME field.
	DSI_CLTCR_LP2HS_TIME_Pos = 0x0
	// Bit mask of LP2HS_TIME field.
	DSI_CLTCR_LP2HS_TIME_Msk = 0x3ff
	// Position of HS2LP_TIME field.
	DSI_CLTCR_HS2LP_TIME_Pos = 0x10
	// Bit mask of HS2LP_TIME field.
	DSI_CLTCR_HS2LP_TIME_Msk = 0x3ff0000

	// DLTRC: DSI Host Data Lane Timer Configuration Register
	// Position of MRD_TIME field.
	DSI_DLTRC_MRD_TIME_Pos = 0x0
	// Bit mask of MRD_TIME field.
	DSI_DLTRC_MRD_TIME_Msk = 0x7fff
	// Position of LP2HS_TIME field.
	DSI_DLTRC_LP2HS_TIME_Pos = 0x10
	// Bit mask of LP2HS_TIME field.
	DSI_DLTRC_LP2HS_TIME_Msk = 0xff0000
	// Position of HS2LP_TIME field.
	DSI_DLTRC_HS2LP_TIME_Pos = 0x18
	// Bit mask of HS2LP_TIME field.
	DSI_DLTRC_HS2LP_TIME_Msk = 0xff000000

	// PCTLR: DSI Host PHY Control Register
	// Position of DEN field.
	DSI_PCTLR_DEN_Pos = 0x1
	// Bit mask of DEN field.
	DSI_PCTLR_DEN_Msk = 0x2
	// Bit DEN.
	DSI_PCTLR_DEN = 0x2
	// Position of CKE field.
	DSI_PCTLR_CKE_Pos = 0x2
	// Bit mask of CKE field.
	DSI_PCTLR_CKE_Msk = 0x4
	// Bit CKE.
	DSI_PCTLR_CKE = 0x4

	// PCONFR: DSI Host PHY Configuration Register
	// Position of NL field.
	DSI_PCONFR_NL_Pos = 0x0
	// Bit mask of NL field.
	DSI_PCONFR_NL_Msk = 0x3
	// Position of SW_TIME field.
	DSI_PCONFR_SW_TIME_Pos = 0x8
	// Bit mask of SW_TIME field.
	DSI_PCONFR_SW_TIME_Msk = 0xff00

	// PUCR: DSI Host PHY ULPS Control Register
	// Position of URCL field.
	DSI_PUCR_URCL_Pos = 0x0
	// Bit mask of URCL field.
	DSI_PUCR_URCL_Msk = 0x1
	// Bit URCL.
	DSI_PUCR_URCL = 0x1
	// Position of UECL field.
	DSI_PUCR_UECL_Pos = 0x1
	// Bit mask of UECL field.
	DSI_PUCR_UECL_Msk = 0x2
	// Bit UECL.
	DSI_PUCR_UECL = 0x2
	// Position of URDL field.
	DSI_PUCR_URDL_Pos = 0x2
	// Bit mask of URDL field.
	DSI_PUCR_URDL_Msk = 0x4
	// Bit URDL.
	DSI_PUCR_URDL = 0x4
	// Position of UEDL field.
	DSI_PUCR_UEDL_Pos = 0x3
	// Bit mask of UEDL field.
	DSI_PUCR_UEDL_Msk = 0x8
	// Bit UEDL.
	DSI_PUCR_UEDL = 0x8

	// PTTCR: DSI Host PHY TX Triggers Configuration Register
	// Position of TX_TRIG field.
	DSI_PTTCR_TX_TRIG_Pos = 0x0
	// Bit mask of TX_TRIG field.
	DSI_PTTCR_TX_TRIG_Msk = 0xf

	// PSR: DSI Host PHY Status Register
	// Position of PD field.
	DSI_PSR_PD_Pos = 0x1
	// Bit mask of PD field.
	DSI_PSR_PD_Msk = 0x2
	// Bit PD.
	DSI_PSR_PD = 0x2
	// Position of PSSC field.
	DSI_PSR_PSSC_Pos = 0x2
	// Bit mask of PSSC field.
	DSI_PSR_PSSC_Msk = 0x4
	// Bit PSSC.
	DSI_PSR_PSSC = 0x4
	// Position of UANC field.
	DSI_PSR_UANC_Pos = 0x3
	// Bit mask of UANC field.
	DSI_PSR_UANC_Msk = 0x8
	// Bit UANC.
	DSI_PSR_UANC = 0x8
	// Position of PSS0 field.
	DSI_PSR_PSS0_Pos = 0x4
	// Bit mask of PSS0 field.
	DSI_PSR_PSS0_Msk = 0x10
	// Bit PSS0.
	DSI_PSR_PSS0 = 0x10
	// Position of UAN0 field.
	DSI_PSR_UAN0_Pos = 0x5
	// Bit mask of UAN0 field.
	DSI_PSR_UAN0_Msk = 0x20
	// Bit UAN0.
	DSI_PSR_UAN0 = 0x20
	// Position of RUE0 field.
	DSI_PSR_RUE0_Pos = 0x6
	// Bit mask of RUE0 field.
	DSI_PSR_RUE0_Msk = 0x40
	// Bit RUE0.
	DSI_PSR_RUE0 = 0x40
	// Position of PSS1 field.
	DSI_PSR_PSS1_Pos = 0x7
	// Bit mask of PSS1 field.
	DSI_PSR_PSS1_Msk = 0x80
	// Bit PSS1.
	DSI_PSR_PSS1 = 0x80
	// Position of UAN1 field.
	DSI_PSR_UAN1_Pos = 0x8
	// Bit mask of UAN1 field.
	DSI_PSR_UAN1_Msk = 0x100
	// Bit UAN1.
	DSI_PSR_UAN1 = 0x100

	// ISR0: DSI Host Interrupt & Status Register 0
	// Position of AE0 field.
	DSI_ISR0_AE0_Pos = 0x0
	// Bit mask of AE0 field.
	DSI_ISR0_AE0_Msk = 0x1
	// Bit AE0.
	DSI_ISR0_AE0 = 0x1
	// Position of AE1 field.
	DSI_ISR0_AE1_Pos = 0x1
	// Bit mask of AE1 field.
	DSI_ISR0_AE1_Msk = 0x2
	// Bit AE1.
	DSI_ISR0_AE1 = 0x2
	// Position of AE2 field.
	DSI_ISR0_AE2_Pos = 0x2
	// Bit mask of AE2 field.
	DSI_ISR0_AE2_Msk = 0x4
	// Bit AE2.
	DSI_ISR0_AE2 = 0x4
	// Position of AE3 field.
	DSI_ISR0_AE3_Pos = 0x3
	// Bit mask of AE3 field.
	DSI_ISR0_AE3_Msk = 0x8
	// Bit AE3.
	DSI_ISR0_AE3 = 0x8
	// Position of AE4 field.
	DSI_ISR0_AE4_Pos = 0x4
	// Bit mask of AE4 field.
	DSI_ISR0_AE4_Msk = 0x10
	// Bit AE4.
	DSI_ISR0_AE4 = 0x10
	// Position of AE5 field.
	DSI_ISR0_AE5_Pos = 0x5
	// Bit mask of AE5 field.
	DSI_ISR0_AE5_Msk = 0x20
	// Bit AE5.
	DSI_ISR0_AE5 = 0x20
	// Position of AE6 field.
	DSI_ISR0_AE6_Pos = 0x6
	// Bit mask of AE6 field.
	DSI_ISR0_AE6_Msk = 0x40
	// Bit AE6.
	DSI_ISR0_AE6 = 0x40
	// Position of AE7 field.
	DSI_ISR0_AE7_Pos = 0x7
	// Bit mask of AE7 field.
	DSI_ISR0_AE7_Msk = 0x80
	// Bit AE7.
	DSI_ISR0_AE7 = 0x80
	// Position of AE8 field.
	DSI_ISR0_AE8_Pos = 0x8
	// Bit mask of AE8 field.
	DSI_ISR0_AE8_Msk = 0x100
	// Bit AE8.
	DSI_ISR0_AE8 = 0x100
	// Position of AE9 field.
	DSI_ISR0_AE9_Pos = 0x9
	// Bit mask of AE9 field.
	DSI_ISR0_AE9_Msk = 0x200
	// Bit AE9.
	DSI_ISR0_AE9 = 0x200
	// Position of AE10 field.
	DSI_ISR0_AE10_Pos = 0xa
	// Bit mask of AE10 field.
	DSI_ISR0_AE10_Msk = 0x400
	// Bit AE10.
	DSI_ISR0_AE10 = 0x400
	// Position of AE11 field.
	DSI_ISR0_AE11_Pos = 0xb
	// Bit mask of AE11 field.
	DSI_ISR0_AE11_Msk = 0x800
	// Bit AE11.
	DSI_ISR0_AE11 = 0x800
	// Position of AE12 field.
	DSI_ISR0_AE12_Pos = 0xc
	// Bit mask of AE12 field.
	DSI_ISR0_AE12_Msk = 0x1000
	// Bit AE12.
	DSI_ISR0_AE12 = 0x1000
	// Position of AE13 field.
	DSI_ISR0_AE13_Pos = 0xd
	// Bit mask of AE13 field.
	DSI_ISR0_AE13_Msk = 0x2000
	// Bit AE13.
	DSI_ISR0_AE13 = 0x2000
	// Position of AE14 field.
	DSI_ISR0_AE14_Pos = 0xe
	// Bit mask of AE14 field.
	DSI_ISR0_AE14_Msk = 0x4000
	// Bit AE14.
	DSI_ISR0_AE14 = 0x4000
	// Position of AE15 field.
	DSI_ISR0_AE15_Pos = 0xf
	// Bit mask of AE15 field.
	DSI_ISR0_AE15_Msk = 0x8000
	// Bit AE15.
	DSI_ISR0_AE15 = 0x8000
	// Position of PE0 field.
	DSI_ISR0_PE0_Pos = 0x10
	// Bit mask of PE0 field.
	DSI_ISR0_PE0_Msk = 0x10000
	// Bit PE0.
	DSI_ISR0_PE0 = 0x10000
	// Position of PE1 field.
	DSI_ISR0_PE1_Pos = 0x11
	// Bit mask of PE1 field.
	DSI_ISR0_PE1_Msk = 0x20000
	// Bit PE1.
	DSI_ISR0_PE1 = 0x20000
	// Position of PE2 field.
	DSI_ISR0_PE2_Pos = 0x12
	// Bit mask of PE2 field.
	DSI_ISR0_PE2_Msk = 0x40000
	// Bit PE2.
	DSI_ISR0_PE2 = 0x40000
	// Position of PE3 field.
	DSI_ISR0_PE3_Pos = 0x13
	// Bit mask of PE3 field.
	DSI_ISR0_PE3_Msk = 0x80000
	// Bit PE3.
	DSI_ISR0_PE3 = 0x80000
	// Position of PE4 field.
	DSI_ISR0_PE4_Pos = 0x14
	// Bit mask of PE4 field.
	DSI_ISR0_PE4_Msk = 0x100000
	// Bit PE4.
	DSI_ISR0_PE4 = 0x100000

	// ISR1: DSI Host Interrupt & Status Register 1
	// Position of TOHSTX field.
	DSI_ISR1_TOHSTX_Pos = 0x0
	// Bit mask of TOHSTX field.
	DSI_ISR1_TOHSTX_Msk = 0x1
	// Bit TOHSTX.
	DSI_ISR1_TOHSTX = 0x1
	// Position of TOLPRX field.
	DSI_ISR1_TOLPRX_Pos = 0x1
	// Bit mask of TOLPRX field.
	DSI_ISR1_TOLPRX_Msk = 0x2
	// Bit TOLPRX.
	DSI_ISR1_TOLPRX = 0x2
	// Position of ECCSE field.
	DSI_ISR1_ECCSE_Pos = 0x2
	// Bit mask of ECCSE field.
	DSI_ISR1_ECCSE_Msk = 0x4
	// Bit ECCSE.
	DSI_ISR1_ECCSE = 0x4
	// Position of ECCME field.
	DSI_ISR1_ECCME_Pos = 0x3
	// Bit mask of ECCME field.
	DSI_ISR1_ECCME_Msk = 0x8
	// Bit ECCME.
	DSI_ISR1_ECCME = 0x8
	// Position of CRCE field.
	DSI_ISR1_CRCE_Pos = 0x4
	// Bit mask of CRCE field.
	DSI_ISR1_CRCE_Msk = 0x10
	// Bit CRCE.
	DSI_ISR1_CRCE = 0x10
	// Position of PSE field.
	DSI_ISR1_PSE_Pos = 0x5
	// Bit mask of PSE field.
	DSI_ISR1_PSE_Msk = 0x20
	// Bit PSE.
	DSI_ISR1_PSE = 0x20
	// Position of EOTPE field.
	DSI_ISR1_EOTPE_Pos = 0x6
	// Bit mask of EOTPE field.
	DSI_ISR1_EOTPE_Msk = 0x40
	// Bit EOTPE.
	DSI_ISR1_EOTPE = 0x40
	// Position of LPWRE field.
	DSI_ISR1_LPWRE_Pos = 0x7
	// Bit mask of LPWRE field.
	DSI_ISR1_LPWRE_Msk = 0x80
	// Bit LPWRE.
	DSI_ISR1_LPWRE = 0x80
	// Position of GCWRE field.
	DSI_ISR1_GCWRE_Pos = 0x8
	// Bit mask of GCWRE field.
	DSI_ISR1_GCWRE_Msk = 0x100
	// Bit GCWRE.
	DSI_ISR1_GCWRE = 0x100
	// Position of GPWRE field.
	DSI_ISR1_GPWRE_Pos = 0x9
	// Bit mask of GPWRE field.
	DSI_ISR1_GPWRE_Msk = 0x200
	// Bit GPWRE.
	DSI_ISR1_GPWRE = 0x200
	// Position of GPTXE field.
	DSI_ISR1_GPTXE_Pos = 0xa
	// Bit mask of GPTXE field.
	DSI_ISR1_GPTXE_Msk = 0x400
	// Bit GPTXE.
	DSI_ISR1_GPTXE = 0x400
	// Position of GPRDE field.
	DSI_ISR1_GPRDE_Pos = 0xb
	// Bit mask of GPRDE field.
	DSI_ISR1_GPRDE_Msk = 0x800
	// Bit GPRDE.
	DSI_ISR1_GPRDE = 0x800
	// Position of GPRXE field.
	DSI_ISR1_GPRXE_Pos = 0xc
	// Bit mask of GPRXE field.
	DSI_ISR1_GPRXE_Msk = 0x1000
	// Bit GPRXE.
	DSI_ISR1_GPRXE = 0x1000

	// IER0: DSI Host Interrupt Enable Register 0
	// Position of AE0IE field.
	DSI_IER0_AE0IE_Pos = 0x0
	// Bit mask of AE0IE field.
	DSI_IER0_AE0IE_Msk = 0x1
	// Bit AE0IE.
	DSI_IER0_AE0IE = 0x1
	// Position of AE1IE field.
	DSI_IER0_AE1IE_Pos = 0x1
	// Bit mask of AE1IE field.
	DSI_IER0_AE1IE_Msk = 0x2
	// Bit AE1IE.
	DSI_IER0_AE1IE = 0x2
	// Position of AE2IE field.
	DSI_IER0_AE2IE_Pos = 0x2
	// Bit mask of AE2IE field.
	DSI_IER0_AE2IE_Msk = 0x4
	// Bit AE2IE.
	DSI_IER0_AE2IE = 0x4
	// Position of AE3IE field.
	DSI_IER0_AE3IE_Pos = 0x3
	// Bit mask of AE3IE field.
	DSI_IER0_AE3IE_Msk = 0x8
	// Bit AE3IE.
	DSI_IER0_AE3IE = 0x8
	// Position of AE4IE field.
	DSI_IER0_AE4IE_Pos = 0x4
	// Bit mask of AE4IE field.
	DSI_IER0_AE4IE_Msk = 0x10
	// Bit AE4IE.
	DSI_IER0_AE4IE = 0x10
	// Position of AE5IE field.
	DSI_IER0_AE5IE_Pos = 0x5
	// Bit mask of AE5IE field.
	DSI_IER0_AE5IE_Msk = 0x20
	// Bit AE5IE.
	DSI_IER0_AE5IE = 0x20
	// Position of AE6IE field.
	DSI_IER0_AE6IE_Pos = 0x6
	// Bit mask of AE6IE field.
	DSI_IER0_AE6IE_Msk = 0x40
	// Bit AE6IE.
	DSI_IER0_AE6IE = 0x40
	// Position of AE7IE field.
	DSI_IER0_AE7IE_Pos = 0x7
	// Bit mask of AE7IE field.
	DSI_IER0_AE7IE_Msk = 0x80
	// Bit AE7IE.
	DSI_IER0_AE7IE = 0x80
	// Position of AE8IE field.
	DSI_IER0_AE8IE_Pos = 0x8
	// Bit mask of AE8IE field.
	DSI_IER0_AE8IE_Msk = 0x100
	// Bit AE8IE.
	DSI_IER0_AE8IE = 0x100
	// Position of AE9IE field.
	DSI_IER0_AE9IE_Pos = 0x9
	// Bit mask of AE9IE field.
	DSI_IER0_AE9IE_Msk = 0x200
	// Bit AE9IE.
	DSI_IER0_AE9IE = 0x200
	// Position of AE10IE field.
	DSI_IER0_AE10IE_Pos = 0xa
	// Bit mask of AE10IE field.
	DSI_IER0_AE10IE_Msk = 0x400
	// Bit AE10IE.
	DSI_IER0_AE10IE = 0x400
	// Position of AE11IE field.
	DSI_IER0_AE11IE_Pos = 0xb
	// Bit mask of AE11IE field.
	DSI_IER0_AE11IE_Msk = 0x800
	// Bit AE11IE.
	DSI_IER0_AE11IE = 0x800
	// Position of AE12IE field.
	DSI_IER0_AE12IE_Pos = 0xc
	// Bit mask of AE12IE field.
	DSI_IER0_AE12IE_Msk = 0x1000
	// Bit AE12IE.
	DSI_IER0_AE12IE = 0x1000
	// Position of AE13IE field.
	DSI_IER0_AE13IE_Pos = 0xd
	// Bit mask of AE13IE field.
	DSI_IER0_AE13IE_Msk = 0x2000
	// Bit AE13IE.
	DSI_IER0_AE13IE = 0x2000
	// Position of AE14IE field.
	DSI_IER0_AE14IE_Pos = 0xe
	// Bit mask of AE14IE field.
	DSI_IER0_AE14IE_Msk = 0x4000
	// Bit AE14IE.
	DSI_IER0_AE14IE = 0x4000
	// Position of AE15IE field.
	DSI_IER0_AE15IE_Pos = 0xf
	// Bit mask of AE15IE field.
	DSI_IER0_AE15IE_Msk = 0x8000
	// Bit AE15IE.
	DSI_IER0_AE15IE = 0x8000
	// Position of PE0IE field.
	DSI_IER0_PE0IE_Pos = 0x10
	// Bit mask of PE0IE field.
	DSI_IER0_PE0IE_Msk = 0x10000
	// Bit PE0IE.
	DSI_IER0_PE0IE = 0x10000
	// Position of PE1IE field.
	DSI_IER0_PE1IE_Pos = 0x11
	// Bit mask of PE1IE field.
	DSI_IER0_PE1IE_Msk = 0x20000
	// Bit PE1IE.
	DSI_IER0_PE1IE = 0x20000
	// Position of PE2IE field.
	DSI_IER0_PE2IE_Pos = 0x12
	// Bit mask of PE2IE field.
	DSI_IER0_PE2IE_Msk = 0x40000
	// Bit PE2IE.
	DSI_IER0_PE2IE = 0x40000
	// Position of PE3IE field.
	DSI_IER0_PE3IE_Pos = 0x13
	// Bit mask of PE3IE field.
	DSI_IER0_PE3IE_Msk = 0x80000
	// Bit PE3IE.
	DSI_IER0_PE3IE = 0x80000
	// Position of PE4IE field.
	DSI_IER0_PE4IE_Pos = 0x14
	// Bit mask of PE4IE field.
	DSI_IER0_PE4IE_Msk = 0x100000
	// Bit PE4IE.
	DSI_IER0_PE4IE = 0x100000

	// IER1: DSI Host Interrupt Enable Register 1
	// Position of TOHSTXIE field.
	DSI_IER1_TOHSTXIE_Pos = 0x0
	// Bit mask of TOHSTXIE field.
	DSI_IER1_TOHSTXIE_Msk = 0x1
	// Bit TOHSTXIE.
	DSI_IER1_TOHSTXIE = 0x1
	// Position of TOLPRXIE field.
	DSI_IER1_TOLPRXIE_Pos = 0x1
	// Bit mask of TOLPRXIE field.
	DSI_IER1_TOLPRXIE_Msk = 0x2
	// Bit TOLPRXIE.
	DSI_IER1_TOLPRXIE = 0x2
	// Position of ECCSEIE field.
	DSI_IER1_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	DSI_IER1_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	DSI_IER1_ECCSEIE = 0x4
	// Position of ECCMEIE field.
	DSI_IER1_ECCMEIE_Pos = 0x3
	// Bit mask of ECCMEIE field.
	DSI_IER1_ECCMEIE_Msk = 0x8
	// Bit ECCMEIE.
	DSI_IER1_ECCMEIE = 0x8
	// Position of CRCEIE field.
	DSI_IER1_CRCEIE_Pos = 0x4
	// Bit mask of CRCEIE field.
	DSI_IER1_CRCEIE_Msk = 0x10
	// Bit CRCEIE.
	DSI_IER1_CRCEIE = 0x10
	// Position of PSEIE field.
	DSI_IER1_PSEIE_Pos = 0x5
	// Bit mask of PSEIE field.
	DSI_IER1_PSEIE_Msk = 0x20
	// Bit PSEIE.
	DSI_IER1_PSEIE = 0x20
	// Position of EOTPEIE field.
	DSI_IER1_EOTPEIE_Pos = 0x6
	// Bit mask of EOTPEIE field.
	DSI_IER1_EOTPEIE_Msk = 0x40
	// Bit EOTPEIE.
	DSI_IER1_EOTPEIE = 0x40
	// Position of LPWREIE field.
	DSI_IER1_LPWREIE_Pos = 0x7
	// Bit mask of LPWREIE field.
	DSI_IER1_LPWREIE_Msk = 0x80
	// Bit LPWREIE.
	DSI_IER1_LPWREIE = 0x80
	// Position of GCWREIE field.
	DSI_IER1_GCWREIE_Pos = 0x8
	// Bit mask of GCWREIE field.
	DSI_IER1_GCWREIE_Msk = 0x100
	// Bit GCWREIE.
	DSI_IER1_GCWREIE = 0x100
	// Position of GPWREIE field.
	DSI_IER1_GPWREIE_Pos = 0x9
	// Bit mask of GPWREIE field.
	DSI_IER1_GPWREIE_Msk = 0x200
	// Bit GPWREIE.
	DSI_IER1_GPWREIE = 0x200
	// Position of GPTXEIE field.
	DSI_IER1_GPTXEIE_Pos = 0xa
	// Bit mask of GPTXEIE field.
	DSI_IER1_GPTXEIE_Msk = 0x400
	// Bit GPTXEIE.
	DSI_IER1_GPTXEIE = 0x400
	// Position of GPRDEIE field.
	DSI_IER1_GPRDEIE_Pos = 0xb
	// Bit mask of GPRDEIE field.
	DSI_IER1_GPRDEIE_Msk = 0x800
	// Bit GPRDEIE.
	DSI_IER1_GPRDEIE = 0x800
	// Position of GPRXEIE field.
	DSI_IER1_GPRXEIE_Pos = 0xc
	// Bit mask of GPRXEIE field.
	DSI_IER1_GPRXEIE_Msk = 0x1000
	// Bit GPRXEIE.
	DSI_IER1_GPRXEIE = 0x1000

	// FIR0: DSI Host Force Interrupt Register 0
	// Position of FAE0 field.
	DSI_FIR0_FAE0_Pos = 0x0
	// Bit mask of FAE0 field.
	DSI_FIR0_FAE0_Msk = 0x1
	// Bit FAE0.
	DSI_FIR0_FAE0 = 0x1
	// Position of FAE1 field.
	DSI_FIR0_FAE1_Pos = 0x1
	// Bit mask of FAE1 field.
	DSI_FIR0_FAE1_Msk = 0x2
	// Bit FAE1.
	DSI_FIR0_FAE1 = 0x2
	// Position of FAE2 field.
	DSI_FIR0_FAE2_Pos = 0x2
	// Bit mask of FAE2 field.
	DSI_FIR0_FAE2_Msk = 0x4
	// Bit FAE2.
	DSI_FIR0_FAE2 = 0x4
	// Position of FAE3 field.
	DSI_FIR0_FAE3_Pos = 0x3
	// Bit mask of FAE3 field.
	DSI_FIR0_FAE3_Msk = 0x8
	// Bit FAE3.
	DSI_FIR0_FAE3 = 0x8
	// Position of FAE4 field.
	DSI_FIR0_FAE4_Pos = 0x4
	// Bit mask of FAE4 field.
	DSI_FIR0_FAE4_Msk = 0x10
	// Bit FAE4.
	DSI_FIR0_FAE4 = 0x10
	// Position of FAE5 field.
	DSI_FIR0_FAE5_Pos = 0x5
	// Bit mask of FAE5 field.
	DSI_FIR0_FAE5_Msk = 0x20
	// Bit FAE5.
	DSI_FIR0_FAE5 = 0x20
	// Position of FAE6 field.
	DSI_FIR0_FAE6_Pos = 0x6
	// Bit mask of FAE6 field.
	DSI_FIR0_FAE6_Msk = 0x40
	// Bit FAE6.
	DSI_FIR0_FAE6 = 0x40
	// Position of FAE7 field.
	DSI_FIR0_FAE7_Pos = 0x7
	// Bit mask of FAE7 field.
	DSI_FIR0_FAE7_Msk = 0x80
	// Bit FAE7.
	DSI_FIR0_FAE7 = 0x80
	// Position of FAE8 field.
	DSI_FIR0_FAE8_Pos = 0x8
	// Bit mask of FAE8 field.
	DSI_FIR0_FAE8_Msk = 0x100
	// Bit FAE8.
	DSI_FIR0_FAE8 = 0x100
	// Position of FAE9 field.
	DSI_FIR0_FAE9_Pos = 0x9
	// Bit mask of FAE9 field.
	DSI_FIR0_FAE9_Msk = 0x200
	// Bit FAE9.
	DSI_FIR0_FAE9 = 0x200
	// Position of FAE10 field.
	DSI_FIR0_FAE10_Pos = 0xa
	// Bit mask of FAE10 field.
	DSI_FIR0_FAE10_Msk = 0x400
	// Bit FAE10.
	DSI_FIR0_FAE10 = 0x400
	// Position of FAE11 field.
	DSI_FIR0_FAE11_Pos = 0xb
	// Bit mask of FAE11 field.
	DSI_FIR0_FAE11_Msk = 0x800
	// Bit FAE11.
	DSI_FIR0_FAE11 = 0x800
	// Position of FAE12 field.
	DSI_FIR0_FAE12_Pos = 0xc
	// Bit mask of FAE12 field.
	DSI_FIR0_FAE12_Msk = 0x1000
	// Bit FAE12.
	DSI_FIR0_FAE12 = 0x1000
	// Position of FAE13 field.
	DSI_FIR0_FAE13_Pos = 0xd
	// Bit mask of FAE13 field.
	DSI_FIR0_FAE13_Msk = 0x2000
	// Bit FAE13.
	DSI_FIR0_FAE13 = 0x2000
	// Position of FAE14 field.
	DSI_FIR0_FAE14_Pos = 0xe
	// Bit mask of FAE14 field.
	DSI_FIR0_FAE14_Msk = 0x4000
	// Bit FAE14.
	DSI_FIR0_FAE14 = 0x4000
	// Position of FAE15 field.
	DSI_FIR0_FAE15_Pos = 0xf
	// Bit mask of FAE15 field.
	DSI_FIR0_FAE15_Msk = 0x8000
	// Bit FAE15.
	DSI_FIR0_FAE15 = 0x8000
	// Position of FPE0 field.
	DSI_FIR0_FPE0_Pos = 0x10
	// Bit mask of FPE0 field.
	DSI_FIR0_FPE0_Msk = 0x10000
	// Bit FPE0.
	DSI_FIR0_FPE0 = 0x10000
	// Position of FPE1 field.
	DSI_FIR0_FPE1_Pos = 0x11
	// Bit mask of FPE1 field.
	DSI_FIR0_FPE1_Msk = 0x20000
	// Bit FPE1.
	DSI_FIR0_FPE1 = 0x20000
	// Position of FPE2 field.
	DSI_FIR0_FPE2_Pos = 0x12
	// Bit mask of FPE2 field.
	DSI_FIR0_FPE2_Msk = 0x40000
	// Bit FPE2.
	DSI_FIR0_FPE2 = 0x40000
	// Position of FPE3 field.
	DSI_FIR0_FPE3_Pos = 0x13
	// Bit mask of FPE3 field.
	DSI_FIR0_FPE3_Msk = 0x80000
	// Bit FPE3.
	DSI_FIR0_FPE3 = 0x80000
	// Position of FPE4 field.
	DSI_FIR0_FPE4_Pos = 0x14
	// Bit mask of FPE4 field.
	DSI_FIR0_FPE4_Msk = 0x100000
	// Bit FPE4.
	DSI_FIR0_FPE4 = 0x100000

	// FIR1: DSI Host Force Interrupt Register 1
	// Position of FTOHSTX field.
	DSI_FIR1_FTOHSTX_Pos = 0x0
	// Bit mask of FTOHSTX field.
	DSI_FIR1_FTOHSTX_Msk = 0x1
	// Bit FTOHSTX.
	DSI_FIR1_FTOHSTX = 0x1
	// Position of FTOLPRX field.
	DSI_FIR1_FTOLPRX_Pos = 0x1
	// Bit mask of FTOLPRX field.
	DSI_FIR1_FTOLPRX_Msk = 0x2
	// Bit FTOLPRX.
	DSI_FIR1_FTOLPRX = 0x2
	// Position of FECCSE field.
	DSI_FIR1_FECCSE_Pos = 0x2
	// Bit mask of FECCSE field.
	DSI_FIR1_FECCSE_Msk = 0x4
	// Bit FECCSE.
	DSI_FIR1_FECCSE = 0x4
	// Position of FECCME field.
	DSI_FIR1_FECCME_Pos = 0x3
	// Bit mask of FECCME field.
	DSI_FIR1_FECCME_Msk = 0x8
	// Bit FECCME.
	DSI_FIR1_FECCME = 0x8
	// Position of FCRCE field.
	DSI_FIR1_FCRCE_Pos = 0x4
	// Bit mask of FCRCE field.
	DSI_FIR1_FCRCE_Msk = 0x10
	// Bit FCRCE.
	DSI_FIR1_FCRCE = 0x10
	// Position of FPSE field.
	DSI_FIR1_FPSE_Pos = 0x5
	// Bit mask of FPSE field.
	DSI_FIR1_FPSE_Msk = 0x20
	// Bit FPSE.
	DSI_FIR1_FPSE = 0x20
	// Position of FEOTPE field.
	DSI_FIR1_FEOTPE_Pos = 0x6
	// Bit mask of FEOTPE field.
	DSI_FIR1_FEOTPE_Msk = 0x40
	// Bit FEOTPE.
	DSI_FIR1_FEOTPE = 0x40
	// Position of FLPWRE field.
	DSI_FIR1_FLPWRE_Pos = 0x7
	// Bit mask of FLPWRE field.
	DSI_FIR1_FLPWRE_Msk = 0x80
	// Bit FLPWRE.
	DSI_FIR1_FLPWRE = 0x80
	// Position of FGCWRE field.
	DSI_FIR1_FGCWRE_Pos = 0x8
	// Bit mask of FGCWRE field.
	DSI_FIR1_FGCWRE_Msk = 0x100
	// Bit FGCWRE.
	DSI_FIR1_FGCWRE = 0x100
	// Position of FGPWRE field.
	DSI_FIR1_FGPWRE_Pos = 0x9
	// Bit mask of FGPWRE field.
	DSI_FIR1_FGPWRE_Msk = 0x200
	// Bit FGPWRE.
	DSI_FIR1_FGPWRE = 0x200
	// Position of FGPTXE field.
	DSI_FIR1_FGPTXE_Pos = 0xa
	// Bit mask of FGPTXE field.
	DSI_FIR1_FGPTXE_Msk = 0x400
	// Bit FGPTXE.
	DSI_FIR1_FGPTXE = 0x400
	// Position of FGPRDE field.
	DSI_FIR1_FGPRDE_Pos = 0xb
	// Bit mask of FGPRDE field.
	DSI_FIR1_FGPRDE_Msk = 0x800
	// Bit FGPRDE.
	DSI_FIR1_FGPRDE = 0x800
	// Position of FGPRXE field.
	DSI_FIR1_FGPRXE_Pos = 0xc
	// Bit mask of FGPRXE field.
	DSI_FIR1_FGPRXE_Msk = 0x1000
	// Bit FGPRXE.
	DSI_FIR1_FGPRXE = 0x1000

	// VSCR: DSI Host Video Shadow Control Register
	// Position of EN field.
	DSI_VSCR_EN_Pos = 0x0
	// Bit mask of EN field.
	DSI_VSCR_EN_Msk = 0x1
	// Bit EN.
	DSI_VSCR_EN = 0x1
	// Position of UR field.
	DSI_VSCR_UR_Pos = 0x8
	// Bit mask of UR field.
	DSI_VSCR_UR_Msk = 0x100
	// Bit UR.
	DSI_VSCR_UR = 0x100

	// LCVCIDR: DSI Host LTDC Current VCID Register
	// Position of VCID field.
	DSI_LCVCIDR_VCID_Pos = 0x0
	// Bit mask of VCID field.
	DSI_LCVCIDR_VCID_Msk = 0x3

	// LCCCR: DSI Host LTDC Current Color Coding Register
	// Position of COLC field.
	DSI_LCCCR_COLC_Pos = 0x0
	// Bit mask of COLC field.
	DSI_LCCCR_COLC_Msk = 0xf
	// Position of LPE field.
	DSI_LCCCR_LPE_Pos = 0x8
	// Bit mask of LPE field.
	DSI_LCCCR_LPE_Msk = 0x100
	// Bit LPE.
	DSI_LCCCR_LPE = 0x100

	// LPMCCR: DSI Host Low-Power mode Current Configuration Register
	// Position of VLPSIZE field.
	DSI_LPMCCR_VLPSIZE_Pos = 0x0
	// Bit mask of VLPSIZE field.
	DSI_LPMCCR_VLPSIZE_Msk = 0xff
	// Position of LPSIZE field.
	DSI_LPMCCR_LPSIZE_Pos = 0x10
	// Bit mask of LPSIZE field.
	DSI_LPMCCR_LPSIZE_Msk = 0xff0000

	// VMCCR: DSI Host Video mode Current Configuration Register
	// Position of VMT field.
	DSI_VMCCR_VMT_Pos = 0x0
	// Bit mask of VMT field.
	DSI_VMCCR_VMT_Msk = 0x3
	// Position of LPVSAE field.
	DSI_VMCCR_LPVSAE_Pos = 0x2
	// Bit mask of LPVSAE field.
	DSI_VMCCR_LPVSAE_Msk = 0x4
	// Bit LPVSAE.
	DSI_VMCCR_LPVSAE = 0x4
	// Position of LPVBPE field.
	DSI_VMCCR_LPVBPE_Pos = 0x3
	// Bit mask of LPVBPE field.
	DSI_VMCCR_LPVBPE_Msk = 0x8
	// Bit LPVBPE.
	DSI_VMCCR_LPVBPE = 0x8
	// Position of LPVFPE field.
	DSI_VMCCR_LPVFPE_Pos = 0x4
	// Bit mask of LPVFPE field.
	DSI_VMCCR_LPVFPE_Msk = 0x10
	// Bit LPVFPE.
	DSI_VMCCR_LPVFPE = 0x10
	// Position of LPVAE field.
	DSI_VMCCR_LPVAE_Pos = 0x5
	// Bit mask of LPVAE field.
	DSI_VMCCR_LPVAE_Msk = 0x20
	// Bit LPVAE.
	DSI_VMCCR_LPVAE = 0x20
	// Position of LPHBPE field.
	DSI_VMCCR_LPHBPE_Pos = 0x6
	// Bit mask of LPHBPE field.
	DSI_VMCCR_LPHBPE_Msk = 0x40
	// Bit LPHBPE.
	DSI_VMCCR_LPHBPE = 0x40
	// Position of LPHFE field.
	DSI_VMCCR_LPHFE_Pos = 0x7
	// Bit mask of LPHFE field.
	DSI_VMCCR_LPHFE_Msk = 0x80
	// Bit LPHFE.
	DSI_VMCCR_LPHFE = 0x80
	// Position of FBTAAE field.
	DSI_VMCCR_FBTAAE_Pos = 0x8
	// Bit mask of FBTAAE field.
	DSI_VMCCR_FBTAAE_Msk = 0x100
	// Bit FBTAAE.
	DSI_VMCCR_FBTAAE = 0x100
	// Position of LPCE field.
	DSI_VMCCR_LPCE_Pos = 0x9
	// Bit mask of LPCE field.
	DSI_VMCCR_LPCE_Msk = 0x200
	// Bit LPCE.
	DSI_VMCCR_LPCE = 0x200

	// VPCCR: DSI Host Video Packet Current Configuration Register
	// Position of VPSIZE field.
	DSI_VPCCR_VPSIZE_Pos = 0x0
	// Bit mask of VPSIZE field.
	DSI_VPCCR_VPSIZE_Msk = 0x3fff

	// VCCCR: DSI Host Video Chunks Current Configuration Register
	// Position of NUMC field.
	DSI_VCCCR_NUMC_Pos = 0x0
	// Bit mask of NUMC field.
	DSI_VCCCR_NUMC_Msk = 0x1fff

	// VNPCCR: DSI Host Video Null Packet Current Configuration Register
	// Position of NPSIZE field.
	DSI_VNPCCR_NPSIZE_Pos = 0x0
	// Bit mask of NPSIZE field.
	DSI_VNPCCR_NPSIZE_Msk = 0x1fff

	// VHSACCR: DSI Host Video HSA Current Configuration Register
	// Position of HSA field.
	DSI_VHSACCR_HSA_Pos = 0x0
	// Bit mask of HSA field.
	DSI_VHSACCR_HSA_Msk = 0xfff

	// VHBPCCR: DSI Host Video HBP Current Configuration Register
	// Position of HBP field.
	DSI_VHBPCCR_HBP_Pos = 0x0
	// Bit mask of HBP field.
	DSI_VHBPCCR_HBP_Msk = 0xfff

	// VLCCR: DSI Host Video Line Current Configuration Register
	// Position of HLINE field.
	DSI_VLCCR_HLINE_Pos = 0x0
	// Bit mask of HLINE field.
	DSI_VLCCR_HLINE_Msk = 0x7fff

	// VVSACCR: DSI Host Video VSA Current Configuration Register
	// Position of VSA field.
	DSI_VVSACCR_VSA_Pos = 0x0
	// Bit mask of VSA field.
	DSI_VVSACCR_VSA_Msk = 0x3ff

	// VVBPCCR: DSI Host Video VBP Current Configuration Register
	// Position of VBP field.
	DSI_VVBPCCR_VBP_Pos = 0x0
	// Bit mask of VBP field.
	DSI_VVBPCCR_VBP_Msk = 0x3ff

	// VVFPCCR: DSI Host Video VFP Current Configuration Register
	// Position of VFP field.
	DSI_VVFPCCR_VFP_Pos = 0x0
	// Bit mask of VFP field.
	DSI_VVFPCCR_VFP_Msk = 0x3ff

	// VVACCR: DSI Host Video VA Current Configuration Register
	// Position of VA field.
	DSI_VVACCR_VA_Pos = 0x0
	// Bit mask of VA field.
	DSI_VVACCR_VA_Msk = 0x3fff

	// WCFGR: DSI Wrapper Configuration Register
	// Position of VSPOL field.
	DSI_WCFGR_VSPOL_Pos = 0x7
	// Bit mask of VSPOL field.
	DSI_WCFGR_VSPOL_Msk = 0x80
	// Bit VSPOL.
	DSI_WCFGR_VSPOL = 0x80
	// Position of AR field.
	DSI_WCFGR_AR_Pos = 0x6
	// Bit mask of AR field.
	DSI_WCFGR_AR_Msk = 0x40
	// Bit AR.
	DSI_WCFGR_AR = 0x40
	// Position of TEPOL field.
	DSI_WCFGR_TEPOL_Pos = 0x5
	// Bit mask of TEPOL field.
	DSI_WCFGR_TEPOL_Msk = 0x20
	// Bit TEPOL.
	DSI_WCFGR_TEPOL = 0x20
	// Position of TESRC field.
	DSI_WCFGR_TESRC_Pos = 0x4
	// Bit mask of TESRC field.
	DSI_WCFGR_TESRC_Msk = 0x10
	// Bit TESRC.
	DSI_WCFGR_TESRC = 0x10
	// Position of COLMUX field.
	DSI_WCFGR_COLMUX_Pos = 0x1
	// Bit mask of COLMUX field.
	DSI_WCFGR_COLMUX_Msk = 0xe
	// Position of DSIM field.
	DSI_WCFGR_DSIM_Pos = 0x0
	// Bit mask of DSIM field.
	DSI_WCFGR_DSIM_Msk = 0x1
	// Bit DSIM.
	DSI_WCFGR_DSIM = 0x1

	// WCR: DSI Wrapper Control Register
	// Position of DSIEN field.
	DSI_WCR_DSIEN_Pos = 0x3
	// Bit mask of DSIEN field.
	DSI_WCR_DSIEN_Msk = 0x8
	// Bit DSIEN.
	DSI_WCR_DSIEN = 0x8
	// Position of LTDCEN field.
	DSI_WCR_LTDCEN_Pos = 0x2
	// Bit mask of LTDCEN field.
	DSI_WCR_LTDCEN_Msk = 0x4
	// Bit LTDCEN.
	DSI_WCR_LTDCEN = 0x4
	// Position of SHTDN field.
	DSI_WCR_SHTDN_Pos = 0x1
	// Bit mask of SHTDN field.
	DSI_WCR_SHTDN_Msk = 0x2
	// Bit SHTDN.
	DSI_WCR_SHTDN = 0x2
	// Position of COLM field.
	DSI_WCR_COLM_Pos = 0x0
	// Bit mask of COLM field.
	DSI_WCR_COLM_Msk = 0x1
	// Bit COLM.
	DSI_WCR_COLM = 0x1

	// WIER: DSI Wrapper Interrupt Enable Register
	// Position of RRIE field.
	DSI_WIER_RRIE_Pos = 0xd
	// Bit mask of RRIE field.
	DSI_WIER_RRIE_Msk = 0x2000
	// Bit RRIE.
	DSI_WIER_RRIE = 0x2000
	// Position of PLLUIE field.
	DSI_WIER_PLLUIE_Pos = 0xa
	// Bit mask of PLLUIE field.
	DSI_WIER_PLLUIE_Msk = 0x400
	// Bit PLLUIE.
	DSI_WIER_PLLUIE = 0x400
	// Position of PLLLIE field.
	DSI_WIER_PLLLIE_Pos = 0x9
	// Bit mask of PLLLIE field.
	DSI_WIER_PLLLIE_Msk = 0x200
	// Bit PLLLIE.
	DSI_WIER_PLLLIE = 0x200
	// Position of ERIE field.
	DSI_WIER_ERIE_Pos = 0x1
	// Bit mask of ERIE field.
	DSI_WIER_ERIE_Msk = 0x2
	// Bit ERIE.
	DSI_WIER_ERIE = 0x2
	// Position of TEIE field.
	DSI_WIER_TEIE_Pos = 0x0
	// Bit mask of TEIE field.
	DSI_WIER_TEIE_Msk = 0x1
	// Bit TEIE.
	DSI_WIER_TEIE = 0x1

	// WISR: DSI Wrapper Interrupt & Status Register
	// Position of RRIF field.
	DSI_WISR_RRIF_Pos = 0xd
	// Bit mask of RRIF field.
	DSI_WISR_RRIF_Msk = 0x2000
	// Bit RRIF.
	DSI_WISR_RRIF = 0x2000
	// Position of RRS field.
	DSI_WISR_RRS_Pos = 0xc
	// Bit mask of RRS field.
	DSI_WISR_RRS_Msk = 0x1000
	// Bit RRS.
	DSI_WISR_RRS = 0x1000
	// Position of PLLUIF field.
	DSI_WISR_PLLUIF_Pos = 0xa
	// Bit mask of PLLUIF field.
	DSI_WISR_PLLUIF_Msk = 0x400
	// Bit PLLUIF.
	DSI_WISR_PLLUIF = 0x400
	// Position of PLLLIF field.
	DSI_WISR_PLLLIF_Pos = 0x9
	// Bit mask of PLLLIF field.
	DSI_WISR_PLLLIF_Msk = 0x200
	// Bit PLLLIF.
	DSI_WISR_PLLLIF = 0x200
	// Position of PLLLS field.
	DSI_WISR_PLLLS_Pos = 0x8
	// Bit mask of PLLLS field.
	DSI_WISR_PLLLS_Msk = 0x100
	// Bit PLLLS.
	DSI_WISR_PLLLS = 0x100
	// Position of BUSY field.
	DSI_WISR_BUSY_Pos = 0x2
	// Bit mask of BUSY field.
	DSI_WISR_BUSY_Msk = 0x4
	// Bit BUSY.
	DSI_WISR_BUSY = 0x4
	// Position of ERIF field.
	DSI_WISR_ERIF_Pos = 0x1
	// Bit mask of ERIF field.
	DSI_WISR_ERIF_Msk = 0x2
	// Bit ERIF.
	DSI_WISR_ERIF = 0x2
	// Position of TEIF field.
	DSI_WISR_TEIF_Pos = 0x0
	// Bit mask of TEIF field.
	DSI_WISR_TEIF_Msk = 0x1
	// Bit TEIF.
	DSI_WISR_TEIF = 0x1

	// WIFCR: DSI Wrapper Interrupt Flag Clear Register
	// Position of CRRIF field.
	DSI_WIFCR_CRRIF_Pos = 0xd
	// Bit mask of CRRIF field.
	DSI_WIFCR_CRRIF_Msk = 0x2000
	// Bit CRRIF.
	DSI_WIFCR_CRRIF = 0x2000
	// Position of CPLLUIF field.
	DSI_WIFCR_CPLLUIF_Pos = 0xa
	// Bit mask of CPLLUIF field.
	DSI_WIFCR_CPLLUIF_Msk = 0x400
	// Bit CPLLUIF.
	DSI_WIFCR_CPLLUIF = 0x400
	// Position of CPLLLIF field.
	DSI_WIFCR_CPLLLIF_Pos = 0x9
	// Bit mask of CPLLLIF field.
	DSI_WIFCR_CPLLLIF_Msk = 0x200
	// Bit CPLLLIF.
	DSI_WIFCR_CPLLLIF = 0x200
	// Position of CERIF field.
	DSI_WIFCR_CERIF_Pos = 0x1
	// Bit mask of CERIF field.
	DSI_WIFCR_CERIF_Msk = 0x2
	// Bit CERIF.
	DSI_WIFCR_CERIF = 0x2
	// Position of CTEIF field.
	DSI_WIFCR_CTEIF_Pos = 0x0
	// Bit mask of CTEIF field.
	DSI_WIFCR_CTEIF_Msk = 0x1
	// Bit CTEIF.
	DSI_WIFCR_CTEIF = 0x1

	// WPCR0: DSI Wrapper PHY Configuration Register 0
	// Position of TCLKPOSTEN field.
	DSI_WPCR0_TCLKPOSTEN_Pos = 0x1b
	// Bit mask of TCLKPOSTEN field.
	DSI_WPCR0_TCLKPOSTEN_Msk = 0x8000000
	// Bit TCLKPOSTEN.
	DSI_WPCR0_TCLKPOSTEN = 0x8000000
	// Position of TLPXCEN field.
	DSI_WPCR0_TLPXCEN_Pos = 0x1a
	// Bit mask of TLPXCEN field.
	DSI_WPCR0_TLPXCEN_Msk = 0x4000000
	// Bit TLPXCEN.
	DSI_WPCR0_TLPXCEN = 0x4000000
	// Position of THSEXITEN field.
	DSI_WPCR0_THSEXITEN_Pos = 0x19
	// Bit mask of THSEXITEN field.
	DSI_WPCR0_THSEXITEN_Msk = 0x2000000
	// Bit THSEXITEN.
	DSI_WPCR0_THSEXITEN = 0x2000000
	// Position of TLPXDEN field.
	DSI_WPCR0_TLPXDEN_Pos = 0x18
	// Bit mask of TLPXDEN field.
	DSI_WPCR0_TLPXDEN_Msk = 0x1000000
	// Bit TLPXDEN.
	DSI_WPCR0_TLPXDEN = 0x1000000
	// Position of THSZEROEN field.
	DSI_WPCR0_THSZEROEN_Pos = 0x17
	// Bit mask of THSZEROEN field.
	DSI_WPCR0_THSZEROEN_Msk = 0x800000
	// Bit THSZEROEN.
	DSI_WPCR0_THSZEROEN = 0x800000
	// Position of THSTRAILEN field.
	DSI_WPCR0_THSTRAILEN_Pos = 0x16
	// Bit mask of THSTRAILEN field.
	DSI_WPCR0_THSTRAILEN_Msk = 0x400000
	// Bit THSTRAILEN.
	DSI_WPCR0_THSTRAILEN = 0x400000
	// Position of THSPREPEN field.
	DSI_WPCR0_THSPREPEN_Pos = 0x15
	// Bit mask of THSPREPEN field.
	DSI_WPCR0_THSPREPEN_Msk = 0x200000
	// Bit THSPREPEN.
	DSI_WPCR0_THSPREPEN = 0x200000
	// Position of TCLKZEROEN field.
	DSI_WPCR0_TCLKZEROEN_Pos = 0x14
	// Bit mask of TCLKZEROEN field.
	DSI_WPCR0_TCLKZEROEN_Msk = 0x100000
	// Bit TCLKZEROEN.
	DSI_WPCR0_TCLKZEROEN = 0x100000
	// Position of TCLKPREPEN field.
	DSI_WPCR0_TCLKPREPEN_Pos = 0x13
	// Bit mask of TCLKPREPEN field.
	DSI_WPCR0_TCLKPREPEN_Msk = 0x80000
	// Bit TCLKPREPEN.
	DSI_WPCR0_TCLKPREPEN = 0x80000
	// Position of PDEN field.
	DSI_WPCR0_PDEN_Pos = 0x12
	// Bit mask of PDEN field.
	DSI_WPCR0_PDEN_Msk = 0x40000
	// Bit PDEN.
	DSI_WPCR0_PDEN = 0x40000
	// Position of TDDL field.
	DSI_WPCR0_TDDL_Pos = 0x10
	// Bit mask of TDDL field.
	DSI_WPCR0_TDDL_Msk = 0x10000
	// Bit TDDL.
	DSI_WPCR0_TDDL = 0x10000
	// Position of CDOFFDL field.
	DSI_WPCR0_CDOFFDL_Pos = 0xe
	// Bit mask of CDOFFDL field.
	DSI_WPCR0_CDOFFDL_Msk = 0x4000
	// Bit CDOFFDL.
	DSI_WPCR0_CDOFFDL = 0x4000
	// Position of FTXSMDL field.
	DSI_WPCR0_FTXSMDL_Pos = 0xd
	// Bit mask of FTXSMDL field.
	DSI_WPCR0_FTXSMDL_Msk = 0x2000
	// Bit FTXSMDL.
	DSI_WPCR0_FTXSMDL = 0x2000
	// Position of FTXSMCL field.
	DSI_WPCR0_FTXSMCL_Pos = 0xc
	// Bit mask of FTXSMCL field.
	DSI_WPCR0_FTXSMCL_Msk = 0x1000
	// Bit FTXSMCL.
	DSI_WPCR0_FTXSMCL = 0x1000
	// Position of HSIDL1 field.
	DSI_WPCR0_HSIDL1_Pos = 0xb
	// Bit mask of HSIDL1 field.
	DSI_WPCR0_HSIDL1_Msk = 0x800
	// Bit HSIDL1.
	DSI_WPCR0_HSIDL1 = 0x800
	// Position of HSIDL0 field.
	DSI_WPCR0_HSIDL0_Pos = 0xa
	// Bit mask of HSIDL0 field.
	DSI_WPCR0_HSIDL0_Msk = 0x400
	// Bit HSIDL0.
	DSI_WPCR0_HSIDL0 = 0x400
	// Position of HSICL field.
	DSI_WPCR0_HSICL_Pos = 0x9
	// Bit mask of HSICL field.
	DSI_WPCR0_HSICL_Msk = 0x200
	// Bit HSICL.
	DSI_WPCR0_HSICL = 0x200
	// Position of SWDL1 field.
	DSI_WPCR0_SWDL1_Pos = 0x8
	// Bit mask of SWDL1 field.
	DSI_WPCR0_SWDL1_Msk = 0x100
	// Bit SWDL1.
	DSI_WPCR0_SWDL1 = 0x100
	// Position of SWDL0 field.
	DSI_WPCR0_SWDL0_Pos = 0x7
	// Bit mask of SWDL0 field.
	DSI_WPCR0_SWDL0_Msk = 0x80
	// Bit SWDL0.
	DSI_WPCR0_SWDL0 = 0x80
	// Position of SWCL field.
	DSI_WPCR0_SWCL_Pos = 0x6
	// Bit mask of SWCL field.
	DSI_WPCR0_SWCL_Msk = 0x40
	// Bit SWCL.
	DSI_WPCR0_SWCL = 0x40
	// Position of UIX4 field.
	DSI_WPCR0_UIX4_Pos = 0x0
	// Bit mask of UIX4 field.
	DSI_WPCR0_UIX4_Msk = 0x3f

	// WPCR1: DSI Wrapper PHY Configuration Register 1
	// Position of LPRXFT field.
	DSI_WPCR1_LPRXFT_Pos = 0x19
	// Bit mask of LPRXFT field.
	DSI_WPCR1_LPRXFT_Msk = 0x6000000
	// Position of FLPRXLPM field.
	DSI_WPCR1_FLPRXLPM_Pos = 0x16
	// Bit mask of FLPRXLPM field.
	DSI_WPCR1_FLPRXLPM_Msk = 0x400000
	// Bit FLPRXLPM.
	DSI_WPCR1_FLPRXLPM = 0x400000
	// Position of HSTXSRCDL field.
	DSI_WPCR1_HSTXSRCDL_Pos = 0x12
	// Bit mask of HSTXSRCDL field.
	DSI_WPCR1_HSTXSRCDL_Msk = 0xc0000
	// Position of HSTXSRCCL field.
	DSI_WPCR1_HSTXSRCCL_Pos = 0x10
	// Bit mask of HSTXSRCCL field.
	DSI_WPCR1_HSTXSRCCL_Msk = 0x30000
	// Position of SDCC field.
	DSI_WPCR1_SDCC_Pos = 0xc
	// Bit mask of SDCC field.
	DSI_WPCR1_SDCC_Msk = 0x1000
	// Bit SDCC.
	DSI_WPCR1_SDCC = 0x1000
	// Position of LPSRDL field.
	DSI_WPCR1_LPSRDL_Pos = 0x8
	// Bit mask of LPSRDL field.
	DSI_WPCR1_LPSRDL_Msk = 0x300
	// Position of LPSRCL field.
	DSI_WPCR1_LPSRCL_Pos = 0x6
	// Bit mask of LPSRCL field.
	DSI_WPCR1_LPSRCL_Msk = 0xc0
	// Position of HSTXDLL field.
	DSI_WPCR1_HSTXDLL_Pos = 0x2
	// Bit mask of HSTXDLL field.
	DSI_WPCR1_HSTXDLL_Msk = 0xc
	// Position of HSTXDCL field.
	DSI_WPCR1_HSTXDCL_Pos = 0x0
	// Bit mask of HSTXDCL field.
	DSI_WPCR1_HSTXDCL_Msk = 0x3

	// WPCR2: DSI Wrapper PHY Configuration Register 2
	// Position of THSTRAIL field.
	DSI_WPCR2_THSTRAIL_Pos = 0x18
	// Bit mask of THSTRAIL field.
	DSI_WPCR2_THSTRAIL_Msk = 0xff000000
	// Position of THSPREP field.
	DSI_WPCR2_THSPREP_Pos = 0x10
	// Bit mask of THSPREP field.
	DSI_WPCR2_THSPREP_Msk = 0xff0000
	// Position of TCLKZEO field.
	DSI_WPCR2_TCLKZEO_Pos = 0x8
	// Bit mask of TCLKZEO field.
	DSI_WPCR2_TCLKZEO_Msk = 0xff00
	// Position of TCLKPREP field.
	DSI_WPCR2_TCLKPREP_Pos = 0x0
	// Bit mask of TCLKPREP field.
	DSI_WPCR2_TCLKPREP_Msk = 0xff

	// WPCR3: DSI_WPCR3
	// Position of TLPXC field.
	DSI_WPCR3_TLPXC_Pos = 0x18
	// Bit mask of TLPXC field.
	DSI_WPCR3_TLPXC_Msk = 0xff000000
	// Position of THSEXIT field.
	DSI_WPCR3_THSEXIT_Pos = 0x10
	// Bit mask of THSEXIT field.
	DSI_WPCR3_THSEXIT_Msk = 0xff0000
	// Position of TLPXD field.
	DSI_WPCR3_TLPXD_Pos = 0x8
	// Bit mask of TLPXD field.
	DSI_WPCR3_TLPXD_Msk = 0xff00
	// Position of THSZERO field.
	DSI_WPCR3_THSZERO_Pos = 0x0
	// Bit mask of THSZERO field.
	DSI_WPCR3_THSZERO_Msk = 0xff

	// WPCR4: DSI Wrapper PHY Configuration Register 4
	// Position of THSZERO field.
	DSI_WPCR4_THSZERO_Pos = 0x0
	// Bit mask of THSZERO field.
	DSI_WPCR4_THSZERO_Msk = 0xff

	// WRPCR: DSI Wrapper Regulator and PLL Control Register
	// Position of REGEN field.
	DSI_WRPCR_REGEN_Pos = 0x18
	// Bit mask of REGEN field.
	DSI_WRPCR_REGEN_Msk = 0x1000000
	// Bit REGEN.
	DSI_WRPCR_REGEN = 0x1000000
	// Position of ODF field.
	DSI_WRPCR_ODF_Pos = 0x10
	// Bit mask of ODF field.
	DSI_WRPCR_ODF_Msk = 0x30000
	// Position of IDF field.
	DSI_WRPCR_IDF_Pos = 0xb
	// Bit mask of IDF field.
	DSI_WRPCR_IDF_Msk = 0x7800
	// Position of NDIV field.
	DSI_WRPCR_NDIV_Pos = 0x2
	// Bit mask of NDIV field.
	DSI_WRPCR_NDIV_Msk = 0x1fc
	// Position of PLLEN field.
	DSI_WRPCR_PLLEN_Pos = 0x0
	// Bit mask of PLLEN field.
	DSI_WRPCR_PLLEN_Msk = 0x1
	// Bit PLLEN.
	DSI_WRPCR_PLLEN = 0x1
)

// Constants for GFXMMU: Graphic MMU
const (
	// CR: Graphic MMU configuration register
	// Position of B0OIE field.
	GFXMMU_CR_B0OIE_Pos = 0x0
	// Bit mask of B0OIE field.
	GFXMMU_CR_B0OIE_Msk = 0x1
	// Bit B0OIE.
	GFXMMU_CR_B0OIE = 0x1
	// Position of B1OIE field.
	GFXMMU_CR_B1OIE_Pos = 0x1
	// Bit mask of B1OIE field.
	GFXMMU_CR_B1OIE_Msk = 0x2
	// Bit B1OIE.
	GFXMMU_CR_B1OIE = 0x2
	// Position of B2OIE field.
	GFXMMU_CR_B2OIE_Pos = 0x2
	// Bit mask of B2OIE field.
	GFXMMU_CR_B2OIE_Msk = 0x4
	// Bit B2OIE.
	GFXMMU_CR_B2OIE = 0x4
	// Position of B3OIE field.
	GFXMMU_CR_B3OIE_Pos = 0x3
	// Bit mask of B3OIE field.
	GFXMMU_CR_B3OIE_Msk = 0x8
	// Bit B3OIE.
	GFXMMU_CR_B3OIE = 0x8
	// Position of AMEIE field.
	GFXMMU_CR_AMEIE_Pos = 0x4
	// Bit mask of AMEIE field.
	GFXMMU_CR_AMEIE_Msk = 0x10
	// Bit AMEIE.
	GFXMMU_CR_AMEIE = 0x10
	// Position of BM192 field.
	GFXMMU_CR_BM192_Pos = 0x6
	// Bit mask of BM192 field.
	GFXMMU_CR_BM192_Msk = 0x40
	// Bit BM192.
	GFXMMU_CR_BM192 = 0x40

	// SR: Graphic MMU status register
	// Position of B0OF field.
	GFXMMU_SR_B0OF_Pos = 0x0
	// Bit mask of B0OF field.
	GFXMMU_SR_B0OF_Msk = 0x1
	// Bit B0OF.
	GFXMMU_SR_B0OF = 0x1
	// Position of B1OF field.
	GFXMMU_SR_B1OF_Pos = 0x1
	// Bit mask of B1OF field.
	GFXMMU_SR_B1OF_Msk = 0x2
	// Bit B1OF.
	GFXMMU_SR_B1OF = 0x2
	// Position of B2OF field.
	GFXMMU_SR_B2OF_Pos = 0x2
	// Bit mask of B2OF field.
	GFXMMU_SR_B2OF_Msk = 0x4
	// Bit B2OF.
	GFXMMU_SR_B2OF = 0x4
	// Position of B3OF field.
	GFXMMU_SR_B3OF_Pos = 0x3
	// Bit mask of B3OF field.
	GFXMMU_SR_B3OF_Msk = 0x8
	// Bit B3OF.
	GFXMMU_SR_B3OF = 0x8
	// Position of AMEF field.
	GFXMMU_SR_AMEF_Pos = 0x4
	// Bit mask of AMEF field.
	GFXMMU_SR_AMEF_Msk = 0x10
	// Bit AMEF.
	GFXMMU_SR_AMEF = 0x10

	// FCR: Graphic MMU flag clear register
	// Position of CB0OF field.
	GFXMMU_FCR_CB0OF_Pos = 0x0
	// Bit mask of CB0OF field.
	GFXMMU_FCR_CB0OF_Msk = 0x1
	// Bit CB0OF.
	GFXMMU_FCR_CB0OF = 0x1
	// Position of CB1OF field.
	GFXMMU_FCR_CB1OF_Pos = 0x1
	// Bit mask of CB1OF field.
	GFXMMU_FCR_CB1OF_Msk = 0x2
	// Bit CB1OF.
	GFXMMU_FCR_CB1OF = 0x2
	// Position of CB2OF field.
	GFXMMU_FCR_CB2OF_Pos = 0x2
	// Bit mask of CB2OF field.
	GFXMMU_FCR_CB2OF_Msk = 0x4
	// Bit CB2OF.
	GFXMMU_FCR_CB2OF = 0x4
	// Position of CB3OF field.
	GFXMMU_FCR_CB3OF_Pos = 0x3
	// Bit mask of CB3OF field.
	GFXMMU_FCR_CB3OF_Msk = 0x8
	// Bit CB3OF.
	GFXMMU_FCR_CB3OF = 0x8
	// Position of CAMEF field.
	GFXMMU_FCR_CAMEF_Pos = 0x4
	// Bit mask of CAMEF field.
	GFXMMU_FCR_CAMEF_Msk = 0x10
	// Bit CAMEF.
	GFXMMU_FCR_CAMEF = 0x10

	// DVR: Graphic MMU default value register
	// Position of DV field.
	GFXMMU_DVR_DV_Pos = 0x0
	// Bit mask of DV field.
	GFXMMU_DVR_DV_Msk = 0xffffffff

	// B0CR: Graphic MMU buffer 0 configuration register
	// Position of PBO field.
	GFXMMU_B0CR_PBO_Pos = 0x4
	// Bit mask of PBO field.
	GFXMMU_B0CR_PBO_Msk = 0x7ffff0
	// Position of PBBA field.
	GFXMMU_B0CR_PBBA_Pos = 0x17
	// Bit mask of PBBA field.
	GFXMMU_B0CR_PBBA_Msk = 0xff800000

	// B1CR: Graphic MMU buffer 1 configuration register
	// Position of PBO field.
	GFXMMU_B1CR_PBO_Pos = 0x4
	// Bit mask of PBO field.
	GFXMMU_B1CR_PBO_Msk = 0x7ffff0
	// Position of PBBA field.
	GFXMMU_B1CR_PBBA_Pos = 0x17
	// Bit mask of PBBA field.
	GFXMMU_B1CR_PBBA_Msk = 0xff800000

	// B2CR: Graphic MMU buffer 2 configuration register
	// Position of PBO field.
	GFXMMU_B2CR_PBO_Pos = 0x4
	// Bit mask of PBO field.
	GFXMMU_B2CR_PBO_Msk = 0x7ffff0
	// Position of PBBA field.
	GFXMMU_B2CR_PBBA_Pos = 0x17
	// Bit mask of PBBA field.
	GFXMMU_B2CR_PBBA_Msk = 0xff800000

	// B3CR: Graphic MMU buffer 3 configuration register
	// Position of PBO field.
	GFXMMU_B3CR_PBO_Pos = 0x4
	// Bit mask of PBO field.
	GFXMMU_B3CR_PBO_Msk = 0x7ffff0
	// Position of PBBA field.
	GFXMMU_B3CR_PBBA_Pos = 0x17
	// Bit mask of PBBA field.
	GFXMMU_B3CR_PBBA_Msk = 0xff800000

	// VERR: Graphic MMU version register
	// Position of MINREV field.
	GFXMMU_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	GFXMMU_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	GFXMMU_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	GFXMMU_VERR_MAJREV_Msk = 0xf0

	// IPIDR: Graphic MMU identification register
	// Position of ID field.
	GFXMMU_IPIDR_ID_Pos = 0x0
	// Bit mask of ID field.
	GFXMMU_IPIDR_ID_Msk = 0xffffffff

	// SIDR: Graphic MMU size identification register
	// Position of SID field.
	GFXMMU_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	GFXMMU_SIDR_SID_Msk = 0xffffffff

	// LUT0L: Graphic MMU LUT entry 0 low
	// Position of EN field.
	GFXMMU_LUT0L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT0L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT0L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT0L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT0L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT0L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT0L_LVB_Msk = 0xff0000

	// LUT0H: Graphic MMU LUT entry 0 high
	// Position of LO field.
	GFXMMU_LUT0H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT0H_LO_Msk = 0x3ffff0

	// LUT1L: Graphic MMU LUT entry 1 low
	// Position of EN field.
	GFXMMU_LUT1L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1L_LVB_Msk = 0xff0000

	// LUT1H: Graphic MMU LUT entry 1 high
	// Position of LO field.
	GFXMMU_LUT1H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1H_LO_Msk = 0x3ffff0

	// LUT2L: Graphic MMU LUT entry 2 low
	// Position of EN field.
	GFXMMU_LUT2L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT2L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT2L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT2L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT2L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT2L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT2L_LVB_Msk = 0xff0000

	// LUT2H: Graphic MMU LUT entry 2 high
	// Position of LO field.
	GFXMMU_LUT2H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT2H_LO_Msk = 0x3ffff0

	// LUT3L: Graphic MMU LUT entry 3 low
	// Position of EN field.
	GFXMMU_LUT3L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT3L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT3L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT3L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT3L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT3L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT3L_LVB_Msk = 0xff0000

	// LUT3H: Graphic MMU LUT entry 3 high
	// Position of LO field.
	GFXMMU_LUT3H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT3H_LO_Msk = 0x3ffff0

	// LUT4L: Graphic MMU LUT entry 4 low
	// Position of EN field.
	GFXMMU_LUT4L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT4L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT4L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT4L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT4L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT4L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT4L_LVB_Msk = 0xff0000

	// LUT4H: Graphic MMU LUT entry 4 high
	// Position of LO field.
	GFXMMU_LUT4H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT4H_LO_Msk = 0x3ffff0

	// LUT5L: Graphic MMU LUT entry 5 low
	// Position of EN field.
	GFXMMU_LUT5L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT5L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT5L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT5L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT5L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT5L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT5L_LVB_Msk = 0xff0000

	// LUT5H: Graphic MMU LUT entry 5 high
	// Position of LO field.
	GFXMMU_LUT5H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT5H_LO_Msk = 0x3ffff0

	// LUT6L: Graphic MMU LUT entry 6 low
	// Position of EN field.
	GFXMMU_LUT6L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT6L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT6L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT6L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT6L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT6L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT6L_LVB_Msk = 0xff0000

	// LUT6H: Graphic MMU LUT entry 6 high
	// Position of LO field.
	GFXMMU_LUT6H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT6H_LO_Msk = 0x3ffff0

	// LUT7L: Graphic MMU LUT entry 7 low
	// Position of EN field.
	GFXMMU_LUT7L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT7L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT7L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT7L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT7L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT7L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT7L_LVB_Msk = 0xff0000

	// LUT7H: Graphic MMU LUT entry 7 high
	// Position of LO field.
	GFXMMU_LUT7H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT7H_LO_Msk = 0x3ffff0

	// LUT8L: Graphic MMU LUT entry 8 low
	// Position of EN field.
	GFXMMU_LUT8L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT8L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT8L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT8L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT8L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT8L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT8L_LVB_Msk = 0xff0000

	// LUT8H: Graphic MMU LUT entry 8 high
	// Position of LO field.
	GFXMMU_LUT8H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT8H_LO_Msk = 0x3ffff0

	// LUT9L: Graphic MMU LUT entry 9 low
	// Position of EN field.
	GFXMMU_LUT9L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT9L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT9L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT9L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT9L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT9L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT9L_LVB_Msk = 0xff0000

	// LUT9H: Graphic MMU LUT entry 9 high
	// Position of LO field.
	GFXMMU_LUT9H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT9H_LO_Msk = 0x3ffff0

	// LUT10L: Graphic MMU LUT entry 10 low
	// Position of EN field.
	GFXMMU_LUT10L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT10L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT10L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT10L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT10L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT10L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT10L_LVB_Msk = 0xff0000

	// LUT10H: Graphic MMU LUT entry 10 high
	// Position of LO field.
	GFXMMU_LUT10H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT10H_LO_Msk = 0x3ffff0

	// LUT11L: Graphic MMU LUT entry 11 low
	// Position of EN field.
	GFXMMU_LUT11L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT11L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT11L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT11L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT11L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT11L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT11L_LVB_Msk = 0xff0000

	// LUT11H: Graphic MMU LUT entry 11 high
	// Position of LO field.
	GFXMMU_LUT11H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT11H_LO_Msk = 0x3ffff0

	// LUT12L: Graphic MMU LUT entry 12 low
	// Position of EN field.
	GFXMMU_LUT12L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT12L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT12L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT12L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT12L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT12L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT12L_LVB_Msk = 0xff0000

	// LUT12H: Graphic MMU LUT entry 12 high
	// Position of LO field.
	GFXMMU_LUT12H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT12H_LO_Msk = 0x3ffff0

	// LUT13L: Graphic MMU LUT entry 13 low
	// Position of EN field.
	GFXMMU_LUT13L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT13L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT13L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT13L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT13L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT13L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT13L_LVB_Msk = 0xff0000

	// LUT13H: Graphic MMU LUT entry 13 high
	// Position of LO field.
	GFXMMU_LUT13H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT13H_LO_Msk = 0x3ffff0

	// LUT14L: Graphic MMU LUT entry 14 low
	// Position of EN field.
	GFXMMU_LUT14L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT14L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT14L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT14L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT14L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT14L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT14L_LVB_Msk = 0xff0000

	// LUT14H: Graphic MMU LUT entry 14 high
	// Position of LO field.
	GFXMMU_LUT14H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT14H_LO_Msk = 0x3ffff0

	// LUT15L: Graphic MMU LUT entry 15 low
	// Position of EN field.
	GFXMMU_LUT15L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT15L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT15L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT15L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT15L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT15L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT15L_LVB_Msk = 0xff0000

	// LUT15H: Graphic MMU LUT entry 15 high
	// Position of LO field.
	GFXMMU_LUT15H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT15H_LO_Msk = 0x3ffff0

	// LUT16L: Graphic MMU LUT entry 16 low
	// Position of EN field.
	GFXMMU_LUT16L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT16L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT16L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT16L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT16L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT16L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT16L_LVB_Msk = 0xff0000

	// LUT16H: Graphic MMU LUT entry 16 high
	// Position of LO field.
	GFXMMU_LUT16H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT16H_LO_Msk = 0x3ffff0

	// LUT17L: Graphic MMU LUT entry 17 low
	// Position of EN field.
	GFXMMU_LUT17L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT17L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT17L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT17L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT17L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT17L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT17L_LVB_Msk = 0xff0000

	// LUT17H: Graphic MMU LUT entry 17 high
	// Position of LO field.
	GFXMMU_LUT17H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT17H_LO_Msk = 0x3ffff0

	// LUT18L: Graphic MMU LUT entry 18 low
	// Position of EN field.
	GFXMMU_LUT18L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT18L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT18L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT18L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT18L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT18L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT18L_LVB_Msk = 0xff0000

	// LUT18H: Graphic MMU LUT entry 18 high
	// Position of LO field.
	GFXMMU_LUT18H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT18H_LO_Msk = 0x3ffff0

	// LUT19L: Graphic MMU LUT entry 19 low
	// Position of EN field.
	GFXMMU_LUT19L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT19L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT19L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT19L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT19L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT19L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT19L_LVB_Msk = 0xff0000

	// LUT19H: Graphic MMU LUT entry 19 high
	// Position of LO field.
	GFXMMU_LUT19H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT19H_LO_Msk = 0x3ffff0

	// LUT20L: Graphic MMU LUT entry 20 low
	// Position of EN field.
	GFXMMU_LUT20L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT20L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT20L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT20L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT20L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT20L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT20L_LVB_Msk = 0xff0000

	// LUT20H: Graphic MMU LUT entry 20 high
	// Position of LO field.
	GFXMMU_LUT20H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT20H_LO_Msk = 0x3ffff0

	// LUT21L: Graphic MMU LUT entry 21 low
	// Position of EN field.
	GFXMMU_LUT21L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT21L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT21L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT21L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT21L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT21L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT21L_LVB_Msk = 0xff0000

	// LUT21H: Graphic MMU LUT entry 21 high
	// Position of LO field.
	GFXMMU_LUT21H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT21H_LO_Msk = 0x3ffff0

	// LUT22L: Graphic MMU LUT entry 22 low
	// Position of EN field.
	GFXMMU_LUT22L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT22L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT22L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT22L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT22L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT22L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT22L_LVB_Msk = 0xff0000

	// LUT22H: Graphic MMU LUT entry 22 high
	// Position of LO field.
	GFXMMU_LUT22H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT22H_LO_Msk = 0x3ffff0

	// LUT23L: Graphic MMU LUT entry 23 low
	// Position of EN field.
	GFXMMU_LUT23L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT23L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT23L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT23L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT23L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT23L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT23L_LVB_Msk = 0xff0000

	// LUT23H: Graphic MMU LUT entry 23 high
	// Position of LO field.
	GFXMMU_LUT23H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT23H_LO_Msk = 0x3ffff0

	// LUT24L: Graphic MMU LUT entry 24 low
	// Position of EN field.
	GFXMMU_LUT24L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT24L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT24L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT24L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT24L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT24L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT24L_LVB_Msk = 0xff0000

	// LUT24H: Graphic MMU LUT entry 24 high
	// Position of LO field.
	GFXMMU_LUT24H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT24H_LO_Msk = 0x3ffff0

	// LUT25L: Graphic MMU LUT entry 25 low
	// Position of EN field.
	GFXMMU_LUT25L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT25L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT25L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT25L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT25L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT25L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT25L_LVB_Msk = 0xff0000

	// LUT25H: Graphic MMU LUT entry 25 high
	// Position of LO field.
	GFXMMU_LUT25H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT25H_LO_Msk = 0x3ffff0

	// LUT26L: Graphic MMU LUT entry 26 low
	// Position of EN field.
	GFXMMU_LUT26L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT26L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT26L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT26L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT26L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT26L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT26L_LVB_Msk = 0xff0000

	// LUT26H: Graphic MMU LUT entry 26 high
	// Position of LO field.
	GFXMMU_LUT26H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT26H_LO_Msk = 0x3ffff0

	// LUT27L: Graphic MMU LUT entry 27 low
	// Position of EN field.
	GFXMMU_LUT27L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT27L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT27L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT27L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT27L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT27L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT27L_LVB_Msk = 0xff0000

	// LUT27H: Graphic MMU LUT entry 27 high
	// Position of LO field.
	GFXMMU_LUT27H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT27H_LO_Msk = 0x3ffff0

	// LUT28L: Graphic MMU LUT entry 28 low
	// Position of EN field.
	GFXMMU_LUT28L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT28L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT28L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT28L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT28L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT28L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT28L_LVB_Msk = 0xff0000

	// LUT28H: Graphic MMU LUT entry 28 high
	// Position of LO field.
	GFXMMU_LUT28H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT28H_LO_Msk = 0x3ffff0

	// LUT29L: Graphic MMU LUT entry 29 low
	// Position of EN field.
	GFXMMU_LUT29L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT29L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT29L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT29L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT29L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT29L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT29L_LVB_Msk = 0xff0000

	// LUT29H: Graphic MMU LUT entry 29 high
	// Position of LO field.
	GFXMMU_LUT29H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT29H_LO_Msk = 0x3ffff0

	// LUT30L: Graphic MMU LUT entry 30 low
	// Position of EN field.
	GFXMMU_LUT30L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT30L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT30L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT30L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT30L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT30L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT30L_LVB_Msk = 0xff0000

	// LUT30H: Graphic MMU LUT entry 30 high
	// Position of LO field.
	GFXMMU_LUT30H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT30H_LO_Msk = 0x3ffff0

	// LUT31L: Graphic MMU LUT entry 31 low
	// Position of EN field.
	GFXMMU_LUT31L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT31L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT31L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT31L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT31L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT31L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT31L_LVB_Msk = 0xff0000

	// LUT31H: Graphic MMU LUT entry 31 high
	// Position of LO field.
	GFXMMU_LUT31H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT31H_LO_Msk = 0x3ffff0

	// LUT32L: Graphic MMU LUT entry 32 low
	// Position of EN field.
	GFXMMU_LUT32L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT32L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT32L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT32L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT32L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT32L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT32L_LVB_Msk = 0xff0000

	// LUT32H: Graphic MMU LUT entry 32 high
	// Position of LO field.
	GFXMMU_LUT32H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT32H_LO_Msk = 0x3ffff0

	// LUT33L: Graphic MMU LUT entry 33 low
	// Position of EN field.
	GFXMMU_LUT33L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT33L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT33L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT33L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT33L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT33L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT33L_LVB_Msk = 0xff0000

	// LUT33H: Graphic MMU LUT entry 33 high
	// Position of LO field.
	GFXMMU_LUT33H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT33H_LO_Msk = 0x3ffff0

	// LUT34L: Graphic MMU LUT entry 34 low
	// Position of EN field.
	GFXMMU_LUT34L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT34L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT34L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT34L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT34L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT34L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT34L_LVB_Msk = 0xff0000

	// LUT34H: Graphic MMU LUT entry 34 high
	// Position of LO field.
	GFXMMU_LUT34H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT34H_LO_Msk = 0x3ffff0

	// LUT35L: Graphic MMU LUT entry 35 low
	// Position of EN field.
	GFXMMU_LUT35L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT35L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT35L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT35L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT35L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT35L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT35L_LVB_Msk = 0xff0000

	// LUT35H: Graphic MMU LUT entry 35 high
	// Position of LO field.
	GFXMMU_LUT35H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT35H_LO_Msk = 0x3ffff0

	// LUT36L: Graphic MMU LUT entry 36 low
	// Position of EN field.
	GFXMMU_LUT36L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT36L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT36L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT36L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT36L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT36L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT36L_LVB_Msk = 0xff0000

	// LUT36H: Graphic MMU LUT entry 36 high
	// Position of LO field.
	GFXMMU_LUT36H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT36H_LO_Msk = 0x3ffff0

	// LUT37L: Graphic MMU LUT entry 37 low
	// Position of EN field.
	GFXMMU_LUT37L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT37L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT37L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT37L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT37L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT37L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT37L_LVB_Msk = 0xff0000

	// LUT37H: Graphic MMU LUT entry 37 high
	// Position of LO field.
	GFXMMU_LUT37H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT37H_LO_Msk = 0x3ffff0

	// LUT38L: Graphic MMU LUT entry 38 low
	// Position of EN field.
	GFXMMU_LUT38L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT38L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT38L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT38L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT38L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT38L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT38L_LVB_Msk = 0xff0000

	// LUT38H: Graphic MMU LUT entry 38 high
	// Position of LO field.
	GFXMMU_LUT38H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT38H_LO_Msk = 0x3ffff0

	// LUT39L: Graphic MMU LUT entry 39 low
	// Position of EN field.
	GFXMMU_LUT39L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT39L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT39L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT39L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT39L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT39L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT39L_LVB_Msk = 0xff0000

	// LUT39H: Graphic MMU LUT entry 39 high
	// Position of LO field.
	GFXMMU_LUT39H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT39H_LO_Msk = 0x3ffff0

	// LUT40L: Graphic MMU LUT entry 40 low
	// Position of EN field.
	GFXMMU_LUT40L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT40L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT40L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT40L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT40L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT40L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT40L_LVB_Msk = 0xff0000

	// LUT40H: Graphic MMU LUT entry 40 high
	// Position of LO field.
	GFXMMU_LUT40H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT40H_LO_Msk = 0x3ffff0

	// LUT41L: Graphic MMU LUT entry 41 low
	// Position of EN field.
	GFXMMU_LUT41L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT41L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT41L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT41L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT41L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT41L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT41L_LVB_Msk = 0xff0000

	// LUT41H: Graphic MMU LUT entry 41 high
	// Position of LO field.
	GFXMMU_LUT41H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT41H_LO_Msk = 0x3ffff0

	// LUT42L: Graphic MMU LUT entry 42 low
	// Position of EN field.
	GFXMMU_LUT42L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT42L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT42L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT42L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT42L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT42L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT42L_LVB_Msk = 0xff0000

	// LUT42H: Graphic MMU LUT entry 42 high
	// Position of LO field.
	GFXMMU_LUT42H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT42H_LO_Msk = 0x3ffff0

	// LUT43L: Graphic MMU LUT entry 43 low
	// Position of EN field.
	GFXMMU_LUT43L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT43L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT43L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT43L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT43L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT43L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT43L_LVB_Msk = 0xff0000

	// LUT43H: Graphic MMU LUT entry 43 high
	// Position of LO field.
	GFXMMU_LUT43H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT43H_LO_Msk = 0x3ffff0

	// LUT44L: Graphic MMU LUT entry 44 low
	// Position of EN field.
	GFXMMU_LUT44L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT44L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT44L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT44L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT44L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT44L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT44L_LVB_Msk = 0xff0000

	// LUT44H: Graphic MMU LUT entry 44 high
	// Position of LO field.
	GFXMMU_LUT44H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT44H_LO_Msk = 0x3ffff0

	// LUT45L: Graphic MMU LUT entry 45 low
	// Position of EN field.
	GFXMMU_LUT45L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT45L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT45L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT45L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT45L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT45L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT45L_LVB_Msk = 0xff0000

	// LUT45H: Graphic MMU LUT entry 45 high
	// Position of LO field.
	GFXMMU_LUT45H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT45H_LO_Msk = 0x3ffff0

	// LUT46L: Graphic MMU LUT entry 46 low
	// Position of EN field.
	GFXMMU_LUT46L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT46L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT46L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT46L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT46L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT46L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT46L_LVB_Msk = 0xff0000

	// LUT46H: Graphic MMU LUT entry 46 high
	// Position of LO field.
	GFXMMU_LUT46H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT46H_LO_Msk = 0x3ffff0

	// LUT47L: Graphic MMU LUT entry 47 low
	// Position of EN field.
	GFXMMU_LUT47L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT47L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT47L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT47L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT47L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT47L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT47L_LVB_Msk = 0xff0000

	// LUT47H: Graphic MMU LUT entry 47 high
	// Position of LO field.
	GFXMMU_LUT47H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT47H_LO_Msk = 0x3ffff0

	// LUT48L: Graphic MMU LUT entry 48 low
	// Position of EN field.
	GFXMMU_LUT48L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT48L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT48L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT48L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT48L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT48L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT48L_LVB_Msk = 0xff0000

	// LUT48H: Graphic MMU LUT entry 48 high
	// Position of LO field.
	GFXMMU_LUT48H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT48H_LO_Msk = 0x3ffff0

	// LUT49L: Graphic MMU LUT entry 49 low
	// Position of EN field.
	GFXMMU_LUT49L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT49L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT49L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT49L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT49L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT49L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT49L_LVB_Msk = 0xff0000

	// LUT49H: Graphic MMU LUT entry 49 high
	// Position of LO field.
	GFXMMU_LUT49H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT49H_LO_Msk = 0x3ffff0

	// LUT50L: Graphic MMU LUT entry 50 low
	// Position of EN field.
	GFXMMU_LUT50L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT50L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT50L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT50L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT50L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT50L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT50L_LVB_Msk = 0xff0000

	// LUT50H: Graphic MMU LUT entry 50 high
	// Position of LO field.
	GFXMMU_LUT50H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT50H_LO_Msk = 0x3ffff0

	// LUT51L: Graphic MMU LUT entry 51 low
	// Position of EN field.
	GFXMMU_LUT51L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT51L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT51L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT51L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT51L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT51L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT51L_LVB_Msk = 0xff0000

	// LUT51H: Graphic MMU LUT entry 51 high
	// Position of LO field.
	GFXMMU_LUT51H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT51H_LO_Msk = 0x3ffff0

	// LUT52L: Graphic MMU LUT entry 52 low
	// Position of EN field.
	GFXMMU_LUT52L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT52L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT52L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT52L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT52L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT52L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT52L_LVB_Msk = 0xff0000

	// LUT52H: Graphic MMU LUT entry 52 high
	// Position of LO field.
	GFXMMU_LUT52H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT52H_LO_Msk = 0x3ffff0

	// LUT53L: Graphic MMU LUT entry 53 low
	// Position of EN field.
	GFXMMU_LUT53L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT53L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT53L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT53L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT53L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT53L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT53L_LVB_Msk = 0xff0000

	// LUT53H: Graphic MMU LUT entry 53 high
	// Position of LO field.
	GFXMMU_LUT53H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT53H_LO_Msk = 0x3ffff0

	// LUT54L: Graphic MMU LUT entry 54 low
	// Position of EN field.
	GFXMMU_LUT54L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT54L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT54L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT54L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT54L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT54L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT54L_LVB_Msk = 0xff0000

	// LUT54H: Graphic MMU LUT entry 54 high
	// Position of LO field.
	GFXMMU_LUT54H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT54H_LO_Msk = 0x3ffff0

	// LUT55L: Graphic MMU LUT entry 55 low
	// Position of EN field.
	GFXMMU_LUT55L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT55L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT55L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT55L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT55L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT55L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT55L_LVB_Msk = 0xff0000

	// LUT55H: Graphic MMU LUT entry 55 high
	// Position of LO field.
	GFXMMU_LUT55H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT55H_LO_Msk = 0x3ffff0

	// LUT56L: Graphic MMU LUT entry 56 low
	// Position of EN field.
	GFXMMU_LUT56L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT56L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT56L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT56L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT56L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT56L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT56L_LVB_Msk = 0xff0000

	// LUT56H: Graphic MMU LUT entry 56 high
	// Position of LO field.
	GFXMMU_LUT56H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT56H_LO_Msk = 0x3ffff0

	// LUT57L: Graphic MMU LUT entry 57 low
	// Position of EN field.
	GFXMMU_LUT57L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT57L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT57L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT57L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT57L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT57L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT57L_LVB_Msk = 0xff0000

	// LUT57H: Graphic MMU LUT entry 57 high
	// Position of LO field.
	GFXMMU_LUT57H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT57H_LO_Msk = 0x3ffff0

	// LUT58L: Graphic MMU LUT entry 58 low
	// Position of EN field.
	GFXMMU_LUT58L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT58L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT58L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT58L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT58L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT58L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT58L_LVB_Msk = 0xff0000

	// LUT58H: Graphic MMU LUT entry 58 high
	// Position of LO field.
	GFXMMU_LUT58H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT58H_LO_Msk = 0x3ffff0

	// LUT59L: Graphic MMU LUT entry 59 low
	// Position of EN field.
	GFXMMU_LUT59L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT59L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT59L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT59L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT59L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT59L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT59L_LVB_Msk = 0xff0000

	// LUT59H: Graphic MMU LUT entry 59 high
	// Position of LO field.
	GFXMMU_LUT59H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT59H_LO_Msk = 0x3ffff0

	// LUT60L: Graphic MMU LUT entry 60 low
	// Position of EN field.
	GFXMMU_LUT60L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT60L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT60L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT60L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT60L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT60L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT60L_LVB_Msk = 0xff0000

	// LUT60H: Graphic MMU LUT entry 60 high
	// Position of LO field.
	GFXMMU_LUT60H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT60H_LO_Msk = 0x3ffff0

	// LUT61L: Graphic MMU LUT entry 61 low
	// Position of EN field.
	GFXMMU_LUT61L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT61L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT61L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT61L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT61L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT61L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT61L_LVB_Msk = 0xff0000

	// LUT61H: Graphic MMU LUT entry 61 high
	// Position of LO field.
	GFXMMU_LUT61H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT61H_LO_Msk = 0x3ffff0

	// LUT62L: Graphic MMU LUT entry 62 low
	// Position of EN field.
	GFXMMU_LUT62L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT62L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT62L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT62L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT62L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT62L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT62L_LVB_Msk = 0xff0000

	// LUT62H: Graphic MMU LUT entry 62 high
	// Position of LO field.
	GFXMMU_LUT62H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT62H_LO_Msk = 0x3ffff0

	// LUT63L: Graphic MMU LUT entry 63 low
	// Position of EN field.
	GFXMMU_LUT63L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT63L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT63L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT63L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT63L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT63L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT63L_LVB_Msk = 0xff0000

	// LUT63H: Graphic MMU LUT entry 63 high
	// Position of LO field.
	GFXMMU_LUT63H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT63H_LO_Msk = 0x3ffff0

	// LUT64L: Graphic MMU LUT entry 64 low
	// Position of EN field.
	GFXMMU_LUT64L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT64L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT64L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT64L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT64L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT64L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT64L_LVB_Msk = 0xff0000

	// LUT64H: Graphic MMU LUT entry 64 high
	// Position of LO field.
	GFXMMU_LUT64H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT64H_LO_Msk = 0x3ffff0

	// LUT65L: Graphic MMU LUT entry 65 low
	// Position of EN field.
	GFXMMU_LUT65L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT65L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT65L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT65L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT65L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT65L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT65L_LVB_Msk = 0xff0000

	// LUT65H: Graphic MMU LUT entry 65 high
	// Position of LO field.
	GFXMMU_LUT65H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT65H_LO_Msk = 0x3ffff0

	// LUT66L: Graphic MMU LUT entry 66 low
	// Position of EN field.
	GFXMMU_LUT66L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT66L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT66L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT66L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT66L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT66L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT66L_LVB_Msk = 0xff0000

	// LUT66H: Graphic MMU LUT entry 66 high
	// Position of LO field.
	GFXMMU_LUT66H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT66H_LO_Msk = 0x3ffff0

	// LUT67L: Graphic MMU LUT entry 67 low
	// Position of EN field.
	GFXMMU_LUT67L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT67L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT67L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT67L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT67L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT67L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT67L_LVB_Msk = 0xff0000

	// LUT67H: Graphic MMU LUT entry 67 high
	// Position of LO field.
	GFXMMU_LUT67H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT67H_LO_Msk = 0x3ffff0

	// LUT68L: Graphic MMU LUT entry 68 low
	// Position of EN field.
	GFXMMU_LUT68L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT68L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT68L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT68L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT68L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT68L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT68L_LVB_Msk = 0xff0000

	// LUT68H: Graphic MMU LUT entry 68 high
	// Position of LO field.
	GFXMMU_LUT68H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT68H_LO_Msk = 0x3ffff0

	// LUT69L: Graphic MMU LUT entry 69 low
	// Position of EN field.
	GFXMMU_LUT69L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT69L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT69L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT69L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT69L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT69L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT69L_LVB_Msk = 0xff0000

	// LUT69H: Graphic MMU LUT entry 69 high
	// Position of LO field.
	GFXMMU_LUT69H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT69H_LO_Msk = 0x3ffff0

	// LUT70L: Graphic MMU LUT entry 70 low
	// Position of EN field.
	GFXMMU_LUT70L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT70L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT70L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT70L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT70L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT70L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT70L_LVB_Msk = 0xff0000

	// LUT70H: Graphic MMU LUT entry 70 high
	// Position of LO field.
	GFXMMU_LUT70H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT70H_LO_Msk = 0x3ffff0

	// LUT71L: Graphic MMU LUT entry 71 low
	// Position of EN field.
	GFXMMU_LUT71L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT71L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT71L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT71L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT71L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT71L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT71L_LVB_Msk = 0xff0000

	// LUT71H: Graphic MMU LUT entry 71 high
	// Position of LO field.
	GFXMMU_LUT71H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT71H_LO_Msk = 0x3ffff0

	// LUT72L: Graphic MMU LUT entry 72 low
	// Position of EN field.
	GFXMMU_LUT72L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT72L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT72L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT72L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT72L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT72L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT72L_LVB_Msk = 0xff0000

	// LUT72H: Graphic MMU LUT entry 72 high
	// Position of LO field.
	GFXMMU_LUT72H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT72H_LO_Msk = 0x3ffff0

	// LUT73L: Graphic MMU LUT entry 73 low
	// Position of EN field.
	GFXMMU_LUT73L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT73L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT73L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT73L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT73L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT73L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT73L_LVB_Msk = 0xff0000

	// LUT73H: Graphic MMU LUT entry 73 high
	// Position of LO field.
	GFXMMU_LUT73H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT73H_LO_Msk = 0x3ffff0

	// LUT74L: Graphic MMU LUT entry 74 low
	// Position of EN field.
	GFXMMU_LUT74L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT74L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT74L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT74L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT74L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT74L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT74L_LVB_Msk = 0xff0000

	// LUT74H: Graphic MMU LUT entry 74 high
	// Position of LO field.
	GFXMMU_LUT74H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT74H_LO_Msk = 0x3ffff0

	// LUT75L: Graphic MMU LUT entry 75 low
	// Position of EN field.
	GFXMMU_LUT75L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT75L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT75L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT75L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT75L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT75L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT75L_LVB_Msk = 0xff0000

	// LUT75H: Graphic MMU LUT entry 75 high
	// Position of LO field.
	GFXMMU_LUT75H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT75H_LO_Msk = 0x3ffff0

	// LUT76L: Graphic MMU LUT entry 76 low
	// Position of EN field.
	GFXMMU_LUT76L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT76L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT76L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT76L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT76L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT76L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT76L_LVB_Msk = 0xff0000

	// LUT76H: Graphic MMU LUT entry 76 high
	// Position of LO field.
	GFXMMU_LUT76H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT76H_LO_Msk = 0x3ffff0

	// LUT77L: Graphic MMU LUT entry 77 low
	// Position of EN field.
	GFXMMU_LUT77L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT77L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT77L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT77L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT77L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT77L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT77L_LVB_Msk = 0xff0000

	// LUT77H: Graphic MMU LUT entry 77 high
	// Position of LO field.
	GFXMMU_LUT77H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT77H_LO_Msk = 0x3ffff0

	// LUT78L: Graphic MMU LUT entry 78 low
	// Position of EN field.
	GFXMMU_LUT78L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT78L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT78L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT78L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT78L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT78L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT78L_LVB_Msk = 0xff0000

	// LUT78H: Graphic MMU LUT entry 78 high
	// Position of LO field.
	GFXMMU_LUT78H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT78H_LO_Msk = 0x3ffff0

	// LUT79L: Graphic MMU LUT entry 79 low
	// Position of EN field.
	GFXMMU_LUT79L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT79L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT79L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT79L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT79L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT79L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT79L_LVB_Msk = 0xff0000

	// LUT79H: Graphic MMU LUT entry 79 high
	// Position of LO field.
	GFXMMU_LUT79H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT79H_LO_Msk = 0x3ffff0

	// LUT80L: Graphic MMU LUT entry 80 low
	// Position of EN field.
	GFXMMU_LUT80L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT80L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT80L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT80L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT80L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT80L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT80L_LVB_Msk = 0xff0000

	// LUT80H: Graphic MMU LUT entry 80 high
	// Position of LO field.
	GFXMMU_LUT80H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT80H_LO_Msk = 0x3ffff0

	// LUT81L: Graphic MMU LUT entry 81 low
	// Position of EN field.
	GFXMMU_LUT81L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT81L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT81L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT81L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT81L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT81L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT81L_LVB_Msk = 0xff0000

	// LUT81H: Graphic MMU LUT entry 81 high
	// Position of LO field.
	GFXMMU_LUT81H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT81H_LO_Msk = 0x3ffff0

	// LUT82L: Graphic MMU LUT entry 82 low
	// Position of EN field.
	GFXMMU_LUT82L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT82L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT82L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT82L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT82L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT82L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT82L_LVB_Msk = 0xff0000

	// LUT82H: Graphic MMU LUT entry 82 high
	// Position of LO field.
	GFXMMU_LUT82H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT82H_LO_Msk = 0x3ffff0

	// LUT83L: Graphic MMU LUT entry 83 low
	// Position of EN field.
	GFXMMU_LUT83L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT83L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT83L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT83L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT83L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT83L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT83L_LVB_Msk = 0xff0000

	// LUT83H: Graphic MMU LUT entry 83 high
	// Position of LO field.
	GFXMMU_LUT83H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT83H_LO_Msk = 0x3ffff0

	// LUT84L: Graphic MMU LUT entry 84 low
	// Position of EN field.
	GFXMMU_LUT84L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT84L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT84L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT84L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT84L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT84L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT84L_LVB_Msk = 0xff0000

	// LUT84H: Graphic MMU LUT entry 84 high
	// Position of LO field.
	GFXMMU_LUT84H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT84H_LO_Msk = 0x3ffff0

	// LUT85L: Graphic MMU LUT entry 85 low
	// Position of EN field.
	GFXMMU_LUT85L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT85L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT85L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT85L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT85L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT85L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT85L_LVB_Msk = 0xff0000

	// LUT85H: Graphic MMU LUT entry 85 high
	// Position of LO field.
	GFXMMU_LUT85H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT85H_LO_Msk = 0x3ffff0

	// LUT86L: Graphic MMU LUT entry 86 low
	// Position of EN field.
	GFXMMU_LUT86L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT86L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT86L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT86L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT86L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT86L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT86L_LVB_Msk = 0xff0000

	// LUT86H: Graphic MMU LUT entry 86 high
	// Position of LO field.
	GFXMMU_LUT86H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT86H_LO_Msk = 0x3ffff0

	// LUT87L: Graphic MMU LUT entry 87 low
	// Position of EN field.
	GFXMMU_LUT87L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT87L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT87L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT87L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT87L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT87L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT87L_LVB_Msk = 0xff0000

	// LUT87H: Graphic MMU LUT entry 87 high
	// Position of LO field.
	GFXMMU_LUT87H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT87H_LO_Msk = 0x3ffff0

	// LUT88L: Graphic MMU LUT entry 88 low
	// Position of EN field.
	GFXMMU_LUT88L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT88L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT88L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT88L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT88L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT88L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT88L_LVB_Msk = 0xff0000

	// LUT88H: Graphic MMU LUT entry 88 high
	// Position of LO field.
	GFXMMU_LUT88H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT88H_LO_Msk = 0x3ffff0

	// LUT89L: Graphic MMU LUT entry 89 low
	// Position of EN field.
	GFXMMU_LUT89L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT89L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT89L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT89L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT89L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT89L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT89L_LVB_Msk = 0xff0000

	// LUT89H: Graphic MMU LUT entry 89 high
	// Position of LO field.
	GFXMMU_LUT89H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT89H_LO_Msk = 0x3ffff0

	// LUT90L: Graphic MMU LUT entry 90 low
	// Position of EN field.
	GFXMMU_LUT90L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT90L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT90L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT90L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT90L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT90L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT90L_LVB_Msk = 0xff0000

	// LUT90H: Graphic MMU LUT entry 90 high
	// Position of LO field.
	GFXMMU_LUT90H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT90H_LO_Msk = 0x3ffff0

	// LUT91L: Graphic MMU LUT entry 91 low
	// Position of EN field.
	GFXMMU_LUT91L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT91L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT91L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT91L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT91L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT91L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT91L_LVB_Msk = 0xff0000

	// LUT91H: Graphic MMU LUT entry 91 high
	// Position of LO field.
	GFXMMU_LUT91H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT91H_LO_Msk = 0x3ffff0

	// LUT92L: Graphic MMU LUT entry 92 low
	// Position of EN field.
	GFXMMU_LUT92L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT92L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT92L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT92L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT92L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT92L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT92L_LVB_Msk = 0xff0000

	// LUT92H: Graphic MMU LUT entry 92 high
	// Position of LO field.
	GFXMMU_LUT92H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT92H_LO_Msk = 0x3ffff0

	// LUT93L: Graphic MMU LUT entry 93 low
	// Position of EN field.
	GFXMMU_LUT93L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT93L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT93L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT93L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT93L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT93L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT93L_LVB_Msk = 0xff0000

	// LUT93H: Graphic MMU LUT entry 93 high
	// Position of LO field.
	GFXMMU_LUT93H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT93H_LO_Msk = 0x3ffff0

	// LUT94L: Graphic MMU LUT entry 94 low
	// Position of EN field.
	GFXMMU_LUT94L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT94L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT94L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT94L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT94L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT94L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT94L_LVB_Msk = 0xff0000

	// LUT94H: Graphic MMU LUT entry 94 high
	// Position of LO field.
	GFXMMU_LUT94H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT94H_LO_Msk = 0x3ffff0

	// LUT95L: Graphic MMU LUT entry 95 low
	// Position of EN field.
	GFXMMU_LUT95L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT95L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT95L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT95L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT95L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT95L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT95L_LVB_Msk = 0xff0000

	// LUT95H: Graphic MMU LUT entry 95 high
	// Position of LO field.
	GFXMMU_LUT95H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT95H_LO_Msk = 0x3ffff0

	// LUT96L: Graphic MMU LUT entry 96 low
	// Position of EN field.
	GFXMMU_LUT96L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT96L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT96L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT96L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT96L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT96L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT96L_LVB_Msk = 0xff0000

	// LUT96H: Graphic MMU LUT entry 96 high
	// Position of LO field.
	GFXMMU_LUT96H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT96H_LO_Msk = 0x3ffff0

	// LUT97L: Graphic MMU LUT entry 97 low
	// Position of EN field.
	GFXMMU_LUT97L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT97L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT97L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT97L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT97L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT97L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT97L_LVB_Msk = 0xff0000

	// LUT97H: Graphic MMU LUT entry 97 high
	// Position of LO field.
	GFXMMU_LUT97H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT97H_LO_Msk = 0x3ffff0

	// LUT98L: Graphic MMU LUT entry 98 low
	// Position of EN field.
	GFXMMU_LUT98L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT98L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT98L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT98L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT98L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT98L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT98L_LVB_Msk = 0xff0000

	// LUT98H: Graphic MMU LUT entry 98 high
	// Position of LO field.
	GFXMMU_LUT98H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT98H_LO_Msk = 0x3ffff0

	// LUT99L: Graphic MMU LUT entry 99 low
	// Position of EN field.
	GFXMMU_LUT99L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT99L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT99L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT99L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT99L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT99L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT99L_LVB_Msk = 0xff0000

	// LUT99H: Graphic MMU LUT entry 99 high
	// Position of LO field.
	GFXMMU_LUT99H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT99H_LO_Msk = 0x3ffff0

	// LUT100L: Graphic MMU LUT entry 100 low
	// Position of EN field.
	GFXMMU_LUT100L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT100L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT100L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT100L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT100L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT100L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT100L_LVB_Msk = 0xff0000

	// LUT100H: Graphic MMU LUT entry 100 high
	// Position of LO field.
	GFXMMU_LUT100H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT100H_LO_Msk = 0x3ffff0

	// LUT101L: Graphic MMU LUT entry 101 low
	// Position of EN field.
	GFXMMU_LUT101L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT101L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT101L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT101L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT101L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT101L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT101L_LVB_Msk = 0xff0000

	// LUT101H: Graphic MMU LUT entry 101 high
	// Position of LO field.
	GFXMMU_LUT101H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT101H_LO_Msk = 0x3ffff0

	// LUT102L: Graphic MMU LUT entry 102 low
	// Position of EN field.
	GFXMMU_LUT102L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT102L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT102L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT102L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT102L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT102L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT102L_LVB_Msk = 0xff0000

	// LUT102H: Graphic MMU LUT entry 102 high
	// Position of LO field.
	GFXMMU_LUT102H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT102H_LO_Msk = 0x3ffff0

	// LUT103L: Graphic MMU LUT entry 103 low
	// Position of EN field.
	GFXMMU_LUT103L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT103L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT103L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT103L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT103L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT103L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT103L_LVB_Msk = 0xff0000

	// LUT103H: Graphic MMU LUT entry 103 high
	// Position of LO field.
	GFXMMU_LUT103H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT103H_LO_Msk = 0x3ffff0

	// LUT104L: Graphic MMU LUT entry 104 low
	// Position of EN field.
	GFXMMU_LUT104L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT104L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT104L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT104L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT104L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT104L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT104L_LVB_Msk = 0xff0000

	// LUT104H: Graphic MMU LUT entry 104 high
	// Position of LO field.
	GFXMMU_LUT104H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT104H_LO_Msk = 0x3ffff0

	// LUT105L: Graphic MMU LUT entry 105 low
	// Position of EN field.
	GFXMMU_LUT105L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT105L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT105L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT105L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT105L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT105L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT105L_LVB_Msk = 0xff0000

	// LUT105H: Graphic MMU LUT entry 105 high
	// Position of LO field.
	GFXMMU_LUT105H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT105H_LO_Msk = 0x3ffff0

	// LUT106L: Graphic MMU LUT entry 106 low
	// Position of EN field.
	GFXMMU_LUT106L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT106L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT106L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT106L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT106L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT106L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT106L_LVB_Msk = 0xff0000

	// LUT106H: Graphic MMU LUT entry 106 high
	// Position of LO field.
	GFXMMU_LUT106H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT106H_LO_Msk = 0x3ffff0

	// LUT107L: Graphic MMU LUT entry 107 low
	// Position of EN field.
	GFXMMU_LUT107L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT107L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT107L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT107L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT107L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT107L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT107L_LVB_Msk = 0xff0000

	// LUT107H: Graphic MMU LUT entry 107 high
	// Position of LO field.
	GFXMMU_LUT107H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT107H_LO_Msk = 0x3ffff0

	// LUT108L: Graphic MMU LUT entry 108 low
	// Position of EN field.
	GFXMMU_LUT108L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT108L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT108L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT108L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT108L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT108L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT108L_LVB_Msk = 0xff0000

	// LUT108H: Graphic MMU LUT entry 108 high
	// Position of LO field.
	GFXMMU_LUT108H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT108H_LO_Msk = 0x3ffff0

	// LUT109L: Graphic MMU LUT entry 109 low
	// Position of EN field.
	GFXMMU_LUT109L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT109L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT109L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT109L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT109L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT109L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT109L_LVB_Msk = 0xff0000

	// LUT109H: Graphic MMU LUT entry 109 high
	// Position of LO field.
	GFXMMU_LUT109H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT109H_LO_Msk = 0x3ffff0

	// LUT110L: Graphic MMU LUT entry 110 low
	// Position of EN field.
	GFXMMU_LUT110L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT110L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT110L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT110L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT110L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT110L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT110L_LVB_Msk = 0xff0000

	// LUT110H: Graphic MMU LUT entry 110 high
	// Position of LO field.
	GFXMMU_LUT110H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT110H_LO_Msk = 0x3ffff0

	// LUT111L: Graphic MMU LUT entry 111 low
	// Position of EN field.
	GFXMMU_LUT111L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT111L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT111L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT111L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT111L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT111L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT111L_LVB_Msk = 0xff0000

	// LUT111H: Graphic MMU LUT entry 111 high
	// Position of LO field.
	GFXMMU_LUT111H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT111H_LO_Msk = 0x3ffff0

	// LUT112L: Graphic MMU LUT entry 112 low
	// Position of EN field.
	GFXMMU_LUT112L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT112L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT112L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT112L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT112L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT112L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT112L_LVB_Msk = 0xff0000

	// LUT112H: Graphic MMU LUT entry 112 high
	// Position of LO field.
	GFXMMU_LUT112H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT112H_LO_Msk = 0x3ffff0

	// LUT113L: Graphic MMU LUT entry 113 low
	// Position of EN field.
	GFXMMU_LUT113L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT113L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT113L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT113L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT113L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT113L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT113L_LVB_Msk = 0xff0000

	// LUT113H: Graphic MMU LUT entry 113 high
	// Position of LO field.
	GFXMMU_LUT113H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT113H_LO_Msk = 0x3ffff0

	// LUT114L: Graphic MMU LUT entry 114 low
	// Position of EN field.
	GFXMMU_LUT114L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT114L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT114L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT114L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT114L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT114L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT114L_LVB_Msk = 0xff0000

	// LUT114H: Graphic MMU LUT entry 114 high
	// Position of LO field.
	GFXMMU_LUT114H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT114H_LO_Msk = 0x3ffff0

	// LUT115L: Graphic MMU LUT entry 115 low
	// Position of EN field.
	GFXMMU_LUT115L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT115L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT115L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT115L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT115L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT115L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT115L_LVB_Msk = 0xff0000

	// LUT115H: Graphic MMU LUT entry 115 high
	// Position of LO field.
	GFXMMU_LUT115H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT115H_LO_Msk = 0x3ffff0

	// LUT116L: Graphic MMU LUT entry 116 low
	// Position of EN field.
	GFXMMU_LUT116L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT116L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT116L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT116L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT116L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT116L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT116L_LVB_Msk = 0xff0000

	// LUT116H: Graphic MMU LUT entry 116 high
	// Position of LO field.
	GFXMMU_LUT116H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT116H_LO_Msk = 0x3ffff0

	// LUT117L: Graphic MMU LUT entry 117 low
	// Position of EN field.
	GFXMMU_LUT117L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT117L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT117L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT117L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT117L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT117L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT117L_LVB_Msk = 0xff0000

	// LUT117H: Graphic MMU LUT entry 117 high
	// Position of LO field.
	GFXMMU_LUT117H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT117H_LO_Msk = 0x3ffff0

	// LUT118L: Graphic MMU LUT entry 118 low
	// Position of EN field.
	GFXMMU_LUT118L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT118L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT118L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT118L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT118L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT118L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT118L_LVB_Msk = 0xff0000

	// LUT118H: Graphic MMU LUT entry 118 high
	// Position of LO field.
	GFXMMU_LUT118H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT118H_LO_Msk = 0x3ffff0

	// LUT119L: Graphic MMU LUT entry 119 low
	// Position of EN field.
	GFXMMU_LUT119L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT119L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT119L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT119L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT119L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT119L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT119L_LVB_Msk = 0xff0000

	// LUT119H: Graphic MMU LUT entry 119 high
	// Position of LO field.
	GFXMMU_LUT119H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT119H_LO_Msk = 0x3ffff0

	// LUT120L: Graphic MMU LUT entry 120 low
	// Position of EN field.
	GFXMMU_LUT120L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT120L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT120L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT120L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT120L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT120L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT120L_LVB_Msk = 0xff0000

	// LUT120H: Graphic MMU LUT entry 120 high
	// Position of LO field.
	GFXMMU_LUT120H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT120H_LO_Msk = 0x3ffff0

	// LUT121L: Graphic MMU LUT entry 121 low
	// Position of EN field.
	GFXMMU_LUT121L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT121L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT121L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT121L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT121L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT121L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT121L_LVB_Msk = 0xff0000

	// LUT121H: Graphic MMU LUT entry 121 high
	// Position of LO field.
	GFXMMU_LUT121H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT121H_LO_Msk = 0x3ffff0

	// LUT122L: Graphic MMU LUT entry 122 low
	// Position of EN field.
	GFXMMU_LUT122L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT122L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT122L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT122L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT122L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT122L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT122L_LVB_Msk = 0xff0000

	// LUT122H: Graphic MMU LUT entry 122 high
	// Position of LO field.
	GFXMMU_LUT122H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT122H_LO_Msk = 0x3ffff0

	// LUT123L: Graphic MMU LUT entry 123 low
	// Position of EN field.
	GFXMMU_LUT123L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT123L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT123L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT123L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT123L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT123L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT123L_LVB_Msk = 0xff0000

	// LUT123H: Graphic MMU LUT entry 123 high
	// Position of LO field.
	GFXMMU_LUT123H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT123H_LO_Msk = 0x3ffff0

	// LUT124L: Graphic MMU LUT entry 124 low
	// Position of EN field.
	GFXMMU_LUT124L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT124L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT124L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT124L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT124L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT124L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT124L_LVB_Msk = 0xff0000

	// LUT124H: Graphic MMU LUT entry 124 high
	// Position of LO field.
	GFXMMU_LUT124H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT124H_LO_Msk = 0x3ffff0

	// LUT125L: Graphic MMU LUT entry 125 low
	// Position of EN field.
	GFXMMU_LUT125L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT125L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT125L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT125L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT125L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT125L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT125L_LVB_Msk = 0xff0000

	// LUT125H: Graphic MMU LUT entry 125 high
	// Position of LO field.
	GFXMMU_LUT125H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT125H_LO_Msk = 0x3ffff0

	// LUT126L: Graphic MMU LUT entry 126 low
	// Position of EN field.
	GFXMMU_LUT126L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT126L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT126L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT126L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT126L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT126L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT126L_LVB_Msk = 0xff0000

	// LUT126H: Graphic MMU LUT entry 126 high
	// Position of LO field.
	GFXMMU_LUT126H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT126H_LO_Msk = 0x3ffff0

	// LUT127L: Graphic MMU LUT entry 127 low
	// Position of EN field.
	GFXMMU_LUT127L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT127L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT127L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT127L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT127L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT127L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT127L_LVB_Msk = 0xff0000

	// LUT127H: Graphic MMU LUT entry 127 high
	// Position of LO field.
	GFXMMU_LUT127H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT127H_LO_Msk = 0x3ffff0

	// LUT128L: Graphic MMU LUT entry 128 low
	// Position of EN field.
	GFXMMU_LUT128L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT128L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT128L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT128L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT128L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT128L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT128L_LVB_Msk = 0xff0000

	// LUT128H: Graphic MMU LUT entry 128 high
	// Position of LO field.
	GFXMMU_LUT128H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT128H_LO_Msk = 0x3ffff0

	// LUT129L: Graphic MMU LUT entry 129 low
	// Position of EN field.
	GFXMMU_LUT129L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT129L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT129L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT129L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT129L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT129L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT129L_LVB_Msk = 0xff0000

	// LUT129H: Graphic MMU LUT entry 129 high
	// Position of LO field.
	GFXMMU_LUT129H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT129H_LO_Msk = 0x3ffff0

	// LUT130L: Graphic MMU LUT entry 130 low
	// Position of EN field.
	GFXMMU_LUT130L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT130L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT130L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT130L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT130L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT130L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT130L_LVB_Msk = 0xff0000

	// LUT130H: Graphic MMU LUT entry 130 high
	// Position of LO field.
	GFXMMU_LUT130H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT130H_LO_Msk = 0x3ffff0

	// LUT131L: Graphic MMU LUT entry 131 low
	// Position of EN field.
	GFXMMU_LUT131L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT131L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT131L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT131L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT131L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT131L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT131L_LVB_Msk = 0xff0000

	// LUT131H: Graphic MMU LUT entry 131 high
	// Position of LO field.
	GFXMMU_LUT131H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT131H_LO_Msk = 0x3ffff0

	// LUT132L: Graphic MMU LUT entry 132 low
	// Position of EN field.
	GFXMMU_LUT132L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT132L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT132L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT132L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT132L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT132L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT132L_LVB_Msk = 0xff0000

	// LUT132H: Graphic MMU LUT entry 132 high
	// Position of LO field.
	GFXMMU_LUT132H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT132H_LO_Msk = 0x3ffff0

	// LUT133L: Graphic MMU LUT entry 133 low
	// Position of EN field.
	GFXMMU_LUT133L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT133L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT133L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT133L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT133L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT133L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT133L_LVB_Msk = 0xff0000

	// LUT133H: Graphic MMU LUT entry 133 high
	// Position of LO field.
	GFXMMU_LUT133H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT133H_LO_Msk = 0x3ffff0

	// LUT134L: Graphic MMU LUT entry 134 low
	// Position of EN field.
	GFXMMU_LUT134L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT134L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT134L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT134L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT134L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT134L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT134L_LVB_Msk = 0xff0000

	// LUT134H: Graphic MMU LUT entry 134 high
	// Position of LO field.
	GFXMMU_LUT134H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT134H_LO_Msk = 0x3ffff0

	// LUT135L: Graphic MMU LUT entry 135 low
	// Position of EN field.
	GFXMMU_LUT135L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT135L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT135L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT135L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT135L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT135L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT135L_LVB_Msk = 0xff0000

	// LUT135H: Graphic MMU LUT entry 135 high
	// Position of LO field.
	GFXMMU_LUT135H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT135H_LO_Msk = 0x3ffff0

	// LUT136L: Graphic MMU LUT entry 136 low
	// Position of EN field.
	GFXMMU_LUT136L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT136L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT136L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT136L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT136L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT136L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT136L_LVB_Msk = 0xff0000

	// LUT136H: Graphic MMU LUT entry 136 high
	// Position of LO field.
	GFXMMU_LUT136H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT136H_LO_Msk = 0x3ffff0

	// LUT137L: Graphic MMU LUT entry 137 low
	// Position of EN field.
	GFXMMU_LUT137L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT137L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT137L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT137L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT137L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT137L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT137L_LVB_Msk = 0xff0000

	// LUT137H: Graphic MMU LUT entry 137 high
	// Position of LO field.
	GFXMMU_LUT137H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT137H_LO_Msk = 0x3ffff0

	// LUT138L: Graphic MMU LUT entry 138 low
	// Position of EN field.
	GFXMMU_LUT138L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT138L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT138L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT138L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT138L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT138L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT138L_LVB_Msk = 0xff0000

	// LUT138H: Graphic MMU LUT entry 138 high
	// Position of LO field.
	GFXMMU_LUT138H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT138H_LO_Msk = 0x3ffff0

	// LUT139L: Graphic MMU LUT entry 139 low
	// Position of EN field.
	GFXMMU_LUT139L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT139L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT139L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT139L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT139L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT139L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT139L_LVB_Msk = 0xff0000

	// LUT139H: Graphic MMU LUT entry 139 high
	// Position of LO field.
	GFXMMU_LUT139H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT139H_LO_Msk = 0x3ffff0

	// LUT140L: Graphic MMU LUT entry 140 low
	// Position of EN field.
	GFXMMU_LUT140L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT140L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT140L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT140L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT140L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT140L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT140L_LVB_Msk = 0xff0000

	// LUT140H: Graphic MMU LUT entry 140 high
	// Position of LO field.
	GFXMMU_LUT140H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT140H_LO_Msk = 0x3ffff0

	// LUT141L: Graphic MMU LUT entry 141 low
	// Position of EN field.
	GFXMMU_LUT141L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT141L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT141L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT141L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT141L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT141L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT141L_LVB_Msk = 0xff0000

	// LUT141H: Graphic MMU LUT entry 141 high
	// Position of LO field.
	GFXMMU_LUT141H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT141H_LO_Msk = 0x3ffff0

	// LUT142L: Graphic MMU LUT entry 142 low
	// Position of EN field.
	GFXMMU_LUT142L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT142L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT142L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT142L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT142L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT142L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT142L_LVB_Msk = 0xff0000

	// LUT142H: Graphic MMU LUT entry 142 high
	// Position of LO field.
	GFXMMU_LUT142H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT142H_LO_Msk = 0x3ffff0

	// LUT143L: Graphic MMU LUT entry 143 low
	// Position of EN field.
	GFXMMU_LUT143L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT143L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT143L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT143L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT143L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT143L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT143L_LVB_Msk = 0xff0000

	// LUT143H: Graphic MMU LUT entry 143 high
	// Position of LO field.
	GFXMMU_LUT143H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT143H_LO_Msk = 0x3ffff0

	// LUT144L: Graphic MMU LUT entry 144 low
	// Position of EN field.
	GFXMMU_LUT144L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT144L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT144L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT144L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT144L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT144L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT144L_LVB_Msk = 0xff0000

	// LUT144H: Graphic MMU LUT entry 144 high
	// Position of LO field.
	GFXMMU_LUT144H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT144H_LO_Msk = 0x3ffff0

	// LUT145L: Graphic MMU LUT entry 145 low
	// Position of EN field.
	GFXMMU_LUT145L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT145L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT145L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT145L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT145L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT145L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT145L_LVB_Msk = 0xff0000

	// LUT145H: Graphic MMU LUT entry 145 high
	// Position of LO field.
	GFXMMU_LUT145H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT145H_LO_Msk = 0x3ffff0

	// LUT146L: Graphic MMU LUT entry 146 low
	// Position of EN field.
	GFXMMU_LUT146L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT146L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT146L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT146L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT146L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT146L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT146L_LVB_Msk = 0xff0000

	// LUT146H: Graphic MMU LUT entry 146 high
	// Position of LO field.
	GFXMMU_LUT146H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT146H_LO_Msk = 0x3ffff0

	// LUT147L: Graphic MMU LUT entry 147 low
	// Position of EN field.
	GFXMMU_LUT147L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT147L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT147L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT147L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT147L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT147L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT147L_LVB_Msk = 0xff0000

	// LUT147H: Graphic MMU LUT entry 147 high
	// Position of LO field.
	GFXMMU_LUT147H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT147H_LO_Msk = 0x3ffff0

	// LUT148L: Graphic MMU LUT entry 148 low
	// Position of EN field.
	GFXMMU_LUT148L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT148L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT148L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT148L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT148L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT148L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT148L_LVB_Msk = 0xff0000

	// LUT148H: Graphic MMU LUT entry 148 high
	// Position of LO field.
	GFXMMU_LUT148H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT148H_LO_Msk = 0x3ffff0

	// LUT149L: Graphic MMU LUT entry 149 low
	// Position of EN field.
	GFXMMU_LUT149L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT149L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT149L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT149L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT149L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT149L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT149L_LVB_Msk = 0xff0000

	// LUT149H: Graphic MMU LUT entry 149 high
	// Position of LO field.
	GFXMMU_LUT149H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT149H_LO_Msk = 0x3ffff0

	// LUT150L: Graphic MMU LUT entry 150 low
	// Position of EN field.
	GFXMMU_LUT150L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT150L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT150L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT150L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT150L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT150L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT150L_LVB_Msk = 0xff0000

	// LUT150H: Graphic MMU LUT entry 150 high
	// Position of LO field.
	GFXMMU_LUT150H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT150H_LO_Msk = 0x3ffff0

	// LUT151L: Graphic MMU LUT entry 151 low
	// Position of EN field.
	GFXMMU_LUT151L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT151L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT151L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT151L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT151L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT151L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT151L_LVB_Msk = 0xff0000

	// LUT151H: Graphic MMU LUT entry 151 high
	// Position of LO field.
	GFXMMU_LUT151H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT151H_LO_Msk = 0x3ffff0

	// LUT152L: Graphic MMU LUT entry 152 low
	// Position of EN field.
	GFXMMU_LUT152L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT152L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT152L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT152L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT152L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT152L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT152L_LVB_Msk = 0xff0000

	// LUT152H: Graphic MMU LUT entry 152 high
	// Position of LO field.
	GFXMMU_LUT152H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT152H_LO_Msk = 0x3ffff0

	// LUT153L: Graphic MMU LUT entry 153 low
	// Position of EN field.
	GFXMMU_LUT153L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT153L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT153L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT153L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT153L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT153L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT153L_LVB_Msk = 0xff0000

	// LUT153H: Graphic MMU LUT entry 153 high
	// Position of LO field.
	GFXMMU_LUT153H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT153H_LO_Msk = 0x3ffff0

	// LUT154L: Graphic MMU LUT entry 154 low
	// Position of EN field.
	GFXMMU_LUT154L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT154L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT154L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT154L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT154L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT154L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT154L_LVB_Msk = 0xff0000

	// LUT154H: Graphic MMU LUT entry 154 high
	// Position of LO field.
	GFXMMU_LUT154H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT154H_LO_Msk = 0x3ffff0

	// LUT155L: Graphic MMU LUT entry 155 low
	// Position of EN field.
	GFXMMU_LUT155L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT155L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT155L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT155L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT155L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT155L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT155L_LVB_Msk = 0xff0000

	// LUT155H: Graphic MMU LUT entry 155 high
	// Position of LO field.
	GFXMMU_LUT155H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT155H_LO_Msk = 0x3ffff0

	// LUT156L: Graphic MMU LUT entry 156 low
	// Position of EN field.
	GFXMMU_LUT156L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT156L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT156L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT156L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT156L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT156L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT156L_LVB_Msk = 0xff0000

	// LUT156H: Graphic MMU LUT entry 156 high
	// Position of LO field.
	GFXMMU_LUT156H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT156H_LO_Msk = 0x3ffff0

	// LUT157L: Graphic MMU LUT entry 157 low
	// Position of EN field.
	GFXMMU_LUT157L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT157L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT157L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT157L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT157L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT157L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT157L_LVB_Msk = 0xff0000

	// LUT157H: Graphic MMU LUT entry 157 high
	// Position of LO field.
	GFXMMU_LUT157H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT157H_LO_Msk = 0x3ffff0

	// LUT158L: Graphic MMU LUT entry 158 low
	// Position of EN field.
	GFXMMU_LUT158L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT158L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT158L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT158L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT158L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT158L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT158L_LVB_Msk = 0xff0000

	// LUT158H: Graphic MMU LUT entry 158 high
	// Position of LO field.
	GFXMMU_LUT158H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT158H_LO_Msk = 0x3ffff0

	// LUT159L: Graphic MMU LUT entry 159 low
	// Position of EN field.
	GFXMMU_LUT159L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT159L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT159L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT159L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT159L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT159L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT159L_LVB_Msk = 0xff0000

	// LUT159H: Graphic MMU LUT entry 159 high
	// Position of LO field.
	GFXMMU_LUT159H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT159H_LO_Msk = 0x3ffff0

	// LUT160L: Graphic MMU LUT entry 160 low
	// Position of EN field.
	GFXMMU_LUT160L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT160L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT160L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT160L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT160L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT160L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT160L_LVB_Msk = 0xff0000

	// LUT160H: Graphic MMU LUT entry 160 high
	// Position of LO field.
	GFXMMU_LUT160H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT160H_LO_Msk = 0x3ffff0

	// LUT161L: Graphic MMU LUT entry 161 low
	// Position of EN field.
	GFXMMU_LUT161L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT161L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT161L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT161L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT161L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT161L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT161L_LVB_Msk = 0xff0000

	// LUT161H: Graphic MMU LUT entry 161 high
	// Position of LO field.
	GFXMMU_LUT161H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT161H_LO_Msk = 0x3ffff0

	// LUT162L: Graphic MMU LUT entry 162 low
	// Position of EN field.
	GFXMMU_LUT162L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT162L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT162L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT162L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT162L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT162L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT162L_LVB_Msk = 0xff0000

	// LUT162H: Graphic MMU LUT entry 162 high
	// Position of LO field.
	GFXMMU_LUT162H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT162H_LO_Msk = 0x3ffff0

	// LUT163L: Graphic MMU LUT entry 163 low
	// Position of EN field.
	GFXMMU_LUT163L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT163L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT163L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT163L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT163L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT163L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT163L_LVB_Msk = 0xff0000

	// LUT163H: Graphic MMU LUT entry 163 high
	// Position of LO field.
	GFXMMU_LUT163H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT163H_LO_Msk = 0x3ffff0

	// LUT164L: Graphic MMU LUT entry 164 low
	// Position of EN field.
	GFXMMU_LUT164L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT164L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT164L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT164L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT164L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT164L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT164L_LVB_Msk = 0xff0000

	// LUT164H: Graphic MMU LUT entry 164 high
	// Position of LO field.
	GFXMMU_LUT164H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT164H_LO_Msk = 0x3ffff0

	// LUT165L: Graphic MMU LUT entry 165 low
	// Position of EN field.
	GFXMMU_LUT165L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT165L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT165L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT165L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT165L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT165L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT165L_LVB_Msk = 0xff0000

	// LUT165H: Graphic MMU LUT entry 165 high
	// Position of LO field.
	GFXMMU_LUT165H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT165H_LO_Msk = 0x3ffff0

	// LUT166L: Graphic MMU LUT entry 166 low
	// Position of EN field.
	GFXMMU_LUT166L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT166L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT166L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT166L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT166L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT166L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT166L_LVB_Msk = 0xff0000

	// LUT166H: Graphic MMU LUT entry 166 high
	// Position of LO field.
	GFXMMU_LUT166H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT166H_LO_Msk = 0x3ffff0

	// LUT167L: Graphic MMU LUT entry 167 low
	// Position of EN field.
	GFXMMU_LUT167L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT167L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT167L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT167L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT167L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT167L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT167L_LVB_Msk = 0xff0000

	// LUT167H: Graphic MMU LUT entry 167 high
	// Position of LO field.
	GFXMMU_LUT167H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT167H_LO_Msk = 0x3ffff0

	// LUT168L: Graphic MMU LUT entry 168 low
	// Position of EN field.
	GFXMMU_LUT168L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT168L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT168L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT168L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT168L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT168L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT168L_LVB_Msk = 0xff0000

	// LUT168H: Graphic MMU LUT entry 168 high
	// Position of LO field.
	GFXMMU_LUT168H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT168H_LO_Msk = 0x3ffff0

	// LUT169L: Graphic MMU LUT entry 169 low
	// Position of EN field.
	GFXMMU_LUT169L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT169L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT169L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT169L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT169L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT169L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT169L_LVB_Msk = 0xff0000

	// LUT169H: Graphic MMU LUT entry 169 high
	// Position of LO field.
	GFXMMU_LUT169H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT169H_LO_Msk = 0x3ffff0

	// LUT170L: Graphic MMU LUT entry 170 low
	// Position of EN field.
	GFXMMU_LUT170L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT170L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT170L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT170L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT170L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT170L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT170L_LVB_Msk = 0xff0000

	// LUT170H: Graphic MMU LUT entry 170 high
	// Position of LO field.
	GFXMMU_LUT170H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT170H_LO_Msk = 0x3ffff0

	// LUT171L: Graphic MMU LUT entry 171 low
	// Position of EN field.
	GFXMMU_LUT171L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT171L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT171L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT171L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT171L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT171L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT171L_LVB_Msk = 0xff0000

	// LUT171H: Graphic MMU LUT entry 171 high
	// Position of LO field.
	GFXMMU_LUT171H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT171H_LO_Msk = 0x3ffff0

	// LUT172L: Graphic MMU LUT entry 172 low
	// Position of EN field.
	GFXMMU_LUT172L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT172L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT172L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT172L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT172L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT172L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT172L_LVB_Msk = 0xff0000

	// LUT172H: Graphic MMU LUT entry 172 high
	// Position of LO field.
	GFXMMU_LUT172H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT172H_LO_Msk = 0x3ffff0

	// LUT173L: Graphic MMU LUT entry 173 low
	// Position of EN field.
	GFXMMU_LUT173L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT173L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT173L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT173L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT173L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT173L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT173L_LVB_Msk = 0xff0000

	// LUT173H: Graphic MMU LUT entry 173 high
	// Position of LO field.
	GFXMMU_LUT173H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT173H_LO_Msk = 0x3ffff0

	// LUT174L: Graphic MMU LUT entry 174 low
	// Position of EN field.
	GFXMMU_LUT174L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT174L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT174L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT174L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT174L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT174L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT174L_LVB_Msk = 0xff0000

	// LUT174H: Graphic MMU LUT entry 174 high
	// Position of LO field.
	GFXMMU_LUT174H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT174H_LO_Msk = 0x3ffff0

	// LUT175L: Graphic MMU LUT entry 175 low
	// Position of EN field.
	GFXMMU_LUT175L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT175L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT175L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT175L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT175L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT175L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT175L_LVB_Msk = 0xff0000

	// LUT175H: Graphic MMU LUT entry 175 high
	// Position of LO field.
	GFXMMU_LUT175H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT175H_LO_Msk = 0x3ffff0

	// LUT176L: Graphic MMU LUT entry 176 low
	// Position of EN field.
	GFXMMU_LUT176L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT176L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT176L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT176L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT176L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT176L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT176L_LVB_Msk = 0xff0000

	// LUT176H: Graphic MMU LUT entry 176 high
	// Position of LO field.
	GFXMMU_LUT176H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT176H_LO_Msk = 0x3ffff0

	// LUT177L: Graphic MMU LUT entry 177 low
	// Position of EN field.
	GFXMMU_LUT177L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT177L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT177L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT177L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT177L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT177L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT177L_LVB_Msk = 0xff0000

	// LUT177H: Graphic MMU LUT entry 177 high
	// Position of LO field.
	GFXMMU_LUT177H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT177H_LO_Msk = 0x3ffff0

	// LUT178L: Graphic MMU LUT entry 178 low
	// Position of EN field.
	GFXMMU_LUT178L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT178L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT178L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT178L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT178L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT178L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT178L_LVB_Msk = 0xff0000

	// LUT178H: Graphic MMU LUT entry 178 high
	// Position of LO field.
	GFXMMU_LUT178H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT178H_LO_Msk = 0x3ffff0

	// LUT179L: Graphic MMU LUT entry 179 low
	// Position of EN field.
	GFXMMU_LUT179L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT179L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT179L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT179L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT179L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT179L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT179L_LVB_Msk = 0xff0000

	// LUT179H: Graphic MMU LUT entry 179 high
	// Position of LO field.
	GFXMMU_LUT179H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT179H_LO_Msk = 0x3ffff0

	// LUT180L: Graphic MMU LUT entry 180 low
	// Position of EN field.
	GFXMMU_LUT180L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT180L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT180L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT180L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT180L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT180L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT180L_LVB_Msk = 0xff0000

	// LUT180H: Graphic MMU LUT entry 180 high
	// Position of LO field.
	GFXMMU_LUT180H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT180H_LO_Msk = 0x3ffff0

	// LUT181L: Graphic MMU LUT entry 181 low
	// Position of EN field.
	GFXMMU_LUT181L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT181L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT181L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT181L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT181L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT181L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT181L_LVB_Msk = 0xff0000

	// LUT181H: Graphic MMU LUT entry 181 high
	// Position of LO field.
	GFXMMU_LUT181H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT181H_LO_Msk = 0x3ffff0

	// LUT182L: Graphic MMU LUT entry 182 low
	// Position of EN field.
	GFXMMU_LUT182L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT182L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT182L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT182L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT182L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT182L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT182L_LVB_Msk = 0xff0000

	// LUT182H: Graphic MMU LUT entry 182 high
	// Position of LO field.
	GFXMMU_LUT182H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT182H_LO_Msk = 0x3ffff0

	// LUT183L: Graphic MMU LUT entry 183 low
	// Position of EN field.
	GFXMMU_LUT183L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT183L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT183L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT183L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT183L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT183L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT183L_LVB_Msk = 0xff0000

	// LUT183H: Graphic MMU LUT entry 183 high
	// Position of LO field.
	GFXMMU_LUT183H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT183H_LO_Msk = 0x3ffff0

	// LUT184L: Graphic MMU LUT entry 184 low
	// Position of EN field.
	GFXMMU_LUT184L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT184L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT184L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT184L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT184L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT184L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT184L_LVB_Msk = 0xff0000

	// LUT184H: Graphic MMU LUT entry 184 high
	// Position of LO field.
	GFXMMU_LUT184H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT184H_LO_Msk = 0x3ffff0

	// LUT185L: Graphic MMU LUT entry 185 low
	// Position of EN field.
	GFXMMU_LUT185L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT185L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT185L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT185L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT185L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT185L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT185L_LVB_Msk = 0xff0000

	// LUT185H: Graphic MMU LUT entry 185 high
	// Position of LO field.
	GFXMMU_LUT185H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT185H_LO_Msk = 0x3ffff0

	// LUT186L: Graphic MMU LUT entry 186 low
	// Position of EN field.
	GFXMMU_LUT186L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT186L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT186L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT186L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT186L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT186L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT186L_LVB_Msk = 0xff0000

	// LUT186H: Graphic MMU LUT entry 186 high
	// Position of LO field.
	GFXMMU_LUT186H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT186H_LO_Msk = 0x3ffff0

	// LUT187L: Graphic MMU LUT entry 187 low
	// Position of EN field.
	GFXMMU_LUT187L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT187L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT187L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT187L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT187L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT187L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT187L_LVB_Msk = 0xff0000

	// LUT187H: Graphic MMU LUT entry 187 high
	// Position of LO field.
	GFXMMU_LUT187H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT187H_LO_Msk = 0x3ffff0

	// LUT188L: Graphic MMU LUT entry 188 low
	// Position of EN field.
	GFXMMU_LUT188L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT188L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT188L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT188L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT188L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT188L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT188L_LVB_Msk = 0xff0000

	// LUT188H: Graphic MMU LUT entry 188 high
	// Position of LO field.
	GFXMMU_LUT188H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT188H_LO_Msk = 0x3ffff0

	// LUT189L: Graphic MMU LUT entry 189 low
	// Position of EN field.
	GFXMMU_LUT189L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT189L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT189L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT189L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT189L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT189L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT189L_LVB_Msk = 0xff0000

	// LUT189H: Graphic MMU LUT entry 189 high
	// Position of LO field.
	GFXMMU_LUT189H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT189H_LO_Msk = 0x3ffff0

	// LUT190L: Graphic MMU LUT entry 190 low
	// Position of EN field.
	GFXMMU_LUT190L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT190L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT190L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT190L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT190L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT190L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT190L_LVB_Msk = 0xff0000

	// LUT190H: Graphic MMU LUT entry 190 high
	// Position of LO field.
	GFXMMU_LUT190H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT190H_LO_Msk = 0x3ffff0

	// LUT191L: Graphic MMU LUT entry 191 low
	// Position of EN field.
	GFXMMU_LUT191L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT191L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT191L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT191L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT191L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT191L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT191L_LVB_Msk = 0xff0000

	// LUT191H: Graphic MMU LUT entry 191 high
	// Position of LO field.
	GFXMMU_LUT191H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT191H_LO_Msk = 0x3ffff0

	// LUT192L: Graphic MMU LUT entry 192 low
	// Position of EN field.
	GFXMMU_LUT192L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT192L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT192L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT192L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT192L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT192L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT192L_LVB_Msk = 0xff0000

	// LUT192H: Graphic MMU LUT entry 192 high
	// Position of LO field.
	GFXMMU_LUT192H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT192H_LO_Msk = 0x3ffff0

	// LUT193L: Graphic MMU LUT entry 193 low
	// Position of EN field.
	GFXMMU_LUT193L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT193L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT193L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT193L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT193L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT193L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT193L_LVB_Msk = 0xff0000

	// LUT193H: Graphic MMU LUT entry 193 high
	// Position of LO field.
	GFXMMU_LUT193H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT193H_LO_Msk = 0x3ffff0

	// LUT194L: Graphic MMU LUT entry 194 low
	// Position of EN field.
	GFXMMU_LUT194L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT194L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT194L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT194L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT194L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT194L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT194L_LVB_Msk = 0xff0000

	// LUT194H: Graphic MMU LUT entry 194 high
	// Position of LO field.
	GFXMMU_LUT194H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT194H_LO_Msk = 0x3ffff0

	// LUT195L: Graphic MMU LUT entry 195 low
	// Position of EN field.
	GFXMMU_LUT195L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT195L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT195L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT195L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT195L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT195L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT195L_LVB_Msk = 0xff0000

	// LUT195H: Graphic MMU LUT entry 195 high
	// Position of LO field.
	GFXMMU_LUT195H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT195H_LO_Msk = 0x3ffff0

	// LUT196L: Graphic MMU LUT entry 196 low
	// Position of EN field.
	GFXMMU_LUT196L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT196L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT196L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT196L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT196L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT196L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT196L_LVB_Msk = 0xff0000

	// LUT196H: Graphic MMU LUT entry 196 high
	// Position of LO field.
	GFXMMU_LUT196H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT196H_LO_Msk = 0x3ffff0

	// LUT197L: Graphic MMU LUT entry 197 low
	// Position of EN field.
	GFXMMU_LUT197L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT197L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT197L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT197L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT197L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT197L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT197L_LVB_Msk = 0xff0000

	// LUT197H: Graphic MMU LUT entry 197 high
	// Position of LO field.
	GFXMMU_LUT197H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT197H_LO_Msk = 0x3ffff0

	// LUT198L: Graphic MMU LUT entry 198 low
	// Position of EN field.
	GFXMMU_LUT198L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT198L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT198L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT198L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT198L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT198L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT198L_LVB_Msk = 0xff0000

	// LUT198H: Graphic MMU LUT entry 198 high
	// Position of LO field.
	GFXMMU_LUT198H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT198H_LO_Msk = 0x3ffff0

	// LUT199L: Graphic MMU LUT entry 199 low
	// Position of EN field.
	GFXMMU_LUT199L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT199L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT199L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT199L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT199L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT199L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT199L_LVB_Msk = 0xff0000

	// LUT199H: Graphic MMU LUT entry 199 high
	// Position of LO field.
	GFXMMU_LUT199H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT199H_LO_Msk = 0x3ffff0

	// LUT200L: Graphic MMU LUT entry 200 low
	// Position of EN field.
	GFXMMU_LUT200L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT200L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT200L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT200L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT200L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT200L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT200L_LVB_Msk = 0xff0000

	// LUT200H: Graphic MMU LUT entry 200 high
	// Position of LO field.
	GFXMMU_LUT200H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT200H_LO_Msk = 0x3ffff0

	// LUT201L: Graphic MMU LUT entry 201 low
	// Position of EN field.
	GFXMMU_LUT201L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT201L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT201L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT201L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT201L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT201L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT201L_LVB_Msk = 0xff0000

	// LUT201H: Graphic MMU LUT entry 201 high
	// Position of LO field.
	GFXMMU_LUT201H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT201H_LO_Msk = 0x3ffff0

	// LUT202L: Graphic MMU LUT entry 202 low
	// Position of EN field.
	GFXMMU_LUT202L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT202L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT202L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT202L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT202L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT202L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT202L_LVB_Msk = 0xff0000

	// LUT202H: Graphic MMU LUT entry 202 high
	// Position of LO field.
	GFXMMU_LUT202H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT202H_LO_Msk = 0x3ffff0

	// LUT203L: Graphic MMU LUT entry 203 low
	// Position of EN field.
	GFXMMU_LUT203L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT203L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT203L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT203L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT203L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT203L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT203L_LVB_Msk = 0xff0000

	// LUT203H: Graphic MMU LUT entry 203 high
	// Position of LO field.
	GFXMMU_LUT203H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT203H_LO_Msk = 0x3ffff0

	// LUT204L: Graphic MMU LUT entry 204 low
	// Position of EN field.
	GFXMMU_LUT204L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT204L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT204L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT204L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT204L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT204L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT204L_LVB_Msk = 0xff0000

	// LUT204H: Graphic MMU LUT entry 204 high
	// Position of LO field.
	GFXMMU_LUT204H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT204H_LO_Msk = 0x3ffff0

	// LUT205L: Graphic MMU LUT entry 205 low
	// Position of EN field.
	GFXMMU_LUT205L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT205L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT205L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT205L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT205L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT205L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT205L_LVB_Msk = 0xff0000

	// LUT205H: Graphic MMU LUT entry 205 high
	// Position of LO field.
	GFXMMU_LUT205H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT205H_LO_Msk = 0x3ffff0

	// LUT206L: Graphic MMU LUT entry 206 low
	// Position of EN field.
	GFXMMU_LUT206L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT206L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT206L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT206L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT206L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT206L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT206L_LVB_Msk = 0xff0000

	// LUT206H: Graphic MMU LUT entry 206 high
	// Position of LO field.
	GFXMMU_LUT206H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT206H_LO_Msk = 0x3ffff0

	// LUT207L: Graphic MMU LUT entry 207 low
	// Position of EN field.
	GFXMMU_LUT207L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT207L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT207L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT207L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT207L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT207L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT207L_LVB_Msk = 0xff0000

	// LUT207H: Graphic MMU LUT entry 207 high
	// Position of LO field.
	GFXMMU_LUT207H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT207H_LO_Msk = 0x3ffff0

	// LUT208L: Graphic MMU LUT entry 208 low
	// Position of EN field.
	GFXMMU_LUT208L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT208L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT208L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT208L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT208L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT208L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT208L_LVB_Msk = 0xff0000

	// LUT208H: Graphic MMU LUT entry 208 high
	// Position of LO field.
	GFXMMU_LUT208H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT208H_LO_Msk = 0x3ffff0

	// LUT209L: Graphic MMU LUT entry 209 low
	// Position of EN field.
	GFXMMU_LUT209L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT209L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT209L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT209L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT209L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT209L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT209L_LVB_Msk = 0xff0000

	// LUT209H: Graphic MMU LUT entry 209 high
	// Position of LO field.
	GFXMMU_LUT209H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT209H_LO_Msk = 0x3ffff0

	// LUT210L: Graphic MMU LUT entry 210 low
	// Position of EN field.
	GFXMMU_LUT210L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT210L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT210L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT210L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT210L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT210L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT210L_LVB_Msk = 0xff0000

	// LUT210H: Graphic MMU LUT entry 210 high
	// Position of LO field.
	GFXMMU_LUT210H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT210H_LO_Msk = 0x3ffff0

	// LUT211L: Graphic MMU LUT entry 211 low
	// Position of EN field.
	GFXMMU_LUT211L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT211L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT211L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT211L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT211L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT211L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT211L_LVB_Msk = 0xff0000

	// LUT211H: Graphic MMU LUT entry 211 high
	// Position of LO field.
	GFXMMU_LUT211H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT211H_LO_Msk = 0x3ffff0

	// LUT212L: Graphic MMU LUT entry 212 low
	// Position of EN field.
	GFXMMU_LUT212L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT212L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT212L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT212L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT212L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT212L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT212L_LVB_Msk = 0xff0000

	// LUT212H: Graphic MMU LUT entry 212 high
	// Position of LO field.
	GFXMMU_LUT212H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT212H_LO_Msk = 0x3ffff0

	// LUT213L: Graphic MMU LUT entry 213 low
	// Position of EN field.
	GFXMMU_LUT213L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT213L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT213L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT213L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT213L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT213L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT213L_LVB_Msk = 0xff0000

	// LUT213H: Graphic MMU LUT entry 213 high
	// Position of LO field.
	GFXMMU_LUT213H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT213H_LO_Msk = 0x3ffff0

	// LUT214L: Graphic MMU LUT entry 214 low
	// Position of EN field.
	GFXMMU_LUT214L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT214L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT214L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT214L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT214L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT214L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT214L_LVB_Msk = 0xff0000

	// LUT214H: Graphic MMU LUT entry 214 high
	// Position of LO field.
	GFXMMU_LUT214H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT214H_LO_Msk = 0x3ffff0

	// LUT215L: Graphic MMU LUT entry 215 low
	// Position of EN field.
	GFXMMU_LUT215L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT215L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT215L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT215L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT215L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT215L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT215L_LVB_Msk = 0xff0000

	// LUT215H: Graphic MMU LUT entry 215 high
	// Position of LO field.
	GFXMMU_LUT215H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT215H_LO_Msk = 0x3ffff0

	// LUT216L: Graphic MMU LUT entry 216 low
	// Position of EN field.
	GFXMMU_LUT216L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT216L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT216L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT216L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT216L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT216L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT216L_LVB_Msk = 0xff0000

	// LUT216H: Graphic MMU LUT entry 216 high
	// Position of LO field.
	GFXMMU_LUT216H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT216H_LO_Msk = 0x3ffff0

	// LUT217L: Graphic MMU LUT entry 217 low
	// Position of EN field.
	GFXMMU_LUT217L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT217L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT217L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT217L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT217L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT217L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT217L_LVB_Msk = 0xff0000

	// LUT217H: Graphic MMU LUT entry 217 high
	// Position of LO field.
	GFXMMU_LUT217H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT217H_LO_Msk = 0x3ffff0

	// LUT218L: Graphic MMU LUT entry 218 low
	// Position of EN field.
	GFXMMU_LUT218L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT218L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT218L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT218L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT218L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT218L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT218L_LVB_Msk = 0xff0000

	// LUT218H: Graphic MMU LUT entry 218 high
	// Position of LO field.
	GFXMMU_LUT218H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT218H_LO_Msk = 0x3ffff0

	// LUT219L: Graphic MMU LUT entry 219 low
	// Position of EN field.
	GFXMMU_LUT219L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT219L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT219L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT219L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT219L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT219L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT219L_LVB_Msk = 0xff0000

	// LUT219H: Graphic MMU LUT entry 219 high
	// Position of LO field.
	GFXMMU_LUT219H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT219H_LO_Msk = 0x3ffff0

	// LUT220L: Graphic MMU LUT entry 220 low
	// Position of EN field.
	GFXMMU_LUT220L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT220L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT220L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT220L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT220L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT220L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT220L_LVB_Msk = 0xff0000

	// LUT220H: Graphic MMU LUT entry 220 high
	// Position of LO field.
	GFXMMU_LUT220H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT220H_LO_Msk = 0x3ffff0

	// LUT221L: Graphic MMU LUT entry 221 low
	// Position of EN field.
	GFXMMU_LUT221L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT221L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT221L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT221L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT221L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT221L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT221L_LVB_Msk = 0xff0000

	// LUT221H: Graphic MMU LUT entry 221 high
	// Position of LO field.
	GFXMMU_LUT221H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT221H_LO_Msk = 0x3ffff0

	// LUT222L: Graphic MMU LUT entry 222 low
	// Position of EN field.
	GFXMMU_LUT222L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT222L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT222L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT222L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT222L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT222L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT222L_LVB_Msk = 0xff0000

	// LUT222H: Graphic MMU LUT entry 222 high
	// Position of LO field.
	GFXMMU_LUT222H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT222H_LO_Msk = 0x3ffff0

	// LUT223L: Graphic MMU LUT entry 223 low
	// Position of EN field.
	GFXMMU_LUT223L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT223L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT223L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT223L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT223L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT223L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT223L_LVB_Msk = 0xff0000

	// LUT223H: Graphic MMU LUT entry 223 high
	// Position of LO field.
	GFXMMU_LUT223H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT223H_LO_Msk = 0x3ffff0

	// LUT224L: Graphic MMU LUT entry 224 low
	// Position of EN field.
	GFXMMU_LUT224L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT224L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT224L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT224L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT224L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT224L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT224L_LVB_Msk = 0xff0000

	// LUT224H: Graphic MMU LUT entry 224 high
	// Position of LO field.
	GFXMMU_LUT224H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT224H_LO_Msk = 0x3ffff0

	// LUT225L: Graphic MMU LUT entry 225 low
	// Position of EN field.
	GFXMMU_LUT225L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT225L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT225L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT225L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT225L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT225L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT225L_LVB_Msk = 0xff0000

	// LUT225H: Graphic MMU LUT entry 225 high
	// Position of LO field.
	GFXMMU_LUT225H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT225H_LO_Msk = 0x3ffff0

	// LUT226L: Graphic MMU LUT entry 226 low
	// Position of EN field.
	GFXMMU_LUT226L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT226L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT226L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT226L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT226L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT226L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT226L_LVB_Msk = 0xff0000

	// LUT226H: Graphic MMU LUT entry 226 high
	// Position of LO field.
	GFXMMU_LUT226H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT226H_LO_Msk = 0x3ffff0

	// LUT227L: Graphic MMU LUT entry 227 low
	// Position of EN field.
	GFXMMU_LUT227L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT227L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT227L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT227L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT227L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT227L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT227L_LVB_Msk = 0xff0000

	// LUT227H: Graphic MMU LUT entry 227 high
	// Position of LO field.
	GFXMMU_LUT227H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT227H_LO_Msk = 0x3ffff0

	// LUT228L: Graphic MMU LUT entry 228 low
	// Position of EN field.
	GFXMMU_LUT228L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT228L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT228L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT228L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT228L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT228L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT228L_LVB_Msk = 0xff0000

	// LUT228H: Graphic MMU LUT entry 228 high
	// Position of LO field.
	GFXMMU_LUT228H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT228H_LO_Msk = 0x3ffff0

	// LUT229L: Graphic MMU LUT entry 229 low
	// Position of EN field.
	GFXMMU_LUT229L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT229L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT229L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT229L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT229L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT229L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT229L_LVB_Msk = 0xff0000

	// LUT229H: Graphic MMU LUT entry 229 high
	// Position of LO field.
	GFXMMU_LUT229H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT229H_LO_Msk = 0x3ffff0

	// LUT230L: Graphic MMU LUT entry 230 low
	// Position of EN field.
	GFXMMU_LUT230L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT230L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT230L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT230L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT230L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT230L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT230L_LVB_Msk = 0xff0000

	// LUT230H: Graphic MMU LUT entry 230 high
	// Position of LO field.
	GFXMMU_LUT230H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT230H_LO_Msk = 0x3ffff0

	// LUT231L: Graphic MMU LUT entry 231 low
	// Position of EN field.
	GFXMMU_LUT231L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT231L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT231L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT231L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT231L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT231L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT231L_LVB_Msk = 0xff0000

	// LUT231H: Graphic MMU LUT entry 231 high
	// Position of LO field.
	GFXMMU_LUT231H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT231H_LO_Msk = 0x3ffff0

	// LUT232L: Graphic MMU LUT entry 232 low
	// Position of EN field.
	GFXMMU_LUT232L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT232L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT232L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT232L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT232L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT232L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT232L_LVB_Msk = 0xff0000

	// LUT232H: Graphic MMU LUT entry 232 high
	// Position of LO field.
	GFXMMU_LUT232H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT232H_LO_Msk = 0x3ffff0

	// LUT233L: Graphic MMU LUT entry 233 low
	// Position of EN field.
	GFXMMU_LUT233L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT233L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT233L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT233L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT233L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT233L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT233L_LVB_Msk = 0xff0000

	// LUT233H: Graphic MMU LUT entry 233 high
	// Position of LO field.
	GFXMMU_LUT233H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT233H_LO_Msk = 0x3ffff0

	// LUT234L: Graphic MMU LUT entry 234 low
	// Position of EN field.
	GFXMMU_LUT234L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT234L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT234L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT234L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT234L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT234L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT234L_LVB_Msk = 0xff0000

	// LUT234H: Graphic MMU LUT entry 234 high
	// Position of LO field.
	GFXMMU_LUT234H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT234H_LO_Msk = 0x3ffff0

	// LUT235L: Graphic MMU LUT entry 235 low
	// Position of EN field.
	GFXMMU_LUT235L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT235L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT235L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT235L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT235L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT235L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT235L_LVB_Msk = 0xff0000

	// LUT235H: Graphic MMU LUT entry 235 high
	// Position of LO field.
	GFXMMU_LUT235H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT235H_LO_Msk = 0x3ffff0

	// LUT236L: Graphic MMU LUT entry 236 low
	// Position of EN field.
	GFXMMU_LUT236L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT236L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT236L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT236L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT236L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT236L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT236L_LVB_Msk = 0xff0000

	// LUT236H: Graphic MMU LUT entry 236 high
	// Position of LO field.
	GFXMMU_LUT236H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT236H_LO_Msk = 0x3ffff0

	// LUT237L: Graphic MMU LUT entry 237 low
	// Position of EN field.
	GFXMMU_LUT237L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT237L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT237L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT237L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT237L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT237L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT237L_LVB_Msk = 0xff0000

	// LUT237H: Graphic MMU LUT entry 237 high
	// Position of LO field.
	GFXMMU_LUT237H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT237H_LO_Msk = 0x3ffff0

	// LUT238L: Graphic MMU LUT entry 238 low
	// Position of EN field.
	GFXMMU_LUT238L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT238L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT238L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT238L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT238L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT238L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT238L_LVB_Msk = 0xff0000

	// LUT238H: Graphic MMU LUT entry 238 high
	// Position of LO field.
	GFXMMU_LUT238H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT238H_LO_Msk = 0x3ffff0

	// LUT239L: Graphic MMU LUT entry 239 low
	// Position of EN field.
	GFXMMU_LUT239L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT239L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT239L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT239L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT239L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT239L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT239L_LVB_Msk = 0xff0000

	// LUT239H: Graphic MMU LUT entry 239 high
	// Position of LO field.
	GFXMMU_LUT239H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT239H_LO_Msk = 0x3ffff0

	// LUT240L: Graphic MMU LUT entry 240 low
	// Position of EN field.
	GFXMMU_LUT240L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT240L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT240L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT240L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT240L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT240L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT240L_LVB_Msk = 0xff0000

	// LUT240H: Graphic MMU LUT entry 240 high
	// Position of LO field.
	GFXMMU_LUT240H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT240H_LO_Msk = 0x3ffff0

	// LUT241L: Graphic MMU LUT entry 241 low
	// Position of EN field.
	GFXMMU_LUT241L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT241L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT241L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT241L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT241L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT241L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT241L_LVB_Msk = 0xff0000

	// LUT241H: Graphic MMU LUT entry 241 high
	// Position of LO field.
	GFXMMU_LUT241H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT241H_LO_Msk = 0x3ffff0

	// LUT242L: Graphic MMU LUT entry 242 low
	// Position of EN field.
	GFXMMU_LUT242L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT242L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT242L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT242L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT242L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT242L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT242L_LVB_Msk = 0xff0000

	// LUT242H: Graphic MMU LUT entry 242 high
	// Position of LO field.
	GFXMMU_LUT242H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT242H_LO_Msk = 0x3ffff0

	// LUT243L: Graphic MMU LUT entry 243 low
	// Position of EN field.
	GFXMMU_LUT243L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT243L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT243L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT243L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT243L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT243L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT243L_LVB_Msk = 0xff0000

	// LUT243H: Graphic MMU LUT entry 243 high
	// Position of LO field.
	GFXMMU_LUT243H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT243H_LO_Msk = 0x3ffff0

	// LUT244L: Graphic MMU LUT entry 244 low
	// Position of EN field.
	GFXMMU_LUT244L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT244L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT244L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT244L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT244L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT244L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT244L_LVB_Msk = 0xff0000

	// LUT244H: Graphic MMU LUT entry 244 high
	// Position of LO field.
	GFXMMU_LUT244H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT244H_LO_Msk = 0x3ffff0

	// LUT245L: Graphic MMU LUT entry 245 low
	// Position of EN field.
	GFXMMU_LUT245L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT245L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT245L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT245L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT245L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT245L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT245L_LVB_Msk = 0xff0000

	// LUT245H: Graphic MMU LUT entry 245 high
	// Position of LO field.
	GFXMMU_LUT245H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT245H_LO_Msk = 0x3ffff0

	// LUT246L: Graphic MMU LUT entry 246 low
	// Position of EN field.
	GFXMMU_LUT246L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT246L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT246L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT246L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT246L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT246L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT246L_LVB_Msk = 0xff0000

	// LUT246H: Graphic MMU LUT entry 246 high
	// Position of LO field.
	GFXMMU_LUT246H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT246H_LO_Msk = 0x3ffff0

	// LUT247L: Graphic MMU LUT entry 247 low
	// Position of EN field.
	GFXMMU_LUT247L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT247L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT247L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT247L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT247L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT247L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT247L_LVB_Msk = 0xff0000

	// LUT247H: Graphic MMU LUT entry 247 high
	// Position of LO field.
	GFXMMU_LUT247H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT247H_LO_Msk = 0x3ffff0

	// LUT248L: Graphic MMU LUT entry 248 low
	// Position of EN field.
	GFXMMU_LUT248L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT248L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT248L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT248L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT248L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT248L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT248L_LVB_Msk = 0xff0000

	// LUT248H: Graphic MMU LUT entry 248 high
	// Position of LO field.
	GFXMMU_LUT248H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT248H_LO_Msk = 0x3ffff0

	// LUT249L: Graphic MMU LUT entry 249 low
	// Position of EN field.
	GFXMMU_LUT249L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT249L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT249L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT249L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT249L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT249L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT249L_LVB_Msk = 0xff0000

	// LUT249H: Graphic MMU LUT entry 249 high
	// Position of LO field.
	GFXMMU_LUT249H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT249H_LO_Msk = 0x3ffff0

	// LUT250L: Graphic MMU LUT entry 250 low
	// Position of EN field.
	GFXMMU_LUT250L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT250L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT250L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT250L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT250L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT250L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT250L_LVB_Msk = 0xff0000

	// LUT250H: Graphic MMU LUT entry 250 high
	// Position of LO field.
	GFXMMU_LUT250H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT250H_LO_Msk = 0x3ffff0

	// LUT251L: Graphic MMU LUT entry 251 low
	// Position of EN field.
	GFXMMU_LUT251L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT251L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT251L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT251L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT251L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT251L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT251L_LVB_Msk = 0xff0000

	// LUT251H: Graphic MMU LUT entry 251 high
	// Position of LO field.
	GFXMMU_LUT251H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT251H_LO_Msk = 0x3ffff0

	// LUT252L: Graphic MMU LUT entry 252 low
	// Position of EN field.
	GFXMMU_LUT252L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT252L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT252L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT252L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT252L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT252L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT252L_LVB_Msk = 0xff0000

	// LUT252H: Graphic MMU LUT entry 252 high
	// Position of LO field.
	GFXMMU_LUT252H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT252H_LO_Msk = 0x3ffff0

	// LUT253L: Graphic MMU LUT entry 253 low
	// Position of EN field.
	GFXMMU_LUT253L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT253L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT253L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT253L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT253L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT253L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT253L_LVB_Msk = 0xff0000

	// LUT253H: Graphic MMU LUT entry 253 high
	// Position of LO field.
	GFXMMU_LUT253H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT253H_LO_Msk = 0x3ffff0

	// LUT254L: Graphic MMU LUT entry 254 low
	// Position of EN field.
	GFXMMU_LUT254L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT254L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT254L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT254L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT254L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT254L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT254L_LVB_Msk = 0xff0000

	// LUT254H: Graphic MMU LUT entry 254 high
	// Position of LO field.
	GFXMMU_LUT254H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT254H_LO_Msk = 0x3ffff0

	// LUT255L: Graphic MMU LUT entry 255 low
	// Position of EN field.
	GFXMMU_LUT255L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT255L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT255L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT255L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT255L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT255L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT255L_LVB_Msk = 0xff0000

	// LUT255H: Graphic MMU LUT entry 255 high
	// Position of LO field.
	GFXMMU_LUT255H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT255H_LO_Msk = 0x3ffff0

	// LUT256L: Graphic MMU LUT entry 256 low
	// Position of EN field.
	GFXMMU_LUT256L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT256L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT256L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT256L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT256L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT256L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT256L_LVB_Msk = 0xff0000

	// LUT256H: Graphic MMU LUT entry 256 high
	// Position of LO field.
	GFXMMU_LUT256H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT256H_LO_Msk = 0x3ffff0

	// LUT257L: Graphic MMU LUT entry 257 low
	// Position of EN field.
	GFXMMU_LUT257L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT257L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT257L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT257L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT257L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT257L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT257L_LVB_Msk = 0xff0000

	// LUT257H: Graphic MMU LUT entry 257 high
	// Position of LO field.
	GFXMMU_LUT257H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT257H_LO_Msk = 0x3ffff0

	// LUT258L: Graphic MMU LUT entry 258 low
	// Position of EN field.
	GFXMMU_LUT258L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT258L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT258L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT258L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT258L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT258L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT258L_LVB_Msk = 0xff0000

	// LUT258H: Graphic MMU LUT entry 258 high
	// Position of LO field.
	GFXMMU_LUT258H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT258H_LO_Msk = 0x3ffff0

	// LUT259L: Graphic MMU LUT entry 259 low
	// Position of EN field.
	GFXMMU_LUT259L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT259L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT259L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT259L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT259L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT259L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT259L_LVB_Msk = 0xff0000

	// LUT259H: Graphic MMU LUT entry 259 high
	// Position of LO field.
	GFXMMU_LUT259H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT259H_LO_Msk = 0x3ffff0

	// LUT260L: Graphic MMU LUT entry 260 low
	// Position of EN field.
	GFXMMU_LUT260L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT260L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT260L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT260L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT260L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT260L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT260L_LVB_Msk = 0xff0000

	// LUT260H: Graphic MMU LUT entry 260 high
	// Position of LO field.
	GFXMMU_LUT260H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT260H_LO_Msk = 0x3ffff0

	// LUT261L: Graphic MMU LUT entry 261 low
	// Position of EN field.
	GFXMMU_LUT261L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT261L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT261L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT261L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT261L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT261L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT261L_LVB_Msk = 0xff0000

	// LUT261H: Graphic MMU LUT entry 261 high
	// Position of LO field.
	GFXMMU_LUT261H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT261H_LO_Msk = 0x3ffff0

	// LUT262L: Graphic MMU LUT entry 262 low
	// Position of EN field.
	GFXMMU_LUT262L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT262L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT262L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT262L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT262L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT262L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT262L_LVB_Msk = 0xff0000

	// LUT262H: Graphic MMU LUT entry 262 high
	// Position of LO field.
	GFXMMU_LUT262H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT262H_LO_Msk = 0x3ffff0

	// LUT263L: Graphic MMU LUT entry 263 low
	// Position of EN field.
	GFXMMU_LUT263L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT263L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT263L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT263L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT263L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT263L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT263L_LVB_Msk = 0xff0000

	// LUT263H: Graphic MMU LUT entry 263 high
	// Position of LO field.
	GFXMMU_LUT263H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT263H_LO_Msk = 0x3ffff0

	// LUT264L: Graphic MMU LUT entry 264 low
	// Position of EN field.
	GFXMMU_LUT264L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT264L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT264L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT264L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT264L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT264L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT264L_LVB_Msk = 0xff0000

	// LUT264H: Graphic MMU LUT entry 264 high
	// Position of LO field.
	GFXMMU_LUT264H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT264H_LO_Msk = 0x3ffff0

	// LUT265L: Graphic MMU LUT entry 265 low
	// Position of EN field.
	GFXMMU_LUT265L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT265L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT265L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT265L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT265L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT265L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT265L_LVB_Msk = 0xff0000

	// LUT265H: Graphic MMU LUT entry 265 high
	// Position of LO field.
	GFXMMU_LUT265H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT265H_LO_Msk = 0x3ffff0

	// LUT266L: Graphic MMU LUT entry 266 low
	// Position of EN field.
	GFXMMU_LUT266L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT266L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT266L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT266L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT266L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT266L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT266L_LVB_Msk = 0xff0000

	// LUT266H: Graphic MMU LUT entry 266 high
	// Position of LO field.
	GFXMMU_LUT266H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT266H_LO_Msk = 0x3ffff0

	// LUT267L: Graphic MMU LUT entry 267 low
	// Position of EN field.
	GFXMMU_LUT267L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT267L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT267L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT267L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT267L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT267L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT267L_LVB_Msk = 0xff0000

	// LUT267H: Graphic MMU LUT entry 267 high
	// Position of LO field.
	GFXMMU_LUT267H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT267H_LO_Msk = 0x3ffff0

	// LUT268L: Graphic MMU LUT entry 268 low
	// Position of EN field.
	GFXMMU_LUT268L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT268L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT268L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT268L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT268L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT268L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT268L_LVB_Msk = 0xff0000

	// LUT268H: Graphic MMU LUT entry 268 high
	// Position of LO field.
	GFXMMU_LUT268H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT268H_LO_Msk = 0x3ffff0

	// LUT269L: Graphic MMU LUT entry 269 low
	// Position of EN field.
	GFXMMU_LUT269L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT269L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT269L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT269L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT269L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT269L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT269L_LVB_Msk = 0xff0000

	// LUT269H: Graphic MMU LUT entry 269 high
	// Position of LO field.
	GFXMMU_LUT269H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT269H_LO_Msk = 0x3ffff0

	// LUT270L: Graphic MMU LUT entry 270 low
	// Position of EN field.
	GFXMMU_LUT270L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT270L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT270L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT270L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT270L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT270L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT270L_LVB_Msk = 0xff0000

	// LUT270H: Graphic MMU LUT entry 270 high
	// Position of LO field.
	GFXMMU_LUT270H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT270H_LO_Msk = 0x3ffff0

	// LUT271L: Graphic MMU LUT entry 271 low
	// Position of EN field.
	GFXMMU_LUT271L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT271L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT271L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT271L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT271L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT271L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT271L_LVB_Msk = 0xff0000

	// LUT271H: Graphic MMU LUT entry 271 high
	// Position of LO field.
	GFXMMU_LUT271H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT271H_LO_Msk = 0x3ffff0

	// LUT272L: Graphic MMU LUT entry 272 low
	// Position of EN field.
	GFXMMU_LUT272L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT272L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT272L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT272L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT272L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT272L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT272L_LVB_Msk = 0xff0000

	// LUT272H: Graphic MMU LUT entry 272 high
	// Position of LO field.
	GFXMMU_LUT272H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT272H_LO_Msk = 0x3ffff0

	// LUT273L: Graphic MMU LUT entry 273 low
	// Position of EN field.
	GFXMMU_LUT273L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT273L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT273L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT273L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT273L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT273L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT273L_LVB_Msk = 0xff0000

	// LUT273H: Graphic MMU LUT entry 273 high
	// Position of LO field.
	GFXMMU_LUT273H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT273H_LO_Msk = 0x3ffff0

	// LUT274L: Graphic MMU LUT entry 274 low
	// Position of EN field.
	GFXMMU_LUT274L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT274L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT274L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT274L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT274L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT274L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT274L_LVB_Msk = 0xff0000

	// LUT274H: Graphic MMU LUT entry 274 high
	// Position of LO field.
	GFXMMU_LUT274H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT274H_LO_Msk = 0x3ffff0

	// LUT275L: Graphic MMU LUT entry 275 low
	// Position of EN field.
	GFXMMU_LUT275L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT275L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT275L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT275L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT275L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT275L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT275L_LVB_Msk = 0xff0000

	// LUT275H: Graphic MMU LUT entry 275 high
	// Position of LO field.
	GFXMMU_LUT275H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT275H_LO_Msk = 0x3ffff0

	// LUT276L: Graphic MMU LUT entry 276 low
	// Position of EN field.
	GFXMMU_LUT276L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT276L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT276L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT276L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT276L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT276L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT276L_LVB_Msk = 0xff0000

	// LUT276H: Graphic MMU LUT entry 276 high
	// Position of LO field.
	GFXMMU_LUT276H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT276H_LO_Msk = 0x3ffff0

	// LUT277L: Graphic MMU LUT entry 277 low
	// Position of EN field.
	GFXMMU_LUT277L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT277L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT277L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT277L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT277L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT277L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT277L_LVB_Msk = 0xff0000

	// LUT277H: Graphic MMU LUT entry 277 high
	// Position of LO field.
	GFXMMU_LUT277H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT277H_LO_Msk = 0x3ffff0

	// LUT278L: Graphic MMU LUT entry 278 low
	// Position of EN field.
	GFXMMU_LUT278L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT278L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT278L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT278L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT278L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT278L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT278L_LVB_Msk = 0xff0000

	// LUT278H: Graphic MMU LUT entry 278 high
	// Position of LO field.
	GFXMMU_LUT278H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT278H_LO_Msk = 0x3ffff0

	// LUT279L: Graphic MMU LUT entry 279 low
	// Position of EN field.
	GFXMMU_LUT279L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT279L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT279L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT279L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT279L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT279L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT279L_LVB_Msk = 0xff0000

	// LUT279H: Graphic MMU LUT entry 279 high
	// Position of LO field.
	GFXMMU_LUT279H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT279H_LO_Msk = 0x3ffff0

	// LUT280L: Graphic MMU LUT entry 280 low
	// Position of EN field.
	GFXMMU_LUT280L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT280L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT280L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT280L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT280L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT280L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT280L_LVB_Msk = 0xff0000

	// LUT280H: Graphic MMU LUT entry 280 high
	// Position of LO field.
	GFXMMU_LUT280H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT280H_LO_Msk = 0x3ffff0

	// LUT281L: Graphic MMU LUT entry 281 low
	// Position of EN field.
	GFXMMU_LUT281L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT281L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT281L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT281L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT281L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT281L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT281L_LVB_Msk = 0xff0000

	// LUT281H: Graphic MMU LUT entry 281 high
	// Position of LO field.
	GFXMMU_LUT281H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT281H_LO_Msk = 0x3ffff0

	// LUT282L: Graphic MMU LUT entry 282 low
	// Position of EN field.
	GFXMMU_LUT282L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT282L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT282L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT282L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT282L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT282L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT282L_LVB_Msk = 0xff0000

	// LUT282H: Graphic MMU LUT entry 282 high
	// Position of LO field.
	GFXMMU_LUT282H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT282H_LO_Msk = 0x3ffff0

	// LUT283L: Graphic MMU LUT entry 283 low
	// Position of EN field.
	GFXMMU_LUT283L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT283L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT283L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT283L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT283L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT283L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT283L_LVB_Msk = 0xff0000

	// LUT283H: Graphic MMU LUT entry 283 high
	// Position of LO field.
	GFXMMU_LUT283H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT283H_LO_Msk = 0x3ffff0

	// LUT284L: Graphic MMU LUT entry 284 low
	// Position of EN field.
	GFXMMU_LUT284L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT284L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT284L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT284L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT284L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT284L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT284L_LVB_Msk = 0xff0000

	// LUT284H: Graphic MMU LUT entry 284 high
	// Position of LO field.
	GFXMMU_LUT284H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT284H_LO_Msk = 0x3ffff0

	// LUT285L: Graphic MMU LUT entry 285 low
	// Position of EN field.
	GFXMMU_LUT285L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT285L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT285L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT285L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT285L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT285L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT285L_LVB_Msk = 0xff0000

	// LUT285H: Graphic MMU LUT entry 285 high
	// Position of LO field.
	GFXMMU_LUT285H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT285H_LO_Msk = 0x3ffff0

	// LUT286L: Graphic MMU LUT entry 286 low
	// Position of EN field.
	GFXMMU_LUT286L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT286L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT286L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT286L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT286L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT286L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT286L_LVB_Msk = 0xff0000

	// LUT286H: Graphic MMU LUT entry 286 high
	// Position of LO field.
	GFXMMU_LUT286H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT286H_LO_Msk = 0x3ffff0

	// LUT287L: Graphic MMU LUT entry 287 low
	// Position of EN field.
	GFXMMU_LUT287L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT287L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT287L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT287L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT287L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT287L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT287L_LVB_Msk = 0xff0000

	// LUT287H: Graphic MMU LUT entry 287 high
	// Position of LO field.
	GFXMMU_LUT287H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT287H_LO_Msk = 0x3ffff0

	// LUT288L: Graphic MMU LUT entry 288 low
	// Position of EN field.
	GFXMMU_LUT288L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT288L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT288L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT288L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT288L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT288L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT288L_LVB_Msk = 0xff0000

	// LUT288H: Graphic MMU LUT entry 288 high
	// Position of LO field.
	GFXMMU_LUT288H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT288H_LO_Msk = 0x3ffff0

	// LUT289L: Graphic MMU LUT entry 289 low
	// Position of EN field.
	GFXMMU_LUT289L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT289L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT289L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT289L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT289L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT289L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT289L_LVB_Msk = 0xff0000

	// LUT289H: Graphic MMU LUT entry 289 high
	// Position of LO field.
	GFXMMU_LUT289H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT289H_LO_Msk = 0x3ffff0

	// LUT290L: Graphic MMU LUT entry 290 low
	// Position of EN field.
	GFXMMU_LUT290L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT290L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT290L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT290L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT290L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT290L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT290L_LVB_Msk = 0xff0000

	// LUT290H: Graphic MMU LUT entry 290 high
	// Position of LO field.
	GFXMMU_LUT290H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT290H_LO_Msk = 0x3ffff0

	// LUT291L: Graphic MMU LUT entry 291 low
	// Position of EN field.
	GFXMMU_LUT291L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT291L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT291L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT291L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT291L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT291L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT291L_LVB_Msk = 0xff0000

	// LUT291H: Graphic MMU LUT entry 291 high
	// Position of LO field.
	GFXMMU_LUT291H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT291H_LO_Msk = 0x3ffff0

	// LUT292L: Graphic MMU LUT entry 292 low
	// Position of EN field.
	GFXMMU_LUT292L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT292L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT292L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT292L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT292L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT292L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT292L_LVB_Msk = 0xff0000

	// LUT292H: Graphic MMU LUT entry 292 high
	// Position of LO field.
	GFXMMU_LUT292H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT292H_LO_Msk = 0x3ffff0

	// LUT293L: Graphic MMU LUT entry 293 low
	// Position of EN field.
	GFXMMU_LUT293L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT293L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT293L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT293L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT293L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT293L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT293L_LVB_Msk = 0xff0000

	// LUT293H: Graphic MMU LUT entry 293 high
	// Position of LO field.
	GFXMMU_LUT293H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT293H_LO_Msk = 0x3ffff0

	// LUT294L: Graphic MMU LUT entry 294 low
	// Position of EN field.
	GFXMMU_LUT294L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT294L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT294L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT294L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT294L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT294L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT294L_LVB_Msk = 0xff0000

	// LUT294H: Graphic MMU LUT entry 294 high
	// Position of LO field.
	GFXMMU_LUT294H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT294H_LO_Msk = 0x3ffff0

	// LUT295L: Graphic MMU LUT entry 295 low
	// Position of EN field.
	GFXMMU_LUT295L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT295L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT295L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT295L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT295L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT295L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT295L_LVB_Msk = 0xff0000

	// LUT295H: Graphic MMU LUT entry 295 high
	// Position of LO field.
	GFXMMU_LUT295H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT295H_LO_Msk = 0x3ffff0

	// LUT296L: Graphic MMU LUT entry 296 low
	// Position of EN field.
	GFXMMU_LUT296L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT296L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT296L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT296L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT296L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT296L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT296L_LVB_Msk = 0xff0000

	// LUT296H: Graphic MMU LUT entry 296 high
	// Position of LO field.
	GFXMMU_LUT296H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT296H_LO_Msk = 0x3ffff0

	// LUT297L: Graphic MMU LUT entry 297 low
	// Position of EN field.
	GFXMMU_LUT297L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT297L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT297L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT297L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT297L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT297L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT297L_LVB_Msk = 0xff0000

	// LUT297H: Graphic MMU LUT entry 297 high
	// Position of LO field.
	GFXMMU_LUT297H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT297H_LO_Msk = 0x3ffff0

	// LUT298L: Graphic MMU LUT entry 298 low
	// Position of EN field.
	GFXMMU_LUT298L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT298L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT298L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT298L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT298L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT298L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT298L_LVB_Msk = 0xff0000

	// LUT298H: Graphic MMU LUT entry 298 high
	// Position of LO field.
	GFXMMU_LUT298H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT298H_LO_Msk = 0x3ffff0

	// LUT299L: Graphic MMU LUT entry 299 low
	// Position of EN field.
	GFXMMU_LUT299L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT299L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT299L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT299L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT299L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT299L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT299L_LVB_Msk = 0xff0000

	// LUT299H: Graphic MMU LUT entry 299 high
	// Position of LO field.
	GFXMMU_LUT299H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT299H_LO_Msk = 0x3ffff0

	// LUT300L: Graphic MMU LUT entry 300 low
	// Position of EN field.
	GFXMMU_LUT300L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT300L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT300L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT300L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT300L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT300L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT300L_LVB_Msk = 0xff0000

	// LUT300H: Graphic MMU LUT entry 300 high
	// Position of LO field.
	GFXMMU_LUT300H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT300H_LO_Msk = 0x3ffff0

	// LUT301L: Graphic MMU LUT entry 301 low
	// Position of EN field.
	GFXMMU_LUT301L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT301L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT301L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT301L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT301L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT301L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT301L_LVB_Msk = 0xff0000

	// LUT301H: Graphic MMU LUT entry 301 high
	// Position of LO field.
	GFXMMU_LUT301H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT301H_LO_Msk = 0x3ffff0

	// LUT302L: Graphic MMU LUT entry 302 low
	// Position of EN field.
	GFXMMU_LUT302L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT302L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT302L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT302L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT302L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT302L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT302L_LVB_Msk = 0xff0000

	// LUT302H: Graphic MMU LUT entry 302 high
	// Position of LO field.
	GFXMMU_LUT302H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT302H_LO_Msk = 0x3ffff0

	// LUT303L: Graphic MMU LUT entry 303 low
	// Position of EN field.
	GFXMMU_LUT303L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT303L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT303L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT303L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT303L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT303L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT303L_LVB_Msk = 0xff0000

	// LUT303H: Graphic MMU LUT entry 303 high
	// Position of LO field.
	GFXMMU_LUT303H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT303H_LO_Msk = 0x3ffff0

	// LUT304L: Graphic MMU LUT entry 304 low
	// Position of EN field.
	GFXMMU_LUT304L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT304L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT304L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT304L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT304L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT304L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT304L_LVB_Msk = 0xff0000

	// LUT304H: Graphic MMU LUT entry 304 high
	// Position of LO field.
	GFXMMU_LUT304H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT304H_LO_Msk = 0x3ffff0

	// LUT305L: Graphic MMU LUT entry 305 low
	// Position of EN field.
	GFXMMU_LUT305L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT305L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT305L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT305L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT305L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT305L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT305L_LVB_Msk = 0xff0000

	// LUT305H: Graphic MMU LUT entry 305 high
	// Position of LO field.
	GFXMMU_LUT305H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT305H_LO_Msk = 0x3ffff0

	// LUT306L: Graphic MMU LUT entry 306 low
	// Position of EN field.
	GFXMMU_LUT306L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT306L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT306L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT306L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT306L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT306L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT306L_LVB_Msk = 0xff0000

	// LUT306H: Graphic MMU LUT entry 306 high
	// Position of LO field.
	GFXMMU_LUT306H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT306H_LO_Msk = 0x3ffff0

	// LUT307L: Graphic MMU LUT entry 307 low
	// Position of EN field.
	GFXMMU_LUT307L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT307L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT307L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT307L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT307L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT307L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT307L_LVB_Msk = 0xff0000

	// LUT307H: Graphic MMU LUT entry 307 high
	// Position of LO field.
	GFXMMU_LUT307H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT307H_LO_Msk = 0x3ffff0

	// LUT308L: Graphic MMU LUT entry 308 low
	// Position of EN field.
	GFXMMU_LUT308L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT308L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT308L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT308L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT308L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT308L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT308L_LVB_Msk = 0xff0000

	// LUT308H: Graphic MMU LUT entry 308 high
	// Position of LO field.
	GFXMMU_LUT308H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT308H_LO_Msk = 0x3ffff0

	// LUT309L: Graphic MMU LUT entry 309 low
	// Position of EN field.
	GFXMMU_LUT309L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT309L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT309L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT309L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT309L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT309L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT309L_LVB_Msk = 0xff0000

	// LUT309H: Graphic MMU LUT entry 309 high
	// Position of LO field.
	GFXMMU_LUT309H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT309H_LO_Msk = 0x3ffff0

	// LUT310L: Graphic MMU LUT entry 310 low
	// Position of EN field.
	GFXMMU_LUT310L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT310L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT310L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT310L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT310L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT310L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT310L_LVB_Msk = 0xff0000

	// LUT310H: Graphic MMU LUT entry 310 high
	// Position of LO field.
	GFXMMU_LUT310H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT310H_LO_Msk = 0x3ffff0

	// LUT311L: Graphic MMU LUT entry 311 low
	// Position of EN field.
	GFXMMU_LUT311L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT311L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT311L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT311L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT311L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT311L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT311L_LVB_Msk = 0xff0000

	// LUT311H: Graphic MMU LUT entry 311 high
	// Position of LO field.
	GFXMMU_LUT311H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT311H_LO_Msk = 0x3ffff0

	// LUT312L: Graphic MMU LUT entry 312 low
	// Position of EN field.
	GFXMMU_LUT312L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT312L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT312L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT312L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT312L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT312L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT312L_LVB_Msk = 0xff0000

	// LUT312H: Graphic MMU LUT entry 312 high
	// Position of LO field.
	GFXMMU_LUT312H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT312H_LO_Msk = 0x3ffff0

	// LUT313L: Graphic MMU LUT entry 313 low
	// Position of EN field.
	GFXMMU_LUT313L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT313L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT313L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT313L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT313L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT313L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT313L_LVB_Msk = 0xff0000

	// LUT313H: Graphic MMU LUT entry 313 high
	// Position of LO field.
	GFXMMU_LUT313H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT313H_LO_Msk = 0x3ffff0

	// LUT314L: Graphic MMU LUT entry 314 low
	// Position of EN field.
	GFXMMU_LUT314L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT314L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT314L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT314L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT314L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT314L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT314L_LVB_Msk = 0xff0000

	// LUT314H: Graphic MMU LUT entry 314 high
	// Position of LO field.
	GFXMMU_LUT314H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT314H_LO_Msk = 0x3ffff0

	// LUT315L: Graphic MMU LUT entry 315 low
	// Position of EN field.
	GFXMMU_LUT315L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT315L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT315L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT315L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT315L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT315L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT315L_LVB_Msk = 0xff0000

	// LUT315H: Graphic MMU LUT entry 315 high
	// Position of LO field.
	GFXMMU_LUT315H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT315H_LO_Msk = 0x3ffff0

	// LUT316L: Graphic MMU LUT entry 316 low
	// Position of EN field.
	GFXMMU_LUT316L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT316L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT316L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT316L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT316L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT316L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT316L_LVB_Msk = 0xff0000

	// LUT316H: Graphic MMU LUT entry 316 high
	// Position of LO field.
	GFXMMU_LUT316H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT316H_LO_Msk = 0x3ffff0

	// LUT317L: Graphic MMU LUT entry 317 low
	// Position of EN field.
	GFXMMU_LUT317L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT317L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT317L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT317L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT317L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT317L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT317L_LVB_Msk = 0xff0000

	// LUT317H: Graphic MMU LUT entry 317 high
	// Position of LO field.
	GFXMMU_LUT317H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT317H_LO_Msk = 0x3ffff0

	// LUT318L: Graphic MMU LUT entry 318 low
	// Position of EN field.
	GFXMMU_LUT318L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT318L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT318L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT318L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT318L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT318L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT318L_LVB_Msk = 0xff0000

	// LUT318H: Graphic MMU LUT entry 318 high
	// Position of LO field.
	GFXMMU_LUT318H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT318H_LO_Msk = 0x3ffff0

	// LUT319L: Graphic MMU LUT entry 319 low
	// Position of EN field.
	GFXMMU_LUT319L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT319L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT319L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT319L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT319L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT319L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT319L_LVB_Msk = 0xff0000

	// LUT319H: Graphic MMU LUT entry 319 high
	// Position of LO field.
	GFXMMU_LUT319H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT319H_LO_Msk = 0x3ffff0

	// LUT320L: Graphic MMU LUT entry 320 low
	// Position of EN field.
	GFXMMU_LUT320L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT320L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT320L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT320L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT320L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT320L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT320L_LVB_Msk = 0xff0000

	// LUT320H: Graphic MMU LUT entry 320 high
	// Position of LO field.
	GFXMMU_LUT320H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT320H_LO_Msk = 0x3ffff0

	// LUT321L: Graphic MMU LUT entry 321 low
	// Position of EN field.
	GFXMMU_LUT321L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT321L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT321L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT321L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT321L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT321L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT321L_LVB_Msk = 0xff0000

	// LUT321H: Graphic MMU LUT entry 321 high
	// Position of LO field.
	GFXMMU_LUT321H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT321H_LO_Msk = 0x3ffff0

	// LUT322L: Graphic MMU LUT entry 322 low
	// Position of EN field.
	GFXMMU_LUT322L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT322L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT322L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT322L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT322L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT322L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT322L_LVB_Msk = 0xff0000

	// LUT322H: Graphic MMU LUT entry 322 high
	// Position of LO field.
	GFXMMU_LUT322H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT322H_LO_Msk = 0x3ffff0

	// LUT323L: Graphic MMU LUT entry 323 low
	// Position of EN field.
	GFXMMU_LUT323L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT323L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT323L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT323L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT323L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT323L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT323L_LVB_Msk = 0xff0000

	// LUT323H: Graphic MMU LUT entry 323 high
	// Position of LO field.
	GFXMMU_LUT323H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT323H_LO_Msk = 0x3ffff0

	// LUT324L: Graphic MMU LUT entry 324 low
	// Position of EN field.
	GFXMMU_LUT324L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT324L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT324L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT324L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT324L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT324L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT324L_LVB_Msk = 0xff0000

	// LUT324H: Graphic MMU LUT entry 324 high
	// Position of LO field.
	GFXMMU_LUT324H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT324H_LO_Msk = 0x3ffff0

	// LUT325L: Graphic MMU LUT entry 325 low
	// Position of EN field.
	GFXMMU_LUT325L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT325L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT325L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT325L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT325L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT325L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT325L_LVB_Msk = 0xff0000

	// LUT325H: Graphic MMU LUT entry 325 high
	// Position of LO field.
	GFXMMU_LUT325H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT325H_LO_Msk = 0x3ffff0

	// LUT326L: Graphic MMU LUT entry 326 low
	// Position of EN field.
	GFXMMU_LUT326L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT326L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT326L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT326L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT326L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT326L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT326L_LVB_Msk = 0xff0000

	// LUT326H: Graphic MMU LUT entry 326 high
	// Position of LO field.
	GFXMMU_LUT326H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT326H_LO_Msk = 0x3ffff0

	// LUT327L: Graphic MMU LUT entry 327 low
	// Position of EN field.
	GFXMMU_LUT327L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT327L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT327L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT327L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT327L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT327L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT327L_LVB_Msk = 0xff0000

	// LUT327H: Graphic MMU LUT entry 327 high
	// Position of LO field.
	GFXMMU_LUT327H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT327H_LO_Msk = 0x3ffff0

	// LUT328L: Graphic MMU LUT entry 328 low
	// Position of EN field.
	GFXMMU_LUT328L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT328L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT328L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT328L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT328L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT328L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT328L_LVB_Msk = 0xff0000

	// LUT328H: Graphic MMU LUT entry 328 high
	// Position of LO field.
	GFXMMU_LUT328H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT328H_LO_Msk = 0x3ffff0

	// LUT329L: Graphic MMU LUT entry 329 low
	// Position of EN field.
	GFXMMU_LUT329L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT329L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT329L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT329L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT329L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT329L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT329L_LVB_Msk = 0xff0000

	// LUT329H: Graphic MMU LUT entry 329 high
	// Position of LO field.
	GFXMMU_LUT329H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT329H_LO_Msk = 0x3ffff0

	// LUT330L: Graphic MMU LUT entry 330 low
	// Position of EN field.
	GFXMMU_LUT330L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT330L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT330L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT330L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT330L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT330L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT330L_LVB_Msk = 0xff0000

	// LUT330H: Graphic MMU LUT entry 330 high
	// Position of LO field.
	GFXMMU_LUT330H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT330H_LO_Msk = 0x3ffff0

	// LUT331L: Graphic MMU LUT entry 331 low
	// Position of EN field.
	GFXMMU_LUT331L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT331L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT331L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT331L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT331L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT331L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT331L_LVB_Msk = 0xff0000

	// LUT331H: Graphic MMU LUT entry 331 high
	// Position of LO field.
	GFXMMU_LUT331H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT331H_LO_Msk = 0x3ffff0

	// LUT332L: Graphic MMU LUT entry 332 low
	// Position of EN field.
	GFXMMU_LUT332L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT332L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT332L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT332L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT332L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT332L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT332L_LVB_Msk = 0xff0000

	// LUT332H: Graphic MMU LUT entry 332 high
	// Position of LO field.
	GFXMMU_LUT332H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT332H_LO_Msk = 0x3ffff0

	// LUT333L: Graphic MMU LUT entry 333 low
	// Position of EN field.
	GFXMMU_LUT333L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT333L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT333L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT333L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT333L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT333L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT333L_LVB_Msk = 0xff0000

	// LUT333H: Graphic MMU LUT entry 333 high
	// Position of LO field.
	GFXMMU_LUT333H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT333H_LO_Msk = 0x3ffff0

	// LUT334L: Graphic MMU LUT entry 334 low
	// Position of EN field.
	GFXMMU_LUT334L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT334L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT334L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT334L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT334L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT334L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT334L_LVB_Msk = 0xff0000

	// LUT334H: Graphic MMU LUT entry 334 high
	// Position of LO field.
	GFXMMU_LUT334H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT334H_LO_Msk = 0x3ffff0

	// LUT335L: Graphic MMU LUT entry 335 low
	// Position of EN field.
	GFXMMU_LUT335L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT335L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT335L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT335L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT335L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT335L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT335L_LVB_Msk = 0xff0000

	// LUT335H: Graphic MMU LUT entry 335 high
	// Position of LO field.
	GFXMMU_LUT335H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT335H_LO_Msk = 0x3ffff0

	// LUT336L: Graphic MMU LUT entry 336 low
	// Position of EN field.
	GFXMMU_LUT336L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT336L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT336L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT336L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT336L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT336L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT336L_LVB_Msk = 0xff0000

	// LUT336H: Graphic MMU LUT entry 336 high
	// Position of LO field.
	GFXMMU_LUT336H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT336H_LO_Msk = 0x3ffff0

	// LUT337L: Graphic MMU LUT entry 337 low
	// Position of EN field.
	GFXMMU_LUT337L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT337L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT337L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT337L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT337L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT337L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT337L_LVB_Msk = 0xff0000

	// LUT337H: Graphic MMU LUT entry 337 high
	// Position of LO field.
	GFXMMU_LUT337H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT337H_LO_Msk = 0x3ffff0

	// LUT338L: Graphic MMU LUT entry 338 low
	// Position of EN field.
	GFXMMU_LUT338L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT338L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT338L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT338L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT338L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT338L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT338L_LVB_Msk = 0xff0000

	// LUT338H: Graphic MMU LUT entry 338 high
	// Position of LO field.
	GFXMMU_LUT338H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT338H_LO_Msk = 0x3ffff0

	// LUT339L: Graphic MMU LUT entry 339 low
	// Position of EN field.
	GFXMMU_LUT339L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT339L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT339L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT339L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT339L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT339L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT339L_LVB_Msk = 0xff0000

	// LUT339H: Graphic MMU LUT entry 339 high
	// Position of LO field.
	GFXMMU_LUT339H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT339H_LO_Msk = 0x3ffff0

	// LUT340L: Graphic MMU LUT entry 340 low
	// Position of EN field.
	GFXMMU_LUT340L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT340L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT340L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT340L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT340L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT340L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT340L_LVB_Msk = 0xff0000

	// LUT340H: Graphic MMU LUT entry 340 high
	// Position of LO field.
	GFXMMU_LUT340H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT340H_LO_Msk = 0x3ffff0

	// LUT341L: Graphic MMU LUT entry 341 low
	// Position of EN field.
	GFXMMU_LUT341L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT341L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT341L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT341L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT341L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT341L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT341L_LVB_Msk = 0xff0000

	// LUT341H: Graphic MMU LUT entry 341 high
	// Position of LO field.
	GFXMMU_LUT341H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT341H_LO_Msk = 0x3ffff0

	// LUT342L: Graphic MMU LUT entry 342 low
	// Position of EN field.
	GFXMMU_LUT342L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT342L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT342L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT342L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT342L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT342L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT342L_LVB_Msk = 0xff0000

	// LUT342H: Graphic MMU LUT entry 342 high
	// Position of LO field.
	GFXMMU_LUT342H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT342H_LO_Msk = 0x3ffff0

	// LUT343L: Graphic MMU LUT entry 343 low
	// Position of EN field.
	GFXMMU_LUT343L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT343L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT343L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT343L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT343L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT343L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT343L_LVB_Msk = 0xff0000

	// LUT343H: Graphic MMU LUT entry 343 high
	// Position of LO field.
	GFXMMU_LUT343H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT343H_LO_Msk = 0x3ffff0

	// LUT344L: Graphic MMU LUT entry 344 low
	// Position of EN field.
	GFXMMU_LUT344L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT344L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT344L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT344L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT344L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT344L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT344L_LVB_Msk = 0xff0000

	// LUT344H: Graphic MMU LUT entry 344 high
	// Position of LO field.
	GFXMMU_LUT344H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT344H_LO_Msk = 0x3ffff0

	// LUT345L: Graphic MMU LUT entry 345 low
	// Position of EN field.
	GFXMMU_LUT345L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT345L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT345L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT345L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT345L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT345L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT345L_LVB_Msk = 0xff0000

	// LUT345H: Graphic MMU LUT entry 345 high
	// Position of LO field.
	GFXMMU_LUT345H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT345H_LO_Msk = 0x3ffff0

	// LUT346L: Graphic MMU LUT entry 346 low
	// Position of EN field.
	GFXMMU_LUT346L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT346L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT346L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT346L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT346L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT346L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT346L_LVB_Msk = 0xff0000

	// LUT346H: Graphic MMU LUT entry 346 high
	// Position of LO field.
	GFXMMU_LUT346H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT346H_LO_Msk = 0x3ffff0

	// LUT347L: Graphic MMU LUT entry 347 low
	// Position of EN field.
	GFXMMU_LUT347L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT347L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT347L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT347L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT347L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT347L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT347L_LVB_Msk = 0xff0000

	// LUT347H: Graphic MMU LUT entry 347 high
	// Position of LO field.
	GFXMMU_LUT347H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT347H_LO_Msk = 0x3ffff0

	// LUT348L: Graphic MMU LUT entry 348 low
	// Position of EN field.
	GFXMMU_LUT348L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT348L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT348L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT348L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT348L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT348L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT348L_LVB_Msk = 0xff0000

	// LUT348H: Graphic MMU LUT entry 348 high
	// Position of LO field.
	GFXMMU_LUT348H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT348H_LO_Msk = 0x3ffff0

	// LUT349L: Graphic MMU LUT entry 349 low
	// Position of EN field.
	GFXMMU_LUT349L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT349L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT349L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT349L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT349L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT349L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT349L_LVB_Msk = 0xff0000

	// LUT349H: Graphic MMU LUT entry 349 high
	// Position of LO field.
	GFXMMU_LUT349H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT349H_LO_Msk = 0x3ffff0

	// LUT350L: Graphic MMU LUT entry 350 low
	// Position of EN field.
	GFXMMU_LUT350L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT350L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT350L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT350L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT350L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT350L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT350L_LVB_Msk = 0xff0000

	// LUT350H: Graphic MMU LUT entry 350 high
	// Position of LO field.
	GFXMMU_LUT350H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT350H_LO_Msk = 0x3ffff0

	// LUT351L: Graphic MMU LUT entry 351 low
	// Position of EN field.
	GFXMMU_LUT351L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT351L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT351L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT351L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT351L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT351L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT351L_LVB_Msk = 0xff0000

	// LUT351H: Graphic MMU LUT entry 351 high
	// Position of LO field.
	GFXMMU_LUT351H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT351H_LO_Msk = 0x3ffff0

	// LUT352L: Graphic MMU LUT entry 352 low
	// Position of EN field.
	GFXMMU_LUT352L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT352L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT352L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT352L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT352L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT352L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT352L_LVB_Msk = 0xff0000

	// LUT352H: Graphic MMU LUT entry 352 high
	// Position of LO field.
	GFXMMU_LUT352H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT352H_LO_Msk = 0x3ffff0

	// LUT353L: Graphic MMU LUT entry 353 low
	// Position of EN field.
	GFXMMU_LUT353L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT353L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT353L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT353L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT353L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT353L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT353L_LVB_Msk = 0xff0000

	// LUT353H: Graphic MMU LUT entry 353 high
	// Position of LO field.
	GFXMMU_LUT353H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT353H_LO_Msk = 0x3ffff0

	// LUT354L: Graphic MMU LUT entry 354 low
	// Position of EN field.
	GFXMMU_LUT354L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT354L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT354L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT354L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT354L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT354L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT354L_LVB_Msk = 0xff0000

	// LUT354H: Graphic MMU LUT entry 354 high
	// Position of LO field.
	GFXMMU_LUT354H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT354H_LO_Msk = 0x3ffff0

	// LUT355L: Graphic MMU LUT entry 355 low
	// Position of EN field.
	GFXMMU_LUT355L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT355L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT355L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT355L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT355L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT355L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT355L_LVB_Msk = 0xff0000

	// LUT355H: Graphic MMU LUT entry 355 high
	// Position of LO field.
	GFXMMU_LUT355H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT355H_LO_Msk = 0x3ffff0

	// LUT356L: Graphic MMU LUT entry 356 low
	// Position of EN field.
	GFXMMU_LUT356L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT356L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT356L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT356L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT356L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT356L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT356L_LVB_Msk = 0xff0000

	// LUT356H: Graphic MMU LUT entry 356 high
	// Position of LO field.
	GFXMMU_LUT356H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT356H_LO_Msk = 0x3ffff0

	// LUT357L: Graphic MMU LUT entry 357 low
	// Position of EN field.
	GFXMMU_LUT357L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT357L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT357L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT357L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT357L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT357L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT357L_LVB_Msk = 0xff0000

	// LUT357H: Graphic MMU LUT entry 357 high
	// Position of LO field.
	GFXMMU_LUT357H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT357H_LO_Msk = 0x3ffff0

	// LUT358L: Graphic MMU LUT entry 358 low
	// Position of EN field.
	GFXMMU_LUT358L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT358L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT358L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT358L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT358L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT358L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT358L_LVB_Msk = 0xff0000

	// LUT358H: Graphic MMU LUT entry 358 high
	// Position of LO field.
	GFXMMU_LUT358H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT358H_LO_Msk = 0x3ffff0

	// LUT359L: Graphic MMU LUT entry 359 low
	// Position of EN field.
	GFXMMU_LUT359L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT359L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT359L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT359L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT359L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT359L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT359L_LVB_Msk = 0xff0000

	// LUT359H: Graphic MMU LUT entry 359 high
	// Position of LO field.
	GFXMMU_LUT359H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT359H_LO_Msk = 0x3ffff0

	// LUT360L: Graphic MMU LUT entry 360 low
	// Position of EN field.
	GFXMMU_LUT360L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT360L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT360L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT360L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT360L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT360L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT360L_LVB_Msk = 0xff0000

	// LUT360H: Graphic MMU LUT entry 360 high
	// Position of LO field.
	GFXMMU_LUT360H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT360H_LO_Msk = 0x3ffff0

	// LUT361L: Graphic MMU LUT entry 361 low
	// Position of EN field.
	GFXMMU_LUT361L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT361L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT361L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT361L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT361L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT361L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT361L_LVB_Msk = 0xff0000

	// LUT361H: Graphic MMU LUT entry 361 high
	// Position of LO field.
	GFXMMU_LUT361H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT361H_LO_Msk = 0x3ffff0

	// LUT362L: Graphic MMU LUT entry 362 low
	// Position of EN field.
	GFXMMU_LUT362L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT362L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT362L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT362L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT362L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT362L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT362L_LVB_Msk = 0xff0000

	// LUT362H: Graphic MMU LUT entry 362 high
	// Position of LO field.
	GFXMMU_LUT362H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT362H_LO_Msk = 0x3ffff0

	// LUT363L: Graphic MMU LUT entry 363 low
	// Position of EN field.
	GFXMMU_LUT363L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT363L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT363L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT363L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT363L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT363L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT363L_LVB_Msk = 0xff0000

	// LUT363H: Graphic MMU LUT entry 363 high
	// Position of LO field.
	GFXMMU_LUT363H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT363H_LO_Msk = 0x3ffff0

	// LUT364L: Graphic MMU LUT entry 364 low
	// Position of EN field.
	GFXMMU_LUT364L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT364L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT364L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT364L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT364L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT364L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT364L_LVB_Msk = 0xff0000

	// LUT364H: Graphic MMU LUT entry 364 high
	// Position of LO field.
	GFXMMU_LUT364H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT364H_LO_Msk = 0x3ffff0

	// LUT365L: Graphic MMU LUT entry 365 low
	// Position of EN field.
	GFXMMU_LUT365L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT365L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT365L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT365L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT365L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT365L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT365L_LVB_Msk = 0xff0000

	// LUT365H: Graphic MMU LUT entry 365 high
	// Position of LO field.
	GFXMMU_LUT365H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT365H_LO_Msk = 0x3ffff0

	// LUT366L: Graphic MMU LUT entry 366 low
	// Position of EN field.
	GFXMMU_LUT366L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT366L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT366L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT366L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT366L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT366L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT366L_LVB_Msk = 0xff0000

	// LUT366H: Graphic MMU LUT entry 366 high
	// Position of LO field.
	GFXMMU_LUT366H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT366H_LO_Msk = 0x3ffff0

	// LUT367L: Graphic MMU LUT entry 367 low
	// Position of EN field.
	GFXMMU_LUT367L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT367L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT367L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT367L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT367L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT367L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT367L_LVB_Msk = 0xff0000

	// LUT367H: Graphic MMU LUT entry 367 high
	// Position of LO field.
	GFXMMU_LUT367H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT367H_LO_Msk = 0x3ffff0

	// LUT368L: Graphic MMU LUT entry 368 low
	// Position of EN field.
	GFXMMU_LUT368L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT368L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT368L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT368L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT368L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT368L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT368L_LVB_Msk = 0xff0000

	// LUT368H: Graphic MMU LUT entry 368 high
	// Position of LO field.
	GFXMMU_LUT368H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT368H_LO_Msk = 0x3ffff0

	// LUT369L: Graphic MMU LUT entry 369 low
	// Position of EN field.
	GFXMMU_LUT369L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT369L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT369L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT369L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT369L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT369L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT369L_LVB_Msk = 0xff0000

	// LUT369H: Graphic MMU LUT entry 369 high
	// Position of LO field.
	GFXMMU_LUT369H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT369H_LO_Msk = 0x3ffff0

	// LUT370L: Graphic MMU LUT entry 370 low
	// Position of EN field.
	GFXMMU_LUT370L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT370L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT370L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT370L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT370L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT370L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT370L_LVB_Msk = 0xff0000

	// LUT370H: Graphic MMU LUT entry 370 high
	// Position of LO field.
	GFXMMU_LUT370H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT370H_LO_Msk = 0x3ffff0

	// LUT371L: Graphic MMU LUT entry 371 low
	// Position of EN field.
	GFXMMU_LUT371L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT371L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT371L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT371L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT371L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT371L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT371L_LVB_Msk = 0xff0000

	// LUT371H: Graphic MMU LUT entry 371 high
	// Position of LO field.
	GFXMMU_LUT371H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT371H_LO_Msk = 0x3ffff0

	// LUT372L: Graphic MMU LUT entry 372 low
	// Position of EN field.
	GFXMMU_LUT372L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT372L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT372L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT372L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT372L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT372L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT372L_LVB_Msk = 0xff0000

	// LUT372H: Graphic MMU LUT entry 372 high
	// Position of LO field.
	GFXMMU_LUT372H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT372H_LO_Msk = 0x3ffff0

	// LUT373L: Graphic MMU LUT entry 373 low
	// Position of EN field.
	GFXMMU_LUT373L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT373L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT373L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT373L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT373L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT373L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT373L_LVB_Msk = 0xff0000

	// LUT373H: Graphic MMU LUT entry 373 high
	// Position of LO field.
	GFXMMU_LUT373H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT373H_LO_Msk = 0x3ffff0

	// LUT374L: Graphic MMU LUT entry 374 low
	// Position of EN field.
	GFXMMU_LUT374L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT374L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT374L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT374L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT374L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT374L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT374L_LVB_Msk = 0xff0000

	// LUT374H: Graphic MMU LUT entry 374 high
	// Position of LO field.
	GFXMMU_LUT374H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT374H_LO_Msk = 0x3ffff0

	// LUT375L: Graphic MMU LUT entry 375 low
	// Position of EN field.
	GFXMMU_LUT375L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT375L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT375L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT375L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT375L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT375L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT375L_LVB_Msk = 0xff0000

	// LUT375H: Graphic MMU LUT entry 375 high
	// Position of LO field.
	GFXMMU_LUT375H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT375H_LO_Msk = 0x3ffff0

	// LUT376L: Graphic MMU LUT entry 376 low
	// Position of EN field.
	GFXMMU_LUT376L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT376L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT376L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT376L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT376L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT376L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT376L_LVB_Msk = 0xff0000

	// LUT376H: Graphic MMU LUT entry 376 high
	// Position of LO field.
	GFXMMU_LUT376H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT376H_LO_Msk = 0x3ffff0

	// LUT377L: Graphic MMU LUT entry 377 low
	// Position of EN field.
	GFXMMU_LUT377L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT377L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT377L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT377L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT377L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT377L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT377L_LVB_Msk = 0xff0000

	// LUT377H: Graphic MMU LUT entry 377 high
	// Position of LO field.
	GFXMMU_LUT377H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT377H_LO_Msk = 0x3ffff0

	// LUT378L: Graphic MMU LUT entry 378 low
	// Position of EN field.
	GFXMMU_LUT378L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT378L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT378L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT378L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT378L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT378L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT378L_LVB_Msk = 0xff0000

	// LUT378H: Graphic MMU LUT entry 378 high
	// Position of LO field.
	GFXMMU_LUT378H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT378H_LO_Msk = 0x3ffff0

	// LUT379L: Graphic MMU LUT entry 379 low
	// Position of EN field.
	GFXMMU_LUT379L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT379L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT379L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT379L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT379L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT379L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT379L_LVB_Msk = 0xff0000

	// LUT379H: Graphic MMU LUT entry 379 high
	// Position of LO field.
	GFXMMU_LUT379H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT379H_LO_Msk = 0x3ffff0

	// LUT380L: Graphic MMU LUT entry 380 low
	// Position of EN field.
	GFXMMU_LUT380L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT380L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT380L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT380L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT380L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT380L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT380L_LVB_Msk = 0xff0000

	// LUT380H: Graphic MMU LUT entry 380 high
	// Position of LO field.
	GFXMMU_LUT380H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT380H_LO_Msk = 0x3ffff0

	// LUT381L: Graphic MMU LUT entry 381 low
	// Position of EN field.
	GFXMMU_LUT381L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT381L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT381L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT381L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT381L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT381L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT381L_LVB_Msk = 0xff0000

	// LUT381H: Graphic MMU LUT entry 381 high
	// Position of LO field.
	GFXMMU_LUT381H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT381H_LO_Msk = 0x3ffff0

	// LUT382L: Graphic MMU LUT entry 382 low
	// Position of EN field.
	GFXMMU_LUT382L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT382L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT382L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT382L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT382L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT382L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT382L_LVB_Msk = 0xff0000

	// LUT382H: Graphic MMU LUT entry 382 high
	// Position of LO field.
	GFXMMU_LUT382H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT382H_LO_Msk = 0x3ffff0

	// LUT383L: Graphic MMU LUT entry 383 low
	// Position of EN field.
	GFXMMU_LUT383L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT383L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT383L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT383L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT383L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT383L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT383L_LVB_Msk = 0xff0000

	// LUT383H: Graphic MMU LUT entry 383 high
	// Position of LO field.
	GFXMMU_LUT383H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT383H_LO_Msk = 0x3ffff0

	// LUT384L: Graphic MMU LUT entry 384 low
	// Position of EN field.
	GFXMMU_LUT384L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT384L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT384L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT384L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT384L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT384L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT384L_LVB_Msk = 0xff0000

	// LUT384H: Graphic MMU LUT entry 384 high
	// Position of LO field.
	GFXMMU_LUT384H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT384H_LO_Msk = 0x3ffff0

	// LUT385L: Graphic MMU LUT entry 385 low
	// Position of EN field.
	GFXMMU_LUT385L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT385L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT385L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT385L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT385L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT385L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT385L_LVB_Msk = 0xff0000

	// LUT385H: Graphic MMU LUT entry 385 high
	// Position of LO field.
	GFXMMU_LUT385H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT385H_LO_Msk = 0x3ffff0

	// LUT386L: Graphic MMU LUT entry 386 low
	// Position of EN field.
	GFXMMU_LUT386L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT386L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT386L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT386L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT386L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT386L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT386L_LVB_Msk = 0xff0000

	// LUT386H: Graphic MMU LUT entry 386 high
	// Position of LO field.
	GFXMMU_LUT386H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT386H_LO_Msk = 0x3ffff0

	// LUT387L: Graphic MMU LUT entry 387 low
	// Position of EN field.
	GFXMMU_LUT387L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT387L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT387L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT387L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT387L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT387L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT387L_LVB_Msk = 0xff0000

	// LUT387H: Graphic MMU LUT entry 387 high
	// Position of LO field.
	GFXMMU_LUT387H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT387H_LO_Msk = 0x3ffff0

	// LUT388L: Graphic MMU LUT entry 388 low
	// Position of EN field.
	GFXMMU_LUT388L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT388L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT388L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT388L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT388L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT388L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT388L_LVB_Msk = 0xff0000

	// LUT388H: Graphic MMU LUT entry 388 high
	// Position of LO field.
	GFXMMU_LUT388H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT388H_LO_Msk = 0x3ffff0

	// LUT389L: Graphic MMU LUT entry 389 low
	// Position of EN field.
	GFXMMU_LUT389L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT389L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT389L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT389L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT389L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT389L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT389L_LVB_Msk = 0xff0000

	// LUT389H: Graphic MMU LUT entry 389 high
	// Position of LO field.
	GFXMMU_LUT389H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT389H_LO_Msk = 0x3ffff0

	// LUT390L: Graphic MMU LUT entry 390 low
	// Position of EN field.
	GFXMMU_LUT390L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT390L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT390L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT390L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT390L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT390L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT390L_LVB_Msk = 0xff0000

	// LUT390H: Graphic MMU LUT entry 390 high
	// Position of LO field.
	GFXMMU_LUT390H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT390H_LO_Msk = 0x3ffff0

	// LUT391L: Graphic MMU LUT entry 391 low
	// Position of EN field.
	GFXMMU_LUT391L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT391L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT391L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT391L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT391L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT391L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT391L_LVB_Msk = 0xff0000

	// LUT391H: Graphic MMU LUT entry 391 high
	// Position of LO field.
	GFXMMU_LUT391H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT391H_LO_Msk = 0x3ffff0

	// LUT392L: Graphic MMU LUT entry 392 low
	// Position of EN field.
	GFXMMU_LUT392L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT392L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT392L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT392L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT392L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT392L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT392L_LVB_Msk = 0xff0000

	// LUT392H: Graphic MMU LUT entry 392 high
	// Position of LO field.
	GFXMMU_LUT392H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT392H_LO_Msk = 0x3ffff0

	// LUT393L: Graphic MMU LUT entry 393 low
	// Position of EN field.
	GFXMMU_LUT393L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT393L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT393L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT393L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT393L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT393L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT393L_LVB_Msk = 0xff0000

	// LUT393H: Graphic MMU LUT entry 393 high
	// Position of LO field.
	GFXMMU_LUT393H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT393H_LO_Msk = 0x3ffff0

	// LUT394L: Graphic MMU LUT entry 394 low
	// Position of EN field.
	GFXMMU_LUT394L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT394L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT394L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT394L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT394L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT394L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT394L_LVB_Msk = 0xff0000

	// LUT394H: Graphic MMU LUT entry 394 high
	// Position of LO field.
	GFXMMU_LUT394H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT394H_LO_Msk = 0x3ffff0

	// LUT395L: Graphic MMU LUT entry 395 low
	// Position of EN field.
	GFXMMU_LUT395L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT395L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT395L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT395L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT395L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT395L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT395L_LVB_Msk = 0xff0000

	// LUT395H: Graphic MMU LUT entry 395 high
	// Position of LO field.
	GFXMMU_LUT395H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT395H_LO_Msk = 0x3ffff0

	// LUT396L: Graphic MMU LUT entry 396 low
	// Position of EN field.
	GFXMMU_LUT396L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT396L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT396L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT396L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT396L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT396L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT396L_LVB_Msk = 0xff0000

	// LUT396H: Graphic MMU LUT entry 396 high
	// Position of LO field.
	GFXMMU_LUT396H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT396H_LO_Msk = 0x3ffff0

	// LUT397L: Graphic MMU LUT entry 397 low
	// Position of EN field.
	GFXMMU_LUT397L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT397L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT397L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT397L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT397L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT397L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT397L_LVB_Msk = 0xff0000

	// LUT397H: Graphic MMU LUT entry 397 high
	// Position of LO field.
	GFXMMU_LUT397H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT397H_LO_Msk = 0x3ffff0

	// LUT398L: Graphic MMU LUT entry 398 low
	// Position of EN field.
	GFXMMU_LUT398L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT398L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT398L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT398L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT398L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT398L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT398L_LVB_Msk = 0xff0000

	// LUT398H: Graphic MMU LUT entry 398 high
	// Position of LO field.
	GFXMMU_LUT398H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT398H_LO_Msk = 0x3ffff0

	// LUT399L: Graphic MMU LUT entry 399 low
	// Position of EN field.
	GFXMMU_LUT399L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT399L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT399L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT399L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT399L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT399L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT399L_LVB_Msk = 0xff0000

	// LUT399H: Graphic MMU LUT entry 399 high
	// Position of LO field.
	GFXMMU_LUT399H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT399H_LO_Msk = 0x3ffff0

	// LUT400L: Graphic MMU LUT entry 400 low
	// Position of EN field.
	GFXMMU_LUT400L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT400L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT400L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT400L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT400L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT400L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT400L_LVB_Msk = 0xff0000

	// LUT400H: Graphic MMU LUT entry 400 high
	// Position of LO field.
	GFXMMU_LUT400H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT400H_LO_Msk = 0x3ffff0

	// LUT401L: Graphic MMU LUT entry 401 low
	// Position of EN field.
	GFXMMU_LUT401L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT401L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT401L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT401L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT401L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT401L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT401L_LVB_Msk = 0xff0000

	// LUT401H: Graphic MMU LUT entry 401 high
	// Position of LO field.
	GFXMMU_LUT401H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT401H_LO_Msk = 0x3ffff0

	// LUT402L: Graphic MMU LUT entry 402 low
	// Position of EN field.
	GFXMMU_LUT402L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT402L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT402L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT402L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT402L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT402L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT402L_LVB_Msk = 0xff0000

	// LUT402H: Graphic MMU LUT entry 402 high
	// Position of LO field.
	GFXMMU_LUT402H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT402H_LO_Msk = 0x3ffff0

	// LUT403L: Graphic MMU LUT entry 403 low
	// Position of EN field.
	GFXMMU_LUT403L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT403L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT403L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT403L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT403L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT403L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT403L_LVB_Msk = 0xff0000

	// LUT403H: Graphic MMU LUT entry 403 high
	// Position of LO field.
	GFXMMU_LUT403H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT403H_LO_Msk = 0x3ffff0

	// LUT404L: Graphic MMU LUT entry 404 low
	// Position of EN field.
	GFXMMU_LUT404L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT404L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT404L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT404L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT404L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT404L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT404L_LVB_Msk = 0xff0000

	// LUT404H: Graphic MMU LUT entry 404 high
	// Position of LO field.
	GFXMMU_LUT404H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT404H_LO_Msk = 0x3ffff0

	// LUT405L: Graphic MMU LUT entry 405 low
	// Position of EN field.
	GFXMMU_LUT405L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT405L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT405L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT405L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT405L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT405L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT405L_LVB_Msk = 0xff0000

	// LUT405H: Graphic MMU LUT entry 405 high
	// Position of LO field.
	GFXMMU_LUT405H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT405H_LO_Msk = 0x3ffff0

	// LUT406L: Graphic MMU LUT entry 406 low
	// Position of EN field.
	GFXMMU_LUT406L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT406L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT406L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT406L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT406L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT406L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT406L_LVB_Msk = 0xff0000

	// LUT406H: Graphic MMU LUT entry 406 high
	// Position of LO field.
	GFXMMU_LUT406H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT406H_LO_Msk = 0x3ffff0

	// LUT407L: Graphic MMU LUT entry 407 low
	// Position of EN field.
	GFXMMU_LUT407L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT407L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT407L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT407L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT407L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT407L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT407L_LVB_Msk = 0xff0000

	// LUT407H: Graphic MMU LUT entry 407 high
	// Position of LO field.
	GFXMMU_LUT407H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT407H_LO_Msk = 0x3ffff0

	// LUT408L: Graphic MMU LUT entry 408 low
	// Position of EN field.
	GFXMMU_LUT408L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT408L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT408L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT408L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT408L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT408L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT408L_LVB_Msk = 0xff0000

	// LUT408H: Graphic MMU LUT entry 408 high
	// Position of LO field.
	GFXMMU_LUT408H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT408H_LO_Msk = 0x3ffff0

	// LUT409L: Graphic MMU LUT entry 409 low
	// Position of EN field.
	GFXMMU_LUT409L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT409L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT409L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT409L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT409L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT409L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT409L_LVB_Msk = 0xff0000

	// LUT409H: Graphic MMU LUT entry 409 high
	// Position of LO field.
	GFXMMU_LUT409H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT409H_LO_Msk = 0x3ffff0

	// LUT410L: Graphic MMU LUT entry 410 low
	// Position of EN field.
	GFXMMU_LUT410L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT410L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT410L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT410L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT410L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT410L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT410L_LVB_Msk = 0xff0000

	// LUT410H: Graphic MMU LUT entry 410 high
	// Position of LO field.
	GFXMMU_LUT410H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT410H_LO_Msk = 0x3ffff0

	// LUT411L: Graphic MMU LUT entry 411 low
	// Position of EN field.
	GFXMMU_LUT411L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT411L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT411L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT411L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT411L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT411L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT411L_LVB_Msk = 0xff0000

	// LUT411H: Graphic MMU LUT entry 411 high
	// Position of LO field.
	GFXMMU_LUT411H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT411H_LO_Msk = 0x3ffff0

	// LUT412L: Graphic MMU LUT entry 412 low
	// Position of EN field.
	GFXMMU_LUT412L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT412L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT412L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT412L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT412L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT412L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT412L_LVB_Msk = 0xff0000

	// LUT412H: Graphic MMU LUT entry 412 high
	// Position of LO field.
	GFXMMU_LUT412H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT412H_LO_Msk = 0x3ffff0

	// LUT413L: Graphic MMU LUT entry 413 low
	// Position of EN field.
	GFXMMU_LUT413L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT413L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT413L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT413L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT413L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT413L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT413L_LVB_Msk = 0xff0000

	// LUT413H: Graphic MMU LUT entry 413 high
	// Position of LO field.
	GFXMMU_LUT413H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT413H_LO_Msk = 0x3ffff0

	// LUT414L: Graphic MMU LUT entry 414 low
	// Position of EN field.
	GFXMMU_LUT414L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT414L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT414L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT414L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT414L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT414L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT414L_LVB_Msk = 0xff0000

	// LUT414H: Graphic MMU LUT entry 414 high
	// Position of LO field.
	GFXMMU_LUT414H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT414H_LO_Msk = 0x3ffff0

	// LUT415L: Graphic MMU LUT entry 415 low
	// Position of EN field.
	GFXMMU_LUT415L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT415L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT415L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT415L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT415L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT415L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT415L_LVB_Msk = 0xff0000

	// LUT415H: Graphic MMU LUT entry 415 high
	// Position of LO field.
	GFXMMU_LUT415H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT415H_LO_Msk = 0x3ffff0

	// LUT416L: Graphic MMU LUT entry 416 low
	// Position of EN field.
	GFXMMU_LUT416L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT416L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT416L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT416L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT416L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT416L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT416L_LVB_Msk = 0xff0000

	// LUT416H: Graphic MMU LUT entry 416 high
	// Position of LO field.
	GFXMMU_LUT416H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT416H_LO_Msk = 0x3ffff0

	// LUT417L: Graphic MMU LUT entry 417 low
	// Position of EN field.
	GFXMMU_LUT417L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT417L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT417L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT417L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT417L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT417L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT417L_LVB_Msk = 0xff0000

	// LUT417H: Graphic MMU LUT entry 417 high
	// Position of LO field.
	GFXMMU_LUT417H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT417H_LO_Msk = 0x3ffff0

	// LUT418L: Graphic MMU LUT entry 418 low
	// Position of EN field.
	GFXMMU_LUT418L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT418L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT418L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT418L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT418L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT418L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT418L_LVB_Msk = 0xff0000

	// LUT418H: Graphic MMU LUT entry 418 high
	// Position of LO field.
	GFXMMU_LUT418H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT418H_LO_Msk = 0x3ffff0

	// LUT419L: Graphic MMU LUT entry 419 low
	// Position of EN field.
	GFXMMU_LUT419L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT419L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT419L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT419L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT419L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT419L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT419L_LVB_Msk = 0xff0000

	// LUT419H: Graphic MMU LUT entry 419 high
	// Position of LO field.
	GFXMMU_LUT419H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT419H_LO_Msk = 0x3ffff0

	// LUT420L: Graphic MMU LUT entry 420 low
	// Position of EN field.
	GFXMMU_LUT420L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT420L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT420L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT420L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT420L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT420L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT420L_LVB_Msk = 0xff0000

	// LUT420H: Graphic MMU LUT entry 420 high
	// Position of LO field.
	GFXMMU_LUT420H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT420H_LO_Msk = 0x3ffff0

	// LUT421L: Graphic MMU LUT entry 421 low
	// Position of EN field.
	GFXMMU_LUT421L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT421L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT421L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT421L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT421L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT421L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT421L_LVB_Msk = 0xff0000

	// LUT421H: Graphic MMU LUT entry 421 high
	// Position of LO field.
	GFXMMU_LUT421H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT421H_LO_Msk = 0x3ffff0

	// LUT422L: Graphic MMU LUT entry 422 low
	// Position of EN field.
	GFXMMU_LUT422L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT422L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT422L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT422L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT422L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT422L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT422L_LVB_Msk = 0xff0000

	// LUT422H: Graphic MMU LUT entry 422 high
	// Position of LO field.
	GFXMMU_LUT422H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT422H_LO_Msk = 0x3ffff0

	// LUT423L: Graphic MMU LUT entry 423 low
	// Position of EN field.
	GFXMMU_LUT423L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT423L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT423L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT423L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT423L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT423L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT423L_LVB_Msk = 0xff0000

	// LUT423H: Graphic MMU LUT entry 423 high
	// Position of LO field.
	GFXMMU_LUT423H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT423H_LO_Msk = 0x3ffff0

	// LUT424L: Graphic MMU LUT entry 424 low
	// Position of EN field.
	GFXMMU_LUT424L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT424L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT424L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT424L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT424L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT424L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT424L_LVB_Msk = 0xff0000

	// LUT424H: Graphic MMU LUT entry 424 high
	// Position of LO field.
	GFXMMU_LUT424H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT424H_LO_Msk = 0x3ffff0

	// LUT425L: Graphic MMU LUT entry 425 low
	// Position of EN field.
	GFXMMU_LUT425L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT425L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT425L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT425L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT425L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT425L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT425L_LVB_Msk = 0xff0000

	// LUT425H: Graphic MMU LUT entry 425 high
	// Position of LO field.
	GFXMMU_LUT425H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT425H_LO_Msk = 0x3ffff0

	// LUT426L: Graphic MMU LUT entry 426 low
	// Position of EN field.
	GFXMMU_LUT426L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT426L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT426L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT426L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT426L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT426L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT426L_LVB_Msk = 0xff0000

	// LUT426H: Graphic MMU LUT entry 426 high
	// Position of LO field.
	GFXMMU_LUT426H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT426H_LO_Msk = 0x3ffff0

	// LUT427L: Graphic MMU LUT entry 427 low
	// Position of EN field.
	GFXMMU_LUT427L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT427L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT427L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT427L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT427L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT427L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT427L_LVB_Msk = 0xff0000

	// LUT427H: Graphic MMU LUT entry 427 high
	// Position of LO field.
	GFXMMU_LUT427H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT427H_LO_Msk = 0x3ffff0

	// LUT428L: Graphic MMU LUT entry 428 low
	// Position of EN field.
	GFXMMU_LUT428L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT428L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT428L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT428L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT428L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT428L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT428L_LVB_Msk = 0xff0000

	// LUT428H: Graphic MMU LUT entry 428 high
	// Position of LO field.
	GFXMMU_LUT428H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT428H_LO_Msk = 0x3ffff0

	// LUT429L: Graphic MMU LUT entry 429 low
	// Position of EN field.
	GFXMMU_LUT429L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT429L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT429L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT429L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT429L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT429L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT429L_LVB_Msk = 0xff0000

	// LUT429H: Graphic MMU LUT entry 429 high
	// Position of LO field.
	GFXMMU_LUT429H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT429H_LO_Msk = 0x3ffff0

	// LUT430L: Graphic MMU LUT entry 430 low
	// Position of EN field.
	GFXMMU_LUT430L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT430L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT430L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT430L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT430L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT430L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT430L_LVB_Msk = 0xff0000

	// LUT430H: Graphic MMU LUT entry 430 high
	// Position of LO field.
	GFXMMU_LUT430H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT430H_LO_Msk = 0x3ffff0

	// LUT431L: Graphic MMU LUT entry 431 low
	// Position of EN field.
	GFXMMU_LUT431L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT431L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT431L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT431L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT431L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT431L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT431L_LVB_Msk = 0xff0000

	// LUT431H: Graphic MMU LUT entry 431 high
	// Position of LO field.
	GFXMMU_LUT431H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT431H_LO_Msk = 0x3ffff0

	// LUT432L: Graphic MMU LUT entry 432 low
	// Position of EN field.
	GFXMMU_LUT432L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT432L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT432L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT432L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT432L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT432L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT432L_LVB_Msk = 0xff0000

	// LUT432H: Graphic MMU LUT entry 432 high
	// Position of LO field.
	GFXMMU_LUT432H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT432H_LO_Msk = 0x3ffff0

	// LUT433L: Graphic MMU LUT entry 433 low
	// Position of EN field.
	GFXMMU_LUT433L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT433L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT433L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT433L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT433L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT433L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT433L_LVB_Msk = 0xff0000

	// LUT433H: Graphic MMU LUT entry 433 high
	// Position of LO field.
	GFXMMU_LUT433H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT433H_LO_Msk = 0x3ffff0

	// LUT434L: Graphic MMU LUT entry 434 low
	// Position of EN field.
	GFXMMU_LUT434L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT434L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT434L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT434L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT434L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT434L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT434L_LVB_Msk = 0xff0000

	// LUT434H: Graphic MMU LUT entry 434 high
	// Position of LO field.
	GFXMMU_LUT434H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT434H_LO_Msk = 0x3ffff0

	// LUT435L: Graphic MMU LUT entry 435 low
	// Position of EN field.
	GFXMMU_LUT435L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT435L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT435L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT435L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT435L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT435L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT435L_LVB_Msk = 0xff0000

	// LUT435H: Graphic MMU LUT entry 435 high
	// Position of LO field.
	GFXMMU_LUT435H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT435H_LO_Msk = 0x3ffff0

	// LUT436L: Graphic MMU LUT entry 436 low
	// Position of EN field.
	GFXMMU_LUT436L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT436L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT436L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT436L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT436L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT436L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT436L_LVB_Msk = 0xff0000

	// LUT436H: Graphic MMU LUT entry 436 high
	// Position of LO field.
	GFXMMU_LUT436H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT436H_LO_Msk = 0x3ffff0

	// LUT437L: Graphic MMU LUT entry 437 low
	// Position of EN field.
	GFXMMU_LUT437L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT437L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT437L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT437L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT437L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT437L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT437L_LVB_Msk = 0xff0000

	// LUT437H: Graphic MMU LUT entry 437 high
	// Position of LO field.
	GFXMMU_LUT437H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT437H_LO_Msk = 0x3ffff0

	// LUT438L: Graphic MMU LUT entry 438 low
	// Position of EN field.
	GFXMMU_LUT438L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT438L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT438L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT438L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT438L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT438L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT438L_LVB_Msk = 0xff0000

	// LUT438H: Graphic MMU LUT entry 438 high
	// Position of LO field.
	GFXMMU_LUT438H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT438H_LO_Msk = 0x3ffff0

	// LUT439L: Graphic MMU LUT entry 439 low
	// Position of EN field.
	GFXMMU_LUT439L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT439L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT439L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT439L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT439L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT439L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT439L_LVB_Msk = 0xff0000

	// LUT439H: Graphic MMU LUT entry 439 high
	// Position of LO field.
	GFXMMU_LUT439H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT439H_LO_Msk = 0x3ffff0

	// LUT440L: Graphic MMU LUT entry 440 low
	// Position of EN field.
	GFXMMU_LUT440L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT440L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT440L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT440L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT440L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT440L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT440L_LVB_Msk = 0xff0000

	// LUT440H: Graphic MMU LUT entry 440 high
	// Position of LO field.
	GFXMMU_LUT440H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT440H_LO_Msk = 0x3ffff0

	// LUT441L: Graphic MMU LUT entry 441 low
	// Position of EN field.
	GFXMMU_LUT441L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT441L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT441L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT441L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT441L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT441L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT441L_LVB_Msk = 0xff0000

	// LUT441H: Graphic MMU LUT entry 441 high
	// Position of LO field.
	GFXMMU_LUT441H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT441H_LO_Msk = 0x3ffff0

	// LUT442L: Graphic MMU LUT entry 442 low
	// Position of EN field.
	GFXMMU_LUT442L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT442L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT442L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT442L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT442L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT442L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT442L_LVB_Msk = 0xff0000

	// LUT442H: Graphic MMU LUT entry 442 high
	// Position of LO field.
	GFXMMU_LUT442H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT442H_LO_Msk = 0x3ffff0

	// LUT443L: Graphic MMU LUT entry 443 low
	// Position of EN field.
	GFXMMU_LUT443L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT443L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT443L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT443L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT443L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT443L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT443L_LVB_Msk = 0xff0000

	// LUT443H: Graphic MMU LUT entry 443 high
	// Position of LO field.
	GFXMMU_LUT443H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT443H_LO_Msk = 0x3ffff0

	// LUT444L: Graphic MMU LUT entry 444 low
	// Position of EN field.
	GFXMMU_LUT444L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT444L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT444L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT444L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT444L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT444L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT444L_LVB_Msk = 0xff0000

	// LUT444H: Graphic MMU LUT entry 444 high
	// Position of LO field.
	GFXMMU_LUT444H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT444H_LO_Msk = 0x3ffff0

	// LUT445L: Graphic MMU LUT entry 445 low
	// Position of EN field.
	GFXMMU_LUT445L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT445L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT445L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT445L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT445L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT445L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT445L_LVB_Msk = 0xff0000

	// LUT445H: Graphic MMU LUT entry 445 high
	// Position of LO field.
	GFXMMU_LUT445H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT445H_LO_Msk = 0x3ffff0

	// LUT446L: Graphic MMU LUT entry 446 low
	// Position of EN field.
	GFXMMU_LUT446L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT446L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT446L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT446L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT446L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT446L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT446L_LVB_Msk = 0xff0000

	// LUT446H: Graphic MMU LUT entry 446 high
	// Position of LO field.
	GFXMMU_LUT446H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT446H_LO_Msk = 0x3ffff0

	// LUT447L: Graphic MMU LUT entry 447 low
	// Position of EN field.
	GFXMMU_LUT447L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT447L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT447L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT447L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT447L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT447L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT447L_LVB_Msk = 0xff0000

	// LUT447H: Graphic MMU LUT entry 447 high
	// Position of LO field.
	GFXMMU_LUT447H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT447H_LO_Msk = 0x3ffff0

	// LUT448L: Graphic MMU LUT entry 448 low
	// Position of EN field.
	GFXMMU_LUT448L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT448L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT448L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT448L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT448L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT448L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT448L_LVB_Msk = 0xff0000

	// LUT448H: Graphic MMU LUT entry 448 high
	// Position of LO field.
	GFXMMU_LUT448H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT448H_LO_Msk = 0x3ffff0

	// LUT449L: Graphic MMU LUT entry 449 low
	// Position of EN field.
	GFXMMU_LUT449L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT449L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT449L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT449L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT449L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT449L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT449L_LVB_Msk = 0xff0000

	// LUT449H: Graphic MMU LUT entry 449 high
	// Position of LO field.
	GFXMMU_LUT449H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT449H_LO_Msk = 0x3ffff0

	// LUT450L: Graphic MMU LUT entry 450 low
	// Position of EN field.
	GFXMMU_LUT450L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT450L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT450L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT450L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT450L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT450L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT450L_LVB_Msk = 0xff0000

	// LUT450H: Graphic MMU LUT entry 450 high
	// Position of LO field.
	GFXMMU_LUT450H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT450H_LO_Msk = 0x3ffff0

	// LUT451L: Graphic MMU LUT entry 451 low
	// Position of EN field.
	GFXMMU_LUT451L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT451L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT451L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT451L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT451L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT451L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT451L_LVB_Msk = 0xff0000

	// LUT451H: Graphic MMU LUT entry 451 high
	// Position of LO field.
	GFXMMU_LUT451H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT451H_LO_Msk = 0x3ffff0

	// LUT452L: Graphic MMU LUT entry 452 low
	// Position of EN field.
	GFXMMU_LUT452L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT452L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT452L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT452L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT452L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT452L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT452L_LVB_Msk = 0xff0000

	// LUT452H: Graphic MMU LUT entry 452 high
	// Position of LO field.
	GFXMMU_LUT452H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT452H_LO_Msk = 0x3ffff0

	// LUT453L: Graphic MMU LUT entry 453 low
	// Position of EN field.
	GFXMMU_LUT453L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT453L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT453L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT453L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT453L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT453L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT453L_LVB_Msk = 0xff0000

	// LUT453H: Graphic MMU LUT entry 453 high
	// Position of LO field.
	GFXMMU_LUT453H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT453H_LO_Msk = 0x3ffff0

	// LUT454L: Graphic MMU LUT entry 454 low
	// Position of EN field.
	GFXMMU_LUT454L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT454L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT454L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT454L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT454L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT454L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT454L_LVB_Msk = 0xff0000

	// LUT454H: Graphic MMU LUT entry 454 high
	// Position of LO field.
	GFXMMU_LUT454H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT454H_LO_Msk = 0x3ffff0

	// LUT455L: Graphic MMU LUT entry 455 low
	// Position of EN field.
	GFXMMU_LUT455L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT455L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT455L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT455L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT455L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT455L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT455L_LVB_Msk = 0xff0000

	// LUT455H: Graphic MMU LUT entry 455 high
	// Position of LO field.
	GFXMMU_LUT455H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT455H_LO_Msk = 0x3ffff0

	// LUT456L: Graphic MMU LUT entry 456 low
	// Position of EN field.
	GFXMMU_LUT456L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT456L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT456L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT456L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT456L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT456L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT456L_LVB_Msk = 0xff0000

	// LUT456H: Graphic MMU LUT entry 456 high
	// Position of LO field.
	GFXMMU_LUT456H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT456H_LO_Msk = 0x3ffff0

	// LUT457L: Graphic MMU LUT entry 457 low
	// Position of EN field.
	GFXMMU_LUT457L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT457L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT457L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT457L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT457L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT457L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT457L_LVB_Msk = 0xff0000

	// LUT457H: Graphic MMU LUT entry 457 high
	// Position of LO field.
	GFXMMU_LUT457H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT457H_LO_Msk = 0x3ffff0

	// LUT458L: Graphic MMU LUT entry 458 low
	// Position of EN field.
	GFXMMU_LUT458L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT458L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT458L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT458L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT458L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT458L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT458L_LVB_Msk = 0xff0000

	// LUT458H: Graphic MMU LUT entry 458 high
	// Position of LO field.
	GFXMMU_LUT458H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT458H_LO_Msk = 0x3ffff0

	// LUT459L: Graphic MMU LUT entry 459 low
	// Position of EN field.
	GFXMMU_LUT459L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT459L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT459L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT459L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT459L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT459L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT459L_LVB_Msk = 0xff0000

	// LUT459H: Graphic MMU LUT entry 459 high
	// Position of LO field.
	GFXMMU_LUT459H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT459H_LO_Msk = 0x3ffff0

	// LUT460L: Graphic MMU LUT entry 460 low
	// Position of EN field.
	GFXMMU_LUT460L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT460L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT460L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT460L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT460L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT460L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT460L_LVB_Msk = 0xff0000

	// LUT460H: Graphic MMU LUT entry 460 high
	// Position of LO field.
	GFXMMU_LUT460H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT460H_LO_Msk = 0x3ffff0

	// LUT461L: Graphic MMU LUT entry 461 low
	// Position of EN field.
	GFXMMU_LUT461L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT461L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT461L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT461L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT461L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT461L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT461L_LVB_Msk = 0xff0000

	// LUT461H: Graphic MMU LUT entry 461 high
	// Position of LO field.
	GFXMMU_LUT461H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT461H_LO_Msk = 0x3ffff0

	// LUT462L: Graphic MMU LUT entry 462 low
	// Position of EN field.
	GFXMMU_LUT462L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT462L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT462L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT462L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT462L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT462L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT462L_LVB_Msk = 0xff0000

	// LUT462H: Graphic MMU LUT entry 462 high
	// Position of LO field.
	GFXMMU_LUT462H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT462H_LO_Msk = 0x3ffff0

	// LUT463L: Graphic MMU LUT entry 463 low
	// Position of EN field.
	GFXMMU_LUT463L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT463L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT463L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT463L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT463L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT463L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT463L_LVB_Msk = 0xff0000

	// LUT463H: Graphic MMU LUT entry 463 high
	// Position of LO field.
	GFXMMU_LUT463H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT463H_LO_Msk = 0x3ffff0

	// LUT464L: Graphic MMU LUT entry 464 low
	// Position of EN field.
	GFXMMU_LUT464L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT464L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT464L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT464L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT464L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT464L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT464L_LVB_Msk = 0xff0000

	// LUT464H: Graphic MMU LUT entry 464 high
	// Position of LO field.
	GFXMMU_LUT464H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT464H_LO_Msk = 0x3ffff0

	// LUT465L: Graphic MMU LUT entry 465 low
	// Position of EN field.
	GFXMMU_LUT465L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT465L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT465L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT465L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT465L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT465L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT465L_LVB_Msk = 0xff0000

	// LUT465H: Graphic MMU LUT entry 465 high
	// Position of LO field.
	GFXMMU_LUT465H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT465H_LO_Msk = 0x3ffff0

	// LUT466L: Graphic MMU LUT entry 466 low
	// Position of EN field.
	GFXMMU_LUT466L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT466L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT466L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT466L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT466L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT466L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT466L_LVB_Msk = 0xff0000

	// LUT466H: Graphic MMU LUT entry 466 high
	// Position of LO field.
	GFXMMU_LUT466H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT466H_LO_Msk = 0x3ffff0

	// LUT467L: Graphic MMU LUT entry 467 low
	// Position of EN field.
	GFXMMU_LUT467L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT467L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT467L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT467L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT467L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT467L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT467L_LVB_Msk = 0xff0000

	// LUT467H: Graphic MMU LUT entry 467 high
	// Position of LO field.
	GFXMMU_LUT467H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT467H_LO_Msk = 0x3ffff0

	// LUT468L: Graphic MMU LUT entry 468 low
	// Position of EN field.
	GFXMMU_LUT468L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT468L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT468L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT468L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT468L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT468L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT468L_LVB_Msk = 0xff0000

	// LUT468H: Graphic MMU LUT entry 468 high
	// Position of LO field.
	GFXMMU_LUT468H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT468H_LO_Msk = 0x3ffff0

	// LUT469L: Graphic MMU LUT entry 469 low
	// Position of EN field.
	GFXMMU_LUT469L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT469L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT469L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT469L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT469L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT469L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT469L_LVB_Msk = 0xff0000

	// LUT469H: Graphic MMU LUT entry 469 high
	// Position of LO field.
	GFXMMU_LUT469H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT469H_LO_Msk = 0x3ffff0

	// LUT470L: Graphic MMU LUT entry 470 low
	// Position of EN field.
	GFXMMU_LUT470L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT470L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT470L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT470L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT470L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT470L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT470L_LVB_Msk = 0xff0000

	// LUT470H: Graphic MMU LUT entry 470 high
	// Position of LO field.
	GFXMMU_LUT470H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT470H_LO_Msk = 0x3ffff0

	// LUT471L: Graphic MMU LUT entry 471 low
	// Position of EN field.
	GFXMMU_LUT471L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT471L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT471L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT471L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT471L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT471L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT471L_LVB_Msk = 0xff0000

	// LUT471H: Graphic MMU LUT entry 471 high
	// Position of LO field.
	GFXMMU_LUT471H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT471H_LO_Msk = 0x3ffff0

	// LUT472L: Graphic MMU LUT entry 472 low
	// Position of EN field.
	GFXMMU_LUT472L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT472L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT472L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT472L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT472L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT472L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT472L_LVB_Msk = 0xff0000

	// LUT472H: Graphic MMU LUT entry 472 high
	// Position of LO field.
	GFXMMU_LUT472H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT472H_LO_Msk = 0x3ffff0

	// LUT473L: Graphic MMU LUT entry 473 low
	// Position of EN field.
	GFXMMU_LUT473L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT473L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT473L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT473L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT473L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT473L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT473L_LVB_Msk = 0xff0000

	// LUT473H: Graphic MMU LUT entry 473 high
	// Position of LO field.
	GFXMMU_LUT473H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT473H_LO_Msk = 0x3ffff0

	// LUT474L: Graphic MMU LUT entry 474 low
	// Position of EN field.
	GFXMMU_LUT474L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT474L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT474L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT474L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT474L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT474L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT474L_LVB_Msk = 0xff0000

	// LUT474H: Graphic MMU LUT entry 474 high
	// Position of LO field.
	GFXMMU_LUT474H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT474H_LO_Msk = 0x3ffff0

	// LUT475L: Graphic MMU LUT entry 475 low
	// Position of EN field.
	GFXMMU_LUT475L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT475L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT475L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT475L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT475L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT475L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT475L_LVB_Msk = 0xff0000

	// LUT475H: Graphic MMU LUT entry 475 high
	// Position of LO field.
	GFXMMU_LUT475H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT475H_LO_Msk = 0x3ffff0

	// LUT476L: Graphic MMU LUT entry 476 low
	// Position of EN field.
	GFXMMU_LUT476L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT476L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT476L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT476L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT476L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT476L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT476L_LVB_Msk = 0xff0000

	// LUT476H: Graphic MMU LUT entry 476 high
	// Position of LO field.
	GFXMMU_LUT476H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT476H_LO_Msk = 0x3ffff0

	// LUT477L: Graphic MMU LUT entry 477 low
	// Position of EN field.
	GFXMMU_LUT477L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT477L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT477L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT477L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT477L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT477L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT477L_LVB_Msk = 0xff0000

	// LUT477H: Graphic MMU LUT entry 477 high
	// Position of LO field.
	GFXMMU_LUT477H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT477H_LO_Msk = 0x3ffff0

	// LUT478L: Graphic MMU LUT entry 478 low
	// Position of EN field.
	GFXMMU_LUT478L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT478L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT478L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT478L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT478L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT478L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT478L_LVB_Msk = 0xff0000

	// LUT478H: Graphic MMU LUT entry 478 high
	// Position of LO field.
	GFXMMU_LUT478H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT478H_LO_Msk = 0x3ffff0

	// LUT479L: Graphic MMU LUT entry 479 low
	// Position of EN field.
	GFXMMU_LUT479L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT479L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT479L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT479L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT479L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT479L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT479L_LVB_Msk = 0xff0000

	// LUT479H: Graphic MMU LUT entry 479 high
	// Position of LO field.
	GFXMMU_LUT479H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT479H_LO_Msk = 0x3ffff0

	// LUT480L: Graphic MMU LUT entry 480 low
	// Position of EN field.
	GFXMMU_LUT480L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT480L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT480L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT480L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT480L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT480L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT480L_LVB_Msk = 0xff0000

	// LUT480H: Graphic MMU LUT entry 480 high
	// Position of LO field.
	GFXMMU_LUT480H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT480H_LO_Msk = 0x3ffff0

	// LUT481L: Graphic MMU LUT entry 481 low
	// Position of EN field.
	GFXMMU_LUT481L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT481L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT481L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT481L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT481L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT481L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT481L_LVB_Msk = 0xff0000

	// LUT481H: Graphic MMU LUT entry 481 high
	// Position of LO field.
	GFXMMU_LUT481H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT481H_LO_Msk = 0x3ffff0

	// LUT482L: Graphic MMU LUT entry 482 low
	// Position of EN field.
	GFXMMU_LUT482L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT482L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT482L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT482L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT482L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT482L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT482L_LVB_Msk = 0xff0000

	// LUT482H: Graphic MMU LUT entry 482 high
	// Position of LO field.
	GFXMMU_LUT482H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT482H_LO_Msk = 0x3ffff0

	// LUT483L: Graphic MMU LUT entry 483 low
	// Position of EN field.
	GFXMMU_LUT483L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT483L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT483L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT483L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT483L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT483L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT483L_LVB_Msk = 0xff0000

	// LUT483H: Graphic MMU LUT entry 483 high
	// Position of LO field.
	GFXMMU_LUT483H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT483H_LO_Msk = 0x3ffff0

	// LUT484L: Graphic MMU LUT entry 484 low
	// Position of EN field.
	GFXMMU_LUT484L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT484L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT484L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT484L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT484L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT484L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT484L_LVB_Msk = 0xff0000

	// LUT484H: Graphic MMU LUT entry 484 high
	// Position of LO field.
	GFXMMU_LUT484H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT484H_LO_Msk = 0x3ffff0

	// LUT485L: Graphic MMU LUT entry 485 low
	// Position of EN field.
	GFXMMU_LUT485L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT485L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT485L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT485L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT485L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT485L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT485L_LVB_Msk = 0xff0000

	// LUT485H: Graphic MMU LUT entry 485 high
	// Position of LO field.
	GFXMMU_LUT485H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT485H_LO_Msk = 0x3ffff0

	// LUT486L: Graphic MMU LUT entry 486 low
	// Position of EN field.
	GFXMMU_LUT486L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT486L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT486L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT486L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT486L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT486L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT486L_LVB_Msk = 0xff0000

	// LUT486H: Graphic MMU LUT entry 486 high
	// Position of LO field.
	GFXMMU_LUT486H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT486H_LO_Msk = 0x3ffff0

	// LUT487L: Graphic MMU LUT entry 487 low
	// Position of EN field.
	GFXMMU_LUT487L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT487L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT487L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT487L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT487L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT487L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT487L_LVB_Msk = 0xff0000

	// LUT487H: Graphic MMU LUT entry 487 high
	// Position of LO field.
	GFXMMU_LUT487H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT487H_LO_Msk = 0x3ffff0

	// LUT488L: Graphic MMU LUT entry 488 low
	// Position of EN field.
	GFXMMU_LUT488L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT488L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT488L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT488L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT488L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT488L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT488L_LVB_Msk = 0xff0000

	// LUT488H: Graphic MMU LUT entry 488 high
	// Position of LO field.
	GFXMMU_LUT488H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT488H_LO_Msk = 0x3ffff0

	// LUT489L: Graphic MMU LUT entry 489 low
	// Position of EN field.
	GFXMMU_LUT489L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT489L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT489L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT489L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT489L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT489L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT489L_LVB_Msk = 0xff0000

	// LUT489H: Graphic MMU LUT entry 489 high
	// Position of LO field.
	GFXMMU_LUT489H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT489H_LO_Msk = 0x3ffff0

	// LUT490L: Graphic MMU LUT entry 490 low
	// Position of EN field.
	GFXMMU_LUT490L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT490L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT490L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT490L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT490L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT490L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT490L_LVB_Msk = 0xff0000

	// LUT490H: Graphic MMU LUT entry 490 high
	// Position of LO field.
	GFXMMU_LUT490H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT490H_LO_Msk = 0x3ffff0

	// LUT491L: Graphic MMU LUT entry 491 low
	// Position of EN field.
	GFXMMU_LUT491L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT491L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT491L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT491L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT491L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT491L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT491L_LVB_Msk = 0xff0000

	// LUT491H: Graphic MMU LUT entry 491 high
	// Position of LO field.
	GFXMMU_LUT491H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT491H_LO_Msk = 0x3ffff0

	// LUT492L: Graphic MMU LUT entry 492 low
	// Position of EN field.
	GFXMMU_LUT492L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT492L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT492L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT492L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT492L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT492L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT492L_LVB_Msk = 0xff0000

	// LUT492H: Graphic MMU LUT entry 492 high
	// Position of LO field.
	GFXMMU_LUT492H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT492H_LO_Msk = 0x3ffff0

	// LUT493L: Graphic MMU LUT entry 493 low
	// Position of EN field.
	GFXMMU_LUT493L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT493L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT493L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT493L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT493L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT493L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT493L_LVB_Msk = 0xff0000

	// LUT493H: Graphic MMU LUT entry 493 high
	// Position of LO field.
	GFXMMU_LUT493H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT493H_LO_Msk = 0x3ffff0

	// LUT494L: Graphic MMU LUT entry 494 low
	// Position of EN field.
	GFXMMU_LUT494L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT494L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT494L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT494L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT494L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT494L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT494L_LVB_Msk = 0xff0000

	// LUT494H: Graphic MMU LUT entry 494 high
	// Position of LO field.
	GFXMMU_LUT494H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT494H_LO_Msk = 0x3ffff0

	// LUT495L: Graphic MMU LUT entry 495 low
	// Position of EN field.
	GFXMMU_LUT495L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT495L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT495L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT495L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT495L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT495L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT495L_LVB_Msk = 0xff0000

	// LUT495H: Graphic MMU LUT entry 495 high
	// Position of LO field.
	GFXMMU_LUT495H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT495H_LO_Msk = 0x3ffff0

	// LUT496L: Graphic MMU LUT entry 496 low
	// Position of EN field.
	GFXMMU_LUT496L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT496L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT496L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT496L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT496L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT496L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT496L_LVB_Msk = 0xff0000

	// LUT496H: Graphic MMU LUT entry 496 high
	// Position of LO field.
	GFXMMU_LUT496H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT496H_LO_Msk = 0x3ffff0

	// LUT497L: Graphic MMU LUT entry 497 low
	// Position of EN field.
	GFXMMU_LUT497L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT497L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT497L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT497L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT497L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT497L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT497L_LVB_Msk = 0xff0000

	// LUT497H: Graphic MMU LUT entry 497 high
	// Position of LO field.
	GFXMMU_LUT497H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT497H_LO_Msk = 0x3ffff0

	// LUT498L: Graphic MMU LUT entry 498 low
	// Position of EN field.
	GFXMMU_LUT498L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT498L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT498L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT498L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT498L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT498L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT498L_LVB_Msk = 0xff0000

	// LUT498H: Graphic MMU LUT entry 498 high
	// Position of LO field.
	GFXMMU_LUT498H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT498H_LO_Msk = 0x3ffff0

	// LUT499L: Graphic MMU LUT entry 499 low
	// Position of EN field.
	GFXMMU_LUT499L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT499L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT499L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT499L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT499L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT499L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT499L_LVB_Msk = 0xff0000

	// LUT499H: Graphic MMU LUT entry 499 high
	// Position of LO field.
	GFXMMU_LUT499H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT499H_LO_Msk = 0x3ffff0

	// LUT500L: Graphic MMU LUT entry 500 low
	// Position of EN field.
	GFXMMU_LUT500L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT500L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT500L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT500L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT500L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT500L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT500L_LVB_Msk = 0xff0000

	// LUT500H: Graphic MMU LUT entry 500 high
	// Position of LO field.
	GFXMMU_LUT500H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT500H_LO_Msk = 0x3ffff0

	// LUT501L: Graphic MMU LUT entry 501 low
	// Position of EN field.
	GFXMMU_LUT501L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT501L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT501L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT501L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT501L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT501L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT501L_LVB_Msk = 0xff0000

	// LUT501H: Graphic MMU LUT entry 501 high
	// Position of LO field.
	GFXMMU_LUT501H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT501H_LO_Msk = 0x3ffff0

	// LUT502L: Graphic MMU LUT entry 502 low
	// Position of EN field.
	GFXMMU_LUT502L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT502L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT502L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT502L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT502L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT502L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT502L_LVB_Msk = 0xff0000

	// LUT502H: Graphic MMU LUT entry 502 high
	// Position of LO field.
	GFXMMU_LUT502H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT502H_LO_Msk = 0x3ffff0

	// LUT503L: Graphic MMU LUT entry 503 low
	// Position of EN field.
	GFXMMU_LUT503L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT503L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT503L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT503L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT503L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT503L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT503L_LVB_Msk = 0xff0000

	// LUT503H: Graphic MMU LUT entry 503 high
	// Position of LO field.
	GFXMMU_LUT503H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT503H_LO_Msk = 0x3ffff0

	// LUT504L: Graphic MMU LUT entry 504 low
	// Position of EN field.
	GFXMMU_LUT504L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT504L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT504L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT504L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT504L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT504L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT504L_LVB_Msk = 0xff0000

	// LUT504H: Graphic MMU LUT entry 504 high
	// Position of LO field.
	GFXMMU_LUT504H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT504H_LO_Msk = 0x3ffff0

	// LUT505L: Graphic MMU LUT entry 505 low
	// Position of EN field.
	GFXMMU_LUT505L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT505L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT505L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT505L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT505L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT505L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT505L_LVB_Msk = 0xff0000

	// LUT505H: Graphic MMU LUT entry 505 high
	// Position of LO field.
	GFXMMU_LUT505H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT505H_LO_Msk = 0x3ffff0

	// LUT506L: Graphic MMU LUT entry 506 low
	// Position of EN field.
	GFXMMU_LUT506L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT506L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT506L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT506L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT506L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT506L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT506L_LVB_Msk = 0xff0000

	// LUT506H: Graphic MMU LUT entry 506 high
	// Position of LO field.
	GFXMMU_LUT506H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT506H_LO_Msk = 0x3ffff0

	// LUT507L: Graphic MMU LUT entry 507 low
	// Position of EN field.
	GFXMMU_LUT507L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT507L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT507L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT507L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT507L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT507L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT507L_LVB_Msk = 0xff0000

	// LUT507H: Graphic MMU LUT entry 507 high
	// Position of LO field.
	GFXMMU_LUT507H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT507H_LO_Msk = 0x3ffff0

	// LUT508L: Graphic MMU LUT entry 508 low
	// Position of EN field.
	GFXMMU_LUT508L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT508L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT508L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT508L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT508L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT508L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT508L_LVB_Msk = 0xff0000

	// LUT508H: Graphic MMU LUT entry 508 high
	// Position of LO field.
	GFXMMU_LUT508H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT508H_LO_Msk = 0x3ffff0

	// LUT509L: Graphic MMU LUT entry 509 low
	// Position of EN field.
	GFXMMU_LUT509L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT509L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT509L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT509L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT509L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT509L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT509L_LVB_Msk = 0xff0000

	// LUT509H: Graphic MMU LUT entry 509 high
	// Position of LO field.
	GFXMMU_LUT509H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT509H_LO_Msk = 0x3ffff0

	// LUT510L: Graphic MMU LUT entry 510 low
	// Position of EN field.
	GFXMMU_LUT510L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT510L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT510L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT510L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT510L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT510L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT510L_LVB_Msk = 0xff0000

	// LUT510H: Graphic MMU LUT entry 510 high
	// Position of LO field.
	GFXMMU_LUT510H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT510H_LO_Msk = 0x3ffff0

	// LUT511L: Graphic MMU LUT entry 511 low
	// Position of EN field.
	GFXMMU_LUT511L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT511L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT511L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT511L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT511L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT511L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT511L_LVB_Msk = 0xff0000

	// LUT511H: Graphic MMU LUT entry 511 high
	// Position of LO field.
	GFXMMU_LUT511H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT511H_LO_Msk = 0x3ffff0

	// LUT512L: Graphic MMU LUT entry 512 low
	// Position of EN field.
	GFXMMU_LUT512L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT512L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT512L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT512L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT512L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT512L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT512L_LVB_Msk = 0xff0000

	// LUT512H: Graphic MMU LUT entry 512 high
	// Position of LO field.
	GFXMMU_LUT512H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT512H_LO_Msk = 0x3ffff0

	// LUT513L: Graphic MMU LUT entry 513 low
	// Position of EN field.
	GFXMMU_LUT513L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT513L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT513L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT513L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT513L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT513L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT513L_LVB_Msk = 0xff0000

	// LUT513H: Graphic MMU LUT entry 513 high
	// Position of LO field.
	GFXMMU_LUT513H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT513H_LO_Msk = 0x3ffff0

	// LUT514L: Graphic MMU LUT entry 514 low
	// Position of EN field.
	GFXMMU_LUT514L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT514L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT514L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT514L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT514L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT514L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT514L_LVB_Msk = 0xff0000

	// LUT514H: Graphic MMU LUT entry 514 high
	// Position of LO field.
	GFXMMU_LUT514H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT514H_LO_Msk = 0x3ffff0

	// LUT515L: Graphic MMU LUT entry 515 low
	// Position of EN field.
	GFXMMU_LUT515L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT515L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT515L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT515L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT515L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT515L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT515L_LVB_Msk = 0xff0000

	// LUT515H: Graphic MMU LUT entry 515 high
	// Position of LO field.
	GFXMMU_LUT515H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT515H_LO_Msk = 0x3ffff0

	// LUT516L: Graphic MMU LUT entry 516 low
	// Position of EN field.
	GFXMMU_LUT516L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT516L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT516L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT516L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT516L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT516L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT516L_LVB_Msk = 0xff0000

	// LUT516H: Graphic MMU LUT entry 516 high
	// Position of LO field.
	GFXMMU_LUT516H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT516H_LO_Msk = 0x3ffff0

	// LUT517L: Graphic MMU LUT entry 517 low
	// Position of EN field.
	GFXMMU_LUT517L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT517L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT517L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT517L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT517L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT517L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT517L_LVB_Msk = 0xff0000

	// LUT517H: Graphic MMU LUT entry 517 high
	// Position of LO field.
	GFXMMU_LUT517H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT517H_LO_Msk = 0x3ffff0

	// LUT518L: Graphic MMU LUT entry 518 low
	// Position of EN field.
	GFXMMU_LUT518L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT518L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT518L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT518L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT518L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT518L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT518L_LVB_Msk = 0xff0000

	// LUT518H: Graphic MMU LUT entry 518 high
	// Position of LO field.
	GFXMMU_LUT518H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT518H_LO_Msk = 0x3ffff0

	// LUT519L: Graphic MMU LUT entry 519 low
	// Position of EN field.
	GFXMMU_LUT519L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT519L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT519L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT519L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT519L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT519L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT519L_LVB_Msk = 0xff0000

	// LUT519H: Graphic MMU LUT entry 519 high
	// Position of LO field.
	GFXMMU_LUT519H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT519H_LO_Msk = 0x3ffff0

	// LUT520L: Graphic MMU LUT entry 520 low
	// Position of EN field.
	GFXMMU_LUT520L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT520L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT520L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT520L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT520L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT520L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT520L_LVB_Msk = 0xff0000

	// LUT520H: Graphic MMU LUT entry 520 high
	// Position of LO field.
	GFXMMU_LUT520H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT520H_LO_Msk = 0x3ffff0

	// LUT521L: Graphic MMU LUT entry 521 low
	// Position of EN field.
	GFXMMU_LUT521L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT521L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT521L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT521L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT521L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT521L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT521L_LVB_Msk = 0xff0000

	// LUT521H: Graphic MMU LUT entry 521 high
	// Position of LO field.
	GFXMMU_LUT521H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT521H_LO_Msk = 0x3ffff0

	// LUT522L: Graphic MMU LUT entry 522 low
	// Position of EN field.
	GFXMMU_LUT522L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT522L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT522L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT522L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT522L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT522L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT522L_LVB_Msk = 0xff0000

	// LUT522H: Graphic MMU LUT entry 522 high
	// Position of LO field.
	GFXMMU_LUT522H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT522H_LO_Msk = 0x3ffff0

	// LUT523L: Graphic MMU LUT entry 523 low
	// Position of EN field.
	GFXMMU_LUT523L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT523L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT523L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT523L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT523L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT523L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT523L_LVB_Msk = 0xff0000

	// LUT523H: Graphic MMU LUT entry 523 high
	// Position of LO field.
	GFXMMU_LUT523H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT523H_LO_Msk = 0x3ffff0

	// LUT524L: Graphic MMU LUT entry 524 low
	// Position of EN field.
	GFXMMU_LUT524L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT524L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT524L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT524L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT524L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT524L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT524L_LVB_Msk = 0xff0000

	// LUT524H: Graphic MMU LUT entry 524 high
	// Position of LO field.
	GFXMMU_LUT524H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT524H_LO_Msk = 0x3ffff0

	// LUT525L: Graphic MMU LUT entry 525 low
	// Position of EN field.
	GFXMMU_LUT525L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT525L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT525L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT525L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT525L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT525L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT525L_LVB_Msk = 0xff0000

	// LUT525H: Graphic MMU LUT entry 525 high
	// Position of LO field.
	GFXMMU_LUT525H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT525H_LO_Msk = 0x3ffff0

	// LUT526L: Graphic MMU LUT entry 526 low
	// Position of EN field.
	GFXMMU_LUT526L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT526L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT526L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT526L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT526L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT526L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT526L_LVB_Msk = 0xff0000

	// LUT526H: Graphic MMU LUT entry 526 high
	// Position of LO field.
	GFXMMU_LUT526H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT526H_LO_Msk = 0x3ffff0

	// LUT527L: Graphic MMU LUT entry 527 low
	// Position of EN field.
	GFXMMU_LUT527L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT527L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT527L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT527L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT527L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT527L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT527L_LVB_Msk = 0xff0000

	// LUT527H: Graphic MMU LUT entry 527 high
	// Position of LO field.
	GFXMMU_LUT527H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT527H_LO_Msk = 0x3ffff0

	// LUT528L: Graphic MMU LUT entry 528 low
	// Position of EN field.
	GFXMMU_LUT528L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT528L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT528L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT528L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT528L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT528L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT528L_LVB_Msk = 0xff0000

	// LUT528H: Graphic MMU LUT entry 528 high
	// Position of LO field.
	GFXMMU_LUT528H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT528H_LO_Msk = 0x3ffff0

	// LUT529L: Graphic MMU LUT entry 529 low
	// Position of EN field.
	GFXMMU_LUT529L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT529L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT529L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT529L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT529L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT529L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT529L_LVB_Msk = 0xff0000

	// LUT529H: Graphic MMU LUT entry 529 high
	// Position of LO field.
	GFXMMU_LUT529H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT529H_LO_Msk = 0x3ffff0

	// LUT530L: Graphic MMU LUT entry 530 low
	// Position of EN field.
	GFXMMU_LUT530L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT530L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT530L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT530L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT530L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT530L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT530L_LVB_Msk = 0xff0000

	// LUT530H: Graphic MMU LUT entry 530 high
	// Position of LO field.
	GFXMMU_LUT530H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT530H_LO_Msk = 0x3ffff0

	// LUT531L: Graphic MMU LUT entry 531 low
	// Position of EN field.
	GFXMMU_LUT531L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT531L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT531L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT531L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT531L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT531L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT531L_LVB_Msk = 0xff0000

	// LUT531H: Graphic MMU LUT entry 531 high
	// Position of LO field.
	GFXMMU_LUT531H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT531H_LO_Msk = 0x3ffff0

	// LUT532L: Graphic MMU LUT entry 532 low
	// Position of EN field.
	GFXMMU_LUT532L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT532L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT532L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT532L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT532L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT532L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT532L_LVB_Msk = 0xff0000

	// LUT532H: Graphic MMU LUT entry 532 high
	// Position of LO field.
	GFXMMU_LUT532H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT532H_LO_Msk = 0x3ffff0

	// LUT533L: Graphic MMU LUT entry 533 low
	// Position of EN field.
	GFXMMU_LUT533L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT533L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT533L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT533L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT533L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT533L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT533L_LVB_Msk = 0xff0000

	// LUT533H: Graphic MMU LUT entry 533 high
	// Position of LO field.
	GFXMMU_LUT533H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT533H_LO_Msk = 0x3ffff0

	// LUT534L: Graphic MMU LUT entry 534 low
	// Position of EN field.
	GFXMMU_LUT534L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT534L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT534L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT534L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT534L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT534L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT534L_LVB_Msk = 0xff0000

	// LUT534H: Graphic MMU LUT entry 534 high
	// Position of LO field.
	GFXMMU_LUT534H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT534H_LO_Msk = 0x3ffff0

	// LUT535L: Graphic MMU LUT entry 535 low
	// Position of EN field.
	GFXMMU_LUT535L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT535L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT535L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT535L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT535L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT535L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT535L_LVB_Msk = 0xff0000

	// LUT535H: Graphic MMU LUT entry 535 high
	// Position of LO field.
	GFXMMU_LUT535H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT535H_LO_Msk = 0x3ffff0

	// LUT536L: Graphic MMU LUT entry 536 low
	// Position of EN field.
	GFXMMU_LUT536L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT536L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT536L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT536L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT536L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT536L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT536L_LVB_Msk = 0xff0000

	// LUT536H: Graphic MMU LUT entry 536 high
	// Position of LO field.
	GFXMMU_LUT536H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT536H_LO_Msk = 0x3ffff0

	// LUT537L: Graphic MMU LUT entry 537 low
	// Position of EN field.
	GFXMMU_LUT537L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT537L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT537L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT537L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT537L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT537L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT537L_LVB_Msk = 0xff0000

	// LUT537H: Graphic MMU LUT entry 537 high
	// Position of LO field.
	GFXMMU_LUT537H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT537H_LO_Msk = 0x3ffff0

	// LUT538L: Graphic MMU LUT entry 538 low
	// Position of EN field.
	GFXMMU_LUT538L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT538L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT538L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT538L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT538L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT538L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT538L_LVB_Msk = 0xff0000

	// LUT538H: Graphic MMU LUT entry 538 high
	// Position of LO field.
	GFXMMU_LUT538H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT538H_LO_Msk = 0x3ffff0

	// LUT539L: Graphic MMU LUT entry 539 low
	// Position of EN field.
	GFXMMU_LUT539L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT539L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT539L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT539L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT539L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT539L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT539L_LVB_Msk = 0xff0000

	// LUT539H: Graphic MMU LUT entry 539 high
	// Position of LO field.
	GFXMMU_LUT539H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT539H_LO_Msk = 0x3ffff0

	// LUT540L: Graphic MMU LUT entry 540 low
	// Position of EN field.
	GFXMMU_LUT540L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT540L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT540L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT540L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT540L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT540L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT540L_LVB_Msk = 0xff0000

	// LUT540H: Graphic MMU LUT entry 540 high
	// Position of LO field.
	GFXMMU_LUT540H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT540H_LO_Msk = 0x3ffff0

	// LUT541L: Graphic MMU LUT entry 541 low
	// Position of EN field.
	GFXMMU_LUT541L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT541L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT541L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT541L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT541L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT541L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT541L_LVB_Msk = 0xff0000

	// LUT541H: Graphic MMU LUT entry 541 high
	// Position of LO field.
	GFXMMU_LUT541H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT541H_LO_Msk = 0x3ffff0

	// LUT542L: Graphic MMU LUT entry 542 low
	// Position of EN field.
	GFXMMU_LUT542L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT542L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT542L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT542L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT542L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT542L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT542L_LVB_Msk = 0xff0000

	// LUT542H: Graphic MMU LUT entry 542 high
	// Position of LO field.
	GFXMMU_LUT542H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT542H_LO_Msk = 0x3ffff0

	// LUT543L: Graphic MMU LUT entry 543 low
	// Position of EN field.
	GFXMMU_LUT543L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT543L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT543L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT543L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT543L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT543L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT543L_LVB_Msk = 0xff0000

	// LUT543H: Graphic MMU LUT entry 543 high
	// Position of LO field.
	GFXMMU_LUT543H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT543H_LO_Msk = 0x3ffff0

	// LUT544L: Graphic MMU LUT entry 544 low
	// Position of EN field.
	GFXMMU_LUT544L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT544L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT544L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT544L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT544L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT544L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT544L_LVB_Msk = 0xff0000

	// LUT544H: Graphic MMU LUT entry 544 high
	// Position of LO field.
	GFXMMU_LUT544H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT544H_LO_Msk = 0x3ffff0

	// LUT545L: Graphic MMU LUT entry 545 low
	// Position of EN field.
	GFXMMU_LUT545L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT545L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT545L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT545L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT545L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT545L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT545L_LVB_Msk = 0xff0000

	// LUT545H: Graphic MMU LUT entry 545 high
	// Position of LO field.
	GFXMMU_LUT545H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT545H_LO_Msk = 0x3ffff0

	// LUT546L: Graphic MMU LUT entry 546 low
	// Position of EN field.
	GFXMMU_LUT546L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT546L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT546L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT546L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT546L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT546L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT546L_LVB_Msk = 0xff0000

	// LUT546H: Graphic MMU LUT entry 546 high
	// Position of LO field.
	GFXMMU_LUT546H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT546H_LO_Msk = 0x3ffff0

	// LUT547L: Graphic MMU LUT entry 547 low
	// Position of EN field.
	GFXMMU_LUT547L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT547L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT547L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT547L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT547L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT547L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT547L_LVB_Msk = 0xff0000

	// LUT547H: Graphic MMU LUT entry 547 high
	// Position of LO field.
	GFXMMU_LUT547H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT547H_LO_Msk = 0x3ffff0

	// LUT548L: Graphic MMU LUT entry 548 low
	// Position of EN field.
	GFXMMU_LUT548L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT548L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT548L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT548L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT548L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT548L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT548L_LVB_Msk = 0xff0000

	// LUT548H: Graphic MMU LUT entry 548 high
	// Position of LO field.
	GFXMMU_LUT548H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT548H_LO_Msk = 0x3ffff0

	// LUT549L: Graphic MMU LUT entry 549 low
	// Position of EN field.
	GFXMMU_LUT549L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT549L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT549L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT549L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT549L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT549L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT549L_LVB_Msk = 0xff0000

	// LUT549H: Graphic MMU LUT entry 549 high
	// Position of LO field.
	GFXMMU_LUT549H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT549H_LO_Msk = 0x3ffff0

	// LUT550L: Graphic MMU LUT entry 550 low
	// Position of EN field.
	GFXMMU_LUT550L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT550L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT550L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT550L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT550L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT550L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT550L_LVB_Msk = 0xff0000

	// LUT550H: Graphic MMU LUT entry 550 high
	// Position of LO field.
	GFXMMU_LUT550H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT550H_LO_Msk = 0x3ffff0

	// LUT551L: Graphic MMU LUT entry 551 low
	// Position of EN field.
	GFXMMU_LUT551L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT551L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT551L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT551L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT551L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT551L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT551L_LVB_Msk = 0xff0000

	// LUT551H: Graphic MMU LUT entry 551 high
	// Position of LO field.
	GFXMMU_LUT551H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT551H_LO_Msk = 0x3ffff0

	// LUT552L: Graphic MMU LUT entry 552 low
	// Position of EN field.
	GFXMMU_LUT552L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT552L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT552L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT552L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT552L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT552L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT552L_LVB_Msk = 0xff0000

	// LUT552H: Graphic MMU LUT entry 552 high
	// Position of LO field.
	GFXMMU_LUT552H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT552H_LO_Msk = 0x3ffff0

	// LUT553L: Graphic MMU LUT entry 553 low
	// Position of EN field.
	GFXMMU_LUT553L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT553L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT553L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT553L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT553L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT553L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT553L_LVB_Msk = 0xff0000

	// LUT553H: Graphic MMU LUT entry 553 high
	// Position of LO field.
	GFXMMU_LUT553H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT553H_LO_Msk = 0x3ffff0

	// LUT554L: Graphic MMU LUT entry 554 low
	// Position of EN field.
	GFXMMU_LUT554L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT554L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT554L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT554L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT554L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT554L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT554L_LVB_Msk = 0xff0000

	// LUT554H: Graphic MMU LUT entry 554 high
	// Position of LO field.
	GFXMMU_LUT554H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT554H_LO_Msk = 0x3ffff0

	// LUT555L: Graphic MMU LUT entry 555 low
	// Position of EN field.
	GFXMMU_LUT555L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT555L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT555L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT555L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT555L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT555L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT555L_LVB_Msk = 0xff0000

	// LUT555H: Graphic MMU LUT entry 555 high
	// Position of LO field.
	GFXMMU_LUT555H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT555H_LO_Msk = 0x3ffff0

	// LUT556L: Graphic MMU LUT entry 556 low
	// Position of EN field.
	GFXMMU_LUT556L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT556L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT556L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT556L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT556L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT556L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT556L_LVB_Msk = 0xff0000

	// LUT556H: Graphic MMU LUT entry 556 high
	// Position of LO field.
	GFXMMU_LUT556H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT556H_LO_Msk = 0x3ffff0

	// LUT557L: Graphic MMU LUT entry 557 low
	// Position of EN field.
	GFXMMU_LUT557L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT557L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT557L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT557L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT557L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT557L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT557L_LVB_Msk = 0xff0000

	// LUT557H: Graphic MMU LUT entry 557 high
	// Position of LO field.
	GFXMMU_LUT557H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT557H_LO_Msk = 0x3ffff0

	// LUT558L: Graphic MMU LUT entry 558 low
	// Position of EN field.
	GFXMMU_LUT558L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT558L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT558L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT558L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT558L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT558L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT558L_LVB_Msk = 0xff0000

	// LUT558H: Graphic MMU LUT entry 558 high
	// Position of LO field.
	GFXMMU_LUT558H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT558H_LO_Msk = 0x3ffff0

	// LUT559L: Graphic MMU LUT entry 559 low
	// Position of EN field.
	GFXMMU_LUT559L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT559L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT559L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT559L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT559L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT559L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT559L_LVB_Msk = 0xff0000

	// LUT559H: Graphic MMU LUT entry 559 high
	// Position of LO field.
	GFXMMU_LUT559H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT559H_LO_Msk = 0x3ffff0

	// LUT560L: Graphic MMU LUT entry 560 low
	// Position of EN field.
	GFXMMU_LUT560L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT560L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT560L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT560L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT560L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT560L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT560L_LVB_Msk = 0xff0000

	// LUT560H: Graphic MMU LUT entry 560 high
	// Position of LO field.
	GFXMMU_LUT560H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT560H_LO_Msk = 0x3ffff0

	// LUT561L: Graphic MMU LUT entry 561 low
	// Position of EN field.
	GFXMMU_LUT561L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT561L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT561L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT561L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT561L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT561L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT561L_LVB_Msk = 0xff0000

	// LUT561H: Graphic MMU LUT entry 561 high
	// Position of LO field.
	GFXMMU_LUT561H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT561H_LO_Msk = 0x3ffff0

	// LUT562L: Graphic MMU LUT entry 562 low
	// Position of EN field.
	GFXMMU_LUT562L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT562L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT562L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT562L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT562L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT562L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT562L_LVB_Msk = 0xff0000

	// LUT562H: Graphic MMU LUT entry 562 high
	// Position of LO field.
	GFXMMU_LUT562H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT562H_LO_Msk = 0x3ffff0

	// LUT563L: Graphic MMU LUT entry 563 low
	// Position of EN field.
	GFXMMU_LUT563L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT563L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT563L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT563L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT563L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT563L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT563L_LVB_Msk = 0xff0000

	// LUT563H: Graphic MMU LUT entry 563 high
	// Position of LO field.
	GFXMMU_LUT563H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT563H_LO_Msk = 0x3ffff0

	// LUT564L: Graphic MMU LUT entry 564 low
	// Position of EN field.
	GFXMMU_LUT564L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT564L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT564L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT564L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT564L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT564L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT564L_LVB_Msk = 0xff0000

	// LUT564H: Graphic MMU LUT entry 564 high
	// Position of LO field.
	GFXMMU_LUT564H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT564H_LO_Msk = 0x3ffff0

	// LUT565L: Graphic MMU LUT entry 565 low
	// Position of EN field.
	GFXMMU_LUT565L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT565L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT565L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT565L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT565L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT565L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT565L_LVB_Msk = 0xff0000

	// LUT565H: Graphic MMU LUT entry 565 high
	// Position of LO field.
	GFXMMU_LUT565H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT565H_LO_Msk = 0x3ffff0

	// LUT566L: Graphic MMU LUT entry 566 low
	// Position of EN field.
	GFXMMU_LUT566L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT566L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT566L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT566L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT566L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT566L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT566L_LVB_Msk = 0xff0000

	// LUT566H: Graphic MMU LUT entry 566 high
	// Position of LO field.
	GFXMMU_LUT566H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT566H_LO_Msk = 0x3ffff0

	// LUT567L: Graphic MMU LUT entry 567 low
	// Position of EN field.
	GFXMMU_LUT567L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT567L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT567L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT567L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT567L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT567L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT567L_LVB_Msk = 0xff0000

	// LUT567H: Graphic MMU LUT entry 567 high
	// Position of LO field.
	GFXMMU_LUT567H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT567H_LO_Msk = 0x3ffff0

	// LUT568L: Graphic MMU LUT entry 568 low
	// Position of EN field.
	GFXMMU_LUT568L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT568L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT568L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT568L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT568L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT568L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT568L_LVB_Msk = 0xff0000

	// LUT568H: Graphic MMU LUT entry 568 high
	// Position of LO field.
	GFXMMU_LUT568H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT568H_LO_Msk = 0x3ffff0

	// LUT569L: Graphic MMU LUT entry 569 low
	// Position of EN field.
	GFXMMU_LUT569L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT569L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT569L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT569L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT569L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT569L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT569L_LVB_Msk = 0xff0000

	// LUT569H: Graphic MMU LUT entry 569 high
	// Position of LO field.
	GFXMMU_LUT569H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT569H_LO_Msk = 0x3ffff0

	// LUT570L: Graphic MMU LUT entry 570 low
	// Position of EN field.
	GFXMMU_LUT570L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT570L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT570L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT570L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT570L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT570L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT570L_LVB_Msk = 0xff0000

	// LUT570H: Graphic MMU LUT entry 570 high
	// Position of LO field.
	GFXMMU_LUT570H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT570H_LO_Msk = 0x3ffff0

	// LUT571L: Graphic MMU LUT entry 571 low
	// Position of EN field.
	GFXMMU_LUT571L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT571L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT571L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT571L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT571L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT571L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT571L_LVB_Msk = 0xff0000

	// LUT571H: Graphic MMU LUT entry 571 high
	// Position of LO field.
	GFXMMU_LUT571H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT571H_LO_Msk = 0x3ffff0

	// LUT572L: Graphic MMU LUT entry 572 low
	// Position of EN field.
	GFXMMU_LUT572L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT572L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT572L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT572L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT572L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT572L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT572L_LVB_Msk = 0xff0000

	// LUT572H: Graphic MMU LUT entry 572 high
	// Position of LO field.
	GFXMMU_LUT572H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT572H_LO_Msk = 0x3ffff0

	// LUT573L: Graphic MMU LUT entry 573 low
	// Position of EN field.
	GFXMMU_LUT573L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT573L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT573L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT573L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT573L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT573L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT573L_LVB_Msk = 0xff0000

	// LUT573H: Graphic MMU LUT entry 573 high
	// Position of LO field.
	GFXMMU_LUT573H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT573H_LO_Msk = 0x3ffff0

	// LUT574L: Graphic MMU LUT entry 574 low
	// Position of EN field.
	GFXMMU_LUT574L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT574L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT574L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT574L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT574L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT574L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT574L_LVB_Msk = 0xff0000

	// LUT574H: Graphic MMU LUT entry 574 high
	// Position of LO field.
	GFXMMU_LUT574H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT574H_LO_Msk = 0x3ffff0

	// LUT575L: Graphic MMU LUT entry 575 low
	// Position of EN field.
	GFXMMU_LUT575L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT575L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT575L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT575L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT575L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT575L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT575L_LVB_Msk = 0xff0000

	// LUT575H: Graphic MMU LUT entry 575 high
	// Position of LO field.
	GFXMMU_LUT575H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT575H_LO_Msk = 0x3ffff0

	// LUT576L: Graphic MMU LUT entry 576 low
	// Position of EN field.
	GFXMMU_LUT576L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT576L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT576L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT576L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT576L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT576L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT576L_LVB_Msk = 0xff0000

	// LUT576H: Graphic MMU LUT entry 576 high
	// Position of LO field.
	GFXMMU_LUT576H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT576H_LO_Msk = 0x3ffff0

	// LUT577L: Graphic MMU LUT entry 577 low
	// Position of EN field.
	GFXMMU_LUT577L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT577L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT577L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT577L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT577L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT577L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT577L_LVB_Msk = 0xff0000

	// LUT577H: Graphic MMU LUT entry 577 high
	// Position of LO field.
	GFXMMU_LUT577H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT577H_LO_Msk = 0x3ffff0

	// LUT578L: Graphic MMU LUT entry 578 low
	// Position of EN field.
	GFXMMU_LUT578L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT578L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT578L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT578L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT578L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT578L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT578L_LVB_Msk = 0xff0000

	// LUT578H: Graphic MMU LUT entry 578 high
	// Position of LO field.
	GFXMMU_LUT578H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT578H_LO_Msk = 0x3ffff0

	// LUT579L: Graphic MMU LUT entry 579 low
	// Position of EN field.
	GFXMMU_LUT579L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT579L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT579L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT579L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT579L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT579L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT579L_LVB_Msk = 0xff0000

	// LUT579H: Graphic MMU LUT entry 579 high
	// Position of LO field.
	GFXMMU_LUT579H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT579H_LO_Msk = 0x3ffff0

	// LUT580L: Graphic MMU LUT entry 580 low
	// Position of EN field.
	GFXMMU_LUT580L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT580L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT580L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT580L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT580L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT580L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT580L_LVB_Msk = 0xff0000

	// LUT580H: Graphic MMU LUT entry 580 high
	// Position of LO field.
	GFXMMU_LUT580H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT580H_LO_Msk = 0x3ffff0

	// LUT581L: Graphic MMU LUT entry 581 low
	// Position of EN field.
	GFXMMU_LUT581L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT581L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT581L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT581L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT581L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT581L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT581L_LVB_Msk = 0xff0000

	// LUT581H: Graphic MMU LUT entry 581 high
	// Position of LO field.
	GFXMMU_LUT581H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT581H_LO_Msk = 0x3ffff0

	// LUT582L: Graphic MMU LUT entry 582 low
	// Position of EN field.
	GFXMMU_LUT582L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT582L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT582L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT582L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT582L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT582L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT582L_LVB_Msk = 0xff0000

	// LUT582H: Graphic MMU LUT entry 582 high
	// Position of LO field.
	GFXMMU_LUT582H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT582H_LO_Msk = 0x3ffff0

	// LUT583L: Graphic MMU LUT entry 583 low
	// Position of EN field.
	GFXMMU_LUT583L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT583L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT583L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT583L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT583L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT583L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT583L_LVB_Msk = 0xff0000

	// LUT583H: Graphic MMU LUT entry 583 high
	// Position of LO field.
	GFXMMU_LUT583H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT583H_LO_Msk = 0x3ffff0

	// LUT584L: Graphic MMU LUT entry 584 low
	// Position of EN field.
	GFXMMU_LUT584L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT584L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT584L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT584L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT584L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT584L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT584L_LVB_Msk = 0xff0000

	// LUT584H: Graphic MMU LUT entry 584 high
	// Position of LO field.
	GFXMMU_LUT584H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT584H_LO_Msk = 0x3ffff0

	// LUT585L: Graphic MMU LUT entry 585 low
	// Position of EN field.
	GFXMMU_LUT585L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT585L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT585L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT585L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT585L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT585L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT585L_LVB_Msk = 0xff0000

	// LUT585H: Graphic MMU LUT entry 585 high
	// Position of LO field.
	GFXMMU_LUT585H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT585H_LO_Msk = 0x3ffff0

	// LUT586L: Graphic MMU LUT entry 586 low
	// Position of EN field.
	GFXMMU_LUT586L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT586L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT586L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT586L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT586L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT586L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT586L_LVB_Msk = 0xff0000

	// LUT586H: Graphic MMU LUT entry 586 high
	// Position of LO field.
	GFXMMU_LUT586H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT586H_LO_Msk = 0x3ffff0

	// LUT587L: Graphic MMU LUT entry 587 low
	// Position of EN field.
	GFXMMU_LUT587L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT587L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT587L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT587L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT587L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT587L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT587L_LVB_Msk = 0xff0000

	// LUT587H: Graphic MMU LUT entry 587 high
	// Position of LO field.
	GFXMMU_LUT587H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT587H_LO_Msk = 0x3ffff0

	// LUT588L: Graphic MMU LUT entry 588 low
	// Position of EN field.
	GFXMMU_LUT588L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT588L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT588L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT588L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT588L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT588L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT588L_LVB_Msk = 0xff0000

	// LUT588H: Graphic MMU LUT entry 588 high
	// Position of LO field.
	GFXMMU_LUT588H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT588H_LO_Msk = 0x3ffff0

	// LUT589L: Graphic MMU LUT entry 589 low
	// Position of EN field.
	GFXMMU_LUT589L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT589L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT589L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT589L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT589L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT589L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT589L_LVB_Msk = 0xff0000

	// LUT589H: Graphic MMU LUT entry 589 high
	// Position of LO field.
	GFXMMU_LUT589H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT589H_LO_Msk = 0x3ffff0

	// LUT590L: Graphic MMU LUT entry 590 low
	// Position of EN field.
	GFXMMU_LUT590L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT590L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT590L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT590L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT590L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT590L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT590L_LVB_Msk = 0xff0000

	// LUT590H: Graphic MMU LUT entry 590 high
	// Position of LO field.
	GFXMMU_LUT590H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT590H_LO_Msk = 0x3ffff0

	// LUT591L: Graphic MMU LUT entry 591 low
	// Position of EN field.
	GFXMMU_LUT591L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT591L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT591L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT591L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT591L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT591L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT591L_LVB_Msk = 0xff0000

	// LUT591H: Graphic MMU LUT entry 591 high
	// Position of LO field.
	GFXMMU_LUT591H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT591H_LO_Msk = 0x3ffff0

	// LUT592L: Graphic MMU LUT entry 592 low
	// Position of EN field.
	GFXMMU_LUT592L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT592L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT592L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT592L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT592L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT592L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT592L_LVB_Msk = 0xff0000

	// LUT592H: Graphic MMU LUT entry 592 high
	// Position of LO field.
	GFXMMU_LUT592H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT592H_LO_Msk = 0x3ffff0

	// LUT593L: Graphic MMU LUT entry 593 low
	// Position of EN field.
	GFXMMU_LUT593L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT593L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT593L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT593L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT593L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT593L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT593L_LVB_Msk = 0xff0000

	// LUT593H: Graphic MMU LUT entry 593 high
	// Position of LO field.
	GFXMMU_LUT593H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT593H_LO_Msk = 0x3ffff0

	// LUT594L: Graphic MMU LUT entry 594 low
	// Position of EN field.
	GFXMMU_LUT594L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT594L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT594L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT594L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT594L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT594L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT594L_LVB_Msk = 0xff0000

	// LUT594H: Graphic MMU LUT entry 594 high
	// Position of LO field.
	GFXMMU_LUT594H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT594H_LO_Msk = 0x3ffff0

	// LUT595L: Graphic MMU LUT entry 595 low
	// Position of EN field.
	GFXMMU_LUT595L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT595L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT595L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT595L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT595L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT595L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT595L_LVB_Msk = 0xff0000

	// LUT595H: Graphic MMU LUT entry 595 high
	// Position of LO field.
	GFXMMU_LUT595H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT595H_LO_Msk = 0x3ffff0

	// LUT596L: Graphic MMU LUT entry 596 low
	// Position of EN field.
	GFXMMU_LUT596L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT596L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT596L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT596L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT596L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT596L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT596L_LVB_Msk = 0xff0000

	// LUT596H: Graphic MMU LUT entry 596 high
	// Position of LO field.
	GFXMMU_LUT596H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT596H_LO_Msk = 0x3ffff0

	// LUT597L: Graphic MMU LUT entry 597 low
	// Position of EN field.
	GFXMMU_LUT597L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT597L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT597L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT597L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT597L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT597L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT597L_LVB_Msk = 0xff0000

	// LUT597H: Graphic MMU LUT entry 597 high
	// Position of LO field.
	GFXMMU_LUT597H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT597H_LO_Msk = 0x3ffff0

	// LUT598L: Graphic MMU LUT entry 598 low
	// Position of EN field.
	GFXMMU_LUT598L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT598L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT598L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT598L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT598L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT598L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT598L_LVB_Msk = 0xff0000

	// LUT598H: Graphic MMU LUT entry 598 high
	// Position of LO field.
	GFXMMU_LUT598H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT598H_LO_Msk = 0x3ffff0

	// LUT599L: Graphic MMU LUT entry 599 low
	// Position of EN field.
	GFXMMU_LUT599L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT599L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT599L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT599L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT599L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT599L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT599L_LVB_Msk = 0xff0000

	// LUT599H: Graphic MMU LUT entry 599 high
	// Position of LO field.
	GFXMMU_LUT599H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT599H_LO_Msk = 0x3ffff0

	// LUT600L: Graphic MMU LUT entry 600 low
	// Position of EN field.
	GFXMMU_LUT600L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT600L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT600L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT600L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT600L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT600L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT600L_LVB_Msk = 0xff0000

	// LUT600H: Graphic MMU LUT entry 600 high
	// Position of LO field.
	GFXMMU_LUT600H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT600H_LO_Msk = 0x3ffff0

	// LUT601L: Graphic MMU LUT entry 601 low
	// Position of EN field.
	GFXMMU_LUT601L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT601L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT601L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT601L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT601L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT601L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT601L_LVB_Msk = 0xff0000

	// LUT601H: Graphic MMU LUT entry 601 high
	// Position of LO field.
	GFXMMU_LUT601H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT601H_LO_Msk = 0x3ffff0

	// LUT602L: Graphic MMU LUT entry 602 low
	// Position of EN field.
	GFXMMU_LUT602L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT602L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT602L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT602L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT602L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT602L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT602L_LVB_Msk = 0xff0000

	// LUT602H: Graphic MMU LUT entry 602 high
	// Position of LO field.
	GFXMMU_LUT602H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT602H_LO_Msk = 0x3ffff0

	// LUT603L: Graphic MMU LUT entry 603 low
	// Position of EN field.
	GFXMMU_LUT603L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT603L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT603L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT603L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT603L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT603L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT603L_LVB_Msk = 0xff0000

	// LUT603H: Graphic MMU LUT entry 603 high
	// Position of LO field.
	GFXMMU_LUT603H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT603H_LO_Msk = 0x3ffff0

	// LUT604L: Graphic MMU LUT entry 604 low
	// Position of EN field.
	GFXMMU_LUT604L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT604L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT604L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT604L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT604L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT604L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT604L_LVB_Msk = 0xff0000

	// LUT604H: Graphic MMU LUT entry 604 high
	// Position of LO field.
	GFXMMU_LUT604H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT604H_LO_Msk = 0x3ffff0

	// LUT605L: Graphic MMU LUT entry 605 low
	// Position of EN field.
	GFXMMU_LUT605L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT605L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT605L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT605L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT605L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT605L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT605L_LVB_Msk = 0xff0000

	// LUT605H: Graphic MMU LUT entry 605 high
	// Position of LO field.
	GFXMMU_LUT605H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT605H_LO_Msk = 0x3ffff0

	// LUT606L: Graphic MMU LUT entry 606 low
	// Position of EN field.
	GFXMMU_LUT606L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT606L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT606L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT606L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT606L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT606L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT606L_LVB_Msk = 0xff0000

	// LUT606H: Graphic MMU LUT entry 606 high
	// Position of LO field.
	GFXMMU_LUT606H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT606H_LO_Msk = 0x3ffff0

	// LUT607L: Graphic MMU LUT entry 607 low
	// Position of EN field.
	GFXMMU_LUT607L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT607L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT607L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT607L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT607L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT607L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT607L_LVB_Msk = 0xff0000

	// LUT607H: Graphic MMU LUT entry 607 high
	// Position of LO field.
	GFXMMU_LUT607H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT607H_LO_Msk = 0x3ffff0

	// LUT608L: Graphic MMU LUT entry 608 low
	// Position of EN field.
	GFXMMU_LUT608L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT608L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT608L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT608L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT608L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT608L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT608L_LVB_Msk = 0xff0000

	// LUT608H: Graphic MMU LUT entry 608 high
	// Position of LO field.
	GFXMMU_LUT608H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT608H_LO_Msk = 0x3ffff0

	// LUT609L: Graphic MMU LUT entry 609 low
	// Position of EN field.
	GFXMMU_LUT609L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT609L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT609L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT609L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT609L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT609L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT609L_LVB_Msk = 0xff0000

	// LUT609H: Graphic MMU LUT entry 609 high
	// Position of LO field.
	GFXMMU_LUT609H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT609H_LO_Msk = 0x3ffff0

	// LUT610L: Graphic MMU LUT entry 610 low
	// Position of EN field.
	GFXMMU_LUT610L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT610L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT610L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT610L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT610L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT610L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT610L_LVB_Msk = 0xff0000

	// LUT610H: Graphic MMU LUT entry 610 high
	// Position of LO field.
	GFXMMU_LUT610H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT610H_LO_Msk = 0x3ffff0

	// LUT611L: Graphic MMU LUT entry 611 low
	// Position of EN field.
	GFXMMU_LUT611L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT611L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT611L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT611L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT611L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT611L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT611L_LVB_Msk = 0xff0000

	// LUT611H: Graphic MMU LUT entry 611 high
	// Position of LO field.
	GFXMMU_LUT611H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT611H_LO_Msk = 0x3ffff0

	// LUT612L: Graphic MMU LUT entry 612 low
	// Position of EN field.
	GFXMMU_LUT612L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT612L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT612L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT612L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT612L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT612L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT612L_LVB_Msk = 0xff0000

	// LUT612H: Graphic MMU LUT entry 612 high
	// Position of LO field.
	GFXMMU_LUT612H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT612H_LO_Msk = 0x3ffff0

	// LUT613L: Graphic MMU LUT entry 613 low
	// Position of EN field.
	GFXMMU_LUT613L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT613L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT613L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT613L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT613L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT613L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT613L_LVB_Msk = 0xff0000

	// LUT613H: Graphic MMU LUT entry 613 high
	// Position of LO field.
	GFXMMU_LUT613H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT613H_LO_Msk = 0x3ffff0

	// LUT614L: Graphic MMU LUT entry 614 low
	// Position of EN field.
	GFXMMU_LUT614L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT614L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT614L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT614L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT614L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT614L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT614L_LVB_Msk = 0xff0000

	// LUT614H: Graphic MMU LUT entry 614 high
	// Position of LO field.
	GFXMMU_LUT614H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT614H_LO_Msk = 0x3ffff0

	// LUT615L: Graphic MMU LUT entry 615 low
	// Position of EN field.
	GFXMMU_LUT615L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT615L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT615L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT615L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT615L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT615L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT615L_LVB_Msk = 0xff0000

	// LUT615H: Graphic MMU LUT entry 615 high
	// Position of LO field.
	GFXMMU_LUT615H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT615H_LO_Msk = 0x3ffff0

	// LUT616L: Graphic MMU LUT entry 616 low
	// Position of EN field.
	GFXMMU_LUT616L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT616L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT616L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT616L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT616L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT616L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT616L_LVB_Msk = 0xff0000

	// LUT616H: Graphic MMU LUT entry 616 high
	// Position of LO field.
	GFXMMU_LUT616H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT616H_LO_Msk = 0x3ffff0

	// LUT617L: Graphic MMU LUT entry 617 low
	// Position of EN field.
	GFXMMU_LUT617L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT617L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT617L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT617L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT617L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT617L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT617L_LVB_Msk = 0xff0000

	// LUT617H: Graphic MMU LUT entry 617 high
	// Position of LO field.
	GFXMMU_LUT617H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT617H_LO_Msk = 0x3ffff0

	// LUT618L: Graphic MMU LUT entry 618 low
	// Position of EN field.
	GFXMMU_LUT618L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT618L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT618L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT618L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT618L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT618L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT618L_LVB_Msk = 0xff0000

	// LUT618H: Graphic MMU LUT entry 618 high
	// Position of LO field.
	GFXMMU_LUT618H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT618H_LO_Msk = 0x3ffff0

	// LUT619L: Graphic MMU LUT entry 619 low
	// Position of EN field.
	GFXMMU_LUT619L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT619L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT619L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT619L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT619L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT619L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT619L_LVB_Msk = 0xff0000

	// LUT619H: Graphic MMU LUT entry 619 high
	// Position of LO field.
	GFXMMU_LUT619H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT619H_LO_Msk = 0x3ffff0

	// LUT620L: Graphic MMU LUT entry 620 low
	// Position of EN field.
	GFXMMU_LUT620L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT620L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT620L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT620L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT620L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT620L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT620L_LVB_Msk = 0xff0000

	// LUT620H: Graphic MMU LUT entry 620 high
	// Position of LO field.
	GFXMMU_LUT620H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT620H_LO_Msk = 0x3ffff0

	// LUT621L: Graphic MMU LUT entry 621 low
	// Position of EN field.
	GFXMMU_LUT621L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT621L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT621L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT621L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT621L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT621L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT621L_LVB_Msk = 0xff0000

	// LUT621H: Graphic MMU LUT entry 621 high
	// Position of LO field.
	GFXMMU_LUT621H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT621H_LO_Msk = 0x3ffff0

	// LUT622L: Graphic MMU LUT entry 622 low
	// Position of EN field.
	GFXMMU_LUT622L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT622L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT622L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT622L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT622L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT622L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT622L_LVB_Msk = 0xff0000

	// LUT622H: Graphic MMU LUT entry 622 high
	// Position of LO field.
	GFXMMU_LUT622H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT622H_LO_Msk = 0x3ffff0

	// LUT623L: Graphic MMU LUT entry 623 low
	// Position of EN field.
	GFXMMU_LUT623L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT623L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT623L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT623L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT623L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT623L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT623L_LVB_Msk = 0xff0000

	// LUT623H: Graphic MMU LUT entry 623 high
	// Position of LO field.
	GFXMMU_LUT623H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT623H_LO_Msk = 0x3ffff0

	// LUT624L: Graphic MMU LUT entry 624 low
	// Position of EN field.
	GFXMMU_LUT624L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT624L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT624L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT624L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT624L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT624L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT624L_LVB_Msk = 0xff0000

	// LUT624H: Graphic MMU LUT entry 624 high
	// Position of LO field.
	GFXMMU_LUT624H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT624H_LO_Msk = 0x3ffff0

	// LUT625L: Graphic MMU LUT entry 625 low
	// Position of EN field.
	GFXMMU_LUT625L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT625L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT625L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT625L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT625L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT625L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT625L_LVB_Msk = 0xff0000

	// LUT625H: Graphic MMU LUT entry 625 high
	// Position of LO field.
	GFXMMU_LUT625H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT625H_LO_Msk = 0x3ffff0

	// LUT626L: Graphic MMU LUT entry 626 low
	// Position of EN field.
	GFXMMU_LUT626L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT626L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT626L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT626L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT626L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT626L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT626L_LVB_Msk = 0xff0000

	// LUT626H: Graphic MMU LUT entry 626 high
	// Position of LO field.
	GFXMMU_LUT626H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT626H_LO_Msk = 0x3ffff0

	// LUT627L: Graphic MMU LUT entry 627 low
	// Position of EN field.
	GFXMMU_LUT627L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT627L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT627L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT627L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT627L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT627L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT627L_LVB_Msk = 0xff0000

	// LUT627H: Graphic MMU LUT entry 627 high
	// Position of LO field.
	GFXMMU_LUT627H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT627H_LO_Msk = 0x3ffff0

	// LUT628L: Graphic MMU LUT entry 628 low
	// Position of EN field.
	GFXMMU_LUT628L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT628L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT628L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT628L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT628L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT628L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT628L_LVB_Msk = 0xff0000

	// LUT628H: Graphic MMU LUT entry 628 high
	// Position of LO field.
	GFXMMU_LUT628H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT628H_LO_Msk = 0x3ffff0

	// LUT629L: Graphic MMU LUT entry 629 low
	// Position of EN field.
	GFXMMU_LUT629L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT629L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT629L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT629L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT629L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT629L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT629L_LVB_Msk = 0xff0000

	// LUT629H: Graphic MMU LUT entry 629 high
	// Position of LO field.
	GFXMMU_LUT629H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT629H_LO_Msk = 0x3ffff0

	// LUT630L: Graphic MMU LUT entry 630 low
	// Position of EN field.
	GFXMMU_LUT630L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT630L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT630L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT630L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT630L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT630L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT630L_LVB_Msk = 0xff0000

	// LUT630H: Graphic MMU LUT entry 630 high
	// Position of LO field.
	GFXMMU_LUT630H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT630H_LO_Msk = 0x3ffff0

	// LUT631L: Graphic MMU LUT entry 631 low
	// Position of EN field.
	GFXMMU_LUT631L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT631L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT631L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT631L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT631L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT631L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT631L_LVB_Msk = 0xff0000

	// LUT631H: Graphic MMU LUT entry 631 high
	// Position of LO field.
	GFXMMU_LUT631H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT631H_LO_Msk = 0x3ffff0

	// LUT632L: Graphic MMU LUT entry 632 low
	// Position of EN field.
	GFXMMU_LUT632L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT632L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT632L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT632L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT632L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT632L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT632L_LVB_Msk = 0xff0000

	// LUT632H: Graphic MMU LUT entry 632 high
	// Position of LO field.
	GFXMMU_LUT632H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT632H_LO_Msk = 0x3ffff0

	// LUT633L: Graphic MMU LUT entry 633 low
	// Position of EN field.
	GFXMMU_LUT633L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT633L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT633L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT633L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT633L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT633L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT633L_LVB_Msk = 0xff0000

	// LUT633H: Graphic MMU LUT entry 633 high
	// Position of LO field.
	GFXMMU_LUT633H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT633H_LO_Msk = 0x3ffff0

	// LUT634L: Graphic MMU LUT entry 634 low
	// Position of EN field.
	GFXMMU_LUT634L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT634L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT634L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT634L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT634L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT634L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT634L_LVB_Msk = 0xff0000

	// LUT634H: Graphic MMU LUT entry 634 high
	// Position of LO field.
	GFXMMU_LUT634H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT634H_LO_Msk = 0x3ffff0

	// LUT635L: Graphic MMU LUT entry 635 low
	// Position of EN field.
	GFXMMU_LUT635L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT635L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT635L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT635L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT635L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT635L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT635L_LVB_Msk = 0xff0000

	// LUT635H: Graphic MMU LUT entry 635 high
	// Position of LO field.
	GFXMMU_LUT635H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT635H_LO_Msk = 0x3ffff0

	// LUT636L: Graphic MMU LUT entry 636 low
	// Position of EN field.
	GFXMMU_LUT636L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT636L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT636L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT636L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT636L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT636L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT636L_LVB_Msk = 0xff0000

	// LUT636H: Graphic MMU LUT entry 636 high
	// Position of LO field.
	GFXMMU_LUT636H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT636H_LO_Msk = 0x3ffff0

	// LUT637L: Graphic MMU LUT entry 637 low
	// Position of EN field.
	GFXMMU_LUT637L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT637L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT637L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT637L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT637L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT637L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT637L_LVB_Msk = 0xff0000

	// LUT637H: Graphic MMU LUT entry 637 high
	// Position of LO field.
	GFXMMU_LUT637H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT637H_LO_Msk = 0x3ffff0

	// LUT638L: Graphic MMU LUT entry 638 low
	// Position of EN field.
	GFXMMU_LUT638L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT638L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT638L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT638L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT638L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT638L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT638L_LVB_Msk = 0xff0000

	// LUT638H: Graphic MMU LUT entry 638 high
	// Position of LO field.
	GFXMMU_LUT638H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT638H_LO_Msk = 0x3ffff0

	// LUT639L: Graphic MMU LUT entry 639 low
	// Position of EN field.
	GFXMMU_LUT639L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT639L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT639L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT639L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT639L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT639L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT639L_LVB_Msk = 0xff0000

	// LUT639H: Graphic MMU LUT entry 639 high
	// Position of LO field.
	GFXMMU_LUT639H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT639H_LO_Msk = 0x3ffff0

	// LUT640L: Graphic MMU LUT entry 640 low
	// Position of EN field.
	GFXMMU_LUT640L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT640L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT640L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT640L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT640L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT640L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT640L_LVB_Msk = 0xff0000

	// LUT640H: Graphic MMU LUT entry 640 high
	// Position of LO field.
	GFXMMU_LUT640H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT640H_LO_Msk = 0x3ffff0

	// LUT641L: Graphic MMU LUT entry 641 low
	// Position of EN field.
	GFXMMU_LUT641L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT641L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT641L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT641L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT641L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT641L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT641L_LVB_Msk = 0xff0000

	// LUT641H: Graphic MMU LUT entry 641 high
	// Position of LO field.
	GFXMMU_LUT641H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT641H_LO_Msk = 0x3ffff0

	// LUT642L: Graphic MMU LUT entry 642 low
	// Position of EN field.
	GFXMMU_LUT642L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT642L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT642L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT642L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT642L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT642L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT642L_LVB_Msk = 0xff0000

	// LUT642H: Graphic MMU LUT entry 642 high
	// Position of LO field.
	GFXMMU_LUT642H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT642H_LO_Msk = 0x3ffff0

	// LUT643L: Graphic MMU LUT entry 643 low
	// Position of EN field.
	GFXMMU_LUT643L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT643L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT643L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT643L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT643L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT643L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT643L_LVB_Msk = 0xff0000

	// LUT643H: Graphic MMU LUT entry 643 high
	// Position of LO field.
	GFXMMU_LUT643H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT643H_LO_Msk = 0x3ffff0

	// LUT644L: Graphic MMU LUT entry 644 low
	// Position of EN field.
	GFXMMU_LUT644L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT644L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT644L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT644L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT644L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT644L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT644L_LVB_Msk = 0xff0000

	// LUT644H: Graphic MMU LUT entry 644 high
	// Position of LO field.
	GFXMMU_LUT644H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT644H_LO_Msk = 0x3ffff0

	// LUT645L: Graphic MMU LUT entry 645 low
	// Position of EN field.
	GFXMMU_LUT645L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT645L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT645L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT645L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT645L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT645L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT645L_LVB_Msk = 0xff0000

	// LUT645H: Graphic MMU LUT entry 645 high
	// Position of LO field.
	GFXMMU_LUT645H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT645H_LO_Msk = 0x3ffff0

	// LUT646L: Graphic MMU LUT entry 646 low
	// Position of EN field.
	GFXMMU_LUT646L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT646L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT646L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT646L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT646L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT646L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT646L_LVB_Msk = 0xff0000

	// LUT646H: Graphic MMU LUT entry 646 high
	// Position of LO field.
	GFXMMU_LUT646H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT646H_LO_Msk = 0x3ffff0

	// LUT647L: Graphic MMU LUT entry 647 low
	// Position of EN field.
	GFXMMU_LUT647L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT647L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT647L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT647L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT647L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT647L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT647L_LVB_Msk = 0xff0000

	// LUT647H: Graphic MMU LUT entry 647 high
	// Position of LO field.
	GFXMMU_LUT647H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT647H_LO_Msk = 0x3ffff0

	// LUT648L: Graphic MMU LUT entry 648 low
	// Position of EN field.
	GFXMMU_LUT648L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT648L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT648L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT648L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT648L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT648L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT648L_LVB_Msk = 0xff0000

	// LUT648H: Graphic MMU LUT entry 648 high
	// Position of LO field.
	GFXMMU_LUT648H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT648H_LO_Msk = 0x3ffff0

	// LUT649L: Graphic MMU LUT entry 649 low
	// Position of EN field.
	GFXMMU_LUT649L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT649L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT649L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT649L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT649L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT649L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT649L_LVB_Msk = 0xff0000

	// LUT649H: Graphic MMU LUT entry 649 high
	// Position of LO field.
	GFXMMU_LUT649H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT649H_LO_Msk = 0x3ffff0

	// LUT650L: Graphic MMU LUT entry 650 low
	// Position of EN field.
	GFXMMU_LUT650L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT650L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT650L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT650L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT650L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT650L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT650L_LVB_Msk = 0xff0000

	// LUT650H: Graphic MMU LUT entry 650 high
	// Position of LO field.
	GFXMMU_LUT650H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT650H_LO_Msk = 0x3ffff0

	// LUT651L: Graphic MMU LUT entry 651 low
	// Position of EN field.
	GFXMMU_LUT651L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT651L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT651L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT651L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT651L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT651L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT651L_LVB_Msk = 0xff0000

	// LUT651H: Graphic MMU LUT entry 651 high
	// Position of LO field.
	GFXMMU_LUT651H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT651H_LO_Msk = 0x3ffff0

	// LUT652L: Graphic MMU LUT entry 652 low
	// Position of EN field.
	GFXMMU_LUT652L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT652L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT652L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT652L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT652L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT652L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT652L_LVB_Msk = 0xff0000

	// LUT652H: Graphic MMU LUT entry 652 high
	// Position of LO field.
	GFXMMU_LUT652H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT652H_LO_Msk = 0x3ffff0

	// LUT653L: Graphic MMU LUT entry 653 low
	// Position of EN field.
	GFXMMU_LUT653L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT653L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT653L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT653L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT653L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT653L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT653L_LVB_Msk = 0xff0000

	// LUT653H: Graphic MMU LUT entry 653 high
	// Position of LO field.
	GFXMMU_LUT653H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT653H_LO_Msk = 0x3ffff0

	// LUT654L: Graphic MMU LUT entry 654 low
	// Position of EN field.
	GFXMMU_LUT654L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT654L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT654L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT654L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT654L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT654L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT654L_LVB_Msk = 0xff0000

	// LUT654H: Graphic MMU LUT entry 654 high
	// Position of LO field.
	GFXMMU_LUT654H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT654H_LO_Msk = 0x3ffff0

	// LUT655L: Graphic MMU LUT entry 655 low
	// Position of EN field.
	GFXMMU_LUT655L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT655L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT655L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT655L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT655L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT655L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT655L_LVB_Msk = 0xff0000

	// LUT655H: Graphic MMU LUT entry 655 high
	// Position of LO field.
	GFXMMU_LUT655H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT655H_LO_Msk = 0x3ffff0

	// LUT656L: Graphic MMU LUT entry 656 low
	// Position of EN field.
	GFXMMU_LUT656L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT656L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT656L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT656L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT656L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT656L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT656L_LVB_Msk = 0xff0000

	// LUT656H: Graphic MMU LUT entry 656 high
	// Position of LO field.
	GFXMMU_LUT656H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT656H_LO_Msk = 0x3ffff0

	// LUT657L: Graphic MMU LUT entry 657 low
	// Position of EN field.
	GFXMMU_LUT657L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT657L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT657L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT657L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT657L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT657L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT657L_LVB_Msk = 0xff0000

	// LUT657H: Graphic MMU LUT entry 657 high
	// Position of LO field.
	GFXMMU_LUT657H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT657H_LO_Msk = 0x3ffff0

	// LUT658L: Graphic MMU LUT entry 658 low
	// Position of EN field.
	GFXMMU_LUT658L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT658L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT658L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT658L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT658L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT658L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT658L_LVB_Msk = 0xff0000

	// LUT658H: Graphic MMU LUT entry 658 high
	// Position of LO field.
	GFXMMU_LUT658H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT658H_LO_Msk = 0x3ffff0

	// LUT659L: Graphic MMU LUT entry 659 low
	// Position of EN field.
	GFXMMU_LUT659L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT659L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT659L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT659L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT659L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT659L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT659L_LVB_Msk = 0xff0000

	// LUT659H: Graphic MMU LUT entry 659 high
	// Position of LO field.
	GFXMMU_LUT659H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT659H_LO_Msk = 0x3ffff0

	// LUT660L: Graphic MMU LUT entry 660 low
	// Position of EN field.
	GFXMMU_LUT660L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT660L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT660L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT660L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT660L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT660L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT660L_LVB_Msk = 0xff0000

	// LUT660H: Graphic MMU LUT entry 660 high
	// Position of LO field.
	GFXMMU_LUT660H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT660H_LO_Msk = 0x3ffff0

	// LUT661L: Graphic MMU LUT entry 661 low
	// Position of EN field.
	GFXMMU_LUT661L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT661L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT661L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT661L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT661L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT661L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT661L_LVB_Msk = 0xff0000

	// LUT661H: Graphic MMU LUT entry 661 high
	// Position of LO field.
	GFXMMU_LUT661H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT661H_LO_Msk = 0x3ffff0

	// LUT662L: Graphic MMU LUT entry 662 low
	// Position of EN field.
	GFXMMU_LUT662L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT662L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT662L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT662L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT662L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT662L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT662L_LVB_Msk = 0xff0000

	// LUT662H: Graphic MMU LUT entry 662 high
	// Position of LO field.
	GFXMMU_LUT662H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT662H_LO_Msk = 0x3ffff0

	// LUT663L: Graphic MMU LUT entry 663 low
	// Position of EN field.
	GFXMMU_LUT663L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT663L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT663L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT663L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT663L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT663L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT663L_LVB_Msk = 0xff0000

	// LUT663H: Graphic MMU LUT entry 663 high
	// Position of LO field.
	GFXMMU_LUT663H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT663H_LO_Msk = 0x3ffff0

	// LUT664L: Graphic MMU LUT entry 664 low
	// Position of EN field.
	GFXMMU_LUT664L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT664L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT664L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT664L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT664L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT664L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT664L_LVB_Msk = 0xff0000

	// LUT664H: Graphic MMU LUT entry 664 high
	// Position of LO field.
	GFXMMU_LUT664H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT664H_LO_Msk = 0x3ffff0

	// LUT665L: Graphic MMU LUT entry 665 low
	// Position of EN field.
	GFXMMU_LUT665L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT665L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT665L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT665L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT665L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT665L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT665L_LVB_Msk = 0xff0000

	// LUT665H: Graphic MMU LUT entry 665 high
	// Position of LO field.
	GFXMMU_LUT665H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT665H_LO_Msk = 0x3ffff0

	// LUT666L: Graphic MMU LUT entry 666 low
	// Position of EN field.
	GFXMMU_LUT666L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT666L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT666L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT666L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT666L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT666L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT666L_LVB_Msk = 0xff0000

	// LUT666H: Graphic MMU LUT entry 666 high
	// Position of LO field.
	GFXMMU_LUT666H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT666H_LO_Msk = 0x3ffff0

	// LUT667L: Graphic MMU LUT entry 667 low
	// Position of EN field.
	GFXMMU_LUT667L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT667L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT667L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT667L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT667L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT667L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT667L_LVB_Msk = 0xff0000

	// LUT667H: Graphic MMU LUT entry 667 high
	// Position of LO field.
	GFXMMU_LUT667H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT667H_LO_Msk = 0x3ffff0

	// LUT668L: Graphic MMU LUT entry 668 low
	// Position of EN field.
	GFXMMU_LUT668L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT668L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT668L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT668L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT668L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT668L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT668L_LVB_Msk = 0xff0000

	// LUT668H: Graphic MMU LUT entry 668 high
	// Position of LO field.
	GFXMMU_LUT668H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT668H_LO_Msk = 0x3ffff0

	// LUT669L: Graphic MMU LUT entry 669 low
	// Position of EN field.
	GFXMMU_LUT669L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT669L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT669L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT669L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT669L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT669L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT669L_LVB_Msk = 0xff0000

	// LUT669H: Graphic MMU LUT entry 669 high
	// Position of LO field.
	GFXMMU_LUT669H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT669H_LO_Msk = 0x3ffff0

	// LUT670L: Graphic MMU LUT entry 670 low
	// Position of EN field.
	GFXMMU_LUT670L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT670L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT670L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT670L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT670L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT670L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT670L_LVB_Msk = 0xff0000

	// LUT670H: Graphic MMU LUT entry 670 high
	// Position of LO field.
	GFXMMU_LUT670H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT670H_LO_Msk = 0x3ffff0

	// LUT671L: Graphic MMU LUT entry 671 low
	// Position of EN field.
	GFXMMU_LUT671L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT671L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT671L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT671L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT671L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT671L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT671L_LVB_Msk = 0xff0000

	// LUT671H: Graphic MMU LUT entry 671 high
	// Position of LO field.
	GFXMMU_LUT671H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT671H_LO_Msk = 0x3ffff0

	// LUT672L: Graphic MMU LUT entry 672 low
	// Position of EN field.
	GFXMMU_LUT672L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT672L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT672L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT672L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT672L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT672L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT672L_LVB_Msk = 0xff0000

	// LUT672H: Graphic MMU LUT entry 672 high
	// Position of LO field.
	GFXMMU_LUT672H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT672H_LO_Msk = 0x3ffff0

	// LUT673L: Graphic MMU LUT entry 673 low
	// Position of EN field.
	GFXMMU_LUT673L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT673L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT673L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT673L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT673L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT673L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT673L_LVB_Msk = 0xff0000

	// LUT673H: Graphic MMU LUT entry 673 high
	// Position of LO field.
	GFXMMU_LUT673H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT673H_LO_Msk = 0x3ffff0

	// LUT674L: Graphic MMU LUT entry 674 low
	// Position of EN field.
	GFXMMU_LUT674L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT674L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT674L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT674L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT674L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT674L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT674L_LVB_Msk = 0xff0000

	// LUT674H: Graphic MMU LUT entry 674 high
	// Position of LO field.
	GFXMMU_LUT674H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT674H_LO_Msk = 0x3ffff0

	// LUT675L: Graphic MMU LUT entry 675 low
	// Position of EN field.
	GFXMMU_LUT675L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT675L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT675L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT675L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT675L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT675L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT675L_LVB_Msk = 0xff0000

	// LUT675H: Graphic MMU LUT entry 675 high
	// Position of LO field.
	GFXMMU_LUT675H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT675H_LO_Msk = 0x3ffff0

	// LUT676L: Graphic MMU LUT entry 676 low
	// Position of EN field.
	GFXMMU_LUT676L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT676L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT676L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT676L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT676L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT676L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT676L_LVB_Msk = 0xff0000

	// LUT676H: Graphic MMU LUT entry 676 high
	// Position of LO field.
	GFXMMU_LUT676H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT676H_LO_Msk = 0x3ffff0

	// LUT677L: Graphic MMU LUT entry 677 low
	// Position of EN field.
	GFXMMU_LUT677L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT677L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT677L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT677L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT677L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT677L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT677L_LVB_Msk = 0xff0000

	// LUT677H: Graphic MMU LUT entry 677 high
	// Position of LO field.
	GFXMMU_LUT677H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT677H_LO_Msk = 0x3ffff0

	// LUT678L: Graphic MMU LUT entry 678 low
	// Position of EN field.
	GFXMMU_LUT678L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT678L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT678L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT678L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT678L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT678L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT678L_LVB_Msk = 0xff0000

	// LUT678H: Graphic MMU LUT entry 678 high
	// Position of LO field.
	GFXMMU_LUT678H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT678H_LO_Msk = 0x3ffff0

	// LUT679L: Graphic MMU LUT entry 679 low
	// Position of EN field.
	GFXMMU_LUT679L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT679L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT679L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT679L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT679L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT679L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT679L_LVB_Msk = 0xff0000

	// LUT679H: Graphic MMU LUT entry 679 high
	// Position of LO field.
	GFXMMU_LUT679H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT679H_LO_Msk = 0x3ffff0

	// LUT680L: Graphic MMU LUT entry 680 low
	// Position of EN field.
	GFXMMU_LUT680L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT680L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT680L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT680L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT680L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT680L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT680L_LVB_Msk = 0xff0000

	// LUT680H: Graphic MMU LUT entry 680 high
	// Position of LO field.
	GFXMMU_LUT680H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT680H_LO_Msk = 0x3ffff0

	// LUT681L: Graphic MMU LUT entry 681 low
	// Position of EN field.
	GFXMMU_LUT681L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT681L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT681L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT681L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT681L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT681L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT681L_LVB_Msk = 0xff0000

	// LUT681H: Graphic MMU LUT entry 681 high
	// Position of LO field.
	GFXMMU_LUT681H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT681H_LO_Msk = 0x3ffff0

	// LUT682L: Graphic MMU LUT entry 682 low
	// Position of EN field.
	GFXMMU_LUT682L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT682L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT682L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT682L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT682L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT682L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT682L_LVB_Msk = 0xff0000

	// LUT682H: Graphic MMU LUT entry 682 high
	// Position of LO field.
	GFXMMU_LUT682H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT682H_LO_Msk = 0x3ffff0

	// LUT683L: Graphic MMU LUT entry 683 low
	// Position of EN field.
	GFXMMU_LUT683L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT683L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT683L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT683L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT683L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT683L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT683L_LVB_Msk = 0xff0000

	// LUT683H: Graphic MMU LUT entry 683 high
	// Position of LO field.
	GFXMMU_LUT683H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT683H_LO_Msk = 0x3ffff0

	// LUT684L: Graphic MMU LUT entry 684 low
	// Position of EN field.
	GFXMMU_LUT684L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT684L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT684L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT684L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT684L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT684L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT684L_LVB_Msk = 0xff0000

	// LUT684H: Graphic MMU LUT entry 684 high
	// Position of LO field.
	GFXMMU_LUT684H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT684H_LO_Msk = 0x3ffff0

	// LUT685L: Graphic MMU LUT entry 685 low
	// Position of EN field.
	GFXMMU_LUT685L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT685L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT685L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT685L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT685L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT685L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT685L_LVB_Msk = 0xff0000

	// LUT685H: Graphic MMU LUT entry 685 high
	// Position of LO field.
	GFXMMU_LUT685H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT685H_LO_Msk = 0x3ffff0

	// LUT686L: Graphic MMU LUT entry 686 low
	// Position of EN field.
	GFXMMU_LUT686L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT686L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT686L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT686L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT686L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT686L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT686L_LVB_Msk = 0xff0000

	// LUT686H: Graphic MMU LUT entry 686 high
	// Position of LO field.
	GFXMMU_LUT686H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT686H_LO_Msk = 0x3ffff0

	// LUT687L: Graphic MMU LUT entry 687 low
	// Position of EN field.
	GFXMMU_LUT687L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT687L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT687L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT687L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT687L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT687L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT687L_LVB_Msk = 0xff0000

	// LUT687H: Graphic MMU LUT entry 687 high
	// Position of LO field.
	GFXMMU_LUT687H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT687H_LO_Msk = 0x3ffff0

	// LUT688L: Graphic MMU LUT entry 688 low
	// Position of EN field.
	GFXMMU_LUT688L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT688L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT688L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT688L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT688L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT688L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT688L_LVB_Msk = 0xff0000

	// LUT688H: Graphic MMU LUT entry 688 high
	// Position of LO field.
	GFXMMU_LUT688H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT688H_LO_Msk = 0x3ffff0

	// LUT689L: Graphic MMU LUT entry 689 low
	// Position of EN field.
	GFXMMU_LUT689L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT689L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT689L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT689L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT689L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT689L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT689L_LVB_Msk = 0xff0000

	// LUT689H: Graphic MMU LUT entry 689 high
	// Position of LO field.
	GFXMMU_LUT689H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT689H_LO_Msk = 0x3ffff0

	// LUT690L: Graphic MMU LUT entry 690 low
	// Position of EN field.
	GFXMMU_LUT690L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT690L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT690L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT690L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT690L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT690L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT690L_LVB_Msk = 0xff0000

	// LUT690H: Graphic MMU LUT entry 690 high
	// Position of LO field.
	GFXMMU_LUT690H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT690H_LO_Msk = 0x3ffff0

	// LUT691L: Graphic MMU LUT entry 691 low
	// Position of EN field.
	GFXMMU_LUT691L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT691L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT691L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT691L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT691L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT691L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT691L_LVB_Msk = 0xff0000

	// LUT691H: Graphic MMU LUT entry 691 high
	// Position of LO field.
	GFXMMU_LUT691H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT691H_LO_Msk = 0x3ffff0

	// LUT692L: Graphic MMU LUT entry 692 low
	// Position of EN field.
	GFXMMU_LUT692L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT692L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT692L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT692L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT692L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT692L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT692L_LVB_Msk = 0xff0000

	// LUT692H: Graphic MMU LUT entry 692 high
	// Position of LO field.
	GFXMMU_LUT692H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT692H_LO_Msk = 0x3ffff0

	// LUT693L: Graphic MMU LUT entry 693 low
	// Position of EN field.
	GFXMMU_LUT693L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT693L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT693L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT693L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT693L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT693L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT693L_LVB_Msk = 0xff0000

	// LUT693H: Graphic MMU LUT entry 693 high
	// Position of LO field.
	GFXMMU_LUT693H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT693H_LO_Msk = 0x3ffff0

	// LUT694L: Graphic MMU LUT entry 694 low
	// Position of EN field.
	GFXMMU_LUT694L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT694L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT694L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT694L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT694L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT694L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT694L_LVB_Msk = 0xff0000

	// LUT694H: Graphic MMU LUT entry 694 high
	// Position of LO field.
	GFXMMU_LUT694H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT694H_LO_Msk = 0x3ffff0

	// LUT695L: Graphic MMU LUT entry 695 low
	// Position of EN field.
	GFXMMU_LUT695L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT695L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT695L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT695L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT695L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT695L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT695L_LVB_Msk = 0xff0000

	// LUT695H: Graphic MMU LUT entry 695 high
	// Position of LO field.
	GFXMMU_LUT695H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT695H_LO_Msk = 0x3ffff0

	// LUT696L: Graphic MMU LUT entry 696 low
	// Position of EN field.
	GFXMMU_LUT696L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT696L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT696L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT696L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT696L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT696L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT696L_LVB_Msk = 0xff0000

	// LUT696H: Graphic MMU LUT entry 696 high
	// Position of LO field.
	GFXMMU_LUT696H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT696H_LO_Msk = 0x3ffff0

	// LUT697L: Graphic MMU LUT entry 697 low
	// Position of EN field.
	GFXMMU_LUT697L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT697L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT697L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT697L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT697L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT697L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT697L_LVB_Msk = 0xff0000

	// LUT697H: Graphic MMU LUT entry 697 high
	// Position of LO field.
	GFXMMU_LUT697H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT697H_LO_Msk = 0x3ffff0

	// LUT698L: Graphic MMU LUT entry 698 low
	// Position of EN field.
	GFXMMU_LUT698L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT698L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT698L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT698L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT698L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT698L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT698L_LVB_Msk = 0xff0000

	// LUT698H: Graphic MMU LUT entry 698 high
	// Position of LO field.
	GFXMMU_LUT698H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT698H_LO_Msk = 0x3ffff0

	// LUT699L: Graphic MMU LUT entry 699 low
	// Position of EN field.
	GFXMMU_LUT699L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT699L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT699L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT699L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT699L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT699L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT699L_LVB_Msk = 0xff0000

	// LUT699H: Graphic MMU LUT entry 699 high
	// Position of LO field.
	GFXMMU_LUT699H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT699H_LO_Msk = 0x3ffff0

	// LUT700L: Graphic MMU LUT entry 700 low
	// Position of EN field.
	GFXMMU_LUT700L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT700L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT700L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT700L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT700L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT700L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT700L_LVB_Msk = 0xff0000

	// LUT700H: Graphic MMU LUT entry 700 high
	// Position of LO field.
	GFXMMU_LUT700H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT700H_LO_Msk = 0x3ffff0

	// LUT701L: Graphic MMU LUT entry 701 low
	// Position of EN field.
	GFXMMU_LUT701L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT701L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT701L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT701L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT701L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT701L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT701L_LVB_Msk = 0xff0000

	// LUT701H: Graphic MMU LUT entry 701 high
	// Position of LO field.
	GFXMMU_LUT701H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT701H_LO_Msk = 0x3ffff0

	// LUT702L: Graphic MMU LUT entry 702 low
	// Position of EN field.
	GFXMMU_LUT702L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT702L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT702L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT702L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT702L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT702L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT702L_LVB_Msk = 0xff0000

	// LUT702H: Graphic MMU LUT entry 702 high
	// Position of LO field.
	GFXMMU_LUT702H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT702H_LO_Msk = 0x3ffff0

	// LUT703L: Graphic MMU LUT entry 703 low
	// Position of EN field.
	GFXMMU_LUT703L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT703L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT703L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT703L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT703L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT703L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT703L_LVB_Msk = 0xff0000

	// LUT703H: Graphic MMU LUT entry 703 high
	// Position of LO field.
	GFXMMU_LUT703H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT703H_LO_Msk = 0x3ffff0

	// LUT704L: Graphic MMU LUT entry 704 low
	// Position of EN field.
	GFXMMU_LUT704L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT704L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT704L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT704L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT704L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT704L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT704L_LVB_Msk = 0xff0000

	// LUT704H: Graphic MMU LUT entry 704 high
	// Position of LO field.
	GFXMMU_LUT704H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT704H_LO_Msk = 0x3ffff0

	// LUT705L: Graphic MMU LUT entry 705 low
	// Position of EN field.
	GFXMMU_LUT705L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT705L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT705L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT705L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT705L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT705L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT705L_LVB_Msk = 0xff0000

	// LUT705H: Graphic MMU LUT entry 705 high
	// Position of LO field.
	GFXMMU_LUT705H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT705H_LO_Msk = 0x3ffff0

	// LUT706L: Graphic MMU LUT entry 706 low
	// Position of EN field.
	GFXMMU_LUT706L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT706L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT706L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT706L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT706L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT706L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT706L_LVB_Msk = 0xff0000

	// LUT706H: Graphic MMU LUT entry 706 high
	// Position of LO field.
	GFXMMU_LUT706H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT706H_LO_Msk = 0x3ffff0

	// LUT707L: Graphic MMU LUT entry 707 low
	// Position of EN field.
	GFXMMU_LUT707L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT707L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT707L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT707L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT707L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT707L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT707L_LVB_Msk = 0xff0000

	// LUT707H: Graphic MMU LUT entry 707 high
	// Position of LO field.
	GFXMMU_LUT707H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT707H_LO_Msk = 0x3ffff0

	// LUT708L: Graphic MMU LUT entry 708 low
	// Position of EN field.
	GFXMMU_LUT708L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT708L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT708L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT708L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT708L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT708L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT708L_LVB_Msk = 0xff0000

	// LUT708H: Graphic MMU LUT entry 708 high
	// Position of LO field.
	GFXMMU_LUT708H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT708H_LO_Msk = 0x3ffff0

	// LUT709L: Graphic MMU LUT entry 709 low
	// Position of EN field.
	GFXMMU_LUT709L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT709L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT709L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT709L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT709L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT709L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT709L_LVB_Msk = 0xff0000

	// LUT709H: Graphic MMU LUT entry 709 high
	// Position of LO field.
	GFXMMU_LUT709H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT709H_LO_Msk = 0x3ffff0

	// LUT710L: Graphic MMU LUT entry 710 low
	// Position of EN field.
	GFXMMU_LUT710L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT710L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT710L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT710L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT710L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT710L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT710L_LVB_Msk = 0xff0000

	// LUT710H: Graphic MMU LUT entry 710 high
	// Position of LO field.
	GFXMMU_LUT710H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT710H_LO_Msk = 0x3ffff0

	// LUT711L: Graphic MMU LUT entry 711 low
	// Position of EN field.
	GFXMMU_LUT711L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT711L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT711L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT711L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT711L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT711L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT711L_LVB_Msk = 0xff0000

	// LUT711H: Graphic MMU LUT entry 711 high
	// Position of LO field.
	GFXMMU_LUT711H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT711H_LO_Msk = 0x3ffff0

	// LUT712L: Graphic MMU LUT entry 712 low
	// Position of EN field.
	GFXMMU_LUT712L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT712L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT712L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT712L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT712L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT712L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT712L_LVB_Msk = 0xff0000

	// LUT712H: Graphic MMU LUT entry 712 high
	// Position of LO field.
	GFXMMU_LUT712H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT712H_LO_Msk = 0x3ffff0

	// LUT713L: Graphic MMU LUT entry 713 low
	// Position of EN field.
	GFXMMU_LUT713L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT713L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT713L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT713L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT713L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT713L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT713L_LVB_Msk = 0xff0000

	// LUT713H: Graphic MMU LUT entry 713 high
	// Position of LO field.
	GFXMMU_LUT713H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT713H_LO_Msk = 0x3ffff0

	// LUT714L: Graphic MMU LUT entry 714 low
	// Position of EN field.
	GFXMMU_LUT714L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT714L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT714L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT714L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT714L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT714L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT714L_LVB_Msk = 0xff0000

	// LUT714H: Graphic MMU LUT entry 714 high
	// Position of LO field.
	GFXMMU_LUT714H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT714H_LO_Msk = 0x3ffff0

	// LUT715L: Graphic MMU LUT entry 715 low
	// Position of EN field.
	GFXMMU_LUT715L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT715L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT715L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT715L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT715L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT715L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT715L_LVB_Msk = 0xff0000

	// LUT715H: Graphic MMU LUT entry 715 high
	// Position of LO field.
	GFXMMU_LUT715H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT715H_LO_Msk = 0x3ffff0

	// LUT716L: Graphic MMU LUT entry 716 low
	// Position of EN field.
	GFXMMU_LUT716L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT716L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT716L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT716L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT716L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT716L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT716L_LVB_Msk = 0xff0000

	// LUT716H: Graphic MMU LUT entry 716 high
	// Position of LO field.
	GFXMMU_LUT716H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT716H_LO_Msk = 0x3ffff0

	// LUT717L: Graphic MMU LUT entry 717 low
	// Position of EN field.
	GFXMMU_LUT717L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT717L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT717L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT717L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT717L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT717L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT717L_LVB_Msk = 0xff0000

	// LUT717H: Graphic MMU LUT entry 717 high
	// Position of LO field.
	GFXMMU_LUT717H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT717H_LO_Msk = 0x3ffff0

	// LUT718L: Graphic MMU LUT entry 718 low
	// Position of EN field.
	GFXMMU_LUT718L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT718L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT718L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT718L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT718L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT718L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT718L_LVB_Msk = 0xff0000

	// LUT718H: Graphic MMU LUT entry 718 high
	// Position of LO field.
	GFXMMU_LUT718H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT718H_LO_Msk = 0x3ffff0

	// LUT719L: Graphic MMU LUT entry 719 low
	// Position of EN field.
	GFXMMU_LUT719L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT719L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT719L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT719L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT719L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT719L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT719L_LVB_Msk = 0xff0000

	// LUT719H: Graphic MMU LUT entry 719 high
	// Position of LO field.
	GFXMMU_LUT719H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT719H_LO_Msk = 0x3ffff0

	// LUT720L: Graphic MMU LUT entry 720 low
	// Position of EN field.
	GFXMMU_LUT720L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT720L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT720L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT720L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT720L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT720L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT720L_LVB_Msk = 0xff0000

	// LUT720H: Graphic MMU LUT entry 720 high
	// Position of LO field.
	GFXMMU_LUT720H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT720H_LO_Msk = 0x3ffff0

	// LUT721L: Graphic MMU LUT entry 721 low
	// Position of EN field.
	GFXMMU_LUT721L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT721L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT721L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT721L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT721L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT721L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT721L_LVB_Msk = 0xff0000

	// LUT721H: Graphic MMU LUT entry 721 high
	// Position of LO field.
	GFXMMU_LUT721H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT721H_LO_Msk = 0x3ffff0

	// LUT722L: Graphic MMU LUT entry 722 low
	// Position of EN field.
	GFXMMU_LUT722L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT722L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT722L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT722L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT722L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT722L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT722L_LVB_Msk = 0xff0000

	// LUT722H: Graphic MMU LUT entry 722 high
	// Position of LO field.
	GFXMMU_LUT722H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT722H_LO_Msk = 0x3ffff0

	// LUT723L: Graphic MMU LUT entry 723 low
	// Position of EN field.
	GFXMMU_LUT723L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT723L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT723L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT723L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT723L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT723L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT723L_LVB_Msk = 0xff0000

	// LUT723H: Graphic MMU LUT entry 723 high
	// Position of LO field.
	GFXMMU_LUT723H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT723H_LO_Msk = 0x3ffff0

	// LUT724L: Graphic MMU LUT entry 724 low
	// Position of EN field.
	GFXMMU_LUT724L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT724L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT724L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT724L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT724L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT724L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT724L_LVB_Msk = 0xff0000

	// LUT724H: Graphic MMU LUT entry 724 high
	// Position of LO field.
	GFXMMU_LUT724H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT724H_LO_Msk = 0x3ffff0

	// LUT725L: Graphic MMU LUT entry 725 low
	// Position of EN field.
	GFXMMU_LUT725L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT725L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT725L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT725L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT725L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT725L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT725L_LVB_Msk = 0xff0000

	// LUT725H: Graphic MMU LUT entry 725 high
	// Position of LO field.
	GFXMMU_LUT725H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT725H_LO_Msk = 0x3ffff0

	// LUT726L: Graphic MMU LUT entry 726 low
	// Position of EN field.
	GFXMMU_LUT726L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT726L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT726L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT726L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT726L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT726L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT726L_LVB_Msk = 0xff0000

	// LUT726H: Graphic MMU LUT entry 726 high
	// Position of LO field.
	GFXMMU_LUT726H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT726H_LO_Msk = 0x3ffff0

	// LUT727L: Graphic MMU LUT entry 727 low
	// Position of EN field.
	GFXMMU_LUT727L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT727L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT727L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT727L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT727L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT727L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT727L_LVB_Msk = 0xff0000

	// LUT727H: Graphic MMU LUT entry 727 high
	// Position of LO field.
	GFXMMU_LUT727H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT727H_LO_Msk = 0x3ffff0

	// LUT728L: Graphic MMU LUT entry 728 low
	// Position of EN field.
	GFXMMU_LUT728L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT728L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT728L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT728L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT728L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT728L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT728L_LVB_Msk = 0xff0000

	// LUT728H: Graphic MMU LUT entry 728 high
	// Position of LO field.
	GFXMMU_LUT728H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT728H_LO_Msk = 0x3ffff0

	// LUT729L: Graphic MMU LUT entry 729 low
	// Position of EN field.
	GFXMMU_LUT729L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT729L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT729L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT729L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT729L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT729L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT729L_LVB_Msk = 0xff0000

	// LUT729H: Graphic MMU LUT entry 729 high
	// Position of LO field.
	GFXMMU_LUT729H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT729H_LO_Msk = 0x3ffff0

	// LUT730L: Graphic MMU LUT entry 730 low
	// Position of EN field.
	GFXMMU_LUT730L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT730L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT730L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT730L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT730L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT730L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT730L_LVB_Msk = 0xff0000

	// LUT730H: Graphic MMU LUT entry 730 high
	// Position of LO field.
	GFXMMU_LUT730H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT730H_LO_Msk = 0x3ffff0

	// LUT731L: Graphic MMU LUT entry 731 low
	// Position of EN field.
	GFXMMU_LUT731L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT731L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT731L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT731L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT731L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT731L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT731L_LVB_Msk = 0xff0000

	// LUT731H: Graphic MMU LUT entry 731 high
	// Position of LO field.
	GFXMMU_LUT731H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT731H_LO_Msk = 0x3ffff0

	// LUT732L: Graphic MMU LUT entry 732 low
	// Position of EN field.
	GFXMMU_LUT732L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT732L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT732L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT732L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT732L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT732L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT732L_LVB_Msk = 0xff0000

	// LUT732H: Graphic MMU LUT entry 732 high
	// Position of LO field.
	GFXMMU_LUT732H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT732H_LO_Msk = 0x3ffff0

	// LUT733L: Graphic MMU LUT entry 733 low
	// Position of EN field.
	GFXMMU_LUT733L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT733L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT733L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT733L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT733L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT733L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT733L_LVB_Msk = 0xff0000

	// LUT733H: Graphic MMU LUT entry 733 high
	// Position of LO field.
	GFXMMU_LUT733H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT733H_LO_Msk = 0x3ffff0

	// LUT734L: Graphic MMU LUT entry 734 low
	// Position of EN field.
	GFXMMU_LUT734L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT734L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT734L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT734L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT734L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT734L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT734L_LVB_Msk = 0xff0000

	// LUT734H: Graphic MMU LUT entry 734 high
	// Position of LO field.
	GFXMMU_LUT734H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT734H_LO_Msk = 0x3ffff0

	// LUT735L: Graphic MMU LUT entry 735 low
	// Position of EN field.
	GFXMMU_LUT735L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT735L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT735L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT735L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT735L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT735L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT735L_LVB_Msk = 0xff0000

	// LUT735H: Graphic MMU LUT entry 735 high
	// Position of LO field.
	GFXMMU_LUT735H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT735H_LO_Msk = 0x3ffff0

	// LUT736L: Graphic MMU LUT entry 736 low
	// Position of EN field.
	GFXMMU_LUT736L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT736L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT736L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT736L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT736L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT736L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT736L_LVB_Msk = 0xff0000

	// LUT736H: Graphic MMU LUT entry 736 high
	// Position of LO field.
	GFXMMU_LUT736H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT736H_LO_Msk = 0x3ffff0

	// LUT737L: Graphic MMU LUT entry 737 low
	// Position of EN field.
	GFXMMU_LUT737L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT737L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT737L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT737L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT737L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT737L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT737L_LVB_Msk = 0xff0000

	// LUT737H: Graphic MMU LUT entry 737 high
	// Position of LO field.
	GFXMMU_LUT737H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT737H_LO_Msk = 0x3ffff0

	// LUT738L: Graphic MMU LUT entry 738 low
	// Position of EN field.
	GFXMMU_LUT738L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT738L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT738L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT738L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT738L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT738L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT738L_LVB_Msk = 0xff0000

	// LUT738H: Graphic MMU LUT entry 738 high
	// Position of LO field.
	GFXMMU_LUT738H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT738H_LO_Msk = 0x3ffff0

	// LUT739L: Graphic MMU LUT entry 739 low
	// Position of EN field.
	GFXMMU_LUT739L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT739L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT739L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT739L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT739L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT739L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT739L_LVB_Msk = 0xff0000

	// LUT739H: Graphic MMU LUT entry 739 high
	// Position of LO field.
	GFXMMU_LUT739H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT739H_LO_Msk = 0x3ffff0

	// LUT740L: Graphic MMU LUT entry 740 low
	// Position of EN field.
	GFXMMU_LUT740L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT740L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT740L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT740L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT740L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT740L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT740L_LVB_Msk = 0xff0000

	// LUT740H: Graphic MMU LUT entry 740 high
	// Position of LO field.
	GFXMMU_LUT740H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT740H_LO_Msk = 0x3ffff0

	// LUT741L: Graphic MMU LUT entry 741 low
	// Position of EN field.
	GFXMMU_LUT741L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT741L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT741L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT741L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT741L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT741L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT741L_LVB_Msk = 0xff0000

	// LUT741H: Graphic MMU LUT entry 741 high
	// Position of LO field.
	GFXMMU_LUT741H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT741H_LO_Msk = 0x3ffff0

	// LUT742L: Graphic MMU LUT entry 742 low
	// Position of EN field.
	GFXMMU_LUT742L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT742L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT742L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT742L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT742L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT742L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT742L_LVB_Msk = 0xff0000

	// LUT742H: Graphic MMU LUT entry 742 high
	// Position of LO field.
	GFXMMU_LUT742H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT742H_LO_Msk = 0x3ffff0

	// LUT743L: Graphic MMU LUT entry 743 low
	// Position of EN field.
	GFXMMU_LUT743L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT743L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT743L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT743L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT743L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT743L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT743L_LVB_Msk = 0xff0000

	// LUT743H: Graphic MMU LUT entry 743 high
	// Position of LO field.
	GFXMMU_LUT743H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT743H_LO_Msk = 0x3ffff0

	// LUT744L: Graphic MMU LUT entry 744 low
	// Position of EN field.
	GFXMMU_LUT744L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT744L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT744L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT744L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT744L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT744L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT744L_LVB_Msk = 0xff0000

	// LUT744H: Graphic MMU LUT entry 744 high
	// Position of LO field.
	GFXMMU_LUT744H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT744H_LO_Msk = 0x3ffff0

	// LUT745L: Graphic MMU LUT entry 745 low
	// Position of EN field.
	GFXMMU_LUT745L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT745L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT745L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT745L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT745L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT745L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT745L_LVB_Msk = 0xff0000

	// LUT745H: Graphic MMU LUT entry 745 high
	// Position of LO field.
	GFXMMU_LUT745H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT745H_LO_Msk = 0x3ffff0

	// LUT746L: Graphic MMU LUT entry 746 low
	// Position of EN field.
	GFXMMU_LUT746L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT746L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT746L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT746L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT746L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT746L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT746L_LVB_Msk = 0xff0000

	// LUT746H: Graphic MMU LUT entry 746 high
	// Position of LO field.
	GFXMMU_LUT746H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT746H_LO_Msk = 0x3ffff0

	// LUT747L: Graphic MMU LUT entry 747 low
	// Position of EN field.
	GFXMMU_LUT747L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT747L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT747L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT747L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT747L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT747L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT747L_LVB_Msk = 0xff0000

	// LUT747H: Graphic MMU LUT entry 747 high
	// Position of LO field.
	GFXMMU_LUT747H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT747H_LO_Msk = 0x3ffff0

	// LUT748L: Graphic MMU LUT entry 748 low
	// Position of EN field.
	GFXMMU_LUT748L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT748L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT748L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT748L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT748L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT748L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT748L_LVB_Msk = 0xff0000

	// LUT748H: Graphic MMU LUT entry 748 high
	// Position of LO field.
	GFXMMU_LUT748H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT748H_LO_Msk = 0x3ffff0

	// LUT749L: Graphic MMU LUT entry 749 low
	// Position of EN field.
	GFXMMU_LUT749L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT749L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT749L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT749L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT749L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT749L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT749L_LVB_Msk = 0xff0000

	// LUT749H: Graphic MMU LUT entry 749 high
	// Position of LO field.
	GFXMMU_LUT749H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT749H_LO_Msk = 0x3ffff0

	// LUT750L: Graphic MMU LUT entry 750 low
	// Position of EN field.
	GFXMMU_LUT750L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT750L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT750L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT750L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT750L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT750L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT750L_LVB_Msk = 0xff0000

	// LUT750H: Graphic MMU LUT entry 750 high
	// Position of LO field.
	GFXMMU_LUT750H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT750H_LO_Msk = 0x3ffff0

	// LUT751L: Graphic MMU LUT entry 751 low
	// Position of EN field.
	GFXMMU_LUT751L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT751L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT751L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT751L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT751L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT751L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT751L_LVB_Msk = 0xff0000

	// LUT751H: Graphic MMU LUT entry 751 high
	// Position of LO field.
	GFXMMU_LUT751H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT751H_LO_Msk = 0x3ffff0

	// LUT752L: Graphic MMU LUT entry 752 low
	// Position of EN field.
	GFXMMU_LUT752L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT752L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT752L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT752L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT752L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT752L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT752L_LVB_Msk = 0xff0000

	// LUT752H: Graphic MMU LUT entry 752 high
	// Position of LO field.
	GFXMMU_LUT752H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT752H_LO_Msk = 0x3ffff0

	// LUT753L: Graphic MMU LUT entry 753 low
	// Position of EN field.
	GFXMMU_LUT753L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT753L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT753L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT753L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT753L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT753L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT753L_LVB_Msk = 0xff0000

	// LUT753H: Graphic MMU LUT entry 753 high
	// Position of LO field.
	GFXMMU_LUT753H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT753H_LO_Msk = 0x3ffff0

	// LUT754L: Graphic MMU LUT entry 754 low
	// Position of EN field.
	GFXMMU_LUT754L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT754L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT754L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT754L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT754L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT754L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT754L_LVB_Msk = 0xff0000

	// LUT754H: Graphic MMU LUT entry 754 high
	// Position of LO field.
	GFXMMU_LUT754H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT754H_LO_Msk = 0x3ffff0

	// LUT755L: Graphic MMU LUT entry 755 low
	// Position of EN field.
	GFXMMU_LUT755L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT755L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT755L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT755L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT755L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT755L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT755L_LVB_Msk = 0xff0000

	// LUT755H: Graphic MMU LUT entry 755 high
	// Position of LO field.
	GFXMMU_LUT755H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT755H_LO_Msk = 0x3ffff0

	// LUT756L: Graphic MMU LUT entry 756 low
	// Position of EN field.
	GFXMMU_LUT756L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT756L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT756L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT756L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT756L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT756L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT756L_LVB_Msk = 0xff0000

	// LUT756H: Graphic MMU LUT entry 756 high
	// Position of LO field.
	GFXMMU_LUT756H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT756H_LO_Msk = 0x3ffff0

	// LUT757L: Graphic MMU LUT entry 757 low
	// Position of EN field.
	GFXMMU_LUT757L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT757L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT757L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT757L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT757L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT757L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT757L_LVB_Msk = 0xff0000

	// LUT757H: Graphic MMU LUT entry 757 high
	// Position of LO field.
	GFXMMU_LUT757H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT757H_LO_Msk = 0x3ffff0

	// LUT758L: Graphic MMU LUT entry 758 low
	// Position of EN field.
	GFXMMU_LUT758L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT758L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT758L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT758L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT758L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT758L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT758L_LVB_Msk = 0xff0000

	// LUT758H: Graphic MMU LUT entry 758 high
	// Position of LO field.
	GFXMMU_LUT758H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT758H_LO_Msk = 0x3ffff0

	// LUT759L: Graphic MMU LUT entry 759 low
	// Position of EN field.
	GFXMMU_LUT759L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT759L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT759L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT759L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT759L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT759L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT759L_LVB_Msk = 0xff0000

	// LUT759H: Graphic MMU LUT entry 759 high
	// Position of LO field.
	GFXMMU_LUT759H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT759H_LO_Msk = 0x3ffff0

	// LUT760L: Graphic MMU LUT entry 760 low
	// Position of EN field.
	GFXMMU_LUT760L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT760L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT760L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT760L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT760L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT760L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT760L_LVB_Msk = 0xff0000

	// LUT760H: Graphic MMU LUT entry 760 high
	// Position of LO field.
	GFXMMU_LUT760H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT760H_LO_Msk = 0x3ffff0

	// LUT761L: Graphic MMU LUT entry 761 low
	// Position of EN field.
	GFXMMU_LUT761L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT761L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT761L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT761L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT761L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT761L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT761L_LVB_Msk = 0xff0000

	// LUT761H: Graphic MMU LUT entry 761 high
	// Position of LO field.
	GFXMMU_LUT761H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT761H_LO_Msk = 0x3ffff0

	// LUT762L: Graphic MMU LUT entry 762 low
	// Position of EN field.
	GFXMMU_LUT762L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT762L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT762L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT762L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT762L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT762L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT762L_LVB_Msk = 0xff0000

	// LUT762H: Graphic MMU LUT entry 762 high
	// Position of LO field.
	GFXMMU_LUT762H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT762H_LO_Msk = 0x3ffff0

	// LUT763L: Graphic MMU LUT entry 763 low
	// Position of EN field.
	GFXMMU_LUT763L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT763L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT763L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT763L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT763L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT763L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT763L_LVB_Msk = 0xff0000

	// LUT763H: Graphic MMU LUT entry 763 high
	// Position of LO field.
	GFXMMU_LUT763H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT763H_LO_Msk = 0x3ffff0

	// LUT764L: Graphic MMU LUT entry 764 low
	// Position of EN field.
	GFXMMU_LUT764L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT764L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT764L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT764L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT764L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT764L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT764L_LVB_Msk = 0xff0000

	// LUT764H: Graphic MMU LUT entry 764 high
	// Position of LO field.
	GFXMMU_LUT764H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT764H_LO_Msk = 0x3ffff0

	// LUT765L: Graphic MMU LUT entry 765 low
	// Position of EN field.
	GFXMMU_LUT765L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT765L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT765L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT765L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT765L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT765L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT765L_LVB_Msk = 0xff0000

	// LUT765H: Graphic MMU LUT entry 765 high
	// Position of LO field.
	GFXMMU_LUT765H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT765H_LO_Msk = 0x3ffff0

	// LUT766L: Graphic MMU LUT entry 766 low
	// Position of EN field.
	GFXMMU_LUT766L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT766L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT766L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT766L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT766L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT766L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT766L_LVB_Msk = 0xff0000

	// LUT766H: Graphic MMU LUT entry 766 high
	// Position of LO field.
	GFXMMU_LUT766H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT766H_LO_Msk = 0x3ffff0

	// LUT767L: Graphic MMU LUT entry 767 low
	// Position of EN field.
	GFXMMU_LUT767L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT767L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT767L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT767L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT767L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT767L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT767L_LVB_Msk = 0xff0000

	// LUT767H: Graphic MMU LUT entry 767 high
	// Position of LO field.
	GFXMMU_LUT767H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT767H_LO_Msk = 0x3ffff0

	// LUT768L: Graphic MMU LUT entry 768 low
	// Position of EN field.
	GFXMMU_LUT768L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT768L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT768L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT768L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT768L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT768L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT768L_LVB_Msk = 0xff0000

	// LUT768H: Graphic MMU LUT entry 768 high
	// Position of LO field.
	GFXMMU_LUT768H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT768H_LO_Msk = 0x3ffff0

	// LUT769L: Graphic MMU LUT entry 769 low
	// Position of EN field.
	GFXMMU_LUT769L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT769L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT769L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT769L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT769L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT769L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT769L_LVB_Msk = 0xff0000

	// LUT769H: Graphic MMU LUT entry 769 high
	// Position of LO field.
	GFXMMU_LUT769H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT769H_LO_Msk = 0x3ffff0

	// LUT770L: Graphic MMU LUT entry 770 low
	// Position of EN field.
	GFXMMU_LUT770L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT770L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT770L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT770L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT770L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT770L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT770L_LVB_Msk = 0xff0000

	// LUT770H: Graphic MMU LUT entry 770 high
	// Position of LO field.
	GFXMMU_LUT770H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT770H_LO_Msk = 0x3ffff0

	// LUT771L: Graphic MMU LUT entry 771 low
	// Position of EN field.
	GFXMMU_LUT771L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT771L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT771L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT771L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT771L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT771L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT771L_LVB_Msk = 0xff0000

	// LUT771H: Graphic MMU LUT entry 771 high
	// Position of LO field.
	GFXMMU_LUT771H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT771H_LO_Msk = 0x3ffff0

	// LUT772L: Graphic MMU LUT entry 772 low
	// Position of EN field.
	GFXMMU_LUT772L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT772L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT772L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT772L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT772L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT772L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT772L_LVB_Msk = 0xff0000

	// LUT772H: Graphic MMU LUT entry 772 high
	// Position of LO field.
	GFXMMU_LUT772H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT772H_LO_Msk = 0x3ffff0

	// LUT773L: Graphic MMU LUT entry 773 low
	// Position of EN field.
	GFXMMU_LUT773L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT773L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT773L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT773L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT773L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT773L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT773L_LVB_Msk = 0xff0000

	// LUT773H: Graphic MMU LUT entry 773 high
	// Position of LO field.
	GFXMMU_LUT773H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT773H_LO_Msk = 0x3ffff0

	// LUT774L: Graphic MMU LUT entry 774 low
	// Position of EN field.
	GFXMMU_LUT774L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT774L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT774L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT774L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT774L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT774L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT774L_LVB_Msk = 0xff0000

	// LUT774H: Graphic MMU LUT entry 774 high
	// Position of LO field.
	GFXMMU_LUT774H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT774H_LO_Msk = 0x3ffff0

	// LUT775L: Graphic MMU LUT entry 775 low
	// Position of EN field.
	GFXMMU_LUT775L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT775L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT775L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT775L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT775L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT775L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT775L_LVB_Msk = 0xff0000

	// LUT775H: Graphic MMU LUT entry 775 high
	// Position of LO field.
	GFXMMU_LUT775H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT775H_LO_Msk = 0x3ffff0

	// LUT776L: Graphic MMU LUT entry 776 low
	// Position of EN field.
	GFXMMU_LUT776L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT776L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT776L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT776L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT776L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT776L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT776L_LVB_Msk = 0xff0000

	// LUT776H: Graphic MMU LUT entry 776 high
	// Position of LO field.
	GFXMMU_LUT776H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT776H_LO_Msk = 0x3ffff0

	// LUT777L: Graphic MMU LUT entry 777 low
	// Position of EN field.
	GFXMMU_LUT777L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT777L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT777L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT777L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT777L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT777L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT777L_LVB_Msk = 0xff0000

	// LUT777H: Graphic MMU LUT entry 777 high
	// Position of LO field.
	GFXMMU_LUT777H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT777H_LO_Msk = 0x3ffff0

	// LUT778L: Graphic MMU LUT entry 778 low
	// Position of EN field.
	GFXMMU_LUT778L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT778L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT778L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT778L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT778L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT778L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT778L_LVB_Msk = 0xff0000

	// LUT778H: Graphic MMU LUT entry 778 high
	// Position of LO field.
	GFXMMU_LUT778H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT778H_LO_Msk = 0x3ffff0

	// LUT779L: Graphic MMU LUT entry 779 low
	// Position of EN field.
	GFXMMU_LUT779L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT779L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT779L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT779L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT779L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT779L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT779L_LVB_Msk = 0xff0000

	// LUT779H: Graphic MMU LUT entry 779 high
	// Position of LO field.
	GFXMMU_LUT779H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT779H_LO_Msk = 0x3ffff0

	// LUT780L: Graphic MMU LUT entry 780 low
	// Position of EN field.
	GFXMMU_LUT780L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT780L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT780L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT780L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT780L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT780L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT780L_LVB_Msk = 0xff0000

	// LUT780H: Graphic MMU LUT entry 780 high
	// Position of LO field.
	GFXMMU_LUT780H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT780H_LO_Msk = 0x3ffff0

	// LUT781L: Graphic MMU LUT entry 781 low
	// Position of EN field.
	GFXMMU_LUT781L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT781L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT781L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT781L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT781L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT781L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT781L_LVB_Msk = 0xff0000

	// LUT781H: Graphic MMU LUT entry 781 high
	// Position of LO field.
	GFXMMU_LUT781H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT781H_LO_Msk = 0x3ffff0

	// LUT782L: Graphic MMU LUT entry 782 low
	// Position of EN field.
	GFXMMU_LUT782L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT782L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT782L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT782L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT782L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT782L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT782L_LVB_Msk = 0xff0000

	// LUT782H: Graphic MMU LUT entry 782 high
	// Position of LO field.
	GFXMMU_LUT782H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT782H_LO_Msk = 0x3ffff0

	// LUT783L: Graphic MMU LUT entry 783 low
	// Position of EN field.
	GFXMMU_LUT783L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT783L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT783L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT783L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT783L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT783L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT783L_LVB_Msk = 0xff0000

	// LUT783H: Graphic MMU LUT entry 783 high
	// Position of LO field.
	GFXMMU_LUT783H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT783H_LO_Msk = 0x3ffff0

	// LUT784L: Graphic MMU LUT entry 784 low
	// Position of EN field.
	GFXMMU_LUT784L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT784L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT784L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT784L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT784L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT784L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT784L_LVB_Msk = 0xff0000

	// LUT784H: Graphic MMU LUT entry 784 high
	// Position of LO field.
	GFXMMU_LUT784H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT784H_LO_Msk = 0x3ffff0

	// LUT785L: Graphic MMU LUT entry 785 low
	// Position of EN field.
	GFXMMU_LUT785L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT785L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT785L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT785L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT785L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT785L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT785L_LVB_Msk = 0xff0000

	// LUT785H: Graphic MMU LUT entry 785 high
	// Position of LO field.
	GFXMMU_LUT785H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT785H_LO_Msk = 0x3ffff0

	// LUT786L: Graphic MMU LUT entry 786 low
	// Position of EN field.
	GFXMMU_LUT786L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT786L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT786L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT786L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT786L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT786L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT786L_LVB_Msk = 0xff0000

	// LUT786H: Graphic MMU LUT entry 786 high
	// Position of LO field.
	GFXMMU_LUT786H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT786H_LO_Msk = 0x3ffff0

	// LUT787L: Graphic MMU LUT entry 787 low
	// Position of EN field.
	GFXMMU_LUT787L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT787L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT787L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT787L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT787L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT787L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT787L_LVB_Msk = 0xff0000

	// LUT787H: Graphic MMU LUT entry 787 high
	// Position of LO field.
	GFXMMU_LUT787H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT787H_LO_Msk = 0x3ffff0

	// LUT788L: Graphic MMU LUT entry 788 low
	// Position of EN field.
	GFXMMU_LUT788L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT788L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT788L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT788L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT788L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT788L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT788L_LVB_Msk = 0xff0000

	// LUT788H: Graphic MMU LUT entry 788 high
	// Position of LO field.
	GFXMMU_LUT788H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT788H_LO_Msk = 0x3ffff0

	// LUT789L: Graphic MMU LUT entry 789 low
	// Position of EN field.
	GFXMMU_LUT789L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT789L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT789L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT789L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT789L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT789L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT789L_LVB_Msk = 0xff0000

	// LUT789H: Graphic MMU LUT entry 789 high
	// Position of LO field.
	GFXMMU_LUT789H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT789H_LO_Msk = 0x3ffff0

	// LUT790L: Graphic MMU LUT entry 790 low
	// Position of EN field.
	GFXMMU_LUT790L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT790L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT790L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT790L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT790L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT790L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT790L_LVB_Msk = 0xff0000

	// LUT790H: Graphic MMU LUT entry 790 high
	// Position of LO field.
	GFXMMU_LUT790H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT790H_LO_Msk = 0x3ffff0

	// LUT791L: Graphic MMU LUT entry 791 low
	// Position of EN field.
	GFXMMU_LUT791L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT791L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT791L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT791L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT791L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT791L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT791L_LVB_Msk = 0xff0000

	// LUT791H: Graphic MMU LUT entry 791 high
	// Position of LO field.
	GFXMMU_LUT791H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT791H_LO_Msk = 0x3ffff0

	// LUT792L: Graphic MMU LUT entry 792 low
	// Position of EN field.
	GFXMMU_LUT792L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT792L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT792L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT792L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT792L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT792L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT792L_LVB_Msk = 0xff0000

	// LUT792H: Graphic MMU LUT entry 792 high
	// Position of LO field.
	GFXMMU_LUT792H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT792H_LO_Msk = 0x3ffff0

	// LUT793L: Graphic MMU LUT entry 793 low
	// Position of EN field.
	GFXMMU_LUT793L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT793L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT793L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT793L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT793L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT793L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT793L_LVB_Msk = 0xff0000

	// LUT793H: Graphic MMU LUT entry 793 high
	// Position of LO field.
	GFXMMU_LUT793H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT793H_LO_Msk = 0x3ffff0

	// LUT794L: Graphic MMU LUT entry 794 low
	// Position of EN field.
	GFXMMU_LUT794L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT794L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT794L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT794L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT794L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT794L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT794L_LVB_Msk = 0xff0000

	// LUT794H: Graphic MMU LUT entry 794 high
	// Position of LO field.
	GFXMMU_LUT794H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT794H_LO_Msk = 0x3ffff0

	// LUT795L: Graphic MMU LUT entry 795 low
	// Position of EN field.
	GFXMMU_LUT795L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT795L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT795L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT795L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT795L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT795L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT795L_LVB_Msk = 0xff0000

	// LUT795H: Graphic MMU LUT entry 795 high
	// Position of LO field.
	GFXMMU_LUT795H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT795H_LO_Msk = 0x3ffff0

	// LUT796L: Graphic MMU LUT entry 796 low
	// Position of EN field.
	GFXMMU_LUT796L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT796L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT796L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT796L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT796L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT796L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT796L_LVB_Msk = 0xff0000

	// LUT796H: Graphic MMU LUT entry 796 high
	// Position of LO field.
	GFXMMU_LUT796H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT796H_LO_Msk = 0x3ffff0

	// LUT797L: Graphic MMU LUT entry 797 low
	// Position of EN field.
	GFXMMU_LUT797L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT797L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT797L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT797L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT797L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT797L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT797L_LVB_Msk = 0xff0000

	// LUT797H: Graphic MMU LUT entry 797 high
	// Position of LO field.
	GFXMMU_LUT797H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT797H_LO_Msk = 0x3ffff0

	// LUT798L: Graphic MMU LUT entry 798 low
	// Position of EN field.
	GFXMMU_LUT798L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT798L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT798L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT798L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT798L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT798L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT798L_LVB_Msk = 0xff0000

	// LUT798H: Graphic MMU LUT entry 798 high
	// Position of LO field.
	GFXMMU_LUT798H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT798H_LO_Msk = 0x3ffff0

	// LUT799L: Graphic MMU LUT entry 799 low
	// Position of EN field.
	GFXMMU_LUT799L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT799L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT799L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT799L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT799L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT799L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT799L_LVB_Msk = 0xff0000

	// LUT799H: Graphic MMU LUT entry 799 high
	// Position of LO field.
	GFXMMU_LUT799H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT799H_LO_Msk = 0x3ffff0

	// LUT800L: Graphic MMU LUT entry 800 low
	// Position of EN field.
	GFXMMU_LUT800L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT800L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT800L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT800L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT800L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT800L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT800L_LVB_Msk = 0xff0000

	// LUT800H: Graphic MMU LUT entry 800 high
	// Position of LO field.
	GFXMMU_LUT800H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT800H_LO_Msk = 0x3ffff0

	// LUT801L: Graphic MMU LUT entry 801 low
	// Position of EN field.
	GFXMMU_LUT801L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT801L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT801L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT801L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT801L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT801L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT801L_LVB_Msk = 0xff0000

	// LUT801H: Graphic MMU LUT entry 801 high
	// Position of LO field.
	GFXMMU_LUT801H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT801H_LO_Msk = 0x3ffff0

	// LUT802L: Graphic MMU LUT entry 802 low
	// Position of EN field.
	GFXMMU_LUT802L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT802L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT802L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT802L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT802L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT802L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT802L_LVB_Msk = 0xff0000

	// LUT802H: Graphic MMU LUT entry 802 high
	// Position of LO field.
	GFXMMU_LUT802H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT802H_LO_Msk = 0x3ffff0

	// LUT803L: Graphic MMU LUT entry 803 low
	// Position of EN field.
	GFXMMU_LUT803L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT803L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT803L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT803L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT803L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT803L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT803L_LVB_Msk = 0xff0000

	// LUT803H: Graphic MMU LUT entry 803 high
	// Position of LO field.
	GFXMMU_LUT803H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT803H_LO_Msk = 0x3ffff0

	// LUT804L: Graphic MMU LUT entry 804 low
	// Position of EN field.
	GFXMMU_LUT804L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT804L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT804L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT804L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT804L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT804L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT804L_LVB_Msk = 0xff0000

	// LUT804H: Graphic MMU LUT entry 804 high
	// Position of LO field.
	GFXMMU_LUT804H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT804H_LO_Msk = 0x3ffff0

	// LUT805L: Graphic MMU LUT entry 805 low
	// Position of EN field.
	GFXMMU_LUT805L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT805L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT805L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT805L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT805L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT805L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT805L_LVB_Msk = 0xff0000

	// LUT805H: Graphic MMU LUT entry 805 high
	// Position of LO field.
	GFXMMU_LUT805H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT805H_LO_Msk = 0x3ffff0

	// LUT806L: Graphic MMU LUT entry 806 low
	// Position of EN field.
	GFXMMU_LUT806L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT806L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT806L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT806L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT806L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT806L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT806L_LVB_Msk = 0xff0000

	// LUT806H: Graphic MMU LUT entry 806 high
	// Position of LO field.
	GFXMMU_LUT806H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT806H_LO_Msk = 0x3ffff0

	// LUT807L: Graphic MMU LUT entry 807 low
	// Position of EN field.
	GFXMMU_LUT807L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT807L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT807L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT807L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT807L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT807L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT807L_LVB_Msk = 0xff0000

	// LUT807H: Graphic MMU LUT entry 807 high
	// Position of LO field.
	GFXMMU_LUT807H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT807H_LO_Msk = 0x3ffff0

	// LUT808L: Graphic MMU LUT entry 808 low
	// Position of EN field.
	GFXMMU_LUT808L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT808L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT808L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT808L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT808L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT808L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT808L_LVB_Msk = 0xff0000

	// LUT808H: Graphic MMU LUT entry 808 high
	// Position of LO field.
	GFXMMU_LUT808H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT808H_LO_Msk = 0x3ffff0

	// LUT809L: Graphic MMU LUT entry 809 low
	// Position of EN field.
	GFXMMU_LUT809L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT809L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT809L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT809L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT809L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT809L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT809L_LVB_Msk = 0xff0000

	// LUT809H: Graphic MMU LUT entry 809 high
	// Position of LO field.
	GFXMMU_LUT809H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT809H_LO_Msk = 0x3ffff0

	// LUT810L: Graphic MMU LUT entry 810 low
	// Position of EN field.
	GFXMMU_LUT810L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT810L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT810L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT810L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT810L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT810L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT810L_LVB_Msk = 0xff0000

	// LUT810H: Graphic MMU LUT entry 810 high
	// Position of LO field.
	GFXMMU_LUT810H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT810H_LO_Msk = 0x3ffff0

	// LUT811L: Graphic MMU LUT entry 811 low
	// Position of EN field.
	GFXMMU_LUT811L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT811L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT811L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT811L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT811L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT811L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT811L_LVB_Msk = 0xff0000

	// LUT811H: Graphic MMU LUT entry 811 high
	// Position of LO field.
	GFXMMU_LUT811H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT811H_LO_Msk = 0x3ffff0

	// LUT812L: Graphic MMU LUT entry 812 low
	// Position of EN field.
	GFXMMU_LUT812L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT812L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT812L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT812L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT812L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT812L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT812L_LVB_Msk = 0xff0000

	// LUT812H: Graphic MMU LUT entry 812 high
	// Position of LO field.
	GFXMMU_LUT812H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT812H_LO_Msk = 0x3ffff0

	// LUT813L: Graphic MMU LUT entry 813 low
	// Position of EN field.
	GFXMMU_LUT813L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT813L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT813L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT813L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT813L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT813L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT813L_LVB_Msk = 0xff0000

	// LUT813H: Graphic MMU LUT entry 813 high
	// Position of LO field.
	GFXMMU_LUT813H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT813H_LO_Msk = 0x3ffff0

	// LUT814L: Graphic MMU LUT entry 814 low
	// Position of EN field.
	GFXMMU_LUT814L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT814L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT814L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT814L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT814L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT814L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT814L_LVB_Msk = 0xff0000

	// LUT814H: Graphic MMU LUT entry 814 high
	// Position of LO field.
	GFXMMU_LUT814H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT814H_LO_Msk = 0x3ffff0

	// LUT815L: Graphic MMU LUT entry 815 low
	// Position of EN field.
	GFXMMU_LUT815L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT815L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT815L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT815L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT815L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT815L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT815L_LVB_Msk = 0xff0000

	// LUT815H: Graphic MMU LUT entry 815 high
	// Position of LO field.
	GFXMMU_LUT815H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT815H_LO_Msk = 0x3ffff0

	// LUT816L: Graphic MMU LUT entry 816 low
	// Position of EN field.
	GFXMMU_LUT816L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT816L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT816L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT816L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT816L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT816L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT816L_LVB_Msk = 0xff0000

	// LUT816H: Graphic MMU LUT entry 816 high
	// Position of LO field.
	GFXMMU_LUT816H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT816H_LO_Msk = 0x3ffff0

	// LUT817L: Graphic MMU LUT entry 817 low
	// Position of EN field.
	GFXMMU_LUT817L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT817L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT817L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT817L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT817L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT817L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT817L_LVB_Msk = 0xff0000

	// LUT817H: Graphic MMU LUT entry 817 high
	// Position of LO field.
	GFXMMU_LUT817H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT817H_LO_Msk = 0x3ffff0

	// LUT818L: Graphic MMU LUT entry 818 low
	// Position of EN field.
	GFXMMU_LUT818L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT818L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT818L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT818L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT818L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT818L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT818L_LVB_Msk = 0xff0000

	// LUT818H: Graphic MMU LUT entry 818 high
	// Position of LO field.
	GFXMMU_LUT818H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT818H_LO_Msk = 0x3ffff0

	// LUT819L: Graphic MMU LUT entry 819 low
	// Position of EN field.
	GFXMMU_LUT819L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT819L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT819L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT819L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT819L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT819L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT819L_LVB_Msk = 0xff0000

	// LUT819H: Graphic MMU LUT entry 819 high
	// Position of LO field.
	GFXMMU_LUT819H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT819H_LO_Msk = 0x3ffff0

	// LUT820L: Graphic MMU LUT entry 820 low
	// Position of EN field.
	GFXMMU_LUT820L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT820L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT820L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT820L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT820L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT820L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT820L_LVB_Msk = 0xff0000

	// LUT820H: Graphic MMU LUT entry 820 high
	// Position of LO field.
	GFXMMU_LUT820H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT820H_LO_Msk = 0x3ffff0

	// LUT821L: Graphic MMU LUT entry 821 low
	// Position of EN field.
	GFXMMU_LUT821L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT821L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT821L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT821L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT821L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT821L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT821L_LVB_Msk = 0xff0000

	// LUT821H: Graphic MMU LUT entry 821 high
	// Position of LO field.
	GFXMMU_LUT821H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT821H_LO_Msk = 0x3ffff0

	// LUT822L: Graphic MMU LUT entry 822 low
	// Position of EN field.
	GFXMMU_LUT822L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT822L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT822L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT822L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT822L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT822L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT822L_LVB_Msk = 0xff0000

	// LUT822H: Graphic MMU LUT entry 822 high
	// Position of LO field.
	GFXMMU_LUT822H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT822H_LO_Msk = 0x3ffff0

	// LUT823L: Graphic MMU LUT entry 823 low
	// Position of EN field.
	GFXMMU_LUT823L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT823L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT823L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT823L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT823L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT823L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT823L_LVB_Msk = 0xff0000

	// LUT823H: Graphic MMU LUT entry 823 high
	// Position of LO field.
	GFXMMU_LUT823H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT823H_LO_Msk = 0x3ffff0

	// LUT824L: Graphic MMU LUT entry 824 low
	// Position of EN field.
	GFXMMU_LUT824L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT824L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT824L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT824L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT824L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT824L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT824L_LVB_Msk = 0xff0000

	// LUT824H: Graphic MMU LUT entry 824 high
	// Position of LO field.
	GFXMMU_LUT824H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT824H_LO_Msk = 0x3ffff0

	// LUT825L: Graphic MMU LUT entry 825 low
	// Position of EN field.
	GFXMMU_LUT825L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT825L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT825L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT825L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT825L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT825L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT825L_LVB_Msk = 0xff0000

	// LUT825H: Graphic MMU LUT entry 825 high
	// Position of LO field.
	GFXMMU_LUT825H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT825H_LO_Msk = 0x3ffff0

	// LUT826L: Graphic MMU LUT entry 826 low
	// Position of EN field.
	GFXMMU_LUT826L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT826L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT826L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT826L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT826L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT826L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT826L_LVB_Msk = 0xff0000

	// LUT826H: Graphic MMU LUT entry 826 high
	// Position of LO field.
	GFXMMU_LUT826H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT826H_LO_Msk = 0x3ffff0

	// LUT827L: Graphic MMU LUT entry 827 low
	// Position of EN field.
	GFXMMU_LUT827L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT827L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT827L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT827L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT827L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT827L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT827L_LVB_Msk = 0xff0000

	// LUT827H: Graphic MMU LUT entry 827 high
	// Position of LO field.
	GFXMMU_LUT827H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT827H_LO_Msk = 0x3ffff0

	// LUT828L: Graphic MMU LUT entry 828 low
	// Position of EN field.
	GFXMMU_LUT828L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT828L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT828L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT828L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT828L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT828L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT828L_LVB_Msk = 0xff0000

	// LUT828H: Graphic MMU LUT entry 828 high
	// Position of LO field.
	GFXMMU_LUT828H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT828H_LO_Msk = 0x3ffff0

	// LUT829L: Graphic MMU LUT entry 829 low
	// Position of EN field.
	GFXMMU_LUT829L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT829L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT829L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT829L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT829L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT829L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT829L_LVB_Msk = 0xff0000

	// LUT829H: Graphic MMU LUT entry 829 high
	// Position of LO field.
	GFXMMU_LUT829H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT829H_LO_Msk = 0x3ffff0

	// LUT830L: Graphic MMU LUT entry 830 low
	// Position of EN field.
	GFXMMU_LUT830L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT830L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT830L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT830L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT830L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT830L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT830L_LVB_Msk = 0xff0000

	// LUT830H: Graphic MMU LUT entry 830 high
	// Position of LO field.
	GFXMMU_LUT830H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT830H_LO_Msk = 0x3ffff0

	// LUT831L: Graphic MMU LUT entry 831 low
	// Position of EN field.
	GFXMMU_LUT831L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT831L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT831L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT831L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT831L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT831L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT831L_LVB_Msk = 0xff0000

	// LUT831H: Graphic MMU LUT entry 831 high
	// Position of LO field.
	GFXMMU_LUT831H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT831H_LO_Msk = 0x3ffff0

	// LUT832L: Graphic MMU LUT entry 832 low
	// Position of EN field.
	GFXMMU_LUT832L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT832L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT832L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT832L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT832L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT832L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT832L_LVB_Msk = 0xff0000

	// LUT832H: Graphic MMU LUT entry 832 high
	// Position of LO field.
	GFXMMU_LUT832H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT832H_LO_Msk = 0x3ffff0

	// LUT833L: Graphic MMU LUT entry 833 low
	// Position of EN field.
	GFXMMU_LUT833L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT833L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT833L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT833L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT833L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT833L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT833L_LVB_Msk = 0xff0000

	// LUT833H: Graphic MMU LUT entry 833 high
	// Position of LO field.
	GFXMMU_LUT833H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT833H_LO_Msk = 0x3ffff0

	// LUT834L: Graphic MMU LUT entry 834 low
	// Position of EN field.
	GFXMMU_LUT834L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT834L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT834L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT834L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT834L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT834L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT834L_LVB_Msk = 0xff0000

	// LUT834H: Graphic MMU LUT entry 834 high
	// Position of LO field.
	GFXMMU_LUT834H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT834H_LO_Msk = 0x3ffff0

	// LUT835L: Graphic MMU LUT entry 835 low
	// Position of EN field.
	GFXMMU_LUT835L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT835L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT835L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT835L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT835L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT835L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT835L_LVB_Msk = 0xff0000

	// LUT835H: Graphic MMU LUT entry 835 high
	// Position of LO field.
	GFXMMU_LUT835H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT835H_LO_Msk = 0x3ffff0

	// LUT836L: Graphic MMU LUT entry 836 low
	// Position of EN field.
	GFXMMU_LUT836L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT836L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT836L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT836L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT836L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT836L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT836L_LVB_Msk = 0xff0000

	// LUT836H: Graphic MMU LUT entry 836 high
	// Position of LO field.
	GFXMMU_LUT836H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT836H_LO_Msk = 0x3ffff0

	// LUT837L: Graphic MMU LUT entry 837 low
	// Position of EN field.
	GFXMMU_LUT837L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT837L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT837L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT837L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT837L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT837L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT837L_LVB_Msk = 0xff0000

	// LUT837H: Graphic MMU LUT entry 837 high
	// Position of LO field.
	GFXMMU_LUT837H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT837H_LO_Msk = 0x3ffff0

	// LUT838L: Graphic MMU LUT entry 838 low
	// Position of EN field.
	GFXMMU_LUT838L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT838L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT838L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT838L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT838L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT838L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT838L_LVB_Msk = 0xff0000

	// LUT838H: Graphic MMU LUT entry 838 high
	// Position of LO field.
	GFXMMU_LUT838H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT838H_LO_Msk = 0x3ffff0

	// LUT839L: Graphic MMU LUT entry 839 low
	// Position of EN field.
	GFXMMU_LUT839L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT839L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT839L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT839L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT839L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT839L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT839L_LVB_Msk = 0xff0000

	// LUT839H: Graphic MMU LUT entry 839 high
	// Position of LO field.
	GFXMMU_LUT839H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT839H_LO_Msk = 0x3ffff0

	// LUT840L: Graphic MMU LUT entry 840 low
	// Position of EN field.
	GFXMMU_LUT840L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT840L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT840L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT840L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT840L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT840L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT840L_LVB_Msk = 0xff0000

	// LUT840H: Graphic MMU LUT entry 840 high
	// Position of LO field.
	GFXMMU_LUT840H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT840H_LO_Msk = 0x3ffff0

	// LUT841L: Graphic MMU LUT entry 841 low
	// Position of EN field.
	GFXMMU_LUT841L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT841L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT841L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT841L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT841L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT841L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT841L_LVB_Msk = 0xff0000

	// LUT841H: Graphic MMU LUT entry 841 high
	// Position of LO field.
	GFXMMU_LUT841H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT841H_LO_Msk = 0x3ffff0

	// LUT842L: Graphic MMU LUT entry 842 low
	// Position of EN field.
	GFXMMU_LUT842L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT842L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT842L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT842L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT842L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT842L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT842L_LVB_Msk = 0xff0000

	// LUT842H: Graphic MMU LUT entry 842 high
	// Position of LO field.
	GFXMMU_LUT842H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT842H_LO_Msk = 0x3ffff0

	// LUT843L: Graphic MMU LUT entry 843 low
	// Position of EN field.
	GFXMMU_LUT843L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT843L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT843L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT843L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT843L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT843L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT843L_LVB_Msk = 0xff0000

	// LUT843H: Graphic MMU LUT entry 843 high
	// Position of LO field.
	GFXMMU_LUT843H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT843H_LO_Msk = 0x3ffff0

	// LUT844L: Graphic MMU LUT entry 844 low
	// Position of EN field.
	GFXMMU_LUT844L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT844L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT844L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT844L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT844L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT844L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT844L_LVB_Msk = 0xff0000

	// LUT844H: Graphic MMU LUT entry 844 high
	// Position of LO field.
	GFXMMU_LUT844H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT844H_LO_Msk = 0x3ffff0

	// LUT845L: Graphic MMU LUT entry 845 low
	// Position of EN field.
	GFXMMU_LUT845L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT845L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT845L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT845L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT845L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT845L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT845L_LVB_Msk = 0xff0000

	// LUT845H: Graphic MMU LUT entry 845 high
	// Position of LO field.
	GFXMMU_LUT845H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT845H_LO_Msk = 0x3ffff0

	// LUT846L: Graphic MMU LUT entry 846 low
	// Position of EN field.
	GFXMMU_LUT846L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT846L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT846L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT846L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT846L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT846L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT846L_LVB_Msk = 0xff0000

	// LUT846H: Graphic MMU LUT entry 846 high
	// Position of LO field.
	GFXMMU_LUT846H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT846H_LO_Msk = 0x3ffff0

	// LUT847L: Graphic MMU LUT entry 847 low
	// Position of EN field.
	GFXMMU_LUT847L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT847L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT847L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT847L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT847L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT847L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT847L_LVB_Msk = 0xff0000

	// LUT847H: Graphic MMU LUT entry 847 high
	// Position of LO field.
	GFXMMU_LUT847H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT847H_LO_Msk = 0x3ffff0

	// LUT848L: Graphic MMU LUT entry 848 low
	// Position of EN field.
	GFXMMU_LUT848L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT848L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT848L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT848L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT848L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT848L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT848L_LVB_Msk = 0xff0000

	// LUT848H: Graphic MMU LUT entry 848 high
	// Position of LO field.
	GFXMMU_LUT848H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT848H_LO_Msk = 0x3ffff0

	// LUT849L: Graphic MMU LUT entry 849 low
	// Position of EN field.
	GFXMMU_LUT849L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT849L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT849L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT849L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT849L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT849L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT849L_LVB_Msk = 0xff0000

	// LUT849H: Graphic MMU LUT entry 849 high
	// Position of LO field.
	GFXMMU_LUT849H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT849H_LO_Msk = 0x3ffff0

	// LUT850L: Graphic MMU LUT entry 850 low
	// Position of EN field.
	GFXMMU_LUT850L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT850L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT850L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT850L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT850L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT850L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT850L_LVB_Msk = 0xff0000

	// LUT850H: Graphic MMU LUT entry 850 high
	// Position of LO field.
	GFXMMU_LUT850H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT850H_LO_Msk = 0x3ffff0

	// LUT851L: Graphic MMU LUT entry 851 low
	// Position of EN field.
	GFXMMU_LUT851L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT851L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT851L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT851L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT851L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT851L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT851L_LVB_Msk = 0xff0000

	// LUT851H: Graphic MMU LUT entry 851 high
	// Position of LO field.
	GFXMMU_LUT851H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT851H_LO_Msk = 0x3ffff0

	// LUT852L: Graphic MMU LUT entry 852 low
	// Position of EN field.
	GFXMMU_LUT852L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT852L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT852L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT852L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT852L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT852L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT852L_LVB_Msk = 0xff0000

	// LUT852H: Graphic MMU LUT entry 852 high
	// Position of LO field.
	GFXMMU_LUT852H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT852H_LO_Msk = 0x3ffff0

	// LUT853L: Graphic MMU LUT entry 853 low
	// Position of EN field.
	GFXMMU_LUT853L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT853L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT853L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT853L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT853L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT853L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT853L_LVB_Msk = 0xff0000

	// LUT853H: Graphic MMU LUT entry 853 high
	// Position of LO field.
	GFXMMU_LUT853H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT853H_LO_Msk = 0x3ffff0

	// LUT854L: Graphic MMU LUT entry 854 low
	// Position of EN field.
	GFXMMU_LUT854L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT854L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT854L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT854L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT854L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT854L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT854L_LVB_Msk = 0xff0000

	// LUT854H: Graphic MMU LUT entry 854 high
	// Position of LO field.
	GFXMMU_LUT854H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT854H_LO_Msk = 0x3ffff0

	// LUT855L: Graphic MMU LUT entry 855 low
	// Position of EN field.
	GFXMMU_LUT855L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT855L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT855L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT855L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT855L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT855L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT855L_LVB_Msk = 0xff0000

	// LUT855H: Graphic MMU LUT entry 855 high
	// Position of LO field.
	GFXMMU_LUT855H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT855H_LO_Msk = 0x3ffff0

	// LUT856L: Graphic MMU LUT entry 856 low
	// Position of EN field.
	GFXMMU_LUT856L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT856L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT856L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT856L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT856L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT856L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT856L_LVB_Msk = 0xff0000

	// LUT856H: Graphic MMU LUT entry 856 high
	// Position of LO field.
	GFXMMU_LUT856H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT856H_LO_Msk = 0x3ffff0

	// LUT857L: Graphic MMU LUT entry 857 low
	// Position of EN field.
	GFXMMU_LUT857L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT857L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT857L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT857L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT857L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT857L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT857L_LVB_Msk = 0xff0000

	// LUT857H: Graphic MMU LUT entry 857 high
	// Position of LO field.
	GFXMMU_LUT857H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT857H_LO_Msk = 0x3ffff0

	// LUT858L: Graphic MMU LUT entry 858 low
	// Position of EN field.
	GFXMMU_LUT858L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT858L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT858L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT858L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT858L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT858L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT858L_LVB_Msk = 0xff0000

	// LUT858H: Graphic MMU LUT entry 858 high
	// Position of LO field.
	GFXMMU_LUT858H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT858H_LO_Msk = 0x3ffff0

	// LUT859L: Graphic MMU LUT entry 859 low
	// Position of EN field.
	GFXMMU_LUT859L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT859L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT859L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT859L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT859L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT859L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT859L_LVB_Msk = 0xff0000

	// LUT859H: Graphic MMU LUT entry 859 high
	// Position of LO field.
	GFXMMU_LUT859H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT859H_LO_Msk = 0x3ffff0

	// LUT860L: Graphic MMU LUT entry 860 low
	// Position of EN field.
	GFXMMU_LUT860L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT860L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT860L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT860L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT860L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT860L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT860L_LVB_Msk = 0xff0000

	// LUT860H: Graphic MMU LUT entry 860 high
	// Position of LO field.
	GFXMMU_LUT860H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT860H_LO_Msk = 0x3ffff0

	// LUT861L: Graphic MMU LUT entry 861 low
	// Position of EN field.
	GFXMMU_LUT861L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT861L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT861L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT861L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT861L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT861L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT861L_LVB_Msk = 0xff0000

	// LUT861H: Graphic MMU LUT entry 861 high
	// Position of LO field.
	GFXMMU_LUT861H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT861H_LO_Msk = 0x3ffff0

	// LUT862L: Graphic MMU LUT entry 862 low
	// Position of EN field.
	GFXMMU_LUT862L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT862L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT862L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT862L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT862L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT862L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT862L_LVB_Msk = 0xff0000

	// LUT862H: Graphic MMU LUT entry 862 high
	// Position of LO field.
	GFXMMU_LUT862H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT862H_LO_Msk = 0x3ffff0

	// LUT863L: Graphic MMU LUT entry 863 low
	// Position of EN field.
	GFXMMU_LUT863L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT863L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT863L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT863L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT863L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT863L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT863L_LVB_Msk = 0xff0000

	// LUT863H: Graphic MMU LUT entry 863 high
	// Position of LO field.
	GFXMMU_LUT863H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT863H_LO_Msk = 0x3ffff0

	// LUT864L: Graphic MMU LUT entry 864 low
	// Position of EN field.
	GFXMMU_LUT864L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT864L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT864L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT864L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT864L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT864L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT864L_LVB_Msk = 0xff0000

	// LUT864H: Graphic MMU LUT entry 864 high
	// Position of LO field.
	GFXMMU_LUT864H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT864H_LO_Msk = 0x3ffff0

	// LUT865L: Graphic MMU LUT entry 865 low
	// Position of EN field.
	GFXMMU_LUT865L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT865L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT865L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT865L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT865L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT865L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT865L_LVB_Msk = 0xff0000

	// LUT865H: Graphic MMU LUT entry 865 high
	// Position of LO field.
	GFXMMU_LUT865H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT865H_LO_Msk = 0x3ffff0

	// LUT866L: Graphic MMU LUT entry 866 low
	// Position of EN field.
	GFXMMU_LUT866L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT866L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT866L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT866L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT866L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT866L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT866L_LVB_Msk = 0xff0000

	// LUT866H: Graphic MMU LUT entry 866 high
	// Position of LO field.
	GFXMMU_LUT866H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT866H_LO_Msk = 0x3ffff0

	// LUT867L: Graphic MMU LUT entry 867 low
	// Position of EN field.
	GFXMMU_LUT867L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT867L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT867L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT867L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT867L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT867L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT867L_LVB_Msk = 0xff0000

	// LUT867H: Graphic MMU LUT entry 867 high
	// Position of LO field.
	GFXMMU_LUT867H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT867H_LO_Msk = 0x3ffff0

	// LUT868L: Graphic MMU LUT entry 868 low
	// Position of EN field.
	GFXMMU_LUT868L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT868L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT868L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT868L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT868L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT868L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT868L_LVB_Msk = 0xff0000

	// LUT868H: Graphic MMU LUT entry 868 high
	// Position of LO field.
	GFXMMU_LUT868H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT868H_LO_Msk = 0x3ffff0

	// LUT869L: Graphic MMU LUT entry 869 low
	// Position of EN field.
	GFXMMU_LUT869L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT869L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT869L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT869L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT869L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT869L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT869L_LVB_Msk = 0xff0000

	// LUT869H: Graphic MMU LUT entry 869 high
	// Position of LO field.
	GFXMMU_LUT869H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT869H_LO_Msk = 0x3ffff0

	// LUT870L: Graphic MMU LUT entry 870 low
	// Position of EN field.
	GFXMMU_LUT870L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT870L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT870L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT870L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT870L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT870L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT870L_LVB_Msk = 0xff0000

	// LUT870H: Graphic MMU LUT entry 870 high
	// Position of LO field.
	GFXMMU_LUT870H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT870H_LO_Msk = 0x3ffff0

	// LUT871L: Graphic MMU LUT entry 871 low
	// Position of EN field.
	GFXMMU_LUT871L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT871L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT871L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT871L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT871L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT871L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT871L_LVB_Msk = 0xff0000

	// LUT871H: Graphic MMU LUT entry 871 high
	// Position of LO field.
	GFXMMU_LUT871H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT871H_LO_Msk = 0x3ffff0

	// LUT872L: Graphic MMU LUT entry 872 low
	// Position of EN field.
	GFXMMU_LUT872L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT872L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT872L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT872L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT872L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT872L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT872L_LVB_Msk = 0xff0000

	// LUT872H: Graphic MMU LUT entry 872 high
	// Position of LO field.
	GFXMMU_LUT872H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT872H_LO_Msk = 0x3ffff0

	// LUT873L: Graphic MMU LUT entry 873 low
	// Position of EN field.
	GFXMMU_LUT873L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT873L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT873L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT873L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT873L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT873L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT873L_LVB_Msk = 0xff0000

	// LUT873H: Graphic MMU LUT entry 873 high
	// Position of LO field.
	GFXMMU_LUT873H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT873H_LO_Msk = 0x3ffff0

	// LUT874L: Graphic MMU LUT entry 874 low
	// Position of EN field.
	GFXMMU_LUT874L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT874L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT874L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT874L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT874L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT874L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT874L_LVB_Msk = 0xff0000

	// LUT874H: Graphic MMU LUT entry 874 high
	// Position of LO field.
	GFXMMU_LUT874H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT874H_LO_Msk = 0x3ffff0

	// LUT875L: Graphic MMU LUT entry 875 low
	// Position of EN field.
	GFXMMU_LUT875L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT875L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT875L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT875L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT875L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT875L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT875L_LVB_Msk = 0xff0000

	// LUT875H: Graphic MMU LUT entry 875 high
	// Position of LO field.
	GFXMMU_LUT875H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT875H_LO_Msk = 0x3ffff0

	// LUT876L: Graphic MMU LUT entry 876 low
	// Position of EN field.
	GFXMMU_LUT876L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT876L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT876L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT876L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT876L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT876L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT876L_LVB_Msk = 0xff0000

	// LUT876H: Graphic MMU LUT entry 876 high
	// Position of LO field.
	GFXMMU_LUT876H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT876H_LO_Msk = 0x3ffff0

	// LUT877L: Graphic MMU LUT entry 877 low
	// Position of EN field.
	GFXMMU_LUT877L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT877L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT877L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT877L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT877L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT877L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT877L_LVB_Msk = 0xff0000

	// LUT877H: Graphic MMU LUT entry 877 high
	// Position of LO field.
	GFXMMU_LUT877H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT877H_LO_Msk = 0x3ffff0

	// LUT878L: Graphic MMU LUT entry 878 low
	// Position of EN field.
	GFXMMU_LUT878L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT878L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT878L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT878L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT878L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT878L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT878L_LVB_Msk = 0xff0000

	// LUT878H: Graphic MMU LUT entry 878 high
	// Position of LO field.
	GFXMMU_LUT878H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT878H_LO_Msk = 0x3ffff0

	// LUT879L: Graphic MMU LUT entry 879 low
	// Position of EN field.
	GFXMMU_LUT879L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT879L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT879L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT879L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT879L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT879L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT879L_LVB_Msk = 0xff0000

	// LUT879H: Graphic MMU LUT entry 879 high
	// Position of LO field.
	GFXMMU_LUT879H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT879H_LO_Msk = 0x3ffff0

	// LUT880L: Graphic MMU LUT entry 880 low
	// Position of EN field.
	GFXMMU_LUT880L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT880L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT880L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT880L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT880L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT880L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT880L_LVB_Msk = 0xff0000

	// LUT880H: Graphic MMU LUT entry 880 high
	// Position of LO field.
	GFXMMU_LUT880H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT880H_LO_Msk = 0x3ffff0

	// LUT881L: Graphic MMU LUT entry 881 low
	// Position of EN field.
	GFXMMU_LUT881L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT881L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT881L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT881L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT881L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT881L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT881L_LVB_Msk = 0xff0000

	// LUT881H: Graphic MMU LUT entry 881 high
	// Position of LO field.
	GFXMMU_LUT881H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT881H_LO_Msk = 0x3ffff0

	// LUT882L: Graphic MMU LUT entry 882 low
	// Position of EN field.
	GFXMMU_LUT882L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT882L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT882L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT882L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT882L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT882L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT882L_LVB_Msk = 0xff0000

	// LUT882H: Graphic MMU LUT entry 882 high
	// Position of LO field.
	GFXMMU_LUT882H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT882H_LO_Msk = 0x3ffff0

	// LUT883L: Graphic MMU LUT entry 883 low
	// Position of EN field.
	GFXMMU_LUT883L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT883L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT883L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT883L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT883L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT883L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT883L_LVB_Msk = 0xff0000

	// LUT883H: Graphic MMU LUT entry 883 high
	// Position of LO field.
	GFXMMU_LUT883H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT883H_LO_Msk = 0x3ffff0

	// LUT884L: Graphic MMU LUT entry 884 low
	// Position of EN field.
	GFXMMU_LUT884L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT884L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT884L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT884L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT884L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT884L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT884L_LVB_Msk = 0xff0000

	// LUT884H: Graphic MMU LUT entry 884 high
	// Position of LO field.
	GFXMMU_LUT884H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT884H_LO_Msk = 0x3ffff0

	// LUT885L: Graphic MMU LUT entry 885 low
	// Position of EN field.
	GFXMMU_LUT885L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT885L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT885L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT885L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT885L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT885L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT885L_LVB_Msk = 0xff0000

	// LUT885H: Graphic MMU LUT entry 885 high
	// Position of LO field.
	GFXMMU_LUT885H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT885H_LO_Msk = 0x3ffff0

	// LUT886L: Graphic MMU LUT entry 886 low
	// Position of EN field.
	GFXMMU_LUT886L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT886L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT886L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT886L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT886L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT886L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT886L_LVB_Msk = 0xff0000

	// LUT886H: Graphic MMU LUT entry 886 high
	// Position of LO field.
	GFXMMU_LUT886H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT886H_LO_Msk = 0x3ffff0

	// LUT887L: Graphic MMU LUT entry 887 low
	// Position of EN field.
	GFXMMU_LUT887L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT887L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT887L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT887L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT887L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT887L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT887L_LVB_Msk = 0xff0000

	// LUT887H: Graphic MMU LUT entry 887 high
	// Position of LO field.
	GFXMMU_LUT887H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT887H_LO_Msk = 0x3ffff0

	// LUT888L: Graphic MMU LUT entry 888 low
	// Position of EN field.
	GFXMMU_LUT888L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT888L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT888L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT888L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT888L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT888L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT888L_LVB_Msk = 0xff0000

	// LUT888H: Graphic MMU LUT entry 888 high
	// Position of LO field.
	GFXMMU_LUT888H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT888H_LO_Msk = 0x3ffff0

	// LUT889L: Graphic MMU LUT entry 889 low
	// Position of EN field.
	GFXMMU_LUT889L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT889L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT889L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT889L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT889L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT889L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT889L_LVB_Msk = 0xff0000

	// LUT889H: Graphic MMU LUT entry 889 high
	// Position of LO field.
	GFXMMU_LUT889H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT889H_LO_Msk = 0x3ffff0

	// LUT890L: Graphic MMU LUT entry 890 low
	// Position of EN field.
	GFXMMU_LUT890L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT890L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT890L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT890L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT890L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT890L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT890L_LVB_Msk = 0xff0000

	// LUT890H: Graphic MMU LUT entry 890 high
	// Position of LO field.
	GFXMMU_LUT890H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT890H_LO_Msk = 0x3ffff0

	// LUT891L: Graphic MMU LUT entry 891 low
	// Position of EN field.
	GFXMMU_LUT891L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT891L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT891L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT891L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT891L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT891L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT891L_LVB_Msk = 0xff0000

	// LUT891H: Graphic MMU LUT entry 891 high
	// Position of LO field.
	GFXMMU_LUT891H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT891H_LO_Msk = 0x3ffff0

	// LUT892L: Graphic MMU LUT entry 892 low
	// Position of EN field.
	GFXMMU_LUT892L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT892L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT892L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT892L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT892L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT892L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT892L_LVB_Msk = 0xff0000

	// LUT892H: Graphic MMU LUT entry 892 high
	// Position of LO field.
	GFXMMU_LUT892H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT892H_LO_Msk = 0x3ffff0

	// LUT893L: Graphic MMU LUT entry 893 low
	// Position of EN field.
	GFXMMU_LUT893L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT893L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT893L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT893L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT893L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT893L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT893L_LVB_Msk = 0xff0000

	// LUT893H: Graphic MMU LUT entry 893 high
	// Position of LO field.
	GFXMMU_LUT893H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT893H_LO_Msk = 0x3ffff0

	// LUT894L: Graphic MMU LUT entry 894 low
	// Position of EN field.
	GFXMMU_LUT894L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT894L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT894L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT894L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT894L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT894L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT894L_LVB_Msk = 0xff0000

	// LUT894H: Graphic MMU LUT entry 894 high
	// Position of LO field.
	GFXMMU_LUT894H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT894H_LO_Msk = 0x3ffff0

	// LUT895L: Graphic MMU LUT entry 895 low
	// Position of EN field.
	GFXMMU_LUT895L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT895L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT895L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT895L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT895L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT895L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT895L_LVB_Msk = 0xff0000

	// LUT895H: Graphic MMU LUT entry 895 high
	// Position of LO field.
	GFXMMU_LUT895H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT895H_LO_Msk = 0x3ffff0

	// LUT896L: Graphic MMU LUT entry 896 low
	// Position of EN field.
	GFXMMU_LUT896L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT896L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT896L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT896L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT896L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT896L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT896L_LVB_Msk = 0xff0000

	// LUT896H: Graphic MMU LUT entry 896 high
	// Position of LO field.
	GFXMMU_LUT896H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT896H_LO_Msk = 0x3ffff0

	// LUT897L: Graphic MMU LUT entry 897 low
	// Position of EN field.
	GFXMMU_LUT897L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT897L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT897L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT897L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT897L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT897L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT897L_LVB_Msk = 0xff0000

	// LUT897H: Graphic MMU LUT entry 897 high
	// Position of LO field.
	GFXMMU_LUT897H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT897H_LO_Msk = 0x3ffff0

	// LUT898L: Graphic MMU LUT entry 898 low
	// Position of EN field.
	GFXMMU_LUT898L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT898L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT898L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT898L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT898L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT898L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT898L_LVB_Msk = 0xff0000

	// LUT898H: Graphic MMU LUT entry 898 high
	// Position of LO field.
	GFXMMU_LUT898H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT898H_LO_Msk = 0x3ffff0

	// LUT899L: Graphic MMU LUT entry 899 low
	// Position of EN field.
	GFXMMU_LUT899L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT899L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT899L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT899L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT899L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT899L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT899L_LVB_Msk = 0xff0000

	// LUT899H: Graphic MMU LUT entry 899 high
	// Position of LO field.
	GFXMMU_LUT899H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT899H_LO_Msk = 0x3ffff0

	// LUT900L: Graphic MMU LUT entry 900 low
	// Position of EN field.
	GFXMMU_LUT900L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT900L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT900L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT900L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT900L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT900L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT900L_LVB_Msk = 0xff0000

	// LUT900H: Graphic MMU LUT entry 900 high
	// Position of LO field.
	GFXMMU_LUT900H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT900H_LO_Msk = 0x3ffff0

	// LUT901L: Graphic MMU LUT entry 901 low
	// Position of EN field.
	GFXMMU_LUT901L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT901L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT901L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT901L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT901L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT901L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT901L_LVB_Msk = 0xff0000

	// LUT901H: Graphic MMU LUT entry 901 high
	// Position of LO field.
	GFXMMU_LUT901H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT901H_LO_Msk = 0x3ffff0

	// LUT902L: Graphic MMU LUT entry 902 low
	// Position of EN field.
	GFXMMU_LUT902L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT902L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT902L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT902L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT902L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT902L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT902L_LVB_Msk = 0xff0000

	// LUT902H: Graphic MMU LUT entry 902 high
	// Position of LO field.
	GFXMMU_LUT902H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT902H_LO_Msk = 0x3ffff0

	// LUT903L: Graphic MMU LUT entry 903 low
	// Position of EN field.
	GFXMMU_LUT903L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT903L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT903L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT903L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT903L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT903L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT903L_LVB_Msk = 0xff0000

	// LUT903H: Graphic MMU LUT entry 903 high
	// Position of LO field.
	GFXMMU_LUT903H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT903H_LO_Msk = 0x3ffff0

	// LUT904L: Graphic MMU LUT entry 904 low
	// Position of EN field.
	GFXMMU_LUT904L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT904L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT904L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT904L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT904L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT904L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT904L_LVB_Msk = 0xff0000

	// LUT904H: Graphic MMU LUT entry 904 high
	// Position of LO field.
	GFXMMU_LUT904H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT904H_LO_Msk = 0x3ffff0

	// LUT905L: Graphic MMU LUT entry 905 low
	// Position of EN field.
	GFXMMU_LUT905L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT905L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT905L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT905L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT905L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT905L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT905L_LVB_Msk = 0xff0000

	// LUT905H: Graphic MMU LUT entry 905 high
	// Position of LO field.
	GFXMMU_LUT905H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT905H_LO_Msk = 0x3ffff0

	// LUT906L: Graphic MMU LUT entry 906 low
	// Position of EN field.
	GFXMMU_LUT906L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT906L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT906L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT906L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT906L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT906L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT906L_LVB_Msk = 0xff0000

	// LUT906H: Graphic MMU LUT entry 906 high
	// Position of LO field.
	GFXMMU_LUT906H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT906H_LO_Msk = 0x3ffff0

	// LUT907L: Graphic MMU LUT entry 907 low
	// Position of EN field.
	GFXMMU_LUT907L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT907L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT907L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT907L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT907L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT907L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT907L_LVB_Msk = 0xff0000

	// LUT907H: Graphic MMU LUT entry 907 high
	// Position of LO field.
	GFXMMU_LUT907H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT907H_LO_Msk = 0x3ffff0

	// LUT908L: Graphic MMU LUT entry 908 low
	// Position of EN field.
	GFXMMU_LUT908L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT908L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT908L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT908L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT908L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT908L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT908L_LVB_Msk = 0xff0000

	// LUT908H: Graphic MMU LUT entry 908 high
	// Position of LO field.
	GFXMMU_LUT908H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT908H_LO_Msk = 0x3ffff0

	// LUT909L: Graphic MMU LUT entry 909 low
	// Position of EN field.
	GFXMMU_LUT909L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT909L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT909L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT909L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT909L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT909L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT909L_LVB_Msk = 0xff0000

	// LUT909H: Graphic MMU LUT entry 909 high
	// Position of LO field.
	GFXMMU_LUT909H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT909H_LO_Msk = 0x3ffff0

	// LUT910L: Graphic MMU LUT entry 910 low
	// Position of EN field.
	GFXMMU_LUT910L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT910L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT910L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT910L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT910L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT910L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT910L_LVB_Msk = 0xff0000

	// LUT910H: Graphic MMU LUT entry 910 high
	// Position of LO field.
	GFXMMU_LUT910H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT910H_LO_Msk = 0x3ffff0

	// LUT911L: Graphic MMU LUT entry 911 low
	// Position of EN field.
	GFXMMU_LUT911L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT911L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT911L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT911L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT911L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT911L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT911L_LVB_Msk = 0xff0000

	// LUT911H: Graphic MMU LUT entry 911 high
	// Position of LO field.
	GFXMMU_LUT911H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT911H_LO_Msk = 0x3ffff0

	// LUT912L: Graphic MMU LUT entry 912 low
	// Position of EN field.
	GFXMMU_LUT912L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT912L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT912L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT912L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT912L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT912L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT912L_LVB_Msk = 0xff0000

	// LUT912H: Graphic MMU LUT entry 912 high
	// Position of LO field.
	GFXMMU_LUT912H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT912H_LO_Msk = 0x3ffff0

	// LUT913L: Graphic MMU LUT entry 913 low
	// Position of EN field.
	GFXMMU_LUT913L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT913L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT913L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT913L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT913L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT913L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT913L_LVB_Msk = 0xff0000

	// LUT913H: Graphic MMU LUT entry 913 high
	// Position of LO field.
	GFXMMU_LUT913H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT913H_LO_Msk = 0x3ffff0

	// LUT914L: Graphic MMU LUT entry 914 low
	// Position of EN field.
	GFXMMU_LUT914L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT914L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT914L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT914L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT914L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT914L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT914L_LVB_Msk = 0xff0000

	// LUT914H: Graphic MMU LUT entry 914 high
	// Position of LO field.
	GFXMMU_LUT914H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT914H_LO_Msk = 0x3ffff0

	// LUT915L: Graphic MMU LUT entry 915 low
	// Position of EN field.
	GFXMMU_LUT915L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT915L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT915L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT915L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT915L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT915L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT915L_LVB_Msk = 0xff0000

	// LUT915H: Graphic MMU LUT entry 915 high
	// Position of LO field.
	GFXMMU_LUT915H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT915H_LO_Msk = 0x3ffff0

	// LUT916L: Graphic MMU LUT entry 916 low
	// Position of EN field.
	GFXMMU_LUT916L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT916L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT916L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT916L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT916L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT916L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT916L_LVB_Msk = 0xff0000

	// LUT916H: Graphic MMU LUT entry 916 high
	// Position of LO field.
	GFXMMU_LUT916H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT916H_LO_Msk = 0x3ffff0

	// LUT917L: Graphic MMU LUT entry 917 low
	// Position of EN field.
	GFXMMU_LUT917L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT917L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT917L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT917L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT917L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT917L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT917L_LVB_Msk = 0xff0000

	// LUT917H: Graphic MMU LUT entry 917 high
	// Position of LO field.
	GFXMMU_LUT917H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT917H_LO_Msk = 0x3ffff0

	// LUT918L: Graphic MMU LUT entry 918 low
	// Position of EN field.
	GFXMMU_LUT918L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT918L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT918L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT918L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT918L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT918L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT918L_LVB_Msk = 0xff0000

	// LUT918H: Graphic MMU LUT entry 918 high
	// Position of LO field.
	GFXMMU_LUT918H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT918H_LO_Msk = 0x3ffff0

	// LUT919L: Graphic MMU LUT entry 919 low
	// Position of EN field.
	GFXMMU_LUT919L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT919L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT919L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT919L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT919L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT919L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT919L_LVB_Msk = 0xff0000

	// LUT919H: Graphic MMU LUT entry 919 high
	// Position of LO field.
	GFXMMU_LUT919H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT919H_LO_Msk = 0x3ffff0

	// LUT920L: Graphic MMU LUT entry 920 low
	// Position of EN field.
	GFXMMU_LUT920L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT920L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT920L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT920L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT920L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT920L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT920L_LVB_Msk = 0xff0000

	// LUT920H: Graphic MMU LUT entry 920 high
	// Position of LO field.
	GFXMMU_LUT920H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT920H_LO_Msk = 0x3ffff0

	// LUT921L: Graphic MMU LUT entry 921 low
	// Position of EN field.
	GFXMMU_LUT921L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT921L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT921L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT921L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT921L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT921L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT921L_LVB_Msk = 0xff0000

	// LUT921H: Graphic MMU LUT entry 921 high
	// Position of LO field.
	GFXMMU_LUT921H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT921H_LO_Msk = 0x3ffff0

	// LUT922L: Graphic MMU LUT entry 922 low
	// Position of EN field.
	GFXMMU_LUT922L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT922L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT922L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT922L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT922L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT922L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT922L_LVB_Msk = 0xff0000

	// LUT922H: Graphic MMU LUT entry 922 high
	// Position of LO field.
	GFXMMU_LUT922H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT922H_LO_Msk = 0x3ffff0

	// LUT923L: Graphic MMU LUT entry 923 low
	// Position of EN field.
	GFXMMU_LUT923L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT923L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT923L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT923L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT923L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT923L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT923L_LVB_Msk = 0xff0000

	// LUT923H: Graphic MMU LUT entry 923 high
	// Position of LO field.
	GFXMMU_LUT923H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT923H_LO_Msk = 0x3ffff0

	// LUT924L: Graphic MMU LUT entry 924 low
	// Position of EN field.
	GFXMMU_LUT924L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT924L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT924L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT924L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT924L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT924L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT924L_LVB_Msk = 0xff0000

	// LUT924H: Graphic MMU LUT entry 924 high
	// Position of LO field.
	GFXMMU_LUT924H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT924H_LO_Msk = 0x3ffff0

	// LUT925L: Graphic MMU LUT entry 925 low
	// Position of EN field.
	GFXMMU_LUT925L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT925L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT925L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT925L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT925L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT925L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT925L_LVB_Msk = 0xff0000

	// LUT925H: Graphic MMU LUT entry 925 high
	// Position of LO field.
	GFXMMU_LUT925H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT925H_LO_Msk = 0x3ffff0

	// LUT926L: Graphic MMU LUT entry 926 low
	// Position of EN field.
	GFXMMU_LUT926L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT926L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT926L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT926L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT926L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT926L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT926L_LVB_Msk = 0xff0000

	// LUT926H: Graphic MMU LUT entry 926 high
	// Position of LO field.
	GFXMMU_LUT926H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT926H_LO_Msk = 0x3ffff0

	// LUT927L: Graphic MMU LUT entry 927 low
	// Position of EN field.
	GFXMMU_LUT927L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT927L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT927L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT927L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT927L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT927L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT927L_LVB_Msk = 0xff0000

	// LUT927H: Graphic MMU LUT entry 927 high
	// Position of LO field.
	GFXMMU_LUT927H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT927H_LO_Msk = 0x3ffff0

	// LUT928L: Graphic MMU LUT entry 928 low
	// Position of EN field.
	GFXMMU_LUT928L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT928L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT928L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT928L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT928L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT928L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT928L_LVB_Msk = 0xff0000

	// LUT928H: Graphic MMU LUT entry 928 high
	// Position of LO field.
	GFXMMU_LUT928H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT928H_LO_Msk = 0x3ffff0

	// LUT929L: Graphic MMU LUT entry 929 low
	// Position of EN field.
	GFXMMU_LUT929L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT929L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT929L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT929L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT929L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT929L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT929L_LVB_Msk = 0xff0000

	// LUT929H: Graphic MMU LUT entry 929 high
	// Position of LO field.
	GFXMMU_LUT929H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT929H_LO_Msk = 0x3ffff0

	// LUT930L: Graphic MMU LUT entry 930 low
	// Position of EN field.
	GFXMMU_LUT930L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT930L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT930L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT930L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT930L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT930L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT930L_LVB_Msk = 0xff0000

	// LUT930H: Graphic MMU LUT entry 930 high
	// Position of LO field.
	GFXMMU_LUT930H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT930H_LO_Msk = 0x3ffff0

	// LUT931L: Graphic MMU LUT entry 931 low
	// Position of EN field.
	GFXMMU_LUT931L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT931L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT931L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT931L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT931L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT931L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT931L_LVB_Msk = 0xff0000

	// LUT931H: Graphic MMU LUT entry 931 high
	// Position of LO field.
	GFXMMU_LUT931H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT931H_LO_Msk = 0x3ffff0

	// LUT932L: Graphic MMU LUT entry 932 low
	// Position of EN field.
	GFXMMU_LUT932L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT932L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT932L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT932L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT932L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT932L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT932L_LVB_Msk = 0xff0000

	// LUT932H: Graphic MMU LUT entry 932 high
	// Position of LO field.
	GFXMMU_LUT932H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT932H_LO_Msk = 0x3ffff0

	// LUT933L: Graphic MMU LUT entry 933 low
	// Position of EN field.
	GFXMMU_LUT933L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT933L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT933L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT933L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT933L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT933L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT933L_LVB_Msk = 0xff0000

	// LUT933H: Graphic MMU LUT entry 933 high
	// Position of LO field.
	GFXMMU_LUT933H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT933H_LO_Msk = 0x3ffff0

	// LUT934L: Graphic MMU LUT entry 934 low
	// Position of EN field.
	GFXMMU_LUT934L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT934L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT934L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT934L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT934L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT934L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT934L_LVB_Msk = 0xff0000

	// LUT934H: Graphic MMU LUT entry 934 high
	// Position of LO field.
	GFXMMU_LUT934H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT934H_LO_Msk = 0x3ffff0

	// LUT935L: Graphic MMU LUT entry 935 low
	// Position of EN field.
	GFXMMU_LUT935L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT935L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT935L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT935L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT935L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT935L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT935L_LVB_Msk = 0xff0000

	// LUT935H: Graphic MMU LUT entry 935 high
	// Position of LO field.
	GFXMMU_LUT935H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT935H_LO_Msk = 0x3ffff0

	// LUT936L: Graphic MMU LUT entry 936 low
	// Position of EN field.
	GFXMMU_LUT936L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT936L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT936L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT936L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT936L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT936L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT936L_LVB_Msk = 0xff0000

	// LUT936H: Graphic MMU LUT entry 936 high
	// Position of LO field.
	GFXMMU_LUT936H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT936H_LO_Msk = 0x3ffff0

	// LUT937L: Graphic MMU LUT entry 937 low
	// Position of EN field.
	GFXMMU_LUT937L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT937L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT937L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT937L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT937L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT937L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT937L_LVB_Msk = 0xff0000

	// LUT937H: Graphic MMU LUT entry 937 high
	// Position of LO field.
	GFXMMU_LUT937H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT937H_LO_Msk = 0x3ffff0

	// LUT938L: Graphic MMU LUT entry 938 low
	// Position of EN field.
	GFXMMU_LUT938L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT938L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT938L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT938L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT938L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT938L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT938L_LVB_Msk = 0xff0000

	// LUT938H: Graphic MMU LUT entry 938 high
	// Position of LO field.
	GFXMMU_LUT938H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT938H_LO_Msk = 0x3ffff0

	// LUT939L: Graphic MMU LUT entry 939 low
	// Position of EN field.
	GFXMMU_LUT939L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT939L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT939L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT939L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT939L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT939L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT939L_LVB_Msk = 0xff0000

	// LUT939H: Graphic MMU LUT entry 939 high
	// Position of LO field.
	GFXMMU_LUT939H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT939H_LO_Msk = 0x3ffff0

	// LUT940L: Graphic MMU LUT entry 940 low
	// Position of EN field.
	GFXMMU_LUT940L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT940L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT940L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT940L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT940L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT940L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT940L_LVB_Msk = 0xff0000

	// LUT940H: Graphic MMU LUT entry 940 high
	// Position of LO field.
	GFXMMU_LUT940H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT940H_LO_Msk = 0x3ffff0

	// LUT941L: Graphic MMU LUT entry 941 low
	// Position of EN field.
	GFXMMU_LUT941L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT941L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT941L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT941L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT941L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT941L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT941L_LVB_Msk = 0xff0000

	// LUT941H: Graphic MMU LUT entry 941 high
	// Position of LO field.
	GFXMMU_LUT941H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT941H_LO_Msk = 0x3ffff0

	// LUT942L: Graphic MMU LUT entry 942 low
	// Position of EN field.
	GFXMMU_LUT942L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT942L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT942L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT942L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT942L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT942L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT942L_LVB_Msk = 0xff0000

	// LUT942H: Graphic MMU LUT entry 942 high
	// Position of LO field.
	GFXMMU_LUT942H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT942H_LO_Msk = 0x3ffff0

	// LUT943L: Graphic MMU LUT entry 943 low
	// Position of EN field.
	GFXMMU_LUT943L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT943L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT943L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT943L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT943L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT943L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT943L_LVB_Msk = 0xff0000

	// LUT943H: Graphic MMU LUT entry 943 high
	// Position of LO field.
	GFXMMU_LUT943H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT943H_LO_Msk = 0x3ffff0

	// LUT944L: Graphic MMU LUT entry 944 low
	// Position of EN field.
	GFXMMU_LUT944L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT944L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT944L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT944L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT944L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT944L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT944L_LVB_Msk = 0xff0000

	// LUT944H: Graphic MMU LUT entry 944 high
	// Position of LO field.
	GFXMMU_LUT944H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT944H_LO_Msk = 0x3ffff0

	// LUT945L: Graphic MMU LUT entry 945 low
	// Position of EN field.
	GFXMMU_LUT945L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT945L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT945L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT945L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT945L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT945L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT945L_LVB_Msk = 0xff0000

	// LUT945H: Graphic MMU LUT entry 945 high
	// Position of LO field.
	GFXMMU_LUT945H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT945H_LO_Msk = 0x3ffff0

	// LUT946L: Graphic MMU LUT entry 946 low
	// Position of EN field.
	GFXMMU_LUT946L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT946L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT946L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT946L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT946L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT946L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT946L_LVB_Msk = 0xff0000

	// LUT946H: Graphic MMU LUT entry 946 high
	// Position of LO field.
	GFXMMU_LUT946H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT946H_LO_Msk = 0x3ffff0

	// LUT947L: Graphic MMU LUT entry 947 low
	// Position of EN field.
	GFXMMU_LUT947L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT947L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT947L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT947L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT947L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT947L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT947L_LVB_Msk = 0xff0000

	// LUT947H: Graphic MMU LUT entry 947 high
	// Position of LO field.
	GFXMMU_LUT947H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT947H_LO_Msk = 0x3ffff0

	// LUT948L: Graphic MMU LUT entry 948 low
	// Position of EN field.
	GFXMMU_LUT948L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT948L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT948L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT948L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT948L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT948L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT948L_LVB_Msk = 0xff0000

	// LUT948H: Graphic MMU LUT entry 948 high
	// Position of LO field.
	GFXMMU_LUT948H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT948H_LO_Msk = 0x3ffff0

	// LUT949L: Graphic MMU LUT entry 949 low
	// Position of EN field.
	GFXMMU_LUT949L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT949L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT949L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT949L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT949L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT949L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT949L_LVB_Msk = 0xff0000

	// LUT949H: Graphic MMU LUT entry 949 high
	// Position of LO field.
	GFXMMU_LUT949H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT949H_LO_Msk = 0x3ffff0

	// LUT950L: Graphic MMU LUT entry 950 low
	// Position of EN field.
	GFXMMU_LUT950L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT950L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT950L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT950L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT950L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT950L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT950L_LVB_Msk = 0xff0000

	// LUT950H: Graphic MMU LUT entry 950 high
	// Position of LO field.
	GFXMMU_LUT950H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT950H_LO_Msk = 0x3ffff0

	// LUT951L: Graphic MMU LUT entry 951 low
	// Position of EN field.
	GFXMMU_LUT951L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT951L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT951L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT951L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT951L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT951L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT951L_LVB_Msk = 0xff0000

	// LUT951H: Graphic MMU LUT entry 951 high
	// Position of LO field.
	GFXMMU_LUT951H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT951H_LO_Msk = 0x3ffff0

	// LUT952L: Graphic MMU LUT entry 952 low
	// Position of EN field.
	GFXMMU_LUT952L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT952L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT952L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT952L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT952L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT952L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT952L_LVB_Msk = 0xff0000

	// LUT952H: Graphic MMU LUT entry 952 high
	// Position of LO field.
	GFXMMU_LUT952H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT952H_LO_Msk = 0x3ffff0

	// LUT953L: Graphic MMU LUT entry 953 low
	// Position of EN field.
	GFXMMU_LUT953L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT953L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT953L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT953L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT953L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT953L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT953L_LVB_Msk = 0xff0000

	// LUT953H: Graphic MMU LUT entry 953 high
	// Position of LO field.
	GFXMMU_LUT953H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT953H_LO_Msk = 0x3ffff0

	// LUT954L: Graphic MMU LUT entry 954 low
	// Position of EN field.
	GFXMMU_LUT954L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT954L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT954L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT954L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT954L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT954L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT954L_LVB_Msk = 0xff0000

	// LUT954H: Graphic MMU LUT entry 954 high
	// Position of LO field.
	GFXMMU_LUT954H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT954H_LO_Msk = 0x3ffff0

	// LUT955L: Graphic MMU LUT entry 955 low
	// Position of EN field.
	GFXMMU_LUT955L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT955L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT955L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT955L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT955L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT955L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT955L_LVB_Msk = 0xff0000

	// LUT955H: Graphic MMU LUT entry 955 high
	// Position of LO field.
	GFXMMU_LUT955H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT955H_LO_Msk = 0x3ffff0

	// LUT956L: Graphic MMU LUT entry 956 low
	// Position of EN field.
	GFXMMU_LUT956L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT956L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT956L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT956L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT956L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT956L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT956L_LVB_Msk = 0xff0000

	// LUT956H: Graphic MMU LUT entry 956 high
	// Position of LO field.
	GFXMMU_LUT956H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT956H_LO_Msk = 0x3ffff0

	// LUT957L: Graphic MMU LUT entry 957 low
	// Position of EN field.
	GFXMMU_LUT957L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT957L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT957L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT957L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT957L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT957L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT957L_LVB_Msk = 0xff0000

	// LUT957H: Graphic MMU LUT entry 957 high
	// Position of LO field.
	GFXMMU_LUT957H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT957H_LO_Msk = 0x3ffff0

	// LUT958L: Graphic MMU LUT entry 958 low
	// Position of EN field.
	GFXMMU_LUT958L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT958L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT958L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT958L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT958L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT958L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT958L_LVB_Msk = 0xff0000

	// LUT958H: Graphic MMU LUT entry 958 high
	// Position of LO field.
	GFXMMU_LUT958H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT958H_LO_Msk = 0x3ffff0

	// LUT959L: Graphic MMU LUT entry 959 low
	// Position of EN field.
	GFXMMU_LUT959L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT959L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT959L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT959L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT959L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT959L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT959L_LVB_Msk = 0xff0000

	// LUT959H: Graphic MMU LUT entry 959 high
	// Position of LO field.
	GFXMMU_LUT959H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT959H_LO_Msk = 0x3ffff0

	// LUT960L: Graphic MMU LUT entry 960 low
	// Position of EN field.
	GFXMMU_LUT960L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT960L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT960L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT960L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT960L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT960L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT960L_LVB_Msk = 0xff0000

	// LUT960H: Graphic MMU LUT entry 960 high
	// Position of LO field.
	GFXMMU_LUT960H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT960H_LO_Msk = 0x3ffff0

	// LUT961L: Graphic MMU LUT entry 961 low
	// Position of EN field.
	GFXMMU_LUT961L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT961L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT961L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT961L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT961L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT961L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT961L_LVB_Msk = 0xff0000

	// LUT961H: Graphic MMU LUT entry 961 high
	// Position of LO field.
	GFXMMU_LUT961H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT961H_LO_Msk = 0x3ffff0

	// LUT962L: Graphic MMU LUT entry 962 low
	// Position of EN field.
	GFXMMU_LUT962L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT962L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT962L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT962L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT962L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT962L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT962L_LVB_Msk = 0xff0000

	// LUT962H: Graphic MMU LUT entry 962 high
	// Position of LO field.
	GFXMMU_LUT962H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT962H_LO_Msk = 0x3ffff0

	// LUT963L: Graphic MMU LUT entry 963 low
	// Position of EN field.
	GFXMMU_LUT963L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT963L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT963L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT963L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT963L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT963L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT963L_LVB_Msk = 0xff0000

	// LUT963H: Graphic MMU LUT entry 963 high
	// Position of LO field.
	GFXMMU_LUT963H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT963H_LO_Msk = 0x3ffff0

	// LUT964L: Graphic MMU LUT entry 964 low
	// Position of EN field.
	GFXMMU_LUT964L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT964L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT964L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT964L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT964L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT964L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT964L_LVB_Msk = 0xff0000

	// LUT964H: Graphic MMU LUT entry 964 high
	// Position of LO field.
	GFXMMU_LUT964H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT964H_LO_Msk = 0x3ffff0

	// LUT965L: Graphic MMU LUT entry 965 low
	// Position of EN field.
	GFXMMU_LUT965L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT965L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT965L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT965L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT965L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT965L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT965L_LVB_Msk = 0xff0000

	// LUT965H: Graphic MMU LUT entry 965 high
	// Position of LO field.
	GFXMMU_LUT965H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT965H_LO_Msk = 0x3ffff0

	// LUT966L: Graphic MMU LUT entry 966 low
	// Position of EN field.
	GFXMMU_LUT966L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT966L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT966L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT966L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT966L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT966L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT966L_LVB_Msk = 0xff0000

	// LUT966H: Graphic MMU LUT entry 966 high
	// Position of LO field.
	GFXMMU_LUT966H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT966H_LO_Msk = 0x3ffff0

	// LUT967L: Graphic MMU LUT entry 967 low
	// Position of EN field.
	GFXMMU_LUT967L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT967L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT967L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT967L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT967L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT967L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT967L_LVB_Msk = 0xff0000

	// LUT967H: Graphic MMU LUT entry 967 high
	// Position of LO field.
	GFXMMU_LUT967H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT967H_LO_Msk = 0x3ffff0

	// LUT968L: Graphic MMU LUT entry 968 low
	// Position of EN field.
	GFXMMU_LUT968L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT968L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT968L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT968L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT968L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT968L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT968L_LVB_Msk = 0xff0000

	// LUT968H: Graphic MMU LUT entry 968 high
	// Position of LO field.
	GFXMMU_LUT968H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT968H_LO_Msk = 0x3ffff0

	// LUT969L: Graphic MMU LUT entry 969 low
	// Position of EN field.
	GFXMMU_LUT969L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT969L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT969L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT969L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT969L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT969L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT969L_LVB_Msk = 0xff0000

	// LUT969H: Graphic MMU LUT entry 969 high
	// Position of LO field.
	GFXMMU_LUT969H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT969H_LO_Msk = 0x3ffff0

	// LUT970L: Graphic MMU LUT entry 970 low
	// Position of EN field.
	GFXMMU_LUT970L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT970L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT970L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT970L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT970L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT970L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT970L_LVB_Msk = 0xff0000

	// LUT970H: Graphic MMU LUT entry 970 high
	// Position of LO field.
	GFXMMU_LUT970H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT970H_LO_Msk = 0x3ffff0

	// LUT971L: Graphic MMU LUT entry 971 low
	// Position of EN field.
	GFXMMU_LUT971L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT971L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT971L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT971L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT971L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT971L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT971L_LVB_Msk = 0xff0000

	// LUT971H: Graphic MMU LUT entry 971 high
	// Position of LO field.
	GFXMMU_LUT971H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT971H_LO_Msk = 0x3ffff0

	// LUT972L: Graphic MMU LUT entry 972 low
	// Position of EN field.
	GFXMMU_LUT972L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT972L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT972L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT972L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT972L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT972L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT972L_LVB_Msk = 0xff0000

	// LUT972H: Graphic MMU LUT entry 972 high
	// Position of LO field.
	GFXMMU_LUT972H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT972H_LO_Msk = 0x3ffff0

	// LUT973L: Graphic MMU LUT entry 973 low
	// Position of EN field.
	GFXMMU_LUT973L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT973L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT973L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT973L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT973L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT973L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT973L_LVB_Msk = 0xff0000

	// LUT973H: Graphic MMU LUT entry 973 high
	// Position of LO field.
	GFXMMU_LUT973H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT973H_LO_Msk = 0x3ffff0

	// LUT974L: Graphic MMU LUT entry 974 low
	// Position of EN field.
	GFXMMU_LUT974L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT974L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT974L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT974L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT974L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT974L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT974L_LVB_Msk = 0xff0000

	// LUT974H: Graphic MMU LUT entry 974 high
	// Position of LO field.
	GFXMMU_LUT974H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT974H_LO_Msk = 0x3ffff0

	// LUT975L: Graphic MMU LUT entry 975 low
	// Position of EN field.
	GFXMMU_LUT975L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT975L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT975L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT975L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT975L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT975L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT975L_LVB_Msk = 0xff0000

	// LUT975H: Graphic MMU LUT entry 975 high
	// Position of LO field.
	GFXMMU_LUT975H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT975H_LO_Msk = 0x3ffff0

	// LUT976L: Graphic MMU LUT entry 976 low
	// Position of EN field.
	GFXMMU_LUT976L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT976L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT976L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT976L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT976L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT976L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT976L_LVB_Msk = 0xff0000

	// LUT976H: Graphic MMU LUT entry 976 high
	// Position of LO field.
	GFXMMU_LUT976H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT976H_LO_Msk = 0x3ffff0

	// LUT977L: Graphic MMU LUT entry 977 low
	// Position of EN field.
	GFXMMU_LUT977L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT977L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT977L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT977L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT977L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT977L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT977L_LVB_Msk = 0xff0000

	// LUT977H: Graphic MMU LUT entry 977 high
	// Position of LO field.
	GFXMMU_LUT977H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT977H_LO_Msk = 0x3ffff0

	// LUT978L: Graphic MMU LUT entry 978 low
	// Position of EN field.
	GFXMMU_LUT978L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT978L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT978L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT978L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT978L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT978L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT978L_LVB_Msk = 0xff0000

	// LUT978H: Graphic MMU LUT entry 978 high
	// Position of LO field.
	GFXMMU_LUT978H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT978H_LO_Msk = 0x3ffff0

	// LUT979L: Graphic MMU LUT entry 979 low
	// Position of EN field.
	GFXMMU_LUT979L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT979L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT979L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT979L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT979L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT979L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT979L_LVB_Msk = 0xff0000

	// LUT979H: Graphic MMU LUT entry 979 high
	// Position of LO field.
	GFXMMU_LUT979H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT979H_LO_Msk = 0x3ffff0

	// LUT980L: Graphic MMU LUT entry 980 low
	// Position of EN field.
	GFXMMU_LUT980L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT980L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT980L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT980L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT980L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT980L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT980L_LVB_Msk = 0xff0000

	// LUT980H: Graphic MMU LUT entry 980 high
	// Position of LO field.
	GFXMMU_LUT980H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT980H_LO_Msk = 0x3ffff0

	// LUT981L: Graphic MMU LUT entry 981 low
	// Position of EN field.
	GFXMMU_LUT981L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT981L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT981L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT981L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT981L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT981L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT981L_LVB_Msk = 0xff0000

	// LUT981H: Graphic MMU LUT entry 981 high
	// Position of LO field.
	GFXMMU_LUT981H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT981H_LO_Msk = 0x3ffff0

	// LUT982L: Graphic MMU LUT entry 982 low
	// Position of EN field.
	GFXMMU_LUT982L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT982L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT982L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT982L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT982L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT982L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT982L_LVB_Msk = 0xff0000

	// LUT982H: Graphic MMU LUT entry 982 high
	// Position of LO field.
	GFXMMU_LUT982H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT982H_LO_Msk = 0x3ffff0

	// LUT983L: Graphic MMU LUT entry 983 low
	// Position of EN field.
	GFXMMU_LUT983L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT983L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT983L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT983L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT983L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT983L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT983L_LVB_Msk = 0xff0000

	// LUT983H: Graphic MMU LUT entry 983 high
	// Position of LO field.
	GFXMMU_LUT983H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT983H_LO_Msk = 0x3ffff0

	// LUT984L: Graphic MMU LUT entry 984 low
	// Position of EN field.
	GFXMMU_LUT984L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT984L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT984L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT984L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT984L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT984L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT984L_LVB_Msk = 0xff0000

	// LUT984H: Graphic MMU LUT entry 984 high
	// Position of LO field.
	GFXMMU_LUT984H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT984H_LO_Msk = 0x3ffff0

	// LUT985L: Graphic MMU LUT entry 985 low
	// Position of EN field.
	GFXMMU_LUT985L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT985L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT985L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT985L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT985L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT985L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT985L_LVB_Msk = 0xff0000

	// LUT985H: Graphic MMU LUT entry 985 high
	// Position of LO field.
	GFXMMU_LUT985H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT985H_LO_Msk = 0x3ffff0

	// LUT986L: Graphic MMU LUT entry 986 low
	// Position of EN field.
	GFXMMU_LUT986L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT986L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT986L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT986L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT986L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT986L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT986L_LVB_Msk = 0xff0000

	// LUT986H: Graphic MMU LUT entry 986 high
	// Position of LO field.
	GFXMMU_LUT986H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT986H_LO_Msk = 0x3ffff0

	// LUT987L: Graphic MMU LUT entry 987 low
	// Position of EN field.
	GFXMMU_LUT987L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT987L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT987L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT987L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT987L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT987L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT987L_LVB_Msk = 0xff0000

	// LUT987H: Graphic MMU LUT entry 987 high
	// Position of LO field.
	GFXMMU_LUT987H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT987H_LO_Msk = 0x3ffff0

	// LUT988L: Graphic MMU LUT entry 988 low
	// Position of EN field.
	GFXMMU_LUT988L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT988L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT988L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT988L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT988L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT988L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT988L_LVB_Msk = 0xff0000

	// LUT988H: Graphic MMU LUT entry 988 high
	// Position of LO field.
	GFXMMU_LUT988H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT988H_LO_Msk = 0x3ffff0

	// LUT989L: Graphic MMU LUT entry 989 low
	// Position of EN field.
	GFXMMU_LUT989L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT989L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT989L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT989L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT989L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT989L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT989L_LVB_Msk = 0xff0000

	// LUT989H: Graphic MMU LUT entry 989 high
	// Position of LO field.
	GFXMMU_LUT989H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT989H_LO_Msk = 0x3ffff0

	// LUT990L: Graphic MMU LUT entry 990 low
	// Position of EN field.
	GFXMMU_LUT990L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT990L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT990L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT990L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT990L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT990L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT990L_LVB_Msk = 0xff0000

	// LUT990H: Graphic MMU LUT entry 990 high
	// Position of LO field.
	GFXMMU_LUT990H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT990H_LO_Msk = 0x3ffff0

	// LUT991L: Graphic MMU LUT entry 991 low
	// Position of EN field.
	GFXMMU_LUT991L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT991L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT991L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT991L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT991L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT991L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT991L_LVB_Msk = 0xff0000

	// LUT991H: Graphic MMU LUT entry 991 high
	// Position of LO field.
	GFXMMU_LUT991H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT991H_LO_Msk = 0x3ffff0

	// LUT992L: Graphic MMU LUT entry 992 low
	// Position of EN field.
	GFXMMU_LUT992L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT992L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT992L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT992L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT992L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT992L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT992L_LVB_Msk = 0xff0000

	// LUT992H: Graphic MMU LUT entry 992 high
	// Position of LO field.
	GFXMMU_LUT992H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT992H_LO_Msk = 0x3ffff0

	// LUT993L: Graphic MMU LUT entry 993 low
	// Position of EN field.
	GFXMMU_LUT993L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT993L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT993L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT993L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT993L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT993L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT993L_LVB_Msk = 0xff0000

	// LUT993H: Graphic MMU LUT entry 993 high
	// Position of LO field.
	GFXMMU_LUT993H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT993H_LO_Msk = 0x3ffff0

	// LUT994L: Graphic MMU LUT entry 994 low
	// Position of EN field.
	GFXMMU_LUT994L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT994L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT994L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT994L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT994L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT994L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT994L_LVB_Msk = 0xff0000

	// LUT994H: Graphic MMU LUT entry 994 high
	// Position of LO field.
	GFXMMU_LUT994H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT994H_LO_Msk = 0x3ffff0

	// LUT995L: Graphic MMU LUT entry 995 low
	// Position of EN field.
	GFXMMU_LUT995L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT995L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT995L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT995L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT995L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT995L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT995L_LVB_Msk = 0xff0000

	// LUT995H: Graphic MMU LUT entry 995 high
	// Position of LO field.
	GFXMMU_LUT995H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT995H_LO_Msk = 0x3ffff0

	// LUT996L: Graphic MMU LUT entry 996 low
	// Position of EN field.
	GFXMMU_LUT996L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT996L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT996L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT996L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT996L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT996L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT996L_LVB_Msk = 0xff0000

	// LUT996H: Graphic MMU LUT entry 996 high
	// Position of LO field.
	GFXMMU_LUT996H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT996H_LO_Msk = 0x3ffff0

	// LUT997L: Graphic MMU LUT entry 997 low
	// Position of EN field.
	GFXMMU_LUT997L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT997L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT997L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT997L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT997L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT997L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT997L_LVB_Msk = 0xff0000

	// LUT997H: Graphic MMU LUT entry 997 high
	// Position of LO field.
	GFXMMU_LUT997H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT997H_LO_Msk = 0x3ffff0

	// LUT998L: Graphic MMU LUT entry 998 low
	// Position of EN field.
	GFXMMU_LUT998L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT998L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT998L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT998L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT998L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT998L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT998L_LVB_Msk = 0xff0000

	// LUT998H: Graphic MMU LUT entry 998 high
	// Position of LO field.
	GFXMMU_LUT998H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT998H_LO_Msk = 0x3ffff0

	// LUT999L: Graphic MMU LUT entry 999 low
	// Position of EN field.
	GFXMMU_LUT999L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT999L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT999L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT999L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT999L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT999L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT999L_LVB_Msk = 0xff0000

	// LUT999H: Graphic MMU LUT entry 999 high
	// Position of LO field.
	GFXMMU_LUT999H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT999H_LO_Msk = 0x3ffff0

	// LUT1000L: Graphic MMU LUT entry 1000 low
	// Position of EN field.
	GFXMMU_LUT1000L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1000L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1000L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1000L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1000L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1000L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1000L_LVB_Msk = 0xff0000

	// LUT1000H: Graphic MMU LUT entry 1000 high
	// Position of LO field.
	GFXMMU_LUT1000H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1000H_LO_Msk = 0x3ffff0

	// LUT1001L: Graphic MMU LUT entry 1001 low
	// Position of EN field.
	GFXMMU_LUT1001L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1001L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1001L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1001L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1001L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1001L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1001L_LVB_Msk = 0xff0000

	// LUT1001H: Graphic MMU LUT entry 1001 high
	// Position of LO field.
	GFXMMU_LUT1001H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1001H_LO_Msk = 0x3ffff0

	// LUT1002L: Graphic MMU LUT entry 1002 low
	// Position of EN field.
	GFXMMU_LUT1002L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1002L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1002L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1002L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1002L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1002L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1002L_LVB_Msk = 0xff0000

	// LUT1002H: Graphic MMU LUT entry 1002 high
	// Position of LO field.
	GFXMMU_LUT1002H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1002H_LO_Msk = 0x3ffff0

	// LUT1003L: Graphic MMU LUT entry 1003 low
	// Position of EN field.
	GFXMMU_LUT1003L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1003L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1003L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1003L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1003L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1003L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1003L_LVB_Msk = 0xff0000

	// LUT1003H: Graphic MMU LUT entry 1003 high
	// Position of LO field.
	GFXMMU_LUT1003H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1003H_LO_Msk = 0x3ffff0

	// LUT1004L: Graphic MMU LUT entry 1004 low
	// Position of EN field.
	GFXMMU_LUT1004L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1004L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1004L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1004L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1004L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1004L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1004L_LVB_Msk = 0xff0000

	// LUT1004H: Graphic MMU LUT entry 1004 high
	// Position of LO field.
	GFXMMU_LUT1004H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1004H_LO_Msk = 0x3ffff0

	// LUT1005L: Graphic MMU LUT entry 1005 low
	// Position of EN field.
	GFXMMU_LUT1005L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1005L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1005L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1005L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1005L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1005L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1005L_LVB_Msk = 0xff0000

	// LUT1005H: Graphic MMU LUT entry 1005 high
	// Position of LO field.
	GFXMMU_LUT1005H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1005H_LO_Msk = 0x3ffff0

	// LUT1006L: Graphic MMU LUT entry 1006 low
	// Position of EN field.
	GFXMMU_LUT1006L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1006L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1006L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1006L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1006L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1006L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1006L_LVB_Msk = 0xff0000

	// LUT1006H: Graphic MMU LUT entry 1006 high
	// Position of LO field.
	GFXMMU_LUT1006H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1006H_LO_Msk = 0x3ffff0

	// LUT1007L: Graphic MMU LUT entry 1007 low
	// Position of EN field.
	GFXMMU_LUT1007L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1007L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1007L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1007L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1007L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1007L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1007L_LVB_Msk = 0xff0000

	// LUT1007H: Graphic MMU LUT entry 1007 high
	// Position of LO field.
	GFXMMU_LUT1007H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1007H_LO_Msk = 0x3ffff0

	// LUT1008L: Graphic MMU LUT entry 1008 low
	// Position of EN field.
	GFXMMU_LUT1008L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1008L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1008L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1008L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1008L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1008L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1008L_LVB_Msk = 0xff0000

	// LUT1008H: Graphic MMU LUT entry 1008 high
	// Position of LO field.
	GFXMMU_LUT1008H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1008H_LO_Msk = 0x3ffff0

	// LUT1009L: Graphic MMU LUT entry 1009 low
	// Position of EN field.
	GFXMMU_LUT1009L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1009L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1009L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1009L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1009L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1009L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1009L_LVB_Msk = 0xff0000

	// LUT1009H: Graphic MMU LUT entry 1009 high
	// Position of LO field.
	GFXMMU_LUT1009H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1009H_LO_Msk = 0x3ffff0

	// LUT1010L: Graphic MMU LUT entry 1010 low
	// Position of EN field.
	GFXMMU_LUT1010L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1010L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1010L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1010L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1010L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1010L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1010L_LVB_Msk = 0xff0000

	// LUT1010H: Graphic MMU LUT entry 1010 high
	// Position of LO field.
	GFXMMU_LUT1010H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1010H_LO_Msk = 0x3ffff0

	// LUT1011L: Graphic MMU LUT entry 1011 low
	// Position of EN field.
	GFXMMU_LUT1011L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1011L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1011L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1011L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1011L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1011L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1011L_LVB_Msk = 0xff0000

	// LUT1011H: Graphic MMU LUT entry 1011 high
	// Position of LO field.
	GFXMMU_LUT1011H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1011H_LO_Msk = 0x3ffff0

	// LUT1012L: Graphic MMU LUT entry 1012 low
	// Position of EN field.
	GFXMMU_LUT1012L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1012L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1012L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1012L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1012L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1012L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1012L_LVB_Msk = 0xff0000

	// LUT1012H: Graphic MMU LUT entry 1012 high
	// Position of LO field.
	GFXMMU_LUT1012H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1012H_LO_Msk = 0x3ffff0

	// LUT1013L: Graphic MMU LUT entry 1013 low
	// Position of EN field.
	GFXMMU_LUT1013L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1013L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1013L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1013L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1013L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1013L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1013L_LVB_Msk = 0xff0000

	// LUT1013H: Graphic MMU LUT entry 1013 high
	// Position of LO field.
	GFXMMU_LUT1013H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1013H_LO_Msk = 0x3ffff0

	// LUT1014L: Graphic MMU LUT entry 1014 low
	// Position of EN field.
	GFXMMU_LUT1014L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1014L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1014L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1014L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1014L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1014L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1014L_LVB_Msk = 0xff0000

	// LUT1014H: Graphic MMU LUT entry 1014 high
	// Position of LO field.
	GFXMMU_LUT1014H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1014H_LO_Msk = 0x3ffff0

	// LUT1015L: Graphic MMU LUT entry 1015 low
	// Position of EN field.
	GFXMMU_LUT1015L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1015L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1015L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1015L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1015L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1015L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1015L_LVB_Msk = 0xff0000

	// LUT1015H: Graphic MMU LUT entry 1015 high
	// Position of LO field.
	GFXMMU_LUT1015H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1015H_LO_Msk = 0x3ffff0

	// LUT1016L: Graphic MMU LUT entry 1016 low
	// Position of EN field.
	GFXMMU_LUT1016L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1016L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1016L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1016L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1016L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1016L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1016L_LVB_Msk = 0xff0000

	// LUT1016H: Graphic MMU LUT entry 1016 high
	// Position of LO field.
	GFXMMU_LUT1016H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1016H_LO_Msk = 0x3ffff0

	// LUT1017L: Graphic MMU LUT entry 1017 low
	// Position of EN field.
	GFXMMU_LUT1017L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1017L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1017L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1017L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1017L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1017L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1017L_LVB_Msk = 0xff0000

	// LUT1017H: Graphic MMU LUT entry 1017 high
	// Position of LO field.
	GFXMMU_LUT1017H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1017H_LO_Msk = 0x3ffff0

	// LUT1018L: Graphic MMU LUT entry 1018 low
	// Position of EN field.
	GFXMMU_LUT1018L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1018L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1018L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1018L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1018L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1018L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1018L_LVB_Msk = 0xff0000

	// LUT1018H: Graphic MMU LUT entry 1018 high
	// Position of LO field.
	GFXMMU_LUT1018H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1018H_LO_Msk = 0x3ffff0

	// LUT1019L: Graphic MMU LUT entry 1019 low
	// Position of EN field.
	GFXMMU_LUT1019L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1019L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1019L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1019L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1019L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1019L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1019L_LVB_Msk = 0xff0000

	// LUT1019H: Graphic MMU LUT entry 1019 high
	// Position of LO field.
	GFXMMU_LUT1019H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1019H_LO_Msk = 0x3ffff0

	// LUT1020L: Graphic MMU LUT entry 1020 low
	// Position of EN field.
	GFXMMU_LUT1020L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1020L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1020L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1020L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1020L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1020L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1020L_LVB_Msk = 0xff0000

	// LUT1020H: Graphic MMU LUT entry 1020 high
	// Position of LO field.
	GFXMMU_LUT1020H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1020H_LO_Msk = 0x3ffff0

	// LUT1021L: Graphic MMU LUT entry 1021 low
	// Position of EN field.
	GFXMMU_LUT1021L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1021L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1021L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1021L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1021L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1021L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1021L_LVB_Msk = 0xff0000

	// LUT1021H: Graphic MMU LUT entry 1021 high
	// Position of LO field.
	GFXMMU_LUT1021H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1021H_LO_Msk = 0x3ffff0

	// LUT1022L: Graphic MMU LUT entry 1022 low
	// Position of EN field.
	GFXMMU_LUT1022L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1022L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1022L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1022L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1022L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1022L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1022L_LVB_Msk = 0xff0000

	// LUT1022H: Graphic MMU LUT entry 1022 high
	// Position of LO field.
	GFXMMU_LUT1022H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1022H_LO_Msk = 0x3ffff0

	// LUT1023L: Graphic MMU LUT entry 1023 low
	// Position of EN field.
	GFXMMU_LUT1023L_EN_Pos = 0x0
	// Bit mask of EN field.
	GFXMMU_LUT1023L_EN_Msk = 0x1
	// Bit EN.
	GFXMMU_LUT1023L_EN = 0x1
	// Position of FVB field.
	GFXMMU_LUT1023L_FVB_Pos = 0x8
	// Bit mask of FVB field.
	GFXMMU_LUT1023L_FVB_Msk = 0xff00
	// Position of LVB field.
	GFXMMU_LUT1023L_LVB_Pos = 0x10
	// Bit mask of LVB field.
	GFXMMU_LUT1023L_LVB_Msk = 0xff0000

	// LUT1023H: Graphic MMU LUT entry 1023 high
	// Position of LO field.
	GFXMMU_LUT1023H_LO_Pos = 0x4
	// Bit mask of LO field.
	GFXMMU_LUT1023H_LO_Msk = 0x3ffff0
)

// Constants for OCTOSPIM: OctoSPI IO Manager
const (
	// P1CR: OctoSPI IO Manager Port 1 Configuration Register
	// Position of CLKEN field.
	OCTOSPIM_P1CR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	OCTOSPIM_P1CR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	OCTOSPIM_P1CR_CLKEN = 0x1
	// Position of CLKSRC field.
	OCTOSPIM_P1CR_CLKSRC_Pos = 0x1
	// Bit mask of CLKSRC field.
	OCTOSPIM_P1CR_CLKSRC_Msk = 0x2
	// Bit CLKSRC.
	OCTOSPIM_P1CR_CLKSRC = 0x2
	// Position of DQSEN field.
	OCTOSPIM_P1CR_DQSEN_Pos = 0x4
	// Bit mask of DQSEN field.
	OCTOSPIM_P1CR_DQSEN_Msk = 0x10
	// Bit DQSEN.
	OCTOSPIM_P1CR_DQSEN = 0x10
	// Position of DQSSRC field.
	OCTOSPIM_P1CR_DQSSRC_Pos = 0x5
	// Bit mask of DQSSRC field.
	OCTOSPIM_P1CR_DQSSRC_Msk = 0x20
	// Bit DQSSRC.
	OCTOSPIM_P1CR_DQSSRC = 0x20
	// Position of NCSEN field.
	OCTOSPIM_P1CR_NCSEN_Pos = 0x8
	// Bit mask of NCSEN field.
	OCTOSPIM_P1CR_NCSEN_Msk = 0x100
	// Bit NCSEN.
	OCTOSPIM_P1CR_NCSEN = 0x100
	// Position of NCSSRC field.
	OCTOSPIM_P1CR_NCSSRC_Pos = 0x9
	// Bit mask of NCSSRC field.
	OCTOSPIM_P1CR_NCSSRC_Msk = 0x200
	// Bit NCSSRC.
	OCTOSPIM_P1CR_NCSSRC = 0x200
	// Position of IOLEN field.
	OCTOSPIM_P1CR_IOLEN_Pos = 0x10
	// Bit mask of IOLEN field.
	OCTOSPIM_P1CR_IOLEN_Msk = 0x10000
	// Bit IOLEN.
	OCTOSPIM_P1CR_IOLEN = 0x10000
	// Position of IOLSRC field.
	OCTOSPIM_P1CR_IOLSRC_Pos = 0x11
	// Bit mask of IOLSRC field.
	OCTOSPIM_P1CR_IOLSRC_Msk = 0x60000
	// Position of IOHEN field.
	OCTOSPIM_P1CR_IOHEN_Pos = 0x18
	// Bit mask of IOHEN field.
	OCTOSPIM_P1CR_IOHEN_Msk = 0x1000000
	// Bit IOHEN.
	OCTOSPIM_P1CR_IOHEN = 0x1000000
	// Position of IOHSRC field.
	OCTOSPIM_P1CR_IOHSRC_Pos = 0x19
	// Bit mask of IOHSRC field.
	OCTOSPIM_P1CR_IOHSRC_Msk = 0x6000000

	// P2CR: OctoSPI IO Manager Port 2 Configuration Register
	// Position of CLKEN field.
	OCTOSPIM_P2CR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	OCTOSPIM_P2CR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	OCTOSPIM_P2CR_CLKEN = 0x1
	// Position of CLKSRC field.
	OCTOSPIM_P2CR_CLKSRC_Pos = 0x1
	// Bit mask of CLKSRC field.
	OCTOSPIM_P2CR_CLKSRC_Msk = 0x2
	// Bit CLKSRC.
	OCTOSPIM_P2CR_CLKSRC = 0x2
	// Position of DQSEN field.
	OCTOSPIM_P2CR_DQSEN_Pos = 0x4
	// Bit mask of DQSEN field.
	OCTOSPIM_P2CR_DQSEN_Msk = 0x10
	// Bit DQSEN.
	OCTOSPIM_P2CR_DQSEN = 0x10
	// Position of DQSSRC field.
	OCTOSPIM_P2CR_DQSSRC_Pos = 0x5
	// Bit mask of DQSSRC field.
	OCTOSPIM_P2CR_DQSSRC_Msk = 0x20
	// Bit DQSSRC.
	OCTOSPIM_P2CR_DQSSRC = 0x20
	// Position of NCSEN field.
	OCTOSPIM_P2CR_NCSEN_Pos = 0x8
	// Bit mask of NCSEN field.
	OCTOSPIM_P2CR_NCSEN_Msk = 0x100
	// Bit NCSEN.
	OCTOSPIM_P2CR_NCSEN = 0x100
	// Position of NCSSRC field.
	OCTOSPIM_P2CR_NCSSRC_Pos = 0x9
	// Bit mask of NCSSRC field.
	OCTOSPIM_P2CR_NCSSRC_Msk = 0x200
	// Bit NCSSRC.
	OCTOSPIM_P2CR_NCSSRC = 0x200
	// Position of IOLEN field.
	OCTOSPIM_P2CR_IOLEN_Pos = 0x10
	// Bit mask of IOLEN field.
	OCTOSPIM_P2CR_IOLEN_Msk = 0x10000
	// Bit IOLEN.
	OCTOSPIM_P2CR_IOLEN = 0x10000
	// Position of IOLSRC field.
	OCTOSPIM_P2CR_IOLSRC_Pos = 0x11
	// Bit mask of IOLSRC field.
	OCTOSPIM_P2CR_IOLSRC_Msk = 0x60000
	// Position of IOHEN field.
	OCTOSPIM_P2CR_IOHEN_Pos = 0x18
	// Bit mask of IOHEN field.
	OCTOSPIM_P2CR_IOHEN_Msk = 0x1000000
	// Bit IOHEN.
	OCTOSPIM_P2CR_IOHEN = 0x1000000
	// Position of IOHSRC field.
	OCTOSPIM_P2CR_IOHSRC_Pos = 0x19
	// Bit mask of IOHSRC field.
	OCTOSPIM_P2CR_IOHSRC_Msk = 0x6000000
)

// Constants for FPU: Floting point unit
const (
	// FPCCR: Floating-point context control register
	// Position of LSPACT field.
	FPU_FPCCR_LSPACT_Pos = 0x0
	// Bit mask of LSPACT field.
	FPU_FPCCR_LSPACT_Msk = 0x1
	// Bit LSPACT.
	FPU_FPCCR_LSPACT = 0x1
	// Position of USER field.
	FPU_FPCCR_USER_Pos = 0x1
	// Bit mask of USER field.
	FPU_FPCCR_USER_Msk = 0x2
	// Bit USER.
	FPU_FPCCR_USER = 0x2
	// Position of THREAD field.
	FPU_FPCCR_THREAD_Pos = 0x3
	// Bit mask of THREAD field.
	FPU_FPCCR_THREAD_Msk = 0x8
	// Bit THREAD.
	FPU_FPCCR_THREAD = 0x8
	// Position of HFRDY field.
	FPU_FPCCR_HFRDY_Pos = 0x4
	// Bit mask of HFRDY field.
	FPU_FPCCR_HFRDY_Msk = 0x10
	// Bit HFRDY.
	FPU_FPCCR_HFRDY = 0x10
	// Position of MMRDY field.
	FPU_FPCCR_MMRDY_Pos = 0x5
	// Bit mask of MMRDY field.
	FPU_FPCCR_MMRDY_Msk = 0x20
	// Bit MMRDY.
	FPU_FPCCR_MMRDY = 0x20
	// Position of BFRDY field.
	FPU_FPCCR_BFRDY_Pos = 0x6
	// Bit mask of BFRDY field.
	FPU_FPCCR_BFRDY_Msk = 0x40
	// Bit BFRDY.
	FPU_FPCCR_BFRDY = 0x40
	// Position of MONRDY field.
	FPU_FPCCR_MONRDY_Pos = 0x8
	// Bit mask of MONRDY field.
	FPU_FPCCR_MONRDY_Msk = 0x100
	// Bit MONRDY.
	FPU_FPCCR_MONRDY = 0x100
	// Position of LSPEN field.
	FPU_FPCCR_LSPEN_Pos = 0x1e
	// Bit mask of LSPEN field.
	FPU_FPCCR_LSPEN_Msk = 0x40000000
	// Bit LSPEN.
	FPU_FPCCR_LSPEN = 0x40000000
	// Position of ASPEN field.
	FPU_FPCCR_ASPEN_Pos = 0x1f
	// Bit mask of ASPEN field.
	FPU_FPCCR_ASPEN_Msk = 0x80000000
	// Bit ASPEN.
	FPU_FPCCR_ASPEN = 0x80000000

	// FPCAR: Floating-point context address register
	// Position of ADDRESS field.
	FPU_FPCAR_ADDRESS_Pos = 0x3
	// Bit mask of ADDRESS field.
	FPU_FPCAR_ADDRESS_Msk = 0xfffffff8

	// FPSCR: Floating-point status control register
	// Position of IOC field.
	FPU_FPSCR_IOC_Pos = 0x0
	// Bit mask of IOC field.
	FPU_FPSCR_IOC_Msk = 0x1
	// Bit IOC.
	FPU_FPSCR_IOC = 0x1
	// Position of DZC field.
	FPU_FPSCR_DZC_Pos = 0x1
	// Bit mask of DZC field.
	FPU_FPSCR_DZC_Msk = 0x2
	// Bit DZC.
	FPU_FPSCR_DZC = 0x2
	// Position of OFC field.
	FPU_FPSCR_OFC_Pos = 0x2
	// Bit mask of OFC field.
	FPU_FPSCR_OFC_Msk = 0x4
	// Bit OFC.
	FPU_FPSCR_OFC = 0x4
	// Position of UFC field.
	FPU_FPSCR_UFC_Pos = 0x3
	// Bit mask of UFC field.
	FPU_FPSCR_UFC_Msk = 0x8
	// Bit UFC.
	FPU_FPSCR_UFC = 0x8
	// Position of IXC field.
	FPU_FPSCR_IXC_Pos = 0x4
	// Bit mask of IXC field.
	FPU_FPSCR_IXC_Msk = 0x10
	// Bit IXC.
	FPU_FPSCR_IXC = 0x10
	// Position of IDC field.
	FPU_FPSCR_IDC_Pos = 0x7
	// Bit mask of IDC field.
	FPU_FPSCR_IDC_Msk = 0x80
	// Bit IDC.
	FPU_FPSCR_IDC = 0x80
	// Position of RMode field.
	FPU_FPSCR_RMode_Pos = 0x16
	// Bit mask of RMode field.
	FPU_FPSCR_RMode_Msk = 0xc00000
	// Position of FZ field.
	FPU_FPSCR_FZ_Pos = 0x18
	// Bit mask of FZ field.
	FPU_FPSCR_FZ_Msk = 0x1000000
	// Bit FZ.
	FPU_FPSCR_FZ = 0x1000000
	// Position of DN field.
	FPU_FPSCR_DN_Pos = 0x19
	// Bit mask of DN field.
	FPU_FPSCR_DN_Msk = 0x2000000
	// Bit DN.
	FPU_FPSCR_DN = 0x2000000
	// Position of AHP field.
	FPU_FPSCR_AHP_Pos = 0x1a
	// Bit mask of AHP field.
	FPU_FPSCR_AHP_Msk = 0x4000000
	// Bit AHP.
	FPU_FPSCR_AHP = 0x4000000
	// Position of V field.
	FPU_FPSCR_V_Pos = 0x1c
	// Bit mask of V field.
	FPU_FPSCR_V_Msk = 0x10000000
	// Bit V.
	FPU_FPSCR_V = 0x10000000
	// Position of C field.
	FPU_FPSCR_C_Pos = 0x1d
	// Bit mask of C field.
	FPU_FPSCR_C_Msk = 0x20000000
	// Bit C.
	FPU_FPSCR_C = 0x20000000
	// Position of Z field.
	FPU_FPSCR_Z_Pos = 0x1e
	// Bit mask of Z field.
	FPU_FPSCR_Z_Msk = 0x40000000
	// Bit Z.
	FPU_FPSCR_Z = 0x40000000
	// Position of N field.
	FPU_FPSCR_N_Pos = 0x1f
	// Bit mask of N field.
	FPU_FPSCR_N_Msk = 0x80000000
	// Bit N.
	FPU_FPSCR_N = 0x80000000
)

// Constants for MPU: Memory protection unit
const (
	// TYPER: MPU type register
	// Position of SEPARATE field.
	MPU_TYPER_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPER_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPER_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPER_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPER_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPER_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPER_IREGION_Msk = 0xff0000

	// CTRL: MPU control register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU region number register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU region base address register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU region attribute and size register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x3e
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000
)

// Constants for STK: SysTick timer
const (
	// CTRL: SysTick control and status register
	// Position of ENABLE field.
	STK_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	STK_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	STK_CTRL_ENABLE = 0x1
	// Position of TICKINT field.
	STK_CTRL_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	STK_CTRL_TICKINT_Msk = 0x2
	// Bit TICKINT.
	STK_CTRL_TICKINT = 0x2
	// Position of CLKSOURCE field.
	STK_CTRL_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	STK_CTRL_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	STK_CTRL_CLKSOURCE = 0x4
	// Position of COUNTFLAG field.
	STK_CTRL_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	STK_CTRL_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	STK_CTRL_COUNTFLAG = 0x10000

	// LOAD: SysTick reload value register
	// Position of RELOAD field.
	STK_LOAD_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	STK_LOAD_RELOAD_Msk = 0xffffff

	// VAL: SysTick current value register
	// Position of CURRENT field.
	STK_VAL_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	STK_VAL_CURRENT_Msk = 0xffffff

	// CALIB: SysTick calibration value register
	// Position of TENMS field.
	STK_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	STK_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	STK_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	STK_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	STK_CALIB_SKEW = 0x40000000
	// Position of NOREF field.
	STK_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	STK_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	STK_CALIB_NOREF = 0x80000000
)

// Constants for SCB: System control block
const (
	// CPUID: CPUID base register
	// Position of Revision field.
	SCB_CPUID_Revision_Pos = 0x0
	// Bit mask of Revision field.
	SCB_CPUID_Revision_Msk = 0xf
	// Position of PartNo field.
	SCB_CPUID_PartNo_Pos = 0x4
	// Bit mask of PartNo field.
	SCB_CPUID_PartNo_Msk = 0xfff0
	// Position of Constant field.
	SCB_CPUID_Constant_Pos = 0x10
	// Bit mask of Constant field.
	SCB_CPUID_Constant_Msk = 0xf0000
	// Position of Variant field.
	SCB_CPUID_Variant_Pos = 0x14
	// Bit mask of Variant field.
	SCB_CPUID_Variant_Msk = 0xf00000
	// Position of Implementer field.
	SCB_CPUID_Implementer_Pos = 0x18
	// Bit mask of Implementer field.
	SCB_CPUID_Implementer_Msk = 0xff000000

	// ICSR: Interrupt control and state register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x7f000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000

	// VTOR: Vector table offset register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x9
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0x3ffffe00

	// AIRCR: Application interrupt and reset control register
	// Position of VECTRESET field.
	SCB_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SCB_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SCB_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// Position of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Pos = 0xf
	// Bit mask of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Msk = 0x8000
	// Bit ENDIANESS.
	SCB_AIRCR_ENDIANESS = 0x8000
	// Position of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Pos = 0x10
	// Bit mask of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Msk = 0xffff0000

	// SCR: System control register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// Position of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Pos = 0x4
	// Bit mask of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Msk = 0x10
	// Bit SEVEONPEND.
	SCB_SCR_SEVEONPEND = 0x10

	// CCR: Configuration and control register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// Position of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Pos = 0x3
	// Bit mask of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Msk = 0x8
	// Bit UNALIGN__TRP.
	SCB_CCR_UNALIGN__TRP = 0x8
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200

	// SHPR1: System handler priority registers
	// Position of PRI_4 field.
	SCB_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SCB_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SCB_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SCB_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SCB_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SCB_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System handler priority registers
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System handler priority registers
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System handler control and state register
	// Position of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SCB_SHCSR_MEMFAULTACT = 0x1
	// Position of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SCB_SHCSR_BUSFAULTACT = 0x2
	// Position of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SCB_SHCSR_USGFAULTACT = 0x8
	// Position of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SCB_SHCSR_SVCALLACT = 0x80
	// Position of MONITORACT field.
	SCB_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SCB_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SCB_SHCSR_MONITORACT = 0x100
	// Position of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SCB_SHCSR_PENDSVACT = 0x400
	// Position of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SCB_SHCSR_SYSTICKACT = 0x800
	// Position of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SCB_SHCSR_USGFAULTPENDED = 0x1000
	// Position of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SCB_SHCSR_MEMFAULTPENDED = 0x2000
	// Position of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SCB_SHCSR_BUSFAULTPENDED = 0x4000
	// Position of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SCB_SHCSR_SVCALLPENDED = 0x8000
	// Position of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SCB_SHCSR_MEMFAULTENA = 0x10000
	// Position of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SCB_SHCSR_BUSFAULTENA = 0x20000
	// Position of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SCB_SHCSR_USGFAULTENA = 0x40000

	// CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
	// Position of IACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_Pos = 0x1
	// Bit mask of IACCVIOL field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_Msk = 0x2
	// Bit IACCVIOL.
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 0x2
	// Position of MUNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 0x8
	// Position of MSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 0x10
	// Position of MLSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 0x20
	// Position of MMARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 0x80
	// Position of IBUSERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 0x100
	// Position of PRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 0x200
	// Position of IMPRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 0x400
	// Position of UNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 0x800
	// Position of STKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 0x1000
	// Position of LSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 0x2000
	// Position of BFARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 0x8000
	// Position of UNDEFINSTR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 0x10000
	// Position of INVSTATE field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 0x20000
	// Position of INVPC field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 0x40000
	// Position of NOCP field.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 0x80000
	// Position of UNALIGNED field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 0x1000000
	// Position of DIVBYZERO field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 0x2000000

	// HFSR: Hard fault status register
	// Position of VECTTBL field.
	SCB_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SCB_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SCB_HFSR_VECTTBL = 0x2
	// Position of FORCED field.
	SCB_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SCB_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SCB_HFSR_FORCED = 0x40000000
	// Position of DEBUG_VT field.
	SCB_HFSR_DEBUG_VT_Pos = 0x1f
	// Bit mask of DEBUG_VT field.
	SCB_HFSR_DEBUG_VT_Msk = 0x80000000
	// Bit DEBUG_VT.
	SCB_HFSR_DEBUG_VT = 0x80000000

	// MMFAR: Memory management fault address register
	// Position of MMFAR field.
	SCB_MMFAR_MMFAR_Pos = 0x0
	// Bit mask of MMFAR field.
	SCB_MMFAR_MMFAR_Msk = 0xffffffff

	// BFAR: Bus fault address register
	// Position of BFAR field.
	SCB_BFAR_BFAR_Pos = 0x0
	// Bit mask of BFAR field.
	SCB_BFAR_BFAR_Msk = 0xffffffff

	// AFSR: Auxiliary fault status register
	// Position of IMPDEF field.
	SCB_AFSR_IMPDEF_Pos = 0x0
	// Bit mask of IMPDEF field.
	SCB_AFSR_IMPDEF_Msk = 0xffffffff
)
