// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from stm32g071.svd, see https://github.com/tinygo-org/stm32-svd

//go:build stm32 && stm32g071

/*
// STM32G071
*/

package stm32

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "STM32G071"
	CPU          = "CM0"
	FPUPresent   = false
	NVICPrioBits = 2
)

// Interrupt numbers.
const (
	// System window watchdog
	IRQ_WWDG = 0

	// Power control
	IRQ_PVD = 1

	// Real-time clock
	IRQ_RTC_STAMP = 2

	// Flash
	IRQ_FLASH = 3

	// Reset and clock control
	IRQ_RCC = 4

	// External interrupt/event controller
	IRQ_EXTI0_1 = 5

	// External interrupt/event controller
	IRQ_EXTI2_3 = 6

	// External interrupt/event controller
	IRQ_EXTI4_15 = 7

	// USB Power Delivery interface
	IRQ_UCPD1_UCPD2 = 8

	// DMA controller
	IRQ_DMA_Channel1 = 9

	// DMA controller
	IRQ_DMA_Channel2_3 = 10

	// DMAMUX
	IRQ_DMA_Channel4_5_6_7 = 11

	// Analog to Digital Converter instance 1
	IRQ_ADC_COMP = 12

	// Advanced-timers
	IRQ_TIM1_BRK_UP_TRG_COM = 13

	// Advanced-timers
	IRQ_TIM1_CC = 14

	// General-purpose-timers
	IRQ_TIM2 = 15

	// General-purpose-timers
	IRQ_TIM3 = 16

	// Basic timers
	IRQ_TIM6_DAC_LPTIM1 = 17

	IRQ_TIM7_LPTIM2 = 18

	// General purpose timers
	IRQ_TIM14 = 19

	// General purpose timers
	IRQ_TIM15 = 20

	// General purpose timers
	IRQ_TIM16 = 21

	IRQ_TIM17 = 22

	// Inter-integrated circuit
	IRQ_I2C1 = 23

	IRQ_I2C2 = 24

	// Serial peripheral interface/Inter-IC sound
	IRQ_SPI1 = 25

	IRQ_SPI2 = 26

	// Universal synchronous asynchronous receiver transmitter
	IRQ_USART1 = 27

	IRQ_USART2 = 28

	IRQ_USART3_USART4_LPUART1 = 29

	// Cyclic redundancy check calculation unit
	IRQ_CEC = 30

	// Highest interrupt number on this device.
	IRQ_max = 30
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export WWDG_IRQHandler
func interruptWWDG() {
	callHandlers(IRQ_WWDG)
}

//export PVD_IRQHandler
func interruptPVD() {
	callHandlers(IRQ_PVD)
}

//export RTC_STAMP_IRQHandler
func interruptRTC_STAMP() {
	callHandlers(IRQ_RTC_STAMP)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export RCC_IRQHandler
func interruptRCC() {
	callHandlers(IRQ_RCC)
}

//export EXTI0_1_IRQHandler
func interruptEXTI0_1() {
	callHandlers(IRQ_EXTI0_1)
}

//export EXTI2_3_IRQHandler
func interruptEXTI2_3() {
	callHandlers(IRQ_EXTI2_3)
}

//export EXTI4_15_IRQHandler
func interruptEXTI4_15() {
	callHandlers(IRQ_EXTI4_15)
}

//export UCPD1_UCPD2_IRQHandler
func interruptUCPD1_UCPD2() {
	callHandlers(IRQ_UCPD1_UCPD2)
}

//export DMA_Channel1_IRQHandler
func interruptDMA_Channel1() {
	callHandlers(IRQ_DMA_Channel1)
}

//export DMA_Channel2_3_IRQHandler
func interruptDMA_Channel2_3() {
	callHandlers(IRQ_DMA_Channel2_3)
}

//export DMA_Channel4_5_6_7_IRQHandler
func interruptDMA_Channel4_5_6_7() {
	callHandlers(IRQ_DMA_Channel4_5_6_7)
}

//export ADC_COMP_IRQHandler
func interruptADC_COMP() {
	callHandlers(IRQ_ADC_COMP)
}

//export TIM1_BRK_UP_TRG_COM_IRQHandler
func interruptTIM1_BRK_UP_TRG_COM() {
	callHandlers(IRQ_TIM1_BRK_UP_TRG_COM)
}

//export TIM1_CC_IRQHandler
func interruptTIM1_CC() {
	callHandlers(IRQ_TIM1_CC)
}

//export TIM2_IRQHandler
func interruptTIM2() {
	callHandlers(IRQ_TIM2)
}

//export TIM3_IRQHandler
func interruptTIM3() {
	callHandlers(IRQ_TIM3)
}

//export TIM6_DAC_LPTIM1_IRQHandler
func interruptTIM6_DAC_LPTIM1() {
	callHandlers(IRQ_TIM6_DAC_LPTIM1)
}

//export TIM7_LPTIM2_IRQHandler
func interruptTIM7_LPTIM2() {
	callHandlers(IRQ_TIM7_LPTIM2)
}

//export TIM14_IRQHandler
func interruptTIM14() {
	callHandlers(IRQ_TIM14)
}

//export TIM15_IRQHandler
func interruptTIM15() {
	callHandlers(IRQ_TIM15)
}

//export TIM16_IRQHandler
func interruptTIM16() {
	callHandlers(IRQ_TIM16)
}

//export TIM17_IRQHandler
func interruptTIM17() {
	callHandlers(IRQ_TIM17)
}

//export I2C1_IRQHandler
func interruptI2C1() {
	callHandlers(IRQ_I2C1)
}

//export I2C2_IRQHandler
func interruptI2C2() {
	callHandlers(IRQ_I2C2)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export SPI2_IRQHandler
func interruptSPI2() {
	callHandlers(IRQ_SPI2)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_USART4_LPUART1_IRQHandler
func interruptUSART3_USART4_LPUART1() {
	callHandlers(IRQ_USART3_USART4_LPUART1)
}

//export CEC_IRQHandler
func interruptCEC() {
	callHandlers(IRQ_CEC)
}

// Peripherals.
var (
	// Independent watchdog
	IWDG = (*IWDG_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// System window watchdog
	WWDG = (*WWDG_Type)(unsafe.Pointer(uintptr(0x40002c00)))

	// Flash
	FLASH = (*Flash_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// Debug support
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0x40015800)))

	// Reset and clock control
	RCC = (*RCC_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Power control
	PWR = (*PWR_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// DMA controller
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// DMAMUX
	DMAMUX = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x40020800)))

	// General-purpose I/Os
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// General-purpose I/Os
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000400)))

	// Cyclic redundancy check calculation unit
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// External interrupt/event controller
	EXTI = (*EXTI_Type)(unsafe.Pointer(uintptr(0x40021800)))

	// General purpose timers
	TIM16 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014400)))

	// General purpose timers
	TIM15 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Universal synchronous asynchronous receiver transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40013800)))

	// Serial peripheral interface/Inter-IC sound
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Advanced-timers
	TIM1 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40012c00)))

	// Analog to Digital Converter instance 1
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x40012400)))

	// COMP1
	COMP = (*COMP1_Type)(unsafe.Pointer(uintptr(0x40010200)))

	// System configuration controller
	SYSCFG_VREFBUF = (*SYSCFG_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Tamper and backup registers
	TAMP = (*TAMP_Type)(unsafe.Pointer(uintptr(0x4000b000)))

	// USB Power Delivery interface
	UCPD1 = (*UCPD_Type)(unsafe.Pointer(uintptr(0x4000a000)))

	// Low power timer
	LPTIM1 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40007c00)))

	// Universal synchronous asynchronous receiver transmitter
	LPUART = (*USART_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// HDMI-CEC
	HDMI_CEC = (*CEC_Type)(unsafe.Pointer(uintptr(0x40007800)))

	// DAC
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x40007400)))

	// Inter-integrated circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Real-time clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40002800)))

	// General purpose timers
	TIM14 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Basic timers
	TIM6 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// General-purpose-timers
	TIM2 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Memory protection unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// SysTick timer
	STK = (*STK_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// System control block
	SCB = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000ed00)))

	// General-purpose I/Os
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000800)))

	// General-purpose I/Os
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000c00)))

	// General-purpose I/Os
	GPIOF = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50001400)))

	// General purpose timers
	TIM17 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014800)))

	// Universal synchronous asynchronous receiver transmitter
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004400)))

	// Universal synchronous asynchronous receiver transmitter
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004800)))

	// Universal synchronous asynchronous receiver transmitter
	USART4 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004c00)))

	// Serial peripheral interface/Inter-IC sound
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// USB Power Delivery interface
	UCPD2 = (*UCPD_Type)(unsafe.Pointer(uintptr(0x4000a400)))

	// Low power timer
	LPTIM2 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40009400)))

	// Inter-integrated circuit
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005800)))

	// Basic timers
	TIM7 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001400)))

	// General-purpose-timers
	TIM3 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000400)))
)

// Independent watchdog
type IWDG_Type struct {
	KR     volatile.Register32 // 0x0
	PR     volatile.Register32 // 0x4
	RLR    volatile.Register32 // 0x8
	SR     volatile.Register32 // 0xC
	WINR   volatile.Register32 // 0x10
	_      [988]byte
	HWCFGR volatile.Register32 // 0x3F0
	VERR   volatile.Register32 // 0x3F4
	IPIDR  volatile.Register32 // 0x3F8
	SIDR   volatile.Register32 // 0x3FC
}

// IWDG.KR: Key register
func (o *IWDG_Type) SetKR_KEY(value uint32) {
	volatile.StoreUint32(&o.KR.Reg, volatile.LoadUint32(&o.KR.Reg)&^(0xffff)|value)
}
func (o *IWDG_Type) GetKR_KEY() uint32 {
	return volatile.LoadUint32(&o.KR.Reg) & 0xffff
}

// IWDG.PR: Prescaler register
func (o *IWDG_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x7)|value)
}
func (o *IWDG_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0x7
}

// IWDG.RLR: Reload register
func (o *IWDG_Type) SetRLR_RL(value uint32) {
	volatile.StoreUint32(&o.RLR.Reg, volatile.LoadUint32(&o.RLR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetRLR_RL() uint32 {
	return volatile.LoadUint32(&o.RLR.Reg) & 0xfff
}

// IWDG.SR: Status register
func (o *IWDG_Type) SetSR_WVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *IWDG_Type) GetSR_WVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *IWDG_Type) SetSR_RVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *IWDG_Type) GetSR_RVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *IWDG_Type) SetSR_PVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *IWDG_Type) GetSR_PVU() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// IWDG.WINR: Window register
func (o *IWDG_Type) SetWINR_WIN(value uint32) {
	volatile.StoreUint32(&o.WINR.Reg, volatile.LoadUint32(&o.WINR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetWINR_WIN() uint32 {
	return volatile.LoadUint32(&o.WINR.Reg) & 0xfff
}

// IWDG.HWCFGR: hardware configuration register
func (o *IWDG_Type) SetHWCFGR_WINDOW(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf)|value)
}
func (o *IWDG_Type) GetHWCFGR_WINDOW() uint32 {
	return volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf
}
func (o *IWDG_Type) SetHWCFGR_PR_DEFAULT(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf0)|value<<4)
}
func (o *IWDG_Type) GetHWCFGR_PR_DEFAULT() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf0) >> 4
}

// IWDG.VERR: EXTI IP Version register
func (o *IWDG_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *IWDG_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *IWDG_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *IWDG_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// IWDG.IPIDR: EXTI Identification register
func (o *IWDG_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *IWDG_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// IWDG.SIDR: EXTI Size ID register
func (o *IWDG_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *IWDG_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// System window watchdog
type WWDG_Type struct {
	CR  volatile.Register32 // 0x0
	CFR volatile.Register32 // 0x4
	SR  volatile.Register32 // 0x8
}

// WWDG.CR: Control register
func (o *WWDG_Type) SetCR_WDGA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *WWDG_Type) GetCR_WDGA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *WWDG_Type) SetCR_T(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCR_T() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7f
}

// WWDG.CFR: Configuration register
func (o *WWDG_Type) SetCFR_WDGTB(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x3800)|value<<11)
}
func (o *WWDG_Type) GetCFR_WDGTB() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x3800) >> 11
}
func (o *WWDG_Type) SetCFR_EWI(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *WWDG_Type) GetCFR_EWI() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *WWDG_Type) SetCFR_W(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCFR_W() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x7f
}

// WWDG.SR: Status register
func (o *WWDG_Type) SetSR_EWIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *WWDG_Type) GetSR_EWIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Flash
type Flash_Type struct {
	ACR       volatile.Register32 // 0x0
	_         [4]byte
	KEYR      volatile.Register32 // 0x8
	OPTKEYR   volatile.Register32 // 0xC
	SR        volatile.Register32 // 0x10
	CR        volatile.Register32 // 0x14
	ECCR      volatile.Register32 // 0x18
	_         [4]byte
	OPTR      volatile.Register32 // 0x20
	PCROP1ASR volatile.Register32 // 0x24
	PCROP1AER volatile.Register32 // 0x28
	WRP1AR    volatile.Register32 // 0x2C
	WRP1BR    volatile.Register32 // 0x30
	PCROP1BSR volatile.Register32 // 0x34
	PCROP1BER volatile.Register32 // 0x38
	_         [68]byte
	SECR      volatile.Register32 // 0x80
}

// Flash.ACR: Access control register
func (o *Flash_Type) SetACR_LATENCY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x7)|value)
}
func (o *Flash_Type) GetACR_LATENCY() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x7
}
func (o *Flash_Type) SetACR_PRFTEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetACR_PRFTEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetACR_ICEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *Flash_Type) GetACR_ICEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *Flash_Type) SetACR_ICRST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x800)|value<<11)
}
func (o *Flash_Type) GetACR_ICRST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x800) >> 11
}
func (o *Flash_Type) SetACR_EMPTY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetACR_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetACR_DBG_SWEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetACR_DBG_SWEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x40000) >> 18
}

// Flash.KEYR: Flash key register
func (o *Flash_Type) SetKEYR(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, value)
}
func (o *Flash_Type) GetKEYR() uint32 {
	return volatile.LoadUint32(&o.KEYR.Reg)
}

// Flash.OPTKEYR: Option byte key register
func (o *Flash_Type) SetOPTKEYR(value uint32) {
	volatile.StoreUint32(&o.OPTKEYR.Reg, value)
}
func (o *Flash_Type) GetOPTKEYR() uint32 {
	return volatile.LoadUint32(&o.OPTKEYR.Reg)
}

// Flash.SR: Status register
func (o *Flash_Type) SetSR_EOP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *Flash_Type) GetSR_EOP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *Flash_Type) SetSR_OPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *Flash_Type) GetSR_OPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *Flash_Type) SetSR_PROGERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *Flash_Type) GetSR_PROGERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *Flash_Type) SetSR_WRPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *Flash_Type) GetSR_WRPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *Flash_Type) SetSR_PGAERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *Flash_Type) GetSR_PGAERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *Flash_Type) SetSR_SIZERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *Flash_Type) GetSR_SIZERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *Flash_Type) SetSR_PGSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *Flash_Type) GetSR_PGSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *Flash_Type) SetSR_MISERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetSR_MISERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetSR_FASTERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *Flash_Type) GetSR_FASTERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *Flash_Type) SetSR_RDERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *Flash_Type) GetSR_RDERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *Flash_Type) SetSR_OPTVERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *Flash_Type) GetSR_OPTVERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *Flash_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetSR_CFGBSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetSR_CFGBSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}

// Flash.CR: Flash control register
func (o *Flash_Type) SetCR_PG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *Flash_Type) GetCR_PG() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *Flash_Type) SetCR_PER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *Flash_Type) GetCR_PER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *Flash_Type) SetCR_MER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *Flash_Type) GetCR_MER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *Flash_Type) SetCR_PNB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1f8)|value<<3)
}
func (o *Flash_Type) GetCR_PNB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1f8) >> 3
}
func (o *Flash_Type) SetCR_STRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetCR_STRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetCR_OPTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *Flash_Type) GetCR_OPTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *Flash_Type) SetCR_FSTPG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetCR_FSTPG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetCR_EOPIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetCR_EOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *Flash_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *Flash_Type) SetCR_RDERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *Flash_Type) GetCR_RDERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *Flash_Type) SetCR_OBL_LAUNCH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *Flash_Type) GetCR_OBL_LAUNCH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *Flash_Type) SetCR_SEC_PROT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *Flash_Type) GetCR_SEC_PROT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *Flash_Type) SetCR_OPTLOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetCR_OPTLOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *Flash_Type) SetCR_LOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetCR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// Flash.ECCR: Flash ECC register
func (o *Flash_Type) SetECCR_ADDR_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x3fff)|value)
}
func (o *Flash_Type) GetECCR_ADDR_ECC() uint32 {
	return volatile.LoadUint32(&o.ECCR.Reg) & 0x3fff
}
func (o *Flash_Type) SetECCR_SYSF_ECC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x100000)|value<<20)
}
func (o *Flash_Type) GetECCR_SYSF_ECC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x100000) >> 20
}
func (o *Flash_Type) SetECCR_ECCIE(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetECCR_ECCIE() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetECCR_ECCC(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x40000000)|value<<30)
}
func (o *Flash_Type) GetECCR_ECCC() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x40000000) >> 30
}
func (o *Flash_Type) SetECCR_ECCD(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, volatile.LoadUint32(&o.ECCR.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetECCR_ECCD() uint32 {
	return (volatile.LoadUint32(&o.ECCR.Reg) & 0x80000000) >> 31
}

// Flash.OPTR: Flash option register
func (o *Flash_Type) SetOPTR_RDP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetOPTR_RDP() uint32 {
	return volatile.LoadUint32(&o.OPTR.Reg) & 0xff
}
func (o *Flash_Type) SetOPTR_BOREN(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x100)|value<<8)
}
func (o *Flash_Type) GetOPTR_BOREN() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x100) >> 8
}
func (o *Flash_Type) SetOPTR_BORF_LEV(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x600)|value<<9)
}
func (o *Flash_Type) GetOPTR_BORF_LEV() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x600) >> 9
}
func (o *Flash_Type) SetOPTR_BORR_LEV(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x1800)|value<<11)
}
func (o *Flash_Type) GetOPTR_BORR_LEV() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x1800) >> 11
}
func (o *Flash_Type) SetOPTR_NRST_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x2000)|value<<13)
}
func (o *Flash_Type) GetOPTR_NRST_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x2000) >> 13
}
func (o *Flash_Type) SetOPTR_NRST_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x4000)|value<<14)
}
func (o *Flash_Type) GetOPTR_NRST_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x4000) >> 14
}
func (o *Flash_Type) SetOPTR_NRSTS_HDW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x8000)|value<<15)
}
func (o *Flash_Type) GetOPTR_NRSTS_HDW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x8000) >> 15
}
func (o *Flash_Type) SetOPTR_IDWG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetOPTR_IDWG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x10000) >> 16
}
func (o *Flash_Type) SetOPTR_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x20000)|value<<17)
}
func (o *Flash_Type) GetOPTR_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x20000) >> 17
}
func (o *Flash_Type) SetOPTR_IWDG_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x40000)|value<<18)
}
func (o *Flash_Type) GetOPTR_IWDG_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x40000) >> 18
}
func (o *Flash_Type) SetOPTR_WWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x80000)|value<<19)
}
func (o *Flash_Type) GetOPTR_WWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x80000) >> 19
}
func (o *Flash_Type) SetOPTR_RAM_PARITY_CHECK(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x400000)|value<<22)
}
func (o *Flash_Type) GetOPTR_RAM_PARITY_CHECK() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x400000) >> 22
}
func (o *Flash_Type) SetOPTR_NBOOT_SEL(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x1000000)|value<<24)
}
func (o *Flash_Type) GetOPTR_NBOOT_SEL() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x1000000) >> 24
}
func (o *Flash_Type) SetOPTR_NBOOT1(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x2000000)|value<<25)
}
func (o *Flash_Type) GetOPTR_NBOOT1() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x2000000) >> 25
}
func (o *Flash_Type) SetOPTR_NBOOT0(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x4000000)|value<<26)
}
func (o *Flash_Type) GetOPTR_NBOOT0() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x4000000) >> 26
}
func (o *Flash_Type) SetOPTR_NRST_MODE(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x18000000)|value<<27)
}
func (o *Flash_Type) GetOPTR_NRST_MODE() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x18000000) >> 27
}
func (o *Flash_Type) SetOPTR_IRHEN(value uint32) {
	volatile.StoreUint32(&o.OPTR.Reg, volatile.LoadUint32(&o.OPTR.Reg)&^(0x20000000)|value<<29)
}
func (o *Flash_Type) GetOPTR_IRHEN() uint32 {
	return (volatile.LoadUint32(&o.OPTR.Reg) & 0x20000000) >> 29
}

// Flash.PCROP1ASR: Flash PCROP zone A Start address register
func (o *Flash_Type) SetPCROP1ASR_PCROP1A_STRT(value uint32) {
	volatile.StoreUint32(&o.PCROP1ASR.Reg, volatile.LoadUint32(&o.PCROP1ASR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1ASR_PCROP1A_STRT() uint32 {
	return volatile.LoadUint32(&o.PCROP1ASR.Reg) & 0xff
}

// Flash.PCROP1AER: Flash PCROP zone A End address register
func (o *Flash_Type) SetPCROP1AER_PCROP1A_END(value uint32) {
	volatile.StoreUint32(&o.PCROP1AER.Reg, volatile.LoadUint32(&o.PCROP1AER.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1AER_PCROP1A_END() uint32 {
	return volatile.LoadUint32(&o.PCROP1AER.Reg) & 0xff
}
func (o *Flash_Type) SetPCROP1AER_PCROP_RDP(value uint32) {
	volatile.StoreUint32(&o.PCROP1AER.Reg, volatile.LoadUint32(&o.PCROP1AER.Reg)&^(0x80000000)|value<<31)
}
func (o *Flash_Type) GetPCROP1AER_PCROP_RDP() uint32 {
	return (volatile.LoadUint32(&o.PCROP1AER.Reg) & 0x80000000) >> 31
}

// Flash.WRP1AR: Flash WRP area A address register
func (o *Flash_Type) SetWRP1AR_WRP1A_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP1AR.Reg, volatile.LoadUint32(&o.WRP1AR.Reg)&^(0x3f)|value)
}
func (o *Flash_Type) GetWRP1AR_WRP1A_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP1AR.Reg) & 0x3f
}
func (o *Flash_Type) SetWRP1AR_WRP1A_END(value uint32) {
	volatile.StoreUint32(&o.WRP1AR.Reg, volatile.LoadUint32(&o.WRP1AR.Reg)&^(0x3f0000)|value<<16)
}
func (o *Flash_Type) GetWRP1AR_WRP1A_END() uint32 {
	return (volatile.LoadUint32(&o.WRP1AR.Reg) & 0x3f0000) >> 16
}

// Flash.WRP1BR: Flash WRP area B address register
func (o *Flash_Type) SetWRP1BR_WRP1B_STRT(value uint32) {
	volatile.StoreUint32(&o.WRP1BR.Reg, volatile.LoadUint32(&o.WRP1BR.Reg)&^(0x3f)|value)
}
func (o *Flash_Type) GetWRP1BR_WRP1B_STRT() uint32 {
	return volatile.LoadUint32(&o.WRP1BR.Reg) & 0x3f
}
func (o *Flash_Type) SetWRP1BR_WRP1B_END(value uint32) {
	volatile.StoreUint32(&o.WRP1BR.Reg, volatile.LoadUint32(&o.WRP1BR.Reg)&^(0x3f0000)|value<<16)
}
func (o *Flash_Type) GetWRP1BR_WRP1B_END() uint32 {
	return (volatile.LoadUint32(&o.WRP1BR.Reg) & 0x3f0000) >> 16
}

// Flash.PCROP1BSR: Flash PCROP zone B Start address register
func (o *Flash_Type) SetPCROP1BSR_PCROP1B_STRT(value uint32) {
	volatile.StoreUint32(&o.PCROP1BSR.Reg, volatile.LoadUint32(&o.PCROP1BSR.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1BSR_PCROP1B_STRT() uint32 {
	return volatile.LoadUint32(&o.PCROP1BSR.Reg) & 0xff
}

// Flash.PCROP1BER: Flash PCROP zone B End address register
func (o *Flash_Type) SetPCROP1BER_PCROP1B_END(value uint32) {
	volatile.StoreUint32(&o.PCROP1BER.Reg, volatile.LoadUint32(&o.PCROP1BER.Reg)&^(0xff)|value)
}
func (o *Flash_Type) GetPCROP1BER_PCROP1B_END() uint32 {
	return volatile.LoadUint32(&o.PCROP1BER.Reg) & 0xff
}

// Flash.SECR: Flash Security register
func (o *Flash_Type) SetSECR_SEC_SIZE(value uint32) {
	volatile.StoreUint32(&o.SECR.Reg, volatile.LoadUint32(&o.SECR.Reg)&^(0x7f)|value)
}
func (o *Flash_Type) GetSECR_SEC_SIZE() uint32 {
	return volatile.LoadUint32(&o.SECR.Reg) & 0x7f
}
func (o *Flash_Type) SetSECR_BOOT_LOCK(value uint32) {
	volatile.StoreUint32(&o.SECR.Reg, volatile.LoadUint32(&o.SECR.Reg)&^(0x10000)|value<<16)
}
func (o *Flash_Type) GetSECR_BOOT_LOCK() uint32 {
	return (volatile.LoadUint32(&o.SECR.Reg) & 0x10000) >> 16
}

// Debug support
type DBG_Type struct {
	IDCODE  volatile.Register32 // 0x0
	CR      volatile.Register32 // 0x4
	APB_FZ1 volatile.Register32 // 0x8
	APB_FZ2 volatile.Register32 // 0xC
}

// DBG.IDCODE: MCU Device ID Code Register
func (o *DBG_Type) SetIDCODE_DEV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODE.Reg, volatile.LoadUint32(&o.IDCODE.Reg)&^(0xffff)|value)
}
func (o *DBG_Type) GetIDCODE_DEV_ID() uint32 {
	return volatile.LoadUint32(&o.IDCODE.Reg) & 0xffff
}
func (o *DBG_Type) SetIDCODE_REV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODE.Reg, volatile.LoadUint32(&o.IDCODE.Reg)&^(0xffff0000)|value<<16)
}
func (o *DBG_Type) GetIDCODE_REV_ID() uint32 {
	return (volatile.LoadUint32(&o.IDCODE.Reg) & 0xffff0000) >> 16
}

// DBG.CR: Debug MCU Configuration Register
func (o *DBG_Type) SetCR_DBG_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetCR_DBG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetCR_DBG_STANDBY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBG_Type) GetCR_DBG_STANDBY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}

// DBG.APB_FZ1: DBG APB freeze register 1
func (o *DBG_Type) SetAPB_FZ1_DBG_TIMER2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_TIMER2_STOP() uint32 {
	return volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x1
}
func (o *DBG_Type) SetAPB_FZ1_DBG_TIM3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_TIM3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetAPB_FZ1_DBG_TIMER6_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x10)|value<<4)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_TIMER6_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x10) >> 4
}
func (o *DBG_Type) SetAPB_FZ1_DBG_TIM7_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x20)|value<<5)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_TIM7_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x20) >> 5
}
func (o *DBG_Type) SetAPB_FZ1_DBG_RTC_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x400)|value<<10)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_RTC_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x400) >> 10
}
func (o *DBG_Type) SetAPB_FZ1_DBG_WWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x800)|value<<11)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_WWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x800) >> 11
}
func (o *DBG_Type) SetAPB_FZ1_DBG_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x1000)|value<<12)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x1000) >> 12
}
func (o *DBG_Type) SetAPB_FZ1_DBG_I2C1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x200000)|value<<21)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_I2C1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x200000) >> 21
}
func (o *DBG_Type) SetAPB_FZ1_DBG_LPTIM2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x40000000)|value<<30)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_LPTIM2_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x40000000) >> 30
}
func (o *DBG_Type) SetAPB_FZ1_DBG_LPTIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ1.Reg, volatile.LoadUint32(&o.APB_FZ1.Reg)&^(0x80000000)|value<<31)
}
func (o *DBG_Type) GetAPB_FZ1_DBG_LPTIM1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ1.Reg) & 0x80000000) >> 31
}

// DBG.APB_FZ2: DBG APB freeze register 2
func (o *DBG_Type) SetAPB_FZ2_DBG_TIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ2.Reg, volatile.LoadUint32(&o.APB_FZ2.Reg)&^(0x800)|value<<11)
}
func (o *DBG_Type) GetAPB_FZ2_DBG_TIM1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ2.Reg) & 0x800) >> 11
}
func (o *DBG_Type) SetAPB_FZ2_DBG_TIM14_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ2.Reg, volatile.LoadUint32(&o.APB_FZ2.Reg)&^(0x8000)|value<<15)
}
func (o *DBG_Type) GetAPB_FZ2_DBG_TIM14_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ2.Reg) & 0x8000) >> 15
}
func (o *DBG_Type) SetAPB_FZ2_DBG_TIM15_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ2.Reg, volatile.LoadUint32(&o.APB_FZ2.Reg)&^(0x10000)|value<<16)
}
func (o *DBG_Type) GetAPB_FZ2_DBG_TIM15_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ2.Reg) & 0x10000) >> 16
}
func (o *DBG_Type) SetAPB_FZ2_DBG_TIM16_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ2.Reg, volatile.LoadUint32(&o.APB_FZ2.Reg)&^(0x20000)|value<<17)
}
func (o *DBG_Type) GetAPB_FZ2_DBG_TIM16_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ2.Reg) & 0x20000) >> 17
}
func (o *DBG_Type) SetAPB_FZ2_DBG_TIM17_STOP(value uint32) {
	volatile.StoreUint32(&o.APB_FZ2.Reg, volatile.LoadUint32(&o.APB_FZ2.Reg)&^(0x40000)|value<<18)
}
func (o *DBG_Type) GetAPB_FZ2_DBG_TIM17_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB_FZ2.Reg) & 0x40000) >> 18
}

// Reset and clock control
type RCC_Type struct {
	CR         volatile.Register32 // 0x0
	ICSCR      volatile.Register32 // 0x4
	CFGR       volatile.Register32 // 0x8
	PLLSYSCFGR volatile.Register32 // 0xC
	_          [8]byte
	CIER       volatile.Register32 // 0x18
	CIFR       volatile.Register32 // 0x1C
	CICR       volatile.Register32 // 0x20
	IOPRSTR    volatile.Register32 // 0x24
	AHBRSTR    volatile.Register32 // 0x28
	APBRSTR1   volatile.Register32 // 0x2C
	APBRSTR2   volatile.Register32 // 0x30
	IOPENR     volatile.Register32 // 0x34
	AHBENR     volatile.Register32 // 0x38
	APBENR1    volatile.Register32 // 0x3C
	APBENR2    volatile.Register32 // 0x40
	IOPSMENR   volatile.Register32 // 0x44
	AHBSMENR   volatile.Register32 // 0x48
	APBSMENR1  volatile.Register32 // 0x4C
	APBSMENR2  volatile.Register32 // 0x50
	CCIPR      volatile.Register32 // 0x54
	_          [4]byte
	BDCR       volatile.Register32 // 0x5C
	CSR        volatile.Register32 // 0x60
}

// RCC.CR: Clock control register
func (o *RCC_Type) SetCR_HSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCR_HSION() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCR_HSIKERON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCR_HSIKERON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCR_HSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCR_HSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetCR_HSIDIV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3800)|value<<11)
}
func (o *RCC_Type) GetCR_HSIDIV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3800) >> 11
}
func (o *RCC_Type) SetCR_HSEON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCR_HSEON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCR_HSERDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCR_HSERDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCR_HSEBYP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCR_HSEBYP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCR_CSSON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCR_CSSON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCR_PLLON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCR_PLLON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCR_PLLRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCR_PLLRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}

// RCC.ICSCR: Internal clock sources calibration register
func (o *RCC_Type) SetICSCR_HSICAL(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0xff)|value)
}
func (o *RCC_Type) GetICSCR_HSICAL() uint32 {
	return volatile.LoadUint32(&o.ICSCR.Reg) & 0xff
}
func (o *RCC_Type) SetICSCR_HSITRIM(value uint32) {
	volatile.StoreUint32(&o.ICSCR.Reg, volatile.LoadUint32(&o.ICSCR.Reg)&^(0x7f00)|value<<8)
}
func (o *RCC_Type) GetICSCR_HSITRIM() uint32 {
	return (volatile.LoadUint32(&o.ICSCR.Reg) & 0x7f00) >> 8
}

// RCC.CFGR: Clock configuration register
func (o *RCC_Type) SetCFGR_MCOPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetCFGR_MCOPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x70000000) >> 28
}
func (o *RCC_Type) SetCFGR_MCOSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7000000)|value<<24)
}
func (o *RCC_Type) GetCFGR_MCOSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7000000) >> 24
}
func (o *RCC_Type) SetCFGR_PPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7000)|value<<12)
}
func (o *RCC_Type) GetCFGR_PPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7000) >> 12
}
func (o *RCC_Type) SetCFGR_HPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xf00)|value<<8)
}
func (o *RCC_Type) GetCFGR_HPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xf00) >> 8
}
func (o *RCC_Type) SetCFGR_SWS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x38)|value<<3)
}
func (o *RCC_Type) GetCFGR_SWS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x38) >> 3
}
func (o *RCC_Type) SetCFGR_SW(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7)|value)
}
func (o *RCC_Type) GetCFGR_SW() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x7
}

// RCC.PLLSYSCFGR: PLL configuration register
func (o *RCC_Type) SetPLLSYSCFGR_PLLSRC(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLSRC() uint32 {
	return volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x3
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLM(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x70)|value<<4)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLM() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x70) >> 4
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLN(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x7f00)|value<<8)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLN() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x7f00) >> 8
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLPEN(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLPEN() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLP(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x3e0000)|value<<17)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLP() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x3e0000) >> 17
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLQEN(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLQEN() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLQ(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0xe000000)|value<<25)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLQ() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0xe000000) >> 25
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLREN(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLREN() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetPLLSYSCFGR_PLLR(value uint32) {
	volatile.StoreUint32(&o.PLLSYSCFGR.Reg, volatile.LoadUint32(&o.PLLSYSCFGR.Reg)&^(0xe0000000)|value<<29)
}
func (o *RCC_Type) GetPLLSYSCFGR_PLLR() uint32 {
	return (volatile.LoadUint32(&o.PLLSYSCFGR.Reg) & 0xe0000000) >> 29
}

// RCC.CIER: Clock interrupt enable register
func (o *RCC_Type) SetCIER_LSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIER_LSIRDYIE() uint32 {
	return volatile.LoadUint32(&o.CIER.Reg) & 0x1
}
func (o *RCC_Type) SetCIER_LSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIER_LSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIER_HSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIER_HSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIER_HSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIER_HSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIER_PLLSYSRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIER.Reg, volatile.LoadUint32(&o.CIER.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIER_PLLSYSRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIER.Reg) & 0x20) >> 5
}

// RCC.CIFR: Clock interrupt flag register
func (o *RCC_Type) SetCIFR_LSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIFR_LSIRDYF() uint32 {
	return volatile.LoadUint32(&o.CIFR.Reg) & 0x1
}
func (o *RCC_Type) SetCIFR_LSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIFR_LSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIFR_HSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIFR_HSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIFR_HSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIFR_HSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIFR_PLLSYSRDYF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIFR_PLLSYSRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIFR_CSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCIFR_CSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCIFR_LSECSSF(value uint32) {
	volatile.StoreUint32(&o.CIFR.Reg, volatile.LoadUint32(&o.CIFR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIFR_LSECSSF() uint32 {
	return (volatile.LoadUint32(&o.CIFR.Reg) & 0x200) >> 9
}

// RCC.CICR: Clock interrupt clear register
func (o *RCC_Type) SetCICR_LSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCICR_LSIRDYC() uint32 {
	return volatile.LoadUint32(&o.CICR.Reg) & 0x1
}
func (o *RCC_Type) SetCICR_LSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCICR_LSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCICR_HSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCICR_HSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCICR_HSERDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCICR_HSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCICR_PLLSYSRDYC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCICR_PLLSYSRDYC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCICR_CSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCICR_CSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCICR_LSECSSC(value uint32) {
	volatile.StoreUint32(&o.CICR.Reg, volatile.LoadUint32(&o.CICR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCICR_LSECSSC() uint32 {
	return (volatile.LoadUint32(&o.CICR.Reg) & 0x200) >> 9
}

// RCC.IOPRSTR: GPIO reset register
func (o *RCC_Type) SetIOPRSTR_IOPARST(value uint32) {
	volatile.StoreUint32(&o.IOPRSTR.Reg, volatile.LoadUint32(&o.IOPRSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetIOPRSTR_IOPARST() uint32 {
	return volatile.LoadUint32(&o.IOPRSTR.Reg) & 0x1
}
func (o *RCC_Type) SetIOPRSTR_IOPBRST(value uint32) {
	volatile.StoreUint32(&o.IOPRSTR.Reg, volatile.LoadUint32(&o.IOPRSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetIOPRSTR_IOPBRST() uint32 {
	return (volatile.LoadUint32(&o.IOPRSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetIOPRSTR_IOPCRST(value uint32) {
	volatile.StoreUint32(&o.IOPRSTR.Reg, volatile.LoadUint32(&o.IOPRSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetIOPRSTR_IOPCRST() uint32 {
	return (volatile.LoadUint32(&o.IOPRSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetIOPRSTR_IOPDRST(value uint32) {
	volatile.StoreUint32(&o.IOPRSTR.Reg, volatile.LoadUint32(&o.IOPRSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetIOPRSTR_IOPDRST() uint32 {
	return (volatile.LoadUint32(&o.IOPRSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetIOPRSTR_IOPFRST(value uint32) {
	volatile.StoreUint32(&o.IOPRSTR.Reg, volatile.LoadUint32(&o.IOPRSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetIOPRSTR_IOPFRST() uint32 {
	return (volatile.LoadUint32(&o.IOPRSTR.Reg) & 0x20) >> 5
}

// RCC.AHBRSTR: AHB peripheral reset register
func (o *RCC_Type) SetAHBRSTR_DMARST(value uint32) {
	volatile.StoreUint32(&o.AHBRSTR.Reg, volatile.LoadUint32(&o.AHBRSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHBRSTR_DMARST() uint32 {
	return volatile.LoadUint32(&o.AHBRSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHBRSTR_FLASHRST(value uint32) {
	volatile.StoreUint32(&o.AHBRSTR.Reg, volatile.LoadUint32(&o.AHBRSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHBRSTR_FLASHRST() uint32 {
	return (volatile.LoadUint32(&o.AHBRSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHBRSTR_CRCRST(value uint32) {
	volatile.StoreUint32(&o.AHBRSTR.Reg, volatile.LoadUint32(&o.AHBRSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHBRSTR_CRCRST() uint32 {
	return (volatile.LoadUint32(&o.AHBRSTR.Reg) & 0x1000) >> 12
}

// RCC.APBRSTR1: APB peripheral reset register 1
func (o *RCC_Type) SetAPBRSTR1_TIM2RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPBRSTR1_TIM2RST() uint32 {
	return volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x1
}
func (o *RCC_Type) SetAPBRSTR1_TIM3RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPBRSTR1_TIM3RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPBRSTR1_TIM6RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPBRSTR1_TIM6RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPBRSTR1_TIM7RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPBRSTR1_TIM7RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPBRSTR1_SPI2RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPBRSTR1_SPI2RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPBRSTR1_USART2RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPBRSTR1_USART2RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPBRSTR1_USART3RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPBRSTR1_USART3RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPBRSTR1_USART4RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPBRSTR1_USART4RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPBRSTR1_LPUART1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPBRSTR1_LPUART1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPBRSTR1_I2C1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPBRSTR1_I2C1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPBRSTR1_I2C2RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPBRSTR1_I2C2RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPBRSTR1_CECRST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPBRSTR1_CECRST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPBRSTR1_UCPD1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPBRSTR1_UCPD1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPBRSTR1_UCPD2RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPBRSTR1_UCPD2RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPBRSTR1_DBGRST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPBRSTR1_DBGRST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPBRSTR1_PWRRST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPBRSTR1_PWRRST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPBRSTR1_DAC1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPBRSTR1_DAC1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPBRSTR1_LPTIM2RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPBRSTR1_LPTIM2RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPBRSTR1_LPTIM1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR1.Reg, volatile.LoadUint32(&o.APBRSTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPBRSTR1_LPTIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR1.Reg) & 0x80000000) >> 31
}

// RCC.APBRSTR2: APB peripheral reset register 2
func (o *RCC_Type) SetAPBRSTR2_SYSCFGRST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPBRSTR2_SYSCFGRST() uint32 {
	return volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x1
}
func (o *RCC_Type) SetAPBRSTR2_TIM1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPBRSTR2_TIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPBRSTR2_SPI1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPBRSTR2_SPI1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPBRSTR2_USART1RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPBRSTR2_USART1RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPBRSTR2_TIM14RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPBRSTR2_TIM14RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPBRSTR2_TIM15RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPBRSTR2_TIM15RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPBRSTR2_TIM16RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPBRSTR2_TIM16RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPBRSTR2_TIM17RST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPBRSTR2_TIM17RST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPBRSTR2_ADCRST(value uint32) {
	volatile.StoreUint32(&o.APBRSTR2.Reg, volatile.LoadUint32(&o.APBRSTR2.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPBRSTR2_ADCRST() uint32 {
	return (volatile.LoadUint32(&o.APBRSTR2.Reg) & 0x100000) >> 20
}

// RCC.IOPENR: GPIO clock enable register
func (o *RCC_Type) SetIOPENR_IOPAEN(value uint32) {
	volatile.StoreUint32(&o.IOPENR.Reg, volatile.LoadUint32(&o.IOPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetIOPENR_IOPAEN() uint32 {
	return volatile.LoadUint32(&o.IOPENR.Reg) & 0x1
}
func (o *RCC_Type) SetIOPENR_IOPBEN(value uint32) {
	volatile.StoreUint32(&o.IOPENR.Reg, volatile.LoadUint32(&o.IOPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetIOPENR_IOPBEN() uint32 {
	return (volatile.LoadUint32(&o.IOPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetIOPENR_IOPCEN(value uint32) {
	volatile.StoreUint32(&o.IOPENR.Reg, volatile.LoadUint32(&o.IOPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetIOPENR_IOPCEN() uint32 {
	return (volatile.LoadUint32(&o.IOPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetIOPENR_IOPDEN(value uint32) {
	volatile.StoreUint32(&o.IOPENR.Reg, volatile.LoadUint32(&o.IOPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetIOPENR_IOPDEN() uint32 {
	return (volatile.LoadUint32(&o.IOPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetIOPENR_IOPFEN(value uint32) {
	volatile.StoreUint32(&o.IOPENR.Reg, volatile.LoadUint32(&o.IOPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetIOPENR_IOPFEN() uint32 {
	return (volatile.LoadUint32(&o.IOPENR.Reg) & 0x20) >> 5
}

// RCC.AHBENR: AHB peripheral clock enable register
func (o *RCC_Type) SetAHBENR_DMAEN(value uint32) {
	volatile.StoreUint32(&o.AHBENR.Reg, volatile.LoadUint32(&o.AHBENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHBENR_DMAEN() uint32 {
	return volatile.LoadUint32(&o.AHBENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHBENR_FLASHEN(value uint32) {
	volatile.StoreUint32(&o.AHBENR.Reg, volatile.LoadUint32(&o.AHBENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHBENR_FLASHEN() uint32 {
	return (volatile.LoadUint32(&o.AHBENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHBENR_CRCEN(value uint32) {
	volatile.StoreUint32(&o.AHBENR.Reg, volatile.LoadUint32(&o.AHBENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHBENR_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.AHBENR.Reg) & 0x1000) >> 12
}

// RCC.APBENR1: APB peripheral clock enable register 1
func (o *RCC_Type) SetAPBENR1_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPBENR1_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.APBENR1.Reg) & 0x1
}
func (o *RCC_Type) SetAPBENR1_TIM3EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPBENR1_TIM3EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPBENR1_TIM6EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPBENR1_TIM6EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPBENR1_TIM7EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPBENR1_TIM7EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPBENR1_RTCAPBEN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPBENR1_RTCAPBEN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPBENR1_WWDGEN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPBENR1_WWDGEN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPBENR1_SPI2EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPBENR1_SPI2EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPBENR1_USART2EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPBENR1_USART2EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPBENR1_USART3EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPBENR1_USART3EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPBENR1_USART4EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPBENR1_USART4EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPBENR1_LPUART1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPBENR1_LPUART1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPBENR1_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPBENR1_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPBENR1_I2C2EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPBENR1_I2C2EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPBENR1_CECEN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPBENR1_CECEN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPBENR1_UCPD1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPBENR1_UCPD1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPBENR1_UCPD2EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPBENR1_UCPD2EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPBENR1_DBGEN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPBENR1_DBGEN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPBENR1_PWREN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPBENR1_PWREN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPBENR1_DAC1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPBENR1_DAC1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPBENR1_LPTIM2EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPBENR1_LPTIM2EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPBENR1_LPTIM1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR1.Reg, volatile.LoadUint32(&o.APBENR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPBENR1_LPTIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR1.Reg) & 0x80000000) >> 31
}

// RCC.APBENR2: APB peripheral clock enable register 2
func (o *RCC_Type) SetAPBENR2_SYSCFGEN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPBENR2_SYSCFGEN() uint32 {
	return volatile.LoadUint32(&o.APBENR2.Reg) & 0x1
}
func (o *RCC_Type) SetAPBENR2_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPBENR2_TIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPBENR2_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPBENR2_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPBENR2_USART1EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPBENR2_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPBENR2_TIM14EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPBENR2_TIM14EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPBENR2_TIM15EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPBENR2_TIM15EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPBENR2_TIM16EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPBENR2_TIM16EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPBENR2_TIM17EN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPBENR2_TIM17EN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPBENR2_ADCEN(value uint32) {
	volatile.StoreUint32(&o.APBENR2.Reg, volatile.LoadUint32(&o.APBENR2.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPBENR2_ADCEN() uint32 {
	return (volatile.LoadUint32(&o.APBENR2.Reg) & 0x100000) >> 20
}

// RCC.IOPSMENR: GPIO in Sleep mode clock enable register
func (o *RCC_Type) SetIOPSMENR_IOPASMEN(value uint32) {
	volatile.StoreUint32(&o.IOPSMENR.Reg, volatile.LoadUint32(&o.IOPSMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetIOPSMENR_IOPASMEN() uint32 {
	return volatile.LoadUint32(&o.IOPSMENR.Reg) & 0x1
}
func (o *RCC_Type) SetIOPSMENR_IOPBSMEN(value uint32) {
	volatile.StoreUint32(&o.IOPSMENR.Reg, volatile.LoadUint32(&o.IOPSMENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetIOPSMENR_IOPBSMEN() uint32 {
	return (volatile.LoadUint32(&o.IOPSMENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetIOPSMENR_IOPCSMEN(value uint32) {
	volatile.StoreUint32(&o.IOPSMENR.Reg, volatile.LoadUint32(&o.IOPSMENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetIOPSMENR_IOPCSMEN() uint32 {
	return (volatile.LoadUint32(&o.IOPSMENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetIOPSMENR_IOPDSMEN(value uint32) {
	volatile.StoreUint32(&o.IOPSMENR.Reg, volatile.LoadUint32(&o.IOPSMENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetIOPSMENR_IOPDSMEN() uint32 {
	return (volatile.LoadUint32(&o.IOPSMENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetIOPSMENR_IOPFSMEN(value uint32) {
	volatile.StoreUint32(&o.IOPSMENR.Reg, volatile.LoadUint32(&o.IOPSMENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetIOPSMENR_IOPFSMEN() uint32 {
	return (volatile.LoadUint32(&o.IOPSMENR.Reg) & 0x20) >> 5
}

// RCC.AHBSMENR: AHB peripheral clock enable in Sleep mode register
func (o *RCC_Type) SetAHBSMENR_DMASMEN(value uint32) {
	volatile.StoreUint32(&o.AHBSMENR.Reg, volatile.LoadUint32(&o.AHBSMENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHBSMENR_DMASMEN() uint32 {
	return volatile.LoadUint32(&o.AHBSMENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHBSMENR_FLASHSMEN(value uint32) {
	volatile.StoreUint32(&o.AHBSMENR.Reg, volatile.LoadUint32(&o.AHBSMENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHBSMENR_FLASHSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHBSMENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHBSMENR_SRAMSMEN(value uint32) {
	volatile.StoreUint32(&o.AHBSMENR.Reg, volatile.LoadUint32(&o.AHBSMENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHBSMENR_SRAMSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHBSMENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHBSMENR_CRCSMEN(value uint32) {
	volatile.StoreUint32(&o.AHBSMENR.Reg, volatile.LoadUint32(&o.AHBSMENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHBSMENR_CRCSMEN() uint32 {
	return (volatile.LoadUint32(&o.AHBSMENR.Reg) & 0x1000) >> 12
}

// RCC.APBSMENR1: APB peripheral clock enable in Sleep mode register 1
func (o *RCC_Type) SetAPBSMENR1_TIM2SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPBSMENR1_TIM2SMEN() uint32 {
	return volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x1
}
func (o *RCC_Type) SetAPBSMENR1_TIM3SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPBSMENR1_TIM3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPBSMENR1_TIM6SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPBSMENR1_TIM6SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPBSMENR1_TIM7SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPBSMENR1_TIM7SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPBSMENR1_RTCAPBSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPBSMENR1_RTCAPBSMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPBSMENR1_WWDGSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPBSMENR1_WWDGSMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPBSMENR1_SPI2SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPBSMENR1_SPI2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPBSMENR1_USART2SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPBSMENR1_USART2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPBSMENR1_USART3SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPBSMENR1_USART3SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPBSMENR1_USART4SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPBSMENR1_USART4SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPBSMENR1_LPUART1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPBSMENR1_LPUART1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPBSMENR1_I2C1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPBSMENR1_I2C1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPBSMENR1_I2C2SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPBSMENR1_I2C2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPBSMENR1_CECSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPBSMENR1_CECSMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPBSMENR1_UCPD1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPBSMENR1_UCPD1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPBSMENR1_UCPD2SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPBSMENR1_UCPD2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPBSMENR1_DBGSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPBSMENR1_DBGSMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPBSMENR1_PWRSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPBSMENR1_PWRSMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPBSMENR1_DAC1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPBSMENR1_DAC1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPBSMENR1_LPTIM2SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPBSMENR1_LPTIM2SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPBSMENR1_LPTIM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR1.Reg, volatile.LoadUint32(&o.APBSMENR1.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPBSMENR1_LPTIM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR1.Reg) & 0x80000000) >> 31
}

// RCC.APBSMENR2: APB peripheral clock enable in Sleep mode register 2
func (o *RCC_Type) SetAPBSMENR2_SYSCFGSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPBSMENR2_SYSCFGSMEN() uint32 {
	return volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x1
}
func (o *RCC_Type) SetAPBSMENR2_TIM1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPBSMENR2_TIM1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPBSMENR2_SPI1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPBSMENR2_SPI1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPBSMENR2_USART1SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPBSMENR2_USART1SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPBSMENR2_TIM14SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPBSMENR2_TIM14SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPBSMENR2_TIM15SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPBSMENR2_TIM15SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPBSMENR2_TIM16SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPBSMENR2_TIM16SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPBSMENR2_TIM17SMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPBSMENR2_TIM17SMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPBSMENR2_ADCSMEN(value uint32) {
	volatile.StoreUint32(&o.APBSMENR2.Reg, volatile.LoadUint32(&o.APBSMENR2.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPBSMENR2_ADCSMEN() uint32 {
	return (volatile.LoadUint32(&o.APBSMENR2.Reg) & 0x100000) >> 20
}

// RCC.CCIPR: Peripherals independent clock configuration register
func (o *RCC_Type) SetCCIPR_USART1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCCIPR_USART1SEL() uint32 {
	return volatile.LoadUint32(&o.CCIPR.Reg) & 0x3
}
func (o *RCC_Type) SetCCIPR_USART2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCCIPR_USART2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetCCIPR_CECSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCCIPR_CECSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCCIPR_LPUART1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc00)|value<<10)
}
func (o *RCC_Type) GetCCIPR_LPUART1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc00) >> 10
}
func (o *RCC_Type) SetCCIPR_I2C1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x3000)|value<<12)
}
func (o *RCC_Type) GetCCIPR_I2C1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x3000) >> 12
}
func (o *RCC_Type) SetCCIPR_I2S2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc000)|value<<14)
}
func (o *RCC_Type) GetCCIPR_I2S2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc000) >> 14
}
func (o *RCC_Type) SetCCIPR_LPTIM1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc0000)|value<<18)
}
func (o *RCC_Type) GetCCIPR_LPTIM1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc0000) >> 18
}
func (o *RCC_Type) SetCCIPR_LPTIM2SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetCCIPR_LPTIM2SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetCCIPR_TIM1SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetCCIPR_TIM1SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetCCIPR_TIM15SEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCCIPR_TIM15SEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCCIPR_ADCSEL(value uint32) {
	volatile.StoreUint32(&o.CCIPR.Reg, volatile.LoadUint32(&o.CCIPR.Reg)&^(0xc0000000)|value<<30)
}
func (o *RCC_Type) GetCCIPR_ADCSEL() uint32 {
	return (volatile.LoadUint32(&o.CCIPR.Reg) & 0xc0000000) >> 30
}

// RCC.BDCR: RTC domain control register
func (o *RCC_Type) SetBDCR_LSEON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetBDCR_LSEON() uint32 {
	return volatile.LoadUint32(&o.BDCR.Reg) & 0x1
}
func (o *RCC_Type) SetBDCR_LSERDY(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetBDCR_LSERDY() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetBDCR_LSEBYP(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetBDCR_LSEBYP() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetBDCR_LSEDRV(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetBDCR_LSEDRV() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetBDCR_LSECSSON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetBDCR_LSECSSON() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetBDCR_LSECSSD(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetBDCR_LSECSSD() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetBDCR_RTCSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetBDCR_RTCSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetBDCR_RTCEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetBDCR_RTCEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetBDCR_BDRST(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetBDCR_BDRST() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetBDCR_LSCOEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetBDCR_LSCOEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetBDCR_LSCOSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetBDCR_LSCOSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2000000) >> 25
}

// RCC.CSR: Control/status register
func (o *RCC_Type) SetCSR_LSION(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCSR_LSION() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *RCC_Type) SetCSR_LSIRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCSR_LSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCSR_RMVF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetCSR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetCSR_OBLRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCSR_OBLRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCSR_PINRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCSR_PINRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCSR_PWRRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCSR_PWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCSR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCSR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetCSR_IWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCSR_IWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetCSR_WWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetCSR_WWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetCSR_LPWRRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetCSR_LPWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000000) >> 31
}

// Power control
type PWR_Type struct {
	CR1   volatile.Register32 // 0x0
	CR2   volatile.Register32 // 0x4
	CR3   volatile.Register32 // 0x8
	CR4   volatile.Register32 // 0xC
	SR1   volatile.Register32 // 0x10
	SR2   volatile.Register32 // 0x14
	SCR   volatile.Register32 // 0x18
	_     [4]byte
	PUCRA volatile.Register32 // 0x20
	PDCRA volatile.Register32 // 0x24
	PUCRB volatile.Register32 // 0x28
	PDCRB volatile.Register32 // 0x2C
	PUCRC volatile.Register32 // 0x30
	PDCRC volatile.Register32 // 0x34
	PUCRD volatile.Register32 // 0x38
	PDCRD volatile.Register32 // 0x3C
	_     [8]byte
	PUCRF volatile.Register32 // 0x48
	PDCRF volatile.Register32 // 0x4C
}

// PWR.CR1: Power control register 1
func (o *PWR_Type) SetCR1_LPR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetCR1_LPR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetCR1_VOS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x600)|value<<9)
}
func (o *PWR_Type) GetCR1_VOS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x600) >> 9
}
func (o *PWR_Type) SetCR1_DBP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR1_DBP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR1_FPD_LPSLP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCR1_FPD_LPSLP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCR1_FPD_LPRUN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR1_FPD_LPRUN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR1_FPD_STOP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR1_FPD_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR1_LPMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x7)|value)
}
func (o *PWR_Type) GetCR1_LPMS() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x7
}

// PWR.CR2: Power control register 2
func (o *PWR_Type) SetCR2_PVDE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR2_PVDE() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *PWR_Type) SetCR2_PVDFT(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xe)|value<<1)
}
func (o *PWR_Type) GetCR2_PVDFT() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xe) >> 1
}
func (o *PWR_Type) SetCR2_PVDRT(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x70)|value<<4)
}
func (o *PWR_Type) GetCR2_PVDRT() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x70) >> 4
}

// PWR.CR3: Power control register 3
func (o *PWR_Type) SetCR3_EWUP1(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR3_EWUP1() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}
func (o *PWR_Type) SetCR3_EWUP2(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR3_EWUP2() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR3_EWUP4(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR3_EWUP4() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR3_EWUP5(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR3_EWUP5() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR3_EWUP6(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCR3_EWUP6() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCR3_RRS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR3_RRS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR3_ULPEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR3_ULPEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR3_APC(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCR3_APC() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCR3_EIWUL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetCR3_EIWUL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}

// PWR.CR4: Power control register 4
func (o *PWR_Type) SetCR4_WP1(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR4_WP1() uint32 {
	return volatile.LoadUint32(&o.CR4.Reg) & 0x1
}
func (o *PWR_Type) SetCR4_WP2(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR4_WP2() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR4_WP4(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR4_WP4() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR4_WP5(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR4_WP5() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR4_WP6(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCR4_WP6() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCR4_VBE(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR4_VBE() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR4_VBRS(value uint32) {
	volatile.StoreUint32(&o.CR4.Reg, volatile.LoadUint32(&o.CR4.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR4_VBRS() uint32 {
	return (volatile.LoadUint32(&o.CR4.Reg) & 0x200) >> 9
}

// PWR.SR1: Power status register 1
func (o *PWR_Type) SetSR1_WUF1(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetSR1_WUF1() uint32 {
	return volatile.LoadUint32(&o.SR1.Reg) & 0x1
}
func (o *PWR_Type) SetSR1_WUF2(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSR1_WUF2() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetSR1_WUF4(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetSR1_WUF4() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetSR1_WUF5(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetSR1_WUF5() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetSR1_WUF6(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetSR1_WUF6() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetSR1_SBF(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSR1_SBF() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSR1_WUFI(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetSR1_WUFI() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8000) >> 15
}

// PWR.SR2: Power status register 2
func (o *PWR_Type) SetSR2_PVDO(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetSR2_PVDO() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetSR2_VOSF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetSR2_VOSF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetSR2_REGLPF(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetSR2_REGLPF() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetSR2_REGLPS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSR2_REGLPS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSR2_FLASH_RDY(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetSR2_FLASH_RDY() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x80) >> 7
}

// PWR.SCR: Power status clear register
func (o *PWR_Type) SetSCR_CSBF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetSCR_CSBF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetSCR_CWUF6(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetSCR_CWUF6() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetSCR_CWUF5(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetSCR_CWUF5() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetSCR_CWUF4(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetSCR_CWUF4() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetSCR_CWUF2(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetSCR_CWUF2() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetSCR_CWUF1(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetSCR_CWUF1() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}

// PWR.PUCRA: Power Port A pull-up control register
func (o *PWR_Type) SetPUCRA_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRA_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRA_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRA_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRA_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRA_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRA_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRA_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRA_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRA_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRA_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRA_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRA_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRA_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRA_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRA_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRA_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRA_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRA_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRA_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRA_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRA_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRA_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRA_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRA_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRA_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRA_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRA_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRA_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRA_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRA.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRA_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRA.Reg, volatile.LoadUint32(&o.PUCRA.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRA_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRA.Reg) & 0x1
}

// PWR.PDCRA: Power Port A pull-down control register
func (o *PWR_Type) SetPDCRA_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRA_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRA_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRA_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRA_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRA_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRA_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRA_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRA_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRA_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRA_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRA_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRA_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRA_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRA_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRA_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRA_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRA_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRA_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRA_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRA_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRA_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRA_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRA_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRA_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRA_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRA_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRA_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRA_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRA_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRA.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRA_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRA.Reg, volatile.LoadUint32(&o.PDCRA.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRA_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRA.Reg) & 0x1
}

// PWR.PUCRB: Power Port B pull-up control register
func (o *PWR_Type) SetPUCRB_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRB_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRB_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRB_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRB_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRB_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRB_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRB_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRB_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRB_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRB_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRB_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRB_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRB_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRB_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRB_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRB_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRB_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRB_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRB_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRB_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRB_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRB_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRB_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRB_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRB_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRB_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRB_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRB_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRB_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRB.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRB_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRB.Reg, volatile.LoadUint32(&o.PUCRB.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRB_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRB.Reg) & 0x1
}

// PWR.PDCRB: Power Port B pull-down control register
func (o *PWR_Type) SetPDCRB_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRB_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRB_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRB_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRB_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRB_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRB_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRB_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRB_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRB_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRB_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRB_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRB_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRB_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRB_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRB_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRB_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRB_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRB_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRB_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRB_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRB_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRB_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRB_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRB_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRB_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRB_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRB_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRB_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRB_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRB.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRB_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRB.Reg, volatile.LoadUint32(&o.PDCRB.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRB_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRB.Reg) & 0x1
}

// PWR.PUCRC: Power Port C pull-up control register
func (o *PWR_Type) SetPUCRC_PU15(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPUCRC_PU15() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPUCRC_PU14(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPUCRC_PU14() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPUCRC_PU13(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPUCRC_PU13() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPUCRC_PU12(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPUCRC_PU12() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPUCRC_PU11(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPUCRC_PU11() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPUCRC_PU10(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPUCRC_PU10() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPUCRC_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRC_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRC_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRC_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRC_PU7(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPUCRC_PU7() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPUCRC_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRC_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRC_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRC_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRC_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRC_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRC_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRC_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRC_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRC_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRC_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRC_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRC.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRC_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRC.Reg, volatile.LoadUint32(&o.PUCRC.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRC_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRC.Reg) & 0x1
}

// PWR.PDCRC: Power Port C pull-down control register
func (o *PWR_Type) SetPDCRC_PD15(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x8000)|value<<15)
}
func (o *PWR_Type) GetPDCRC_PD15() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x8000) >> 15
}
func (o *PWR_Type) SetPDCRC_PD14(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetPDCRC_PD14() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetPDCRC_PD13(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetPDCRC_PD13() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetPDCRC_PD12(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetPDCRC_PD12() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetPDCRC_PD11(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetPDCRC_PD11() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetPDCRC_PD10(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetPDCRC_PD10() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetPDCRC_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRC_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRC_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRC_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRC_PD7(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x80)|value<<7)
}
func (o *PWR_Type) GetPDCRC_PD7() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x80) >> 7
}
func (o *PWR_Type) SetPDCRC_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRC_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRC_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRC_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRC_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRC_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRC_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRC_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRC_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRC_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRC_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRC_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRC.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRC_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRC.Reg, volatile.LoadUint32(&o.PDCRC.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRC_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRC.Reg) & 0x1
}

// PWR.PUCRD: Power Port D pull-up control register
func (o *PWR_Type) SetPUCRD_PU9(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPUCRD_PU9() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPUCRD_PU8(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPUCRD_PU8() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPUCRD_PU6(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPUCRD_PU6() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPUCRD_PU5(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPUCRD_PU5() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPUCRD_PU4(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPUCRD_PU4() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPUCRD_PU3(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPUCRD_PU3() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPUCRD_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRD_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRD_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRD_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRD.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRD_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRD.Reg, volatile.LoadUint32(&o.PUCRD.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRD_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRD.Reg) & 0x1
}

// PWR.PDCRD: Power Port D pull-down control register
func (o *PWR_Type) SetPDCRD_PD9(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetPDCRD_PD9() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetPDCRD_PD8(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetPDCRD_PD8() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetPDCRD_PD6(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x40)|value<<6)
}
func (o *PWR_Type) GetPDCRD_PD6() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x40) >> 6
}
func (o *PWR_Type) SetPDCRD_PD5(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetPDCRD_PD5() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetPDCRD_PD4(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetPDCRD_PD4() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetPDCRD_PD3(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetPDCRD_PD3() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetPDCRD_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRD_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRD_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRD_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRD.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRD_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRD.Reg, volatile.LoadUint32(&o.PDCRD.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRD_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRD.Reg) & 0x1
}

// PWR.PUCRF: Power Port F pull-up control register
func (o *PWR_Type) SetPUCRF_PU2(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPUCRF_PU2() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPUCRF_PU1(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPUCRF_PU1() uint32 {
	return (volatile.LoadUint32(&o.PUCRF.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPUCRF_PU0(value uint32) {
	volatile.StoreUint32(&o.PUCRF.Reg, volatile.LoadUint32(&o.PUCRF.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPUCRF_PU0() uint32 {
	return volatile.LoadUint32(&o.PUCRF.Reg) & 0x1
}

// PWR.PDCRF: Power Port F pull-down control register
func (o *PWR_Type) SetPDCRF_PD2(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetPDCRF_PD2() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetPDCRF_PD1(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetPDCRF_PD1() uint32 {
	return (volatile.LoadUint32(&o.PDCRF.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetPDCRF_PD0(value uint32) {
	volatile.StoreUint32(&o.PDCRF.Reg, volatile.LoadUint32(&o.PDCRF.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetPDCRF_PD0() uint32 {
	return volatile.LoadUint32(&o.PDCRF.Reg) & 0x1
}

// DMA controller
type DMA_Type struct {
	ISR  volatile.Register32 // 0x0
	IFCR volatile.Register32 // 0x4
	CH   [7]DMA_CH_Type      // 0x8
}

// DMA.ISR: low interrupt status register
func (o *DMA_Type) SetISR_GIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetISR_GIF1() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *DMA_Type) SetISR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetISR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetISR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetISR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetISR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetISR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetISR_GIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetISR_GIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetISR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetISR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetISR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetISR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetISR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetISR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetISR_GIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetISR_GIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetISR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetISR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetISR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetISR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetISR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetISR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetISR_GIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetISR_GIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetISR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetISR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetISR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetISR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetISR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetISR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetISR_GIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetISR_GIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetISR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetISR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetISR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetISR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetISR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetISR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetISR_GIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetISR_GIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetISR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetISR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetISR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetISR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetISR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetISR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetISR_GIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetISR_GIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetISR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetISR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetISR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetISR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetISR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetISR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}

// DMA.IFCR: high interrupt status register
func (o *DMA_Type) SetIFCR_CGIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetIFCR_CGIF1() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}
func (o *DMA_Type) SetIFCR_CTCIF1(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetIFCR_CTCIF1() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetIFCR_CHTIF2(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetIFCR_CHTIF2() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetIFCR_CTEIF3(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetIFCR_CTEIF3() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetIFCR_CGIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetIFCR_CGIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetIFCR_CTCIF5(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetIFCR_CTCIF5() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetIFCR_CHTIF6(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetIFCR_CHTIF6() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetIFCR_CTEIF7(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetIFCR_CTEIF7() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetIFCR_CGIF8(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetIFCR_CGIF8() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetIFCR_CTCIF9(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetIFCR_CTCIF9() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetIFCR_CHTIF10(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetIFCR_CHTIF10() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetIFCR_CTEIF11(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetIFCR_CTEIF11() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetIFCR_CGIF12(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetIFCR_CGIF12() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetIFCR_CTCIF13(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetIFCR_CTCIF13() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetIFCR_CHTIF14(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetIFCR_CHTIF14() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetIFCR_CTEIF4(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetIFCR_CTEIF4() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000) >> 15
}
func (o *DMA_Type) SetIFCR_CGIF16(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetIFCR_CGIF16() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetIFCR_CTCIF17(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetIFCR_CTCIF17() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetIFCR_CHTIF18(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetIFCR_CHTIF18() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetIFCR_CTEIF19(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetIFCR_CTEIF19() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetIFCR_CGIF20(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetIFCR_CGIF20() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetIFCR_CTCIF21(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetIFCR_CTCIF21() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetIFCR_CHTIF22(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetIFCR_CHTIF22() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetIFCR_CTEIF23(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetIFCR_CTEIF23() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetIFCR_CGIF24(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetIFCR_CGIF24() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetIFCR_CTCIF25(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetIFCR_CTCIF25() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetIFCR_CHTIF26(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetIFCR_CHTIF26() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetIFCR_CTEIF27(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetIFCR_CTEIF27() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8000000) >> 27
}

// Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
type DMA_CH_Type struct {
	CR   volatile.Register32 // 0x8
	NDTR volatile.Register32 // 0xC
	PAR  volatile.Register32 // 0x10
	MAR  volatile.Register32 // 0x14
	_    [4]byte
}

// DMA_CH.CR: DMA channel x configuration register
func (o *DMA_CH_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DMA_CH_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DMA_CH_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_CH_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA_CH_Type) SetCR_HTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_CH_Type) GetCR_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA_CH_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_CH_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DMA_CH_Type) SetCR_DIR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_CH_Type) GetCR_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DMA_CH_Type) SetCR_CIRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_CH_Type) GetCR_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DMA_CH_Type) SetCR_PINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_CH_Type) GetCR_PINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DMA_CH_Type) SetCR_MINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_CH_Type) GetCR_MINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DMA_CH_Type) SetCR_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *DMA_CH_Type) GetCR_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *DMA_CH_Type) SetCR_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *DMA_CH_Type) GetCR_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *DMA_CH_Type) SetCR_PL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3000)|value<<12)
}
func (o *DMA_CH_Type) GetCR_PL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3000) >> 12
}
func (o *DMA_CH_Type) SetCR_MEM2MEM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_CH_Type) GetCR_MEM2MEM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}

// DMA_CH.NDTR: DMA channel x number of data register
func (o *DMA_CH_Type) SetNDTR_NDT(value uint32) {
	volatile.StoreUint32(&o.NDTR.Reg, volatile.LoadUint32(&o.NDTR.Reg)&^(0xffff)|value)
}
func (o *DMA_CH_Type) GetNDTR_NDT() uint32 {
	return volatile.LoadUint32(&o.NDTR.Reg) & 0xffff
}

// DMA_CH.PAR: DMA channel x peripheral address register
func (o *DMA_CH_Type) SetPAR(value uint32) {
	volatile.StoreUint32(&o.PAR.Reg, value)
}
func (o *DMA_CH_Type) GetPAR() uint32 {
	return volatile.LoadUint32(&o.PAR.Reg)
}

// DMA_CH.MAR: DMA channel x memory address register
func (o *DMA_CH_Type) SetMAR(value uint32) {
	volatile.StoreUint32(&o.MAR.Reg, value)
}
func (o *DMA_CH_Type) GetMAR() uint32 {
	return volatile.LoadUint32(&o.MAR.Reg)
}

// DMAMUX
type DMAMUX_Type struct {
	C0CR    volatile.Register32 // 0x0
	C1CR    volatile.Register32 // 0x4
	C2CR    volatile.Register32 // 0x8
	C3CR    volatile.Register32 // 0xC
	C4CR    volatile.Register32 // 0x10
	C5CR    volatile.Register32 // 0x14
	C6CR    volatile.Register32 // 0x18
	_       [100]byte
	CSR     volatile.Register32 // 0x80
	CFR     volatile.Register32 // 0x84
	_       [120]byte
	RG0CR   volatile.Register32 // 0x100
	RG1CR   volatile.Register32 // 0x104
	RG2CR   volatile.Register32 // 0x108
	RG3CR   volatile.Register32 // 0x10C
	_       [48]byte
	RGSR    volatile.Register32 // 0x140
	RGCFR   volatile.Register32 // 0x144
	_       [676]byte
	HWCFGR2 volatile.Register32 // 0x3EC
	HWCFGR1 volatile.Register32 // 0x3F0
	VERR    volatile.Register32 // 0x3F4
	IPIDR   volatile.Register32 // 0x3F8
	SIDR    volatile.Register32 // 0x3FC
}

// DMAMUX.C0CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC0CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC0CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C0CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC0CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC0CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC0CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC0CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC0CR_SE(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC0CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC0CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC0CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC0CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC0CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC0CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C0CR.Reg, volatile.LoadUint32(&o.C0CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC0CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C0CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.C1CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC1CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC1CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C1CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC1CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC1CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC1CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC1CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC1CR_SE(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC1CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC1CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC1CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC1CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC1CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC1CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C1CR.Reg, volatile.LoadUint32(&o.C1CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC1CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C1CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.C2CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC2CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC2CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C2CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC2CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC2CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC2CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC2CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC2CR_SE(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC2CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC2CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC2CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC2CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC2CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC2CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C2CR.Reg, volatile.LoadUint32(&o.C2CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC2CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C2CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.C3CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC3CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC3CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C3CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC3CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC3CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC3CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC3CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC3CR_SE(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC3CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC3CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC3CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC3CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC3CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC3CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C3CR.Reg, volatile.LoadUint32(&o.C3CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC3CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C3CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.C4CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC4CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC4CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C4CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC4CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC4CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC4CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC4CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC4CR_SE(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC4CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC4CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC4CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC4CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC4CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC4CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C4CR.Reg, volatile.LoadUint32(&o.C4CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC4CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C4CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.C5CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC5CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC5CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C5CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC5CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC5CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC5CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC5CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC5CR_SE(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC5CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC5CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC5CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC5CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC5CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC5CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C5CR.Reg, volatile.LoadUint32(&o.C5CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC5CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C5CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.C6CR: DMAMux - DMA request line multiplexer channel x control register
func (o *DMAMUX_Type) SetC6CR_DMAREQ_ID(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetC6CR_DMAREQ_ID() uint32 {
	return volatile.LoadUint32(&o.C6CR.Reg) & 0xff
}
func (o *DMAMUX_Type) SetC6CR_SOIE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetC6CR_SOIE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetC6CR_EGE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x200)|value<<9)
}
func (o *DMAMUX_Type) GetC6CR_EGE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x200) >> 9
}
func (o *DMAMUX_Type) SetC6CR_SE(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetC6CR_SE() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetC6CR_SPOL(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetC6CR_SPOL() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetC6CR_NBREQ(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetC6CR_NBREQ() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0xf80000) >> 19
}
func (o *DMAMUX_Type) SetC6CR_SYNC_ID(value uint32) {
	volatile.StoreUint32(&o.C6CR.Reg, volatile.LoadUint32(&o.C6CR.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAMUX_Type) GetC6CR_SYNC_ID() uint32 {
	return (volatile.LoadUint32(&o.C6CR.Reg) & 0x1f000000) >> 24
}

// DMAMUX.CSR: DMAMUX request line multiplexer interrupt channel status register
func (o *DMAMUX_Type) SetCSR_SOF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetCSR_SOF() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x7f
}

// DMAMUX.CFR: DMAMUX request line multiplexer interrupt clear flag register
func (o *DMAMUX_Type) SetCFR_CSOF(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetCFR_CSOF() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x7f
}

// DMAMUX.RG0CR: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRG0CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG0CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG0CR.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRG0CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG0CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG0CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG0CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG0CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG0CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG0CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG0CR.Reg, volatile.LoadUint32(&o.RG0CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG0CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG0CR.Reg) & 0xf80000) >> 19
}

// DMAMUX.RG1CR: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRG1CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG1CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG1CR.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRG1CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG1CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG1CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG1CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG1CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG1CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG1CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG1CR.Reg, volatile.LoadUint32(&o.RG1CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG1CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG1CR.Reg) & 0xf80000) >> 19
}

// DMAMUX.RG2CR: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRG2CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG2CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG2CR.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRG2CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG2CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG2CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG2CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG2CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG2CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG2CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG2CR.Reg, volatile.LoadUint32(&o.RG2CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG2CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG2CR.Reg) & 0xf80000) >> 19
}

// DMAMUX.RG3CR: DMAMux - DMA request generator channel x control register
func (o *DMAMUX_Type) SetRG3CR_SIG_ID(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x1f)|value)
}
func (o *DMAMUX_Type) GetRG3CR_SIG_ID() uint32 {
	return volatile.LoadUint32(&o.RG3CR.Reg) & 0x1f
}
func (o *DMAMUX_Type) SetRG3CR_OIE(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x100)|value<<8)
}
func (o *DMAMUX_Type) GetRG3CR_OIE() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x100) >> 8
}
func (o *DMAMUX_Type) SetRG3CR_GE(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAMUX_Type) GetRG3CR_GE() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x10000) >> 16
}
func (o *DMAMUX_Type) SetRG3CR_GPOL(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0x60000)|value<<17)
}
func (o *DMAMUX_Type) GetRG3CR_GPOL() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0x60000) >> 17
}
func (o *DMAMUX_Type) SetRG3CR_GNBREQ(value uint32) {
	volatile.StoreUint32(&o.RG3CR.Reg, volatile.LoadUint32(&o.RG3CR.Reg)&^(0xf80000)|value<<19)
}
func (o *DMAMUX_Type) GetRG3CR_GNBREQ() uint32 {
	return (volatile.LoadUint32(&o.RG3CR.Reg) & 0xf80000) >> 19
}

// DMAMUX.RGSR: DMAMux - DMA request generator status register
func (o *DMAMUX_Type) SetRGSR_OF(value uint32) {
	volatile.StoreUint32(&o.RGSR.Reg, volatile.LoadUint32(&o.RGSR.Reg)&^(0xf)|value)
}
func (o *DMAMUX_Type) GetRGSR_OF() uint32 {
	return volatile.LoadUint32(&o.RGSR.Reg) & 0xf
}

// DMAMUX.RGCFR: DMAMux - DMA request generator clear flag register
func (o *DMAMUX_Type) SetRGCFR_COF(value uint32) {
	volatile.StoreUint32(&o.RGCFR.Reg, volatile.LoadUint32(&o.RGCFR.Reg)&^(0xf)|value)
}
func (o *DMAMUX_Type) GetRGCFR_COF() uint32 {
	return volatile.LoadUint32(&o.RGCFR.Reg) & 0xf
}

// DMAMUX.HWCFGR2: DMAMUX hardware configuration 2 register
func (o *DMAMUX_Type) SetHWCFGR2_NUM_DMA_EXT_REQ(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetHWCFGR2_NUM_DMA_EXT_REQ() uint32 {
	return volatile.LoadUint32(&o.HWCFGR2.Reg) & 0xff
}

// DMAMUX.HWCFGR1: DMAMUX hardware configuration 1 register
func (o *DMAMUX_Type) SetHWCFGR1_NUM_DMA_STREAMS(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff)|value)
}
func (o *DMAMUX_Type) GetHWCFGR1_NUM_DMA_STREAMS() uint32 {
	return volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff
}
func (o *DMAMUX_Type) SetHWCFGR1_NUM_DMA_PERIPH_REQ(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff00)|value<<8)
}
func (o *DMAMUX_Type) GetHWCFGR1_NUM_DMA_PERIPH_REQ() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff00) >> 8
}
func (o *DMAMUX_Type) SetHWCFGR1_NUM_DMA_TRIG(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff0000)|value<<16)
}
func (o *DMAMUX_Type) GetHWCFGR1_NUM_DMA_TRIG() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff0000) >> 16
}
func (o *DMAMUX_Type) SetHWCFGR1_NUM_DMA_REQGEN(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff000000)|value<<24)
}
func (o *DMAMUX_Type) GetHWCFGR1_NUM_DMA_REQGEN() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff000000) >> 24
}

// DMAMUX.VERR: DMAMUX version register
func (o *DMAMUX_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *DMAMUX_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *DMAMUX_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *DMAMUX_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// DMAMUX.IPIDR: DMAMUX IP identification register
func (o *DMAMUX_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *DMAMUX_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// DMAMUX.SIDR: DMAMUX size identification register
func (o *DMAMUX_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *DMAMUX_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// General-purpose I/Os
type GPIO_Type struct {
	MODER   volatile.Register32 // 0x0
	OTYPER  volatile.Register32 // 0x4
	OSPEEDR volatile.Register32 // 0x8
	PUPDR   volatile.Register32 // 0xC
	IDR     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	BSRR    volatile.Register32 // 0x18
	LCKR    volatile.Register32 // 0x1C
	AFRL    volatile.Register32 // 0x20
	AFRH    volatile.Register32 // 0x24
	BRR     volatile.Register32 // 0x28
}

// GPIO.MODER: GPIO port mode register
func (o *GPIO_Type) SetMODER_MODER15(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetMODER_MODER15() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetMODER_MODER14(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetMODER_MODER14() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetMODER_MODER13(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetMODER_MODER13() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetMODER_MODER12(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetMODER_MODER12() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetMODER_MODER11(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetMODER_MODER11() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetMODER_MODER10(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetMODER_MODER10() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetMODER_MODER9(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetMODER_MODER9() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetMODER_MODER8(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetMODER_MODER8() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetMODER_MODER7(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetMODER_MODER7() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetMODER_MODER6(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetMODER_MODER6() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetMODER_MODER5(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetMODER_MODER5() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetMODER_MODER4(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetMODER_MODER4() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetMODER_MODER3(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetMODER_MODER3() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetMODER_MODER2(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetMODER_MODER2() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetMODER_MODER1(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetMODER_MODER1() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetMODER_MODER0(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetMODER_MODER0() uint32 {
	return volatile.LoadUint32(&o.MODER.Reg) & 0x3
}

// GPIO.OTYPER: GPIO port output type register
func (o *GPIO_Type) SetOTYPER_OT15(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOTYPER_OT15() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOTYPER_OT14(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOTYPER_OT14() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOTYPER_OT13(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOTYPER_OT13() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOTYPER_OT12(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOTYPER_OT12() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOTYPER_OT11(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOTYPER_OT11() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOTYPER_OT10(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOTYPER_OT10() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOTYPER_OT9(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOTYPER_OT9() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOTYPER_OT8(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOTYPER_OT8() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOTYPER_OT7(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOTYPER_OT7() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOTYPER_OT6(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOTYPER_OT6() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOTYPER_OT5(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOTYPER_OT5() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOTYPER_OT4(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOTYPER_OT4() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOTYPER_OT3(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOTYPER_OT3() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOTYPER_OT2(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOTYPER_OT2() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOTYPER_OT1(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOTYPER_OT1() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOTYPER_OT0(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOTYPER_OT0() uint32 {
	return volatile.LoadUint32(&o.OTYPER.Reg) & 0x1
}

// GPIO.OSPEEDR: GPIO port output speed register
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR15(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR15() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR14(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR14() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR13(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR13() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR12(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR12() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR11(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR11() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR10(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR10() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR9(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR9() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR8(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR8() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR7(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR7() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR6(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR6() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR5(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR5() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR4(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR4() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR3(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR3() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR2(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR2() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR1(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR1() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR0(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR0() uint32 {
	return volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3
}

// GPIO.PUPDR: GPIO port pull-up/pull-down register
func (o *GPIO_Type) SetPUPDR_PUPDR15(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetPUPDR_PUPDR15() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetPUPDR_PUPDR14(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetPUPDR_PUPDR14() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetPUPDR_PUPDR13(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetPUPDR_PUPDR13() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetPUPDR_PUPDR12(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetPUPDR_PUPDR12() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetPUPDR_PUPDR11(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetPUPDR_PUPDR11() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetPUPDR_PUPDR10(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetPUPDR_PUPDR10() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetPUPDR_PUPDR9(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetPUPDR_PUPDR9() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetPUPDR_PUPDR8(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPUPDR_PUPDR8() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetPUPDR_PUPDR7(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetPUPDR_PUPDR7() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetPUPDR_PUPDR6(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetPUPDR_PUPDR6() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetPUPDR_PUPDR5(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetPUPDR_PUPDR5() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetPUPDR_PUPDR4(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetPUPDR_PUPDR4() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetPUPDR_PUPDR3(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetPUPDR_PUPDR3() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetPUPDR_PUPDR2(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetPUPDR_PUPDR2() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetPUPDR_PUPDR1(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPUPDR_PUPDR1() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPUPDR_PUPDR0(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPUPDR_PUPDR0() uint32 {
	return volatile.LoadUint32(&o.PUPDR.Reg) & 0x3
}

// GPIO.IDR: GPIO port input data register
func (o *GPIO_Type) SetIDR_IDR15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIDR_IDR15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIDR_IDR14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIDR_IDR14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIDR_IDR13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIDR_IDR13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIDR_IDR12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIDR_IDR12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIDR_IDR11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIDR_IDR11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIDR_IDR10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIDR_IDR10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIDR_IDR9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIDR_IDR9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIDR_IDR8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIDR_IDR8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIDR_IDR7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIDR_IDR7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIDR_IDR6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIDR_IDR6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIDR_IDR5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIDR_IDR5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIDR_IDR4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIDR_IDR4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIDR_IDR3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIDR_IDR3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIDR_IDR2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIDR_IDR2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIDR_IDR1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIDR_IDR1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIDR_IDR0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIDR_IDR0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// GPIO.ODR: GPIO port output data register
func (o *GPIO_Type) SetODR_ODR15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetODR_ODR15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetODR_ODR14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetODR_ODR14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetODR_ODR13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetODR_ODR13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetODR_ODR12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetODR_ODR12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetODR_ODR11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetODR_ODR11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetODR_ODR10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetODR_ODR10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetODR_ODR9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetODR_ODR9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetODR_ODR8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetODR_ODR8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetODR_ODR7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetODR_ODR7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetODR_ODR6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetODR_ODR6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetODR_ODR5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetODR_ODR5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetODR_ODR4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetODR_ODR4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetODR_ODR3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetODR_ODR3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetODR_ODR2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetODR_ODR2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetODR_ODR1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetODR_ODR1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetODR_ODR0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetODR_ODR0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}

// GPIO.BSRR: GPIO port bit set/reset register
func (o *GPIO_Type) SetBSRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetBSRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000000) >> 31
}
func (o *GPIO_Type) SetBSRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetBSRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetBSRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetBSRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetBSRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetBSRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetBSRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetBSRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetBSRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetBSRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetBSRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetBSRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetBSRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetBSRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetBSRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetBSRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetBSRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetBSRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetBSRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetBSRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetBSRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetBSRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetBSRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetBSRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetBSRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetBSRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetBSRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetBSRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetBSRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetBSRR_BR0() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetBSRR_BS15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBSRR_BS15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetBSRR_BS14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBSRR_BS14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBSRR_BS13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBSRR_BS13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBSRR_BS12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBSRR_BS12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBSRR_BS11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBSRR_BS11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBSRR_BS10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBSRR_BS10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBSRR_BS9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBSRR_BS9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBSRR_BS8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBSRR_BS8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBSRR_BS7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBSRR_BS7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBSRR_BS6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBSRR_BS6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBSRR_BS5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBSRR_BS5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBSRR_BS4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBSRR_BS4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBSRR_BS3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBSRR_BS3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBSRR_BS2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBSRR_BS2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBSRR_BS1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBSRR_BS1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBSRR_BS0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBSRR_BS0() uint32 {
	return volatile.LoadUint32(&o.BSRR.Reg) & 0x1
}

// GPIO.LCKR: GPIO port configuration lock register
func (o *GPIO_Type) SetLCKR_LCKK(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLCKR_LCKK() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLCKR_LCK15(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLCKR_LCK15() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLCKR_LCK14(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLCKR_LCK14() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLCKR_LCK13(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLCKR_LCK13() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLCKR_LCK12(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLCKR_LCK12() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLCKR_LCK11(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLCKR_LCK11() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLCKR_LCK10(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLCKR_LCK10() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLCKR_LCK9(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLCKR_LCK9() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLCKR_LCK8(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLCKR_LCK8() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLCKR_LCK7(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLCKR_LCK7() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLCKR_LCK6(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLCKR_LCK6() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLCKR_LCK5(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLCKR_LCK5() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLCKR_LCK4(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLCKR_LCK4() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLCKR_LCK3(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLCKR_LCK3() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLCKR_LCK2(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLCKR_LCK2() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLCKR_LCK1(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLCKR_LCK1() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLCKR_LCK0(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLCKR_LCK0() uint32 {
	return volatile.LoadUint32(&o.LCKR.Reg) & 0x1
}

// GPIO.AFRL: GPIO alternate function low register
func (o *GPIO_Type) SetAFRL_AFSEL7(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRL_AFSEL7() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRL_AFSEL6(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRL_AFSEL6() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRL_AFSEL5(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRL_AFSEL5() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRL_AFSEL4(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRL_AFSEL4() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRL_AFSEL3(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRL_AFSEL3() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRL_AFSEL2(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRL_AFSEL2() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRL_AFSEL1(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRL_AFSEL1() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRL_AFSEL0(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRL_AFSEL0() uint32 {
	return volatile.LoadUint32(&o.AFRL.Reg) & 0xf
}

// GPIO.AFRH: GPIO alternate function high register
func (o *GPIO_Type) SetAFRH_AFSEL15(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRH_AFSEL15() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRH_AFSEL14(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRH_AFSEL14() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRH_AFSEL13(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRH_AFSEL13() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRH_AFSEL12(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRH_AFSEL12() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRH_AFSEL11(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRH_AFSEL11() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRH_AFSEL10(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRH_AFSEL10() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRH_AFSEL9(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRH_AFSEL9() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRH_AFSEL8(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRH_AFSEL8() uint32 {
	return volatile.LoadUint32(&o.AFRH.Reg) & 0xf
}

// GPIO.BRR: port bit reset register
func (o *GPIO_Type) SetBRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBRR_BR0() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0x1
}
func (o *GPIO_Type) SetBRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8000) >> 15
}

// Cyclic redundancy check calculation unit
type CRC_Type struct {
	DR   volatile.Register32 // 0x0
	IDR  volatile.Register32 // 0x4
	CR   volatile.Register32 // 0x8
	_    [4]byte
	INIT volatile.Register32 // 0x10
	POL  volatile.Register32 // 0x14
}

// CRC.DR: Data register
func (o *CRC_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *CRC_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// CRC.IDR: Independent data register
func (o *CRC_Type) SetIDR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, value)
}
func (o *CRC_Type) GetIDR() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg)
}

// CRC.CR: Control register
func (o *CRC_Type) SetCR_REV_OUT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCR_REV_OUT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCR_REV_IN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *CRC_Type) GetCR_REV_IN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *CRC_Type) SetCR_POLYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *CRC_Type) GetCR_POLYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}
func (o *CRC_Type) SetCR_RESET(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRC_Type) GetCR_RESET() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// CRC.INIT: Initial CRC value
func (o *CRC_Type) SetINIT(value uint32) {
	volatile.StoreUint32(&o.INIT.Reg, value)
}
func (o *CRC_Type) GetINIT() uint32 {
	return volatile.LoadUint32(&o.INIT.Reg)
}

// CRC.POL: polynomial
func (o *CRC_Type) SetPOL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, value)
}
func (o *CRC_Type) GetPOL() uint32 {
	return volatile.LoadUint32(&o.POL.Reg)
}

// External interrupt/event controller
type EXTI_Type struct {
	RTSR1   volatile.Register32 // 0x0
	FTSR1   volatile.Register32 // 0x4
	SWIER1  volatile.Register32 // 0x8
	RPR1    volatile.Register32 // 0xC
	FPR1    volatile.Register32 // 0x10
	_       [76]byte
	EXTICR1 volatile.Register32 // 0x60
	EXTICR2 volatile.Register32 // 0x64
	EXTICR3 volatile.Register32 // 0x68
	EXTICR4 volatile.Register32 // 0x6C
	_       [16]byte
	IMR1    volatile.Register32 // 0x80
	EMR1    volatile.Register32 // 0x84
	_       [8]byte
	IMR2    volatile.Register32 // 0x90
	EMR2    volatile.Register32 // 0x94
	_       [832]byte
	HWCFGR7 volatile.Register32 // 0x3D8
	HWCFGR6 volatile.Register32 // 0x3DC
	HWCFGR5 volatile.Register32 // 0x3E0
	HWCFGR4 volatile.Register32 // 0x3E4
	HWCFGR3 volatile.Register32 // 0x3E8
	HWCFGR2 volatile.Register32 // 0x3EC
	HWCFGR1 volatile.Register32 // 0x3F0
}

// EXTI.RTSR1: EXTI rising trigger selection register
func (o *EXTI_Type) SetRTSR1_TR0(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRTSR1_TR0() uint32 {
	return volatile.LoadUint32(&o.RTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetRTSR1_TR1(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRTSR1_TR1() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRTSR1_TR2(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTSR1_TR2() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTSR1_TR3(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTSR1_TR3() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTSR1_TR4(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTSR1_TR4() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTSR1_TR5(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTSR1_TR5() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTSR1_TR6(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTSR1_TR6() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRTSR1_TR7(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRTSR1_TR7() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRTSR1_TR8(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRTSR1_TR8() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRTSR1_TR9(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRTSR1_TR9() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetRTSR1_TR10(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetRTSR1_TR10() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetRTSR1_TR11(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetRTSR1_TR11() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetRTSR1_TR12(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetRTSR1_TR12() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetRTSR1_TR13(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRTSR1_TR13() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetRTSR1_TR14(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetRTSR1_TR14() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetRTSR1_TR15(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetRTSR1_TR15() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetRTSR1_TR16(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetRTSR1_TR16() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetRTSR1_TR17(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetRTSR1_TR17() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetRTSR1_TR18(value uint32) {
	volatile.StoreUint32(&o.RTSR1.Reg, volatile.LoadUint32(&o.RTSR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetRTSR1_TR18() uint32 {
	return (volatile.LoadUint32(&o.RTSR1.Reg) & 0x40000) >> 18
}

// EXTI.FTSR1: EXTI falling trigger selection register
func (o *EXTI_Type) SetFTSR1_TR0(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFTSR1_TR0() uint32 {
	return volatile.LoadUint32(&o.FTSR1.Reg) & 0x1
}
func (o *EXTI_Type) SetFTSR1_TR1(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFTSR1_TR1() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFTSR1_TR2(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTSR1_TR2() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTSR1_TR3(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTSR1_TR3() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTSR1_TR4(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTSR1_TR4() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTSR1_TR5(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTSR1_TR5() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTSR1_TR6(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTSR1_TR6() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFTSR1_TR7(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFTSR1_TR7() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFTSR1_TR8(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFTSR1_TR8() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFTSR1_TR9(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFTSR1_TR9() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetFTSR1_TR10(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetFTSR1_TR10() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetFTSR1_TR11(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetFTSR1_TR11() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetFTSR1_TR12(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetFTSR1_TR12() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetFTSR1_TR13(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFTSR1_TR13() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetFTSR1_TR14(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetFTSR1_TR14() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetFTSR1_TR15(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetFTSR1_TR15() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetFTSR1_TR16(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetFTSR1_TR16() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetFTSR1_TR17(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetFTSR1_TR17() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetFTSR1_TR18(value uint32) {
	volatile.StoreUint32(&o.FTSR1.Reg, volatile.LoadUint32(&o.FTSR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetFTSR1_TR18() uint32 {
	return (volatile.LoadUint32(&o.FTSR1.Reg) & 0x40000) >> 18
}

// EXTI.SWIER1: EXTI software interrupt event register
func (o *EXTI_Type) SetSWIER1_SWIER0(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetSWIER1_SWIER0() uint32 {
	return volatile.LoadUint32(&o.SWIER1.Reg) & 0x1
}
func (o *EXTI_Type) SetSWIER1(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetSWIER1() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetSWIER1_SWIER2(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIER1_SWIER2() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIER1_SWIER3(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIER1_SWIER3() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIER1_SWIER4(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIER1_SWIER4() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIER1_SWIER5(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIER1_SWIER5() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIER1_SWIER6(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIER1_SWIER6() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetSWIER1_SWIER7(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetSWIER1_SWIER7() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetSWIER1_SWIER8(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetSWIER1_SWIER8() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetSWIER1_SWIER9(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetSWIER1_SWIER9() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetSWIER1_SWIER10(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetSWIER1_SWIER10() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetSWIER1_SWIER11(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetSWIER1_SWIER11() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetSWIER1_SWIER12(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetSWIER1_SWIER12() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetSWIER1_SWIER13(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetSWIER1_SWIER13() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetSWIER1_SWIER14(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetSWIER1_SWIER14() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetSWIER1_SWIER15(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetSWIER1_SWIER15() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetSWIER1_SWIER16(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetSWIER1_SWIER16() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetSWIER1_SWIER17(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetSWIER1_SWIER17() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetSWIER1_SWIER18(value uint32) {
	volatile.StoreUint32(&o.SWIER1.Reg, volatile.LoadUint32(&o.SWIER1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetSWIER1_SWIER18() uint32 {
	return (volatile.LoadUint32(&o.SWIER1.Reg) & 0x40000) >> 18
}

// EXTI.RPR1: EXTI rising edge pending register
func (o *EXTI_Type) SetRPR1_RPIF0(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRPR1_RPIF0() uint32 {
	return volatile.LoadUint32(&o.RPR1.Reg) & 0x1
}
func (o *EXTI_Type) SetRPR1_RPIF1(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRPR1_RPIF1() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRPR1_RPIF2(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRPR1_RPIF2() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRPR1_RPIF3(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRPR1_RPIF3() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRPR1_RPIF4(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRPR1_RPIF4() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRPR1_RPIF5(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRPR1_RPIF5() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRPR1_RPIF6(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRPR1_RPIF6() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRPR1_RPIF7(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRPR1_RPIF7() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRPR1_RPIF8(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRPR1_RPIF8() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRPR1_RPIF9(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRPR1_RPIF9() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetRPR1_RPIF10(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetRPR1_RPIF10() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetRPR1_RPIF11(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetRPR1_RPIF11() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetRPR1_RPIF12(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetRPR1_RPIF12() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetRPR1_RPIF13(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRPR1_RPIF13() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetRPR1_RPIF14(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetRPR1_RPIF14() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetRPR1_RPIF15(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetRPR1_RPIF15() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetRPR1_RPIF16(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetRPR1_RPIF16() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetRPR1_RPIF17(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetRPR1_RPIF17() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetRPR1_RPIF18(value uint32) {
	volatile.StoreUint32(&o.RPR1.Reg, volatile.LoadUint32(&o.RPR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetRPR1_RPIF18() uint32 {
	return (volatile.LoadUint32(&o.RPR1.Reg) & 0x40000) >> 18
}

// EXTI.FPR1: EXTI falling edge pending register
func (o *EXTI_Type) SetFPR1_FPIF0(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFPR1_FPIF0() uint32 {
	return volatile.LoadUint32(&o.FPR1.Reg) & 0x1
}
func (o *EXTI_Type) SetFPR1_FPIF1(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFPR1_FPIF1() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFPR1_FPIF2(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFPR1_FPIF2() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFPR1_FPIF3(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFPR1_FPIF3() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFPR1_FPIF4(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFPR1_FPIF4() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFPR1_FPIF5(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFPR1_FPIF5() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFPR1_FPIF6(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFPR1_FPIF6() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFPR1_FPIF7(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFPR1_FPIF7() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFPR1_FPIF8(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFPR1_FPIF8() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFPR1_FPIF9(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFPR1_FPIF9() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetFPR1_FPIF10(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetFPR1_FPIF10() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetFPR1_FPIF11(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetFPR1_FPIF11() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetFPR1_FPIF12(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetFPR1_FPIF12() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetFPR1_FPIF13(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFPR1_FPIF13() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetFPR1_FPIF14(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetFPR1_FPIF14() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetFPR1_FPIF15(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetFPR1_FPIF15() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetFPR1_FPIF16(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetFPR1_FPIF16() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetFPR1_FPIF17(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetFPR1_FPIF17() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetFPR1_FPIF18(value uint32) {
	volatile.StoreUint32(&o.FPR1.Reg, volatile.LoadUint32(&o.FPR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetFPR1_FPIF18() uint32 {
	return (volatile.LoadUint32(&o.FPR1.Reg) & 0x40000) >> 18
}

// EXTI.EXTICR1: EXTI external interrupt selection register
func (o *EXTI_Type) SetEXTICR1_EXTI0_7(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xff)|value)
}
func (o *EXTI_Type) GetEXTICR1_EXTI0_7() uint32 {
	return volatile.LoadUint32(&o.EXTICR1.Reg) & 0xff
}
func (o *EXTI_Type) SetEXTICR1_EXTI8_15(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xff00)|value<<8)
}
func (o *EXTI_Type) GetEXTICR1_EXTI8_15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xff00) >> 8
}
func (o *EXTI_Type) SetEXTICR1_EXTI16_23(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xff0000)|value<<16)
}
func (o *EXTI_Type) GetEXTICR1_EXTI16_23() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xff0000) >> 16
}
func (o *EXTI_Type) SetEXTICR1_EXTI24_31(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xff000000)|value<<24)
}
func (o *EXTI_Type) GetEXTICR1_EXTI24_31() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xff000000) >> 24
}

// EXTI.EXTICR2: EXTI external interrupt selection register
func (o *EXTI_Type) SetEXTICR2_EXTI0_7(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xff)|value)
}
func (o *EXTI_Type) GetEXTICR2_EXTI0_7() uint32 {
	return volatile.LoadUint32(&o.EXTICR2.Reg) & 0xff
}
func (o *EXTI_Type) SetEXTICR2_EXTI8_15(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xff00)|value<<8)
}
func (o *EXTI_Type) GetEXTICR2_EXTI8_15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xff00) >> 8
}
func (o *EXTI_Type) SetEXTICR2_EXTI16_23(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xff0000)|value<<16)
}
func (o *EXTI_Type) GetEXTICR2_EXTI16_23() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xff0000) >> 16
}
func (o *EXTI_Type) SetEXTICR2_EXTI24_31(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xff000000)|value<<24)
}
func (o *EXTI_Type) GetEXTICR2_EXTI24_31() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xff000000) >> 24
}

// EXTI.EXTICR3: EXTI external interrupt selection register
func (o *EXTI_Type) SetEXTICR3_EXTI0_7(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xff)|value)
}
func (o *EXTI_Type) GetEXTICR3_EXTI0_7() uint32 {
	return volatile.LoadUint32(&o.EXTICR3.Reg) & 0xff
}
func (o *EXTI_Type) SetEXTICR3_EXTI8_15(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xff00)|value<<8)
}
func (o *EXTI_Type) GetEXTICR3_EXTI8_15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xff00) >> 8
}
func (o *EXTI_Type) SetEXTICR3_EXTI16_23(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xff0000)|value<<16)
}
func (o *EXTI_Type) GetEXTICR3_EXTI16_23() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xff0000) >> 16
}
func (o *EXTI_Type) SetEXTICR3_EXTI24_31(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xff000000)|value<<24)
}
func (o *EXTI_Type) GetEXTICR3_EXTI24_31() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xff000000) >> 24
}

// EXTI.EXTICR4: EXTI external interrupt selection register
func (o *EXTI_Type) SetEXTICR4_EXTI0_7(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xff)|value)
}
func (o *EXTI_Type) GetEXTICR4_EXTI0_7() uint32 {
	return volatile.LoadUint32(&o.EXTICR4.Reg) & 0xff
}
func (o *EXTI_Type) SetEXTICR4_EXTI8_15(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xff00)|value<<8)
}
func (o *EXTI_Type) GetEXTICR4_EXTI8_15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xff00) >> 8
}
func (o *EXTI_Type) SetEXTICR4_EXTI16_23(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xff0000)|value<<16)
}
func (o *EXTI_Type) GetEXTICR4_EXTI16_23() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xff0000) >> 16
}
func (o *EXTI_Type) SetEXTICR4_EXTI24_31(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xff000000)|value<<24)
}
func (o *EXTI_Type) GetEXTICR4_EXTI24_31() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xff000000) >> 24
}

// EXTI.IMR1: EXTI CPU wakeup with interrupt mask register
func (o *EXTI_Type) SetIMR1_IM0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetIMR1_IM0() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetIMR1_IM1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetIMR1_IM1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetIMR1_IM2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetIMR1_IM2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetIMR1_IM3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetIMR1_IM3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetIMR1_IM4(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetIMR1_IM4() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetIMR1_IM5(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetIMR1_IM5() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetIMR1_IM6(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetIMR1_IM6() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetIMR1_IM7(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetIMR1_IM7() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetIMR1_IM8(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetIMR1_IM8() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetIMR1_IM9(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetIMR1_IM9() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetIMR1_IM10(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetIMR1_IM10() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetIMR1_IM11(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetIMR1_IM11() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetIMR1_IM12(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetIMR1_IM12() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetIMR1_IM13(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetIMR1_IM13() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetIMR1_IM14(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetIMR1_IM14() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetIMR1_IM15(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetIMR1_IM15() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetIMR1_IM16(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetIMR1_IM16() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetIMR1_IM17(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetIMR1_IM17() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetIMR1_IM18(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetIMR1_IM18() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetIMR1_IM19(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetIMR1_IM19() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetIMR1_IM20(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetIMR1_IM20() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetIMR1_IM21(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetIMR1_IM21() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetIMR1_IM22(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetIMR1_IM22() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x400000) >> 22
}
func (o *EXTI_Type) SetIMR1_IM23(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetIMR1_IM23() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetIMR1_IM24(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1000000)|value<<24)
}
func (o *EXTI_Type) GetIMR1_IM24() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x1000000) >> 24
}
func (o *EXTI_Type) SetIMR1_IM25(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetIMR1_IM25() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetIMR1_IM26(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetIMR1_IM26() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetIMR1_IM27(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetIMR1_IM27() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetIMR1_IM28(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetIMR1_IM28() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetIMR1_IM29(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetIMR1_IM29() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetIMR1_IM30(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetIMR1_IM30() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetIMR1_IM31(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetIMR1_IM31() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000000) >> 31
}

// EXTI.EMR1: EXTI CPU wakeup with event mask register
func (o *EXTI_Type) SetEMR1_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEMR1_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR1.Reg) & 0x1
}
func (o *EXTI_Type) SetEMR1_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEMR1_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetEMR1_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetEMR1_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetEMR1_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetEMR1_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetEMR1_EM4(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetEMR1_EM4() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetEMR1_EM5(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetEMR1_EM5() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetEMR1_EM6(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetEMR1_EM6() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetEMR1_EM7(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetEMR1_EM7() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetEMR1_EM8(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetEMR1_EM8() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetEMR1_EM9(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetEMR1_EM9() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetEMR1_EM10(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetEMR1_EM10() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetEMR1_EM11(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetEMR1_EM11() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetEMR1_EM12(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetEMR1_EM12() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetEMR1_EM13(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetEMR1_EM13() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetEMR1_EM14(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetEMR1_EM14() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetEMR1_EM15(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetEMR1_EM15() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetEMR1_EM16(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetEMR1_EM16() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetEMR1_EM17(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetEMR1_EM17() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetEMR1_EM18(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetEMR1_EM18() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetEMR1_EM19(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetEMR1_EM19() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetEMR1_EM21(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetEMR1_EM21() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetEMR1_EM23(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x800000)|value<<23)
}
func (o *EXTI_Type) GetEMR1_EM23() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x800000) >> 23
}
func (o *EXTI_Type) SetEMR1_EM25(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x2000000)|value<<25)
}
func (o *EXTI_Type) GetEMR1_EM25() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x2000000) >> 25
}
func (o *EXTI_Type) SetEMR1_EM26(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x4000000)|value<<26)
}
func (o *EXTI_Type) GetEMR1_EM26() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x4000000) >> 26
}
func (o *EXTI_Type) SetEMR1_EM27(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x8000000)|value<<27)
}
func (o *EXTI_Type) GetEMR1_EM27() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x8000000) >> 27
}
func (o *EXTI_Type) SetEMR1_EM28(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x10000000)|value<<28)
}
func (o *EXTI_Type) GetEMR1_EM28() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x10000000) >> 28
}
func (o *EXTI_Type) SetEMR1_EM29(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x20000000)|value<<29)
}
func (o *EXTI_Type) GetEMR1_EM29() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x20000000) >> 29
}
func (o *EXTI_Type) SetEMR1_EM30(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x40000000)|value<<30)
}
func (o *EXTI_Type) GetEMR1_EM30() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x40000000) >> 30
}
func (o *EXTI_Type) SetEMR1_EM31(value uint32) {
	volatile.StoreUint32(&o.EMR1.Reg, volatile.LoadUint32(&o.EMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *EXTI_Type) GetEMR1_EM31() uint32 {
	return (volatile.LoadUint32(&o.EMR1.Reg) & 0x80000000) >> 31
}

// EXTI.IMR2: EXTI CPU wakeup with interrupt mask register
func (o *EXTI_Type) SetIMR2_IM32(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetIMR2_IM32() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *EXTI_Type) SetIMR2_IM33(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetIMR2_IM33() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2) >> 1
}

// EXTI.EMR2: EXTI CPU wakeup with event mask register
func (o *EXTI_Type) SetEMR2_EM32(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEMR2_EM32() uint32 {
	return volatile.LoadUint32(&o.EMR2.Reg) & 0x1
}
func (o *EXTI_Type) SetEMR2_EM33(value uint32) {
	volatile.StoreUint32(&o.EMR2.Reg, volatile.LoadUint32(&o.EMR2.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEMR2_EM33() uint32 {
	return (volatile.LoadUint32(&o.EMR2.Reg) & 0x2) >> 1
}

// EXTI.HWCFGR7: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR7(value uint32) {
	volatile.StoreUint32(&o.HWCFGR7.Reg, value)
}
func (o *EXTI_Type) GetHWCFGR7() uint32 {
	return volatile.LoadUint32(&o.HWCFGR7.Reg)
}

// EXTI.HWCFGR6: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR6(value uint32) {
	volatile.StoreUint32(&o.HWCFGR6.Reg, value)
}
func (o *EXTI_Type) GetHWCFGR6() uint32 {
	return volatile.LoadUint32(&o.HWCFGR6.Reg)
}

// EXTI.HWCFGR5: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR5(value uint32) {
	volatile.StoreUint32(&o.HWCFGR5.Reg, value)
}
func (o *EXTI_Type) GetHWCFGR5() uint32 {
	return volatile.LoadUint32(&o.HWCFGR5.Reg)
}

// EXTI.HWCFGR4: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR4(value uint32) {
	volatile.StoreUint32(&o.HWCFGR4.Reg, value)
}
func (o *EXTI_Type) GetHWCFGR4() uint32 {
	return volatile.LoadUint32(&o.HWCFGR4.Reg)
}

// EXTI.HWCFGR3: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR3(value uint32) {
	volatile.StoreUint32(&o.HWCFGR3.Reg, value)
}
func (o *EXTI_Type) GetHWCFGR3() uint32 {
	return volatile.LoadUint32(&o.HWCFGR3.Reg)
}

// EXTI.HWCFGR2: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR2(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, value)
}
func (o *EXTI_Type) GetHWCFGR2() uint32 {
	return volatile.LoadUint32(&o.HWCFGR2.Reg)
}

// EXTI.HWCFGR1: Hardware configuration registers
func (o *EXTI_Type) SetHWCFGR1_NBIOPORT(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff0000)|value<<16)
}
func (o *EXTI_Type) GetHWCFGR1_NBIOPORT() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff0000) >> 16
}
func (o *EXTI_Type) SetHWCFGR1_CPUEVTEN(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xf000)|value<<12)
}
func (o *EXTI_Type) GetHWCFGR1_CPUEVTEN() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xf000) >> 12
}
func (o *EXTI_Type) SetHWCFGR1_NBCPUS(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xf00)|value<<8)
}
func (o *EXTI_Type) GetHWCFGR1_NBCPUS() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xf00) >> 8
}
func (o *EXTI_Type) SetHWCFGR1_NBEVENTS(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff)|value)
}
func (o *EXTI_Type) GetHWCFGR1_NBEVENTS() uint32 {
	return volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff
}

// General purpose timers
type TIM_Type struct {
	CR1          volatile.Register32 // 0x0
	CR2          volatile.Register32 // 0x4
	_            [4]byte
	DIER         volatile.Register32 // 0xC
	SR           volatile.Register32 // 0x10
	EGR          volatile.Register32 // 0x14
	CCMR1_Output volatile.Register32 // 0x18
	_            [4]byte
	CCER         volatile.Register32 // 0x20
	CNT          volatile.Register32 // 0x24
	PSC          volatile.Register32 // 0x28
	ARR          volatile.Register32 // 0x2C
	RCR          volatile.Register32 // 0x30
	CCR1         volatile.Register32 // 0x34
	_            [12]byte
	BDTR         volatile.Register32 // 0x44
	DCR          volatile.Register32 // 0x48
	DMAR         volatile.Register32 // 0x4C
	_            [16]byte
	AF1          volatile.Register32 // 0x60
	_            [4]byte
	TISEL        volatile.Register32 // 0x68
}

// TIM.CR1: control register 1
func (o *TIM_Type) SetCR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *TIM_Type) SetCR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCR1_URS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCR1_UIFREMAP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR1_UIFREMAP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}

// TIM.CR2: control register 2
func (o *TIM_Type) SetCR2_OIS1N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCR2_OIS1N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCR2_OIS1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCR2_OIS1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR2_CCUS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR2_CCUS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR2_CCPC(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR2_CCPC() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// TIM.DIER: DMA/Interrupt enable register
func (o *TIM_Type) SetDIER_COMDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetDIER_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetDIER_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetDIER_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetDIER_UDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetDIER_UDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetDIER_BIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetDIER_BIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetDIER_COMIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetDIER_COMIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetDIER_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetDIER_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetDIER_UIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetDIER_UIE() uint32 {
	return volatile.LoadUint32(&o.DIER.Reg) & 0x1
}

// TIM.SR: status register
func (o *TIM_Type) SetSR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetSR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetSR_BIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSR_BIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSR_COMIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetSR_COMIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetSR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetSR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetSR_UIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetSR_UIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// TIM.EGR: event generation register
func (o *TIM_Type) SetEGR_BG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetEGR_BG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetEGR_COMG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetEGR_COMG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetEGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetEGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetEGR_UG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetEGR_UG() uint32 {
	return volatile.LoadUint32(&o.EGR.Reg) & 0x1
}

// TIM.CCMR1_Output: capture/compare mode register (output mode)
func (o *TIM_Type) SetCCMR1_Output_OC1M_2(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M_2() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x3
}

// TIM.CCER: capture/compare enable register
func (o *TIM_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCER_CC1NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCER_CC1NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}

// TIM.CNT: counter
func (o *TIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}
func (o *TIM_Type) SetCNT_UIFCPY(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCNT_UIFCPY() uint32 {
	return (volatile.LoadUint32(&o.CNT.Reg) & 0x80000000) >> 31
}

// TIM.PSC: prescaler
func (o *TIM_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIM.ARR: auto-reload register
func (o *TIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// TIM.RCR: repetition counter register
func (o *TIM_Type) SetRCR_REP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetRCR_REP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xff
}

// TIM.CCR1: capture/compare register 1
func (o *TIM_Type) SetCCR1(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR1() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0xffff
}

// TIM.BDTR: break and dead-time register
func (o *TIM_Type) SetBDTR_DTG(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetBDTR_DTG() uint32 {
	return volatile.LoadUint32(&o.BDTR.Reg) & 0xff
}
func (o *TIM_Type) SetBDTR_LOCK(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetBDTR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetBDTR_OSSI(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetBDTR_OSSI() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetBDTR_OSSR(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetBDTR_OSSR() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetBDTR_BKE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetBDTR_BKE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetBDTR_BKP(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetBDTR_BKP() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetBDTR_AOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetBDTR_AOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetBDTR_MOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetBDTR_MOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetBDTR_BKF(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf0000)|value<<16)
}
func (o *TIM_Type) GetBDTR_BKF() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf0000) >> 16
}
func (o *TIM_Type) SetBDTR_BKDSRM(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000000)|value<<26)
}
func (o *TIM_Type) GetBDTR_BKDSRM() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000000) >> 26
}
func (o *TIM_Type) SetBDTR_BKBID(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x10000000)|value<<28)
}
func (o *TIM_Type) GetBDTR_BKBID() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x10000000) >> 28
}

// TIM.DCR: DMA control register
func (o *TIM_Type) SetDCR_DBL(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIM_Type) GetDCR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f00) >> 8
}
func (o *TIM_Type) SetDCR_DBA(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f)|value)
}
func (o *TIM_Type) GetDCR_DBA() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1f
}

// TIM.DMAR: DMA address for full transfer
func (o *TIM_Type) SetDMAR_DMAB(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, volatile.LoadUint32(&o.DMAR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetDMAR_DMAB() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg) & 0xffff
}

// TIM.AF1: TIM17 option register 1
func (o *TIM_Type) SetAF1_BKINE(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF1_BKINE() uint32 {
	return volatile.LoadUint32(&o.AF1.Reg) & 0x1
}
func (o *TIM_Type) SetAF1_BKCMP1E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetAF1_BKCMP1E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetAF1_BKCMP2E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetAF1_BKCMP2E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetAF1_BKDFBK1E(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetAF1_BKDFBK1E() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetAF1_BKINP(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF1_BKINP() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetAF1_BKCMP1P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetAF1_BKCMP1P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetAF1_BKCMP2P(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetAF1_BKCMP2P() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x800) >> 11
}

// TIM.TISEL: input selection register
func (o *TIM_Type) SetTISEL_TI1SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf)|value)
}
func (o *TIM_Type) GetTISEL_TI1SEL() uint32 {
	return volatile.LoadUint32(&o.TISEL.Reg) & 0xf
}
func (o *TIM_Type) SetTISEL_TI2SEL(value uint32) {
	volatile.StoreUint32(&o.TISEL.Reg, volatile.LoadUint32(&o.TISEL.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetTISEL_TI2SEL() uint32 {
	return (volatile.LoadUint32(&o.TISEL.Reg) & 0xf00) >> 8
}

// Universal synchronous asynchronous receiver transmitter
type USART_Type struct {
	CR1   volatile.Register32 // 0x0
	CR2   volatile.Register32 // 0x4
	CR3   volatile.Register32 // 0x8
	BRR   volatile.Register32 // 0xC
	GTPR  volatile.Register32 // 0x10
	RTOR  volatile.Register32 // 0x14
	RQR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	ICR   volatile.Register32 // 0x20
	RDR   volatile.Register32 // 0x24
	TDR   volatile.Register32 // 0x28
	PRESC volatile.Register32 // 0x2C
}

// USART.CR1: Control register 1
func (o *USART_Type) SetCR1_RXFFIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetCR1_RXFFIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000000) >> 31
}
func (o *USART_Type) SetCR1_TXFEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetCR1_TXFEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetCR1_FIFOEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetCR1_FIFOEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetCR1_M1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR1_M1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR1_EOBIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetCR1_EOBIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetCR1_RTOIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetCR1_RTOIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetCR1_DEAT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3e00000)|value<<21)
}
func (o *USART_Type) GetCR1_DEAT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3e00000) >> 21
}
func (o *USART_Type) SetCR1_DEDT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *USART_Type) GetCR1_DEDT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1f0000) >> 16
}
func (o *USART_Type) SetCR1_OVER8(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR1_OVER8() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR1_CMIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR1_CMIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR1_MME(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR1_MME() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR1_M0(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR1_M0() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR1_TE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR1_RE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR1_UESM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR1_UESM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR1_UE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR1_UE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// USART.CR2: Control register 2
func (o *USART_Type) SetCR2_ADD4_7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *USART_Type) GetCR2_ADD4_7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf0000000) >> 28
}
func (o *USART_Type) SetCR2_ADD0_3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf000000)|value<<24)
}
func (o *USART_Type) GetCR2_ADD0_3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf000000) >> 24
}
func (o *USART_Type) SetCR2_RTOEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR2_RTOEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR2_ABRMOD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x600000)|value<<21)
}
func (o *USART_Type) GetCR2_ABRMOD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x600000) >> 21
}
func (o *USART_Type) SetCR2_ABREN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetCR2_ABREN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetCR2_MSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR2_MSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCR2_TAINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR2_TAINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR2_TXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetCR2_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetCR2_RXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetCR2_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetCR2_SWAP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR2_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR2_LINEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR2_LINEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR2_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR2_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR2_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR2_LBCL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR2_LBCL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR2_LBDIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR2_LBDIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR2_LBDL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR2_LBDL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR2_ADDM7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR2_ADDM7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR2_DIS_NSS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR2_DIS_NSS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR2_SLVEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR2_SLVEN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// USART.CR3: Control register 3
func (o *USART_Type) SetCR3_TXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000000)|value<<29)
}
func (o *USART_Type) GetCR3_TXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000000) >> 29
}
func (o *USART_Type) SetCR3_RXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR3_RXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR3_RXFTCFG(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe000000)|value<<25)
}
func (o *USART_Type) GetCR3_RXFTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe000000) >> 25
}
func (o *USART_Type) SetCR3_TCBGTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetCR3_TCBGTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000000) >> 24
}
func (o *USART_Type) SetCR3_TXFTIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR3_TXFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR3_WUFIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetCR3_WUFIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetCR3_WUS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x300000)|value<<20)
}
func (o *USART_Type) GetCR3_WUS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x300000) >> 20
}
func (o *USART_Type) SetCR3_SCARCNT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000)|value<<17)
}
func (o *USART_Type) GetCR3_SCARCNT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000) >> 17
}
func (o *USART_Type) SetCR3_DEP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR3_DEP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR3_DEM(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR3_DEM() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR3_DDRE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR3_DDRE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR3_OVRDIS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR3_OVRDIS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR3_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR3_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR3_SCEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR3_SCEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR3_NACK(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR3_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR3_IRLP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR3_IRLP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR3_IREN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR3_IREN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// USART.BRR: Baud rate register
func (o *USART_Type) SetBRR_BRR_4_15(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xfff0)|value<<4)
}
func (o *USART_Type) GetBRR_BRR_4_15() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0xfff0) >> 4
}
func (o *USART_Type) SetBRR_BRR_0_3(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetBRR_BRR_0_3() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xf
}

// USART.GTPR: Guard time and prescaler register
func (o *USART_Type) SetGTPR_GT(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetGTPR_GT() uint32 {
	return (volatile.LoadUint32(&o.GTPR.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetGTPR_PSC(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetGTPR_PSC() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg) & 0xff
}

// USART.RTOR: Receiver timeout register
func (o *USART_Type) SetRTOR_BLEN(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetRTOR_BLEN() uint32 {
	return (volatile.LoadUint32(&o.RTOR.Reg) & 0xff000000) >> 24
}
func (o *USART_Type) SetRTOR_RTO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetRTOR_RTO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffffff
}

// USART.RQR: Request register
func (o *USART_Type) SetRQR_TXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetRQR_TXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetRQR_RXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetRQR_RXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetRQR_MMRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetRQR_MMRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetRQR_SBKRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetRQR_SBKRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetRQR_ABRRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetRQR_ABRRQ() uint32 {
	return volatile.LoadUint32(&o.RQR.Reg) & 0x1
}

// USART.ISR: Interrupt & status register
func (o *USART_Type) SetISR_TXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetISR_TXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetISR_RXFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetISR_RXFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetISR_TCBGT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *USART_Type) GetISR_TCBGT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *USART_Type) SetISR_RXFF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetISR_RXFF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *USART_Type) SetISR_TXFE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetISR_TXFE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetISR_REACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetISR_REACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetISR_TEACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetISR_TEACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetISR_WUF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetISR_WUF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetISR_RWU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetISR_RWU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetISR_SBKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetISR_SBKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetISR_CMF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetISR_CMF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetISR_ABRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetISR_ABRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetISR_ABRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetISR_ABRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetISR_UDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetISR_UDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetISR_EOBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetISR_EOBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetISR_RTOF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetISR_RTOF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetISR_CTS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetISR_CTS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetISR_CTSIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetISR_CTSIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetISR_LBDF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetISR_LBDF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetISR_IDLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetISR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetISR_ORE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetISR_ORE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetISR_NF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetISR_NF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetISR_FE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetISR_FE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetISR_PE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetISR_PE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// USART.ICR: Interrupt flag clear register
func (o *USART_Type) SetICR_WUCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetICR_WUCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetICR_CMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetICR_CMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetICR_UDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetICR_UDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetICR_EOBCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetICR_EOBCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetICR_RTOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetICR_RTOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetICR_CTSCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetICR_CTSCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetICR_LBDCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetICR_LBDCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetICR_TCBGTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetICR_TCBGTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetICR_TCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetICR_TCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetICR_TXFECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetICR_TXFECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetICR_IDLECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetICR_IDLECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetICR_ORECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetICR_ORECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetICR_NCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetICR_NCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetICR_FECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetICR_FECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetICR_PECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetICR_PECF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// USART.RDR: Receive data register
func (o *USART_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0x1ff
}

// USART.TDR: Transmit data register
func (o *USART_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0x1ff
}

// USART.PRESC: Prescaler register
func (o *USART_Type) SetPRESC_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.PRESC.Reg, volatile.LoadUint32(&o.PRESC.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetPRESC_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.PRESC.Reg) & 0xf
}

// Serial peripheral interface/Inter-IC sound
type SPI_Type struct {
	CR1     volatile.Register32 // 0x0
	CR2     volatile.Register32 // 0x4
	SR      volatile.Register32 // 0x8
	DR      volatile.Register32 // 0xC
	CRCPR   volatile.Register32 // 0x10
	RXCRCR  volatile.Register32 // 0x14
	TXCRCR  volatile.Register32 // 0x18
	I2SCFGR volatile.Register32 // 0x1C
	I2SPR   volatile.Register32 // 0x20
	_       [972]byte
	HWCFGR  volatile.Register32 // 0x3F0
	VERR    volatile.Register32 // 0x3F4
	IPIDR   volatile.Register32 // 0x3F8
	SIDR    volatile.Register32 // 0x3FC
}

// SPI.CR1: control register 1
func (o *SPI_Type) SetCR1_BIDIMODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCR1_BIDIMODE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCR1_BIDIOE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR1_BIDIOE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCR1_CRCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR1_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR1_CRCNEXT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR1_CRCNEXT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR1_DFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCR1_DFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetCR1_RXONLY(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCR1_RXONLY() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCR1_SSM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCR1_SSM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCR1_SSI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCR1_SSI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR1_SPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR1_SPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR1_BR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetCR1_BR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetCR1_MSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR1_MSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR1_CPHA() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// SPI.CR2: control register 2
func (o *SPI_Type) SetCR2_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR2_RXDMAEN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *SPI_Type) SetCR2_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR2_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR2_SSOE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR2_SSOE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR2_NSSP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCR2_NSSP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCR2_FRF(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetCR2_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetCR2_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCR2_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCR2_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR2_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR2_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR2_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR2_DS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCR2_DS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCR2_FRXTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR2_FRXTH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR2_LDMA_RX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR2_LDMA_RX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR2_LDMA_TX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR2_LDMA_TX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}

// SPI.SR: status register
func (o *SPI_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RXNE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TXE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TXE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_CHSIDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_CHSIDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_UDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_UDR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_CRCERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSR_TIFRFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_TIFRFE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_FRLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x600)|value<<9)
}
func (o *SPI_Type) GetSR_FRLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x600) >> 9
}
func (o *SPI_Type) SetSR_FTLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1800)|value<<11)
}
func (o *SPI_Type) GetSR_FTLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1800) >> 11
}

// SPI.DR: data register
func (o *SPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// SPI.CRCPR: CRC polynomial register
func (o *SPI_Type) SetCRCPR_CRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPR.Reg, volatile.LoadUint32(&o.CRCPR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetCRCPR_CRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPR.Reg) & 0xffff
}

// SPI.RXCRCR: RX CRC register
func (o *SPI_Type) SetRXCRCR_RxCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRCR.Reg, volatile.LoadUint32(&o.RXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRXCRCR_RxCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRCR.Reg) & 0xffff
}

// SPI.TXCRCR: TX CRC register
func (o *SPI_Type) SetTXCRCR_TxCRC(value uint32) {
	volatile.StoreUint32(&o.TXCRCR.Reg, volatile.LoadUint32(&o.TXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXCRCR_TxCRC() uint32 {
	return volatile.LoadUint32(&o.TXCRCR.Reg) & 0xffff
}

// SPI.I2SCFGR: configuration register
func (o *SPI_Type) SetI2SCFGR_CHLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetI2SCFGR_CHLEN() uint32 {
	return volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1
}
func (o *SPI_Type) SetI2SCFGR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x6)|value<<1)
}
func (o *SPI_Type) GetI2SCFGR_DATLEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x6) >> 1
}
func (o *SPI_Type) SetI2SCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetI2SCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetI2SCFGR_I2SSTD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetI2SCFGR_I2SSTD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetI2SCFGR_PCMSYNC(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetI2SCFGR_PCMSYNC() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetI2SCFGR_I2SCFG(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetI2SCFGR_I2SCFG() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetI2SCFGR_SE2(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetI2SCFGR_SE2() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetI2SCFGR_I2SMOD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetI2SCFGR_I2SMOD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x800) >> 11
}

// SPI.I2SPR: prescaler register
func (o *SPI_Type) SetI2SPR_I2SDIV(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetI2SPR_I2SDIV() uint32 {
	return volatile.LoadUint32(&o.I2SPR.Reg) & 0xff
}
func (o *SPI_Type) SetI2SPR_ODD(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetI2SPR_ODD() uint32 {
	return (volatile.LoadUint32(&o.I2SPR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetI2SPR_MCKOE(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetI2SPR_MCKOE() uint32 {
	return (volatile.LoadUint32(&o.I2SPR.Reg) & 0x200) >> 9
}

// SPI.HWCFGR: hardware configuration register
func (o *SPI_Type) SetHWCFGR_CRCCFG(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetHWCFGR_CRCCFG() uint32 {
	return volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf
}
func (o *SPI_Type) SetHWCFGR_I2SCFG(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetHWCFGR_I2SCFG() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetHWCFGR_I2SCKCFG(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetHWCFGR_I2SCKCFG() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetHWCFGR_DSCFG(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf000)|value<<12)
}
func (o *SPI_Type) GetHWCFGR_DSCFG() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf000) >> 12
}
func (o *SPI_Type) SetHWCFGR_NSSCFG(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetHWCFGR_NSSCFG() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf0000) >> 16
}

// SPI.VERR: EXTI IP Version register
func (o *SPI_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *SPI_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// SPI.IPIDR: EXTI Identification register
func (o *SPI_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *SPI_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// SPI.SIDR: EXTI Size ID register
func (o *SPI_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *SPI_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// Analog to Digital Converter instance 1
type ADC_Type struct {
	ISR     volatile.Register32 // 0x0
	IER     volatile.Register32 // 0x4
	CR      volatile.Register32 // 0x8
	CFGR1   volatile.Register32 // 0xC
	CFGR2   volatile.Register32 // 0x10
	SMPR    volatile.Register32 // 0x14
	_       [8]byte
	AWD1TR  volatile.Register32 // 0x20
	AWD2TR  volatile.Register32 // 0x24
	CHSELR  volatile.Register32 // 0x28
	AWD3TR  volatile.Register32 // 0x2C
	_       [16]byte
	DR      volatile.Register32 // 0x40
	_       [92]byte
	AWD2CR  volatile.Register32 // 0xA0
	AWD3CR  volatile.Register32 // 0xA4
	_       [12]byte
	CALFACT volatile.Register32 // 0xB4
	_       [592]byte
	CCR     volatile.Register32 // 0x308
	_       [204]byte
	HWCFGR6 volatile.Register32 // 0x3D8
	HWCFGR5 volatile.Register32 // 0x3DC
	HWCFGR4 volatile.Register32 // 0x3E0
	HWCFGR3 volatile.Register32 // 0x3E4
	HWCFGR2 volatile.Register32 // 0x3E8
	HWCFGR1 volatile.Register32 // 0x3EC
	HWCFGR0 volatile.Register32 // 0x3F0
	VERR    volatile.Register32 // 0x3F4
	IPIDR   volatile.Register32 // 0x3F8
	SIDR    volatile.Register32 // 0x3FC
}

// ADC.ISR: ADC interrupt and status register
func (o *ADC_Type) SetISR_CCRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetISR_CCRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetISR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetISR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetISR_AWD3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetISR_AWD3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetISR_AWD2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetISR_AWD2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetISR_AWD1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetISR_AWD1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetISR_EOS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetISR_EOS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetISR_EOC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetISR_EOC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetISR_EOSMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetISR_EOSMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetISR_ADRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetISR_ADRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// ADC.IER: ADC interrupt enable register
func (o *ADC_Type) SetIER_CCRDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetIER_CCRDYIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetIER_EOCALIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIER_EOCALIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIER_AWD3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIER_AWD3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIER_AWD2IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIER_AWD2IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIER_AWD1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIER_AWD1IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIER_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIER_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIER_EOSIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIER_EOSIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIER_EOCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIER_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIER_EOSMPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIER_EOSMPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIER_ADRDYIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIER_ADRDYIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// ADC.CR: ADC control register
func (o *ADC_Type) SetCR_ADCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetCR_ADCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}
func (o *ADC_Type) SetCR_ADVREGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_Type) GetCR_ADVREGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *ADC_Type) SetCR_ADSTP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCR_ADSTP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCR_ADSTART(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCR_ADSTART() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCR_ADDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR_ADDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR_ADEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR_ADEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// ADC.CFGR1: ADC configuration register 1
func (o *ADC_Type) SetCFGR1_AWDCH1CH(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x7c000000)|value<<26)
}
func (o *ADC_Type) GetCFGR1_AWDCH1CH() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x7c000000) >> 26
}
func (o *ADC_Type) SetCFGR1_AWD1EN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCFGR1_AWD1EN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCFGR1_AWD1SGL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCFGR1_AWD1SGL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCFGR1_CHSELRMOD(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCFGR1_CHSELRMOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCFGR1_DISCEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCFGR1_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCFGR1_AUTOFF(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetCFGR1_AUTOFF() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetCFGR1_WAIT(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetCFGR1_WAIT() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetCFGR1_CONT(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFGR1_CONT() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFGR1_OVRMOD(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCFGR1_OVRMOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCFGR1_EXTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc00)|value<<10)
}
func (o *ADC_Type) GetCFGR1_EXTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc00) >> 10
}
func (o *ADC_Type) SetCFGR1_EXTSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1c0)|value<<6)
}
func (o *ADC_Type) GetCFGR1_EXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x1c0) >> 6
}
func (o *ADC_Type) SetCFGR1_ALIGN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCFGR1_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCFGR1_RES(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x18)|value<<3)
}
func (o *ADC_Type) GetCFGR1_RES() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x18) >> 3
}
func (o *ADC_Type) SetCFGR1_SCANDIR(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCFGR1_SCANDIR() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCFGR1_DMACFG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCFGR1_DMACFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCFGR1_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR1_DMAEN() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}

// ADC.CFGR2: ADC configuration register 2
func (o *ADC_Type) SetCFGR2_CKMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *ADC_Type) GetCFGR2_CKMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0xc0000000) >> 30
}
func (o *ADC_Type) SetCFGR2_LFTRIG(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetCFGR2_LFTRIG() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetCFGR2_TOVS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCFGR2_TOVS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCFGR2_OVSS(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1e0)|value<<5)
}
func (o *ADC_Type) GetCFGR2_OVSS() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1e0) >> 5
}
func (o *ADC_Type) SetCFGR2_OVSR(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1c)|value<<2)
}
func (o *ADC_Type) GetCFGR2_OVSR() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x1c) >> 2
}
func (o *ADC_Type) SetCFGR2_OVSE(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCFGR2_OVSE() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}

// ADC.SMPR: ADC sampling time register
func (o *ADC_Type) SetSMPR_SMP1(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetSMPR_SMP1() uint32 {
	return volatile.LoadUint32(&o.SMPR.Reg) & 0x7
}
func (o *ADC_Type) SetSMPR_SMP2(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x70)|value<<4)
}
func (o *ADC_Type) GetSMPR_SMP2() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x70) >> 4
}
func (o *ADC_Type) SetSMPR_SMPSEL(value uint32) {
	volatile.StoreUint32(&o.SMPR.Reg, volatile.LoadUint32(&o.SMPR.Reg)&^(0x7ffff00)|value<<8)
}
func (o *ADC_Type) GetSMPR_SMPSEL() uint32 {
	return (volatile.LoadUint32(&o.SMPR.Reg) & 0x7ffff00) >> 8
}

// ADC.AWD1TR: watchdog threshold register
func (o *ADC_Type) SetAWD1TR_HT1(value uint32) {
	volatile.StoreUint32(&o.AWD1TR.Reg, volatile.LoadUint32(&o.AWD1TR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetAWD1TR_HT1() uint32 {
	return (volatile.LoadUint32(&o.AWD1TR.Reg) & 0xfff0000) >> 16
}
func (o *ADC_Type) SetAWD1TR_LT1(value uint32) {
	volatile.StoreUint32(&o.AWD1TR.Reg, volatile.LoadUint32(&o.AWD1TR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetAWD1TR_LT1() uint32 {
	return volatile.LoadUint32(&o.AWD1TR.Reg) & 0xfff
}

// ADC.AWD2TR: watchdog threshold register
func (o *ADC_Type) SetAWD2TR_HT2(value uint32) {
	volatile.StoreUint32(&o.AWD2TR.Reg, volatile.LoadUint32(&o.AWD2TR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetAWD2TR_HT2() uint32 {
	return (volatile.LoadUint32(&o.AWD2TR.Reg) & 0xfff0000) >> 16
}
func (o *ADC_Type) SetAWD2TR_LT2(value uint32) {
	volatile.StoreUint32(&o.AWD2TR.Reg, volatile.LoadUint32(&o.AWD2TR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetAWD2TR_LT2() uint32 {
	return volatile.LoadUint32(&o.AWD2TR.Reg) & 0xfff
}

// ADC.CHSELR: channel selection register
func (o *ADC_Type) SetCHSELR_CHSEL(value uint32) {
	volatile.StoreUint32(&o.CHSELR.Reg, volatile.LoadUint32(&o.CHSELR.Reg)&^(0x7ffff)|value)
}
func (o *ADC_Type) GetCHSELR_CHSEL() uint32 {
	return volatile.LoadUint32(&o.CHSELR.Reg) & 0x7ffff
}

// ADC.AWD3TR: watchdog threshold register
func (o *ADC_Type) SetAWD3TR_HT3(value uint32) {
	volatile.StoreUint32(&o.AWD3TR.Reg, volatile.LoadUint32(&o.AWD3TR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetAWD3TR_HT3() uint32 {
	return (volatile.LoadUint32(&o.AWD3TR.Reg) & 0xfff0000) >> 16
}
func (o *ADC_Type) SetAWD3TR_LT3(value uint32) {
	volatile.StoreUint32(&o.AWD3TR.Reg, volatile.LoadUint32(&o.AWD3TR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetAWD3TR_LT3() uint32 {
	return volatile.LoadUint32(&o.AWD3TR.Reg) & 0xfff
}

// ADC.DR: ADC group regular conversion data register
func (o *ADC_Type) SetDR_REGULARDATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetDR_REGULARDATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// ADC.AWD2CR: ADC analog watchdog 2 configuration register
func (o *ADC_Type) SetAWD2CR_AWD2CH(value uint32) {
	volatile.StoreUint32(&o.AWD2CR.Reg, volatile.LoadUint32(&o.AWD2CR.Reg)&^(0x7ffff)|value)
}
func (o *ADC_Type) GetAWD2CR_AWD2CH() uint32 {
	return volatile.LoadUint32(&o.AWD2CR.Reg) & 0x7ffff
}

// ADC.AWD3CR: ADC analog watchdog 3 configuration register
func (o *ADC_Type) SetAWD3CR_AWD3CH(value uint32) {
	volatile.StoreUint32(&o.AWD3CR.Reg, volatile.LoadUint32(&o.AWD3CR.Reg)&^(0x7ffff)|value)
}
func (o *ADC_Type) GetAWD3CR_AWD3CH() uint32 {
	return volatile.LoadUint32(&o.AWD3CR.Reg) & 0x7ffff
}

// ADC.CALFACT: ADC calibration factors register
func (o *ADC_Type) SetCALFACT(value uint32) {
	volatile.StoreUint32(&o.CALFACT.Reg, volatile.LoadUint32(&o.CALFACT.Reg)&^(0x7f)|value)
}
func (o *ADC_Type) GetCALFACT() uint32 {
	return volatile.LoadUint32(&o.CALFACT.Reg) & 0x7f
}

// ADC.CCR: ADC common control register
func (o *ADC_Type) SetCCR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3c0000)|value<<18)
}
func (o *ADC_Type) GetCCR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x3c0000) >> 18
}
func (o *ADC_Type) SetCCR_VREFEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCCR_VREFEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCCR_TSEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCCR_TSEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCCR_VBATEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCCR_VBATEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1000000) >> 24
}

// ADC.HWCFGR6: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR6_CHMAP20(value uint32) {
	volatile.StoreUint32(&o.HWCFGR6.Reg, volatile.LoadUint32(&o.HWCFGR6.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHWCFGR6_CHMAP20() uint32 {
	return volatile.LoadUint32(&o.HWCFGR6.Reg) & 0x1f
}
func (o *ADC_Type) SetHWCFGR6_CHMAP21(value uint32) {
	volatile.StoreUint32(&o.HWCFGR6.Reg, volatile.LoadUint32(&o.HWCFGR6.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR6_CHMAP21() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR6.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetHWCFGR6_CHMAP22(value uint32) {
	volatile.StoreUint32(&o.HWCFGR6.Reg, volatile.LoadUint32(&o.HWCFGR6.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetHWCFGR6_CHMAP22() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR6.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetHWCFGR6_CHMAP23(value uint32) {
	volatile.StoreUint32(&o.HWCFGR6.Reg, volatile.LoadUint32(&o.HWCFGR6.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetHWCFGR6_CHMAP23() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR6.Reg) & 0x1f000000) >> 24
}

// ADC.HWCFGR5: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR5_CHMAP19(value uint32) {
	volatile.StoreUint32(&o.HWCFGR5.Reg, volatile.LoadUint32(&o.HWCFGR5.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHWCFGR5_CHMAP19() uint32 {
	return volatile.LoadUint32(&o.HWCFGR5.Reg) & 0x1f
}
func (o *ADC_Type) SetHWCFGR5_CHMAP18(value uint32) {
	volatile.StoreUint32(&o.HWCFGR5.Reg, volatile.LoadUint32(&o.HWCFGR5.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR5_CHMAP18() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR5.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetHWCFGR5_CHMAP17(value uint32) {
	volatile.StoreUint32(&o.HWCFGR5.Reg, volatile.LoadUint32(&o.HWCFGR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetHWCFGR5_CHMAP17() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR5.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetHWCFGR5_CHMAP16(value uint32) {
	volatile.StoreUint32(&o.HWCFGR5.Reg, volatile.LoadUint32(&o.HWCFGR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetHWCFGR5_CHMAP16() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR5.Reg) & 0x1f000000) >> 24
}

// ADC.HWCFGR4: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR4_CHMAP15(value uint32) {
	volatile.StoreUint32(&o.HWCFGR4.Reg, volatile.LoadUint32(&o.HWCFGR4.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHWCFGR4_CHMAP15() uint32 {
	return volatile.LoadUint32(&o.HWCFGR4.Reg) & 0x1f
}
func (o *ADC_Type) SetHWCFGR4_CHMAP14(value uint32) {
	volatile.StoreUint32(&o.HWCFGR4.Reg, volatile.LoadUint32(&o.HWCFGR4.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR4_CHMAP14() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR4.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetHWCFGR4_CHMAP13(value uint32) {
	volatile.StoreUint32(&o.HWCFGR4.Reg, volatile.LoadUint32(&o.HWCFGR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetHWCFGR4_CHMAP13() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR4.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetHWCFGR4_CHMAP12(value uint32) {
	volatile.StoreUint32(&o.HWCFGR4.Reg, volatile.LoadUint32(&o.HWCFGR4.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetHWCFGR4_CHMAP12() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR4.Reg) & 0x1f000000) >> 24
}

// ADC.HWCFGR3: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR3_CHMAP11(value uint32) {
	volatile.StoreUint32(&o.HWCFGR3.Reg, volatile.LoadUint32(&o.HWCFGR3.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHWCFGR3_CHMAP11() uint32 {
	return volatile.LoadUint32(&o.HWCFGR3.Reg) & 0x1f
}
func (o *ADC_Type) SetHWCFGR3_CHMAP10(value uint32) {
	volatile.StoreUint32(&o.HWCFGR3.Reg, volatile.LoadUint32(&o.HWCFGR3.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR3_CHMAP10() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR3.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetHWCFGR3_CHMAP9(value uint32) {
	volatile.StoreUint32(&o.HWCFGR3.Reg, volatile.LoadUint32(&o.HWCFGR3.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetHWCFGR3_CHMAP9() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR3.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetHWCFGR3_CHMAP8(value uint32) {
	volatile.StoreUint32(&o.HWCFGR3.Reg, volatile.LoadUint32(&o.HWCFGR3.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetHWCFGR3_CHMAP8() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR3.Reg) & 0x1f000000) >> 24
}

// ADC.HWCFGR2: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR2_CHMAP7(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHWCFGR2_CHMAP7() uint32 {
	return volatile.LoadUint32(&o.HWCFGR2.Reg) & 0x1f
}
func (o *ADC_Type) SetHWCFGR2_CHMAP6(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR2_CHMAP6() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR2.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetHWCFGR2_CHMAP5(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetHWCFGR2_CHMAP5() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR2.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetHWCFGR2_CHMAP4(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetHWCFGR2_CHMAP4() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR2.Reg) & 0x1f000000) >> 24
}

// ADC.HWCFGR1: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR1_CHMAP3(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHWCFGR1_CHMAP3() uint32 {
	return volatile.LoadUint32(&o.HWCFGR1.Reg) & 0x1f
}
func (o *ADC_Type) SetHWCFGR1_CHMAP2(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR1_CHMAP2() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetHWCFGR1_CHMAP1(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetHWCFGR1_CHMAP1() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetHWCFGR1_CHMAP0(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *ADC_Type) GetHWCFGR1_CHMAP0() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0x1f000000) >> 24
}

// ADC.HWCFGR0: Hardware Configuration Register
func (o *ADC_Type) SetHWCFGR0_NUM_CHAN_24(value uint32) {
	volatile.StoreUint32(&o.HWCFGR0.Reg, volatile.LoadUint32(&o.HWCFGR0.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetHWCFGR0_NUM_CHAN_24() uint32 {
	return volatile.LoadUint32(&o.HWCFGR0.Reg) & 0xf
}
func (o *ADC_Type) SetHWCFGR0_EXTRA_AWDS(value uint32) {
	volatile.StoreUint32(&o.HWCFGR0.Reg, volatile.LoadUint32(&o.HWCFGR0.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetHWCFGR0_EXTRA_AWDS() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR0.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetHWCFGR0_OVS(value uint32) {
	volatile.StoreUint32(&o.HWCFGR0.Reg, volatile.LoadUint32(&o.HWCFGR0.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetHWCFGR0_OVS() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR0.Reg) & 0xf00) >> 8
}

// ADC.VERR: EXTI IP Version register
func (o *ADC_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *ADC_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// ADC.IPIDR: EXTI Identification register
func (o *ADC_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *ADC_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// ADC.SIDR: EXTI Size ID register
func (o *ADC_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *ADC_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// COMP1
type COMP1_Type struct {
	COMP1_CSR volatile.Register32 // 0x0
	COMP2_CSR volatile.Register32 // 0x4
}

// COMP1.COMP1_CSR: Comparator 1 control and status register
func (o *COMP1_Type) SetCOMP1_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x1)|value)
}
func (o *COMP1_Type) GetCOMP1_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x1
}
func (o *COMP1_Type) SetCOMP1_CSR_INMSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0xf0)|value<<4)
}
func (o *COMP1_Type) GetCOMP1_CSR_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0xf0) >> 4
}
func (o *COMP1_Type) SetCOMP1_CSR_INPSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x300)|value<<8)
}
func (o *COMP1_Type) GetCOMP1_CSR_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x300) >> 8
}
func (o *COMP1_Type) SetCOMP1_CSR_WINMODE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x800)|value<<11)
}
func (o *COMP1_Type) GetCOMP1_CSR_WINMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x800) >> 11
}
func (o *COMP1_Type) SetCOMP1_CSR_WINOUT(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x4000)|value<<14)
}
func (o *COMP1_Type) GetCOMP1_CSR_WINOUT() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x4000) >> 14
}
func (o *COMP1_Type) SetCOMP1_CSR_POLARITY(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *COMP1_Type) GetCOMP1_CSR_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x8000) >> 15
}
func (o *COMP1_Type) SetCOMP1_CSR_HYST(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x30000)|value<<16)
}
func (o *COMP1_Type) GetCOMP1_CSR_HYST() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x30000) >> 16
}
func (o *COMP1_Type) SetCOMP1_CSR_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0xc0000)|value<<18)
}
func (o *COMP1_Type) GetCOMP1_CSR_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0xc0000) >> 18
}
func (o *COMP1_Type) SetCOMP1_CSR_BLANKSEL(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x1f00000)|value<<20)
}
func (o *COMP1_Type) GetCOMP1_CSR_BLANKSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x1f00000) >> 20
}
func (o *COMP1_Type) SetCOMP1_CSR_VALUE(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *COMP1_Type) GetCOMP1_CSR_VALUE() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x40000000) >> 30
}
func (o *COMP1_Type) SetCOMP1_CSR_LOCK(value uint32) {
	volatile.StoreUint32(&o.COMP1_CSR.Reg, volatile.LoadUint32(&o.COMP1_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP1_Type) GetCOMP1_CSR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.COMP1_CSR.Reg) & 0x80000000) >> 31
}

// COMP1.COMP2_CSR: Comparator 2 control and status register
func (o *COMP1_Type) SetCOMP2_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x1)|value)
}
func (o *COMP1_Type) GetCOMP2_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x1
}
func (o *COMP1_Type) SetCOMP2_CSR_INMSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0xf0)|value<<4)
}
func (o *COMP1_Type) GetCOMP2_CSR_INMSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0xf0) >> 4
}
func (o *COMP1_Type) SetCOMP2_CSR_INPSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x300)|value<<8)
}
func (o *COMP1_Type) GetCOMP2_CSR_INPSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x300) >> 8
}
func (o *COMP1_Type) SetCOMP2_CSR_WINMODE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x800)|value<<11)
}
func (o *COMP1_Type) GetCOMP2_CSR_WINMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x800) >> 11
}
func (o *COMP1_Type) SetCOMP2_CSR_WINOUT(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x4000)|value<<14)
}
func (o *COMP1_Type) GetCOMP2_CSR_WINOUT() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x4000) >> 14
}
func (o *COMP1_Type) SetCOMP2_CSR_POLARITY(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x8000)|value<<15)
}
func (o *COMP1_Type) GetCOMP2_CSR_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x8000) >> 15
}
func (o *COMP1_Type) SetCOMP2_CSR_HYST(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x30000)|value<<16)
}
func (o *COMP1_Type) GetCOMP2_CSR_HYST() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x30000) >> 16
}
func (o *COMP1_Type) SetCOMP2_CSR_PWRMODE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0xc0000)|value<<18)
}
func (o *COMP1_Type) GetCOMP2_CSR_PWRMODE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0xc0000) >> 18
}
func (o *COMP1_Type) SetCOMP2_CSR_BLANKSEL(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x1f00000)|value<<20)
}
func (o *COMP1_Type) GetCOMP2_CSR_BLANKSEL() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x1f00000) >> 20
}
func (o *COMP1_Type) SetCOMP2_CSR_VALUE(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *COMP1_Type) GetCOMP2_CSR_VALUE() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x40000000) >> 30
}
func (o *COMP1_Type) SetCOMP2_CSR_LOCK(value uint32) {
	volatile.StoreUint32(&o.COMP2_CSR.Reg, volatile.LoadUint32(&o.COMP2_CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *COMP1_Type) GetCOMP2_CSR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.COMP2_CSR.Reg) & 0x80000000) >> 31
}

// System configuration controller
type SYSCFG_Type struct {
	CFGR1       volatile.Register32 // 0x0
	_           [20]byte
	CFGR2       volatile.Register32 // 0x18
	_           [20]byte
	VREFBUF_CSR volatile.Register32 // 0x30
	VREFBUF_CCR volatile.Register32 // 0x34
	_           [72]byte
	ITLINE0     volatile.Register32 // 0x80
	ITLINE1     volatile.Register32 // 0x84
	ITLINE2     volatile.Register32 // 0x88
	ITLINE3     volatile.Register32 // 0x8C
	ITLINE4     volatile.Register32 // 0x90
	ITLINE5     volatile.Register32 // 0x94
	ITLINE6     volatile.Register32 // 0x98
	ITLINE7     volatile.Register32 // 0x9C
	ITLINE8     volatile.Register32 // 0xA0
	ITLINE9     volatile.Register32 // 0xA4
	ITLINE10    volatile.Register32 // 0xA8
	ITLINE11    volatile.Register32 // 0xAC
	ITLINE12    volatile.Register32 // 0xB0
	ITLINE13    volatile.Register32 // 0xB4
	ITLINE14    volatile.Register32 // 0xB8
	ITLINE15    volatile.Register32 // 0xBC
	ITLINE16    volatile.Register32 // 0xC0
	ITLINE17    volatile.Register32 // 0xC4
	ITLINE18    volatile.Register32 // 0xC8
	ITLINE19    volatile.Register32 // 0xCC
	ITLINE20    volatile.Register32 // 0xD0
	ITLINE21    volatile.Register32 // 0xD4
	ITLINE22    volatile.Register32 // 0xD8
	ITLINE23    volatile.Register32 // 0xDC
	ITLINE24    volatile.Register32 // 0xE0
	ITLINE25    volatile.Register32 // 0xE4
	ITLINE26    volatile.Register32 // 0xE8
	ITLINE27    volatile.Register32 // 0xEC
	ITLINE28    volatile.Register32 // 0xF0
	ITLINE29    volatile.Register32 // 0xF4
	ITLINE30    volatile.Register32 // 0xF8
	ITLINE31    volatile.Register32 // 0xFC
}

// SYSCFG.CFGR1: SYSCFG configuration register 1
func (o *SYSCFG_Type) SetCFGR1_I2C_PAx_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc00000)|value<<22)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PAx_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc00000) >> 22
}
func (o *SYSCFG_Type) SetCFGR1_I2C2_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCFG_Type) GetCFGR1_I2C2_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x200000) >> 21
}
func (o *SYSCFG_Type) SetCFGR1_I2C1_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCFG_Type) GetCFGR1_I2C1_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100000) >> 20
}
func (o *SYSCFG_Type) SetCFGR1_I2C_PBx_FMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xf0000)|value<<16)
}
func (o *SYSCFG_Type) GetCFGR1_I2C_PBx_FMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xf0000) >> 16
}
func (o *SYSCFG_Type) SetCFGR1_UCPD2_STROBE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x400)|value<<10)
}
func (o *SYSCFG_Type) GetCFGR1_UCPD2_STROBE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x400) >> 10
}
func (o *SYSCFG_Type) SetCFGR1_UCPD1_STROBE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x200)|value<<9)
}
func (o *SYSCFG_Type) GetCFGR1_UCPD1_STROBE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x200) >> 9
}
func (o *SYSCFG_Type) SetCFGR1_BOOSTEN(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCFGR1_BOOSTEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetCFGR1_IR_MOD(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCFG_Type) GetCFGR1_IR_MOD() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xc0) >> 6
}
func (o *SYSCFG_Type) SetCFGR1_IR_POL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetCFGR1_IR_POL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetCFGR1_PA11_PA12_RMP(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetCFGR1_PA11_PA12_RMP() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetCFGR1_MEM_MODE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x3)|value)
}
func (o *SYSCFG_Type) GetCFGR1_MEM_MODE() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x3
}

// SYSCFG.CFGR2: SYSCFG configuration register 1
func (o *SYSCFG_Type) SetCFGR2_LOCKUP_LOCK(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetCFGR2_LOCKUP_LOCK() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x1
}
func (o *SYSCFG_Type) SetCFGR2_SRAM_PARITY_LOCK(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetCFGR2_SRAM_PARITY_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetCFGR2_PVD_LOCK(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetCFGR2_PVD_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetCFGR2_ECC_LOCK(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetCFGR2_ECC_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetCFGR2_SRAM_PEF(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCFGR2_SRAM_PEF() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x100) >> 8
}

// SYSCFG.VREFBUF_CSR: VREFBUF control and status register
func (o *SYSCFG_Type) SetVREFBUF_CSR_ENVR(value uint32) {
	volatile.StoreUint32(&o.VREFBUF_CSR.Reg, volatile.LoadUint32(&o.VREFBUF_CSR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetVREFBUF_CSR_ENVR() uint32 {
	return volatile.LoadUint32(&o.VREFBUF_CSR.Reg) & 0x1
}
func (o *SYSCFG_Type) SetVREFBUF_CSR_HIZ(value uint32) {
	volatile.StoreUint32(&o.VREFBUF_CSR.Reg, volatile.LoadUint32(&o.VREFBUF_CSR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetVREFBUF_CSR_HIZ() uint32 {
	return (volatile.LoadUint32(&o.VREFBUF_CSR.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetVREFBUF_CSR_VRR(value uint32) {
	volatile.StoreUint32(&o.VREFBUF_CSR.Reg, volatile.LoadUint32(&o.VREFBUF_CSR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetVREFBUF_CSR_VRR() uint32 {
	return (volatile.LoadUint32(&o.VREFBUF_CSR.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetVREFBUF_CSR_VRS(value uint32) {
	volatile.StoreUint32(&o.VREFBUF_CSR.Reg, volatile.LoadUint32(&o.VREFBUF_CSR.Reg)&^(0x70)|value<<4)
}
func (o *SYSCFG_Type) GetVREFBUF_CSR_VRS() uint32 {
	return (volatile.LoadUint32(&o.VREFBUF_CSR.Reg) & 0x70) >> 4
}

// SYSCFG.VREFBUF_CCR: VREFBUF calibration control register
func (o *SYSCFG_Type) SetVREFBUF_CCR_TRIM(value uint32) {
	volatile.StoreUint32(&o.VREFBUF_CCR.Reg, volatile.LoadUint32(&o.VREFBUF_CCR.Reg)&^(0x3f)|value)
}
func (o *SYSCFG_Type) GetVREFBUF_CCR_TRIM() uint32 {
	return volatile.LoadUint32(&o.VREFBUF_CCR.Reg) & 0x3f
}

// SYSCFG.ITLINE0: interrupt line 0 status register
func (o *SYSCFG_Type) SetITLINE0_WWDG(value uint32) {
	volatile.StoreUint32(&o.ITLINE0.Reg, volatile.LoadUint32(&o.ITLINE0.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE0_WWDG() uint32 {
	return volatile.LoadUint32(&o.ITLINE0.Reg) & 0x1
}

// SYSCFG.ITLINE1: interrupt line 1 status register
func (o *SYSCFG_Type) SetITLINE1_PVDOUT(value uint32) {
	volatile.StoreUint32(&o.ITLINE1.Reg, volatile.LoadUint32(&o.ITLINE1.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE1_PVDOUT() uint32 {
	return volatile.LoadUint32(&o.ITLINE1.Reg) & 0x1
}

// SYSCFG.ITLINE2: interrupt line 2 status register
func (o *SYSCFG_Type) SetITLINE2_TAMP(value uint32) {
	volatile.StoreUint32(&o.ITLINE2.Reg, volatile.LoadUint32(&o.ITLINE2.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE2_TAMP() uint32 {
	return volatile.LoadUint32(&o.ITLINE2.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE2_RTC(value uint32) {
	volatile.StoreUint32(&o.ITLINE2.Reg, volatile.LoadUint32(&o.ITLINE2.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE2_RTC() uint32 {
	return (volatile.LoadUint32(&o.ITLINE2.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE3: interrupt line 3 status register
func (o *SYSCFG_Type) SetITLINE3_FLASH_ITF(value uint32) {
	volatile.StoreUint32(&o.ITLINE3.Reg, volatile.LoadUint32(&o.ITLINE3.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE3_FLASH_ITF() uint32 {
	return volatile.LoadUint32(&o.ITLINE3.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE3_FLASH_ECC(value uint32) {
	volatile.StoreUint32(&o.ITLINE3.Reg, volatile.LoadUint32(&o.ITLINE3.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE3_FLASH_ECC() uint32 {
	return (volatile.LoadUint32(&o.ITLINE3.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE4: interrupt line 4 status register
func (o *SYSCFG_Type) SetITLINE4_RCC(value uint32) {
	volatile.StoreUint32(&o.ITLINE4.Reg, volatile.LoadUint32(&o.ITLINE4.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE4_RCC() uint32 {
	return volatile.LoadUint32(&o.ITLINE4.Reg) & 0x1
}

// SYSCFG.ITLINE5: interrupt line 5 status register
func (o *SYSCFG_Type) SetITLINE5_EXTI0(value uint32) {
	volatile.StoreUint32(&o.ITLINE5.Reg, volatile.LoadUint32(&o.ITLINE5.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE5_EXTI0() uint32 {
	return volatile.LoadUint32(&o.ITLINE5.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE5_EXTI1(value uint32) {
	volatile.StoreUint32(&o.ITLINE5.Reg, volatile.LoadUint32(&o.ITLINE5.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE5_EXTI1() uint32 {
	return (volatile.LoadUint32(&o.ITLINE5.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE6: interrupt line 6 status register
func (o *SYSCFG_Type) SetITLINE6_EXTI2(value uint32) {
	volatile.StoreUint32(&o.ITLINE6.Reg, volatile.LoadUint32(&o.ITLINE6.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE6_EXTI2() uint32 {
	return volatile.LoadUint32(&o.ITLINE6.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE6_EXTI3(value uint32) {
	volatile.StoreUint32(&o.ITLINE6.Reg, volatile.LoadUint32(&o.ITLINE6.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE6_EXTI3() uint32 {
	return (volatile.LoadUint32(&o.ITLINE6.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE7: interrupt line 7 status register
func (o *SYSCFG_Type) SetITLINE7_EXTI4(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI4() uint32 {
	return volatile.LoadUint32(&o.ITLINE7.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE7_EXTI5(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI5() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetITLINE7_EXTI6(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI6() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetITLINE7_EXTI7(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI7() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetITLINE7_EXTI8(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI8() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetITLINE7_EXTI9(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI9() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetITLINE7_EXTI10(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI10() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetITLINE7_EXTI11(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI11() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetITLINE7_EXTI12(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI12() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetITLINE7_EXTI13(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x200)|value<<9)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI13() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x200) >> 9
}
func (o *SYSCFG_Type) SetITLINE7_EXTI14(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x400)|value<<10)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI14() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x400) >> 10
}
func (o *SYSCFG_Type) SetITLINE7_EXTI15(value uint32) {
	volatile.StoreUint32(&o.ITLINE7.Reg, volatile.LoadUint32(&o.ITLINE7.Reg)&^(0x800)|value<<11)
}
func (o *SYSCFG_Type) GetITLINE7_EXTI15() uint32 {
	return (volatile.LoadUint32(&o.ITLINE7.Reg) & 0x800) >> 11
}

// SYSCFG.ITLINE8: interrupt line 8 status register
func (o *SYSCFG_Type) SetITLINE8_UCPD1(value uint32) {
	volatile.StoreUint32(&o.ITLINE8.Reg, volatile.LoadUint32(&o.ITLINE8.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE8_UCPD1() uint32 {
	return volatile.LoadUint32(&o.ITLINE8.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE8_UCPD2(value uint32) {
	volatile.StoreUint32(&o.ITLINE8.Reg, volatile.LoadUint32(&o.ITLINE8.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE8_UCPD2() uint32 {
	return (volatile.LoadUint32(&o.ITLINE8.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE9: interrupt line 9 status register
func (o *SYSCFG_Type) SetITLINE9_DMA1_CH1(value uint32) {
	volatile.StoreUint32(&o.ITLINE9.Reg, volatile.LoadUint32(&o.ITLINE9.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE9_DMA1_CH1() uint32 {
	return volatile.LoadUint32(&o.ITLINE9.Reg) & 0x1
}

// SYSCFG.ITLINE10: interrupt line 10 status register
func (o *SYSCFG_Type) SetITLINE10_DMA1_CH2(value uint32) {
	volatile.StoreUint32(&o.ITLINE10.Reg, volatile.LoadUint32(&o.ITLINE10.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE10_DMA1_CH2() uint32 {
	return volatile.LoadUint32(&o.ITLINE10.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE10_DMA1_CH3(value uint32) {
	volatile.StoreUint32(&o.ITLINE10.Reg, volatile.LoadUint32(&o.ITLINE10.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE10_DMA1_CH3() uint32 {
	return (volatile.LoadUint32(&o.ITLINE10.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE11: interrupt line 11 status register
func (o *SYSCFG_Type) SetITLINE11_DMAMUX(value uint32) {
	volatile.StoreUint32(&o.ITLINE11.Reg, volatile.LoadUint32(&o.ITLINE11.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE11_DMAMUX() uint32 {
	return volatile.LoadUint32(&o.ITLINE11.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE11_DMA1_CH4(value uint32) {
	volatile.StoreUint32(&o.ITLINE11.Reg, volatile.LoadUint32(&o.ITLINE11.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE11_DMA1_CH4() uint32 {
	return (volatile.LoadUint32(&o.ITLINE11.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetITLINE11_DMA1_CH5(value uint32) {
	volatile.StoreUint32(&o.ITLINE11.Reg, volatile.LoadUint32(&o.ITLINE11.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetITLINE11_DMA1_CH5() uint32 {
	return (volatile.LoadUint32(&o.ITLINE11.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetITLINE11_DMA1_CH6(value uint32) {
	volatile.StoreUint32(&o.ITLINE11.Reg, volatile.LoadUint32(&o.ITLINE11.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetITLINE11_DMA1_CH6() uint32 {
	return (volatile.LoadUint32(&o.ITLINE11.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetITLINE11_DMA1_CH7(value uint32) {
	volatile.StoreUint32(&o.ITLINE11.Reg, volatile.LoadUint32(&o.ITLINE11.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetITLINE11_DMA1_CH7() uint32 {
	return (volatile.LoadUint32(&o.ITLINE11.Reg) & 0x10) >> 4
}

// SYSCFG.ITLINE12: interrupt line 12 status register
func (o *SYSCFG_Type) SetITLINE12_ADC(value uint32) {
	volatile.StoreUint32(&o.ITLINE12.Reg, volatile.LoadUint32(&o.ITLINE12.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE12_ADC() uint32 {
	return volatile.LoadUint32(&o.ITLINE12.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE12_COMP1(value uint32) {
	volatile.StoreUint32(&o.ITLINE12.Reg, volatile.LoadUint32(&o.ITLINE12.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE12_COMP1() uint32 {
	return (volatile.LoadUint32(&o.ITLINE12.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetITLINE12_COMP2(value uint32) {
	volatile.StoreUint32(&o.ITLINE12.Reg, volatile.LoadUint32(&o.ITLINE12.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetITLINE12_COMP2() uint32 {
	return (volatile.LoadUint32(&o.ITLINE12.Reg) & 0x4) >> 2
}

// SYSCFG.ITLINE13: interrupt line 13 status register
func (o *SYSCFG_Type) SetITLINE13_TIM1_CCU(value uint32) {
	volatile.StoreUint32(&o.ITLINE13.Reg, volatile.LoadUint32(&o.ITLINE13.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE13_TIM1_CCU() uint32 {
	return volatile.LoadUint32(&o.ITLINE13.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE13_TIM1_TRG(value uint32) {
	volatile.StoreUint32(&o.ITLINE13.Reg, volatile.LoadUint32(&o.ITLINE13.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE13_TIM1_TRG() uint32 {
	return (volatile.LoadUint32(&o.ITLINE13.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetITLINE13_TIM1_UPD(value uint32) {
	volatile.StoreUint32(&o.ITLINE13.Reg, volatile.LoadUint32(&o.ITLINE13.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetITLINE13_TIM1_UPD() uint32 {
	return (volatile.LoadUint32(&o.ITLINE13.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetITLINE13_TIM1_BRK(value uint32) {
	volatile.StoreUint32(&o.ITLINE13.Reg, volatile.LoadUint32(&o.ITLINE13.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetITLINE13_TIM1_BRK() uint32 {
	return (volatile.LoadUint32(&o.ITLINE13.Reg) & 0x8) >> 3
}

// SYSCFG.ITLINE14: interrupt line 14 status register
func (o *SYSCFG_Type) SetITLINE14_TIM1_CC(value uint32) {
	volatile.StoreUint32(&o.ITLINE14.Reg, volatile.LoadUint32(&o.ITLINE14.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE14_TIM1_CC() uint32 {
	return volatile.LoadUint32(&o.ITLINE14.Reg) & 0x1
}

// SYSCFG.ITLINE15: interrupt line 15 status register
func (o *SYSCFG_Type) SetITLINE15_TIM2(value uint32) {
	volatile.StoreUint32(&o.ITLINE15.Reg, volatile.LoadUint32(&o.ITLINE15.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE15_TIM2() uint32 {
	return volatile.LoadUint32(&o.ITLINE15.Reg) & 0x1
}

// SYSCFG.ITLINE16: interrupt line 16 status register
func (o *SYSCFG_Type) SetITLINE16_TIM3(value uint32) {
	volatile.StoreUint32(&o.ITLINE16.Reg, volatile.LoadUint32(&o.ITLINE16.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE16_TIM3() uint32 {
	return volatile.LoadUint32(&o.ITLINE16.Reg) & 0x1
}

// SYSCFG.ITLINE17: interrupt line 17 status register
func (o *SYSCFG_Type) SetITLINE17_TIM6(value uint32) {
	volatile.StoreUint32(&o.ITLINE17.Reg, volatile.LoadUint32(&o.ITLINE17.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE17_TIM6() uint32 {
	return volatile.LoadUint32(&o.ITLINE17.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE17_DAC(value uint32) {
	volatile.StoreUint32(&o.ITLINE17.Reg, volatile.LoadUint32(&o.ITLINE17.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE17_DAC() uint32 {
	return (volatile.LoadUint32(&o.ITLINE17.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetITLINE17_LPTIM1(value uint32) {
	volatile.StoreUint32(&o.ITLINE17.Reg, volatile.LoadUint32(&o.ITLINE17.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetITLINE17_LPTIM1() uint32 {
	return (volatile.LoadUint32(&o.ITLINE17.Reg) & 0x4) >> 2
}

// SYSCFG.ITLINE18: interrupt line 18 status register
func (o *SYSCFG_Type) SetITLINE18_TIM7(value uint32) {
	volatile.StoreUint32(&o.ITLINE18.Reg, volatile.LoadUint32(&o.ITLINE18.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE18_TIM7() uint32 {
	return volatile.LoadUint32(&o.ITLINE18.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE18_LPTIM2(value uint32) {
	volatile.StoreUint32(&o.ITLINE18.Reg, volatile.LoadUint32(&o.ITLINE18.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE18_LPTIM2() uint32 {
	return (volatile.LoadUint32(&o.ITLINE18.Reg) & 0x2) >> 1
}

// SYSCFG.ITLINE19: interrupt line 19 status register
func (o *SYSCFG_Type) SetITLINE19_TIM14(value uint32) {
	volatile.StoreUint32(&o.ITLINE19.Reg, volatile.LoadUint32(&o.ITLINE19.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE19_TIM14() uint32 {
	return volatile.LoadUint32(&o.ITLINE19.Reg) & 0x1
}

// SYSCFG.ITLINE20: interrupt line 20 status register
func (o *SYSCFG_Type) SetITLINE20_TIM15(value uint32) {
	volatile.StoreUint32(&o.ITLINE20.Reg, volatile.LoadUint32(&o.ITLINE20.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE20_TIM15() uint32 {
	return volatile.LoadUint32(&o.ITLINE20.Reg) & 0x1
}

// SYSCFG.ITLINE21: interrupt line 21 status register
func (o *SYSCFG_Type) SetITLINE21_TIM16(value uint32) {
	volatile.StoreUint32(&o.ITLINE21.Reg, volatile.LoadUint32(&o.ITLINE21.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE21_TIM16() uint32 {
	return volatile.LoadUint32(&o.ITLINE21.Reg) & 0x1
}

// SYSCFG.ITLINE22: interrupt line 22 status register
func (o *SYSCFG_Type) SetITLINE22_TIM17(value uint32) {
	volatile.StoreUint32(&o.ITLINE22.Reg, volatile.LoadUint32(&o.ITLINE22.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE22_TIM17() uint32 {
	return volatile.LoadUint32(&o.ITLINE22.Reg) & 0x1
}

// SYSCFG.ITLINE23: interrupt line 23 status register
func (o *SYSCFG_Type) SetITLINE23_I2C1(value uint32) {
	volatile.StoreUint32(&o.ITLINE23.Reg, volatile.LoadUint32(&o.ITLINE23.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE23_I2C1() uint32 {
	return volatile.LoadUint32(&o.ITLINE23.Reg) & 0x1
}

// SYSCFG.ITLINE24: interrupt line 24 status register
func (o *SYSCFG_Type) SetITLINE24_I2C2(value uint32) {
	volatile.StoreUint32(&o.ITLINE24.Reg, volatile.LoadUint32(&o.ITLINE24.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE24_I2C2() uint32 {
	return volatile.LoadUint32(&o.ITLINE24.Reg) & 0x1
}

// SYSCFG.ITLINE25: interrupt line 25 status register
func (o *SYSCFG_Type) SetITLINE25_SPI1(value uint32) {
	volatile.StoreUint32(&o.ITLINE25.Reg, volatile.LoadUint32(&o.ITLINE25.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE25_SPI1() uint32 {
	return volatile.LoadUint32(&o.ITLINE25.Reg) & 0x1
}

// SYSCFG.ITLINE26: interrupt line 26 status register
func (o *SYSCFG_Type) SetITLINE26_SPI2(value uint32) {
	volatile.StoreUint32(&o.ITLINE26.Reg, volatile.LoadUint32(&o.ITLINE26.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE26_SPI2() uint32 {
	return volatile.LoadUint32(&o.ITLINE26.Reg) & 0x1
}

// SYSCFG.ITLINE27: interrupt line 27 status register
func (o *SYSCFG_Type) SetITLINE27_USART1(value uint32) {
	volatile.StoreUint32(&o.ITLINE27.Reg, volatile.LoadUint32(&o.ITLINE27.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE27_USART1() uint32 {
	return volatile.LoadUint32(&o.ITLINE27.Reg) & 0x1
}

// SYSCFG.ITLINE28: interrupt line 28 status register
func (o *SYSCFG_Type) SetITLINE28_USART2(value uint32) {
	volatile.StoreUint32(&o.ITLINE28.Reg, volatile.LoadUint32(&o.ITLINE28.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE28_USART2() uint32 {
	return volatile.LoadUint32(&o.ITLINE28.Reg) & 0x1
}

// SYSCFG.ITLINE29: interrupt line 29 status register
func (o *SYSCFG_Type) SetITLINE29_USART3(value uint32) {
	volatile.StoreUint32(&o.ITLINE29.Reg, volatile.LoadUint32(&o.ITLINE29.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE29_USART3() uint32 {
	return volatile.LoadUint32(&o.ITLINE29.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE29_USART4(value uint32) {
	volatile.StoreUint32(&o.ITLINE29.Reg, volatile.LoadUint32(&o.ITLINE29.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE29_USART4() uint32 {
	return (volatile.LoadUint32(&o.ITLINE29.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetITLINE29_USART5(value uint32) {
	volatile.StoreUint32(&o.ITLINE29.Reg, volatile.LoadUint32(&o.ITLINE29.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetITLINE29_USART5() uint32 {
	return (volatile.LoadUint32(&o.ITLINE29.Reg) & 0x4) >> 2
}

// SYSCFG.ITLINE30: interrupt line 30 status register
func (o *SYSCFG_Type) SetITLINE30_USART2(value uint32) {
	volatile.StoreUint32(&o.ITLINE30.Reg, volatile.LoadUint32(&o.ITLINE30.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE30_USART2() uint32 {
	return volatile.LoadUint32(&o.ITLINE30.Reg) & 0x1
}

// SYSCFG.ITLINE31: interrupt line 31 status register
func (o *SYSCFG_Type) SetITLINE31_RNG(value uint32) {
	volatile.StoreUint32(&o.ITLINE31.Reg, volatile.LoadUint32(&o.ITLINE31.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetITLINE31_RNG() uint32 {
	return volatile.LoadUint32(&o.ITLINE31.Reg) & 0x1
}
func (o *SYSCFG_Type) SetITLINE31_AES(value uint32) {
	volatile.StoreUint32(&o.ITLINE31.Reg, volatile.LoadUint32(&o.ITLINE31.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetITLINE31_AES() uint32 {
	return (volatile.LoadUint32(&o.ITLINE31.Reg) & 0x2) >> 1
}

// Tamper and backup registers
type TAMP_Type struct {
	CR1     volatile.Register32 // 0x0
	CR2     volatile.Register32 // 0x4
	_       [4]byte
	FLTCR   volatile.Register32 // 0xC
	_       [28]byte
	IER     volatile.Register32 // 0x2C
	SR      volatile.Register32 // 0x30
	MISR    volatile.Register32 // 0x34
	_       [4]byte
	SCR     volatile.Register32 // 0x3C
	_       [192]byte
	BKP0R   volatile.Register32 // 0x100
	BKP1R   volatile.Register32 // 0x104
	BKP2R   volatile.Register32 // 0x108
	BKP3R   volatile.Register32 // 0x10C
	BKP4R   volatile.Register32 // 0x110
	_       [728]byte
	HWCFGR2 volatile.Register32 // 0x3EC
	HWCFGR1 volatile.Register32 // 0x3F0
	VERR    volatile.Register32 // 0x3F4
	IPIDR   volatile.Register32 // 0x3F8
	SIDR    volatile.Register32 // 0x3FC
}

// TAMP.CR1: control register 1
func (o *TAMP_Type) SetCR1_TAMP1E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetCR1_TAMP1E() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *TAMP_Type) SetCR1_TAMP2E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetCR1_TAMP2E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetCR1_ITAMP1E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetCR1_ITAMP1E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetCR1_ITAMP3E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetCR1_ITAMP3E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetCR1_ITAMP4E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *TAMP_Type) GetCR1_ITAMP4E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *TAMP_Type) SetCR1_ITAMP5E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetCR1_ITAMP5E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetCR1_ITAMP6E(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetCR1_ITAMP6E() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}

// TAMP.CR2: control register 2
func (o *TAMP_Type) SetCR2_TAMP1NOER(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetCR2_TAMP1NOER() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *TAMP_Type) SetCR2_TAMP2NOER(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetCR2_TAMP2NOER() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetCR2_TAMP1MSK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetCR2_TAMP1MSK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetCR2_TAMP2MSK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *TAMP_Type) GetCR2_TAMP2MSK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *TAMP_Type) SetCR2_TAMP1TRG(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *TAMP_Type) GetCR2_TAMP1TRG() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *TAMP_Type) SetCR2_TAMP2TRG(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *TAMP_Type) GetCR2_TAMP2TRG() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}

// TAMP.FLTCR: TAMP filter control register
func (o *TAMP_Type) SetFLTCR_TAMPFREQ(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x7)|value)
}
func (o *TAMP_Type) GetFLTCR_TAMPFREQ() uint32 {
	return volatile.LoadUint32(&o.FLTCR.Reg) & 0x7
}
func (o *TAMP_Type) SetFLTCR_TAMPFLT(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x18)|value<<3)
}
func (o *TAMP_Type) GetFLTCR_TAMPFLT() uint32 {
	return (volatile.LoadUint32(&o.FLTCR.Reg) & 0x18) >> 3
}
func (o *TAMP_Type) SetFLTCR_TAMPPRCH(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x60)|value<<5)
}
func (o *TAMP_Type) GetFLTCR_TAMPPRCH() uint32 {
	return (volatile.LoadUint32(&o.FLTCR.Reg) & 0x60) >> 5
}
func (o *TAMP_Type) SetFLTCR_TAMPPUDIS(value uint32) {
	volatile.StoreUint32(&o.FLTCR.Reg, volatile.LoadUint32(&o.FLTCR.Reg)&^(0x80)|value<<7)
}
func (o *TAMP_Type) GetFLTCR_TAMPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.FLTCR.Reg) & 0x80) >> 7
}

// TAMP.IER: TAMP interrupt enable register
func (o *TAMP_Type) SetIER_TAMP1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetIER_TAMP1IE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TAMP_Type) SetIER_TAMP2IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetIER_TAMP2IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetIER_ITAMP1IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetIER_ITAMP1IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetIER_ITAMP3IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetIER_ITAMP3IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetIER_ITAMP4IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *TAMP_Type) GetIER_ITAMP4IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *TAMP_Type) SetIER_ITAMP5IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetIER_ITAMP5IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetIER_ITAMP6IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetIER_ITAMP6IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}

// TAMP.SR: TAMP status register
func (o *TAMP_Type) SetSR_TAMP1F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetSR_TAMP1F() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TAMP_Type) SetSR_TAMP2F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetSR_TAMP2F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetSR_ITAMP1F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetSR_ITAMP1F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetSR_ITAMP3F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetSR_ITAMP3F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetSR_ITAMP4F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *TAMP_Type) GetSR_ITAMP4F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *TAMP_Type) SetSR_ITAMP5F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetSR_ITAMP5F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetSR_ITAMP6F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetSR_ITAMP6F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetSR_ITAMP7F(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *TAMP_Type) GetSR_ITAMP7F() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}

// TAMP.MISR: TAMP masked interrupt status register
func (o *TAMP_Type) SetMISR_TAMP1MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetMISR_TAMP1MF() uint32 {
	return volatile.LoadUint32(&o.MISR.Reg) & 0x1
}
func (o *TAMP_Type) SetMISR_TAMP2MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetMISR_TAMP2MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetMISR_ITAMP1MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetMISR_ITAMP1MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetMISR_ITAMP3MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetMISR_ITAMP3MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetMISR_ITAMP4MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x80000)|value<<19)
}
func (o *TAMP_Type) GetMISR_ITAMP4MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x80000) >> 19
}
func (o *TAMP_Type) SetMISR_ITAMP5MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetMISR_ITAMP5MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetMISR_ITAMP6MF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetMISR_ITAMP6MF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x200000) >> 21
}

// TAMP.SCR: TAMP status clear register
func (o *TAMP_Type) SetSCR_CTAMP1F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *TAMP_Type) GetSCR_CTAMP1F() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}
func (o *TAMP_Type) SetSCR_CTAMP2F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *TAMP_Type) GetSCR_CTAMP2F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *TAMP_Type) SetSCR_CITAMP1F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10000)|value<<16)
}
func (o *TAMP_Type) GetSCR_CITAMP1F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10000) >> 16
}
func (o *TAMP_Type) SetSCR_CITAMP3F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x40000)|value<<18)
}
func (o *TAMP_Type) GetSCR_CITAMP3F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x40000) >> 18
}
func (o *TAMP_Type) SetSCR_CITAMP4F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x80000)|value<<19)
}
func (o *TAMP_Type) GetSCR_CITAMP4F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x80000) >> 19
}
func (o *TAMP_Type) SetSCR_CITAMP5F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100000)|value<<20)
}
func (o *TAMP_Type) GetSCR_CITAMP5F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100000) >> 20
}
func (o *TAMP_Type) SetSCR_CITAMP6F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x200000)|value<<21)
}
func (o *TAMP_Type) GetSCR_CITAMP6F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x200000) >> 21
}
func (o *TAMP_Type) SetSCR_CITAMP7F(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x400000)|value<<22)
}
func (o *TAMP_Type) GetSCR_CITAMP7F() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x400000) >> 22
}

// TAMP.BKP0R: TAMP backup register
func (o *TAMP_Type) SetBKP0R(value uint32) {
	volatile.StoreUint32(&o.BKP0R.Reg, value)
}
func (o *TAMP_Type) GetBKP0R() uint32 {
	return volatile.LoadUint32(&o.BKP0R.Reg)
}

// TAMP.BKP1R: TAMP backup register
func (o *TAMP_Type) SetBKP1R(value uint32) {
	volatile.StoreUint32(&o.BKP1R.Reg, value)
}
func (o *TAMP_Type) GetBKP1R() uint32 {
	return volatile.LoadUint32(&o.BKP1R.Reg)
}

// TAMP.BKP2R: TAMP backup register
func (o *TAMP_Type) SetBKP2R(value uint32) {
	volatile.StoreUint32(&o.BKP2R.Reg, value)
}
func (o *TAMP_Type) GetBKP2R() uint32 {
	return volatile.LoadUint32(&o.BKP2R.Reg)
}

// TAMP.BKP3R: TAMP backup register
func (o *TAMP_Type) SetBKP3R(value uint32) {
	volatile.StoreUint32(&o.BKP3R.Reg, value)
}
func (o *TAMP_Type) GetBKP3R() uint32 {
	return volatile.LoadUint32(&o.BKP3R.Reg)
}

// TAMP.BKP4R: TAMP backup register
func (o *TAMP_Type) SetBKP4R(value uint32) {
	volatile.StoreUint32(&o.BKP4R.Reg, value)
}
func (o *TAMP_Type) GetBKP4R() uint32 {
	return volatile.LoadUint32(&o.BKP4R.Reg)
}

// TAMP.HWCFGR2: TAMP hardware configuration register 2
func (o *TAMP_Type) SetHWCFGR2_PTIONREG_OUT(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0xff)|value)
}
func (o *TAMP_Type) GetHWCFGR2_PTIONREG_OUT() uint32 {
	return volatile.LoadUint32(&o.HWCFGR2.Reg) & 0xff
}
func (o *TAMP_Type) SetHWCFGR2_TRUST_ZONE(value uint32) {
	volatile.StoreUint32(&o.HWCFGR2.Reg, volatile.LoadUint32(&o.HWCFGR2.Reg)&^(0xf00)|value<<8)
}
func (o *TAMP_Type) GetHWCFGR2_TRUST_ZONE() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR2.Reg) & 0xf00) >> 8
}

// TAMP.HWCFGR1: TAMP hardware configuration register 1
func (o *TAMP_Type) SetHWCFGR1_BACKUP_REGS(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xff)|value)
}
func (o *TAMP_Type) GetHWCFGR1_BACKUP_REGS() uint32 {
	return volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xff
}
func (o *TAMP_Type) SetHWCFGR1_TAMPER(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xf00)|value<<8)
}
func (o *TAMP_Type) GetHWCFGR1_TAMPER() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xf00) >> 8
}
func (o *TAMP_Type) SetHWCFGR1_ACTIVE_TAMPER(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xf000)|value<<12)
}
func (o *TAMP_Type) GetHWCFGR1_ACTIVE_TAMPER() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xf000) >> 12
}
func (o *TAMP_Type) SetHWCFGR1_INT_TAMPER(value uint32) {
	volatile.StoreUint32(&o.HWCFGR1.Reg, volatile.LoadUint32(&o.HWCFGR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *TAMP_Type) GetHWCFGR1_INT_TAMPER() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR1.Reg) & 0xffff0000) >> 16
}

// TAMP.VERR: EXTI IP Version register
func (o *TAMP_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *TAMP_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *TAMP_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *TAMP_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// TAMP.IPIDR: EXTI Identification register
func (o *TAMP_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *TAMP_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// TAMP.SIDR: EXTI Size ID register
func (o *TAMP_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *TAMP_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// USB Power Delivery interface
type UCPD_Type struct {
	CFG1       volatile.Register32 // 0x0
	CFG2       volatile.Register32 // 0x4
	CFG3       volatile.Register32 // 0x8
	CR         volatile.Register32 // 0xC
	IMR        volatile.Register32 // 0x10
	SR         volatile.Register32 // 0x14
	ICR        volatile.Register32 // 0x18
	TX_ORDSET  volatile.Register32 // 0x1C
	TX_PAYSZ   volatile.Register32 // 0x20
	TXDR       volatile.Register32 // 0x24
	RX_ORDSET  volatile.Register32 // 0x28
	RX_PAYSZ   volatile.Register32 // 0x2C
	RXDR       volatile.Register32 // 0x30
	RX_ORDEXT1 volatile.Register32 // 0x34
	RX_ORDEXT2 volatile.Register32 // 0x38
	_          [952]byte
	IPVER      volatile.Register32 // 0x3F4
	IPID       volatile.Register32 // 0x3F8
	MID        volatile.Register32 // 0x3FC
}

// UCPD.CFG1: UCPD configuration register
func (o *UCPD_Type) SetCFG1_HBITCLKDIV(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x3f)|value)
}
func (o *UCPD_Type) GetCFG1_HBITCLKDIV() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0x3f
}
func (o *UCPD_Type) SetCFG1_IFRGAP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x7c0)|value<<6)
}
func (o *UCPD_Type) GetCFG1_IFRGAP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x7c0) >> 6
}
func (o *UCPD_Type) SetCFG1_TRANSWIN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf800)|value<<11)
}
func (o *UCPD_Type) GetCFG1_TRANSWIN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xf800) >> 11
}
func (o *UCPD_Type) SetCFG1_PSC_USBPDCLK(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xe0000)|value<<17)
}
func (o *UCPD_Type) GetCFG1_PSC_USBPDCLK() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xe0000) >> 17
}
func (o *UCPD_Type) SetCFG1_RXORDSETEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1ff00000)|value<<20)
}
func (o *UCPD_Type) GetCFG1_RXORDSETEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1ff00000) >> 20
}
func (o *UCPD_Type) SetCFG1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x20000000)|value<<29)
}
func (o *UCPD_Type) GetCFG1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x20000000) >> 29
}
func (o *UCPD_Type) SetCFG1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x40000000)|value<<30)
}
func (o *UCPD_Type) GetCFG1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x40000000) >> 30
}
func (o *UCPD_Type) SetCFG1_UCPDEN(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x80000000)|value<<31)
}
func (o *UCPD_Type) GetCFG1_UCPDEN() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x80000000) >> 31
}

// UCPD.CFG2: UCPD configuration register 2
func (o *UCPD_Type) SetCFG2_RXFILTDIS(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1)|value)
}
func (o *UCPD_Type) GetCFG2_RXFILTDIS() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0x1
}
func (o *UCPD_Type) SetCFG2_RXFILT2N3(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2)|value<<1)
}
func (o *UCPD_Type) GetCFG2_RXFILT2N3() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2) >> 1
}
func (o *UCPD_Type) SetCFG2_FORCECLK(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4)|value<<2)
}
func (o *UCPD_Type) GetCFG2_FORCECLK() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4) >> 2
}
func (o *UCPD_Type) SetCFG2_WUPEN(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8)|value<<3)
}
func (o *UCPD_Type) GetCFG2_WUPEN() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8) >> 3
}

// UCPD.CFG3: UCPD configuration register 3
func (o *UCPD_Type) SetCFG3_TRIM1_NG_CCRPD(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf)|value)
}
func (o *UCPD_Type) GetCFG3_TRIM1_NG_CCRPD() uint32 {
	return volatile.LoadUint32(&o.CFG3.Reg) & 0xf
}
func (o *UCPD_Type) SetCFG3_TRIM1_NG_CC1A5(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1f0)|value<<4)
}
func (o *UCPD_Type) GetCFG3_TRIM1_NG_CC1A5() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1f0) >> 4
}
func (o *UCPD_Type) SetCFG3_TRIM1_NG_CC3A0(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1e00)|value<<9)
}
func (o *UCPD_Type) GetCFG3_TRIM1_NG_CC3A0() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1e00) >> 9
}
func (o *UCPD_Type) SetCFG3_TRIM2_NG_CCRPD(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf0000)|value<<16)
}
func (o *UCPD_Type) GetCFG3_TRIM2_NG_CCRPD() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xf0000) >> 16
}
func (o *UCPD_Type) SetCFG3_TRIM2_NG_CC1A5(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1f00000)|value<<20)
}
func (o *UCPD_Type) GetCFG3_TRIM2_NG_CC1A5() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1f00000) >> 20
}
func (o *UCPD_Type) SetCFG3_TRIM2_NG_CC3A0(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1e000000)|value<<25)
}
func (o *UCPD_Type) GetCFG3_TRIM2_NG_CC3A0() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1e000000) >> 25
}

// UCPD.CR: UCPD control register
func (o *UCPD_Type) SetCR_TXMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *UCPD_Type) GetCR_TXMODE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *UCPD_Type) SetCR_TXSEND(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *UCPD_Type) GetCR_TXSEND() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *UCPD_Type) SetCR_TXHRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *UCPD_Type) GetCR_TXHRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *UCPD_Type) SetCR_RXMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *UCPD_Type) GetCR_RXMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *UCPD_Type) SetCR_PHYRXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *UCPD_Type) GetCR_PHYRXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *UCPD_Type) SetCR_PHYCCSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *UCPD_Type) GetCR_PHYCCSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *UCPD_Type) SetCR_ANASUBMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x180)|value<<7)
}
func (o *UCPD_Type) GetCR_ANASUBMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x180) >> 7
}
func (o *UCPD_Type) SetCR_ANAMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *UCPD_Type) GetCR_ANAMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *UCPD_Type) SetCR_CCENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *UCPD_Type) GetCR_CCENABLE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *UCPD_Type) SetCR_DBATTEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *UCPD_Type) GetCR_DBATTEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *UCPD_Type) SetCR_FRSRXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *UCPD_Type) GetCR_FRSRXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *UCPD_Type) SetCR_FRSTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *UCPD_Type) GetCR_FRSTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *UCPD_Type) SetCR_RDCH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *UCPD_Type) GetCR_RDCH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *UCPD_Type) SetCR_CC1TCDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *UCPD_Type) GetCR_CC1TCDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *UCPD_Type) SetCR_CC2TCDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *UCPD_Type) GetCR_CC2TCDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}

// UCPD.IMR: UCPD Interrupt Mask Register
func (o *UCPD_Type) SetIMR_TXISIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *UCPD_Type) GetIMR_TXISIE() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *UCPD_Type) SetIMR_TXMSGDISCIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *UCPD_Type) GetIMR_TXMSGDISCIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *UCPD_Type) SetIMR_TXMSGSENTIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *UCPD_Type) GetIMR_TXMSGSENTIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *UCPD_Type) SetIMR_TXMSGABTIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *UCPD_Type) GetIMR_TXMSGABTIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *UCPD_Type) SetIMR_HRSTDISCIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *UCPD_Type) GetIMR_HRSTDISCIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *UCPD_Type) SetIMR_HRSTSENTIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *UCPD_Type) GetIMR_HRSTSENTIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *UCPD_Type) SetIMR_TXUNDIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *UCPD_Type) GetIMR_TXUNDIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *UCPD_Type) SetIMR_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *UCPD_Type) GetIMR_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *UCPD_Type) SetIMR_RXORDDETIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *UCPD_Type) GetIMR_RXORDDETIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *UCPD_Type) SetIMR_RXHRSTDETIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *UCPD_Type) GetIMR_RXHRSTDETIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *UCPD_Type) SetIMR_RXOVRIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *UCPD_Type) GetIMR_RXOVRIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *UCPD_Type) SetIMR_RXMSGENDIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *UCPD_Type) GetIMR_RXMSGENDIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *UCPD_Type) SetIMR_TYPECEVT1IE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *UCPD_Type) GetIMR_TYPECEVT1IE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *UCPD_Type) SetIMR_TYPECEVT2IE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *UCPD_Type) GetIMR_TYPECEVT2IE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *UCPD_Type) SetIMR_FRSEVTIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *UCPD_Type) GetIMR_FRSEVTIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}

// UCPD.SR: UCPD Status Register
func (o *UCPD_Type) SetSR_TXIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *UCPD_Type) GetSR_TXIS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *UCPD_Type) SetSR_TXMSGDISC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *UCPD_Type) GetSR_TXMSGDISC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *UCPD_Type) SetSR_TXMSGSENT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *UCPD_Type) GetSR_TXMSGSENT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *UCPD_Type) SetSR_TXMSGABT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *UCPD_Type) GetSR_TXMSGABT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *UCPD_Type) SetSR_HRSTDISC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *UCPD_Type) GetSR_HRSTDISC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *UCPD_Type) SetSR_HRSTSENT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *UCPD_Type) GetSR_HRSTSENT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *UCPD_Type) SetSR_TXUND(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *UCPD_Type) GetSR_TXUND() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *UCPD_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *UCPD_Type) GetSR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *UCPD_Type) SetSR_RXORDDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *UCPD_Type) GetSR_RXORDDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *UCPD_Type) SetSR_RXHRSTDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *UCPD_Type) GetSR_RXHRSTDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *UCPD_Type) SetSR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *UCPD_Type) GetSR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *UCPD_Type) SetSR_RXMSGEND(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *UCPD_Type) GetSR_RXMSGEND() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *UCPD_Type) SetSR_RXERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *UCPD_Type) GetSR_RXERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *UCPD_Type) SetSR_TYPECEVT1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *UCPD_Type) GetSR_TYPECEVT1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *UCPD_Type) SetSR_TYPECEVT2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *UCPD_Type) GetSR_TYPECEVT2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *UCPD_Type) SetSR_TYPEC_VSTATE_CC1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x30000)|value<<16)
}
func (o *UCPD_Type) GetSR_TYPEC_VSTATE_CC1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x30000) >> 16
}
func (o *UCPD_Type) SetSR_TYPEC_VSTATE_CC2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xc0000)|value<<18)
}
func (o *UCPD_Type) GetSR_TYPEC_VSTATE_CC2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xc0000) >> 18
}
func (o *UCPD_Type) SetSR_FRSEVT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *UCPD_Type) GetSR_FRSEVT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}

// UCPD.ICR: UCPD Interrupt Clear Register
func (o *UCPD_Type) SetICR_TXMSGDISCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *UCPD_Type) GetICR_TXMSGDISCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *UCPD_Type) SetICR_TXMSGSENTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *UCPD_Type) GetICR_TXMSGSENTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *UCPD_Type) SetICR_TXMSGABTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *UCPD_Type) GetICR_TXMSGABTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *UCPD_Type) SetICR_HRSTDISCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *UCPD_Type) GetICR_HRSTDISCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *UCPD_Type) SetICR_HRSTSENTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *UCPD_Type) GetICR_HRSTSENTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *UCPD_Type) SetICR_TXUNDCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *UCPD_Type) GetICR_TXUNDCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *UCPD_Type) SetICR_RXORDDETCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *UCPD_Type) GetICR_RXORDDETCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *UCPD_Type) SetICR_RXHRSTDETCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *UCPD_Type) GetICR_RXHRSTDETCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *UCPD_Type) SetICR_RXOVRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *UCPD_Type) GetICR_RXOVRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *UCPD_Type) SetICR_RXMSGENDCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *UCPD_Type) GetICR_RXMSGENDCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *UCPD_Type) SetICR_TYPECEVT1CF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4000)|value<<14)
}
func (o *UCPD_Type) GetICR_TYPECEVT1CF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4000) >> 14
}
func (o *UCPD_Type) SetICR_TYPECEVT2CF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8000)|value<<15)
}
func (o *UCPD_Type) GetICR_TYPECEVT2CF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8000) >> 15
}
func (o *UCPD_Type) SetICR_FRSEVTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *UCPD_Type) GetICR_FRSEVTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}

// UCPD.TX_ORDSET: UCPD Tx Ordered Set Type Register
func (o *UCPD_Type) SetTX_ORDSET_TXORDSET(value uint32) {
	volatile.StoreUint32(&o.TX_ORDSET.Reg, volatile.LoadUint32(&o.TX_ORDSET.Reg)&^(0xfffff)|value)
}
func (o *UCPD_Type) GetTX_ORDSET_TXORDSET() uint32 {
	return volatile.LoadUint32(&o.TX_ORDSET.Reg) & 0xfffff
}

// UCPD.TX_PAYSZ: UCPD Tx Paysize Register
func (o *UCPD_Type) SetTX_PAYSZ_TXPAYSZ(value uint32) {
	volatile.StoreUint32(&o.TX_PAYSZ.Reg, volatile.LoadUint32(&o.TX_PAYSZ.Reg)&^(0x3ff)|value)
}
func (o *UCPD_Type) GetTX_PAYSZ_TXPAYSZ() uint32 {
	return volatile.LoadUint32(&o.TX_PAYSZ.Reg) & 0x3ff
}

// UCPD.TXDR: UCPD Tx Data Register
func (o *UCPD_Type) SetTXDR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *UCPD_Type) GetTXDR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// UCPD.RX_ORDSET: UCPD Rx Ordered Set Register
func (o *UCPD_Type) SetRX_ORDSET_RXORDSET(value uint32) {
	volatile.StoreUint32(&o.RX_ORDSET.Reg, volatile.LoadUint32(&o.RX_ORDSET.Reg)&^(0x7)|value)
}
func (o *UCPD_Type) GetRX_ORDSET_RXORDSET() uint32 {
	return volatile.LoadUint32(&o.RX_ORDSET.Reg) & 0x7
}
func (o *UCPD_Type) SetRX_ORDSET_RXSOP3OF4(value uint32) {
	volatile.StoreUint32(&o.RX_ORDSET.Reg, volatile.LoadUint32(&o.RX_ORDSET.Reg)&^(0x8)|value<<3)
}
func (o *UCPD_Type) GetRX_ORDSET_RXSOP3OF4() uint32 {
	return (volatile.LoadUint32(&o.RX_ORDSET.Reg) & 0x8) >> 3
}
func (o *UCPD_Type) SetRX_ORDSET_RXSOPKINVALID(value uint32) {
	volatile.StoreUint32(&o.RX_ORDSET.Reg, volatile.LoadUint32(&o.RX_ORDSET.Reg)&^(0x70)|value<<4)
}
func (o *UCPD_Type) GetRX_ORDSET_RXSOPKINVALID() uint32 {
	return (volatile.LoadUint32(&o.RX_ORDSET.Reg) & 0x70) >> 4
}

// UCPD.RX_PAYSZ: UCPD Rx Paysize Register
func (o *UCPD_Type) SetRX_PAYSZ_RXPAYSZ(value uint32) {
	volatile.StoreUint32(&o.RX_PAYSZ.Reg, volatile.LoadUint32(&o.RX_PAYSZ.Reg)&^(0x3ff)|value)
}
func (o *UCPD_Type) GetRX_PAYSZ_RXPAYSZ() uint32 {
	return volatile.LoadUint32(&o.RX_PAYSZ.Reg) & 0x3ff
}

// UCPD.RXDR: UCPD Receive Data Register
func (o *UCPD_Type) SetRXDR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *UCPD_Type) GetRXDR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// UCPD.RX_ORDEXT1: UCPD Rx Ordered Set Extension Register
func (o *UCPD_Type) SetRX_ORDEXT1_RXSOPX1(value uint32) {
	volatile.StoreUint32(&o.RX_ORDEXT1.Reg, volatile.LoadUint32(&o.RX_ORDEXT1.Reg)&^(0xfffff)|value)
}
func (o *UCPD_Type) GetRX_ORDEXT1_RXSOPX1() uint32 {
	return volatile.LoadUint32(&o.RX_ORDEXT1.Reg) & 0xfffff
}

// UCPD.RX_ORDEXT2: UCPD Rx Ordered Set Extension Register
func (o *UCPD_Type) SetRX_ORDEXT2_RXSOPX2(value uint32) {
	volatile.StoreUint32(&o.RX_ORDEXT2.Reg, volatile.LoadUint32(&o.RX_ORDEXT2.Reg)&^(0xfffff)|value)
}
func (o *UCPD_Type) GetRX_ORDEXT2_RXSOPX2() uint32 {
	return volatile.LoadUint32(&o.RX_ORDEXT2.Reg) & 0xfffff
}

// UCPD.IPVER: UCPD IP ID register
func (o *UCPD_Type) SetIPVER(value uint32) {
	volatile.StoreUint32(&o.IPVER.Reg, value)
}
func (o *UCPD_Type) GetIPVER() uint32 {
	return volatile.LoadUint32(&o.IPVER.Reg)
}

// UCPD.IPID: UCPD IP ID register
func (o *UCPD_Type) SetIPID(value uint32) {
	volatile.StoreUint32(&o.IPID.Reg, value)
}
func (o *UCPD_Type) GetIPID() uint32 {
	return volatile.LoadUint32(&o.IPID.Reg)
}

// UCPD.MID: UCPD IP ID register
func (o *UCPD_Type) SetMID(value uint32) {
	volatile.StoreUint32(&o.MID.Reg, value)
}
func (o *UCPD_Type) GetMID() uint32 {
	return volatile.LoadUint32(&o.MID.Reg)
}

// Low power timer
type LPTIM_Type struct {
	ISR   volatile.Register32 // 0x0
	ICR   volatile.Register32 // 0x4
	IER   volatile.Register32 // 0x8
	CFGR  volatile.Register32 // 0xC
	CR    volatile.Register32 // 0x10
	CMP   volatile.Register32 // 0x14
	ARR   volatile.Register32 // 0x18
	CNT   volatile.Register32 // 0x1C
	_     [4]byte
	CFGR2 volatile.Register32 // 0x24
}

// LPTIM.ISR: Interrupt and Status Register
func (o *LPTIM_Type) SetISR_DOWN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetISR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetISR_UP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetISR_UP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetISR_ARROK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetISR_ARROK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetISR_CMPOK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetISR_CMPOK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetISR_EXTTRIG(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetISR_EXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetISR_ARRM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetISR_ARRM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetISR_CMPM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetISR_CMPM() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LPTIM.ICR: Interrupt Clear Register
func (o *LPTIM_Type) SetICR_DOWNCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetICR_DOWNCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetICR_UPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetICR_UPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetICR_ARROKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetICR_ARROKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetICR_CMPOKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetICR_CMPOKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetICR_EXTTRIGCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetICR_EXTTRIGCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetICR_ARRMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetICR_ARRMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetICR_CMPMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetICR_CMPMCF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LPTIM.IER: Interrupt Enable Register
func (o *LPTIM_Type) SetIER_DOWNIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetIER_DOWNIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetIER_UPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetIER_UPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetIER_ARROKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetIER_ARROKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetIER_CMPOKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetIER_CMPOKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetIER_EXTTRIGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetIER_EXTTRIGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetIER_ARRMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetIER_ARRMIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetIER_CMPMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetIER_CMPMIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LPTIM.CFGR: Configuration Register
func (o *LPTIM_Type) SetCFGR_ENC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPTIM_Type) GetCFGR_ENC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *LPTIM_Type) SetCFGR_COUNTMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *LPTIM_Type) GetCFGR_COUNTMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *LPTIM_Type) SetCFGR_PRELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *LPTIM_Type) GetCFGR_PRELOAD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *LPTIM_Type) SetCFGR_WAVPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *LPTIM_Type) GetCFGR_WAVPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *LPTIM_Type) SetCFGR_WAVE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *LPTIM_Type) GetCFGR_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *LPTIM_Type) SetCFGR_TIMOUT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000)|value<<19)
}
func (o *LPTIM_Type) GetCFGR_TIMOUT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000) >> 19
}
func (o *LPTIM_Type) SetCFGR_TRIGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x60000)|value<<17)
}
func (o *LPTIM_Type) GetCFGR_TRIGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x60000) >> 17
}
func (o *LPTIM_Type) SetCFGR_TRIGSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe000)|value<<13)
}
func (o *LPTIM_Type) GetCFGR_TRIGSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe000) >> 13
}
func (o *LPTIM_Type) SetCFGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe00)|value<<9)
}
func (o *LPTIM_Type) GetCFGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe00) >> 9
}
func (o *LPTIM_Type) SetCFGR_TRGFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc0)|value<<6)
}
func (o *LPTIM_Type) GetCFGR_TRGFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc0) >> 6
}
func (o *LPTIM_Type) SetCFGR_CKFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x18)|value<<3)
}
func (o *LPTIM_Type) GetCFGR_CKFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x18) >> 3
}
func (o *LPTIM_Type) SetCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x6)|value<<1)
}
func (o *LPTIM_Type) GetCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x6) >> 1
}
func (o *LPTIM_Type) SetCFGR_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCFGR_CKSEL() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x1
}

// LPTIM.CR: Control Register
func (o *LPTIM_Type) SetCR_RSTARE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetCR_RSTARE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetCR_COUNTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetCR_COUNTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetCR_CNTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetCR_CNTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetCR_SNGSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetCR_SNGSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// LPTIM.CMP: Compare Register
func (o *LPTIM_Type) SetCMP(value uint32) {
	volatile.StoreUint32(&o.CMP.Reg, volatile.LoadUint32(&o.CMP.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCMP() uint32 {
	return volatile.LoadUint32(&o.CMP.Reg) & 0xffff
}

// LPTIM.ARR: Autoreload Register
func (o *LPTIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// LPTIM.CNT: Counter Register
func (o *LPTIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// LPTIM.CFGR2: LPTIM configuration register 2
func (o *LPTIM_Type) SetCFGR2_IN2SEL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x30)|value<<4)
}
func (o *LPTIM_Type) GetCFGR2_IN2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR2.Reg) & 0x30) >> 4
}
func (o *LPTIM_Type) SetCFGR2_IN1SEL(value uint32) {
	volatile.StoreUint32(&o.CFGR2.Reg, volatile.LoadUint32(&o.CFGR2.Reg)&^(0x3)|value)
}
func (o *LPTIM_Type) GetCFGR2_IN1SEL() uint32 {
	return volatile.LoadUint32(&o.CFGR2.Reg) & 0x3
}

// HDMI-CEC
type CEC_Type struct {
	CEC_CR   volatile.Register32 // 0x0
	CEC_CFGR volatile.Register32 // 0x4
	CEC_TXDR volatile.Register32 // 0x8
	CEC_RXDR volatile.Register32 // 0xC
	CEC_ISR  volatile.Register32 // 0x10
	CEC_IER  volatile.Register32 // 0x14
}

// CEC.CEC_CR: CEC control register
func (o *CEC_Type) SetCEC_CR_CECEN(value uint32) {
	volatile.StoreUint32(&o.CEC_CR.Reg, volatile.LoadUint32(&o.CEC_CR.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetCEC_CR_CECEN() uint32 {
	return volatile.LoadUint32(&o.CEC_CR.Reg) & 0x1
}
func (o *CEC_Type) SetCEC_CR_TXSOM(value uint32) {
	volatile.StoreUint32(&o.CEC_CR.Reg, volatile.LoadUint32(&o.CEC_CR.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetCEC_CR_TXSOM() uint32 {
	return (volatile.LoadUint32(&o.CEC_CR.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetCEC_CR_TXEOM(value uint32) {
	volatile.StoreUint32(&o.CEC_CR.Reg, volatile.LoadUint32(&o.CEC_CR.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetCEC_CR_TXEOM() uint32 {
	return (volatile.LoadUint32(&o.CEC_CR.Reg) & 0x4) >> 2
}

// CEC.CEC_CFGR: This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
func (o *CEC_Type) SetCEC_CFGR_SFT(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x7)|value)
}
func (o *CEC_Type) GetCEC_CFGR_SFT() uint32 {
	return volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x7
}
func (o *CEC_Type) SetCEC_CFGR_RXTOL(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetCEC_CFGR_RXTOL() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetCEC_CFGR_BRESTP(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetCEC_CFGR_BRESTP() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetCEC_CFGR_BREGEN(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetCEC_CFGR_BREGEN() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetCEC_CFGR_LBPEGEN(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetCEC_CFGR_LBPEGEN() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetCEC_CFGR_BRDNOGEN(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetCEC_CFGR_BRDNOGEN() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetCEC_CFGR_SFTOPT(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetCEC_CFGR_SFTOPT() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetCEC_CFGR_OAR(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x7fff0000)|value<<16)
}
func (o *CEC_Type) GetCEC_CFGR_OAR() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x7fff0000) >> 16
}
func (o *CEC_Type) SetCEC_CFGR_LSTN(value uint32) {
	volatile.StoreUint32(&o.CEC_CFGR.Reg, volatile.LoadUint32(&o.CEC_CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *CEC_Type) GetCEC_CFGR_LSTN() uint32 {
	return (volatile.LoadUint32(&o.CEC_CFGR.Reg) & 0x80000000) >> 31
}

// CEC.CEC_TXDR: CEC Tx data register
func (o *CEC_Type) SetCEC_TXDR_TXD(value uint32) {
	volatile.StoreUint32(&o.CEC_TXDR.Reg, volatile.LoadUint32(&o.CEC_TXDR.Reg)&^(0xff)|value)
}
func (o *CEC_Type) GetCEC_TXDR_TXD() uint32 {
	return volatile.LoadUint32(&o.CEC_TXDR.Reg) & 0xff
}

// CEC.CEC_RXDR: CEC Rx Data Register
func (o *CEC_Type) SetCEC_RXDR_RXD(value uint32) {
	volatile.StoreUint32(&o.CEC_RXDR.Reg, volatile.LoadUint32(&o.CEC_RXDR.Reg)&^(0xff)|value)
}
func (o *CEC_Type) GetCEC_RXDR_RXD() uint32 {
	return volatile.LoadUint32(&o.CEC_RXDR.Reg) & 0xff
}

// CEC.CEC_ISR: CEC Interrupt and Status Register
func (o *CEC_Type) SetCEC_ISR_RXBR(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetCEC_ISR_RXBR() uint32 {
	return volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x1
}
func (o *CEC_Type) SetCEC_ISR_RXEND(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetCEC_ISR_RXEND() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetCEC_ISR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetCEC_ISR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetCEC_ISR_BRE(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetCEC_ISR_BRE() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetCEC_ISR_SBPE(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetCEC_ISR_SBPE() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetCEC_ISR_LBPE(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetCEC_ISR_LBPE() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetCEC_ISR_RXACKE(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetCEC_ISR_RXACKE() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetCEC_ISR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetCEC_ISR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetCEC_ISR_TXBR(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetCEC_ISR_TXBR() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetCEC_ISR_TXEND(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x200)|value<<9)
}
func (o *CEC_Type) GetCEC_ISR_TXEND() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x200) >> 9
}
func (o *CEC_Type) SetCEC_ISR_TXUDR(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x400)|value<<10)
}
func (o *CEC_Type) GetCEC_ISR_TXUDR() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x400) >> 10
}
func (o *CEC_Type) SetCEC_ISR_TXERR(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x800)|value<<11)
}
func (o *CEC_Type) GetCEC_ISR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x800) >> 11
}
func (o *CEC_Type) SetCEC_ISR_TXACKE(value uint32) {
	volatile.StoreUint32(&o.CEC_ISR.Reg, volatile.LoadUint32(&o.CEC_ISR.Reg)&^(0x1000)|value<<12)
}
func (o *CEC_Type) GetCEC_ISR_TXACKE() uint32 {
	return (volatile.LoadUint32(&o.CEC_ISR.Reg) & 0x1000) >> 12
}

// CEC.CEC_IER: CEC interrupt enable register
func (o *CEC_Type) SetCEC_IER_RXBRIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetCEC_IER_RXBRIE() uint32 {
	return volatile.LoadUint32(&o.CEC_IER.Reg) & 0x1
}
func (o *CEC_Type) SetCEC_IER_RXENDIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetCEC_IER_RXENDIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetCEC_IER_RXOVRIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetCEC_IER_RXOVRIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetCEC_IER_BREIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetCEC_IER_BREIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetCEC_IER_SBPEIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetCEC_IER_SBPEIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetCEC_IER_LBPEIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetCEC_IER_LBPEIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetCEC_IER_RXACKIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetCEC_IER_RXACKIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetCEC_IER_ARBLSTIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetCEC_IER_ARBLSTIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetCEC_IER_TXBRIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetCEC_IER_TXBRIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetCEC_IER_TXENDIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x200)|value<<9)
}
func (o *CEC_Type) GetCEC_IER_TXENDIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x200) >> 9
}
func (o *CEC_Type) SetCEC_IER_TXUDRIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x400)|value<<10)
}
func (o *CEC_Type) GetCEC_IER_TXUDRIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x400) >> 10
}
func (o *CEC_Type) SetCEC_IER_TXERRIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x800)|value<<11)
}
func (o *CEC_Type) GetCEC_IER_TXERRIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x800) >> 11
}
func (o *CEC_Type) SetCEC_IER_TXACKIE(value uint32) {
	volatile.StoreUint32(&o.CEC_IER.Reg, volatile.LoadUint32(&o.CEC_IER.Reg)&^(0x1000)|value<<12)
}
func (o *CEC_Type) GetCEC_IER_TXACKIE() uint32 {
	return (volatile.LoadUint32(&o.CEC_IER.Reg) & 0x1000) >> 12
}

// DAC
type DAC_Type struct {
	CR         volatile.Register32 // 0x0
	SWTRGR     volatile.Register32 // 0x4
	DHR12R1    volatile.Register32 // 0x8
	DHR12L1    volatile.Register32 // 0xC
	DHR8R1     volatile.Register32 // 0x10
	DHR12R2    volatile.Register32 // 0x14
	DHR12L2    volatile.Register32 // 0x18
	DHR8R2     volatile.Register32 // 0x1C
	DHR12RD    volatile.Register32 // 0x20
	DHR12LD    volatile.Register32 // 0x24
	DHR8RD     volatile.Register32 // 0x28
	DOR1       volatile.Register32 // 0x2C
	DOR2       volatile.Register32 // 0x30
	SR         volatile.Register32 // 0x34
	CCR        volatile.Register32 // 0x38
	MCR        volatile.Register32 // 0x3C
	SHSR1      volatile.Register32 // 0x40
	SHSR2      volatile.Register32 // 0x44
	SHHR       volatile.Register32 // 0x48
	SHRR       volatile.Register32 // 0x4C
	_          [928]byte
	IP_HWCFGR0 volatile.Register32 // 0x3F0
	VERR       volatile.Register32 // 0x3F4
	IPIDR      volatile.Register32 // 0x3F8
	SIDR       volatile.Register32 // 0x3FC
}

// DAC.CR: DAC control register
func (o *DAC_Type) SetCR_EN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCR_EN1() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DAC_Type) SetCR_TEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCR_TEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCR_TSEL1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3c)|value<<2)
}
func (o *DAC_Type) GetCR_TSEL1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3c) >> 2
}
func (o *DAC_Type) SetCR_WAVE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DAC_Type) GetCR_WAVE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DAC_Type) SetCR_MAMP1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetCR_MAMP1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetCR_DMAEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DAC_Type) GetCR_DMAEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DAC_Type) SetCR_DMAUDRIE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetCR_DMAUDRIE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetCR_CEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetCR_CEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetCR_EN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetCR_EN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DAC_Type) SetCR_TEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *DAC_Type) GetCR_TEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *DAC_Type) SetCR_TSEL2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3c0000)|value<<18)
}
func (o *DAC_Type) GetCR_TSEL2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3c0000) >> 18
}
func (o *DAC_Type) SetCR_WAVE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00000)|value<<22)
}
func (o *DAC_Type) GetCR_WAVE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00000) >> 22
}
func (o *DAC_Type) SetCR_MAMP2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf000000)|value<<24)
}
func (o *DAC_Type) GetCR_MAMP2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf000000) >> 24
}
func (o *DAC_Type) SetCR_DMAEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *DAC_Type) GetCR_DMAEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *DAC_Type) SetCR_DMAUDRIE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetCR_DMAUDRIE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetCR_CEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *DAC_Type) GetCR_CEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}

// DAC.SWTRGR: DAC software trigger register
func (o *DAC_Type) SetSWTRGR_SWTRIG1(value uint32) {
	volatile.StoreUint32(&o.SWTRGR.Reg, volatile.LoadUint32(&o.SWTRGR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSWTRGR_SWTRIG1() uint32 {
	return volatile.LoadUint32(&o.SWTRGR.Reg) & 0x1
}
func (o *DAC_Type) SetSWTRGR_SWTRIG2(value uint32) {
	volatile.StoreUint32(&o.SWTRGR.Reg, volatile.LoadUint32(&o.SWTRGR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSWTRGR_SWTRIG2() uint32 {
	return (volatile.LoadUint32(&o.SWTRGR.Reg) & 0x2) >> 1
}

// DAC.DHR12R1: DAC channel1 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R1.Reg, volatile.LoadUint32(&o.DHR12R1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R1.Reg) & 0xfff
}

// DAC.DHR12L1: DAC channel1 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L1.Reg, volatile.LoadUint32(&o.DHR12L1.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L1_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L1.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R1: DAC channel1 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R1.Reg, volatile.LoadUint32(&o.DHR8R1.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R1.Reg) & 0xff
}

// DAC.DHR12R2: DAC channel2 12-bit right aligned data holding register
func (o *DAC_Type) SetDHR12R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R2.Reg, volatile.LoadUint32(&o.DHR12R2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R2.Reg) & 0xfff
}

// DAC.DHR12L2: DAC channel2 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L2.Reg, volatile.LoadUint32(&o.DHR12L2.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L2_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L2.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R2: DAC channel2 8-bit right-aligned data holding register
func (o *DAC_Type) SetDHR8R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R2.Reg, volatile.LoadUint32(&o.DHR8R2.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R2.Reg) & 0xff
}

// DAC.DHR12RD: Dual DAC 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff
}
func (o *DAC_Type) SetDHR12RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff0000)|value<<16)
}
func (o *DAC_Type) GetDHR12RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff0000) >> 16
}

// DAC.DHR12LD: DUAL DAC 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12LD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12LD_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff0) >> 4
}
func (o *DAC_Type) SetDHR12LD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff00000)|value<<20)
}
func (o *DAC_Type) GetDHR12LD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff00000) >> 20
}

// DAC.DHR8RD: DUAL DAC 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff
}
func (o *DAC_Type) SetDHR8RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff00)|value<<8)
}
func (o *DAC_Type) GetDHR8RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff00) >> 8
}

// DAC.DOR1: DAC channel1 data output register
func (o *DAC_Type) SetDOR1_DACC1DOR(value uint32) {
	volatile.StoreUint32(&o.DOR1.Reg, volatile.LoadUint32(&o.DOR1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR1_DACC1DOR() uint32 {
	return volatile.LoadUint32(&o.DOR1.Reg) & 0xfff
}

// DAC.DOR2: DAC channel2 data output register
func (o *DAC_Type) SetDOR2_DACC2DOR(value uint32) {
	volatile.StoreUint32(&o.DOR2.Reg, volatile.LoadUint32(&o.DOR2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR2_DACC2DOR() uint32 {
	return volatile.LoadUint32(&o.DOR2.Reg) & 0xfff
}

// DAC.SR: DAC status register
func (o *DAC_Type) SetSR_DMAUDR1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetSR_DMAUDR1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetSR_CAL_FLAG1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *DAC_Type) GetSR_CAL_FLAG1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *DAC_Type) SetSR_BWST1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *DAC_Type) GetSR_BWST1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *DAC_Type) SetSR_DMAUDR2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetSR_DMAUDR2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetSR_CAL_FLAG2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *DAC_Type) GetSR_CAL_FLAG2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *DAC_Type) SetSR_BWST2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *DAC_Type) GetSR_BWST2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// DAC.CCR: DAC calibration control register
func (o *DAC_Type) SetCCR_OTRIM1(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f)|value)
}
func (o *DAC_Type) GetCCR_OTRIM1() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1f
}
func (o *DAC_Type) SetCCR_OTRIM2(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1f0000)|value<<16)
}
func (o *DAC_Type) GetCCR_OTRIM2() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1f0000) >> 16
}

// DAC.MCR: DAC mode control register
func (o *DAC_Type) SetMCR_MODE1(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x7)|value)
}
func (o *DAC_Type) GetMCR_MODE1() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x7
}
func (o *DAC_Type) SetMCR_MODE2(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x70000)|value<<16)
}
func (o *DAC_Type) GetMCR_MODE2() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x70000) >> 16
}

// DAC.SHSR1: DAC Sample and Hold sample time register 1
func (o *DAC_Type) SetSHSR1_TSAMPLE1(value uint32) {
	volatile.StoreUint32(&o.SHSR1.Reg, volatile.LoadUint32(&o.SHSR1.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR1_TSAMPLE1() uint32 {
	return volatile.LoadUint32(&o.SHSR1.Reg) & 0x3ff
}

// DAC.SHSR2: DAC Sample and Hold sample time register 2
func (o *DAC_Type) SetSHSR2_TSAMPLE2(value uint32) {
	volatile.StoreUint32(&o.SHSR2.Reg, volatile.LoadUint32(&o.SHSR2.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHSR2_TSAMPLE2() uint32 {
	return volatile.LoadUint32(&o.SHSR2.Reg) & 0x3ff
}

// DAC.SHHR: DAC Sample and Hold hold time register
func (o *DAC_Type) SetSHHR_THOLD1(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff)|value)
}
func (o *DAC_Type) GetSHHR_THOLD1() uint32 {
	return volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff
}
func (o *DAC_Type) SetSHHR_THOLD2(value uint32) {
	volatile.StoreUint32(&o.SHHR.Reg, volatile.LoadUint32(&o.SHHR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DAC_Type) GetSHHR_THOLD2() uint32 {
	return (volatile.LoadUint32(&o.SHHR.Reg) & 0x3ff0000) >> 16
}

// DAC.SHRR: DAC Sample and Hold refresh time register
func (o *DAC_Type) SetSHRR_TREFRESH1(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetSHRR_TREFRESH1() uint32 {
	return volatile.LoadUint32(&o.SHRR.Reg) & 0xff
}
func (o *DAC_Type) SetSHRR_TREFRESH2(value uint32) {
	volatile.StoreUint32(&o.SHRR.Reg, volatile.LoadUint32(&o.SHRR.Reg)&^(0xff0000)|value<<16)
}
func (o *DAC_Type) GetSHRR_TREFRESH2() uint32 {
	return (volatile.LoadUint32(&o.SHRR.Reg) & 0xff0000) >> 16
}

// DAC.IP_HWCFGR0: DAC IP Hardware Configuration Register
func (o *DAC_Type) SetIP_HWCFGR0_DUAL(value uint32) {
	volatile.StoreUint32(&o.IP_HWCFGR0.Reg, volatile.LoadUint32(&o.IP_HWCFGR0.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetIP_HWCFGR0_DUAL() uint32 {
	return volatile.LoadUint32(&o.IP_HWCFGR0.Reg) & 0xf
}
func (o *DAC_Type) SetIP_HWCFGR0_LFSR(value uint32) {
	volatile.StoreUint32(&o.IP_HWCFGR0.Reg, volatile.LoadUint32(&o.IP_HWCFGR0.Reg)&^(0xf0)|value<<4)
}
func (o *DAC_Type) GetIP_HWCFGR0_LFSR() uint32 {
	return (volatile.LoadUint32(&o.IP_HWCFGR0.Reg) & 0xf0) >> 4
}
func (o *DAC_Type) SetIP_HWCFGR0_TRIANGLE(value uint32) {
	volatile.StoreUint32(&o.IP_HWCFGR0.Reg, volatile.LoadUint32(&o.IP_HWCFGR0.Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetIP_HWCFGR0_TRIANGLE() uint32 {
	return (volatile.LoadUint32(&o.IP_HWCFGR0.Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetIP_HWCFGR0_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.IP_HWCFGR0.Reg, volatile.LoadUint32(&o.IP_HWCFGR0.Reg)&^(0xf000)|value<<12)
}
func (o *DAC_Type) GetIP_HWCFGR0_SAMPLE() uint32 {
	return (volatile.LoadUint32(&o.IP_HWCFGR0.Reg) & 0xf000) >> 12
}
func (o *DAC_Type) SetIP_HWCFGR0_OR_CFG(value uint32) {
	volatile.StoreUint32(&o.IP_HWCFGR0.Reg, volatile.LoadUint32(&o.IP_HWCFGR0.Reg)&^(0xff0000)|value<<16)
}
func (o *DAC_Type) GetIP_HWCFGR0_OR_CFG() uint32 {
	return (volatile.LoadUint32(&o.IP_HWCFGR0.Reg) & 0xff0000) >> 16
}

// DAC.VERR: EXTI IP Version register
func (o *DAC_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *DAC_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *DAC_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *DAC_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// DAC.IPIDR: EXTI Identification register
func (o *DAC_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *DAC_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// DAC.SIDR: EXTI Size ID register
func (o *DAC_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *DAC_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// Inter-integrated circuit
type I2C_Type struct {
	CR1      volatile.Register32 // 0x0
	CR2      volatile.Register32 // 0x4
	OAR1     volatile.Register32 // 0x8
	OAR2     volatile.Register32 // 0xC
	TIMINGR  volatile.Register32 // 0x10
	TIMEOUTR volatile.Register32 // 0x14
	ISR      volatile.Register32 // 0x18
	ICR      volatile.Register32 // 0x1C
	PECR     volatile.Register32 // 0x20
	RXDR     volatile.Register32 // 0x24
	TXDR     volatile.Register32 // 0x28
}

// I2C.CR1: Control register 1
func (o *I2C_Type) SetCR1_PE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCR1_PE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *I2C_Type) SetCR1_TXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCR1_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCR1_RXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCR1_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCR1_ADDRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCR1_ADDRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCR1_NACKIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCR1_NACKIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCR1_STOPIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCR1_STOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCR1_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCR1_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCR1_DNF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00)|value<<8)
}
func (o *I2C_Type) GetCR1_DNF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00) >> 8
}
func (o *I2C_Type) SetCR1_ANFOFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR1_ANFOFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR1_SBC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetCR1_SBC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetCR1_NOSTRETCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetCR1_NOSTRETCH() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetCR1_WUPEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetCR1_WUPEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *I2C_Type) SetCR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetCR1_GCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetCR1_SMBHEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetCR1_SMBHEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetCR1_SMBDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetCR1_SMBDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *I2C_Type) SetCR1_ALERTEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400000)|value<<22)
}
func (o *I2C_Type) GetCR1_ALERTEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400000) >> 22
}
func (o *I2C_Type) SetCR1_PECEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *I2C_Type) GetCR1_PECEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}

// I2C.CR2: Control register 2
func (o *I2C_Type) SetCR2_PECBYTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C_Type) GetCR2_PECBYTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000000) >> 26
}
func (o *I2C_Type) SetCR2_AUTOEND(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetCR2_AUTOEND() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}
func (o *I2C_Type) SetCR2_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetCR2_RELOAD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetCR2_NBYTES(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C_Type) GetCR2_NBYTES() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff0000) >> 16
}
func (o *I2C_Type) SetCR2_NACK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR2_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR2_START(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetCR2_START() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetCR2_HEAD10R(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR2_HEAD10R() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR2_ADD10(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCR2_ADD10() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCR2_RD_WRN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCR2_RD_WRN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCR2_SADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetCR2_SADD() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x3ff
}

// I2C.OAR1: Own address register 1
func (o *I2C_Type) SetOAR1_OA1_0(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetOAR1_OA1_0() uint32 {
	return volatile.LoadUint32(&o.OAR1.Reg) & 0x1
}
func (o *I2C_Type) SetOAR1_OA1_7_1(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOAR1_OA1_7_1() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOAR1_OA1_8_9(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x300)|value<<8)
}
func (o *I2C_Type) GetOAR1_OA1_8_9() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x300) >> 8
}
func (o *I2C_Type) SetOAR1_OA1MODE(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetOAR1_OA1MODE() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetOAR1_OA1EN(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR1_OA1EN() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x8000) >> 15
}

// I2C.OAR2: Own address register 2
func (o *I2C_Type) SetOAR2_OA2(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOAR2_OA2() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOAR2_OA2MSK(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x700)|value<<8)
}
func (o *I2C_Type) GetOAR2_OA2MSK() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x700) >> 8
}
func (o *I2C_Type) SetOAR2_OA2EN(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR2_OA2EN() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x8000) >> 15
}

// I2C.TIMINGR: Timing register
func (o *I2C_Type) SetTIMINGR_SCLL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTIMINGR_SCLL() uint32 {
	return volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff
}
func (o *I2C_Type) SetTIMINGR_SCLH(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff00)|value<<8)
}
func (o *I2C_Type) GetTIMINGR_SCLH() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff00) >> 8
}
func (o *I2C_Type) SetTIMINGR_SDADEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000)|value<<16)
}
func (o *I2C_Type) GetTIMINGR_SDADEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000) >> 16
}
func (o *I2C_Type) SetTIMINGR_SCLDEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf00000)|value<<20)
}
func (o *I2C_Type) GetTIMINGR_SCLDEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf00000) >> 20
}
func (o *I2C_Type) SetTIMINGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000000)|value<<28)
}
func (o *I2C_Type) GetTIMINGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000000) >> 28
}

// I2C.TIMEOUTR: Status register 1
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTA(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff)|value)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTA() uint32 {
	return volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff
}
func (o *I2C_Type) SetTIMEOUTR_TIDLE(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetTIMEOUTR_TIDLE() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetTIMEOUTR_TIMOUTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetTIMEOUTR_TIMOUTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTB(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff0000)|value<<16)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTB() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff0000) >> 16
}
func (o *I2C_Type) SetTIMEOUTR_TEXTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetTIMEOUTR_TEXTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x80000000) >> 31
}

// I2C.ISR: Interrupt and Status register
func (o *I2C_Type) SetISR_ADDCODE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xfe0000)|value<<17)
}
func (o *I2C_Type) GetISR_ADDCODE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xfe0000) >> 17
}
func (o *I2C_Type) SetISR_DIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetISR_ALERT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetISR_ALERT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetISR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetISR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetISR_PECERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetISR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetISR_ARLO(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetISR_ARLO() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetISR_BERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetISR_BERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetISR_TCR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetISR_TCR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetISR_STOPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetISR_STOPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetISR_NACKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetISR_NACKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetISR_ADDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetISR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetISR_TXIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetISR_TXIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetISR_TXE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// I2C.ICR: Interrupt clear register
func (o *I2C_Type) SetICR_ALERTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetICR_ALERTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetICR_TIMOUTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetICR_TIMOUTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetICR_PECCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetICR_PECCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetICR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetICR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetICR_ARLOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetICR_ARLOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetICR_BERRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetICR_BERRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetICR_STOPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetICR_STOPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetICR_NACKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetICR_NACKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetICR_ADDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetICR_ADDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}

// I2C.PECR: PEC register
func (o *I2C_Type) SetPECR_PEC(value uint32) {
	volatile.StoreUint32(&o.PECR.Reg, volatile.LoadUint32(&o.PECR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetPECR_PEC() uint32 {
	return volatile.LoadUint32(&o.PECR.Reg) & 0xff
}

// I2C.RXDR: Receive data register
func (o *I2C_Type) SetRXDR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetRXDR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// I2C.TXDR: Transmit data register
func (o *I2C_Type) SetTXDR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTXDR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// Real-time clock
type RTC_Type struct {
	TR       volatile.Register32 // 0x0
	DR       volatile.Register32 // 0x4
	SSR      volatile.Register32 // 0x8
	ICSR     volatile.Register32 // 0xC
	PRER     volatile.Register32 // 0x10
	WUTR     volatile.Register32 // 0x14
	CR       volatile.Register32 // 0x18
	_        [8]byte
	WPR      volatile.Register32 // 0x24
	CALR     volatile.Register32 // 0x28
	SHIFTR   volatile.Register32 // 0x2C
	TSTR     volatile.Register32 // 0x30
	TSDR     volatile.Register32 // 0x34
	TSSSR    volatile.Register32 // 0x38
	_        [4]byte
	ALRMAR   volatile.Register32 // 0x40
	ALRMASSR volatile.Register32 // 0x44
	ALRMBR   volatile.Register32 // 0x48
	ALRMBSSR volatile.Register32 // 0x4C
	SR       volatile.Register32 // 0x50
	MISR     volatile.Register32 // 0x54
	_        [4]byte
	SCR      volatile.Register32 // 0x5C
	_        [912]byte
	HWCFGR   volatile.Register32 // 0x3F0
	VERR     volatile.Register32 // 0x3F4
	IPIDR    volatile.Register32 // 0x3F8
	SIDR     volatile.Register32 // 0x3FC
}

// RTC.TR: time register
func (o *RTC_Type) SetTR_PM(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTR_HT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTR_HU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTR_ST(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTR_SU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTR_SU() uint32 {
	return volatile.LoadUint32(&o.TR.Reg) & 0xf
}

// RTC.DR: date register
func (o *RTC_Type) SetDR_YT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00000)|value<<20)
}
func (o *RTC_Type) GetDR_YT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00000) >> 20
}
func (o *RTC_Type) SetDR_YU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetDR_YU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetDR_WDU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetDR_MT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetDR_MT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetDR_MU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetDR_MU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetDR_DT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetDR_DT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetDR_DU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetDR_DU() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xf
}

// RTC.SSR: sub second register
func (o *RTC_Type) SetSSR_SS(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetSSR_SS() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0xffff
}

// RTC.ICSR: initialization and status register
func (o *RTC_Type) SetICSR_ALRAWF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetICSR_ALRAWF() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1
}
func (o *RTC_Type) SetICSR_ALRBWF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetICSR_ALRBWF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetICSR_WUTWF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetICSR_WUTWF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetICSR_SHPF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetICSR_SHPF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetICSR_INITS(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetICSR_INITS() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetICSR_RSF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetICSR_RSF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetICSR_INITF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetICSR_INITF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetICSR_INIT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetICSR_INIT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetICSR_RECALPF(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetICSR_RECALPF() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000) >> 16
}

// RTC.PRER: prescaler register
func (o *RTC_Type) SetPRER_PREDIV_A(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7f0000)|value<<16)
}
func (o *RTC_Type) GetPRER_PREDIV_A() uint32 {
	return (volatile.LoadUint32(&o.PRER.Reg) & 0x7f0000) >> 16
}
func (o *RTC_Type) SetPRER_PREDIV_S(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetPRER_PREDIV_S() uint32 {
	return volatile.LoadUint32(&o.PRER.Reg) & 0x7fff
}

// RTC.WUTR: wakeup timer register
func (o *RTC_Type) SetWUTR_WUT(value uint32) {
	volatile.StoreUint32(&o.WUTR.Reg, volatile.LoadUint32(&o.WUTR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetWUTR_WUT() uint32 {
	return volatile.LoadUint32(&o.WUTR.Reg) & 0xffff
}

// RTC.CR: control register
func (o *RTC_Type) SetCR_WUCKSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetCR_WUCKSEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7
}
func (o *RTC_Type) SetCR_TSEDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_TSEDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_REFCKON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_REFCKON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_BYPSHAD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCR_BYPSHAD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCR_FMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCR_FMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCR_ALRAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_ALRAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_ALRBE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_ALRBE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_WUTE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_WUTE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_TSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_TSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_ALRAIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_ALRAIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_ALRBIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_ALRBIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCR_WUTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCR_WUTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCR_TSIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCR_TSIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCR_ADD1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetCR_ADD1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetCR_SUB1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCR_SUB1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetCR_BKP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetCR_BKP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetCR_COSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetCR_COSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetCR_POL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetCR_POL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetCR_OSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_Type) GetCR_OSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *RTC_Type) SetCR_COE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCR_COE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCR_ITSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetCR_ITSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RTC_Type) SetCR_TAMPTS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_Type) GetCR_TAMPTS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *RTC_Type) SetCR_TAMPOE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_Type) GetCR_TAMPOE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *RTC_Type) SetCR_TAMPALRM_PU(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_Type) GetCR_TAMPALRM_PU() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *RTC_Type) SetCR_TAMPALRM_TYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetCR_TAMPALRM_TYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetCR_OUT2EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetCR_OUT2EN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// RTC.WPR: write protection register
func (o *RTC_Type) SetWPR_KEY(value uint32) {
	volatile.StoreUint32(&o.WPR.Reg, volatile.LoadUint32(&o.WPR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetWPR_KEY() uint32 {
	return volatile.LoadUint32(&o.WPR.Reg) & 0xff
}

// RTC.CALR: calibration register
func (o *RTC_Type) SetCALR_CALP(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCALR_CALP() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCALR_CALW8(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCALR_CALW8() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCALR_CALW16(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCALR_CALW16() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCALR_CALM(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetCALR_CALM() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x1ff
}

// RTC.SHIFTR: shift control register
func (o *RTC_Type) SetSHIFTR_ADD1S(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSHIFTR_ADD1S() uint32 {
	return (volatile.LoadUint32(&o.SHIFTR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetSHIFTR_SUBFS(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetSHIFTR_SUBFS() uint32 {
	return volatile.LoadUint32(&o.SHIFTR.Reg) & 0x7fff
}

// RTC.TSTR: time stamp time register
func (o *RTC_Type) SetTSTR_SU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSTR_SU() uint32 {
	return volatile.LoadUint32(&o.TSTR.Reg) & 0xf
}
func (o *RTC_Type) SetTSTR_ST(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTSTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTSTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTSTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTSTR_HU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTSTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTSTR_HT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTSTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTSTR_PM(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTSTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x400000) >> 22
}

// RTC.TSDR: time stamp date register
func (o *RTC_Type) SetTSDR_WDU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetTSDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetTSDR_MT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetTSDR_MT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetTSDR_MU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSDR_MU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSDR_DT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetTSDR_DT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetTSDR_DU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSDR_DU() uint32 {
	return volatile.LoadUint32(&o.TSDR.Reg) & 0xf
}

// RTC.TSSSR: timestamp sub second register
func (o *RTC_Type) SetTSSSR_SS(value uint32) {
	volatile.StoreUint32(&o.TSSSR.Reg, volatile.LoadUint32(&o.TSSSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetTSSSR_SS() uint32 {
	return volatile.LoadUint32(&o.TSSSR.Reg) & 0xffff
}

// RTC.ALRMAR: alarm A register
func (o *RTC_Type) SetALRMAR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMAR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMAR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMAR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMAR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMAR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMAR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMAR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMAR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMAR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMAR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMAR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMAR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMAR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMAR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMAR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMAR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMAR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMAR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMAR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMAR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMAR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMAR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMAR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMAR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMAR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMAR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMAR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf
}

// RTC.ALRMASSR: alarm A sub second register
func (o *RTC_Type) SetALRMASSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMASSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMASSR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMASSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMASSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x7fff
}

// RTC.ALRMBR: alarm B register
func (o *RTC_Type) SetALRMBR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMBR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMBR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMBR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMBR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMBR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMBR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMBR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMBR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMBR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMBR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMBR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMBR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMBR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMBR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMBR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMBR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMBR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMBR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMBR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMBR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMBR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMBR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMBR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMBR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMBR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf
}

// RTC.ALRMBSSR: alarm B sub second register
func (o *RTC_Type) SetALRMBSSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBSSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBSSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMBSSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x7fff
}

// RTC.SR: status register
func (o *RTC_Type) SetSR_ALRAF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSR_ALRAF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *RTC_Type) SetSR_ALRBF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSR_ALRBF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSR_WUTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSR_WUTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSR_TSF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSR_TSF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSR_TSOVF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSR_TSOVF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetSR_ITSF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetSR_ITSF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}

// RTC.MISR: masked interrupt status register
func (o *RTC_Type) SetMISR_ALRAMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetMISR_ALRAMF() uint32 {
	return volatile.LoadUint32(&o.MISR.Reg) & 0x1
}
func (o *RTC_Type) SetMISR_ALRBMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetMISR_ALRBMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetMISR_WUTMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetMISR_WUTMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetMISR_TSMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetMISR_TSMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetMISR_TSOVMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetMISR_TSOVMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetMISR_ITSMF(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetMISR_ITSMF() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x20) >> 5
}

// RTC.SCR: status clear register
func (o *RTC_Type) SetSCR_CALRAF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetSCR_CALRAF() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}
func (o *RTC_Type) SetSCR_CALRBF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetSCR_CALRBF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetSCR_CWUTF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetSCR_CWUTF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetSCR_CTSF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetSCR_CTSF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetSCR_CTSOVF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetSCR_CTSOVF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetSCR_CITSF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetSCR_CITSF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20) >> 5
}

// RTC.HWCFGR: hardware configuration register
func (o *RTC_Type) SetHWCFGR_ALARMB(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetHWCFGR_ALARMB() uint32 {
	return volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf
}
func (o *RTC_Type) SetHWCFGR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetHWCFGR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetHWCFGR_SMOOTH_CALIB(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetHWCFGR_SMOOTH_CALIB() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetHWCFGR_TIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf000)|value<<12)
}
func (o *RTC_Type) GetHWCFGR_TIMESTAMP() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf000) >> 12
}
func (o *RTC_Type) SetHWCFGR_OPTIONREG_OUT(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *RTC_Type) GetHWCFGR_OPTIONREG_OUT() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xff0000) >> 16
}
func (o *RTC_Type) SetHWCFGR_TRUST_ZONE(value uint32) {
	volatile.StoreUint32(&o.HWCFGR.Reg, volatile.LoadUint32(&o.HWCFGR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetHWCFGR_TRUST_ZONE() uint32 {
	return (volatile.LoadUint32(&o.HWCFGR.Reg) & 0xf000000) >> 24
}

// RTC.VERR: EXTI IP Version register
func (o *RTC_Type) SetVERR_MINREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetVERR_MINREV() uint32 {
	return volatile.LoadUint32(&o.VERR.Reg) & 0xf
}
func (o *RTC_Type) SetVERR_MAJREV(value uint32) {
	volatile.StoreUint32(&o.VERR.Reg, volatile.LoadUint32(&o.VERR.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetVERR_MAJREV() uint32 {
	return (volatile.LoadUint32(&o.VERR.Reg) & 0xf0) >> 4
}

// RTC.IPIDR: EXTI Identification register
func (o *RTC_Type) SetIPIDR(value uint32) {
	volatile.StoreUint32(&o.IPIDR.Reg, value)
}
func (o *RTC_Type) GetIPIDR() uint32 {
	return volatile.LoadUint32(&o.IPIDR.Reg)
}

// RTC.SIDR: EXTI Size ID register
func (o *RTC_Type) SetSIDR(value uint32) {
	volatile.StoreUint32(&o.SIDR.Reg, value)
}
func (o *RTC_Type) GetSIDR() uint32 {
	return volatile.LoadUint32(&o.SIDR.Reg)
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER volatile.Register32 // 0x0
	_    [124]byte
	ICER volatile.Register32 // 0x80
	_    [124]byte
	ISPR volatile.Register32 // 0x100
	_    [124]byte
	ICPR volatile.Register32 // 0x180
	_    [380]byte
	IPR0 volatile.Register32 // 0x300
	IPR1 volatile.Register32 // 0x304
	IPR2 volatile.Register32 // 0x308
	IPR3 volatile.Register32 // 0x30C
	IPR4 volatile.Register32 // 0x310
	IPR5 volatile.Register32 // 0x314
	IPR6 volatile.Register32 // 0x318
	IPR7 volatile.Register32 // 0x31C
}

// NVIC.ISER: Interrupt Set Enable Register
func (o *NVIC_Type) SetISER(value uint32) {
	volatile.StoreUint32(&o.ISER.Reg, value)
}
func (o *NVIC_Type) GetISER() uint32 {
	return volatile.LoadUint32(&o.ISER.Reg)
}

// NVIC.ICER: Interrupt Clear Enable Register
func (o *NVIC_Type) SetICER(value uint32) {
	volatile.StoreUint32(&o.ICER.Reg, value)
}
func (o *NVIC_Type) GetICER() uint32 {
	return volatile.LoadUint32(&o.ICER.Reg)
}

// NVIC.ISPR: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR(value uint32) {
	volatile.StoreUint32(&o.ISPR.Reg, value)
}
func (o *NVIC_Type) GetISPR() uint32 {
	return volatile.LoadUint32(&o.ISPR.Reg)
}

// NVIC.ICPR: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR(value uint32) {
	volatile.StoreUint32(&o.ICPR.Reg, value)
}
func (o *NVIC_Type) GetICPR() uint32 {
	return volatile.LoadUint32(&o.ICPR.Reg)
}

// NVIC.IPR0: Interrupt Priority Register 0
func (o *NVIC_Type) SetIPR0_PRI_0(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR0_PRI_0() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR0_PRI_1(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR0_PRI_1() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR0_PRI_2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR0_PRI_2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR0_PRI_3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR0_PRI_3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff000000) >> 24
}

// NVIC.IPR1: Interrupt Priority Register 1
func (o *NVIC_Type) SetIPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR1_PRI_7(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR1_PRI_7() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff000000) >> 24
}

// NVIC.IPR2: Interrupt Priority Register 2
func (o *NVIC_Type) SetIPR2_PRI_8(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR2_PRI_8() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR2_PRI_9(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR2_PRI_9() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR2_PRI_10(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR2_PRI_10() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff000000) >> 24
}

// NVIC.IPR3: Interrupt Priority Register 3
func (o *NVIC_Type) SetIPR3_PRI_12(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR3_PRI_12() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR3_PRI_13(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR3_PRI_13() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff000000) >> 24
}

// NVIC.IPR4: Interrupt Priority Register 4
func (o *NVIC_Type) SetIPR4_PRI_16(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR4_PRI_16() uint32 {
	return volatile.LoadUint32(&o.IPR4.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR4_PRI_17(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR4_PRI_17() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR4_PRI_18(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR4_PRI_18() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR4_PRI_19(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR4_PRI_19() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff000000) >> 24
}

// NVIC.IPR5: Interrupt Priority Register 5
func (o *NVIC_Type) SetIPR5_PRI_20(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR5_PRI_20() uint32 {
	return volatile.LoadUint32(&o.IPR5.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR5_PRI_21(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR5_PRI_21() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR5_PRI_22(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR5_PRI_22() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR5_PRI_23(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR5_PRI_23() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff000000) >> 24
}

// NVIC.IPR6: Interrupt Priority Register 6
func (o *NVIC_Type) SetIPR6_PRI_24(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR6_PRI_24() uint32 {
	return volatile.LoadUint32(&o.IPR6.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR6_PRI_25(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR6_PRI_25() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR6_PRI_26(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR6_PRI_26() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR6_PRI_27(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR6_PRI_27() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff000000) >> 24
}

// NVIC.IPR7: Interrupt Priority Register 7
func (o *NVIC_Type) SetIPR7_PRI_28(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR7_PRI_28() uint32 {
	return volatile.LoadUint32(&o.IPR7.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR7_PRI_29(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR7_PRI_29() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR7_PRI_30(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR7_PRI_30() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR7_PRI_31(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR7_PRI_31() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff000000) >> 24
}

// Memory protection unit
type MPU_Type struct {
	TYPER volatile.Register32 // 0x0
	CTRL  volatile.Register32 // 0x4
	RNR   volatile.Register32 // 0x8
	RBAR  volatile.Register32 // 0xC
	RASR  volatile.Register32 // 0x10
}

// MPU.TYPER: MPU type register
func (o *MPU_Type) SetTYPER_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPER_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPER.Reg) & 0x1
}
func (o *MPU_Type) SetTYPER_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPER_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPER_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPER_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU control register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU region number register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU region base address register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU region attribute and size register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x3e)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x3e) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// SysTick timer
type STK_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// STK.CSR: SysTick control and status register
func (o *STK_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *STK_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *STK_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *STK_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *STK_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *STK_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *STK_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *STK_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// STK.RVR: SysTick reload value register
func (o *STK_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// STK.CVR: SysTick current value register
func (o *STK_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// STK.CALIB: SysTick calibration value register
func (o *STK_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *STK_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *STK_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *STK_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *STK_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// System control block
type SCB_Type struct {
	CPUID volatile.Register32 // 0x0
	ICSR  volatile.Register32 // 0x4
	VTOR  volatile.Register32 // 0x8
	AIRCR volatile.Register32 // 0xC
	SCR   volatile.Register32 // 0x10
	CCR   volatile.Register32 // 0x14
	_     [4]byte
	SHPR2 volatile.Register32 // 0x1C
	SHPR3 volatile.Register32 // 0x20
}

// SCB.CPUID: CPUID base register
func (o *SCB_Type) SetCPUID_Revision(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCPUID_Revision() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SCB_Type) SetCPUID_PartNo(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SCB_Type) GetCPUID_PartNo() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SCB_Type) SetCPUID_Architecture(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCPUID_Architecture() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCPUID_Variant(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCPUID_Variant() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCPUID_Implementer(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetCPUID_Implementer() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SCB.ICSR: Interrupt control and state register
func (o *SCB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SCB_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x7f000)|value<<12)
}
func (o *SCB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x7f000) >> 12
}
func (o *SCB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SCB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SCB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SCB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SCB.VTOR: Vector table offset register
func (o *SCB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff80)|value<<7)
}
func (o *SCB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff80) >> 7
}

// SCB.AIRCR: Application interrupt and reset control register
func (o *SCB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetAIRCR_ENDIANESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetAIRCR_ENDIANESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetAIRCR_VECTKEYSTAT(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCB_Type) GetAIRCR_VECTKEYSTAT() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SCB.SCR: System control register
func (o *SCB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetSCR_SEVEONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetSCR_SEVEONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SCB.CCR: Configuration and control register
func (o *SCB_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SCB_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCCR_UNALIGN__TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCCR_UNALIGN__TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}

// SCB.SHPR2: System handler priority registers
func (o *SCB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SCB.SHPR3: System handler priority registers
func (o *SCB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SCB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// Constants for IWDG: Independent watchdog
const (
	// KR: Key register
	// Position of KEY field.
	IWDG_KR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	IWDG_KR_KEY_Msk = 0xffff

	// PR: Prescaler register
	// Position of PR field.
	IWDG_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	IWDG_PR_PR_Msk = 0x7

	// RLR: Reload register
	// Position of RL field.
	IWDG_RLR_RL_Pos = 0x0
	// Bit mask of RL field.
	IWDG_RLR_RL_Msk = 0xfff

	// SR: Status register
	// Position of WVU field.
	IWDG_SR_WVU_Pos = 0x2
	// Bit mask of WVU field.
	IWDG_SR_WVU_Msk = 0x4
	// Bit WVU.
	IWDG_SR_WVU = 0x4
	// Position of RVU field.
	IWDG_SR_RVU_Pos = 0x1
	// Bit mask of RVU field.
	IWDG_SR_RVU_Msk = 0x2
	// Bit RVU.
	IWDG_SR_RVU = 0x2
	// Position of PVU field.
	IWDG_SR_PVU_Pos = 0x0
	// Bit mask of PVU field.
	IWDG_SR_PVU_Msk = 0x1
	// Bit PVU.
	IWDG_SR_PVU = 0x1

	// WINR: Window register
	// Position of WIN field.
	IWDG_WINR_WIN_Pos = 0x0
	// Bit mask of WIN field.
	IWDG_WINR_WIN_Msk = 0xfff

	// HWCFGR: hardware configuration register
	// Position of WINDOW field.
	IWDG_HWCFGR_WINDOW_Pos = 0x0
	// Bit mask of WINDOW field.
	IWDG_HWCFGR_WINDOW_Msk = 0xf
	// Position of PR_DEFAULT field.
	IWDG_HWCFGR_PR_DEFAULT_Pos = 0x4
	// Bit mask of PR_DEFAULT field.
	IWDG_HWCFGR_PR_DEFAULT_Msk = 0xf0

	// VERR: EXTI IP Version register
	// Position of MINREV field.
	IWDG_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	IWDG_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	IWDG_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	IWDG_VERR_MAJREV_Msk = 0xf0

	// IPIDR: EXTI Identification register
	// Position of IPID field.
	IWDG_IPIDR_IPID_Pos = 0x0
	// Bit mask of IPID field.
	IWDG_IPIDR_IPID_Msk = 0xffffffff

	// SIDR: EXTI Size ID register
	// Position of SID field.
	IWDG_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	IWDG_SIDR_SID_Msk = 0xffffffff
)

// Constants for WWDG: System window watchdog
const (
	// CR: Control register
	// Position of WDGA field.
	WWDG_CR_WDGA_Pos = 0x7
	// Bit mask of WDGA field.
	WWDG_CR_WDGA_Msk = 0x80
	// Bit WDGA.
	WWDG_CR_WDGA = 0x80
	// Position of T field.
	WWDG_CR_T_Pos = 0x0
	// Bit mask of T field.
	WWDG_CR_T_Msk = 0x7f

	// CFR: Configuration register
	// Position of WDGTB field.
	WWDG_CFR_WDGTB_Pos = 0xb
	// Bit mask of WDGTB field.
	WWDG_CFR_WDGTB_Msk = 0x3800
	// Position of EWI field.
	WWDG_CFR_EWI_Pos = 0x9
	// Bit mask of EWI field.
	WWDG_CFR_EWI_Msk = 0x200
	// Bit EWI.
	WWDG_CFR_EWI = 0x200
	// Position of W field.
	WWDG_CFR_W_Pos = 0x0
	// Bit mask of W field.
	WWDG_CFR_W_Msk = 0x7f

	// SR: Status register
	// Position of EWIF field.
	WWDG_SR_EWIF_Pos = 0x0
	// Bit mask of EWIF field.
	WWDG_SR_EWIF_Msk = 0x1
	// Bit EWIF.
	WWDG_SR_EWIF = 0x1
)

// Constants for FLASH: Flash
const (
	// ACR: Access control register
	// Position of LATENCY field.
	Flash_ACR_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	Flash_ACR_LATENCY_Msk = 0x7
	// Position of PRFTEN field.
	Flash_ACR_PRFTEN_Pos = 0x8
	// Bit mask of PRFTEN field.
	Flash_ACR_PRFTEN_Msk = 0x100
	// Bit PRFTEN.
	Flash_ACR_PRFTEN = 0x100
	// Position of ICEN field.
	Flash_ACR_ICEN_Pos = 0x9
	// Bit mask of ICEN field.
	Flash_ACR_ICEN_Msk = 0x200
	// Bit ICEN.
	Flash_ACR_ICEN = 0x200
	// Position of ICRST field.
	Flash_ACR_ICRST_Pos = 0xb
	// Bit mask of ICRST field.
	Flash_ACR_ICRST_Msk = 0x800
	// Bit ICRST.
	Flash_ACR_ICRST = 0x800
	// Position of EMPTY field.
	Flash_ACR_EMPTY_Pos = 0x10
	// Bit mask of EMPTY field.
	Flash_ACR_EMPTY_Msk = 0x10000
	// Bit EMPTY.
	Flash_ACR_EMPTY = 0x10000
	// Position of DBG_SWEN field.
	Flash_ACR_DBG_SWEN_Pos = 0x12
	// Bit mask of DBG_SWEN field.
	Flash_ACR_DBG_SWEN_Msk = 0x40000
	// Bit DBG_SWEN.
	Flash_ACR_DBG_SWEN = 0x40000

	// KEYR: Flash key register
	// Position of KEYR field.
	Flash_KEYR_KEYR_Pos = 0x0
	// Bit mask of KEYR field.
	Flash_KEYR_KEYR_Msk = 0xffffffff

	// OPTKEYR: Option byte key register
	// Position of OPTKEYR field.
	Flash_OPTKEYR_OPTKEYR_Pos = 0x0
	// Bit mask of OPTKEYR field.
	Flash_OPTKEYR_OPTKEYR_Msk = 0xffffffff

	// SR: Status register
	// Position of EOP field.
	Flash_SR_EOP_Pos = 0x0
	// Bit mask of EOP field.
	Flash_SR_EOP_Msk = 0x1
	// Bit EOP.
	Flash_SR_EOP = 0x1
	// Position of OPERR field.
	Flash_SR_OPERR_Pos = 0x1
	// Bit mask of OPERR field.
	Flash_SR_OPERR_Msk = 0x2
	// Bit OPERR.
	Flash_SR_OPERR = 0x2
	// Position of PROGERR field.
	Flash_SR_PROGERR_Pos = 0x3
	// Bit mask of PROGERR field.
	Flash_SR_PROGERR_Msk = 0x8
	// Bit PROGERR.
	Flash_SR_PROGERR = 0x8
	// Position of WRPERR field.
	Flash_SR_WRPERR_Pos = 0x4
	// Bit mask of WRPERR field.
	Flash_SR_WRPERR_Msk = 0x10
	// Bit WRPERR.
	Flash_SR_WRPERR = 0x10
	// Position of PGAERR field.
	Flash_SR_PGAERR_Pos = 0x5
	// Bit mask of PGAERR field.
	Flash_SR_PGAERR_Msk = 0x20
	// Bit PGAERR.
	Flash_SR_PGAERR = 0x20
	// Position of SIZERR field.
	Flash_SR_SIZERR_Pos = 0x6
	// Bit mask of SIZERR field.
	Flash_SR_SIZERR_Msk = 0x40
	// Bit SIZERR.
	Flash_SR_SIZERR = 0x40
	// Position of PGSERR field.
	Flash_SR_PGSERR_Pos = 0x7
	// Bit mask of PGSERR field.
	Flash_SR_PGSERR_Msk = 0x80
	// Bit PGSERR.
	Flash_SR_PGSERR = 0x80
	// Position of MISERR field.
	Flash_SR_MISERR_Pos = 0x8
	// Bit mask of MISERR field.
	Flash_SR_MISERR_Msk = 0x100
	// Bit MISERR.
	Flash_SR_MISERR = 0x100
	// Position of FASTERR field.
	Flash_SR_FASTERR_Pos = 0x9
	// Bit mask of FASTERR field.
	Flash_SR_FASTERR_Msk = 0x200
	// Bit FASTERR.
	Flash_SR_FASTERR = 0x200
	// Position of RDERR field.
	Flash_SR_RDERR_Pos = 0xe
	// Bit mask of RDERR field.
	Flash_SR_RDERR_Msk = 0x4000
	// Bit RDERR.
	Flash_SR_RDERR = 0x4000
	// Position of OPTVERR field.
	Flash_SR_OPTVERR_Pos = 0xf
	// Bit mask of OPTVERR field.
	Flash_SR_OPTVERR_Msk = 0x8000
	// Bit OPTVERR.
	Flash_SR_OPTVERR = 0x8000
	// Position of BSY field.
	Flash_SR_BSY_Pos = 0x10
	// Bit mask of BSY field.
	Flash_SR_BSY_Msk = 0x10000
	// Bit BSY.
	Flash_SR_BSY = 0x10000
	// Position of CFGBSY field.
	Flash_SR_CFGBSY_Pos = 0x12
	// Bit mask of CFGBSY field.
	Flash_SR_CFGBSY_Msk = 0x40000
	// Bit CFGBSY.
	Flash_SR_CFGBSY = 0x40000

	// CR: Flash control register
	// Position of PG field.
	Flash_CR_PG_Pos = 0x0
	// Bit mask of PG field.
	Flash_CR_PG_Msk = 0x1
	// Bit PG.
	Flash_CR_PG = 0x1
	// Position of PER field.
	Flash_CR_PER_Pos = 0x1
	// Bit mask of PER field.
	Flash_CR_PER_Msk = 0x2
	// Bit PER.
	Flash_CR_PER = 0x2
	// Position of MER field.
	Flash_CR_MER_Pos = 0x2
	// Bit mask of MER field.
	Flash_CR_MER_Msk = 0x4
	// Bit MER.
	Flash_CR_MER = 0x4
	// Position of PNB field.
	Flash_CR_PNB_Pos = 0x3
	// Bit mask of PNB field.
	Flash_CR_PNB_Msk = 0x1f8
	// Position of STRT field.
	Flash_CR_STRT_Pos = 0x10
	// Bit mask of STRT field.
	Flash_CR_STRT_Msk = 0x10000
	// Bit STRT.
	Flash_CR_STRT = 0x10000
	// Position of OPTSTRT field.
	Flash_CR_OPTSTRT_Pos = 0x11
	// Bit mask of OPTSTRT field.
	Flash_CR_OPTSTRT_Msk = 0x20000
	// Bit OPTSTRT.
	Flash_CR_OPTSTRT = 0x20000
	// Position of FSTPG field.
	Flash_CR_FSTPG_Pos = 0x12
	// Bit mask of FSTPG field.
	Flash_CR_FSTPG_Msk = 0x40000
	// Bit FSTPG.
	Flash_CR_FSTPG = 0x40000
	// Position of EOPIE field.
	Flash_CR_EOPIE_Pos = 0x18
	// Bit mask of EOPIE field.
	Flash_CR_EOPIE_Msk = 0x1000000
	// Bit EOPIE.
	Flash_CR_EOPIE = 0x1000000
	// Position of ERRIE field.
	Flash_CR_ERRIE_Pos = 0x19
	// Bit mask of ERRIE field.
	Flash_CR_ERRIE_Msk = 0x2000000
	// Bit ERRIE.
	Flash_CR_ERRIE = 0x2000000
	// Position of RDERRIE field.
	Flash_CR_RDERRIE_Pos = 0x1a
	// Bit mask of RDERRIE field.
	Flash_CR_RDERRIE_Msk = 0x4000000
	// Bit RDERRIE.
	Flash_CR_RDERRIE = 0x4000000
	// Position of OBL_LAUNCH field.
	Flash_CR_OBL_LAUNCH_Pos = 0x1b
	// Bit mask of OBL_LAUNCH field.
	Flash_CR_OBL_LAUNCH_Msk = 0x8000000
	// Bit OBL_LAUNCH.
	Flash_CR_OBL_LAUNCH = 0x8000000
	// Position of SEC_PROT field.
	Flash_CR_SEC_PROT_Pos = 0x1c
	// Bit mask of SEC_PROT field.
	Flash_CR_SEC_PROT_Msk = 0x10000000
	// Bit SEC_PROT.
	Flash_CR_SEC_PROT = 0x10000000
	// Position of OPTLOCK field.
	Flash_CR_OPTLOCK_Pos = 0x1e
	// Bit mask of OPTLOCK field.
	Flash_CR_OPTLOCK_Msk = 0x40000000
	// Bit OPTLOCK.
	Flash_CR_OPTLOCK = 0x40000000
	// Position of LOCK field.
	Flash_CR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	Flash_CR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	Flash_CR_LOCK = 0x80000000

	// ECCR: Flash ECC register
	// Position of ADDR_ECC field.
	Flash_ECCR_ADDR_ECC_Pos = 0x0
	// Bit mask of ADDR_ECC field.
	Flash_ECCR_ADDR_ECC_Msk = 0x3fff
	// Position of SYSF_ECC field.
	Flash_ECCR_SYSF_ECC_Pos = 0x14
	// Bit mask of SYSF_ECC field.
	Flash_ECCR_SYSF_ECC_Msk = 0x100000
	// Bit SYSF_ECC.
	Flash_ECCR_SYSF_ECC = 0x100000
	// Position of ECCIE field.
	Flash_ECCR_ECCIE_Pos = 0x18
	// Bit mask of ECCIE field.
	Flash_ECCR_ECCIE_Msk = 0x1000000
	// Bit ECCIE.
	Flash_ECCR_ECCIE = 0x1000000
	// Position of ECCC field.
	Flash_ECCR_ECCC_Pos = 0x1e
	// Bit mask of ECCC field.
	Flash_ECCR_ECCC_Msk = 0x40000000
	// Bit ECCC.
	Flash_ECCR_ECCC = 0x40000000
	// Position of ECCD field.
	Flash_ECCR_ECCD_Pos = 0x1f
	// Bit mask of ECCD field.
	Flash_ECCR_ECCD_Msk = 0x80000000
	// Bit ECCD.
	Flash_ECCR_ECCD = 0x80000000

	// OPTR: Flash option register
	// Position of RDP field.
	Flash_OPTR_RDP_Pos = 0x0
	// Bit mask of RDP field.
	Flash_OPTR_RDP_Msk = 0xff
	// Position of BOREN field.
	Flash_OPTR_BOREN_Pos = 0x8
	// Bit mask of BOREN field.
	Flash_OPTR_BOREN_Msk = 0x100
	// Bit BOREN.
	Flash_OPTR_BOREN = 0x100
	// Position of BORF_LEV field.
	Flash_OPTR_BORF_LEV_Pos = 0x9
	// Bit mask of BORF_LEV field.
	Flash_OPTR_BORF_LEV_Msk = 0x600
	// Position of BORR_LEV field.
	Flash_OPTR_BORR_LEV_Pos = 0xb
	// Bit mask of BORR_LEV field.
	Flash_OPTR_BORR_LEV_Msk = 0x1800
	// Position of NRST_STOP field.
	Flash_OPTR_NRST_STOP_Pos = 0xd
	// Bit mask of NRST_STOP field.
	Flash_OPTR_NRST_STOP_Msk = 0x2000
	// Bit NRST_STOP.
	Flash_OPTR_NRST_STOP = 0x2000
	// Position of NRST_STDBY field.
	Flash_OPTR_NRST_STDBY_Pos = 0xe
	// Bit mask of NRST_STDBY field.
	Flash_OPTR_NRST_STDBY_Msk = 0x4000
	// Bit NRST_STDBY.
	Flash_OPTR_NRST_STDBY = 0x4000
	// Position of NRSTS_HDW field.
	Flash_OPTR_NRSTS_HDW_Pos = 0xf
	// Bit mask of NRSTS_HDW field.
	Flash_OPTR_NRSTS_HDW_Msk = 0x8000
	// Bit NRSTS_HDW.
	Flash_OPTR_NRSTS_HDW = 0x8000
	// Position of IDWG_SW field.
	Flash_OPTR_IDWG_SW_Pos = 0x10
	// Bit mask of IDWG_SW field.
	Flash_OPTR_IDWG_SW_Msk = 0x10000
	// Bit IDWG_SW.
	Flash_OPTR_IDWG_SW = 0x10000
	// Position of IWDG_STOP field.
	Flash_OPTR_IWDG_STOP_Pos = 0x11
	// Bit mask of IWDG_STOP field.
	Flash_OPTR_IWDG_STOP_Msk = 0x20000
	// Bit IWDG_STOP.
	Flash_OPTR_IWDG_STOP = 0x20000
	// Position of IWDG_STDBY field.
	Flash_OPTR_IWDG_STDBY_Pos = 0x12
	// Bit mask of IWDG_STDBY field.
	Flash_OPTR_IWDG_STDBY_Msk = 0x40000
	// Bit IWDG_STDBY.
	Flash_OPTR_IWDG_STDBY = 0x40000
	// Position of WWDG_SW field.
	Flash_OPTR_WWDG_SW_Pos = 0x13
	// Bit mask of WWDG_SW field.
	Flash_OPTR_WWDG_SW_Msk = 0x80000
	// Bit WWDG_SW.
	Flash_OPTR_WWDG_SW = 0x80000
	// Position of RAM_PARITY_CHECK field.
	Flash_OPTR_RAM_PARITY_CHECK_Pos = 0x16
	// Bit mask of RAM_PARITY_CHECK field.
	Flash_OPTR_RAM_PARITY_CHECK_Msk = 0x400000
	// Bit RAM_PARITY_CHECK.
	Flash_OPTR_RAM_PARITY_CHECK = 0x400000
	// Position of NBOOT_SEL field.
	Flash_OPTR_NBOOT_SEL_Pos = 0x18
	// Bit mask of NBOOT_SEL field.
	Flash_OPTR_NBOOT_SEL_Msk = 0x1000000
	// Bit NBOOT_SEL.
	Flash_OPTR_NBOOT_SEL = 0x1000000
	// Position of NBOOT1 field.
	Flash_OPTR_NBOOT1_Pos = 0x19
	// Bit mask of NBOOT1 field.
	Flash_OPTR_NBOOT1_Msk = 0x2000000
	// Bit NBOOT1.
	Flash_OPTR_NBOOT1 = 0x2000000
	// Position of NBOOT0 field.
	Flash_OPTR_NBOOT0_Pos = 0x1a
	// Bit mask of NBOOT0 field.
	Flash_OPTR_NBOOT0_Msk = 0x4000000
	// Bit NBOOT0.
	Flash_OPTR_NBOOT0 = 0x4000000
	// Position of NRST_MODE field.
	Flash_OPTR_NRST_MODE_Pos = 0x1b
	// Bit mask of NRST_MODE field.
	Flash_OPTR_NRST_MODE_Msk = 0x18000000
	// Position of IRHEN field.
	Flash_OPTR_IRHEN_Pos = 0x1d
	// Bit mask of IRHEN field.
	Flash_OPTR_IRHEN_Msk = 0x20000000
	// Bit IRHEN.
	Flash_OPTR_IRHEN = 0x20000000

	// PCROP1ASR: Flash PCROP zone A Start address register
	// Position of PCROP1A_STRT field.
	Flash_PCROP1ASR_PCROP1A_STRT_Pos = 0x0
	// Bit mask of PCROP1A_STRT field.
	Flash_PCROP1ASR_PCROP1A_STRT_Msk = 0xff

	// PCROP1AER: Flash PCROP zone A End address register
	// Position of PCROP1A_END field.
	Flash_PCROP1AER_PCROP1A_END_Pos = 0x0
	// Bit mask of PCROP1A_END field.
	Flash_PCROP1AER_PCROP1A_END_Msk = 0xff
	// Position of PCROP_RDP field.
	Flash_PCROP1AER_PCROP_RDP_Pos = 0x1f
	// Bit mask of PCROP_RDP field.
	Flash_PCROP1AER_PCROP_RDP_Msk = 0x80000000
	// Bit PCROP_RDP.
	Flash_PCROP1AER_PCROP_RDP = 0x80000000

	// WRP1AR: Flash WRP area A address register
	// Position of WRP1A_STRT field.
	Flash_WRP1AR_WRP1A_STRT_Pos = 0x0
	// Bit mask of WRP1A_STRT field.
	Flash_WRP1AR_WRP1A_STRT_Msk = 0x3f
	// Position of WRP1A_END field.
	Flash_WRP1AR_WRP1A_END_Pos = 0x10
	// Bit mask of WRP1A_END field.
	Flash_WRP1AR_WRP1A_END_Msk = 0x3f0000

	// WRP1BR: Flash WRP area B address register
	// Position of WRP1B_STRT field.
	Flash_WRP1BR_WRP1B_STRT_Pos = 0x0
	// Bit mask of WRP1B_STRT field.
	Flash_WRP1BR_WRP1B_STRT_Msk = 0x3f
	// Position of WRP1B_END field.
	Flash_WRP1BR_WRP1B_END_Pos = 0x10
	// Bit mask of WRP1B_END field.
	Flash_WRP1BR_WRP1B_END_Msk = 0x3f0000

	// PCROP1BSR: Flash PCROP zone B Start address register
	// Position of PCROP1B_STRT field.
	Flash_PCROP1BSR_PCROP1B_STRT_Pos = 0x0
	// Bit mask of PCROP1B_STRT field.
	Flash_PCROP1BSR_PCROP1B_STRT_Msk = 0xff

	// PCROP1BER: Flash PCROP zone B End address register
	// Position of PCROP1B_END field.
	Flash_PCROP1BER_PCROP1B_END_Pos = 0x0
	// Bit mask of PCROP1B_END field.
	Flash_PCROP1BER_PCROP1B_END_Msk = 0xff

	// SECR: Flash Security register
	// Position of SEC_SIZE field.
	Flash_SECR_SEC_SIZE_Pos = 0x0
	// Bit mask of SEC_SIZE field.
	Flash_SECR_SEC_SIZE_Msk = 0x7f
	// Position of BOOT_LOCK field.
	Flash_SECR_BOOT_LOCK_Pos = 0x10
	// Bit mask of BOOT_LOCK field.
	Flash_SECR_BOOT_LOCK_Msk = 0x10000
	// Bit BOOT_LOCK.
	Flash_SECR_BOOT_LOCK = 0x10000
)

// Constants for DBG: Debug support
const (
	// IDCODE: MCU Device ID Code Register
	// Position of DEV_ID field.
	DBG_IDCODE_DEV_ID_Pos = 0x0
	// Bit mask of DEV_ID field.
	DBG_IDCODE_DEV_ID_Msk = 0xffff
	// Position of REV_ID field.
	DBG_IDCODE_REV_ID_Pos = 0x10
	// Bit mask of REV_ID field.
	DBG_IDCODE_REV_ID_Msk = 0xffff0000

	// CR: Debug MCU Configuration Register
	// Position of DBG_STOP field.
	DBG_CR_DBG_STOP_Pos = 0x1
	// Bit mask of DBG_STOP field.
	DBG_CR_DBG_STOP_Msk = 0x2
	// Bit DBG_STOP.
	DBG_CR_DBG_STOP = 0x2
	// Position of DBG_STANDBY field.
	DBG_CR_DBG_STANDBY_Pos = 0x2
	// Bit mask of DBG_STANDBY field.
	DBG_CR_DBG_STANDBY_Msk = 0x4
	// Bit DBG_STANDBY.
	DBG_CR_DBG_STANDBY = 0x4

	// APB_FZ1: DBG APB freeze register 1
	// Position of DBG_TIMER2_STOP field.
	DBG_APB_FZ1_DBG_TIMER2_STOP_Pos = 0x0
	// Bit mask of DBG_TIMER2_STOP field.
	DBG_APB_FZ1_DBG_TIMER2_STOP_Msk = 0x1
	// Bit DBG_TIMER2_STOP.
	DBG_APB_FZ1_DBG_TIMER2_STOP = 0x1
	// Position of DBG_TIM3_STOP field.
	DBG_APB_FZ1_DBG_TIM3_STOP_Pos = 0x1
	// Bit mask of DBG_TIM3_STOP field.
	DBG_APB_FZ1_DBG_TIM3_STOP_Msk = 0x2
	// Bit DBG_TIM3_STOP.
	DBG_APB_FZ1_DBG_TIM3_STOP = 0x2
	// Position of DBG_TIMER6_STOP field.
	DBG_APB_FZ1_DBG_TIMER6_STOP_Pos = 0x4
	// Bit mask of DBG_TIMER6_STOP field.
	DBG_APB_FZ1_DBG_TIMER6_STOP_Msk = 0x10
	// Bit DBG_TIMER6_STOP.
	DBG_APB_FZ1_DBG_TIMER6_STOP = 0x10
	// Position of DBG_TIM7_STOP field.
	DBG_APB_FZ1_DBG_TIM7_STOP_Pos = 0x5
	// Bit mask of DBG_TIM7_STOP field.
	DBG_APB_FZ1_DBG_TIM7_STOP_Msk = 0x20
	// Bit DBG_TIM7_STOP.
	DBG_APB_FZ1_DBG_TIM7_STOP = 0x20
	// Position of DBG_RTC_STOP field.
	DBG_APB_FZ1_DBG_RTC_STOP_Pos = 0xa
	// Bit mask of DBG_RTC_STOP field.
	DBG_APB_FZ1_DBG_RTC_STOP_Msk = 0x400
	// Bit DBG_RTC_STOP.
	DBG_APB_FZ1_DBG_RTC_STOP = 0x400
	// Position of DBG_WWDG_STOP field.
	DBG_APB_FZ1_DBG_WWDG_STOP_Pos = 0xb
	// Bit mask of DBG_WWDG_STOP field.
	DBG_APB_FZ1_DBG_WWDG_STOP_Msk = 0x800
	// Bit DBG_WWDG_STOP.
	DBG_APB_FZ1_DBG_WWDG_STOP = 0x800
	// Position of DBG_IWDG_STOP field.
	DBG_APB_FZ1_DBG_IWDG_STOP_Pos = 0xc
	// Bit mask of DBG_IWDG_STOP field.
	DBG_APB_FZ1_DBG_IWDG_STOP_Msk = 0x1000
	// Bit DBG_IWDG_STOP.
	DBG_APB_FZ1_DBG_IWDG_STOP = 0x1000
	// Position of DBG_I2C1_STOP field.
	DBG_APB_FZ1_DBG_I2C1_STOP_Pos = 0x15
	// Bit mask of DBG_I2C1_STOP field.
	DBG_APB_FZ1_DBG_I2C1_STOP_Msk = 0x200000
	// Bit DBG_I2C1_STOP.
	DBG_APB_FZ1_DBG_I2C1_STOP = 0x200000
	// Position of DBG_LPTIM2_STOP field.
	DBG_APB_FZ1_DBG_LPTIM2_STOP_Pos = 0x1e
	// Bit mask of DBG_LPTIM2_STOP field.
	DBG_APB_FZ1_DBG_LPTIM2_STOP_Msk = 0x40000000
	// Bit DBG_LPTIM2_STOP.
	DBG_APB_FZ1_DBG_LPTIM2_STOP = 0x40000000
	// Position of DBG_LPTIM1_STOP field.
	DBG_APB_FZ1_DBG_LPTIM1_STOP_Pos = 0x1f
	// Bit mask of DBG_LPTIM1_STOP field.
	DBG_APB_FZ1_DBG_LPTIM1_STOP_Msk = 0x80000000
	// Bit DBG_LPTIM1_STOP.
	DBG_APB_FZ1_DBG_LPTIM1_STOP = 0x80000000

	// APB_FZ2: DBG APB freeze register 2
	// Position of DBG_TIM1_STOP field.
	DBG_APB_FZ2_DBG_TIM1_STOP_Pos = 0xb
	// Bit mask of DBG_TIM1_STOP field.
	DBG_APB_FZ2_DBG_TIM1_STOP_Msk = 0x800
	// Bit DBG_TIM1_STOP.
	DBG_APB_FZ2_DBG_TIM1_STOP = 0x800
	// Position of DBG_TIM14_STOP field.
	DBG_APB_FZ2_DBG_TIM14_STOP_Pos = 0xf
	// Bit mask of DBG_TIM14_STOP field.
	DBG_APB_FZ2_DBG_TIM14_STOP_Msk = 0x8000
	// Bit DBG_TIM14_STOP.
	DBG_APB_FZ2_DBG_TIM14_STOP = 0x8000
	// Position of DBG_TIM15_STOP field.
	DBG_APB_FZ2_DBG_TIM15_STOP_Pos = 0x10
	// Bit mask of DBG_TIM15_STOP field.
	DBG_APB_FZ2_DBG_TIM15_STOP_Msk = 0x10000
	// Bit DBG_TIM15_STOP.
	DBG_APB_FZ2_DBG_TIM15_STOP = 0x10000
	// Position of DBG_TIM16_STOP field.
	DBG_APB_FZ2_DBG_TIM16_STOP_Pos = 0x11
	// Bit mask of DBG_TIM16_STOP field.
	DBG_APB_FZ2_DBG_TIM16_STOP_Msk = 0x20000
	// Bit DBG_TIM16_STOP.
	DBG_APB_FZ2_DBG_TIM16_STOP = 0x20000
	// Position of DBG_TIM17_STOP field.
	DBG_APB_FZ2_DBG_TIM17_STOP_Pos = 0x12
	// Bit mask of DBG_TIM17_STOP field.
	DBG_APB_FZ2_DBG_TIM17_STOP_Msk = 0x40000
	// Bit DBG_TIM17_STOP.
	DBG_APB_FZ2_DBG_TIM17_STOP = 0x40000
)

// Constants for RCC: Reset and clock control
const (
	// CR: Clock control register
	// Position of HSION field.
	RCC_CR_HSION_Pos = 0x8
	// Bit mask of HSION field.
	RCC_CR_HSION_Msk = 0x100
	// Bit HSION.
	RCC_CR_HSION = 0x100
	// Position of HSIKERON field.
	RCC_CR_HSIKERON_Pos = 0x9
	// Bit mask of HSIKERON field.
	RCC_CR_HSIKERON_Msk = 0x200
	// Bit HSIKERON.
	RCC_CR_HSIKERON = 0x200
	// Position of HSIRDY field.
	RCC_CR_HSIRDY_Pos = 0xa
	// Bit mask of HSIRDY field.
	RCC_CR_HSIRDY_Msk = 0x400
	// Bit HSIRDY.
	RCC_CR_HSIRDY = 0x400
	// Position of HSIDIV field.
	RCC_CR_HSIDIV_Pos = 0xb
	// Bit mask of HSIDIV field.
	RCC_CR_HSIDIV_Msk = 0x3800
	// Position of HSEON field.
	RCC_CR_HSEON_Pos = 0x10
	// Bit mask of HSEON field.
	RCC_CR_HSEON_Msk = 0x10000
	// Bit HSEON.
	RCC_CR_HSEON = 0x10000
	// Position of HSERDY field.
	RCC_CR_HSERDY_Pos = 0x11
	// Bit mask of HSERDY field.
	RCC_CR_HSERDY_Msk = 0x20000
	// Bit HSERDY.
	RCC_CR_HSERDY = 0x20000
	// Position of HSEBYP field.
	RCC_CR_HSEBYP_Pos = 0x12
	// Bit mask of HSEBYP field.
	RCC_CR_HSEBYP_Msk = 0x40000
	// Bit HSEBYP.
	RCC_CR_HSEBYP = 0x40000
	// Position of CSSON field.
	RCC_CR_CSSON_Pos = 0x13
	// Bit mask of CSSON field.
	RCC_CR_CSSON_Msk = 0x80000
	// Bit CSSON.
	RCC_CR_CSSON = 0x80000
	// Position of PLLON field.
	RCC_CR_PLLON_Pos = 0x18
	// Bit mask of PLLON field.
	RCC_CR_PLLON_Msk = 0x1000000
	// Bit PLLON.
	RCC_CR_PLLON = 0x1000000
	// Position of PLLRDY field.
	RCC_CR_PLLRDY_Pos = 0x19
	// Bit mask of PLLRDY field.
	RCC_CR_PLLRDY_Msk = 0x2000000
	// Bit PLLRDY.
	RCC_CR_PLLRDY = 0x2000000

	// ICSCR: Internal clock sources calibration register
	// Position of HSICAL field.
	RCC_ICSCR_HSICAL_Pos = 0x0
	// Bit mask of HSICAL field.
	RCC_ICSCR_HSICAL_Msk = 0xff
	// Position of HSITRIM field.
	RCC_ICSCR_HSITRIM_Pos = 0x8
	// Bit mask of HSITRIM field.
	RCC_ICSCR_HSITRIM_Msk = 0x7f00

	// CFGR: Clock configuration register
	// Position of MCOPRE field.
	RCC_CFGR_MCOPRE_Pos = 0x1c
	// Bit mask of MCOPRE field.
	RCC_CFGR_MCOPRE_Msk = 0x70000000
	// Position of MCOSEL field.
	RCC_CFGR_MCOSEL_Pos = 0x18
	// Bit mask of MCOSEL field.
	RCC_CFGR_MCOSEL_Msk = 0x7000000
	// Position of PPRE field.
	RCC_CFGR_PPRE_Pos = 0xc
	// Bit mask of PPRE field.
	RCC_CFGR_PPRE_Msk = 0x7000
	// Position of HPRE field.
	RCC_CFGR_HPRE_Pos = 0x8
	// Bit mask of HPRE field.
	RCC_CFGR_HPRE_Msk = 0xf00
	// Position of SWS field.
	RCC_CFGR_SWS_Pos = 0x3
	// Bit mask of SWS field.
	RCC_CFGR_SWS_Msk = 0x38
	// Position of SW field.
	RCC_CFGR_SW_Pos = 0x0
	// Bit mask of SW field.
	RCC_CFGR_SW_Msk = 0x7

	// PLLSYSCFGR: PLL configuration register
	// Position of PLLSRC field.
	RCC_PLLSYSCFGR_PLLSRC_Pos = 0x0
	// Bit mask of PLLSRC field.
	RCC_PLLSYSCFGR_PLLSRC_Msk = 0x3
	// Position of PLLM field.
	RCC_PLLSYSCFGR_PLLM_Pos = 0x4
	// Bit mask of PLLM field.
	RCC_PLLSYSCFGR_PLLM_Msk = 0x70
	// Position of PLLN field.
	RCC_PLLSYSCFGR_PLLN_Pos = 0x8
	// Bit mask of PLLN field.
	RCC_PLLSYSCFGR_PLLN_Msk = 0x7f00
	// Position of PLLPEN field.
	RCC_PLLSYSCFGR_PLLPEN_Pos = 0x10
	// Bit mask of PLLPEN field.
	RCC_PLLSYSCFGR_PLLPEN_Msk = 0x10000
	// Bit PLLPEN.
	RCC_PLLSYSCFGR_PLLPEN = 0x10000
	// Position of PLLP field.
	RCC_PLLSYSCFGR_PLLP_Pos = 0x11
	// Bit mask of PLLP field.
	RCC_PLLSYSCFGR_PLLP_Msk = 0x3e0000
	// Position of PLLQEN field.
	RCC_PLLSYSCFGR_PLLQEN_Pos = 0x18
	// Bit mask of PLLQEN field.
	RCC_PLLSYSCFGR_PLLQEN_Msk = 0x1000000
	// Bit PLLQEN.
	RCC_PLLSYSCFGR_PLLQEN = 0x1000000
	// Position of PLLQ field.
	RCC_PLLSYSCFGR_PLLQ_Pos = 0x19
	// Bit mask of PLLQ field.
	RCC_PLLSYSCFGR_PLLQ_Msk = 0xe000000
	// Position of PLLREN field.
	RCC_PLLSYSCFGR_PLLREN_Pos = 0x1c
	// Bit mask of PLLREN field.
	RCC_PLLSYSCFGR_PLLREN_Msk = 0x10000000
	// Bit PLLREN.
	RCC_PLLSYSCFGR_PLLREN = 0x10000000
	// Position of PLLR field.
	RCC_PLLSYSCFGR_PLLR_Pos = 0x1d
	// Bit mask of PLLR field.
	RCC_PLLSYSCFGR_PLLR_Msk = 0xe0000000

	// CIER: Clock interrupt enable register
	// Position of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Pos = 0x0
	// Bit mask of LSIRDYIE field.
	RCC_CIER_LSIRDYIE_Msk = 0x1
	// Bit LSIRDYIE.
	RCC_CIER_LSIRDYIE = 0x1
	// Position of LSERDYIE field.
	RCC_CIER_LSERDYIE_Pos = 0x1
	// Bit mask of LSERDYIE field.
	RCC_CIER_LSERDYIE_Msk = 0x2
	// Bit LSERDYIE.
	RCC_CIER_LSERDYIE = 0x2
	// Position of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Pos = 0x3
	// Bit mask of HSIRDYIE field.
	RCC_CIER_HSIRDYIE_Msk = 0x8
	// Bit HSIRDYIE.
	RCC_CIER_HSIRDYIE = 0x8
	// Position of HSERDYIE field.
	RCC_CIER_HSERDYIE_Pos = 0x4
	// Bit mask of HSERDYIE field.
	RCC_CIER_HSERDYIE_Msk = 0x10
	// Bit HSERDYIE.
	RCC_CIER_HSERDYIE = 0x10
	// Position of PLLSYSRDYIE field.
	RCC_CIER_PLLSYSRDYIE_Pos = 0x5
	// Bit mask of PLLSYSRDYIE field.
	RCC_CIER_PLLSYSRDYIE_Msk = 0x20
	// Bit PLLSYSRDYIE.
	RCC_CIER_PLLSYSRDYIE = 0x20

	// CIFR: Clock interrupt flag register
	// Position of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Pos = 0x0
	// Bit mask of LSIRDYF field.
	RCC_CIFR_LSIRDYF_Msk = 0x1
	// Bit LSIRDYF.
	RCC_CIFR_LSIRDYF = 0x1
	// Position of LSERDYF field.
	RCC_CIFR_LSERDYF_Pos = 0x1
	// Bit mask of LSERDYF field.
	RCC_CIFR_LSERDYF_Msk = 0x2
	// Bit LSERDYF.
	RCC_CIFR_LSERDYF = 0x2
	// Position of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Pos = 0x3
	// Bit mask of HSIRDYF field.
	RCC_CIFR_HSIRDYF_Msk = 0x8
	// Bit HSIRDYF.
	RCC_CIFR_HSIRDYF = 0x8
	// Position of HSERDYF field.
	RCC_CIFR_HSERDYF_Pos = 0x4
	// Bit mask of HSERDYF field.
	RCC_CIFR_HSERDYF_Msk = 0x10
	// Bit HSERDYF.
	RCC_CIFR_HSERDYF = 0x10
	// Position of PLLSYSRDYF field.
	RCC_CIFR_PLLSYSRDYF_Pos = 0x5
	// Bit mask of PLLSYSRDYF field.
	RCC_CIFR_PLLSYSRDYF_Msk = 0x20
	// Bit PLLSYSRDYF.
	RCC_CIFR_PLLSYSRDYF = 0x20
	// Position of CSSF field.
	RCC_CIFR_CSSF_Pos = 0x8
	// Bit mask of CSSF field.
	RCC_CIFR_CSSF_Msk = 0x100
	// Bit CSSF.
	RCC_CIFR_CSSF = 0x100
	// Position of LSECSSF field.
	RCC_CIFR_LSECSSF_Pos = 0x9
	// Bit mask of LSECSSF field.
	RCC_CIFR_LSECSSF_Msk = 0x200
	// Bit LSECSSF.
	RCC_CIFR_LSECSSF = 0x200

	// CICR: Clock interrupt clear register
	// Position of LSIRDYC field.
	RCC_CICR_LSIRDYC_Pos = 0x0
	// Bit mask of LSIRDYC field.
	RCC_CICR_LSIRDYC_Msk = 0x1
	// Bit LSIRDYC.
	RCC_CICR_LSIRDYC = 0x1
	// Position of LSERDYC field.
	RCC_CICR_LSERDYC_Pos = 0x1
	// Bit mask of LSERDYC field.
	RCC_CICR_LSERDYC_Msk = 0x2
	// Bit LSERDYC.
	RCC_CICR_LSERDYC = 0x2
	// Position of HSIRDYC field.
	RCC_CICR_HSIRDYC_Pos = 0x3
	// Bit mask of HSIRDYC field.
	RCC_CICR_HSIRDYC_Msk = 0x8
	// Bit HSIRDYC.
	RCC_CICR_HSIRDYC = 0x8
	// Position of HSERDYC field.
	RCC_CICR_HSERDYC_Pos = 0x4
	// Bit mask of HSERDYC field.
	RCC_CICR_HSERDYC_Msk = 0x10
	// Bit HSERDYC.
	RCC_CICR_HSERDYC = 0x10
	// Position of PLLSYSRDYC field.
	RCC_CICR_PLLSYSRDYC_Pos = 0x5
	// Bit mask of PLLSYSRDYC field.
	RCC_CICR_PLLSYSRDYC_Msk = 0x20
	// Bit PLLSYSRDYC.
	RCC_CICR_PLLSYSRDYC = 0x20
	// Position of CSSC field.
	RCC_CICR_CSSC_Pos = 0x8
	// Bit mask of CSSC field.
	RCC_CICR_CSSC_Msk = 0x100
	// Bit CSSC.
	RCC_CICR_CSSC = 0x100
	// Position of LSECSSC field.
	RCC_CICR_LSECSSC_Pos = 0x9
	// Bit mask of LSECSSC field.
	RCC_CICR_LSECSSC_Msk = 0x200
	// Bit LSECSSC.
	RCC_CICR_LSECSSC = 0x200

	// IOPRSTR: GPIO reset register
	// Position of IOPARST field.
	RCC_IOPRSTR_IOPARST_Pos = 0x0
	// Bit mask of IOPARST field.
	RCC_IOPRSTR_IOPARST_Msk = 0x1
	// Bit IOPARST.
	RCC_IOPRSTR_IOPARST = 0x1
	// Position of IOPBRST field.
	RCC_IOPRSTR_IOPBRST_Pos = 0x1
	// Bit mask of IOPBRST field.
	RCC_IOPRSTR_IOPBRST_Msk = 0x2
	// Bit IOPBRST.
	RCC_IOPRSTR_IOPBRST = 0x2
	// Position of IOPCRST field.
	RCC_IOPRSTR_IOPCRST_Pos = 0x2
	// Bit mask of IOPCRST field.
	RCC_IOPRSTR_IOPCRST_Msk = 0x4
	// Bit IOPCRST.
	RCC_IOPRSTR_IOPCRST = 0x4
	// Position of IOPDRST field.
	RCC_IOPRSTR_IOPDRST_Pos = 0x3
	// Bit mask of IOPDRST field.
	RCC_IOPRSTR_IOPDRST_Msk = 0x8
	// Bit IOPDRST.
	RCC_IOPRSTR_IOPDRST = 0x8
	// Position of IOPFRST field.
	RCC_IOPRSTR_IOPFRST_Pos = 0x5
	// Bit mask of IOPFRST field.
	RCC_IOPRSTR_IOPFRST_Msk = 0x20
	// Bit IOPFRST.
	RCC_IOPRSTR_IOPFRST = 0x20

	// AHBRSTR: AHB peripheral reset register
	// Position of DMARST field.
	RCC_AHBRSTR_DMARST_Pos = 0x0
	// Bit mask of DMARST field.
	RCC_AHBRSTR_DMARST_Msk = 0x1
	// Bit DMARST.
	RCC_AHBRSTR_DMARST = 0x1
	// Position of FLASHRST field.
	RCC_AHBRSTR_FLASHRST_Pos = 0x8
	// Bit mask of FLASHRST field.
	RCC_AHBRSTR_FLASHRST_Msk = 0x100
	// Bit FLASHRST.
	RCC_AHBRSTR_FLASHRST = 0x100
	// Position of CRCRST field.
	RCC_AHBRSTR_CRCRST_Pos = 0xc
	// Bit mask of CRCRST field.
	RCC_AHBRSTR_CRCRST_Msk = 0x1000
	// Bit CRCRST.
	RCC_AHBRSTR_CRCRST = 0x1000

	// APBRSTR1: APB peripheral reset register 1
	// Position of TIM2RST field.
	RCC_APBRSTR1_TIM2RST_Pos = 0x0
	// Bit mask of TIM2RST field.
	RCC_APBRSTR1_TIM2RST_Msk = 0x1
	// Bit TIM2RST.
	RCC_APBRSTR1_TIM2RST = 0x1
	// Position of TIM3RST field.
	RCC_APBRSTR1_TIM3RST_Pos = 0x1
	// Bit mask of TIM3RST field.
	RCC_APBRSTR1_TIM3RST_Msk = 0x2
	// Bit TIM3RST.
	RCC_APBRSTR1_TIM3RST = 0x2
	// Position of TIM6RST field.
	RCC_APBRSTR1_TIM6RST_Pos = 0x4
	// Bit mask of TIM6RST field.
	RCC_APBRSTR1_TIM6RST_Msk = 0x10
	// Bit TIM6RST.
	RCC_APBRSTR1_TIM6RST = 0x10
	// Position of TIM7RST field.
	RCC_APBRSTR1_TIM7RST_Pos = 0x5
	// Bit mask of TIM7RST field.
	RCC_APBRSTR1_TIM7RST_Msk = 0x20
	// Bit TIM7RST.
	RCC_APBRSTR1_TIM7RST = 0x20
	// Position of SPI2RST field.
	RCC_APBRSTR1_SPI2RST_Pos = 0xe
	// Bit mask of SPI2RST field.
	RCC_APBRSTR1_SPI2RST_Msk = 0x4000
	// Bit SPI2RST.
	RCC_APBRSTR1_SPI2RST = 0x4000
	// Position of USART2RST field.
	RCC_APBRSTR1_USART2RST_Pos = 0x11
	// Bit mask of USART2RST field.
	RCC_APBRSTR1_USART2RST_Msk = 0x20000
	// Bit USART2RST.
	RCC_APBRSTR1_USART2RST = 0x20000
	// Position of USART3RST field.
	RCC_APBRSTR1_USART3RST_Pos = 0x12
	// Bit mask of USART3RST field.
	RCC_APBRSTR1_USART3RST_Msk = 0x40000
	// Bit USART3RST.
	RCC_APBRSTR1_USART3RST = 0x40000
	// Position of USART4RST field.
	RCC_APBRSTR1_USART4RST_Pos = 0x13
	// Bit mask of USART4RST field.
	RCC_APBRSTR1_USART4RST_Msk = 0x80000
	// Bit USART4RST.
	RCC_APBRSTR1_USART4RST = 0x80000
	// Position of LPUART1RST field.
	RCC_APBRSTR1_LPUART1RST_Pos = 0x14
	// Bit mask of LPUART1RST field.
	RCC_APBRSTR1_LPUART1RST_Msk = 0x100000
	// Bit LPUART1RST.
	RCC_APBRSTR1_LPUART1RST = 0x100000
	// Position of I2C1RST field.
	RCC_APBRSTR1_I2C1RST_Pos = 0x15
	// Bit mask of I2C1RST field.
	RCC_APBRSTR1_I2C1RST_Msk = 0x200000
	// Bit I2C1RST.
	RCC_APBRSTR1_I2C1RST = 0x200000
	// Position of I2C2RST field.
	RCC_APBRSTR1_I2C2RST_Pos = 0x16
	// Bit mask of I2C2RST field.
	RCC_APBRSTR1_I2C2RST_Msk = 0x400000
	// Bit I2C2RST.
	RCC_APBRSTR1_I2C2RST = 0x400000
	// Position of CECRST field.
	RCC_APBRSTR1_CECRST_Pos = 0x18
	// Bit mask of CECRST field.
	RCC_APBRSTR1_CECRST_Msk = 0x1000000
	// Bit CECRST.
	RCC_APBRSTR1_CECRST = 0x1000000
	// Position of UCPD1RST field.
	RCC_APBRSTR1_UCPD1RST_Pos = 0x19
	// Bit mask of UCPD1RST field.
	RCC_APBRSTR1_UCPD1RST_Msk = 0x2000000
	// Bit UCPD1RST.
	RCC_APBRSTR1_UCPD1RST = 0x2000000
	// Position of UCPD2RST field.
	RCC_APBRSTR1_UCPD2RST_Pos = 0x1a
	// Bit mask of UCPD2RST field.
	RCC_APBRSTR1_UCPD2RST_Msk = 0x4000000
	// Bit UCPD2RST.
	RCC_APBRSTR1_UCPD2RST = 0x4000000
	// Position of DBGRST field.
	RCC_APBRSTR1_DBGRST_Pos = 0x1b
	// Bit mask of DBGRST field.
	RCC_APBRSTR1_DBGRST_Msk = 0x8000000
	// Bit DBGRST.
	RCC_APBRSTR1_DBGRST = 0x8000000
	// Position of PWRRST field.
	RCC_APBRSTR1_PWRRST_Pos = 0x1c
	// Bit mask of PWRRST field.
	RCC_APBRSTR1_PWRRST_Msk = 0x10000000
	// Bit PWRRST.
	RCC_APBRSTR1_PWRRST = 0x10000000
	// Position of DAC1RST field.
	RCC_APBRSTR1_DAC1RST_Pos = 0x1d
	// Bit mask of DAC1RST field.
	RCC_APBRSTR1_DAC1RST_Msk = 0x20000000
	// Bit DAC1RST.
	RCC_APBRSTR1_DAC1RST = 0x20000000
	// Position of LPTIM2RST field.
	RCC_APBRSTR1_LPTIM2RST_Pos = 0x1e
	// Bit mask of LPTIM2RST field.
	RCC_APBRSTR1_LPTIM2RST_Msk = 0x40000000
	// Bit LPTIM2RST.
	RCC_APBRSTR1_LPTIM2RST = 0x40000000
	// Position of LPTIM1RST field.
	RCC_APBRSTR1_LPTIM1RST_Pos = 0x1f
	// Bit mask of LPTIM1RST field.
	RCC_APBRSTR1_LPTIM1RST_Msk = 0x80000000
	// Bit LPTIM1RST.
	RCC_APBRSTR1_LPTIM1RST = 0x80000000

	// APBRSTR2: APB peripheral reset register 2
	// Position of SYSCFGRST field.
	RCC_APBRSTR2_SYSCFGRST_Pos = 0x0
	// Bit mask of SYSCFGRST field.
	RCC_APBRSTR2_SYSCFGRST_Msk = 0x1
	// Bit SYSCFGRST.
	RCC_APBRSTR2_SYSCFGRST = 0x1
	// Position of TIM1RST field.
	RCC_APBRSTR2_TIM1RST_Pos = 0xb
	// Bit mask of TIM1RST field.
	RCC_APBRSTR2_TIM1RST_Msk = 0x800
	// Bit TIM1RST.
	RCC_APBRSTR2_TIM1RST = 0x800
	// Position of SPI1RST field.
	RCC_APBRSTR2_SPI1RST_Pos = 0xc
	// Bit mask of SPI1RST field.
	RCC_APBRSTR2_SPI1RST_Msk = 0x1000
	// Bit SPI1RST.
	RCC_APBRSTR2_SPI1RST = 0x1000
	// Position of USART1RST field.
	RCC_APBRSTR2_USART1RST_Pos = 0xe
	// Bit mask of USART1RST field.
	RCC_APBRSTR2_USART1RST_Msk = 0x4000
	// Bit USART1RST.
	RCC_APBRSTR2_USART1RST = 0x4000
	// Position of TIM14RST field.
	RCC_APBRSTR2_TIM14RST_Pos = 0xf
	// Bit mask of TIM14RST field.
	RCC_APBRSTR2_TIM14RST_Msk = 0x8000
	// Bit TIM14RST.
	RCC_APBRSTR2_TIM14RST = 0x8000
	// Position of TIM15RST field.
	RCC_APBRSTR2_TIM15RST_Pos = 0x10
	// Bit mask of TIM15RST field.
	RCC_APBRSTR2_TIM15RST_Msk = 0x10000
	// Bit TIM15RST.
	RCC_APBRSTR2_TIM15RST = 0x10000
	// Position of TIM16RST field.
	RCC_APBRSTR2_TIM16RST_Pos = 0x11
	// Bit mask of TIM16RST field.
	RCC_APBRSTR2_TIM16RST_Msk = 0x20000
	// Bit TIM16RST.
	RCC_APBRSTR2_TIM16RST = 0x20000
	// Position of TIM17RST field.
	RCC_APBRSTR2_TIM17RST_Pos = 0x12
	// Bit mask of TIM17RST field.
	RCC_APBRSTR2_TIM17RST_Msk = 0x40000
	// Bit TIM17RST.
	RCC_APBRSTR2_TIM17RST = 0x40000
	// Position of ADCRST field.
	RCC_APBRSTR2_ADCRST_Pos = 0x14
	// Bit mask of ADCRST field.
	RCC_APBRSTR2_ADCRST_Msk = 0x100000
	// Bit ADCRST.
	RCC_APBRSTR2_ADCRST = 0x100000

	// IOPENR: GPIO clock enable register
	// Position of IOPAEN field.
	RCC_IOPENR_IOPAEN_Pos = 0x0
	// Bit mask of IOPAEN field.
	RCC_IOPENR_IOPAEN_Msk = 0x1
	// Bit IOPAEN.
	RCC_IOPENR_IOPAEN = 0x1
	// Position of IOPBEN field.
	RCC_IOPENR_IOPBEN_Pos = 0x1
	// Bit mask of IOPBEN field.
	RCC_IOPENR_IOPBEN_Msk = 0x2
	// Bit IOPBEN.
	RCC_IOPENR_IOPBEN = 0x2
	// Position of IOPCEN field.
	RCC_IOPENR_IOPCEN_Pos = 0x2
	// Bit mask of IOPCEN field.
	RCC_IOPENR_IOPCEN_Msk = 0x4
	// Bit IOPCEN.
	RCC_IOPENR_IOPCEN = 0x4
	// Position of IOPDEN field.
	RCC_IOPENR_IOPDEN_Pos = 0x3
	// Bit mask of IOPDEN field.
	RCC_IOPENR_IOPDEN_Msk = 0x8
	// Bit IOPDEN.
	RCC_IOPENR_IOPDEN = 0x8
	// Position of IOPFEN field.
	RCC_IOPENR_IOPFEN_Pos = 0x5
	// Bit mask of IOPFEN field.
	RCC_IOPENR_IOPFEN_Msk = 0x20
	// Bit IOPFEN.
	RCC_IOPENR_IOPFEN = 0x20

	// AHBENR: AHB peripheral clock enable register
	// Position of DMAEN field.
	RCC_AHBENR_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	RCC_AHBENR_DMAEN_Msk = 0x1
	// Bit DMAEN.
	RCC_AHBENR_DMAEN = 0x1
	// Position of FLASHEN field.
	RCC_AHBENR_FLASHEN_Pos = 0x8
	// Bit mask of FLASHEN field.
	RCC_AHBENR_FLASHEN_Msk = 0x100
	// Bit FLASHEN.
	RCC_AHBENR_FLASHEN = 0x100
	// Position of CRCEN field.
	RCC_AHBENR_CRCEN_Pos = 0xc
	// Bit mask of CRCEN field.
	RCC_AHBENR_CRCEN_Msk = 0x1000
	// Bit CRCEN.
	RCC_AHBENR_CRCEN = 0x1000

	// APBENR1: APB peripheral clock enable register 1
	// Position of TIM2EN field.
	RCC_APBENR1_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_APBENR1_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_APBENR1_TIM2EN = 0x1
	// Position of TIM3EN field.
	RCC_APBENR1_TIM3EN_Pos = 0x1
	// Bit mask of TIM3EN field.
	RCC_APBENR1_TIM3EN_Msk = 0x2
	// Bit TIM3EN.
	RCC_APBENR1_TIM3EN = 0x2
	// Position of TIM6EN field.
	RCC_APBENR1_TIM6EN_Pos = 0x4
	// Bit mask of TIM6EN field.
	RCC_APBENR1_TIM6EN_Msk = 0x10
	// Bit TIM6EN.
	RCC_APBENR1_TIM6EN = 0x10
	// Position of TIM7EN field.
	RCC_APBENR1_TIM7EN_Pos = 0x5
	// Bit mask of TIM7EN field.
	RCC_APBENR1_TIM7EN_Msk = 0x20
	// Bit TIM7EN.
	RCC_APBENR1_TIM7EN = 0x20
	// Position of RTCAPBEN field.
	RCC_APBENR1_RTCAPBEN_Pos = 0xa
	// Bit mask of RTCAPBEN field.
	RCC_APBENR1_RTCAPBEN_Msk = 0x400
	// Bit RTCAPBEN.
	RCC_APBENR1_RTCAPBEN = 0x400
	// Position of WWDGEN field.
	RCC_APBENR1_WWDGEN_Pos = 0xb
	// Bit mask of WWDGEN field.
	RCC_APBENR1_WWDGEN_Msk = 0x800
	// Bit WWDGEN.
	RCC_APBENR1_WWDGEN = 0x800
	// Position of SPI2EN field.
	RCC_APBENR1_SPI2EN_Pos = 0xe
	// Bit mask of SPI2EN field.
	RCC_APBENR1_SPI2EN_Msk = 0x4000
	// Bit SPI2EN.
	RCC_APBENR1_SPI2EN = 0x4000
	// Position of USART2EN field.
	RCC_APBENR1_USART2EN_Pos = 0x11
	// Bit mask of USART2EN field.
	RCC_APBENR1_USART2EN_Msk = 0x20000
	// Bit USART2EN.
	RCC_APBENR1_USART2EN = 0x20000
	// Position of USART3EN field.
	RCC_APBENR1_USART3EN_Pos = 0x12
	// Bit mask of USART3EN field.
	RCC_APBENR1_USART3EN_Msk = 0x40000
	// Bit USART3EN.
	RCC_APBENR1_USART3EN = 0x40000
	// Position of USART4EN field.
	RCC_APBENR1_USART4EN_Pos = 0x13
	// Bit mask of USART4EN field.
	RCC_APBENR1_USART4EN_Msk = 0x80000
	// Bit USART4EN.
	RCC_APBENR1_USART4EN = 0x80000
	// Position of LPUART1EN field.
	RCC_APBENR1_LPUART1EN_Pos = 0x14
	// Bit mask of LPUART1EN field.
	RCC_APBENR1_LPUART1EN_Msk = 0x100000
	// Bit LPUART1EN.
	RCC_APBENR1_LPUART1EN = 0x100000
	// Position of I2C1EN field.
	RCC_APBENR1_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_APBENR1_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_APBENR1_I2C1EN = 0x200000
	// Position of I2C2EN field.
	RCC_APBENR1_I2C2EN_Pos = 0x16
	// Bit mask of I2C2EN field.
	RCC_APBENR1_I2C2EN_Msk = 0x400000
	// Bit I2C2EN.
	RCC_APBENR1_I2C2EN = 0x400000
	// Position of CECEN field.
	RCC_APBENR1_CECEN_Pos = 0x18
	// Bit mask of CECEN field.
	RCC_APBENR1_CECEN_Msk = 0x1000000
	// Bit CECEN.
	RCC_APBENR1_CECEN = 0x1000000
	// Position of UCPD1EN field.
	RCC_APBENR1_UCPD1EN_Pos = 0x19
	// Bit mask of UCPD1EN field.
	RCC_APBENR1_UCPD1EN_Msk = 0x2000000
	// Bit UCPD1EN.
	RCC_APBENR1_UCPD1EN = 0x2000000
	// Position of UCPD2EN field.
	RCC_APBENR1_UCPD2EN_Pos = 0x1a
	// Bit mask of UCPD2EN field.
	RCC_APBENR1_UCPD2EN_Msk = 0x4000000
	// Bit UCPD2EN.
	RCC_APBENR1_UCPD2EN = 0x4000000
	// Position of DBGEN field.
	RCC_APBENR1_DBGEN_Pos = 0x1b
	// Bit mask of DBGEN field.
	RCC_APBENR1_DBGEN_Msk = 0x8000000
	// Bit DBGEN.
	RCC_APBENR1_DBGEN = 0x8000000
	// Position of PWREN field.
	RCC_APBENR1_PWREN_Pos = 0x1c
	// Bit mask of PWREN field.
	RCC_APBENR1_PWREN_Msk = 0x10000000
	// Bit PWREN.
	RCC_APBENR1_PWREN = 0x10000000
	// Position of DAC1EN field.
	RCC_APBENR1_DAC1EN_Pos = 0x1d
	// Bit mask of DAC1EN field.
	RCC_APBENR1_DAC1EN_Msk = 0x20000000
	// Bit DAC1EN.
	RCC_APBENR1_DAC1EN = 0x20000000
	// Position of LPTIM2EN field.
	RCC_APBENR1_LPTIM2EN_Pos = 0x1e
	// Bit mask of LPTIM2EN field.
	RCC_APBENR1_LPTIM2EN_Msk = 0x40000000
	// Bit LPTIM2EN.
	RCC_APBENR1_LPTIM2EN = 0x40000000
	// Position of LPTIM1EN field.
	RCC_APBENR1_LPTIM1EN_Pos = 0x1f
	// Bit mask of LPTIM1EN field.
	RCC_APBENR1_LPTIM1EN_Msk = 0x80000000
	// Bit LPTIM1EN.
	RCC_APBENR1_LPTIM1EN = 0x80000000

	// APBENR2: APB peripheral clock enable register 2
	// Position of SYSCFGEN field.
	RCC_APBENR2_SYSCFGEN_Pos = 0x0
	// Bit mask of SYSCFGEN field.
	RCC_APBENR2_SYSCFGEN_Msk = 0x1
	// Bit SYSCFGEN.
	RCC_APBENR2_SYSCFGEN = 0x1
	// Position of TIM1EN field.
	RCC_APBENR2_TIM1EN_Pos = 0xb
	// Bit mask of TIM1EN field.
	RCC_APBENR2_TIM1EN_Msk = 0x800
	// Bit TIM1EN.
	RCC_APBENR2_TIM1EN = 0x800
	// Position of SPI1EN field.
	RCC_APBENR2_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_APBENR2_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_APBENR2_SPI1EN = 0x1000
	// Position of USART1EN field.
	RCC_APBENR2_USART1EN_Pos = 0xe
	// Bit mask of USART1EN field.
	RCC_APBENR2_USART1EN_Msk = 0x4000
	// Bit USART1EN.
	RCC_APBENR2_USART1EN = 0x4000
	// Position of TIM14EN field.
	RCC_APBENR2_TIM14EN_Pos = 0xf
	// Bit mask of TIM14EN field.
	RCC_APBENR2_TIM14EN_Msk = 0x8000
	// Bit TIM14EN.
	RCC_APBENR2_TIM14EN = 0x8000
	// Position of TIM15EN field.
	RCC_APBENR2_TIM15EN_Pos = 0x10
	// Bit mask of TIM15EN field.
	RCC_APBENR2_TIM15EN_Msk = 0x10000
	// Bit TIM15EN.
	RCC_APBENR2_TIM15EN = 0x10000
	// Position of TIM16EN field.
	RCC_APBENR2_TIM16EN_Pos = 0x11
	// Bit mask of TIM16EN field.
	RCC_APBENR2_TIM16EN_Msk = 0x20000
	// Bit TIM16EN.
	RCC_APBENR2_TIM16EN = 0x20000
	// Position of TIM17EN field.
	RCC_APBENR2_TIM17EN_Pos = 0x12
	// Bit mask of TIM17EN field.
	RCC_APBENR2_TIM17EN_Msk = 0x40000
	// Bit TIM17EN.
	RCC_APBENR2_TIM17EN = 0x40000
	// Position of ADCEN field.
	RCC_APBENR2_ADCEN_Pos = 0x14
	// Bit mask of ADCEN field.
	RCC_APBENR2_ADCEN_Msk = 0x100000
	// Bit ADCEN.
	RCC_APBENR2_ADCEN = 0x100000

	// IOPSMENR: GPIO in Sleep mode clock enable register
	// Position of IOPASMEN field.
	RCC_IOPSMENR_IOPASMEN_Pos = 0x0
	// Bit mask of IOPASMEN field.
	RCC_IOPSMENR_IOPASMEN_Msk = 0x1
	// Bit IOPASMEN.
	RCC_IOPSMENR_IOPASMEN = 0x1
	// Position of IOPBSMEN field.
	RCC_IOPSMENR_IOPBSMEN_Pos = 0x1
	// Bit mask of IOPBSMEN field.
	RCC_IOPSMENR_IOPBSMEN_Msk = 0x2
	// Bit IOPBSMEN.
	RCC_IOPSMENR_IOPBSMEN = 0x2
	// Position of IOPCSMEN field.
	RCC_IOPSMENR_IOPCSMEN_Pos = 0x2
	// Bit mask of IOPCSMEN field.
	RCC_IOPSMENR_IOPCSMEN_Msk = 0x4
	// Bit IOPCSMEN.
	RCC_IOPSMENR_IOPCSMEN = 0x4
	// Position of IOPDSMEN field.
	RCC_IOPSMENR_IOPDSMEN_Pos = 0x3
	// Bit mask of IOPDSMEN field.
	RCC_IOPSMENR_IOPDSMEN_Msk = 0x8
	// Bit IOPDSMEN.
	RCC_IOPSMENR_IOPDSMEN = 0x8
	// Position of IOPFSMEN field.
	RCC_IOPSMENR_IOPFSMEN_Pos = 0x5
	// Bit mask of IOPFSMEN field.
	RCC_IOPSMENR_IOPFSMEN_Msk = 0x20
	// Bit IOPFSMEN.
	RCC_IOPSMENR_IOPFSMEN = 0x20

	// AHBSMENR: AHB peripheral clock enable in Sleep mode register
	// Position of DMASMEN field.
	RCC_AHBSMENR_DMASMEN_Pos = 0x0
	// Bit mask of DMASMEN field.
	RCC_AHBSMENR_DMASMEN_Msk = 0x1
	// Bit DMASMEN.
	RCC_AHBSMENR_DMASMEN = 0x1
	// Position of FLASHSMEN field.
	RCC_AHBSMENR_FLASHSMEN_Pos = 0x8
	// Bit mask of FLASHSMEN field.
	RCC_AHBSMENR_FLASHSMEN_Msk = 0x100
	// Bit FLASHSMEN.
	RCC_AHBSMENR_FLASHSMEN = 0x100
	// Position of SRAMSMEN field.
	RCC_AHBSMENR_SRAMSMEN_Pos = 0x9
	// Bit mask of SRAMSMEN field.
	RCC_AHBSMENR_SRAMSMEN_Msk = 0x200
	// Bit SRAMSMEN.
	RCC_AHBSMENR_SRAMSMEN = 0x200
	// Position of CRCSMEN field.
	RCC_AHBSMENR_CRCSMEN_Pos = 0xc
	// Bit mask of CRCSMEN field.
	RCC_AHBSMENR_CRCSMEN_Msk = 0x1000
	// Bit CRCSMEN.
	RCC_AHBSMENR_CRCSMEN = 0x1000

	// APBSMENR1: APB peripheral clock enable in Sleep mode register 1
	// Position of TIM2SMEN field.
	RCC_APBSMENR1_TIM2SMEN_Pos = 0x0
	// Bit mask of TIM2SMEN field.
	RCC_APBSMENR1_TIM2SMEN_Msk = 0x1
	// Bit TIM2SMEN.
	RCC_APBSMENR1_TIM2SMEN = 0x1
	// Position of TIM3SMEN field.
	RCC_APBSMENR1_TIM3SMEN_Pos = 0x1
	// Bit mask of TIM3SMEN field.
	RCC_APBSMENR1_TIM3SMEN_Msk = 0x2
	// Bit TIM3SMEN.
	RCC_APBSMENR1_TIM3SMEN = 0x2
	// Position of TIM6SMEN field.
	RCC_APBSMENR1_TIM6SMEN_Pos = 0x4
	// Bit mask of TIM6SMEN field.
	RCC_APBSMENR1_TIM6SMEN_Msk = 0x10
	// Bit TIM6SMEN.
	RCC_APBSMENR1_TIM6SMEN = 0x10
	// Position of TIM7SMEN field.
	RCC_APBSMENR1_TIM7SMEN_Pos = 0x5
	// Bit mask of TIM7SMEN field.
	RCC_APBSMENR1_TIM7SMEN_Msk = 0x20
	// Bit TIM7SMEN.
	RCC_APBSMENR1_TIM7SMEN = 0x20
	// Position of RTCAPBSMEN field.
	RCC_APBSMENR1_RTCAPBSMEN_Pos = 0xa
	// Bit mask of RTCAPBSMEN field.
	RCC_APBSMENR1_RTCAPBSMEN_Msk = 0x400
	// Bit RTCAPBSMEN.
	RCC_APBSMENR1_RTCAPBSMEN = 0x400
	// Position of WWDGSMEN field.
	RCC_APBSMENR1_WWDGSMEN_Pos = 0xb
	// Bit mask of WWDGSMEN field.
	RCC_APBSMENR1_WWDGSMEN_Msk = 0x800
	// Bit WWDGSMEN.
	RCC_APBSMENR1_WWDGSMEN = 0x800
	// Position of SPI2SMEN field.
	RCC_APBSMENR1_SPI2SMEN_Pos = 0xe
	// Bit mask of SPI2SMEN field.
	RCC_APBSMENR1_SPI2SMEN_Msk = 0x4000
	// Bit SPI2SMEN.
	RCC_APBSMENR1_SPI2SMEN = 0x4000
	// Position of USART2SMEN field.
	RCC_APBSMENR1_USART2SMEN_Pos = 0x11
	// Bit mask of USART2SMEN field.
	RCC_APBSMENR1_USART2SMEN_Msk = 0x20000
	// Bit USART2SMEN.
	RCC_APBSMENR1_USART2SMEN = 0x20000
	// Position of USART3SMEN field.
	RCC_APBSMENR1_USART3SMEN_Pos = 0x12
	// Bit mask of USART3SMEN field.
	RCC_APBSMENR1_USART3SMEN_Msk = 0x40000
	// Bit USART3SMEN.
	RCC_APBSMENR1_USART3SMEN = 0x40000
	// Position of USART4SMEN field.
	RCC_APBSMENR1_USART4SMEN_Pos = 0x13
	// Bit mask of USART4SMEN field.
	RCC_APBSMENR1_USART4SMEN_Msk = 0x80000
	// Bit USART4SMEN.
	RCC_APBSMENR1_USART4SMEN = 0x80000
	// Position of LPUART1SMEN field.
	RCC_APBSMENR1_LPUART1SMEN_Pos = 0x14
	// Bit mask of LPUART1SMEN field.
	RCC_APBSMENR1_LPUART1SMEN_Msk = 0x100000
	// Bit LPUART1SMEN.
	RCC_APBSMENR1_LPUART1SMEN = 0x100000
	// Position of I2C1SMEN field.
	RCC_APBSMENR1_I2C1SMEN_Pos = 0x15
	// Bit mask of I2C1SMEN field.
	RCC_APBSMENR1_I2C1SMEN_Msk = 0x200000
	// Bit I2C1SMEN.
	RCC_APBSMENR1_I2C1SMEN = 0x200000
	// Position of I2C2SMEN field.
	RCC_APBSMENR1_I2C2SMEN_Pos = 0x16
	// Bit mask of I2C2SMEN field.
	RCC_APBSMENR1_I2C2SMEN_Msk = 0x400000
	// Bit I2C2SMEN.
	RCC_APBSMENR1_I2C2SMEN = 0x400000
	// Position of CECSMEN field.
	RCC_APBSMENR1_CECSMEN_Pos = 0x18
	// Bit mask of CECSMEN field.
	RCC_APBSMENR1_CECSMEN_Msk = 0x1000000
	// Bit CECSMEN.
	RCC_APBSMENR1_CECSMEN = 0x1000000
	// Position of UCPD1SMEN field.
	RCC_APBSMENR1_UCPD1SMEN_Pos = 0x19
	// Bit mask of UCPD1SMEN field.
	RCC_APBSMENR1_UCPD1SMEN_Msk = 0x2000000
	// Bit UCPD1SMEN.
	RCC_APBSMENR1_UCPD1SMEN = 0x2000000
	// Position of UCPD2SMEN field.
	RCC_APBSMENR1_UCPD2SMEN_Pos = 0x1a
	// Bit mask of UCPD2SMEN field.
	RCC_APBSMENR1_UCPD2SMEN_Msk = 0x4000000
	// Bit UCPD2SMEN.
	RCC_APBSMENR1_UCPD2SMEN = 0x4000000
	// Position of DBGSMEN field.
	RCC_APBSMENR1_DBGSMEN_Pos = 0x1b
	// Bit mask of DBGSMEN field.
	RCC_APBSMENR1_DBGSMEN_Msk = 0x8000000
	// Bit DBGSMEN.
	RCC_APBSMENR1_DBGSMEN = 0x8000000
	// Position of PWRSMEN field.
	RCC_APBSMENR1_PWRSMEN_Pos = 0x1c
	// Bit mask of PWRSMEN field.
	RCC_APBSMENR1_PWRSMEN_Msk = 0x10000000
	// Bit PWRSMEN.
	RCC_APBSMENR1_PWRSMEN = 0x10000000
	// Position of DAC1SMEN field.
	RCC_APBSMENR1_DAC1SMEN_Pos = 0x1d
	// Bit mask of DAC1SMEN field.
	RCC_APBSMENR1_DAC1SMEN_Msk = 0x20000000
	// Bit DAC1SMEN.
	RCC_APBSMENR1_DAC1SMEN = 0x20000000
	// Position of LPTIM2SMEN field.
	RCC_APBSMENR1_LPTIM2SMEN_Pos = 0x1e
	// Bit mask of LPTIM2SMEN field.
	RCC_APBSMENR1_LPTIM2SMEN_Msk = 0x40000000
	// Bit LPTIM2SMEN.
	RCC_APBSMENR1_LPTIM2SMEN = 0x40000000
	// Position of LPTIM1SMEN field.
	RCC_APBSMENR1_LPTIM1SMEN_Pos = 0x1f
	// Bit mask of LPTIM1SMEN field.
	RCC_APBSMENR1_LPTIM1SMEN_Msk = 0x80000000
	// Bit LPTIM1SMEN.
	RCC_APBSMENR1_LPTIM1SMEN = 0x80000000

	// APBSMENR2: APB peripheral clock enable in Sleep mode register 2
	// Position of SYSCFGSMEN field.
	RCC_APBSMENR2_SYSCFGSMEN_Pos = 0x0
	// Bit mask of SYSCFGSMEN field.
	RCC_APBSMENR2_SYSCFGSMEN_Msk = 0x1
	// Bit SYSCFGSMEN.
	RCC_APBSMENR2_SYSCFGSMEN = 0x1
	// Position of TIM1SMEN field.
	RCC_APBSMENR2_TIM1SMEN_Pos = 0xb
	// Bit mask of TIM1SMEN field.
	RCC_APBSMENR2_TIM1SMEN_Msk = 0x800
	// Bit TIM1SMEN.
	RCC_APBSMENR2_TIM1SMEN = 0x800
	// Position of SPI1SMEN field.
	RCC_APBSMENR2_SPI1SMEN_Pos = 0xc
	// Bit mask of SPI1SMEN field.
	RCC_APBSMENR2_SPI1SMEN_Msk = 0x1000
	// Bit SPI1SMEN.
	RCC_APBSMENR2_SPI1SMEN = 0x1000
	// Position of USART1SMEN field.
	RCC_APBSMENR2_USART1SMEN_Pos = 0xe
	// Bit mask of USART1SMEN field.
	RCC_APBSMENR2_USART1SMEN_Msk = 0x4000
	// Bit USART1SMEN.
	RCC_APBSMENR2_USART1SMEN = 0x4000
	// Position of TIM14SMEN field.
	RCC_APBSMENR2_TIM14SMEN_Pos = 0xf
	// Bit mask of TIM14SMEN field.
	RCC_APBSMENR2_TIM14SMEN_Msk = 0x8000
	// Bit TIM14SMEN.
	RCC_APBSMENR2_TIM14SMEN = 0x8000
	// Position of TIM15SMEN field.
	RCC_APBSMENR2_TIM15SMEN_Pos = 0x10
	// Bit mask of TIM15SMEN field.
	RCC_APBSMENR2_TIM15SMEN_Msk = 0x10000
	// Bit TIM15SMEN.
	RCC_APBSMENR2_TIM15SMEN = 0x10000
	// Position of TIM16SMEN field.
	RCC_APBSMENR2_TIM16SMEN_Pos = 0x11
	// Bit mask of TIM16SMEN field.
	RCC_APBSMENR2_TIM16SMEN_Msk = 0x20000
	// Bit TIM16SMEN.
	RCC_APBSMENR2_TIM16SMEN = 0x20000
	// Position of TIM17SMEN field.
	RCC_APBSMENR2_TIM17SMEN_Pos = 0x12
	// Bit mask of TIM17SMEN field.
	RCC_APBSMENR2_TIM17SMEN_Msk = 0x40000
	// Bit TIM17SMEN.
	RCC_APBSMENR2_TIM17SMEN = 0x40000
	// Position of ADCSMEN field.
	RCC_APBSMENR2_ADCSMEN_Pos = 0x14
	// Bit mask of ADCSMEN field.
	RCC_APBSMENR2_ADCSMEN_Msk = 0x100000
	// Bit ADCSMEN.
	RCC_APBSMENR2_ADCSMEN = 0x100000

	// CCIPR: Peripherals independent clock configuration register
	// Position of USART1SEL field.
	RCC_CCIPR_USART1SEL_Pos = 0x0
	// Bit mask of USART1SEL field.
	RCC_CCIPR_USART1SEL_Msk = 0x3
	// Position of USART2SEL field.
	RCC_CCIPR_USART2SEL_Pos = 0x2
	// Bit mask of USART2SEL field.
	RCC_CCIPR_USART2SEL_Msk = 0xc
	// Position of CECSEL field.
	RCC_CCIPR_CECSEL_Pos = 0x6
	// Bit mask of CECSEL field.
	RCC_CCIPR_CECSEL_Msk = 0x40
	// Bit CECSEL.
	RCC_CCIPR_CECSEL = 0x40
	// Position of LPUART1SEL field.
	RCC_CCIPR_LPUART1SEL_Pos = 0xa
	// Bit mask of LPUART1SEL field.
	RCC_CCIPR_LPUART1SEL_Msk = 0xc00
	// Position of I2C1SEL field.
	RCC_CCIPR_I2C1SEL_Pos = 0xc
	// Bit mask of I2C1SEL field.
	RCC_CCIPR_I2C1SEL_Msk = 0x3000
	// Position of I2S2SEL field.
	RCC_CCIPR_I2S2SEL_Pos = 0xe
	// Bit mask of I2S2SEL field.
	RCC_CCIPR_I2S2SEL_Msk = 0xc000
	// Position of LPTIM1SEL field.
	RCC_CCIPR_LPTIM1SEL_Pos = 0x12
	// Bit mask of LPTIM1SEL field.
	RCC_CCIPR_LPTIM1SEL_Msk = 0xc0000
	// Position of LPTIM2SEL field.
	RCC_CCIPR_LPTIM2SEL_Pos = 0x14
	// Bit mask of LPTIM2SEL field.
	RCC_CCIPR_LPTIM2SEL_Msk = 0x300000
	// Position of TIM1SEL field.
	RCC_CCIPR_TIM1SEL_Pos = 0x16
	// Bit mask of TIM1SEL field.
	RCC_CCIPR_TIM1SEL_Msk = 0x400000
	// Bit TIM1SEL.
	RCC_CCIPR_TIM1SEL = 0x400000
	// Position of TIM15SEL field.
	RCC_CCIPR_TIM15SEL_Pos = 0x18
	// Bit mask of TIM15SEL field.
	RCC_CCIPR_TIM15SEL_Msk = 0x1000000
	// Bit TIM15SEL.
	RCC_CCIPR_TIM15SEL = 0x1000000
	// Position of ADCSEL field.
	RCC_CCIPR_ADCSEL_Pos = 0x1e
	// Bit mask of ADCSEL field.
	RCC_CCIPR_ADCSEL_Msk = 0xc0000000

	// BDCR: RTC domain control register
	// Position of LSEON field.
	RCC_BDCR_LSEON_Pos = 0x0
	// Bit mask of LSEON field.
	RCC_BDCR_LSEON_Msk = 0x1
	// Bit LSEON.
	RCC_BDCR_LSEON = 0x1
	// Position of LSERDY field.
	RCC_BDCR_LSERDY_Pos = 0x1
	// Bit mask of LSERDY field.
	RCC_BDCR_LSERDY_Msk = 0x2
	// Bit LSERDY.
	RCC_BDCR_LSERDY = 0x2
	// Position of LSEBYP field.
	RCC_BDCR_LSEBYP_Pos = 0x2
	// Bit mask of LSEBYP field.
	RCC_BDCR_LSEBYP_Msk = 0x4
	// Bit LSEBYP.
	RCC_BDCR_LSEBYP = 0x4
	// Position of LSEDRV field.
	RCC_BDCR_LSEDRV_Pos = 0x3
	// Bit mask of LSEDRV field.
	RCC_BDCR_LSEDRV_Msk = 0x18
	// Position of LSECSSON field.
	RCC_BDCR_LSECSSON_Pos = 0x5
	// Bit mask of LSECSSON field.
	RCC_BDCR_LSECSSON_Msk = 0x20
	// Bit LSECSSON.
	RCC_BDCR_LSECSSON = 0x20
	// Position of LSECSSD field.
	RCC_BDCR_LSECSSD_Pos = 0x6
	// Bit mask of LSECSSD field.
	RCC_BDCR_LSECSSD_Msk = 0x40
	// Bit LSECSSD.
	RCC_BDCR_LSECSSD = 0x40
	// Position of RTCSEL field.
	RCC_BDCR_RTCSEL_Pos = 0x8
	// Bit mask of RTCSEL field.
	RCC_BDCR_RTCSEL_Msk = 0x300
	// Position of RTCEN field.
	RCC_BDCR_RTCEN_Pos = 0xf
	// Bit mask of RTCEN field.
	RCC_BDCR_RTCEN_Msk = 0x8000
	// Bit RTCEN.
	RCC_BDCR_RTCEN = 0x8000
	// Position of BDRST field.
	RCC_BDCR_BDRST_Pos = 0x10
	// Bit mask of BDRST field.
	RCC_BDCR_BDRST_Msk = 0x10000
	// Bit BDRST.
	RCC_BDCR_BDRST = 0x10000
	// Position of LSCOEN field.
	RCC_BDCR_LSCOEN_Pos = 0x18
	// Bit mask of LSCOEN field.
	RCC_BDCR_LSCOEN_Msk = 0x1000000
	// Bit LSCOEN.
	RCC_BDCR_LSCOEN = 0x1000000
	// Position of LSCOSEL field.
	RCC_BDCR_LSCOSEL_Pos = 0x19
	// Bit mask of LSCOSEL field.
	RCC_BDCR_LSCOSEL_Msk = 0x2000000
	// Bit LSCOSEL.
	RCC_BDCR_LSCOSEL = 0x2000000

	// CSR: Control/status register
	// Position of LSION field.
	RCC_CSR_LSION_Pos = 0x0
	// Bit mask of LSION field.
	RCC_CSR_LSION_Msk = 0x1
	// Bit LSION.
	RCC_CSR_LSION = 0x1
	// Position of LSIRDY field.
	RCC_CSR_LSIRDY_Pos = 0x1
	// Bit mask of LSIRDY field.
	RCC_CSR_LSIRDY_Msk = 0x2
	// Bit LSIRDY.
	RCC_CSR_LSIRDY = 0x2
	// Position of RMVF field.
	RCC_CSR_RMVF_Pos = 0x17
	// Bit mask of RMVF field.
	RCC_CSR_RMVF_Msk = 0x800000
	// Bit RMVF.
	RCC_CSR_RMVF = 0x800000
	// Position of OBLRSTF field.
	RCC_CSR_OBLRSTF_Pos = 0x19
	// Bit mask of OBLRSTF field.
	RCC_CSR_OBLRSTF_Msk = 0x2000000
	// Bit OBLRSTF.
	RCC_CSR_OBLRSTF = 0x2000000
	// Position of PINRSTF field.
	RCC_CSR_PINRSTF_Pos = 0x1a
	// Bit mask of PINRSTF field.
	RCC_CSR_PINRSTF_Msk = 0x4000000
	// Bit PINRSTF.
	RCC_CSR_PINRSTF = 0x4000000
	// Position of PWRRSTF field.
	RCC_CSR_PWRRSTF_Pos = 0x1b
	// Bit mask of PWRRSTF field.
	RCC_CSR_PWRRSTF_Msk = 0x8000000
	// Bit PWRRSTF.
	RCC_CSR_PWRRSTF = 0x8000000
	// Position of SFTRSTF field.
	RCC_CSR_SFTRSTF_Pos = 0x1c
	// Bit mask of SFTRSTF field.
	RCC_CSR_SFTRSTF_Msk = 0x10000000
	// Bit SFTRSTF.
	RCC_CSR_SFTRSTF = 0x10000000
	// Position of IWDGRSTF field.
	RCC_CSR_IWDGRSTF_Pos = 0x1d
	// Bit mask of IWDGRSTF field.
	RCC_CSR_IWDGRSTF_Msk = 0x20000000
	// Bit IWDGRSTF.
	RCC_CSR_IWDGRSTF = 0x20000000
	// Position of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Pos = 0x1e
	// Bit mask of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Msk = 0x40000000
	// Bit WWDGRSTF.
	RCC_CSR_WWDGRSTF = 0x40000000
	// Position of LPWRRSTF field.
	RCC_CSR_LPWRRSTF_Pos = 0x1f
	// Bit mask of LPWRRSTF field.
	RCC_CSR_LPWRRSTF_Msk = 0x80000000
	// Bit LPWRRSTF.
	RCC_CSR_LPWRRSTF = 0x80000000
)

// Constants for PWR: Power control
const (
	// CR1: Power control register 1
	// Position of LPR field.
	PWR_CR1_LPR_Pos = 0xe
	// Bit mask of LPR field.
	PWR_CR1_LPR_Msk = 0x4000
	// Bit LPR.
	PWR_CR1_LPR = 0x4000
	// Position of VOS field.
	PWR_CR1_VOS_Pos = 0x9
	// Bit mask of VOS field.
	PWR_CR1_VOS_Msk = 0x600
	// Position of DBP field.
	PWR_CR1_DBP_Pos = 0x8
	// Bit mask of DBP field.
	PWR_CR1_DBP_Msk = 0x100
	// Bit DBP.
	PWR_CR1_DBP = 0x100
	// Position of FPD_LPSLP field.
	PWR_CR1_FPD_LPSLP_Pos = 0x5
	// Bit mask of FPD_LPSLP field.
	PWR_CR1_FPD_LPSLP_Msk = 0x20
	// Bit FPD_LPSLP.
	PWR_CR1_FPD_LPSLP = 0x20
	// Position of FPD_LPRUN field.
	PWR_CR1_FPD_LPRUN_Pos = 0x4
	// Bit mask of FPD_LPRUN field.
	PWR_CR1_FPD_LPRUN_Msk = 0x10
	// Bit FPD_LPRUN.
	PWR_CR1_FPD_LPRUN = 0x10
	// Position of FPD_STOP field.
	PWR_CR1_FPD_STOP_Pos = 0x3
	// Bit mask of FPD_STOP field.
	PWR_CR1_FPD_STOP_Msk = 0x8
	// Bit FPD_STOP.
	PWR_CR1_FPD_STOP = 0x8
	// Position of LPMS field.
	PWR_CR1_LPMS_Pos = 0x0
	// Bit mask of LPMS field.
	PWR_CR1_LPMS_Msk = 0x7

	// CR2: Power control register 2
	// Position of PVDE field.
	PWR_CR2_PVDE_Pos = 0x0
	// Bit mask of PVDE field.
	PWR_CR2_PVDE_Msk = 0x1
	// Bit PVDE.
	PWR_CR2_PVDE = 0x1
	// Position of PVDFT field.
	PWR_CR2_PVDFT_Pos = 0x1
	// Bit mask of PVDFT field.
	PWR_CR2_PVDFT_Msk = 0xe
	// Position of PVDRT field.
	PWR_CR2_PVDRT_Pos = 0x4
	// Bit mask of PVDRT field.
	PWR_CR2_PVDRT_Msk = 0x70

	// CR3: Power control register 3
	// Position of EWUP1 field.
	PWR_CR3_EWUP1_Pos = 0x0
	// Bit mask of EWUP1 field.
	PWR_CR3_EWUP1_Msk = 0x1
	// Bit EWUP1.
	PWR_CR3_EWUP1 = 0x1
	// Position of EWUP2 field.
	PWR_CR3_EWUP2_Pos = 0x1
	// Bit mask of EWUP2 field.
	PWR_CR3_EWUP2_Msk = 0x2
	// Bit EWUP2.
	PWR_CR3_EWUP2 = 0x2
	// Position of EWUP4 field.
	PWR_CR3_EWUP4_Pos = 0x3
	// Bit mask of EWUP4 field.
	PWR_CR3_EWUP4_Msk = 0x8
	// Bit EWUP4.
	PWR_CR3_EWUP4 = 0x8
	// Position of EWUP5 field.
	PWR_CR3_EWUP5_Pos = 0x4
	// Bit mask of EWUP5 field.
	PWR_CR3_EWUP5_Msk = 0x10
	// Bit EWUP5.
	PWR_CR3_EWUP5 = 0x10
	// Position of EWUP6 field.
	PWR_CR3_EWUP6_Pos = 0x5
	// Bit mask of EWUP6 field.
	PWR_CR3_EWUP6_Msk = 0x20
	// Bit EWUP6.
	PWR_CR3_EWUP6 = 0x20
	// Position of RRS field.
	PWR_CR3_RRS_Pos = 0x8
	// Bit mask of RRS field.
	PWR_CR3_RRS_Msk = 0x100
	// Bit RRS.
	PWR_CR3_RRS = 0x100
	// Position of ULPEN field.
	PWR_CR3_ULPEN_Pos = 0x9
	// Bit mask of ULPEN field.
	PWR_CR3_ULPEN_Msk = 0x200
	// Bit ULPEN.
	PWR_CR3_ULPEN = 0x200
	// Position of APC field.
	PWR_CR3_APC_Pos = 0xa
	// Bit mask of APC field.
	PWR_CR3_APC_Msk = 0x400
	// Bit APC.
	PWR_CR3_APC = 0x400
	// Position of EIWUL field.
	PWR_CR3_EIWUL_Pos = 0xf
	// Bit mask of EIWUL field.
	PWR_CR3_EIWUL_Msk = 0x8000
	// Bit EIWUL.
	PWR_CR3_EIWUL = 0x8000

	// CR4: Power control register 4
	// Position of WP1 field.
	PWR_CR4_WP1_Pos = 0x0
	// Bit mask of WP1 field.
	PWR_CR4_WP1_Msk = 0x1
	// Bit WP1.
	PWR_CR4_WP1 = 0x1
	// Position of WP2 field.
	PWR_CR4_WP2_Pos = 0x1
	// Bit mask of WP2 field.
	PWR_CR4_WP2_Msk = 0x2
	// Bit WP2.
	PWR_CR4_WP2 = 0x2
	// Position of WP4 field.
	PWR_CR4_WP4_Pos = 0x3
	// Bit mask of WP4 field.
	PWR_CR4_WP4_Msk = 0x8
	// Bit WP4.
	PWR_CR4_WP4 = 0x8
	// Position of WP5 field.
	PWR_CR4_WP5_Pos = 0x4
	// Bit mask of WP5 field.
	PWR_CR4_WP5_Msk = 0x10
	// Bit WP5.
	PWR_CR4_WP5 = 0x10
	// Position of WP6 field.
	PWR_CR4_WP6_Pos = 0x5
	// Bit mask of WP6 field.
	PWR_CR4_WP6_Msk = 0x20
	// Bit WP6.
	PWR_CR4_WP6 = 0x20
	// Position of VBE field.
	PWR_CR4_VBE_Pos = 0x8
	// Bit mask of VBE field.
	PWR_CR4_VBE_Msk = 0x100
	// Bit VBE.
	PWR_CR4_VBE = 0x100
	// Position of VBRS field.
	PWR_CR4_VBRS_Pos = 0x9
	// Bit mask of VBRS field.
	PWR_CR4_VBRS_Msk = 0x200
	// Bit VBRS.
	PWR_CR4_VBRS = 0x200

	// SR1: Power status register 1
	// Position of WUF1 field.
	PWR_SR1_WUF1_Pos = 0x0
	// Bit mask of WUF1 field.
	PWR_SR1_WUF1_Msk = 0x1
	// Bit WUF1.
	PWR_SR1_WUF1 = 0x1
	// Position of WUF2 field.
	PWR_SR1_WUF2_Pos = 0x1
	// Bit mask of WUF2 field.
	PWR_SR1_WUF2_Msk = 0x2
	// Bit WUF2.
	PWR_SR1_WUF2 = 0x2
	// Position of WUF4 field.
	PWR_SR1_WUF4_Pos = 0x3
	// Bit mask of WUF4 field.
	PWR_SR1_WUF4_Msk = 0x8
	// Bit WUF4.
	PWR_SR1_WUF4 = 0x8
	// Position of WUF5 field.
	PWR_SR1_WUF5_Pos = 0x4
	// Bit mask of WUF5 field.
	PWR_SR1_WUF5_Msk = 0x10
	// Bit WUF5.
	PWR_SR1_WUF5 = 0x10
	// Position of WUF6 field.
	PWR_SR1_WUF6_Pos = 0x5
	// Bit mask of WUF6 field.
	PWR_SR1_WUF6_Msk = 0x20
	// Bit WUF6.
	PWR_SR1_WUF6 = 0x20
	// Position of SBF field.
	PWR_SR1_SBF_Pos = 0x8
	// Bit mask of SBF field.
	PWR_SR1_SBF_Msk = 0x100
	// Bit SBF.
	PWR_SR1_SBF = 0x100
	// Position of WUFI field.
	PWR_SR1_WUFI_Pos = 0xf
	// Bit mask of WUFI field.
	PWR_SR1_WUFI_Msk = 0x8000
	// Bit WUFI.
	PWR_SR1_WUFI = 0x8000

	// SR2: Power status register 2
	// Position of PVDO field.
	PWR_SR2_PVDO_Pos = 0xb
	// Bit mask of PVDO field.
	PWR_SR2_PVDO_Msk = 0x800
	// Bit PVDO.
	PWR_SR2_PVDO = 0x800
	// Position of VOSF field.
	PWR_SR2_VOSF_Pos = 0xa
	// Bit mask of VOSF field.
	PWR_SR2_VOSF_Msk = 0x400
	// Bit VOSF.
	PWR_SR2_VOSF = 0x400
	// Position of REGLPF field.
	PWR_SR2_REGLPF_Pos = 0x9
	// Bit mask of REGLPF field.
	PWR_SR2_REGLPF_Msk = 0x200
	// Bit REGLPF.
	PWR_SR2_REGLPF = 0x200
	// Position of REGLPS field.
	PWR_SR2_REGLPS_Pos = 0x8
	// Bit mask of REGLPS field.
	PWR_SR2_REGLPS_Msk = 0x100
	// Bit REGLPS.
	PWR_SR2_REGLPS = 0x100
	// Position of FLASH_RDY field.
	PWR_SR2_FLASH_RDY_Pos = 0x7
	// Bit mask of FLASH_RDY field.
	PWR_SR2_FLASH_RDY_Msk = 0x80
	// Bit FLASH_RDY.
	PWR_SR2_FLASH_RDY = 0x80

	// SCR: Power status clear register
	// Position of CSBF field.
	PWR_SCR_CSBF_Pos = 0x8
	// Bit mask of CSBF field.
	PWR_SCR_CSBF_Msk = 0x100
	// Bit CSBF.
	PWR_SCR_CSBF = 0x100
	// Position of CWUF6 field.
	PWR_SCR_CWUF6_Pos = 0x5
	// Bit mask of CWUF6 field.
	PWR_SCR_CWUF6_Msk = 0x20
	// Bit CWUF6.
	PWR_SCR_CWUF6 = 0x20
	// Position of CWUF5 field.
	PWR_SCR_CWUF5_Pos = 0x4
	// Bit mask of CWUF5 field.
	PWR_SCR_CWUF5_Msk = 0x10
	// Bit CWUF5.
	PWR_SCR_CWUF5 = 0x10
	// Position of CWUF4 field.
	PWR_SCR_CWUF4_Pos = 0x3
	// Bit mask of CWUF4 field.
	PWR_SCR_CWUF4_Msk = 0x8
	// Bit CWUF4.
	PWR_SCR_CWUF4 = 0x8
	// Position of CWUF2 field.
	PWR_SCR_CWUF2_Pos = 0x1
	// Bit mask of CWUF2 field.
	PWR_SCR_CWUF2_Msk = 0x2
	// Bit CWUF2.
	PWR_SCR_CWUF2 = 0x2
	// Position of CWUF1 field.
	PWR_SCR_CWUF1_Pos = 0x0
	// Bit mask of CWUF1 field.
	PWR_SCR_CWUF1_Msk = 0x1
	// Bit CWUF1.
	PWR_SCR_CWUF1 = 0x1

	// PUCRA: Power Port A pull-up control register
	// Position of PU15 field.
	PWR_PUCRA_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRA_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRA_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRA_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRA_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRA_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRA_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRA_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRA_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRA_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRA_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRA_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRA_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRA_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRA_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRA_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRA_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRA_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRA_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRA_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRA_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRA_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRA_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRA_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRA_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRA_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRA_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRA_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRA_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRA_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRA_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRA_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRA_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRA_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRA_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRA_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRA_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRA_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRA_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRA_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRA_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRA_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRA_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRA_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRA_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRA_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRA_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRA_PU0 = 0x1

	// PDCRA: Power Port A pull-down control register
	// Position of PD15 field.
	PWR_PDCRA_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRA_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRA_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRA_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRA_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRA_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRA_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRA_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRA_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRA_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRA_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRA_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRA_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRA_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRA_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRA_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRA_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRA_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRA_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRA_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRA_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRA_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRA_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRA_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRA_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRA_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRA_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRA_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRA_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRA_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRA_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRA_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRA_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRA_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRA_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRA_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRA_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRA_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRA_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRA_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRA_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRA_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRA_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRA_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRA_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRA_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRA_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRA_PD0 = 0x1

	// PUCRB: Power Port B pull-up control register
	// Position of PU15 field.
	PWR_PUCRB_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRB_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRB_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRB_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRB_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRB_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRB_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRB_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRB_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRB_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRB_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRB_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRB_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRB_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRB_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRB_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRB_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRB_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRB_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRB_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRB_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRB_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRB_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRB_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRB_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRB_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRB_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRB_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRB_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRB_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRB_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRB_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRB_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRB_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRB_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRB_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRB_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRB_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRB_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRB_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRB_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRB_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRB_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRB_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRB_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRB_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRB_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRB_PU0 = 0x1

	// PDCRB: Power Port B pull-down control register
	// Position of PD15 field.
	PWR_PDCRB_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRB_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRB_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRB_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRB_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRB_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRB_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRB_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRB_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRB_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRB_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRB_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRB_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRB_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRB_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRB_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRB_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRB_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRB_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRB_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRB_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRB_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRB_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRB_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRB_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRB_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRB_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRB_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRB_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRB_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRB_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRB_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRB_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRB_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRB_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRB_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRB_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRB_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRB_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRB_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRB_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRB_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRB_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRB_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRB_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRB_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRB_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRB_PD0 = 0x1

	// PUCRC: Power Port C pull-up control register
	// Position of PU15 field.
	PWR_PUCRC_PU15_Pos = 0xf
	// Bit mask of PU15 field.
	PWR_PUCRC_PU15_Msk = 0x8000
	// Bit PU15.
	PWR_PUCRC_PU15 = 0x8000
	// Position of PU14 field.
	PWR_PUCRC_PU14_Pos = 0xe
	// Bit mask of PU14 field.
	PWR_PUCRC_PU14_Msk = 0x4000
	// Bit PU14.
	PWR_PUCRC_PU14 = 0x4000
	// Position of PU13 field.
	PWR_PUCRC_PU13_Pos = 0xd
	// Bit mask of PU13 field.
	PWR_PUCRC_PU13_Msk = 0x2000
	// Bit PU13.
	PWR_PUCRC_PU13 = 0x2000
	// Position of PU12 field.
	PWR_PUCRC_PU12_Pos = 0xc
	// Bit mask of PU12 field.
	PWR_PUCRC_PU12_Msk = 0x1000
	// Bit PU12.
	PWR_PUCRC_PU12 = 0x1000
	// Position of PU11 field.
	PWR_PUCRC_PU11_Pos = 0xb
	// Bit mask of PU11 field.
	PWR_PUCRC_PU11_Msk = 0x800
	// Bit PU11.
	PWR_PUCRC_PU11 = 0x800
	// Position of PU10 field.
	PWR_PUCRC_PU10_Pos = 0xa
	// Bit mask of PU10 field.
	PWR_PUCRC_PU10_Msk = 0x400
	// Bit PU10.
	PWR_PUCRC_PU10 = 0x400
	// Position of PU9 field.
	PWR_PUCRC_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRC_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRC_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRC_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRC_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRC_PU8 = 0x100
	// Position of PU7 field.
	PWR_PUCRC_PU7_Pos = 0x7
	// Bit mask of PU7 field.
	PWR_PUCRC_PU7_Msk = 0x80
	// Bit PU7.
	PWR_PUCRC_PU7 = 0x80
	// Position of PU6 field.
	PWR_PUCRC_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRC_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRC_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRC_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRC_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRC_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRC_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRC_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRC_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRC_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRC_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRC_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRC_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRC_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRC_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRC_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRC_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRC_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRC_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRC_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRC_PU0 = 0x1

	// PDCRC: Power Port C pull-down control register
	// Position of PD15 field.
	PWR_PDCRC_PD15_Pos = 0xf
	// Bit mask of PD15 field.
	PWR_PDCRC_PD15_Msk = 0x8000
	// Bit PD15.
	PWR_PDCRC_PD15 = 0x8000
	// Position of PD14 field.
	PWR_PDCRC_PD14_Pos = 0xe
	// Bit mask of PD14 field.
	PWR_PDCRC_PD14_Msk = 0x4000
	// Bit PD14.
	PWR_PDCRC_PD14 = 0x4000
	// Position of PD13 field.
	PWR_PDCRC_PD13_Pos = 0xd
	// Bit mask of PD13 field.
	PWR_PDCRC_PD13_Msk = 0x2000
	// Bit PD13.
	PWR_PDCRC_PD13 = 0x2000
	// Position of PD12 field.
	PWR_PDCRC_PD12_Pos = 0xc
	// Bit mask of PD12 field.
	PWR_PDCRC_PD12_Msk = 0x1000
	// Bit PD12.
	PWR_PDCRC_PD12 = 0x1000
	// Position of PD11 field.
	PWR_PDCRC_PD11_Pos = 0xb
	// Bit mask of PD11 field.
	PWR_PDCRC_PD11_Msk = 0x800
	// Bit PD11.
	PWR_PDCRC_PD11 = 0x800
	// Position of PD10 field.
	PWR_PDCRC_PD10_Pos = 0xa
	// Bit mask of PD10 field.
	PWR_PDCRC_PD10_Msk = 0x400
	// Bit PD10.
	PWR_PDCRC_PD10 = 0x400
	// Position of PD9 field.
	PWR_PDCRC_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRC_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRC_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRC_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRC_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRC_PD8 = 0x100
	// Position of PD7 field.
	PWR_PDCRC_PD7_Pos = 0x7
	// Bit mask of PD7 field.
	PWR_PDCRC_PD7_Msk = 0x80
	// Bit PD7.
	PWR_PDCRC_PD7 = 0x80
	// Position of PD6 field.
	PWR_PDCRC_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRC_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRC_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRC_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRC_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRC_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRC_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRC_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRC_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRC_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRC_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRC_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRC_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRC_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRC_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRC_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRC_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRC_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRC_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRC_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRC_PD0 = 0x1

	// PUCRD: Power Port D pull-up control register
	// Position of PU9 field.
	PWR_PUCRD_PU9_Pos = 0x9
	// Bit mask of PU9 field.
	PWR_PUCRD_PU9_Msk = 0x200
	// Bit PU9.
	PWR_PUCRD_PU9 = 0x200
	// Position of PU8 field.
	PWR_PUCRD_PU8_Pos = 0x8
	// Bit mask of PU8 field.
	PWR_PUCRD_PU8_Msk = 0x100
	// Bit PU8.
	PWR_PUCRD_PU8 = 0x100
	// Position of PU6 field.
	PWR_PUCRD_PU6_Pos = 0x6
	// Bit mask of PU6 field.
	PWR_PUCRD_PU6_Msk = 0x40
	// Bit PU6.
	PWR_PUCRD_PU6 = 0x40
	// Position of PU5 field.
	PWR_PUCRD_PU5_Pos = 0x5
	// Bit mask of PU5 field.
	PWR_PUCRD_PU5_Msk = 0x20
	// Bit PU5.
	PWR_PUCRD_PU5 = 0x20
	// Position of PU4 field.
	PWR_PUCRD_PU4_Pos = 0x4
	// Bit mask of PU4 field.
	PWR_PUCRD_PU4_Msk = 0x10
	// Bit PU4.
	PWR_PUCRD_PU4 = 0x10
	// Position of PU3 field.
	PWR_PUCRD_PU3_Pos = 0x3
	// Bit mask of PU3 field.
	PWR_PUCRD_PU3_Msk = 0x8
	// Bit PU3.
	PWR_PUCRD_PU3 = 0x8
	// Position of PU2 field.
	PWR_PUCRD_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRD_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRD_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRD_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRD_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRD_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRD_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRD_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRD_PU0 = 0x1

	// PDCRD: Power Port D pull-down control register
	// Position of PD9 field.
	PWR_PDCRD_PD9_Pos = 0x9
	// Bit mask of PD9 field.
	PWR_PDCRD_PD9_Msk = 0x200
	// Bit PD9.
	PWR_PDCRD_PD9 = 0x200
	// Position of PD8 field.
	PWR_PDCRD_PD8_Pos = 0x8
	// Bit mask of PD8 field.
	PWR_PDCRD_PD8_Msk = 0x100
	// Bit PD8.
	PWR_PDCRD_PD8 = 0x100
	// Position of PD6 field.
	PWR_PDCRD_PD6_Pos = 0x6
	// Bit mask of PD6 field.
	PWR_PDCRD_PD6_Msk = 0x40
	// Bit PD6.
	PWR_PDCRD_PD6 = 0x40
	// Position of PD5 field.
	PWR_PDCRD_PD5_Pos = 0x5
	// Bit mask of PD5 field.
	PWR_PDCRD_PD5_Msk = 0x20
	// Bit PD5.
	PWR_PDCRD_PD5 = 0x20
	// Position of PD4 field.
	PWR_PDCRD_PD4_Pos = 0x4
	// Bit mask of PD4 field.
	PWR_PDCRD_PD4_Msk = 0x10
	// Bit PD4.
	PWR_PDCRD_PD4 = 0x10
	// Position of PD3 field.
	PWR_PDCRD_PD3_Pos = 0x3
	// Bit mask of PD3 field.
	PWR_PDCRD_PD3_Msk = 0x8
	// Bit PD3.
	PWR_PDCRD_PD3 = 0x8
	// Position of PD2 field.
	PWR_PDCRD_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRD_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRD_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRD_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRD_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRD_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRD_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRD_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRD_PD0 = 0x1

	// PUCRF: Power Port F pull-up control register
	// Position of PU2 field.
	PWR_PUCRF_PU2_Pos = 0x2
	// Bit mask of PU2 field.
	PWR_PUCRF_PU2_Msk = 0x4
	// Bit PU2.
	PWR_PUCRF_PU2 = 0x4
	// Position of PU1 field.
	PWR_PUCRF_PU1_Pos = 0x1
	// Bit mask of PU1 field.
	PWR_PUCRF_PU1_Msk = 0x2
	// Bit PU1.
	PWR_PUCRF_PU1 = 0x2
	// Position of PU0 field.
	PWR_PUCRF_PU0_Pos = 0x0
	// Bit mask of PU0 field.
	PWR_PUCRF_PU0_Msk = 0x1
	// Bit PU0.
	PWR_PUCRF_PU0 = 0x1

	// PDCRF: Power Port F pull-down control register
	// Position of PD2 field.
	PWR_PDCRF_PD2_Pos = 0x2
	// Bit mask of PD2 field.
	PWR_PDCRF_PD2_Msk = 0x4
	// Bit PD2.
	PWR_PDCRF_PD2 = 0x4
	// Position of PD1 field.
	PWR_PDCRF_PD1_Pos = 0x1
	// Bit mask of PD1 field.
	PWR_PDCRF_PD1_Msk = 0x2
	// Bit PD1.
	PWR_PDCRF_PD1 = 0x2
	// Position of PD0 field.
	PWR_PDCRF_PD0_Pos = 0x0
	// Bit mask of PD0 field.
	PWR_PDCRF_PD0_Msk = 0x1
	// Bit PD0.
	PWR_PDCRF_PD0 = 0x1
)

// Constants for DMA: DMA controller
const (
	// ISR: low interrupt status register
	// Position of GIF1 field.
	DMA_ISR_GIF1_Pos = 0x0
	// Bit mask of GIF1 field.
	DMA_ISR_GIF1_Msk = 0x1
	// Bit GIF1.
	DMA_ISR_GIF1 = 0x1
	// Position of TCIF1 field.
	DMA_ISR_TCIF1_Pos = 0x1
	// Bit mask of TCIF1 field.
	DMA_ISR_TCIF1_Msk = 0x2
	// Bit TCIF1.
	DMA_ISR_TCIF1 = 0x2
	// Position of HTIF1 field.
	DMA_ISR_HTIF1_Pos = 0x2
	// Bit mask of HTIF1 field.
	DMA_ISR_HTIF1_Msk = 0x4
	// Bit HTIF1.
	DMA_ISR_HTIF1 = 0x4
	// Position of TEIF1 field.
	DMA_ISR_TEIF1_Pos = 0x3
	// Bit mask of TEIF1 field.
	DMA_ISR_TEIF1_Msk = 0x8
	// Bit TEIF1.
	DMA_ISR_TEIF1 = 0x8
	// Position of GIF2 field.
	DMA_ISR_GIF2_Pos = 0x4
	// Bit mask of GIF2 field.
	DMA_ISR_GIF2_Msk = 0x10
	// Bit GIF2.
	DMA_ISR_GIF2 = 0x10
	// Position of TCIF2 field.
	DMA_ISR_TCIF2_Pos = 0x5
	// Bit mask of TCIF2 field.
	DMA_ISR_TCIF2_Msk = 0x20
	// Bit TCIF2.
	DMA_ISR_TCIF2 = 0x20
	// Position of HTIF2 field.
	DMA_ISR_HTIF2_Pos = 0x6
	// Bit mask of HTIF2 field.
	DMA_ISR_HTIF2_Msk = 0x40
	// Bit HTIF2.
	DMA_ISR_HTIF2 = 0x40
	// Position of TEIF2 field.
	DMA_ISR_TEIF2_Pos = 0x7
	// Bit mask of TEIF2 field.
	DMA_ISR_TEIF2_Msk = 0x80
	// Bit TEIF2.
	DMA_ISR_TEIF2 = 0x80
	// Position of GIF3 field.
	DMA_ISR_GIF3_Pos = 0x8
	// Bit mask of GIF3 field.
	DMA_ISR_GIF3_Msk = 0x100
	// Bit GIF3.
	DMA_ISR_GIF3 = 0x100
	// Position of TCIF3 field.
	DMA_ISR_TCIF3_Pos = 0x9
	// Bit mask of TCIF3 field.
	DMA_ISR_TCIF3_Msk = 0x200
	// Bit TCIF3.
	DMA_ISR_TCIF3 = 0x200
	// Position of HTIF3 field.
	DMA_ISR_HTIF3_Pos = 0xa
	// Bit mask of HTIF3 field.
	DMA_ISR_HTIF3_Msk = 0x400
	// Bit HTIF3.
	DMA_ISR_HTIF3 = 0x400
	// Position of TEIF3 field.
	DMA_ISR_TEIF3_Pos = 0xb
	// Bit mask of TEIF3 field.
	DMA_ISR_TEIF3_Msk = 0x800
	// Bit TEIF3.
	DMA_ISR_TEIF3 = 0x800
	// Position of GIF4 field.
	DMA_ISR_GIF4_Pos = 0xc
	// Bit mask of GIF4 field.
	DMA_ISR_GIF4_Msk = 0x1000
	// Bit GIF4.
	DMA_ISR_GIF4 = 0x1000
	// Position of TCIF4 field.
	DMA_ISR_TCIF4_Pos = 0xd
	// Bit mask of TCIF4 field.
	DMA_ISR_TCIF4_Msk = 0x2000
	// Bit TCIF4.
	DMA_ISR_TCIF4 = 0x2000
	// Position of HTIF4 field.
	DMA_ISR_HTIF4_Pos = 0xe
	// Bit mask of HTIF4 field.
	DMA_ISR_HTIF4_Msk = 0x4000
	// Bit HTIF4.
	DMA_ISR_HTIF4 = 0x4000
	// Position of TEIF4 field.
	DMA_ISR_TEIF4_Pos = 0xf
	// Bit mask of TEIF4 field.
	DMA_ISR_TEIF4_Msk = 0x8000
	// Bit TEIF4.
	DMA_ISR_TEIF4 = 0x8000
	// Position of GIF5 field.
	DMA_ISR_GIF5_Pos = 0x10
	// Bit mask of GIF5 field.
	DMA_ISR_GIF5_Msk = 0x10000
	// Bit GIF5.
	DMA_ISR_GIF5 = 0x10000
	// Position of TCIF5 field.
	DMA_ISR_TCIF5_Pos = 0x11
	// Bit mask of TCIF5 field.
	DMA_ISR_TCIF5_Msk = 0x20000
	// Bit TCIF5.
	DMA_ISR_TCIF5 = 0x20000
	// Position of HTIF5 field.
	DMA_ISR_HTIF5_Pos = 0x12
	// Bit mask of HTIF5 field.
	DMA_ISR_HTIF5_Msk = 0x40000
	// Bit HTIF5.
	DMA_ISR_HTIF5 = 0x40000
	// Position of TEIF5 field.
	DMA_ISR_TEIF5_Pos = 0x13
	// Bit mask of TEIF5 field.
	DMA_ISR_TEIF5_Msk = 0x80000
	// Bit TEIF5.
	DMA_ISR_TEIF5 = 0x80000
	// Position of GIF6 field.
	DMA_ISR_GIF6_Pos = 0x14
	// Bit mask of GIF6 field.
	DMA_ISR_GIF6_Msk = 0x100000
	// Bit GIF6.
	DMA_ISR_GIF6 = 0x100000
	// Position of TCIF6 field.
	DMA_ISR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA_ISR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA_ISR_TCIF6 = 0x200000
	// Position of HTIF6 field.
	DMA_ISR_HTIF6_Pos = 0x16
	// Bit mask of HTIF6 field.
	DMA_ISR_HTIF6_Msk = 0x400000
	// Bit HTIF6.
	DMA_ISR_HTIF6 = 0x400000
	// Position of TEIF6 field.
	DMA_ISR_TEIF6_Pos = 0x17
	// Bit mask of TEIF6 field.
	DMA_ISR_TEIF6_Msk = 0x800000
	// Bit TEIF6.
	DMA_ISR_TEIF6 = 0x800000
	// Position of GIF7 field.
	DMA_ISR_GIF7_Pos = 0x18
	// Bit mask of GIF7 field.
	DMA_ISR_GIF7_Msk = 0x1000000
	// Bit GIF7.
	DMA_ISR_GIF7 = 0x1000000
	// Position of TCIF7 field.
	DMA_ISR_TCIF7_Pos = 0x19
	// Bit mask of TCIF7 field.
	DMA_ISR_TCIF7_Msk = 0x2000000
	// Bit TCIF7.
	DMA_ISR_TCIF7 = 0x2000000
	// Position of HTIF7 field.
	DMA_ISR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA_ISR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA_ISR_HTIF7 = 0x4000000
	// Position of TEIF7 field.
	DMA_ISR_TEIF7_Pos = 0x1b
	// Bit mask of TEIF7 field.
	DMA_ISR_TEIF7_Msk = 0x8000000
	// Bit TEIF7.
	DMA_ISR_TEIF7 = 0x8000000

	// IFCR: high interrupt status register
	// Position of CGIF1 field.
	DMA_IFCR_CGIF1_Pos = 0x0
	// Bit mask of CGIF1 field.
	DMA_IFCR_CGIF1_Msk = 0x1
	// Bit CGIF1.
	DMA_IFCR_CGIF1 = 0x1
	// Position of CTCIF1 field.
	DMA_IFCR_CTCIF1_Pos = 0x1
	// Bit mask of CTCIF1 field.
	DMA_IFCR_CTCIF1_Msk = 0x2
	// Bit CTCIF1.
	DMA_IFCR_CTCIF1 = 0x2
	// Position of CHTIF2 field.
	DMA_IFCR_CHTIF2_Pos = 0x2
	// Bit mask of CHTIF2 field.
	DMA_IFCR_CHTIF2_Msk = 0x4
	// Bit CHTIF2.
	DMA_IFCR_CHTIF2 = 0x4
	// Position of CTEIF3 field.
	DMA_IFCR_CTEIF3_Pos = 0x3
	// Bit mask of CTEIF3 field.
	DMA_IFCR_CTEIF3_Msk = 0x8
	// Bit CTEIF3.
	DMA_IFCR_CTEIF3 = 0x8
	// Position of CGIF4 field.
	DMA_IFCR_CGIF4_Pos = 0x4
	// Bit mask of CGIF4 field.
	DMA_IFCR_CGIF4_Msk = 0x10
	// Bit CGIF4.
	DMA_IFCR_CGIF4 = 0x10
	// Position of CTCIF5 field.
	DMA_IFCR_CTCIF5_Pos = 0x5
	// Bit mask of CTCIF5 field.
	DMA_IFCR_CTCIF5_Msk = 0x20
	// Bit CTCIF5.
	DMA_IFCR_CTCIF5 = 0x20
	// Position of CHTIF6 field.
	DMA_IFCR_CHTIF6_Pos = 0x6
	// Bit mask of CHTIF6 field.
	DMA_IFCR_CHTIF6_Msk = 0x40
	// Bit CHTIF6.
	DMA_IFCR_CHTIF6 = 0x40
	// Position of CTEIF7 field.
	DMA_IFCR_CTEIF7_Pos = 0x7
	// Bit mask of CTEIF7 field.
	DMA_IFCR_CTEIF7_Msk = 0x80
	// Bit CTEIF7.
	DMA_IFCR_CTEIF7 = 0x80
	// Position of CGIF8 field.
	DMA_IFCR_CGIF8_Pos = 0x8
	// Bit mask of CGIF8 field.
	DMA_IFCR_CGIF8_Msk = 0x100
	// Bit CGIF8.
	DMA_IFCR_CGIF8 = 0x100
	// Position of CTCIF9 field.
	DMA_IFCR_CTCIF9_Pos = 0x9
	// Bit mask of CTCIF9 field.
	DMA_IFCR_CTCIF9_Msk = 0x200
	// Bit CTCIF9.
	DMA_IFCR_CTCIF9 = 0x200
	// Position of CHTIF10 field.
	DMA_IFCR_CHTIF10_Pos = 0xa
	// Bit mask of CHTIF10 field.
	DMA_IFCR_CHTIF10_Msk = 0x400
	// Bit CHTIF10.
	DMA_IFCR_CHTIF10 = 0x400
	// Position of CTEIF11 field.
	DMA_IFCR_CTEIF11_Pos = 0xb
	// Bit mask of CTEIF11 field.
	DMA_IFCR_CTEIF11_Msk = 0x800
	// Bit CTEIF11.
	DMA_IFCR_CTEIF11 = 0x800
	// Position of CGIF12 field.
	DMA_IFCR_CGIF12_Pos = 0xc
	// Bit mask of CGIF12 field.
	DMA_IFCR_CGIF12_Msk = 0x1000
	// Bit CGIF12.
	DMA_IFCR_CGIF12 = 0x1000
	// Position of CTCIF13 field.
	DMA_IFCR_CTCIF13_Pos = 0xd
	// Bit mask of CTCIF13 field.
	DMA_IFCR_CTCIF13_Msk = 0x2000
	// Bit CTCIF13.
	DMA_IFCR_CTCIF13 = 0x2000
	// Position of CHTIF14 field.
	DMA_IFCR_CHTIF14_Pos = 0xe
	// Bit mask of CHTIF14 field.
	DMA_IFCR_CHTIF14_Msk = 0x4000
	// Bit CHTIF14.
	DMA_IFCR_CHTIF14 = 0x4000
	// Position of CTEIF4 field.
	DMA_IFCR_CTEIF4_Pos = 0xf
	// Bit mask of CTEIF4 field.
	DMA_IFCR_CTEIF4_Msk = 0x8000
	// Bit CTEIF4.
	DMA_IFCR_CTEIF4 = 0x8000
	// Position of CGIF16 field.
	DMA_IFCR_CGIF16_Pos = 0x10
	// Bit mask of CGIF16 field.
	DMA_IFCR_CGIF16_Msk = 0x10000
	// Bit CGIF16.
	DMA_IFCR_CGIF16 = 0x10000
	// Position of CTCIF17 field.
	DMA_IFCR_CTCIF17_Pos = 0x11
	// Bit mask of CTCIF17 field.
	DMA_IFCR_CTCIF17_Msk = 0x20000
	// Bit CTCIF17.
	DMA_IFCR_CTCIF17 = 0x20000
	// Position of CHTIF18 field.
	DMA_IFCR_CHTIF18_Pos = 0x12
	// Bit mask of CHTIF18 field.
	DMA_IFCR_CHTIF18_Msk = 0x40000
	// Bit CHTIF18.
	DMA_IFCR_CHTIF18 = 0x40000
	// Position of CTEIF19 field.
	DMA_IFCR_CTEIF19_Pos = 0x13
	// Bit mask of CTEIF19 field.
	DMA_IFCR_CTEIF19_Msk = 0x80000
	// Bit CTEIF19.
	DMA_IFCR_CTEIF19 = 0x80000
	// Position of CGIF20 field.
	DMA_IFCR_CGIF20_Pos = 0x14
	// Bit mask of CGIF20 field.
	DMA_IFCR_CGIF20_Msk = 0x100000
	// Bit CGIF20.
	DMA_IFCR_CGIF20 = 0x100000
	// Position of CTCIF21 field.
	DMA_IFCR_CTCIF21_Pos = 0x15
	// Bit mask of CTCIF21 field.
	DMA_IFCR_CTCIF21_Msk = 0x200000
	// Bit CTCIF21.
	DMA_IFCR_CTCIF21 = 0x200000
	// Position of CHTIF22 field.
	DMA_IFCR_CHTIF22_Pos = 0x16
	// Bit mask of CHTIF22 field.
	DMA_IFCR_CHTIF22_Msk = 0x400000
	// Bit CHTIF22.
	DMA_IFCR_CHTIF22 = 0x400000
	// Position of CTEIF23 field.
	DMA_IFCR_CTEIF23_Pos = 0x17
	// Bit mask of CTEIF23 field.
	DMA_IFCR_CTEIF23_Msk = 0x800000
	// Bit CTEIF23.
	DMA_IFCR_CTEIF23 = 0x800000
	// Position of CGIF24 field.
	DMA_IFCR_CGIF24_Pos = 0x18
	// Bit mask of CGIF24 field.
	DMA_IFCR_CGIF24_Msk = 0x1000000
	// Bit CGIF24.
	DMA_IFCR_CGIF24 = 0x1000000
	// Position of CTCIF25 field.
	DMA_IFCR_CTCIF25_Pos = 0x19
	// Bit mask of CTCIF25 field.
	DMA_IFCR_CTCIF25_Msk = 0x2000000
	// Bit CTCIF25.
	DMA_IFCR_CTCIF25 = 0x2000000
	// Position of CHTIF26 field.
	DMA_IFCR_CHTIF26_Pos = 0x1a
	// Bit mask of CHTIF26 field.
	DMA_IFCR_CHTIF26_Msk = 0x4000000
	// Bit CHTIF26.
	DMA_IFCR_CHTIF26 = 0x4000000
	// Position of CTEIF27 field.
	DMA_IFCR_CTEIF27_Pos = 0x1b
	// Bit mask of CTEIF27 field.
	DMA_IFCR_CTEIF27_Msk = 0x8000000
	// Bit CTEIF27.
	DMA_IFCR_CTEIF27 = 0x8000000

	// CH.CR: DMA channel x configuration register
	// Position of EN field.
	DMA_CH_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH_CR_EN_Msk = 0x1
	// Bit EN.
	DMA_CH_CR_EN = 0x1
	// Position of TCIE field.
	DMA_CH_CR_TCIE_Pos = 0x1
	// Bit mask of TCIE field.
	DMA_CH_CR_TCIE_Msk = 0x2
	// Bit TCIE.
	DMA_CH_CR_TCIE = 0x2
	// Position of HTIE field.
	DMA_CH_CR_HTIE_Pos = 0x2
	// Bit mask of HTIE field.
	DMA_CH_CR_HTIE_Msk = 0x4
	// Bit HTIE.
	DMA_CH_CR_HTIE = 0x4
	// Position of TEIE field.
	DMA_CH_CR_TEIE_Pos = 0x3
	// Bit mask of TEIE field.
	DMA_CH_CR_TEIE_Msk = 0x8
	// Bit TEIE.
	DMA_CH_CR_TEIE = 0x8
	// Position of DIR field.
	DMA_CH_CR_DIR_Pos = 0x4
	// Bit mask of DIR field.
	DMA_CH_CR_DIR_Msk = 0x10
	// Bit DIR.
	DMA_CH_CR_DIR = 0x10
	// Position of CIRC field.
	DMA_CH_CR_CIRC_Pos = 0x5
	// Bit mask of CIRC field.
	DMA_CH_CR_CIRC_Msk = 0x20
	// Bit CIRC.
	DMA_CH_CR_CIRC = 0x20
	// Position of PINC field.
	DMA_CH_CR_PINC_Pos = 0x6
	// Bit mask of PINC field.
	DMA_CH_CR_PINC_Msk = 0x40
	// Bit PINC.
	DMA_CH_CR_PINC = 0x40
	// Position of MINC field.
	DMA_CH_CR_MINC_Pos = 0x7
	// Bit mask of MINC field.
	DMA_CH_CR_MINC_Msk = 0x80
	// Bit MINC.
	DMA_CH_CR_MINC = 0x80
	// Position of PSIZE field.
	DMA_CH_CR_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	DMA_CH_CR_PSIZE_Msk = 0x300
	// Position of MSIZE field.
	DMA_CH_CR_MSIZE_Pos = 0xa
	// Bit mask of MSIZE field.
	DMA_CH_CR_MSIZE_Msk = 0xc00
	// Position of PL field.
	DMA_CH_CR_PL_Pos = 0xc
	// Bit mask of PL field.
	DMA_CH_CR_PL_Msk = 0x3000
	// Position of MEM2MEM field.
	DMA_CH_CR_MEM2MEM_Pos = 0xe
	// Bit mask of MEM2MEM field.
	DMA_CH_CR_MEM2MEM_Msk = 0x4000
	// Bit MEM2MEM.
	DMA_CH_CR_MEM2MEM = 0x4000

	// CH.NDTR: DMA channel x number of data register
	// Position of NDT field.
	DMA_CH_NDTR_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_CH_NDTR_NDT_Msk = 0xffff

	// CH.PAR: DMA channel x peripheral address register
	// Position of PA field.
	DMA_CH_PAR_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_CH_PAR_PA_Msk = 0xffffffff

	// CH.MAR: DMA channel x memory address register
	// Position of MA field.
	DMA_CH_MAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA_CH_MAR_MA_Msk = 0xffffffff
)

// Constants for DMAMUX: DMAMUX
const (
	// C0CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C0CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C0CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C0CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C0CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C0CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C0CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C0CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C0CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C0CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C0CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C0CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C0CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C0CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C0CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C0CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C0CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C0CR_SYNC_ID_Msk = 0x1f000000

	// C1CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C1CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C1CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C1CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C1CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C1CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C1CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C1CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C1CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C1CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C1CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C1CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C1CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C1CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C1CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C1CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C1CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C1CR_SYNC_ID_Msk = 0x1f000000

	// C2CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C2CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C2CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C2CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C2CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C2CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C2CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C2CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C2CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C2CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C2CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C2CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C2CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C2CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C2CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C2CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C2CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C2CR_SYNC_ID_Msk = 0x1f000000

	// C3CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C3CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C3CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C3CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C3CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C3CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C3CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C3CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C3CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C3CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C3CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C3CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C3CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C3CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C3CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C3CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C3CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C3CR_SYNC_ID_Msk = 0x1f000000

	// C4CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C4CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C4CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C4CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C4CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C4CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C4CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C4CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C4CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C4CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C4CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C4CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C4CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C4CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C4CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C4CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C4CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C4CR_SYNC_ID_Msk = 0x1f000000

	// C5CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C5CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C5CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C5CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C5CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C5CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C5CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C5CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C5CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C5CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C5CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C5CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C5CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C5CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C5CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C5CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C5CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C5CR_SYNC_ID_Msk = 0x1f000000

	// C6CR: DMAMux - DMA request line multiplexer channel x control register
	// Position of DMAREQ_ID field.
	DMAMUX_C6CR_DMAREQ_ID_Pos = 0x0
	// Bit mask of DMAREQ_ID field.
	DMAMUX_C6CR_DMAREQ_ID_Msk = 0xff
	// Position of SOIE field.
	DMAMUX_C6CR_SOIE_Pos = 0x8
	// Bit mask of SOIE field.
	DMAMUX_C6CR_SOIE_Msk = 0x100
	// Bit SOIE.
	DMAMUX_C6CR_SOIE = 0x100
	// Position of EGE field.
	DMAMUX_C6CR_EGE_Pos = 0x9
	// Bit mask of EGE field.
	DMAMUX_C6CR_EGE_Msk = 0x200
	// Bit EGE.
	DMAMUX_C6CR_EGE = 0x200
	// Position of SE field.
	DMAMUX_C6CR_SE_Pos = 0x10
	// Bit mask of SE field.
	DMAMUX_C6CR_SE_Msk = 0x10000
	// Bit SE.
	DMAMUX_C6CR_SE = 0x10000
	// Position of SPOL field.
	DMAMUX_C6CR_SPOL_Pos = 0x11
	// Bit mask of SPOL field.
	DMAMUX_C6CR_SPOL_Msk = 0x60000
	// Position of NBREQ field.
	DMAMUX_C6CR_NBREQ_Pos = 0x13
	// Bit mask of NBREQ field.
	DMAMUX_C6CR_NBREQ_Msk = 0xf80000
	// Position of SYNC_ID field.
	DMAMUX_C6CR_SYNC_ID_Pos = 0x18
	// Bit mask of SYNC_ID field.
	DMAMUX_C6CR_SYNC_ID_Msk = 0x1f000000

	// CSR: DMAMUX request line multiplexer interrupt channel status register
	// Position of SOF field.
	DMAMUX_CSR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	DMAMUX_CSR_SOF_Msk = 0x7f

	// CFR: DMAMUX request line multiplexer interrupt clear flag register
	// Position of CSOF field.
	DMAMUX_CFR_CSOF_Pos = 0x0
	// Bit mask of CSOF field.
	DMAMUX_CFR_CSOF_Msk = 0x7f

	// RG0CR: DMAMux - DMA request generator channel x control register
	// Position of SIG_ID field.
	DMAMUX_RG0CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG0CR_SIG_ID_Msk = 0x1f
	// Position of OIE field.
	DMAMUX_RG0CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG0CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG0CR_OIE = 0x100
	// Position of GE field.
	DMAMUX_RG0CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG0CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG0CR_GE = 0x10000
	// Position of GPOL field.
	DMAMUX_RG0CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG0CR_GPOL_Msk = 0x60000
	// Position of GNBREQ field.
	DMAMUX_RG0CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG0CR_GNBREQ_Msk = 0xf80000

	// RG1CR: DMAMux - DMA request generator channel x control register
	// Position of SIG_ID field.
	DMAMUX_RG1CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG1CR_SIG_ID_Msk = 0x1f
	// Position of OIE field.
	DMAMUX_RG1CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG1CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG1CR_OIE = 0x100
	// Position of GE field.
	DMAMUX_RG1CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG1CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG1CR_GE = 0x10000
	// Position of GPOL field.
	DMAMUX_RG1CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG1CR_GPOL_Msk = 0x60000
	// Position of GNBREQ field.
	DMAMUX_RG1CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG1CR_GNBREQ_Msk = 0xf80000

	// RG2CR: DMAMux - DMA request generator channel x control register
	// Position of SIG_ID field.
	DMAMUX_RG2CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG2CR_SIG_ID_Msk = 0x1f
	// Position of OIE field.
	DMAMUX_RG2CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG2CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG2CR_OIE = 0x100
	// Position of GE field.
	DMAMUX_RG2CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG2CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG2CR_GE = 0x10000
	// Position of GPOL field.
	DMAMUX_RG2CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG2CR_GPOL_Msk = 0x60000
	// Position of GNBREQ field.
	DMAMUX_RG2CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG2CR_GNBREQ_Msk = 0xf80000

	// RG3CR: DMAMux - DMA request generator channel x control register
	// Position of SIG_ID field.
	DMAMUX_RG3CR_SIG_ID_Pos = 0x0
	// Bit mask of SIG_ID field.
	DMAMUX_RG3CR_SIG_ID_Msk = 0x1f
	// Position of OIE field.
	DMAMUX_RG3CR_OIE_Pos = 0x8
	// Bit mask of OIE field.
	DMAMUX_RG3CR_OIE_Msk = 0x100
	// Bit OIE.
	DMAMUX_RG3CR_OIE = 0x100
	// Position of GE field.
	DMAMUX_RG3CR_GE_Pos = 0x10
	// Bit mask of GE field.
	DMAMUX_RG3CR_GE_Msk = 0x10000
	// Bit GE.
	DMAMUX_RG3CR_GE = 0x10000
	// Position of GPOL field.
	DMAMUX_RG3CR_GPOL_Pos = 0x11
	// Bit mask of GPOL field.
	DMAMUX_RG3CR_GPOL_Msk = 0x60000
	// Position of GNBREQ field.
	DMAMUX_RG3CR_GNBREQ_Pos = 0x13
	// Bit mask of GNBREQ field.
	DMAMUX_RG3CR_GNBREQ_Msk = 0xf80000

	// RGSR: DMAMux - DMA request generator status register
	// Position of OF field.
	DMAMUX_RGSR_OF_Pos = 0x0
	// Bit mask of OF field.
	DMAMUX_RGSR_OF_Msk = 0xf

	// RGCFR: DMAMux - DMA request generator clear flag register
	// Position of COF field.
	DMAMUX_RGCFR_COF_Pos = 0x0
	// Bit mask of COF field.
	DMAMUX_RGCFR_COF_Msk = 0xf

	// HWCFGR2: DMAMUX hardware configuration 2 register
	// Position of NUM_DMA_EXT_REQ field.
	DMAMUX_HWCFGR2_NUM_DMA_EXT_REQ_Pos = 0x0
	// Bit mask of NUM_DMA_EXT_REQ field.
	DMAMUX_HWCFGR2_NUM_DMA_EXT_REQ_Msk = 0xff

	// HWCFGR1: DMAMUX hardware configuration 1 register
	// Position of NUM_DMA_STREAMS field.
	DMAMUX_HWCFGR1_NUM_DMA_STREAMS_Pos = 0x0
	// Bit mask of NUM_DMA_STREAMS field.
	DMAMUX_HWCFGR1_NUM_DMA_STREAMS_Msk = 0xff
	// Position of NUM_DMA_PERIPH_REQ field.
	DMAMUX_HWCFGR1_NUM_DMA_PERIPH_REQ_Pos = 0x8
	// Bit mask of NUM_DMA_PERIPH_REQ field.
	DMAMUX_HWCFGR1_NUM_DMA_PERIPH_REQ_Msk = 0xff00
	// Position of NUM_DMA_TRIG field.
	DMAMUX_HWCFGR1_NUM_DMA_TRIG_Pos = 0x10
	// Bit mask of NUM_DMA_TRIG field.
	DMAMUX_HWCFGR1_NUM_DMA_TRIG_Msk = 0xff0000
	// Position of NUM_DMA_REQGEN field.
	DMAMUX_HWCFGR1_NUM_DMA_REQGEN_Pos = 0x18
	// Bit mask of NUM_DMA_REQGEN field.
	DMAMUX_HWCFGR1_NUM_DMA_REQGEN_Msk = 0xff000000

	// VERR: DMAMUX version register
	// Position of MINREV field.
	DMAMUX_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	DMAMUX_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	DMAMUX_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	DMAMUX_VERR_MAJREV_Msk = 0xf0

	// IPIDR: DMAMUX IP identification register
	// Position of ID field.
	DMAMUX_IPIDR_ID_Pos = 0x0
	// Bit mask of ID field.
	DMAMUX_IPIDR_ID_Msk = 0xffffffff

	// SIDR: DMAMUX size identification register
	// Position of SID field.
	DMAMUX_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	DMAMUX_SIDR_SID_Msk = 0xffffffff
)

// Constants for GPIOA: General-purpose I/Os
const (
	// MODER: GPIO port mode register
	// Position of MODER15 field.
	GPIO_MODER_MODER15_Pos = 0x1e
	// Bit mask of MODER15 field.
	GPIO_MODER_MODER15_Msk = 0xc0000000
	// Position of MODER14 field.
	GPIO_MODER_MODER14_Pos = 0x1c
	// Bit mask of MODER14 field.
	GPIO_MODER_MODER14_Msk = 0x30000000
	// Position of MODER13 field.
	GPIO_MODER_MODER13_Pos = 0x1a
	// Bit mask of MODER13 field.
	GPIO_MODER_MODER13_Msk = 0xc000000
	// Position of MODER12 field.
	GPIO_MODER_MODER12_Pos = 0x18
	// Bit mask of MODER12 field.
	GPIO_MODER_MODER12_Msk = 0x3000000
	// Position of MODER11 field.
	GPIO_MODER_MODER11_Pos = 0x16
	// Bit mask of MODER11 field.
	GPIO_MODER_MODER11_Msk = 0xc00000
	// Position of MODER10 field.
	GPIO_MODER_MODER10_Pos = 0x14
	// Bit mask of MODER10 field.
	GPIO_MODER_MODER10_Msk = 0x300000
	// Position of MODER9 field.
	GPIO_MODER_MODER9_Pos = 0x12
	// Bit mask of MODER9 field.
	GPIO_MODER_MODER9_Msk = 0xc0000
	// Position of MODER8 field.
	GPIO_MODER_MODER8_Pos = 0x10
	// Bit mask of MODER8 field.
	GPIO_MODER_MODER8_Msk = 0x30000
	// Position of MODER7 field.
	GPIO_MODER_MODER7_Pos = 0xe
	// Bit mask of MODER7 field.
	GPIO_MODER_MODER7_Msk = 0xc000
	// Position of MODER6 field.
	GPIO_MODER_MODER6_Pos = 0xc
	// Bit mask of MODER6 field.
	GPIO_MODER_MODER6_Msk = 0x3000
	// Position of MODER5 field.
	GPIO_MODER_MODER5_Pos = 0xa
	// Bit mask of MODER5 field.
	GPIO_MODER_MODER5_Msk = 0xc00
	// Position of MODER4 field.
	GPIO_MODER_MODER4_Pos = 0x8
	// Bit mask of MODER4 field.
	GPIO_MODER_MODER4_Msk = 0x300
	// Position of MODER3 field.
	GPIO_MODER_MODER3_Pos = 0x6
	// Bit mask of MODER3 field.
	GPIO_MODER_MODER3_Msk = 0xc0
	// Position of MODER2 field.
	GPIO_MODER_MODER2_Pos = 0x4
	// Bit mask of MODER2 field.
	GPIO_MODER_MODER2_Msk = 0x30
	// Position of MODER1 field.
	GPIO_MODER_MODER1_Pos = 0x2
	// Bit mask of MODER1 field.
	GPIO_MODER_MODER1_Msk = 0xc
	// Position of MODER0 field.
	GPIO_MODER_MODER0_Pos = 0x0
	// Bit mask of MODER0 field.
	GPIO_MODER_MODER0_Msk = 0x3

	// OTYPER: GPIO port output type register
	// Position of OT15 field.
	GPIO_OTYPER_OT15_Pos = 0xf
	// Bit mask of OT15 field.
	GPIO_OTYPER_OT15_Msk = 0x8000
	// Bit OT15.
	GPIO_OTYPER_OT15 = 0x8000
	// Position of OT14 field.
	GPIO_OTYPER_OT14_Pos = 0xe
	// Bit mask of OT14 field.
	GPIO_OTYPER_OT14_Msk = 0x4000
	// Bit OT14.
	GPIO_OTYPER_OT14 = 0x4000
	// Position of OT13 field.
	GPIO_OTYPER_OT13_Pos = 0xd
	// Bit mask of OT13 field.
	GPIO_OTYPER_OT13_Msk = 0x2000
	// Bit OT13.
	GPIO_OTYPER_OT13 = 0x2000
	// Position of OT12 field.
	GPIO_OTYPER_OT12_Pos = 0xc
	// Bit mask of OT12 field.
	GPIO_OTYPER_OT12_Msk = 0x1000
	// Bit OT12.
	GPIO_OTYPER_OT12 = 0x1000
	// Position of OT11 field.
	GPIO_OTYPER_OT11_Pos = 0xb
	// Bit mask of OT11 field.
	GPIO_OTYPER_OT11_Msk = 0x800
	// Bit OT11.
	GPIO_OTYPER_OT11 = 0x800
	// Position of OT10 field.
	GPIO_OTYPER_OT10_Pos = 0xa
	// Bit mask of OT10 field.
	GPIO_OTYPER_OT10_Msk = 0x400
	// Bit OT10.
	GPIO_OTYPER_OT10 = 0x400
	// Position of OT9 field.
	GPIO_OTYPER_OT9_Pos = 0x9
	// Bit mask of OT9 field.
	GPIO_OTYPER_OT9_Msk = 0x200
	// Bit OT9.
	GPIO_OTYPER_OT9 = 0x200
	// Position of OT8 field.
	GPIO_OTYPER_OT8_Pos = 0x8
	// Bit mask of OT8 field.
	GPIO_OTYPER_OT8_Msk = 0x100
	// Bit OT8.
	GPIO_OTYPER_OT8 = 0x100
	// Position of OT7 field.
	GPIO_OTYPER_OT7_Pos = 0x7
	// Bit mask of OT7 field.
	GPIO_OTYPER_OT7_Msk = 0x80
	// Bit OT7.
	GPIO_OTYPER_OT7 = 0x80
	// Position of OT6 field.
	GPIO_OTYPER_OT6_Pos = 0x6
	// Bit mask of OT6 field.
	GPIO_OTYPER_OT6_Msk = 0x40
	// Bit OT6.
	GPIO_OTYPER_OT6 = 0x40
	// Position of OT5 field.
	GPIO_OTYPER_OT5_Pos = 0x5
	// Bit mask of OT5 field.
	GPIO_OTYPER_OT5_Msk = 0x20
	// Bit OT5.
	GPIO_OTYPER_OT5 = 0x20
	// Position of OT4 field.
	GPIO_OTYPER_OT4_Pos = 0x4
	// Bit mask of OT4 field.
	GPIO_OTYPER_OT4_Msk = 0x10
	// Bit OT4.
	GPIO_OTYPER_OT4 = 0x10
	// Position of OT3 field.
	GPIO_OTYPER_OT3_Pos = 0x3
	// Bit mask of OT3 field.
	GPIO_OTYPER_OT3_Msk = 0x8
	// Bit OT3.
	GPIO_OTYPER_OT3 = 0x8
	// Position of OT2 field.
	GPIO_OTYPER_OT2_Pos = 0x2
	// Bit mask of OT2 field.
	GPIO_OTYPER_OT2_Msk = 0x4
	// Bit OT2.
	GPIO_OTYPER_OT2 = 0x4
	// Position of OT1 field.
	GPIO_OTYPER_OT1_Pos = 0x1
	// Bit mask of OT1 field.
	GPIO_OTYPER_OT1_Msk = 0x2
	// Bit OT1.
	GPIO_OTYPER_OT1 = 0x2
	// Position of OT0 field.
	GPIO_OTYPER_OT0_Pos = 0x0
	// Bit mask of OT0 field.
	GPIO_OTYPER_OT0_Msk = 0x1
	// Bit OT0.
	GPIO_OTYPER_OT0 = 0x1

	// OSPEEDR: GPIO port output speed register
	// Position of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Pos = 0x1e
	// Bit mask of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Msk = 0xc0000000
	// Position of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Pos = 0x1c
	// Bit mask of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Msk = 0x30000000
	// Position of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Pos = 0x1a
	// Bit mask of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Msk = 0xc000000
	// Position of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Pos = 0x18
	// Bit mask of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Msk = 0x3000000
	// Position of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Pos = 0x16
	// Bit mask of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Msk = 0xc00000
	// Position of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Pos = 0x14
	// Bit mask of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Msk = 0x300000
	// Position of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Pos = 0x12
	// Bit mask of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Msk = 0xc0000
	// Position of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Pos = 0x10
	// Bit mask of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Msk = 0x30000
	// Position of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Pos = 0xe
	// Bit mask of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Msk = 0xc000
	// Position of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Pos = 0xc
	// Bit mask of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Msk = 0x3000
	// Position of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Pos = 0xa
	// Bit mask of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Msk = 0xc00
	// Position of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Pos = 0x8
	// Bit mask of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Msk = 0x300
	// Position of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Pos = 0x6
	// Bit mask of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Msk = 0xc0
	// Position of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Pos = 0x4
	// Bit mask of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Msk = 0x30
	// Position of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Pos = 0x2
	// Bit mask of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Msk = 0xc
	// Position of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Pos = 0x0
	// Bit mask of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Msk = 0x3

	// PUPDR: GPIO port pull-up/pull-down register
	// Position of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Pos = 0x1e
	// Bit mask of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Msk = 0xc0000000
	// Position of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Pos = 0x1c
	// Bit mask of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Msk = 0x30000000
	// Position of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Pos = 0x1a
	// Bit mask of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Msk = 0xc000000
	// Position of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Pos = 0x18
	// Bit mask of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Msk = 0x3000000
	// Position of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Pos = 0x16
	// Bit mask of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Msk = 0xc00000
	// Position of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Pos = 0x14
	// Bit mask of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Msk = 0x300000
	// Position of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Pos = 0x12
	// Bit mask of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Msk = 0xc0000
	// Position of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Pos = 0x10
	// Bit mask of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Msk = 0x30000
	// Position of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Pos = 0xe
	// Bit mask of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Msk = 0xc000
	// Position of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Pos = 0xc
	// Bit mask of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Msk = 0x3000
	// Position of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Pos = 0xa
	// Bit mask of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Msk = 0xc00
	// Position of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Pos = 0x8
	// Bit mask of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Msk = 0x300
	// Position of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Pos = 0x6
	// Bit mask of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Msk = 0xc0
	// Position of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Pos = 0x4
	// Bit mask of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Msk = 0x30
	// Position of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Pos = 0x2
	// Bit mask of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Msk = 0xc
	// Position of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Pos = 0x0
	// Bit mask of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Msk = 0x3

	// IDR: GPIO port input data register
	// Position of IDR15 field.
	GPIO_IDR_IDR15_Pos = 0xf
	// Bit mask of IDR15 field.
	GPIO_IDR_IDR15_Msk = 0x8000
	// Bit IDR15.
	GPIO_IDR_IDR15 = 0x8000
	// Position of IDR14 field.
	GPIO_IDR_IDR14_Pos = 0xe
	// Bit mask of IDR14 field.
	GPIO_IDR_IDR14_Msk = 0x4000
	// Bit IDR14.
	GPIO_IDR_IDR14 = 0x4000
	// Position of IDR13 field.
	GPIO_IDR_IDR13_Pos = 0xd
	// Bit mask of IDR13 field.
	GPIO_IDR_IDR13_Msk = 0x2000
	// Bit IDR13.
	GPIO_IDR_IDR13 = 0x2000
	// Position of IDR12 field.
	GPIO_IDR_IDR12_Pos = 0xc
	// Bit mask of IDR12 field.
	GPIO_IDR_IDR12_Msk = 0x1000
	// Bit IDR12.
	GPIO_IDR_IDR12 = 0x1000
	// Position of IDR11 field.
	GPIO_IDR_IDR11_Pos = 0xb
	// Bit mask of IDR11 field.
	GPIO_IDR_IDR11_Msk = 0x800
	// Bit IDR11.
	GPIO_IDR_IDR11 = 0x800
	// Position of IDR10 field.
	GPIO_IDR_IDR10_Pos = 0xa
	// Bit mask of IDR10 field.
	GPIO_IDR_IDR10_Msk = 0x400
	// Bit IDR10.
	GPIO_IDR_IDR10 = 0x400
	// Position of IDR9 field.
	GPIO_IDR_IDR9_Pos = 0x9
	// Bit mask of IDR9 field.
	GPIO_IDR_IDR9_Msk = 0x200
	// Bit IDR9.
	GPIO_IDR_IDR9 = 0x200
	// Position of IDR8 field.
	GPIO_IDR_IDR8_Pos = 0x8
	// Bit mask of IDR8 field.
	GPIO_IDR_IDR8_Msk = 0x100
	// Bit IDR8.
	GPIO_IDR_IDR8 = 0x100
	// Position of IDR7 field.
	GPIO_IDR_IDR7_Pos = 0x7
	// Bit mask of IDR7 field.
	GPIO_IDR_IDR7_Msk = 0x80
	// Bit IDR7.
	GPIO_IDR_IDR7 = 0x80
	// Position of IDR6 field.
	GPIO_IDR_IDR6_Pos = 0x6
	// Bit mask of IDR6 field.
	GPIO_IDR_IDR6_Msk = 0x40
	// Bit IDR6.
	GPIO_IDR_IDR6 = 0x40
	// Position of IDR5 field.
	GPIO_IDR_IDR5_Pos = 0x5
	// Bit mask of IDR5 field.
	GPIO_IDR_IDR5_Msk = 0x20
	// Bit IDR5.
	GPIO_IDR_IDR5 = 0x20
	// Position of IDR4 field.
	GPIO_IDR_IDR4_Pos = 0x4
	// Bit mask of IDR4 field.
	GPIO_IDR_IDR4_Msk = 0x10
	// Bit IDR4.
	GPIO_IDR_IDR4 = 0x10
	// Position of IDR3 field.
	GPIO_IDR_IDR3_Pos = 0x3
	// Bit mask of IDR3 field.
	GPIO_IDR_IDR3_Msk = 0x8
	// Bit IDR3.
	GPIO_IDR_IDR3 = 0x8
	// Position of IDR2 field.
	GPIO_IDR_IDR2_Pos = 0x2
	// Bit mask of IDR2 field.
	GPIO_IDR_IDR2_Msk = 0x4
	// Bit IDR2.
	GPIO_IDR_IDR2 = 0x4
	// Position of IDR1 field.
	GPIO_IDR_IDR1_Pos = 0x1
	// Bit mask of IDR1 field.
	GPIO_IDR_IDR1_Msk = 0x2
	// Bit IDR1.
	GPIO_IDR_IDR1 = 0x2
	// Position of IDR0 field.
	GPIO_IDR_IDR0_Pos = 0x0
	// Bit mask of IDR0 field.
	GPIO_IDR_IDR0_Msk = 0x1
	// Bit IDR0.
	GPIO_IDR_IDR0 = 0x1

	// ODR: GPIO port output data register
	// Position of ODR15 field.
	GPIO_ODR_ODR15_Pos = 0xf
	// Bit mask of ODR15 field.
	GPIO_ODR_ODR15_Msk = 0x8000
	// Bit ODR15.
	GPIO_ODR_ODR15 = 0x8000
	// Position of ODR14 field.
	GPIO_ODR_ODR14_Pos = 0xe
	// Bit mask of ODR14 field.
	GPIO_ODR_ODR14_Msk = 0x4000
	// Bit ODR14.
	GPIO_ODR_ODR14 = 0x4000
	// Position of ODR13 field.
	GPIO_ODR_ODR13_Pos = 0xd
	// Bit mask of ODR13 field.
	GPIO_ODR_ODR13_Msk = 0x2000
	// Bit ODR13.
	GPIO_ODR_ODR13 = 0x2000
	// Position of ODR12 field.
	GPIO_ODR_ODR12_Pos = 0xc
	// Bit mask of ODR12 field.
	GPIO_ODR_ODR12_Msk = 0x1000
	// Bit ODR12.
	GPIO_ODR_ODR12 = 0x1000
	// Position of ODR11 field.
	GPIO_ODR_ODR11_Pos = 0xb
	// Bit mask of ODR11 field.
	GPIO_ODR_ODR11_Msk = 0x800
	// Bit ODR11.
	GPIO_ODR_ODR11 = 0x800
	// Position of ODR10 field.
	GPIO_ODR_ODR10_Pos = 0xa
	// Bit mask of ODR10 field.
	GPIO_ODR_ODR10_Msk = 0x400
	// Bit ODR10.
	GPIO_ODR_ODR10 = 0x400
	// Position of ODR9 field.
	GPIO_ODR_ODR9_Pos = 0x9
	// Bit mask of ODR9 field.
	GPIO_ODR_ODR9_Msk = 0x200
	// Bit ODR9.
	GPIO_ODR_ODR9 = 0x200
	// Position of ODR8 field.
	GPIO_ODR_ODR8_Pos = 0x8
	// Bit mask of ODR8 field.
	GPIO_ODR_ODR8_Msk = 0x100
	// Bit ODR8.
	GPIO_ODR_ODR8 = 0x100
	// Position of ODR7 field.
	GPIO_ODR_ODR7_Pos = 0x7
	// Bit mask of ODR7 field.
	GPIO_ODR_ODR7_Msk = 0x80
	// Bit ODR7.
	GPIO_ODR_ODR7 = 0x80
	// Position of ODR6 field.
	GPIO_ODR_ODR6_Pos = 0x6
	// Bit mask of ODR6 field.
	GPIO_ODR_ODR6_Msk = 0x40
	// Bit ODR6.
	GPIO_ODR_ODR6 = 0x40
	// Position of ODR5 field.
	GPIO_ODR_ODR5_Pos = 0x5
	// Bit mask of ODR5 field.
	GPIO_ODR_ODR5_Msk = 0x20
	// Bit ODR5.
	GPIO_ODR_ODR5 = 0x20
	// Position of ODR4 field.
	GPIO_ODR_ODR4_Pos = 0x4
	// Bit mask of ODR4 field.
	GPIO_ODR_ODR4_Msk = 0x10
	// Bit ODR4.
	GPIO_ODR_ODR4 = 0x10
	// Position of ODR3 field.
	GPIO_ODR_ODR3_Pos = 0x3
	// Bit mask of ODR3 field.
	GPIO_ODR_ODR3_Msk = 0x8
	// Bit ODR3.
	GPIO_ODR_ODR3 = 0x8
	// Position of ODR2 field.
	GPIO_ODR_ODR2_Pos = 0x2
	// Bit mask of ODR2 field.
	GPIO_ODR_ODR2_Msk = 0x4
	// Bit ODR2.
	GPIO_ODR_ODR2 = 0x4
	// Position of ODR1 field.
	GPIO_ODR_ODR1_Pos = 0x1
	// Bit mask of ODR1 field.
	GPIO_ODR_ODR1_Msk = 0x2
	// Bit ODR1.
	GPIO_ODR_ODR1 = 0x2
	// Position of ODR0 field.
	GPIO_ODR_ODR0_Pos = 0x0
	// Bit mask of ODR0 field.
	GPIO_ODR_ODR0_Msk = 0x1
	// Bit ODR0.
	GPIO_ODR_ODR0 = 0x1

	// BSRR: GPIO port bit set/reset register
	// Position of BR15 field.
	GPIO_BSRR_BR15_Pos = 0x1f
	// Bit mask of BR15 field.
	GPIO_BSRR_BR15_Msk = 0x80000000
	// Bit BR15.
	GPIO_BSRR_BR15 = 0x80000000
	// Position of BR14 field.
	GPIO_BSRR_BR14_Pos = 0x1e
	// Bit mask of BR14 field.
	GPIO_BSRR_BR14_Msk = 0x40000000
	// Bit BR14.
	GPIO_BSRR_BR14 = 0x40000000
	// Position of BR13 field.
	GPIO_BSRR_BR13_Pos = 0x1d
	// Bit mask of BR13 field.
	GPIO_BSRR_BR13_Msk = 0x20000000
	// Bit BR13.
	GPIO_BSRR_BR13 = 0x20000000
	// Position of BR12 field.
	GPIO_BSRR_BR12_Pos = 0x1c
	// Bit mask of BR12 field.
	GPIO_BSRR_BR12_Msk = 0x10000000
	// Bit BR12.
	GPIO_BSRR_BR12 = 0x10000000
	// Position of BR11 field.
	GPIO_BSRR_BR11_Pos = 0x1b
	// Bit mask of BR11 field.
	GPIO_BSRR_BR11_Msk = 0x8000000
	// Bit BR11.
	GPIO_BSRR_BR11 = 0x8000000
	// Position of BR10 field.
	GPIO_BSRR_BR10_Pos = 0x1a
	// Bit mask of BR10 field.
	GPIO_BSRR_BR10_Msk = 0x4000000
	// Bit BR10.
	GPIO_BSRR_BR10 = 0x4000000
	// Position of BR9 field.
	GPIO_BSRR_BR9_Pos = 0x19
	// Bit mask of BR9 field.
	GPIO_BSRR_BR9_Msk = 0x2000000
	// Bit BR9.
	GPIO_BSRR_BR9 = 0x2000000
	// Position of BR8 field.
	GPIO_BSRR_BR8_Pos = 0x18
	// Bit mask of BR8 field.
	GPIO_BSRR_BR8_Msk = 0x1000000
	// Bit BR8.
	GPIO_BSRR_BR8 = 0x1000000
	// Position of BR7 field.
	GPIO_BSRR_BR7_Pos = 0x17
	// Bit mask of BR7 field.
	GPIO_BSRR_BR7_Msk = 0x800000
	// Bit BR7.
	GPIO_BSRR_BR7 = 0x800000
	// Position of BR6 field.
	GPIO_BSRR_BR6_Pos = 0x16
	// Bit mask of BR6 field.
	GPIO_BSRR_BR6_Msk = 0x400000
	// Bit BR6.
	GPIO_BSRR_BR6 = 0x400000
	// Position of BR5 field.
	GPIO_BSRR_BR5_Pos = 0x15
	// Bit mask of BR5 field.
	GPIO_BSRR_BR5_Msk = 0x200000
	// Bit BR5.
	GPIO_BSRR_BR5 = 0x200000
	// Position of BR4 field.
	GPIO_BSRR_BR4_Pos = 0x14
	// Bit mask of BR4 field.
	GPIO_BSRR_BR4_Msk = 0x100000
	// Bit BR4.
	GPIO_BSRR_BR4 = 0x100000
	// Position of BR3 field.
	GPIO_BSRR_BR3_Pos = 0x13
	// Bit mask of BR3 field.
	GPIO_BSRR_BR3_Msk = 0x80000
	// Bit BR3.
	GPIO_BSRR_BR3 = 0x80000
	// Position of BR2 field.
	GPIO_BSRR_BR2_Pos = 0x12
	// Bit mask of BR2 field.
	GPIO_BSRR_BR2_Msk = 0x40000
	// Bit BR2.
	GPIO_BSRR_BR2 = 0x40000
	// Position of BR1 field.
	GPIO_BSRR_BR1_Pos = 0x11
	// Bit mask of BR1 field.
	GPIO_BSRR_BR1_Msk = 0x20000
	// Bit BR1.
	GPIO_BSRR_BR1 = 0x20000
	// Position of BR0 field.
	GPIO_BSRR_BR0_Pos = 0x10
	// Bit mask of BR0 field.
	GPIO_BSRR_BR0_Msk = 0x10000
	// Bit BR0.
	GPIO_BSRR_BR0 = 0x10000
	// Position of BS15 field.
	GPIO_BSRR_BS15_Pos = 0xf
	// Bit mask of BS15 field.
	GPIO_BSRR_BS15_Msk = 0x8000
	// Bit BS15.
	GPIO_BSRR_BS15 = 0x8000
	// Position of BS14 field.
	GPIO_BSRR_BS14_Pos = 0xe
	// Bit mask of BS14 field.
	GPIO_BSRR_BS14_Msk = 0x4000
	// Bit BS14.
	GPIO_BSRR_BS14 = 0x4000
	// Position of BS13 field.
	GPIO_BSRR_BS13_Pos = 0xd
	// Bit mask of BS13 field.
	GPIO_BSRR_BS13_Msk = 0x2000
	// Bit BS13.
	GPIO_BSRR_BS13 = 0x2000
	// Position of BS12 field.
	GPIO_BSRR_BS12_Pos = 0xc
	// Bit mask of BS12 field.
	GPIO_BSRR_BS12_Msk = 0x1000
	// Bit BS12.
	GPIO_BSRR_BS12 = 0x1000
	// Position of BS11 field.
	GPIO_BSRR_BS11_Pos = 0xb
	// Bit mask of BS11 field.
	GPIO_BSRR_BS11_Msk = 0x800
	// Bit BS11.
	GPIO_BSRR_BS11 = 0x800
	// Position of BS10 field.
	GPIO_BSRR_BS10_Pos = 0xa
	// Bit mask of BS10 field.
	GPIO_BSRR_BS10_Msk = 0x400
	// Bit BS10.
	GPIO_BSRR_BS10 = 0x400
	// Position of BS9 field.
	GPIO_BSRR_BS9_Pos = 0x9
	// Bit mask of BS9 field.
	GPIO_BSRR_BS9_Msk = 0x200
	// Bit BS9.
	GPIO_BSRR_BS9 = 0x200
	// Position of BS8 field.
	GPIO_BSRR_BS8_Pos = 0x8
	// Bit mask of BS8 field.
	GPIO_BSRR_BS8_Msk = 0x100
	// Bit BS8.
	GPIO_BSRR_BS8 = 0x100
	// Position of BS7 field.
	GPIO_BSRR_BS7_Pos = 0x7
	// Bit mask of BS7 field.
	GPIO_BSRR_BS7_Msk = 0x80
	// Bit BS7.
	GPIO_BSRR_BS7 = 0x80
	// Position of BS6 field.
	GPIO_BSRR_BS6_Pos = 0x6
	// Bit mask of BS6 field.
	GPIO_BSRR_BS6_Msk = 0x40
	// Bit BS6.
	GPIO_BSRR_BS6 = 0x40
	// Position of BS5 field.
	GPIO_BSRR_BS5_Pos = 0x5
	// Bit mask of BS5 field.
	GPIO_BSRR_BS5_Msk = 0x20
	// Bit BS5.
	GPIO_BSRR_BS5 = 0x20
	// Position of BS4 field.
	GPIO_BSRR_BS4_Pos = 0x4
	// Bit mask of BS4 field.
	GPIO_BSRR_BS4_Msk = 0x10
	// Bit BS4.
	GPIO_BSRR_BS4 = 0x10
	// Position of BS3 field.
	GPIO_BSRR_BS3_Pos = 0x3
	// Bit mask of BS3 field.
	GPIO_BSRR_BS3_Msk = 0x8
	// Bit BS3.
	GPIO_BSRR_BS3 = 0x8
	// Position of BS2 field.
	GPIO_BSRR_BS2_Pos = 0x2
	// Bit mask of BS2 field.
	GPIO_BSRR_BS2_Msk = 0x4
	// Bit BS2.
	GPIO_BSRR_BS2 = 0x4
	// Position of BS1 field.
	GPIO_BSRR_BS1_Pos = 0x1
	// Bit mask of BS1 field.
	GPIO_BSRR_BS1_Msk = 0x2
	// Bit BS1.
	GPIO_BSRR_BS1 = 0x2
	// Position of BS0 field.
	GPIO_BSRR_BS0_Pos = 0x0
	// Bit mask of BS0 field.
	GPIO_BSRR_BS0_Msk = 0x1
	// Bit BS0.
	GPIO_BSRR_BS0 = 0x1

	// LCKR: GPIO port configuration lock register
	// Position of LCKK field.
	GPIO_LCKR_LCKK_Pos = 0x10
	// Bit mask of LCKK field.
	GPIO_LCKR_LCKK_Msk = 0x10000
	// Bit LCKK.
	GPIO_LCKR_LCKK = 0x10000
	// Position of LCK15 field.
	GPIO_LCKR_LCK15_Pos = 0xf
	// Bit mask of LCK15 field.
	GPIO_LCKR_LCK15_Msk = 0x8000
	// Bit LCK15.
	GPIO_LCKR_LCK15 = 0x8000
	// Position of LCK14 field.
	GPIO_LCKR_LCK14_Pos = 0xe
	// Bit mask of LCK14 field.
	GPIO_LCKR_LCK14_Msk = 0x4000
	// Bit LCK14.
	GPIO_LCKR_LCK14 = 0x4000
	// Position of LCK13 field.
	GPIO_LCKR_LCK13_Pos = 0xd
	// Bit mask of LCK13 field.
	GPIO_LCKR_LCK13_Msk = 0x2000
	// Bit LCK13.
	GPIO_LCKR_LCK13 = 0x2000
	// Position of LCK12 field.
	GPIO_LCKR_LCK12_Pos = 0xc
	// Bit mask of LCK12 field.
	GPIO_LCKR_LCK12_Msk = 0x1000
	// Bit LCK12.
	GPIO_LCKR_LCK12 = 0x1000
	// Position of LCK11 field.
	GPIO_LCKR_LCK11_Pos = 0xb
	// Bit mask of LCK11 field.
	GPIO_LCKR_LCK11_Msk = 0x800
	// Bit LCK11.
	GPIO_LCKR_LCK11 = 0x800
	// Position of LCK10 field.
	GPIO_LCKR_LCK10_Pos = 0xa
	// Bit mask of LCK10 field.
	GPIO_LCKR_LCK10_Msk = 0x400
	// Bit LCK10.
	GPIO_LCKR_LCK10 = 0x400
	// Position of LCK9 field.
	GPIO_LCKR_LCK9_Pos = 0x9
	// Bit mask of LCK9 field.
	GPIO_LCKR_LCK9_Msk = 0x200
	// Bit LCK9.
	GPIO_LCKR_LCK9 = 0x200
	// Position of LCK8 field.
	GPIO_LCKR_LCK8_Pos = 0x8
	// Bit mask of LCK8 field.
	GPIO_LCKR_LCK8_Msk = 0x100
	// Bit LCK8.
	GPIO_LCKR_LCK8 = 0x100
	// Position of LCK7 field.
	GPIO_LCKR_LCK7_Pos = 0x7
	// Bit mask of LCK7 field.
	GPIO_LCKR_LCK7_Msk = 0x80
	// Bit LCK7.
	GPIO_LCKR_LCK7 = 0x80
	// Position of LCK6 field.
	GPIO_LCKR_LCK6_Pos = 0x6
	// Bit mask of LCK6 field.
	GPIO_LCKR_LCK6_Msk = 0x40
	// Bit LCK6.
	GPIO_LCKR_LCK6 = 0x40
	// Position of LCK5 field.
	GPIO_LCKR_LCK5_Pos = 0x5
	// Bit mask of LCK5 field.
	GPIO_LCKR_LCK5_Msk = 0x20
	// Bit LCK5.
	GPIO_LCKR_LCK5 = 0x20
	// Position of LCK4 field.
	GPIO_LCKR_LCK4_Pos = 0x4
	// Bit mask of LCK4 field.
	GPIO_LCKR_LCK4_Msk = 0x10
	// Bit LCK4.
	GPIO_LCKR_LCK4 = 0x10
	// Position of LCK3 field.
	GPIO_LCKR_LCK3_Pos = 0x3
	// Bit mask of LCK3 field.
	GPIO_LCKR_LCK3_Msk = 0x8
	// Bit LCK3.
	GPIO_LCKR_LCK3 = 0x8
	// Position of LCK2 field.
	GPIO_LCKR_LCK2_Pos = 0x2
	// Bit mask of LCK2 field.
	GPIO_LCKR_LCK2_Msk = 0x4
	// Bit LCK2.
	GPIO_LCKR_LCK2 = 0x4
	// Position of LCK1 field.
	GPIO_LCKR_LCK1_Pos = 0x1
	// Bit mask of LCK1 field.
	GPIO_LCKR_LCK1_Msk = 0x2
	// Bit LCK1.
	GPIO_LCKR_LCK1 = 0x2
	// Position of LCK0 field.
	GPIO_LCKR_LCK0_Pos = 0x0
	// Bit mask of LCK0 field.
	GPIO_LCKR_LCK0_Msk = 0x1
	// Bit LCK0.
	GPIO_LCKR_LCK0 = 0x1

	// AFRL: GPIO alternate function low register
	// Position of AFSEL7 field.
	GPIO_AFRL_AFSEL7_Pos = 0x1c
	// Bit mask of AFSEL7 field.
	GPIO_AFRL_AFSEL7_Msk = 0xf0000000
	// Position of AFSEL6 field.
	GPIO_AFRL_AFSEL6_Pos = 0x18
	// Bit mask of AFSEL6 field.
	GPIO_AFRL_AFSEL6_Msk = 0xf000000
	// Position of AFSEL5 field.
	GPIO_AFRL_AFSEL5_Pos = 0x14
	// Bit mask of AFSEL5 field.
	GPIO_AFRL_AFSEL5_Msk = 0xf00000
	// Position of AFSEL4 field.
	GPIO_AFRL_AFSEL4_Pos = 0x10
	// Bit mask of AFSEL4 field.
	GPIO_AFRL_AFSEL4_Msk = 0xf0000
	// Position of AFSEL3 field.
	GPIO_AFRL_AFSEL3_Pos = 0xc
	// Bit mask of AFSEL3 field.
	GPIO_AFRL_AFSEL3_Msk = 0xf000
	// Position of AFSEL2 field.
	GPIO_AFRL_AFSEL2_Pos = 0x8
	// Bit mask of AFSEL2 field.
	GPIO_AFRL_AFSEL2_Msk = 0xf00
	// Position of AFSEL1 field.
	GPIO_AFRL_AFSEL1_Pos = 0x4
	// Bit mask of AFSEL1 field.
	GPIO_AFRL_AFSEL1_Msk = 0xf0
	// Position of AFSEL0 field.
	GPIO_AFRL_AFSEL0_Pos = 0x0
	// Bit mask of AFSEL0 field.
	GPIO_AFRL_AFSEL0_Msk = 0xf

	// AFRH: GPIO alternate function high register
	// Position of AFSEL15 field.
	GPIO_AFRH_AFSEL15_Pos = 0x1c
	// Bit mask of AFSEL15 field.
	GPIO_AFRH_AFSEL15_Msk = 0xf0000000
	// Position of AFSEL14 field.
	GPIO_AFRH_AFSEL14_Pos = 0x18
	// Bit mask of AFSEL14 field.
	GPIO_AFRH_AFSEL14_Msk = 0xf000000
	// Position of AFSEL13 field.
	GPIO_AFRH_AFSEL13_Pos = 0x14
	// Bit mask of AFSEL13 field.
	GPIO_AFRH_AFSEL13_Msk = 0xf00000
	// Position of AFSEL12 field.
	GPIO_AFRH_AFSEL12_Pos = 0x10
	// Bit mask of AFSEL12 field.
	GPIO_AFRH_AFSEL12_Msk = 0xf0000
	// Position of AFSEL11 field.
	GPIO_AFRH_AFSEL11_Pos = 0xc
	// Bit mask of AFSEL11 field.
	GPIO_AFRH_AFSEL11_Msk = 0xf000
	// Position of AFSEL10 field.
	GPIO_AFRH_AFSEL10_Pos = 0x8
	// Bit mask of AFSEL10 field.
	GPIO_AFRH_AFSEL10_Msk = 0xf00
	// Position of AFSEL9 field.
	GPIO_AFRH_AFSEL9_Pos = 0x4
	// Bit mask of AFSEL9 field.
	GPIO_AFRH_AFSEL9_Msk = 0xf0
	// Position of AFSEL8 field.
	GPIO_AFRH_AFSEL8_Pos = 0x0
	// Bit mask of AFSEL8 field.
	GPIO_AFRH_AFSEL8_Msk = 0xf

	// BRR: port bit reset register
	// Position of BR0 field.
	GPIO_BRR_BR0_Pos = 0x0
	// Bit mask of BR0 field.
	GPIO_BRR_BR0_Msk = 0x1
	// Bit BR0.
	GPIO_BRR_BR0 = 0x1
	// Position of BR1 field.
	GPIO_BRR_BR1_Pos = 0x1
	// Bit mask of BR1 field.
	GPIO_BRR_BR1_Msk = 0x2
	// Bit BR1.
	GPIO_BRR_BR1 = 0x2
	// Position of BR2 field.
	GPIO_BRR_BR2_Pos = 0x2
	// Bit mask of BR2 field.
	GPIO_BRR_BR2_Msk = 0x4
	// Bit BR2.
	GPIO_BRR_BR2 = 0x4
	// Position of BR3 field.
	GPIO_BRR_BR3_Pos = 0x3
	// Bit mask of BR3 field.
	GPIO_BRR_BR3_Msk = 0x8
	// Bit BR3.
	GPIO_BRR_BR3 = 0x8
	// Position of BR4 field.
	GPIO_BRR_BR4_Pos = 0x4
	// Bit mask of BR4 field.
	GPIO_BRR_BR4_Msk = 0x10
	// Bit BR4.
	GPIO_BRR_BR4 = 0x10
	// Position of BR5 field.
	GPIO_BRR_BR5_Pos = 0x5
	// Bit mask of BR5 field.
	GPIO_BRR_BR5_Msk = 0x20
	// Bit BR5.
	GPIO_BRR_BR5 = 0x20
	// Position of BR6 field.
	GPIO_BRR_BR6_Pos = 0x6
	// Bit mask of BR6 field.
	GPIO_BRR_BR6_Msk = 0x40
	// Bit BR6.
	GPIO_BRR_BR6 = 0x40
	// Position of BR7 field.
	GPIO_BRR_BR7_Pos = 0x7
	// Bit mask of BR7 field.
	GPIO_BRR_BR7_Msk = 0x80
	// Bit BR7.
	GPIO_BRR_BR7 = 0x80
	// Position of BR8 field.
	GPIO_BRR_BR8_Pos = 0x8
	// Bit mask of BR8 field.
	GPIO_BRR_BR8_Msk = 0x100
	// Bit BR8.
	GPIO_BRR_BR8 = 0x100
	// Position of BR9 field.
	GPIO_BRR_BR9_Pos = 0x9
	// Bit mask of BR9 field.
	GPIO_BRR_BR9_Msk = 0x200
	// Bit BR9.
	GPIO_BRR_BR9 = 0x200
	// Position of BR10 field.
	GPIO_BRR_BR10_Pos = 0xa
	// Bit mask of BR10 field.
	GPIO_BRR_BR10_Msk = 0x400
	// Bit BR10.
	GPIO_BRR_BR10 = 0x400
	// Position of BR11 field.
	GPIO_BRR_BR11_Pos = 0xb
	// Bit mask of BR11 field.
	GPIO_BRR_BR11_Msk = 0x800
	// Bit BR11.
	GPIO_BRR_BR11 = 0x800
	// Position of BR12 field.
	GPIO_BRR_BR12_Pos = 0xc
	// Bit mask of BR12 field.
	GPIO_BRR_BR12_Msk = 0x1000
	// Bit BR12.
	GPIO_BRR_BR12 = 0x1000
	// Position of BR13 field.
	GPIO_BRR_BR13_Pos = 0xd
	// Bit mask of BR13 field.
	GPIO_BRR_BR13_Msk = 0x2000
	// Bit BR13.
	GPIO_BRR_BR13 = 0x2000
	// Position of BR14 field.
	GPIO_BRR_BR14_Pos = 0xe
	// Bit mask of BR14 field.
	GPIO_BRR_BR14_Msk = 0x4000
	// Bit BR14.
	GPIO_BRR_BR14 = 0x4000
	// Position of BR15 field.
	GPIO_BRR_BR15_Pos = 0xf
	// Bit mask of BR15 field.
	GPIO_BRR_BR15_Msk = 0x8000
	// Bit BR15.
	GPIO_BRR_BR15 = 0x8000
)

// Constants for CRC: Cyclic redundancy check calculation unit
const (
	// DR: Data register
	// Position of DR field.
	CRC_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	CRC_DR_DR_Msk = 0xffffffff

	// IDR: Independent data register
	// Position of IDR field.
	CRC_IDR_IDR_Pos = 0x0
	// Bit mask of IDR field.
	CRC_IDR_IDR_Msk = 0xffffffff

	// CR: Control register
	// Position of REV_OUT field.
	CRC_CR_REV_OUT_Pos = 0x7
	// Bit mask of REV_OUT field.
	CRC_CR_REV_OUT_Msk = 0x80
	// Bit REV_OUT.
	CRC_CR_REV_OUT = 0x80
	// Position of REV_IN field.
	CRC_CR_REV_IN_Pos = 0x5
	// Bit mask of REV_IN field.
	CRC_CR_REV_IN_Msk = 0x60
	// Position of POLYSIZE field.
	CRC_CR_POLYSIZE_Pos = 0x3
	// Bit mask of POLYSIZE field.
	CRC_CR_POLYSIZE_Msk = 0x18
	// Position of RESET field.
	CRC_CR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	CRC_CR_RESET_Msk = 0x1
	// Bit RESET.
	CRC_CR_RESET = 0x1

	// INIT: Initial CRC value
	// Position of CRC_INIT field.
	CRC_INIT_CRC_INIT_Pos = 0x0
	// Bit mask of CRC_INIT field.
	CRC_INIT_CRC_INIT_Msk = 0xffffffff

	// POL: polynomial
	// Position of POL field.
	CRC_POL_POL_Pos = 0x0
	// Bit mask of POL field.
	CRC_POL_POL_Msk = 0xffffffff
)

// Constants for EXTI: External interrupt/event controller
const (
	// RTSR1: EXTI rising trigger selection register
	// Position of TR0 field.
	EXTI_RTSR1_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_RTSR1_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_RTSR1_TR0 = 0x1
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR0_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_RTSR1_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_RTSR1_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_RTSR1_TR1 = 0x2
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR1_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_RTSR1_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_RTSR1_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_RTSR1_TR2 = 0x4
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR2_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_RTSR1_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_RTSR1_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_RTSR1_TR3 = 0x8
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR3_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_RTSR1_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_RTSR1_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_RTSR1_TR4 = 0x10
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR4_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_RTSR1_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_RTSR1_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_RTSR1_TR5 = 0x20
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR5_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_RTSR1_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_RTSR1_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_RTSR1_TR6 = 0x40
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR6_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_RTSR1_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_RTSR1_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_RTSR1_TR7 = 0x80
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR7_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_RTSR1_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_RTSR1_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_RTSR1_TR8 = 0x100
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR8_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_RTSR1_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_RTSR1_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_RTSR1_TR9 = 0x200
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR9_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_RTSR1_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_RTSR1_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_RTSR1_TR10 = 0x400
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR10_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_RTSR1_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_RTSR1_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_RTSR1_TR11 = 0x800
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR11_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_RTSR1_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_RTSR1_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_RTSR1_TR12 = 0x1000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR12_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_RTSR1_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_RTSR1_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_RTSR1_TR13 = 0x2000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR13_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_RTSR1_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_RTSR1_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_RTSR1_TR14 = 0x4000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR14_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_RTSR1_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_RTSR1_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_RTSR1_TR15 = 0x8000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR15_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_RTSR1_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_RTSR1_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_RTSR1_TR16 = 0x10000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR16_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR16_Enabled = 0x1
	// Position of TR17 field.
	EXTI_RTSR1_TR17_Pos = 0x11
	// Bit mask of TR17 field.
	EXTI_RTSR1_TR17_Msk = 0x20000
	// Bit TR17.
	EXTI_RTSR1_TR17 = 0x20000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR17_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR17_Enabled = 0x1
	// Position of TR18 field.
	EXTI_RTSR1_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_RTSR1_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_RTSR1_TR18 = 0x40000
	// Rising edge trigger is disabled
	EXTI_RTSR1_TR18_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR1_TR18_Enabled = 0x1

	// FTSR1: EXTI falling trigger selection register
	// Position of TR0 field.
	EXTI_FTSR1_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_FTSR1_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_FTSR1_TR0 = 0x1
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR0_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_FTSR1_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_FTSR1_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_FTSR1_TR1 = 0x2
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR1_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_FTSR1_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_FTSR1_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_FTSR1_TR2 = 0x4
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR2_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_FTSR1_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_FTSR1_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_FTSR1_TR3 = 0x8
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR3_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_FTSR1_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_FTSR1_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_FTSR1_TR4 = 0x10
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR4_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_FTSR1_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_FTSR1_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_FTSR1_TR5 = 0x20
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR5_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_FTSR1_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_FTSR1_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_FTSR1_TR6 = 0x40
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR6_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_FTSR1_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_FTSR1_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_FTSR1_TR7 = 0x80
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR7_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_FTSR1_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_FTSR1_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_FTSR1_TR8 = 0x100
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR8_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_FTSR1_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_FTSR1_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_FTSR1_TR9 = 0x200
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR9_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_FTSR1_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_FTSR1_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_FTSR1_TR10 = 0x400
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR10_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_FTSR1_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_FTSR1_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_FTSR1_TR11 = 0x800
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR11_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_FTSR1_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_FTSR1_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_FTSR1_TR12 = 0x1000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR12_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_FTSR1_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_FTSR1_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_FTSR1_TR13 = 0x2000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR13_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_FTSR1_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_FTSR1_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_FTSR1_TR14 = 0x4000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR14_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_FTSR1_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_FTSR1_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_FTSR1_TR15 = 0x8000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR15_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_FTSR1_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_FTSR1_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_FTSR1_TR16 = 0x10000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR16_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR16_Enabled = 0x1
	// Position of TR17 field.
	EXTI_FTSR1_TR17_Pos = 0x11
	// Bit mask of TR17 field.
	EXTI_FTSR1_TR17_Msk = 0x20000
	// Bit TR17.
	EXTI_FTSR1_TR17 = 0x20000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR17_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR17_Enabled = 0x1
	// Position of TR18 field.
	EXTI_FTSR1_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_FTSR1_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_FTSR1_TR18 = 0x40000
	// Falling edge trigger is disabled
	EXTI_FTSR1_TR18_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR1_TR18_Enabled = 0x1

	// SWIER1: EXTI software interrupt event register
	// Position of SWIER0 field.
	EXTI_SWIER1_SWIER0_Pos = 0x0
	// Bit mask of SWIER0 field.
	EXTI_SWIER1_SWIER0_Msk = 0x1
	// Bit SWIER0.
	EXTI_SWIER1_SWIER0 = 0x1
	// Generates an interrupt request
	EXTI_SWIER1_SWIER0_Pend = 0x1
	// Position of SWIER1 field.
	EXTI_SWIER1_SWIER1_Pos = 0x1
	// Bit mask of SWIER1 field.
	EXTI_SWIER1_SWIER1_Msk = 0x2
	// Bit SWIER1.
	EXTI_SWIER1_SWIER1 = 0x2
	// Generates an interrupt request
	EXTI_SWIER1_SWIER1_Pend = 0x1
	// Position of SWIER2 field.
	EXTI_SWIER1_SWIER2_Pos = 0x2
	// Bit mask of SWIER2 field.
	EXTI_SWIER1_SWIER2_Msk = 0x4
	// Bit SWIER2.
	EXTI_SWIER1_SWIER2 = 0x4
	// Generates an interrupt request
	EXTI_SWIER1_SWIER2_Pend = 0x1
	// Position of SWIER3 field.
	EXTI_SWIER1_SWIER3_Pos = 0x3
	// Bit mask of SWIER3 field.
	EXTI_SWIER1_SWIER3_Msk = 0x8
	// Bit SWIER3.
	EXTI_SWIER1_SWIER3 = 0x8
	// Generates an interrupt request
	EXTI_SWIER1_SWIER3_Pend = 0x1
	// Position of SWIER4 field.
	EXTI_SWIER1_SWIER4_Pos = 0x4
	// Bit mask of SWIER4 field.
	EXTI_SWIER1_SWIER4_Msk = 0x10
	// Bit SWIER4.
	EXTI_SWIER1_SWIER4 = 0x10
	// Generates an interrupt request
	EXTI_SWIER1_SWIER4_Pend = 0x1
	// Position of SWIER5 field.
	EXTI_SWIER1_SWIER5_Pos = 0x5
	// Bit mask of SWIER5 field.
	EXTI_SWIER1_SWIER5_Msk = 0x20
	// Bit SWIER5.
	EXTI_SWIER1_SWIER5 = 0x20
	// Generates an interrupt request
	EXTI_SWIER1_SWIER5_Pend = 0x1
	// Position of SWIER6 field.
	EXTI_SWIER1_SWIER6_Pos = 0x6
	// Bit mask of SWIER6 field.
	EXTI_SWIER1_SWIER6_Msk = 0x40
	// Bit SWIER6.
	EXTI_SWIER1_SWIER6 = 0x40
	// Generates an interrupt request
	EXTI_SWIER1_SWIER6_Pend = 0x1
	// Position of SWIER7 field.
	EXTI_SWIER1_SWIER7_Pos = 0x7
	// Bit mask of SWIER7 field.
	EXTI_SWIER1_SWIER7_Msk = 0x80
	// Bit SWIER7.
	EXTI_SWIER1_SWIER7 = 0x80
	// Generates an interrupt request
	EXTI_SWIER1_SWIER7_Pend = 0x1
	// Position of SWIER8 field.
	EXTI_SWIER1_SWIER8_Pos = 0x8
	// Bit mask of SWIER8 field.
	EXTI_SWIER1_SWIER8_Msk = 0x100
	// Bit SWIER8.
	EXTI_SWIER1_SWIER8 = 0x100
	// Generates an interrupt request
	EXTI_SWIER1_SWIER8_Pend = 0x1
	// Position of SWIER9 field.
	EXTI_SWIER1_SWIER9_Pos = 0x9
	// Bit mask of SWIER9 field.
	EXTI_SWIER1_SWIER9_Msk = 0x200
	// Bit SWIER9.
	EXTI_SWIER1_SWIER9 = 0x200
	// Generates an interrupt request
	EXTI_SWIER1_SWIER9_Pend = 0x1
	// Position of SWIER10 field.
	EXTI_SWIER1_SWIER10_Pos = 0xa
	// Bit mask of SWIER10 field.
	EXTI_SWIER1_SWIER10_Msk = 0x400
	// Bit SWIER10.
	EXTI_SWIER1_SWIER10 = 0x400
	// Generates an interrupt request
	EXTI_SWIER1_SWIER10_Pend = 0x1
	// Position of SWIER11 field.
	EXTI_SWIER1_SWIER11_Pos = 0xb
	// Bit mask of SWIER11 field.
	EXTI_SWIER1_SWIER11_Msk = 0x800
	// Bit SWIER11.
	EXTI_SWIER1_SWIER11 = 0x800
	// Generates an interrupt request
	EXTI_SWIER1_SWIER11_Pend = 0x1
	// Position of SWIER12 field.
	EXTI_SWIER1_SWIER12_Pos = 0xc
	// Bit mask of SWIER12 field.
	EXTI_SWIER1_SWIER12_Msk = 0x1000
	// Bit SWIER12.
	EXTI_SWIER1_SWIER12 = 0x1000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER12_Pend = 0x1
	// Position of SWIER13 field.
	EXTI_SWIER1_SWIER13_Pos = 0xd
	// Bit mask of SWIER13 field.
	EXTI_SWIER1_SWIER13_Msk = 0x2000
	// Bit SWIER13.
	EXTI_SWIER1_SWIER13 = 0x2000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER13_Pend = 0x1
	// Position of SWIER14 field.
	EXTI_SWIER1_SWIER14_Pos = 0xe
	// Bit mask of SWIER14 field.
	EXTI_SWIER1_SWIER14_Msk = 0x4000
	// Bit SWIER14.
	EXTI_SWIER1_SWIER14 = 0x4000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER14_Pend = 0x1
	// Position of SWIER15 field.
	EXTI_SWIER1_SWIER15_Pos = 0xf
	// Bit mask of SWIER15 field.
	EXTI_SWIER1_SWIER15_Msk = 0x8000
	// Bit SWIER15.
	EXTI_SWIER1_SWIER15 = 0x8000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER15_Pend = 0x1
	// Position of SWIER16 field.
	EXTI_SWIER1_SWIER16_Pos = 0x10
	// Bit mask of SWIER16 field.
	EXTI_SWIER1_SWIER16_Msk = 0x10000
	// Bit SWIER16.
	EXTI_SWIER1_SWIER16 = 0x10000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER16_Pend = 0x1
	// Position of SWIER17 field.
	EXTI_SWIER1_SWIER17_Pos = 0x11
	// Bit mask of SWIER17 field.
	EXTI_SWIER1_SWIER17_Msk = 0x20000
	// Bit SWIER17.
	EXTI_SWIER1_SWIER17 = 0x20000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER17_Pend = 0x1
	// Position of SWIER18 field.
	EXTI_SWIER1_SWIER18_Pos = 0x12
	// Bit mask of SWIER18 field.
	EXTI_SWIER1_SWIER18_Msk = 0x40000
	// Bit SWIER18.
	EXTI_SWIER1_SWIER18 = 0x40000
	// Generates an interrupt request
	EXTI_SWIER1_SWIER18_Pend = 0x1

	// RPR1: EXTI rising edge pending register
	// Position of RPIF0 field.
	EXTI_RPR1_RPIF0_Pos = 0x0
	// Bit mask of RPIF0 field.
	EXTI_RPR1_RPIF0_Msk = 0x1
	// Bit RPIF0.
	EXTI_RPR1_RPIF0 = 0x1
	// No trigger request occurred
	EXTI_RPR1_RPIF0_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF0_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF0_Clear = 0x1
	// Position of RPIF1 field.
	EXTI_RPR1_RPIF1_Pos = 0x1
	// Bit mask of RPIF1 field.
	EXTI_RPR1_RPIF1_Msk = 0x2
	// Bit RPIF1.
	EXTI_RPR1_RPIF1 = 0x2
	// No trigger request occurred
	EXTI_RPR1_RPIF1_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF1_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF1_Clear = 0x1
	// Position of RPIF2 field.
	EXTI_RPR1_RPIF2_Pos = 0x2
	// Bit mask of RPIF2 field.
	EXTI_RPR1_RPIF2_Msk = 0x4
	// Bit RPIF2.
	EXTI_RPR1_RPIF2 = 0x4
	// No trigger request occurred
	EXTI_RPR1_RPIF2_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF2_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF2_Clear = 0x1
	// Position of RPIF3 field.
	EXTI_RPR1_RPIF3_Pos = 0x3
	// Bit mask of RPIF3 field.
	EXTI_RPR1_RPIF3_Msk = 0x8
	// Bit RPIF3.
	EXTI_RPR1_RPIF3 = 0x8
	// No trigger request occurred
	EXTI_RPR1_RPIF3_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF3_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF3_Clear = 0x1
	// Position of RPIF4 field.
	EXTI_RPR1_RPIF4_Pos = 0x4
	// Bit mask of RPIF4 field.
	EXTI_RPR1_RPIF4_Msk = 0x10
	// Bit RPIF4.
	EXTI_RPR1_RPIF4 = 0x10
	// No trigger request occurred
	EXTI_RPR1_RPIF4_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF4_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF4_Clear = 0x1
	// Position of RPIF5 field.
	EXTI_RPR1_RPIF5_Pos = 0x5
	// Bit mask of RPIF5 field.
	EXTI_RPR1_RPIF5_Msk = 0x20
	// Bit RPIF5.
	EXTI_RPR1_RPIF5 = 0x20
	// No trigger request occurred
	EXTI_RPR1_RPIF5_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF5_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF5_Clear = 0x1
	// Position of RPIF6 field.
	EXTI_RPR1_RPIF6_Pos = 0x6
	// Bit mask of RPIF6 field.
	EXTI_RPR1_RPIF6_Msk = 0x40
	// Bit RPIF6.
	EXTI_RPR1_RPIF6 = 0x40
	// No trigger request occurred
	EXTI_RPR1_RPIF6_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF6_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF6_Clear = 0x1
	// Position of RPIF7 field.
	EXTI_RPR1_RPIF7_Pos = 0x7
	// Bit mask of RPIF7 field.
	EXTI_RPR1_RPIF7_Msk = 0x80
	// Bit RPIF7.
	EXTI_RPR1_RPIF7 = 0x80
	// No trigger request occurred
	EXTI_RPR1_RPIF7_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF7_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF7_Clear = 0x1
	// Position of RPIF8 field.
	EXTI_RPR1_RPIF8_Pos = 0x8
	// Bit mask of RPIF8 field.
	EXTI_RPR1_RPIF8_Msk = 0x100
	// Bit RPIF8.
	EXTI_RPR1_RPIF8 = 0x100
	// No trigger request occurred
	EXTI_RPR1_RPIF8_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF8_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF8_Clear = 0x1
	// Position of RPIF9 field.
	EXTI_RPR1_RPIF9_Pos = 0x9
	// Bit mask of RPIF9 field.
	EXTI_RPR1_RPIF9_Msk = 0x200
	// Bit RPIF9.
	EXTI_RPR1_RPIF9 = 0x200
	// No trigger request occurred
	EXTI_RPR1_RPIF9_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF9_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF9_Clear = 0x1
	// Position of RPIF10 field.
	EXTI_RPR1_RPIF10_Pos = 0xa
	// Bit mask of RPIF10 field.
	EXTI_RPR1_RPIF10_Msk = 0x400
	// Bit RPIF10.
	EXTI_RPR1_RPIF10 = 0x400
	// No trigger request occurred
	EXTI_RPR1_RPIF10_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF10_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF10_Clear = 0x1
	// Position of RPIF11 field.
	EXTI_RPR1_RPIF11_Pos = 0xb
	// Bit mask of RPIF11 field.
	EXTI_RPR1_RPIF11_Msk = 0x800
	// Bit RPIF11.
	EXTI_RPR1_RPIF11 = 0x800
	// No trigger request occurred
	EXTI_RPR1_RPIF11_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF11_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF11_Clear = 0x1
	// Position of RPIF12 field.
	EXTI_RPR1_RPIF12_Pos = 0xc
	// Bit mask of RPIF12 field.
	EXTI_RPR1_RPIF12_Msk = 0x1000
	// Bit RPIF12.
	EXTI_RPR1_RPIF12 = 0x1000
	// No trigger request occurred
	EXTI_RPR1_RPIF12_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF12_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF12_Clear = 0x1
	// Position of RPIF13 field.
	EXTI_RPR1_RPIF13_Pos = 0xd
	// Bit mask of RPIF13 field.
	EXTI_RPR1_RPIF13_Msk = 0x2000
	// Bit RPIF13.
	EXTI_RPR1_RPIF13 = 0x2000
	// No trigger request occurred
	EXTI_RPR1_RPIF13_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF13_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF13_Clear = 0x1
	// Position of RPIF14 field.
	EXTI_RPR1_RPIF14_Pos = 0xe
	// Bit mask of RPIF14 field.
	EXTI_RPR1_RPIF14_Msk = 0x4000
	// Bit RPIF14.
	EXTI_RPR1_RPIF14 = 0x4000
	// No trigger request occurred
	EXTI_RPR1_RPIF14_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF14_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF14_Clear = 0x1
	// Position of RPIF15 field.
	EXTI_RPR1_RPIF15_Pos = 0xf
	// Bit mask of RPIF15 field.
	EXTI_RPR1_RPIF15_Msk = 0x8000
	// Bit RPIF15.
	EXTI_RPR1_RPIF15 = 0x8000
	// No trigger request occurred
	EXTI_RPR1_RPIF15_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF15_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF15_Clear = 0x1
	// Position of RPIF16 field.
	EXTI_RPR1_RPIF16_Pos = 0x10
	// Bit mask of RPIF16 field.
	EXTI_RPR1_RPIF16_Msk = 0x10000
	// Bit RPIF16.
	EXTI_RPR1_RPIF16 = 0x10000
	// No trigger request occurred
	EXTI_RPR1_RPIF16_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF16_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF16_Clear = 0x1
	// Position of RPIF17 field.
	EXTI_RPR1_RPIF17_Pos = 0x11
	// Bit mask of RPIF17 field.
	EXTI_RPR1_RPIF17_Msk = 0x20000
	// Bit RPIF17.
	EXTI_RPR1_RPIF17 = 0x20000
	// No trigger request occurred
	EXTI_RPR1_RPIF17_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF17_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF17_Clear = 0x1
	// Position of RPIF18 field.
	EXTI_RPR1_RPIF18_Pos = 0x12
	// Bit mask of RPIF18 field.
	EXTI_RPR1_RPIF18_Msk = 0x40000
	// Bit RPIF18.
	EXTI_RPR1_RPIF18 = 0x40000
	// No trigger request occurred
	EXTI_RPR1_RPIF18_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_RPR1_RPIF18_Pending = 0x1
	// Clears pending bit
	EXTI_RPR1_RPIF18_Clear = 0x1

	// FPR1: EXTI falling edge pending register
	// Position of FPIF0 field.
	EXTI_FPR1_FPIF0_Pos = 0x0
	// Bit mask of FPIF0 field.
	EXTI_FPR1_FPIF0_Msk = 0x1
	// Bit FPIF0.
	EXTI_FPR1_FPIF0 = 0x1
	// No trigger request occurred
	EXTI_FPR1_FPIF0_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF0_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF0_Clear = 0x1
	// Position of FPIF1 field.
	EXTI_FPR1_FPIF1_Pos = 0x1
	// Bit mask of FPIF1 field.
	EXTI_FPR1_FPIF1_Msk = 0x2
	// Bit FPIF1.
	EXTI_FPR1_FPIF1 = 0x2
	// No trigger request occurred
	EXTI_FPR1_FPIF1_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF1_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF1_Clear = 0x1
	// Position of FPIF2 field.
	EXTI_FPR1_FPIF2_Pos = 0x2
	// Bit mask of FPIF2 field.
	EXTI_FPR1_FPIF2_Msk = 0x4
	// Bit FPIF2.
	EXTI_FPR1_FPIF2 = 0x4
	// No trigger request occurred
	EXTI_FPR1_FPIF2_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF2_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF2_Clear = 0x1
	// Position of FPIF3 field.
	EXTI_FPR1_FPIF3_Pos = 0x3
	// Bit mask of FPIF3 field.
	EXTI_FPR1_FPIF3_Msk = 0x8
	// Bit FPIF3.
	EXTI_FPR1_FPIF3 = 0x8
	// No trigger request occurred
	EXTI_FPR1_FPIF3_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF3_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF3_Clear = 0x1
	// Position of FPIF4 field.
	EXTI_FPR1_FPIF4_Pos = 0x4
	// Bit mask of FPIF4 field.
	EXTI_FPR1_FPIF4_Msk = 0x10
	// Bit FPIF4.
	EXTI_FPR1_FPIF4 = 0x10
	// No trigger request occurred
	EXTI_FPR1_FPIF4_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF4_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF4_Clear = 0x1
	// Position of FPIF5 field.
	EXTI_FPR1_FPIF5_Pos = 0x5
	// Bit mask of FPIF5 field.
	EXTI_FPR1_FPIF5_Msk = 0x20
	// Bit FPIF5.
	EXTI_FPR1_FPIF5 = 0x20
	// No trigger request occurred
	EXTI_FPR1_FPIF5_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF5_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF5_Clear = 0x1
	// Position of FPIF6 field.
	EXTI_FPR1_FPIF6_Pos = 0x6
	// Bit mask of FPIF6 field.
	EXTI_FPR1_FPIF6_Msk = 0x40
	// Bit FPIF6.
	EXTI_FPR1_FPIF6 = 0x40
	// No trigger request occurred
	EXTI_FPR1_FPIF6_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF6_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF6_Clear = 0x1
	// Position of FPIF7 field.
	EXTI_FPR1_FPIF7_Pos = 0x7
	// Bit mask of FPIF7 field.
	EXTI_FPR1_FPIF7_Msk = 0x80
	// Bit FPIF7.
	EXTI_FPR1_FPIF7 = 0x80
	// No trigger request occurred
	EXTI_FPR1_FPIF7_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF7_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF7_Clear = 0x1
	// Position of FPIF8 field.
	EXTI_FPR1_FPIF8_Pos = 0x8
	// Bit mask of FPIF8 field.
	EXTI_FPR1_FPIF8_Msk = 0x100
	// Bit FPIF8.
	EXTI_FPR1_FPIF8 = 0x100
	// No trigger request occurred
	EXTI_FPR1_FPIF8_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF8_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF8_Clear = 0x1
	// Position of FPIF9 field.
	EXTI_FPR1_FPIF9_Pos = 0x9
	// Bit mask of FPIF9 field.
	EXTI_FPR1_FPIF9_Msk = 0x200
	// Bit FPIF9.
	EXTI_FPR1_FPIF9 = 0x200
	// No trigger request occurred
	EXTI_FPR1_FPIF9_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF9_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF9_Clear = 0x1
	// Position of FPIF10 field.
	EXTI_FPR1_FPIF10_Pos = 0xa
	// Bit mask of FPIF10 field.
	EXTI_FPR1_FPIF10_Msk = 0x400
	// Bit FPIF10.
	EXTI_FPR1_FPIF10 = 0x400
	// No trigger request occurred
	EXTI_FPR1_FPIF10_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF10_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF10_Clear = 0x1
	// Position of FPIF11 field.
	EXTI_FPR1_FPIF11_Pos = 0xb
	// Bit mask of FPIF11 field.
	EXTI_FPR1_FPIF11_Msk = 0x800
	// Bit FPIF11.
	EXTI_FPR1_FPIF11 = 0x800
	// No trigger request occurred
	EXTI_FPR1_FPIF11_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF11_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF11_Clear = 0x1
	// Position of FPIF12 field.
	EXTI_FPR1_FPIF12_Pos = 0xc
	// Bit mask of FPIF12 field.
	EXTI_FPR1_FPIF12_Msk = 0x1000
	// Bit FPIF12.
	EXTI_FPR1_FPIF12 = 0x1000
	// No trigger request occurred
	EXTI_FPR1_FPIF12_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF12_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF12_Clear = 0x1
	// Position of FPIF13 field.
	EXTI_FPR1_FPIF13_Pos = 0xd
	// Bit mask of FPIF13 field.
	EXTI_FPR1_FPIF13_Msk = 0x2000
	// Bit FPIF13.
	EXTI_FPR1_FPIF13 = 0x2000
	// No trigger request occurred
	EXTI_FPR1_FPIF13_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF13_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF13_Clear = 0x1
	// Position of FPIF14 field.
	EXTI_FPR1_FPIF14_Pos = 0xe
	// Bit mask of FPIF14 field.
	EXTI_FPR1_FPIF14_Msk = 0x4000
	// Bit FPIF14.
	EXTI_FPR1_FPIF14 = 0x4000
	// No trigger request occurred
	EXTI_FPR1_FPIF14_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF14_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF14_Clear = 0x1
	// Position of FPIF15 field.
	EXTI_FPR1_FPIF15_Pos = 0xf
	// Bit mask of FPIF15 field.
	EXTI_FPR1_FPIF15_Msk = 0x8000
	// Bit FPIF15.
	EXTI_FPR1_FPIF15 = 0x8000
	// No trigger request occurred
	EXTI_FPR1_FPIF15_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF15_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF15_Clear = 0x1
	// Position of FPIF16 field.
	EXTI_FPR1_FPIF16_Pos = 0x10
	// Bit mask of FPIF16 field.
	EXTI_FPR1_FPIF16_Msk = 0x10000
	// Bit FPIF16.
	EXTI_FPR1_FPIF16 = 0x10000
	// No trigger request occurred
	EXTI_FPR1_FPIF16_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF16_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF16_Clear = 0x1
	// Position of FPIF17 field.
	EXTI_FPR1_FPIF17_Pos = 0x11
	// Bit mask of FPIF17 field.
	EXTI_FPR1_FPIF17_Msk = 0x20000
	// Bit FPIF17.
	EXTI_FPR1_FPIF17 = 0x20000
	// No trigger request occurred
	EXTI_FPR1_FPIF17_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF17_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF17_Clear = 0x1
	// Position of FPIF18 field.
	EXTI_FPR1_FPIF18_Pos = 0x12
	// Bit mask of FPIF18 field.
	EXTI_FPR1_FPIF18_Msk = 0x40000
	// Bit FPIF18.
	EXTI_FPR1_FPIF18 = 0x40000
	// No trigger request occurred
	EXTI_FPR1_FPIF18_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_FPR1_FPIF18_Pending = 0x1
	// Clears pending bit
	EXTI_FPR1_FPIF18_Clear = 0x1

	// EXTICR1: EXTI external interrupt selection register
	// Position of EXTI0_7 field.
	EXTI_EXTICR1_EXTI0_7_Pos = 0x0
	// Bit mask of EXTI0_7 field.
	EXTI_EXTICR1_EXTI0_7_Msk = 0xff
	// GPIO port A selected
	EXTI_EXTICR1_EXTI0_7_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR1_EXTI0_7_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR1_EXTI0_7_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR1_EXTI0_7_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR1_EXTI0_7_PF = 0x5
	// Position of EXTI8_15 field.
	EXTI_EXTICR1_EXTI8_15_Pos = 0x8
	// Bit mask of EXTI8_15 field.
	EXTI_EXTICR1_EXTI8_15_Msk = 0xff00
	// GPIO port A selected
	EXTI_EXTICR1_EXTI8_15_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR1_EXTI8_15_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR1_EXTI8_15_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR1_EXTI8_15_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR1_EXTI8_15_PF = 0x5
	// Position of EXTI16_23 field.
	EXTI_EXTICR1_EXTI16_23_Pos = 0x10
	// Bit mask of EXTI16_23 field.
	EXTI_EXTICR1_EXTI16_23_Msk = 0xff0000
	// GPIO port A selected
	EXTI_EXTICR1_EXTI16_23_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR1_EXTI16_23_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR1_EXTI16_23_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR1_EXTI16_23_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR1_EXTI16_23_PF = 0x5
	// Position of EXTI24_31 field.
	EXTI_EXTICR1_EXTI24_31_Pos = 0x18
	// Bit mask of EXTI24_31 field.
	EXTI_EXTICR1_EXTI24_31_Msk = 0xff000000
	// GPIO port A selected
	EXTI_EXTICR1_EXTI24_31_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR1_EXTI24_31_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR1_EXTI24_31_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR1_EXTI24_31_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR1_EXTI24_31_PF = 0x5

	// EXTICR2: EXTI external interrupt selection register
	// Position of EXTI0_7 field.
	EXTI_EXTICR2_EXTI0_7_Pos = 0x0
	// Bit mask of EXTI0_7 field.
	EXTI_EXTICR2_EXTI0_7_Msk = 0xff
	// GPIO port A selected
	EXTI_EXTICR2_EXTI0_7_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR2_EXTI0_7_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR2_EXTI0_7_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR2_EXTI0_7_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR2_EXTI0_7_PF = 0x5
	// Position of EXTI8_15 field.
	EXTI_EXTICR2_EXTI8_15_Pos = 0x8
	// Bit mask of EXTI8_15 field.
	EXTI_EXTICR2_EXTI8_15_Msk = 0xff00
	// GPIO port A selected
	EXTI_EXTICR2_EXTI8_15_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR2_EXTI8_15_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR2_EXTI8_15_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR2_EXTI8_15_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR2_EXTI8_15_PF = 0x5
	// Position of EXTI16_23 field.
	EXTI_EXTICR2_EXTI16_23_Pos = 0x10
	// Bit mask of EXTI16_23 field.
	EXTI_EXTICR2_EXTI16_23_Msk = 0xff0000
	// GPIO port A selected
	EXTI_EXTICR2_EXTI16_23_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR2_EXTI16_23_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR2_EXTI16_23_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR2_EXTI16_23_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR2_EXTI16_23_PF = 0x5
	// Position of EXTI24_31 field.
	EXTI_EXTICR2_EXTI24_31_Pos = 0x18
	// Bit mask of EXTI24_31 field.
	EXTI_EXTICR2_EXTI24_31_Msk = 0xff000000
	// GPIO port A selected
	EXTI_EXTICR2_EXTI24_31_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR2_EXTI24_31_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR2_EXTI24_31_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR2_EXTI24_31_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR2_EXTI24_31_PF = 0x5

	// EXTICR3: EXTI external interrupt selection register
	// Position of EXTI0_7 field.
	EXTI_EXTICR3_EXTI0_7_Pos = 0x0
	// Bit mask of EXTI0_7 field.
	EXTI_EXTICR3_EXTI0_7_Msk = 0xff
	// GPIO port A selected
	EXTI_EXTICR3_EXTI0_7_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR3_EXTI0_7_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR3_EXTI0_7_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR3_EXTI0_7_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR3_EXTI0_7_PF = 0x5
	// Position of EXTI8_15 field.
	EXTI_EXTICR3_EXTI8_15_Pos = 0x8
	// Bit mask of EXTI8_15 field.
	EXTI_EXTICR3_EXTI8_15_Msk = 0xff00
	// GPIO port A selected
	EXTI_EXTICR3_EXTI8_15_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR3_EXTI8_15_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR3_EXTI8_15_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR3_EXTI8_15_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR3_EXTI8_15_PF = 0x5
	// Position of EXTI16_23 field.
	EXTI_EXTICR3_EXTI16_23_Pos = 0x10
	// Bit mask of EXTI16_23 field.
	EXTI_EXTICR3_EXTI16_23_Msk = 0xff0000
	// GPIO port A selected
	EXTI_EXTICR3_EXTI16_23_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR3_EXTI16_23_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR3_EXTI16_23_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR3_EXTI16_23_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR3_EXTI16_23_PF = 0x5
	// Position of EXTI24_31 field.
	EXTI_EXTICR3_EXTI24_31_Pos = 0x18
	// Bit mask of EXTI24_31 field.
	EXTI_EXTICR3_EXTI24_31_Msk = 0xff000000
	// GPIO port A selected
	EXTI_EXTICR3_EXTI24_31_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR3_EXTI24_31_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR3_EXTI24_31_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR3_EXTI24_31_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR3_EXTI24_31_PF = 0x5

	// EXTICR4: EXTI external interrupt selection register
	// Position of EXTI0_7 field.
	EXTI_EXTICR4_EXTI0_7_Pos = 0x0
	// Bit mask of EXTI0_7 field.
	EXTI_EXTICR4_EXTI0_7_Msk = 0xff
	// GPIO port A selected
	EXTI_EXTICR4_EXTI0_7_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR4_EXTI0_7_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR4_EXTI0_7_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR4_EXTI0_7_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR4_EXTI0_7_PF = 0x5
	// Position of EXTI8_15 field.
	EXTI_EXTICR4_EXTI8_15_Pos = 0x8
	// Bit mask of EXTI8_15 field.
	EXTI_EXTICR4_EXTI8_15_Msk = 0xff00
	// GPIO port A selected
	EXTI_EXTICR4_EXTI8_15_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR4_EXTI8_15_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR4_EXTI8_15_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR4_EXTI8_15_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR4_EXTI8_15_PF = 0x5
	// Position of EXTI16_23 field.
	EXTI_EXTICR4_EXTI16_23_Pos = 0x10
	// Bit mask of EXTI16_23 field.
	EXTI_EXTICR4_EXTI16_23_Msk = 0xff0000
	// GPIO port A selected
	EXTI_EXTICR4_EXTI16_23_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR4_EXTI16_23_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR4_EXTI16_23_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR4_EXTI16_23_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR4_EXTI16_23_PF = 0x5
	// Position of EXTI24_31 field.
	EXTI_EXTICR4_EXTI24_31_Pos = 0x18
	// Bit mask of EXTI24_31 field.
	EXTI_EXTICR4_EXTI24_31_Msk = 0xff000000
	// GPIO port A selected
	EXTI_EXTICR4_EXTI24_31_PA = 0x0
	// GPIO port B selected
	EXTI_EXTICR4_EXTI24_31_PB = 0x1
	// GPIO port C selected
	EXTI_EXTICR4_EXTI24_31_PC = 0x2
	// GPIO port D selected
	EXTI_EXTICR4_EXTI24_31_PD = 0x3
	// GPIO port F selected
	EXTI_EXTICR4_EXTI24_31_PF = 0x5

	// IMR1: EXTI CPU wakeup with interrupt mask register
	// Position of IM0 field.
	EXTI_IMR1_IM0_Pos = 0x0
	// Bit mask of IM0 field.
	EXTI_IMR1_IM0_Msk = 0x1
	// Bit IM0.
	EXTI_IMR1_IM0 = 0x1
	// Interrupt request line is masked
	EXTI_IMR1_IM0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM0_Unmasked = 0x1
	// Position of IM1 field.
	EXTI_IMR1_IM1_Pos = 0x1
	// Bit mask of IM1 field.
	EXTI_IMR1_IM1_Msk = 0x2
	// Bit IM1.
	EXTI_IMR1_IM1 = 0x2
	// Interrupt request line is masked
	EXTI_IMR1_IM1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM1_Unmasked = 0x1
	// Position of IM2 field.
	EXTI_IMR1_IM2_Pos = 0x2
	// Bit mask of IM2 field.
	EXTI_IMR1_IM2_Msk = 0x4
	// Bit IM2.
	EXTI_IMR1_IM2 = 0x4
	// Interrupt request line is masked
	EXTI_IMR1_IM2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM2_Unmasked = 0x1
	// Position of IM3 field.
	EXTI_IMR1_IM3_Pos = 0x3
	// Bit mask of IM3 field.
	EXTI_IMR1_IM3_Msk = 0x8
	// Bit IM3.
	EXTI_IMR1_IM3 = 0x8
	// Interrupt request line is masked
	EXTI_IMR1_IM3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM3_Unmasked = 0x1
	// Position of IM4 field.
	EXTI_IMR1_IM4_Pos = 0x4
	// Bit mask of IM4 field.
	EXTI_IMR1_IM4_Msk = 0x10
	// Bit IM4.
	EXTI_IMR1_IM4 = 0x10
	// Interrupt request line is masked
	EXTI_IMR1_IM4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM4_Unmasked = 0x1
	// Position of IM5 field.
	EXTI_IMR1_IM5_Pos = 0x5
	// Bit mask of IM5 field.
	EXTI_IMR1_IM5_Msk = 0x20
	// Bit IM5.
	EXTI_IMR1_IM5 = 0x20
	// Interrupt request line is masked
	EXTI_IMR1_IM5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM5_Unmasked = 0x1
	// Position of IM6 field.
	EXTI_IMR1_IM6_Pos = 0x6
	// Bit mask of IM6 field.
	EXTI_IMR1_IM6_Msk = 0x40
	// Bit IM6.
	EXTI_IMR1_IM6 = 0x40
	// Interrupt request line is masked
	EXTI_IMR1_IM6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM6_Unmasked = 0x1
	// Position of IM7 field.
	EXTI_IMR1_IM7_Pos = 0x7
	// Bit mask of IM7 field.
	EXTI_IMR1_IM7_Msk = 0x80
	// Bit IM7.
	EXTI_IMR1_IM7 = 0x80
	// Interrupt request line is masked
	EXTI_IMR1_IM7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM7_Unmasked = 0x1
	// Position of IM8 field.
	EXTI_IMR1_IM8_Pos = 0x8
	// Bit mask of IM8 field.
	EXTI_IMR1_IM8_Msk = 0x100
	// Bit IM8.
	EXTI_IMR1_IM8 = 0x100
	// Interrupt request line is masked
	EXTI_IMR1_IM8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM8_Unmasked = 0x1
	// Position of IM9 field.
	EXTI_IMR1_IM9_Pos = 0x9
	// Bit mask of IM9 field.
	EXTI_IMR1_IM9_Msk = 0x200
	// Bit IM9.
	EXTI_IMR1_IM9 = 0x200
	// Interrupt request line is masked
	EXTI_IMR1_IM9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM9_Unmasked = 0x1
	// Position of IM10 field.
	EXTI_IMR1_IM10_Pos = 0xa
	// Bit mask of IM10 field.
	EXTI_IMR1_IM10_Msk = 0x400
	// Bit IM10.
	EXTI_IMR1_IM10 = 0x400
	// Interrupt request line is masked
	EXTI_IMR1_IM10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM10_Unmasked = 0x1
	// Position of IM11 field.
	EXTI_IMR1_IM11_Pos = 0xb
	// Bit mask of IM11 field.
	EXTI_IMR1_IM11_Msk = 0x800
	// Bit IM11.
	EXTI_IMR1_IM11 = 0x800
	// Interrupt request line is masked
	EXTI_IMR1_IM11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM11_Unmasked = 0x1
	// Position of IM12 field.
	EXTI_IMR1_IM12_Pos = 0xc
	// Bit mask of IM12 field.
	EXTI_IMR1_IM12_Msk = 0x1000
	// Bit IM12.
	EXTI_IMR1_IM12 = 0x1000
	// Interrupt request line is masked
	EXTI_IMR1_IM12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM12_Unmasked = 0x1
	// Position of IM13 field.
	EXTI_IMR1_IM13_Pos = 0xd
	// Bit mask of IM13 field.
	EXTI_IMR1_IM13_Msk = 0x2000
	// Bit IM13.
	EXTI_IMR1_IM13 = 0x2000
	// Interrupt request line is masked
	EXTI_IMR1_IM13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM13_Unmasked = 0x1
	// Position of IM14 field.
	EXTI_IMR1_IM14_Pos = 0xe
	// Bit mask of IM14 field.
	EXTI_IMR1_IM14_Msk = 0x4000
	// Bit IM14.
	EXTI_IMR1_IM14 = 0x4000
	// Interrupt request line is masked
	EXTI_IMR1_IM14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM14_Unmasked = 0x1
	// Position of IM15 field.
	EXTI_IMR1_IM15_Pos = 0xf
	// Bit mask of IM15 field.
	EXTI_IMR1_IM15_Msk = 0x8000
	// Bit IM15.
	EXTI_IMR1_IM15 = 0x8000
	// Interrupt request line is masked
	EXTI_IMR1_IM15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM15_Unmasked = 0x1
	// Position of IM16 field.
	EXTI_IMR1_IM16_Pos = 0x10
	// Bit mask of IM16 field.
	EXTI_IMR1_IM16_Msk = 0x10000
	// Bit IM16.
	EXTI_IMR1_IM16 = 0x10000
	// Interrupt request line is masked
	EXTI_IMR1_IM16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM16_Unmasked = 0x1
	// Position of IM17 field.
	EXTI_IMR1_IM17_Pos = 0x11
	// Bit mask of IM17 field.
	EXTI_IMR1_IM17_Msk = 0x20000
	// Bit IM17.
	EXTI_IMR1_IM17 = 0x20000
	// Interrupt request line is masked
	EXTI_IMR1_IM17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM17_Unmasked = 0x1
	// Position of IM18 field.
	EXTI_IMR1_IM18_Pos = 0x12
	// Bit mask of IM18 field.
	EXTI_IMR1_IM18_Msk = 0x40000
	// Bit IM18.
	EXTI_IMR1_IM18 = 0x40000
	// Interrupt request line is masked
	EXTI_IMR1_IM18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM18_Unmasked = 0x1
	// Position of IM19 field.
	EXTI_IMR1_IM19_Pos = 0x13
	// Bit mask of IM19 field.
	EXTI_IMR1_IM19_Msk = 0x80000
	// Bit IM19.
	EXTI_IMR1_IM19 = 0x80000
	// Interrupt request line is masked
	EXTI_IMR1_IM19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM19_Unmasked = 0x1
	// Position of IM20 field.
	EXTI_IMR1_IM20_Pos = 0x14
	// Bit mask of IM20 field.
	EXTI_IMR1_IM20_Msk = 0x100000
	// Bit IM20.
	EXTI_IMR1_IM20 = 0x100000
	// Interrupt request line is masked
	EXTI_IMR1_IM20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM20_Unmasked = 0x1
	// Position of IM21 field.
	EXTI_IMR1_IM21_Pos = 0x15
	// Bit mask of IM21 field.
	EXTI_IMR1_IM21_Msk = 0x200000
	// Bit IM21.
	EXTI_IMR1_IM21 = 0x200000
	// Interrupt request line is masked
	EXTI_IMR1_IM21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM21_Unmasked = 0x1
	// Position of IM22 field.
	EXTI_IMR1_IM22_Pos = 0x16
	// Bit mask of IM22 field.
	EXTI_IMR1_IM22_Msk = 0x400000
	// Bit IM22.
	EXTI_IMR1_IM22 = 0x400000
	// Interrupt request line is masked
	EXTI_IMR1_IM22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM22_Unmasked = 0x1
	// Position of IM23 field.
	EXTI_IMR1_IM23_Pos = 0x17
	// Bit mask of IM23 field.
	EXTI_IMR1_IM23_Msk = 0x800000
	// Bit IM23.
	EXTI_IMR1_IM23 = 0x800000
	// Interrupt request line is masked
	EXTI_IMR1_IM23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM23_Unmasked = 0x1
	// Position of IM24 field.
	EXTI_IMR1_IM24_Pos = 0x18
	// Bit mask of IM24 field.
	EXTI_IMR1_IM24_Msk = 0x1000000
	// Bit IM24.
	EXTI_IMR1_IM24 = 0x1000000
	// Interrupt request line is masked
	EXTI_IMR1_IM24_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM24_Unmasked = 0x1
	// Position of IM25 field.
	EXTI_IMR1_IM25_Pos = 0x19
	// Bit mask of IM25 field.
	EXTI_IMR1_IM25_Msk = 0x2000000
	// Bit IM25.
	EXTI_IMR1_IM25 = 0x2000000
	// Interrupt request line is masked
	EXTI_IMR1_IM25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM25_Unmasked = 0x1
	// Position of IM26 field.
	EXTI_IMR1_IM26_Pos = 0x1a
	// Bit mask of IM26 field.
	EXTI_IMR1_IM26_Msk = 0x4000000
	// Bit IM26.
	EXTI_IMR1_IM26 = 0x4000000
	// Interrupt request line is masked
	EXTI_IMR1_IM26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM26_Unmasked = 0x1
	// Position of IM27 field.
	EXTI_IMR1_IM27_Pos = 0x1b
	// Bit mask of IM27 field.
	EXTI_IMR1_IM27_Msk = 0x8000000
	// Bit IM27.
	EXTI_IMR1_IM27 = 0x8000000
	// Interrupt request line is masked
	EXTI_IMR1_IM27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM27_Unmasked = 0x1
	// Position of IM28 field.
	EXTI_IMR1_IM28_Pos = 0x1c
	// Bit mask of IM28 field.
	EXTI_IMR1_IM28_Msk = 0x10000000
	// Bit IM28.
	EXTI_IMR1_IM28 = 0x10000000
	// Interrupt request line is masked
	EXTI_IMR1_IM28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM28_Unmasked = 0x1
	// Position of IM29 field.
	EXTI_IMR1_IM29_Pos = 0x1d
	// Bit mask of IM29 field.
	EXTI_IMR1_IM29_Msk = 0x20000000
	// Bit IM29.
	EXTI_IMR1_IM29 = 0x20000000
	// Interrupt request line is masked
	EXTI_IMR1_IM29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM29_Unmasked = 0x1
	// Position of IM30 field.
	EXTI_IMR1_IM30_Pos = 0x1e
	// Bit mask of IM30 field.
	EXTI_IMR1_IM30_Msk = 0x40000000
	// Bit IM30.
	EXTI_IMR1_IM30 = 0x40000000
	// Interrupt request line is masked
	EXTI_IMR1_IM30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM30_Unmasked = 0x1
	// Position of IM31 field.
	EXTI_IMR1_IM31_Pos = 0x1f
	// Bit mask of IM31 field.
	EXTI_IMR1_IM31_Msk = 0x80000000
	// Bit IM31.
	EXTI_IMR1_IM31 = 0x80000000
	// Interrupt request line is masked
	EXTI_IMR1_IM31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR1_IM31_Unmasked = 0x1

	// EMR1: EXTI CPU wakeup with event mask register
	// Position of EM0 field.
	EXTI_EMR1_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	EXTI_EMR1_EM0_Msk = 0x1
	// Bit EM0.
	EXTI_EMR1_EM0 = 0x1
	// Interrupt request line is masked
	EXTI_EMR1_EM0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM0_Unmasked = 0x1
	// Position of EM1 field.
	EXTI_EMR1_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	EXTI_EMR1_EM1_Msk = 0x2
	// Bit EM1.
	EXTI_EMR1_EM1 = 0x2
	// Interrupt request line is masked
	EXTI_EMR1_EM1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM1_Unmasked = 0x1
	// Position of EM2 field.
	EXTI_EMR1_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	EXTI_EMR1_EM2_Msk = 0x4
	// Bit EM2.
	EXTI_EMR1_EM2 = 0x4
	// Interrupt request line is masked
	EXTI_EMR1_EM2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM2_Unmasked = 0x1
	// Position of EM3 field.
	EXTI_EMR1_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	EXTI_EMR1_EM3_Msk = 0x8
	// Bit EM3.
	EXTI_EMR1_EM3 = 0x8
	// Interrupt request line is masked
	EXTI_EMR1_EM3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM3_Unmasked = 0x1
	// Position of EM4 field.
	EXTI_EMR1_EM4_Pos = 0x4
	// Bit mask of EM4 field.
	EXTI_EMR1_EM4_Msk = 0x10
	// Bit EM4.
	EXTI_EMR1_EM4 = 0x10
	// Interrupt request line is masked
	EXTI_EMR1_EM4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM4_Unmasked = 0x1
	// Position of EM5 field.
	EXTI_EMR1_EM5_Pos = 0x5
	// Bit mask of EM5 field.
	EXTI_EMR1_EM5_Msk = 0x20
	// Bit EM5.
	EXTI_EMR1_EM5 = 0x20
	// Interrupt request line is masked
	EXTI_EMR1_EM5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM5_Unmasked = 0x1
	// Position of EM6 field.
	EXTI_EMR1_EM6_Pos = 0x6
	// Bit mask of EM6 field.
	EXTI_EMR1_EM6_Msk = 0x40
	// Bit EM6.
	EXTI_EMR1_EM6 = 0x40
	// Interrupt request line is masked
	EXTI_EMR1_EM6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM6_Unmasked = 0x1
	// Position of EM7 field.
	EXTI_EMR1_EM7_Pos = 0x7
	// Bit mask of EM7 field.
	EXTI_EMR1_EM7_Msk = 0x80
	// Bit EM7.
	EXTI_EMR1_EM7 = 0x80
	// Interrupt request line is masked
	EXTI_EMR1_EM7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM7_Unmasked = 0x1
	// Position of EM8 field.
	EXTI_EMR1_EM8_Pos = 0x8
	// Bit mask of EM8 field.
	EXTI_EMR1_EM8_Msk = 0x100
	// Bit EM8.
	EXTI_EMR1_EM8 = 0x100
	// Interrupt request line is masked
	EXTI_EMR1_EM8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM8_Unmasked = 0x1
	// Position of EM9 field.
	EXTI_EMR1_EM9_Pos = 0x9
	// Bit mask of EM9 field.
	EXTI_EMR1_EM9_Msk = 0x200
	// Bit EM9.
	EXTI_EMR1_EM9 = 0x200
	// Interrupt request line is masked
	EXTI_EMR1_EM9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM9_Unmasked = 0x1
	// Position of EM10 field.
	EXTI_EMR1_EM10_Pos = 0xa
	// Bit mask of EM10 field.
	EXTI_EMR1_EM10_Msk = 0x400
	// Bit EM10.
	EXTI_EMR1_EM10 = 0x400
	// Interrupt request line is masked
	EXTI_EMR1_EM10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM10_Unmasked = 0x1
	// Position of EM11 field.
	EXTI_EMR1_EM11_Pos = 0xb
	// Bit mask of EM11 field.
	EXTI_EMR1_EM11_Msk = 0x800
	// Bit EM11.
	EXTI_EMR1_EM11 = 0x800
	// Interrupt request line is masked
	EXTI_EMR1_EM11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM11_Unmasked = 0x1
	// Position of EM12 field.
	EXTI_EMR1_EM12_Pos = 0xc
	// Bit mask of EM12 field.
	EXTI_EMR1_EM12_Msk = 0x1000
	// Bit EM12.
	EXTI_EMR1_EM12 = 0x1000
	// Interrupt request line is masked
	EXTI_EMR1_EM12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM12_Unmasked = 0x1
	// Position of EM13 field.
	EXTI_EMR1_EM13_Pos = 0xd
	// Bit mask of EM13 field.
	EXTI_EMR1_EM13_Msk = 0x2000
	// Bit EM13.
	EXTI_EMR1_EM13 = 0x2000
	// Interrupt request line is masked
	EXTI_EMR1_EM13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM13_Unmasked = 0x1
	// Position of EM14 field.
	EXTI_EMR1_EM14_Pos = 0xe
	// Bit mask of EM14 field.
	EXTI_EMR1_EM14_Msk = 0x4000
	// Bit EM14.
	EXTI_EMR1_EM14 = 0x4000
	// Interrupt request line is masked
	EXTI_EMR1_EM14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM14_Unmasked = 0x1
	// Position of EM15 field.
	EXTI_EMR1_EM15_Pos = 0xf
	// Bit mask of EM15 field.
	EXTI_EMR1_EM15_Msk = 0x8000
	// Bit EM15.
	EXTI_EMR1_EM15 = 0x8000
	// Interrupt request line is masked
	EXTI_EMR1_EM15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM15_Unmasked = 0x1
	// Position of EM16 field.
	EXTI_EMR1_EM16_Pos = 0x10
	// Bit mask of EM16 field.
	EXTI_EMR1_EM16_Msk = 0x10000
	// Bit EM16.
	EXTI_EMR1_EM16 = 0x10000
	// Interrupt request line is masked
	EXTI_EMR1_EM16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM16_Unmasked = 0x1
	// Position of EM17 field.
	EXTI_EMR1_EM17_Pos = 0x11
	// Bit mask of EM17 field.
	EXTI_EMR1_EM17_Msk = 0x20000
	// Bit EM17.
	EXTI_EMR1_EM17 = 0x20000
	// Interrupt request line is masked
	EXTI_EMR1_EM17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM17_Unmasked = 0x1
	// Position of EM18 field.
	EXTI_EMR1_EM18_Pos = 0x12
	// Bit mask of EM18 field.
	EXTI_EMR1_EM18_Msk = 0x40000
	// Bit EM18.
	EXTI_EMR1_EM18 = 0x40000
	// Interrupt request line is masked
	EXTI_EMR1_EM18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM18_Unmasked = 0x1
	// Position of EM19 field.
	EXTI_EMR1_EM19_Pos = 0x13
	// Bit mask of EM19 field.
	EXTI_EMR1_EM19_Msk = 0x80000
	// Bit EM19.
	EXTI_EMR1_EM19 = 0x80000
	// Interrupt request line is masked
	EXTI_EMR1_EM19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM19_Unmasked = 0x1
	// Position of EM21 field.
	EXTI_EMR1_EM21_Pos = 0x15
	// Bit mask of EM21 field.
	EXTI_EMR1_EM21_Msk = 0x200000
	// Bit EM21.
	EXTI_EMR1_EM21 = 0x200000
	// Interrupt request line is masked
	EXTI_EMR1_EM21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM21_Unmasked = 0x1
	// Position of EM23 field.
	EXTI_EMR1_EM23_Pos = 0x17
	// Bit mask of EM23 field.
	EXTI_EMR1_EM23_Msk = 0x800000
	// Bit EM23.
	EXTI_EMR1_EM23 = 0x800000
	// Interrupt request line is masked
	EXTI_EMR1_EM23_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM23_Unmasked = 0x1
	// Position of EM25 field.
	EXTI_EMR1_EM25_Pos = 0x19
	// Bit mask of EM25 field.
	EXTI_EMR1_EM25_Msk = 0x2000000
	// Bit EM25.
	EXTI_EMR1_EM25 = 0x2000000
	// Interrupt request line is masked
	EXTI_EMR1_EM25_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM25_Unmasked = 0x1
	// Position of EM26 field.
	EXTI_EMR1_EM26_Pos = 0x1a
	// Bit mask of EM26 field.
	EXTI_EMR1_EM26_Msk = 0x4000000
	// Bit EM26.
	EXTI_EMR1_EM26 = 0x4000000
	// Interrupt request line is masked
	EXTI_EMR1_EM26_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM26_Unmasked = 0x1
	// Position of EM27 field.
	EXTI_EMR1_EM27_Pos = 0x1b
	// Bit mask of EM27 field.
	EXTI_EMR1_EM27_Msk = 0x8000000
	// Bit EM27.
	EXTI_EMR1_EM27 = 0x8000000
	// Interrupt request line is masked
	EXTI_EMR1_EM27_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM27_Unmasked = 0x1
	// Position of EM28 field.
	EXTI_EMR1_EM28_Pos = 0x1c
	// Bit mask of EM28 field.
	EXTI_EMR1_EM28_Msk = 0x10000000
	// Bit EM28.
	EXTI_EMR1_EM28 = 0x10000000
	// Interrupt request line is masked
	EXTI_EMR1_EM28_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM28_Unmasked = 0x1
	// Position of EM29 field.
	EXTI_EMR1_EM29_Pos = 0x1d
	// Bit mask of EM29 field.
	EXTI_EMR1_EM29_Msk = 0x20000000
	// Bit EM29.
	EXTI_EMR1_EM29 = 0x20000000
	// Interrupt request line is masked
	EXTI_EMR1_EM29_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM29_Unmasked = 0x1
	// Position of EM30 field.
	EXTI_EMR1_EM30_Pos = 0x1e
	// Bit mask of EM30 field.
	EXTI_EMR1_EM30_Msk = 0x40000000
	// Bit EM30.
	EXTI_EMR1_EM30 = 0x40000000
	// Interrupt request line is masked
	EXTI_EMR1_EM30_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM30_Unmasked = 0x1
	// Position of EM31 field.
	EXTI_EMR1_EM31_Pos = 0x1f
	// Bit mask of EM31 field.
	EXTI_EMR1_EM31_Msk = 0x80000000
	// Bit EM31.
	EXTI_EMR1_EM31 = 0x80000000
	// Interrupt request line is masked
	EXTI_EMR1_EM31_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR1_EM31_Unmasked = 0x1

	// IMR2: EXTI CPU wakeup with interrupt mask register
	// Position of IM32 field.
	EXTI_IMR2_IM32_Pos = 0x0
	// Bit mask of IM32 field.
	EXTI_IMR2_IM32_Msk = 0x1
	// Bit IM32.
	EXTI_IMR2_IM32 = 0x1
	// Interrupt request line is masked
	EXTI_IMR2_IM32_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_IM32_Unmasked = 0x1
	// Position of IM33 field.
	EXTI_IMR2_IM33_Pos = 0x1
	// Bit mask of IM33 field.
	EXTI_IMR2_IM33_Msk = 0x2
	// Bit IM33.
	EXTI_IMR2_IM33 = 0x2
	// Interrupt request line is masked
	EXTI_IMR2_IM33_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR2_IM33_Unmasked = 0x1

	// EMR2: EXTI CPU wakeup with event mask register
	// Position of EM32 field.
	EXTI_EMR2_EM32_Pos = 0x0
	// Bit mask of EM32 field.
	EXTI_EMR2_EM32_Msk = 0x1
	// Bit EM32.
	EXTI_EMR2_EM32 = 0x1
	// Interrupt request line is masked
	EXTI_EMR2_EM32_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_EM32_Unmasked = 0x1
	// Position of EM33 field.
	EXTI_EMR2_EM33_Pos = 0x1
	// Bit mask of EM33 field.
	EXTI_EMR2_EM33_Msk = 0x2
	// Bit EM33.
	EXTI_EMR2_EM33 = 0x2
	// Interrupt request line is masked
	EXTI_EMR2_EM33_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR2_EM33_Unmasked = 0x1

	// HWCFGR7: Hardware configuration registers
	// Position of CPUEVENT field.
	EXTI_HWCFGR7_CPUEVENT_Pos = 0x0
	// Bit mask of CPUEVENT field.
	EXTI_HWCFGR7_CPUEVENT_Msk = 0xffffffff

	// HWCFGR6: Hardware configuration registers
	// Position of CPUEVENT field.
	EXTI_HWCFGR6_CPUEVENT_Pos = 0x0
	// Bit mask of CPUEVENT field.
	EXTI_HWCFGR6_CPUEVENT_Msk = 0xffffffff

	// HWCFGR5: Hardware configuration registers
	// Position of CPUEVENT field.
	EXTI_HWCFGR5_CPUEVENT_Pos = 0x0
	// Bit mask of CPUEVENT field.
	EXTI_HWCFGR5_CPUEVENT_Msk = 0xffffffff

	// HWCFGR4: Hardware configuration registers
	// Position of EVENT_TRG field.
	EXTI_HWCFGR4_EVENT_TRG_Pos = 0x0
	// Bit mask of EVENT_TRG field.
	EXTI_HWCFGR4_EVENT_TRG_Msk = 0xffffffff

	// HWCFGR3: Hardware configuration registers
	// Position of EVENT_TRG field.
	EXTI_HWCFGR3_EVENT_TRG_Pos = 0x0
	// Bit mask of EVENT_TRG field.
	EXTI_HWCFGR3_EVENT_TRG_Msk = 0xffffffff

	// HWCFGR2: Hardware configuration registers
	// Position of EVENT_TRG field.
	EXTI_HWCFGR2_EVENT_TRG_Pos = 0x0
	// Bit mask of EVENT_TRG field.
	EXTI_HWCFGR2_EVENT_TRG_Msk = 0xffffffff

	// HWCFGR1: Hardware configuration registers
	// Position of NBIOPORT field.
	EXTI_HWCFGR1_NBIOPORT_Pos = 0x10
	// Bit mask of NBIOPORT field.
	EXTI_HWCFGR1_NBIOPORT_Msk = 0xff0000
	// Position of CPUEVTEN field.
	EXTI_HWCFGR1_CPUEVTEN_Pos = 0xc
	// Bit mask of CPUEVTEN field.
	EXTI_HWCFGR1_CPUEVTEN_Msk = 0xf000
	// Position of NBCPUS field.
	EXTI_HWCFGR1_NBCPUS_Pos = 0x8
	// Bit mask of NBCPUS field.
	EXTI_HWCFGR1_NBCPUS_Msk = 0xf00
	// Position of NBEVENTS field.
	EXTI_HWCFGR1_NBEVENTS_Pos = 0x0
	// Bit mask of NBEVENTS field.
	EXTI_HWCFGR1_NBEVENTS_Msk = 0xff
)

// Constants for TIM16: General purpose timers
const (
	// CR1: control register 1
	// Position of CEN field.
	TIM_CR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIM_CR1_CEN_Msk = 0x1
	// Bit CEN.
	TIM_CR1_CEN = 0x1
	// Position of UDIS field.
	TIM_CR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIM_CR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIM_CR1_UDIS = 0x2
	// Position of URS field.
	TIM_CR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIM_CR1_URS_Msk = 0x4
	// Bit URS.
	TIM_CR1_URS = 0x4
	// Position of OPM field.
	TIM_CR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIM_CR1_OPM_Msk = 0x8
	// Bit OPM.
	TIM_CR1_OPM = 0x8
	// Position of ARPE field.
	TIM_CR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIM_CR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIM_CR1_ARPE = 0x80
	// Position of CKD field.
	TIM_CR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIM_CR1_CKD_Msk = 0x300
	// Position of UIFREMAP field.
	TIM_CR1_UIFREMAP_Pos = 0xb
	// Bit mask of UIFREMAP field.
	TIM_CR1_UIFREMAP_Msk = 0x800
	// Bit UIFREMAP.
	TIM_CR1_UIFREMAP = 0x800

	// CR2: control register 2
	// Position of OIS1N field.
	TIM_CR2_OIS1N_Pos = 0x9
	// Bit mask of OIS1N field.
	TIM_CR2_OIS1N_Msk = 0x200
	// Bit OIS1N.
	TIM_CR2_OIS1N = 0x200
	// Position of OIS1 field.
	TIM_CR2_OIS1_Pos = 0x8
	// Bit mask of OIS1 field.
	TIM_CR2_OIS1_Msk = 0x100
	// Bit OIS1.
	TIM_CR2_OIS1 = 0x100
	// Position of CCDS field.
	TIM_CR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIM_CR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIM_CR2_CCDS = 0x8
	// Position of CCUS field.
	TIM_CR2_CCUS_Pos = 0x2
	// Bit mask of CCUS field.
	TIM_CR2_CCUS_Msk = 0x4
	// Bit CCUS.
	TIM_CR2_CCUS = 0x4
	// Position of CCPC field.
	TIM_CR2_CCPC_Pos = 0x0
	// Bit mask of CCPC field.
	TIM_CR2_CCPC_Msk = 0x1
	// Bit CCPC.
	TIM_CR2_CCPC = 0x1

	// DIER: DMA/Interrupt enable register
	// Position of COMDE field.
	TIM_DIER_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIM_DIER_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIM_DIER_COMDE = 0x2000
	// Position of CC1DE field.
	TIM_DIER_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIM_DIER_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIM_DIER_CC1DE = 0x200
	// Position of UDE field.
	TIM_DIER_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIM_DIER_UDE_Msk = 0x100
	// Bit UDE.
	TIM_DIER_UDE = 0x100
	// Position of BIE field.
	TIM_DIER_BIE_Pos = 0x7
	// Bit mask of BIE field.
	TIM_DIER_BIE_Msk = 0x80
	// Bit BIE.
	TIM_DIER_BIE = 0x80
	// Position of COMIE field.
	TIM_DIER_COMIE_Pos = 0x5
	// Bit mask of COMIE field.
	TIM_DIER_COMIE_Msk = 0x20
	// Bit COMIE.
	TIM_DIER_COMIE = 0x20
	// Position of CC1IE field.
	TIM_DIER_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIM_DIER_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIM_DIER_CC1IE = 0x2
	// Position of UIE field.
	TIM_DIER_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIM_DIER_UIE_Msk = 0x1
	// Bit UIE.
	TIM_DIER_UIE = 0x1

	// SR: status register
	// Position of CC1OF field.
	TIM_SR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIM_SR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIM_SR_CC1OF = 0x200
	// Position of BIF field.
	TIM_SR_BIF_Pos = 0x7
	// Bit mask of BIF field.
	TIM_SR_BIF_Msk = 0x80
	// Bit BIF.
	TIM_SR_BIF = 0x80
	// Position of COMIF field.
	TIM_SR_COMIF_Pos = 0x5
	// Bit mask of COMIF field.
	TIM_SR_COMIF_Msk = 0x20
	// Bit COMIF.
	TIM_SR_COMIF = 0x20
	// Position of CC1IF field.
	TIM_SR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIM_SR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIM_SR_CC1IF = 0x2
	// Position of UIF field.
	TIM_SR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIM_SR_UIF_Msk = 0x1
	// Bit UIF.
	TIM_SR_UIF = 0x1

	// EGR: event generation register
	// Position of BG field.
	TIM_EGR_BG_Pos = 0x7
	// Bit mask of BG field.
	TIM_EGR_BG_Msk = 0x80
	// Bit BG.
	TIM_EGR_BG = 0x80
	// Position of COMG field.
	TIM_EGR_COMG_Pos = 0x5
	// Bit mask of COMG field.
	TIM_EGR_COMG_Msk = 0x20
	// Bit COMG.
	TIM_EGR_COMG = 0x20
	// Position of CC1G field.
	TIM_EGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIM_EGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIM_EGR_CC1G = 0x2
	// Position of UG field.
	TIM_EGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIM_EGR_UG_Msk = 0x1
	// Bit UG.
	TIM_EGR_UG = 0x1

	// CCMR1_Output: capture/compare mode register (output mode)
	// Position of OC1M_2 field.
	TIM_CCMR1_Output_OC1M_2_Pos = 0x10
	// Bit mask of OC1M_2 field.
	TIM_CCMR1_Output_OC1M_2_Msk = 0x10000
	// Bit OC1M_2.
	TIM_CCMR1_Output_OC1M_2 = 0x10000
	// Position of OC1M field.
	TIM_CCMR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIM_CCMR1_Output_OC1M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
	TIM_CCMR1_Output_OC1M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
	TIM_CCMR1_Output_OC1M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
	TIM_CCMR1_Output_OC1M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy
	TIM_CCMR1_Output_OC1M_Toggle = 0x3
	// OCyREF is forced low
	TIM_CCMR1_Output_OC1M_ForceInactive = 0x4
	// OCyREF is forced high
	TIM_CCMR1_Output_OC1M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
	TIM_CCMR1_Output_OC1M_PwmMode1 = 0x6
	// Inversely to PwmMode1
	TIM_CCMR1_Output_OC1M_PwmMode2 = 0x7
	// Position of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIM_CCMR1_Output_OC1PE = 0x8
	// Position of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIM_CCMR1_Output_OC1FE = 0x4
	// Position of CC1S field.
	TIM_CCMR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Output_CC1S_Msk = 0x3

	// CCMR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC1F field.
	TIM_CCMR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIM_CCMR1_Input_IC1F_Msk = 0xf0
	// Position of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Msk = 0xc
	// Position of CC1S field.
	TIM_CCMR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Input_CC1S_Msk = 0x3

	// CCER: capture/compare enable register
	// Position of CC1NP field.
	TIM_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIM_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIM_CCER_CC1NP = 0x8
	// Position of CC1NE field.
	TIM_CCER_CC1NE_Pos = 0x2
	// Bit mask of CC1NE field.
	TIM_CCER_CC1NE_Msk = 0x4
	// Bit CC1NE.
	TIM_CCER_CC1NE = 0x4
	// Position of CC1P field.
	TIM_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIM_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIM_CCER_CC1P = 0x2
	// Position of CC1E field.
	TIM_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIM_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIM_CCER_CC1E = 0x1

	// CNT: counter
	// Position of CNT field.
	TIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIM_CNT_CNT_Msk = 0xffff
	// Position of UIFCPY field.
	TIM_CNT_UIFCPY_Pos = 0x1f
	// Bit mask of UIFCPY field.
	TIM_CNT_UIFCPY_Msk = 0x80000000
	// Bit UIFCPY.
	TIM_CNT_UIFCPY = 0x80000000

	// PSC: prescaler
	// Position of PSC field.
	TIM_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIM_PSC_PSC_Msk = 0xffff

	// ARR: auto-reload register
	// Position of ARR field.
	TIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	TIM_ARR_ARR_Msk = 0xffff

	// RCR: repetition counter register
	// Position of REP field.
	TIM_RCR_REP_Pos = 0x0
	// Bit mask of REP field.
	TIM_RCR_REP_Msk = 0xff

	// CCR1: capture/compare register 1
	// Position of CCR1 field.
	TIM_CCR1_CCR1_Pos = 0x0
	// Bit mask of CCR1 field.
	TIM_CCR1_CCR1_Msk = 0xffff

	// BDTR: break and dead-time register
	// Position of DTG field.
	TIM_BDTR_DTG_Pos = 0x0
	// Bit mask of DTG field.
	TIM_BDTR_DTG_Msk = 0xff
	// Position of LOCK field.
	TIM_BDTR_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	TIM_BDTR_LOCK_Msk = 0x300
	// Position of OSSI field.
	TIM_BDTR_OSSI_Pos = 0xa
	// Bit mask of OSSI field.
	TIM_BDTR_OSSI_Msk = 0x400
	// Bit OSSI.
	TIM_BDTR_OSSI = 0x400
	// Position of OSSR field.
	TIM_BDTR_OSSR_Pos = 0xb
	// Bit mask of OSSR field.
	TIM_BDTR_OSSR_Msk = 0x800
	// Bit OSSR.
	TIM_BDTR_OSSR = 0x800
	// Position of BKE field.
	TIM_BDTR_BKE_Pos = 0xc
	// Bit mask of BKE field.
	TIM_BDTR_BKE_Msk = 0x1000
	// Bit BKE.
	TIM_BDTR_BKE = 0x1000
	// Position of BKP field.
	TIM_BDTR_BKP_Pos = 0xd
	// Bit mask of BKP field.
	TIM_BDTR_BKP_Msk = 0x2000
	// Bit BKP.
	TIM_BDTR_BKP = 0x2000
	// Position of AOE field.
	TIM_BDTR_AOE_Pos = 0xe
	// Bit mask of AOE field.
	TIM_BDTR_AOE_Msk = 0x4000
	// Bit AOE.
	TIM_BDTR_AOE = 0x4000
	// Position of MOE field.
	TIM_BDTR_MOE_Pos = 0xf
	// Bit mask of MOE field.
	TIM_BDTR_MOE_Msk = 0x8000
	// Bit MOE.
	TIM_BDTR_MOE = 0x8000
	// Position of BKF field.
	TIM_BDTR_BKF_Pos = 0x10
	// Bit mask of BKF field.
	TIM_BDTR_BKF_Msk = 0xf0000
	// Position of BKDSRM field.
	TIM_BDTR_BKDSRM_Pos = 0x1a
	// Bit mask of BKDSRM field.
	TIM_BDTR_BKDSRM_Msk = 0x4000000
	// Bit BKDSRM.
	TIM_BDTR_BKDSRM = 0x4000000
	// Position of BKBID field.
	TIM_BDTR_BKBID_Pos = 0x1c
	// Bit mask of BKBID field.
	TIM_BDTR_BKBID_Msk = 0x10000000
	// Bit BKBID.
	TIM_BDTR_BKBID = 0x10000000

	// DCR: DMA control register
	// Position of DBL field.
	TIM_DCR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIM_DCR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIM_DCR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIM_DCR_DBA_Msk = 0x1f

	// DMAR: DMA address for full transfer
	// Position of DMAB field.
	TIM_DMAR_DMAB_Pos = 0x0
	// Bit mask of DMAB field.
	TIM_DMAR_DMAB_Msk = 0xffff

	// AF1: TIM17 option register 1
	// Position of BKINE field.
	TIM_AF1_BKINE_Pos = 0x0
	// Bit mask of BKINE field.
	TIM_AF1_BKINE_Msk = 0x1
	// Bit BKINE.
	TIM_AF1_BKINE = 0x1
	// Position of BKCMP1E field.
	TIM_AF1_BKCMP1E_Pos = 0x1
	// Bit mask of BKCMP1E field.
	TIM_AF1_BKCMP1E_Msk = 0x2
	// Bit BKCMP1E.
	TIM_AF1_BKCMP1E = 0x2
	// Position of BKCMP2E field.
	TIM_AF1_BKCMP2E_Pos = 0x2
	// Bit mask of BKCMP2E field.
	TIM_AF1_BKCMP2E_Msk = 0x4
	// Bit BKCMP2E.
	TIM_AF1_BKCMP2E = 0x4
	// Position of BKDFBK1E field.
	TIM_AF1_BKDFBK1E_Pos = 0x8
	// Bit mask of BKDFBK1E field.
	TIM_AF1_BKDFBK1E_Msk = 0x100
	// Bit BKDFBK1E.
	TIM_AF1_BKDFBK1E = 0x100
	// Position of BKINP field.
	TIM_AF1_BKINP_Pos = 0x9
	// Bit mask of BKINP field.
	TIM_AF1_BKINP_Msk = 0x200
	// Bit BKINP.
	TIM_AF1_BKINP = 0x200
	// Position of BKCMP1P field.
	TIM_AF1_BKCMP1P_Pos = 0xa
	// Bit mask of BKCMP1P field.
	TIM_AF1_BKCMP1P_Msk = 0x400
	// Bit BKCMP1P.
	TIM_AF1_BKCMP1P = 0x400
	// Position of BKCMP2P field.
	TIM_AF1_BKCMP2P_Pos = 0xb
	// Bit mask of BKCMP2P field.
	TIM_AF1_BKCMP2P_Msk = 0x800
	// Bit BKCMP2P.
	TIM_AF1_BKCMP2P = 0x800

	// TISEL: input selection register
	// Position of TI1SEL field.
	TIM_TISEL_TI1SEL_Pos = 0x0
	// Bit mask of TI1SEL field.
	TIM_TISEL_TI1SEL_Msk = 0xf
	// Position of TI2SEL field.
	TIM_TISEL_TI2SEL_Pos = 0x8
	// Bit mask of TI2SEL field.
	TIM_TISEL_TI2SEL_Msk = 0xf00
)

// Constants for USART1: Universal synchronous asynchronous receiver transmitter
const (
	// CR1: Control register 1
	// Position of RXFFIE field.
	USART_CR1_RXFFIE_Pos = 0x1f
	// Bit mask of RXFFIE field.
	USART_CR1_RXFFIE_Msk = 0x80000000
	// Bit RXFFIE.
	USART_CR1_RXFFIE = 0x80000000
	// Position of TXFEIE field.
	USART_CR1_TXFEIE_Pos = 0x1e
	// Bit mask of TXFEIE field.
	USART_CR1_TXFEIE_Msk = 0x40000000
	// Bit TXFEIE.
	USART_CR1_TXFEIE = 0x40000000
	// Position of FIFOEN field.
	USART_CR1_FIFOEN_Pos = 0x1d
	// Bit mask of FIFOEN field.
	USART_CR1_FIFOEN_Msk = 0x20000000
	// Bit FIFOEN.
	USART_CR1_FIFOEN = 0x20000000
	// Position of M1 field.
	USART_CR1_M1_Pos = 0x1c
	// Bit mask of M1 field.
	USART_CR1_M1_Msk = 0x10000000
	// Bit M1.
	USART_CR1_M1 = 0x10000000
	// Position of EOBIE field.
	USART_CR1_EOBIE_Pos = 0x1b
	// Bit mask of EOBIE field.
	USART_CR1_EOBIE_Msk = 0x8000000
	// Bit EOBIE.
	USART_CR1_EOBIE = 0x8000000
	// Position of RTOIE field.
	USART_CR1_RTOIE_Pos = 0x1a
	// Bit mask of RTOIE field.
	USART_CR1_RTOIE_Msk = 0x4000000
	// Bit RTOIE.
	USART_CR1_RTOIE = 0x4000000
	// Position of DEAT field.
	USART_CR1_DEAT_Pos = 0x15
	// Bit mask of DEAT field.
	USART_CR1_DEAT_Msk = 0x3e00000
	// Position of DEDT field.
	USART_CR1_DEDT_Pos = 0x10
	// Bit mask of DEDT field.
	USART_CR1_DEDT_Msk = 0x1f0000
	// Position of OVER8 field.
	USART_CR1_OVER8_Pos = 0xf
	// Bit mask of OVER8 field.
	USART_CR1_OVER8_Msk = 0x8000
	// Bit OVER8.
	USART_CR1_OVER8 = 0x8000
	// Position of CMIE field.
	USART_CR1_CMIE_Pos = 0xe
	// Bit mask of CMIE field.
	USART_CR1_CMIE_Msk = 0x4000
	// Bit CMIE.
	USART_CR1_CMIE = 0x4000
	// Position of MME field.
	USART_CR1_MME_Pos = 0xd
	// Bit mask of MME field.
	USART_CR1_MME_Msk = 0x2000
	// Bit MME.
	USART_CR1_MME = 0x2000
	// Position of M0 field.
	USART_CR1_M0_Pos = 0xc
	// Bit mask of M0 field.
	USART_CR1_M0_Msk = 0x1000
	// Bit M0.
	USART_CR1_M0 = 0x1000
	// Position of WAKE field.
	USART_CR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	USART_CR1_WAKE_Msk = 0x800
	// Bit WAKE.
	USART_CR1_WAKE = 0x800
	// Position of PCE field.
	USART_CR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	USART_CR1_PCE_Msk = 0x400
	// Bit PCE.
	USART_CR1_PCE = 0x400
	// Position of PS field.
	USART_CR1_PS_Pos = 0x9
	// Bit mask of PS field.
	USART_CR1_PS_Msk = 0x200
	// Bit PS.
	USART_CR1_PS = 0x200
	// Position of PEIE field.
	USART_CR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	USART_CR1_PEIE_Msk = 0x100
	// Bit PEIE.
	USART_CR1_PEIE = 0x100
	// Position of TXEIE field.
	USART_CR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	USART_CR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	USART_CR1_TXEIE = 0x80
	// Position of TCIE field.
	USART_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	USART_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	USART_CR1_TCIE = 0x40
	// Position of RXNEIE field.
	USART_CR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	USART_CR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	USART_CR1_RXNEIE = 0x20
	// Position of IDLEIE field.
	USART_CR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	USART_CR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	USART_CR1_IDLEIE = 0x10
	// Position of TE field.
	USART_CR1_TE_Pos = 0x3
	// Bit mask of TE field.
	USART_CR1_TE_Msk = 0x8
	// Bit TE.
	USART_CR1_TE = 0x8
	// Position of RE field.
	USART_CR1_RE_Pos = 0x2
	// Bit mask of RE field.
	USART_CR1_RE_Msk = 0x4
	// Bit RE.
	USART_CR1_RE = 0x4
	// Position of UESM field.
	USART_CR1_UESM_Pos = 0x1
	// Bit mask of UESM field.
	USART_CR1_UESM_Msk = 0x2
	// Bit UESM.
	USART_CR1_UESM = 0x2
	// Position of UE field.
	USART_CR1_UE_Pos = 0x0
	// Bit mask of UE field.
	USART_CR1_UE_Msk = 0x1
	// Bit UE.
	USART_CR1_UE = 0x1

	// CR2: Control register 2
	// Position of ADD4_7 field.
	USART_CR2_ADD4_7_Pos = 0x1c
	// Bit mask of ADD4_7 field.
	USART_CR2_ADD4_7_Msk = 0xf0000000
	// Position of ADD0_3 field.
	USART_CR2_ADD0_3_Pos = 0x18
	// Bit mask of ADD0_3 field.
	USART_CR2_ADD0_3_Msk = 0xf000000
	// Position of RTOEN field.
	USART_CR2_RTOEN_Pos = 0x17
	// Bit mask of RTOEN field.
	USART_CR2_RTOEN_Msk = 0x800000
	// Bit RTOEN.
	USART_CR2_RTOEN = 0x800000
	// Position of ABRMOD field.
	USART_CR2_ABRMOD_Pos = 0x15
	// Bit mask of ABRMOD field.
	USART_CR2_ABRMOD_Msk = 0x600000
	// Position of ABREN field.
	USART_CR2_ABREN_Pos = 0x14
	// Bit mask of ABREN field.
	USART_CR2_ABREN_Msk = 0x100000
	// Bit ABREN.
	USART_CR2_ABREN = 0x100000
	// Position of MSBFIRST field.
	USART_CR2_MSBFIRST_Pos = 0x13
	// Bit mask of MSBFIRST field.
	USART_CR2_MSBFIRST_Msk = 0x80000
	// Bit MSBFIRST.
	USART_CR2_MSBFIRST = 0x80000
	// Position of TAINV field.
	USART_CR2_TAINV_Pos = 0x12
	// Bit mask of TAINV field.
	USART_CR2_TAINV_Msk = 0x40000
	// Bit TAINV.
	USART_CR2_TAINV = 0x40000
	// Position of TXINV field.
	USART_CR2_TXINV_Pos = 0x11
	// Bit mask of TXINV field.
	USART_CR2_TXINV_Msk = 0x20000
	// Bit TXINV.
	USART_CR2_TXINV = 0x20000
	// Position of RXINV field.
	USART_CR2_RXINV_Pos = 0x10
	// Bit mask of RXINV field.
	USART_CR2_RXINV_Msk = 0x10000
	// Bit RXINV.
	USART_CR2_RXINV = 0x10000
	// Position of SWAP field.
	USART_CR2_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	USART_CR2_SWAP_Msk = 0x8000
	// Bit SWAP.
	USART_CR2_SWAP = 0x8000
	// Position of LINEN field.
	USART_CR2_LINEN_Pos = 0xe
	// Bit mask of LINEN field.
	USART_CR2_LINEN_Msk = 0x4000
	// Bit LINEN.
	USART_CR2_LINEN = 0x4000
	// Position of STOP field.
	USART_CR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	USART_CR2_STOP_Msk = 0x3000
	// Position of CLKEN field.
	USART_CR2_CLKEN_Pos = 0xb
	// Bit mask of CLKEN field.
	USART_CR2_CLKEN_Msk = 0x800
	// Bit CLKEN.
	USART_CR2_CLKEN = 0x800
	// Position of CPOL field.
	USART_CR2_CPOL_Pos = 0xa
	// Bit mask of CPOL field.
	USART_CR2_CPOL_Msk = 0x400
	// Bit CPOL.
	USART_CR2_CPOL = 0x400
	// Position of CPHA field.
	USART_CR2_CPHA_Pos = 0x9
	// Bit mask of CPHA field.
	USART_CR2_CPHA_Msk = 0x200
	// Bit CPHA.
	USART_CR2_CPHA = 0x200
	// Position of LBCL field.
	USART_CR2_LBCL_Pos = 0x8
	// Bit mask of LBCL field.
	USART_CR2_LBCL_Msk = 0x100
	// Bit LBCL.
	USART_CR2_LBCL = 0x100
	// Position of LBDIE field.
	USART_CR2_LBDIE_Pos = 0x6
	// Bit mask of LBDIE field.
	USART_CR2_LBDIE_Msk = 0x40
	// Bit LBDIE.
	USART_CR2_LBDIE = 0x40
	// Position of LBDL field.
	USART_CR2_LBDL_Pos = 0x5
	// Bit mask of LBDL field.
	USART_CR2_LBDL_Msk = 0x20
	// Bit LBDL.
	USART_CR2_LBDL = 0x20
	// Position of ADDM7 field.
	USART_CR2_ADDM7_Pos = 0x4
	// Bit mask of ADDM7 field.
	USART_CR2_ADDM7_Msk = 0x10
	// Bit ADDM7.
	USART_CR2_ADDM7 = 0x10
	// Position of DIS_NSS field.
	USART_CR2_DIS_NSS_Pos = 0x3
	// Bit mask of DIS_NSS field.
	USART_CR2_DIS_NSS_Msk = 0x8
	// Bit DIS_NSS.
	USART_CR2_DIS_NSS = 0x8
	// Position of SLVEN field.
	USART_CR2_SLVEN_Pos = 0x0
	// Bit mask of SLVEN field.
	USART_CR2_SLVEN_Msk = 0x1
	// Bit SLVEN.
	USART_CR2_SLVEN = 0x1

	// CR3: Control register 3
	// Position of TXFTCFG field.
	USART_CR3_TXFTCFG_Pos = 0x1d
	// Bit mask of TXFTCFG field.
	USART_CR3_TXFTCFG_Msk = 0xe0000000
	// Position of RXFTIE field.
	USART_CR3_RXFTIE_Pos = 0x1c
	// Bit mask of RXFTIE field.
	USART_CR3_RXFTIE_Msk = 0x10000000
	// Bit RXFTIE.
	USART_CR3_RXFTIE = 0x10000000
	// Position of RXFTCFG field.
	USART_CR3_RXFTCFG_Pos = 0x19
	// Bit mask of RXFTCFG field.
	USART_CR3_RXFTCFG_Msk = 0xe000000
	// Position of TCBGTIE field.
	USART_CR3_TCBGTIE_Pos = 0x18
	// Bit mask of TCBGTIE field.
	USART_CR3_TCBGTIE_Msk = 0x1000000
	// Bit TCBGTIE.
	USART_CR3_TCBGTIE = 0x1000000
	// Position of TXFTIE field.
	USART_CR3_TXFTIE_Pos = 0x17
	// Bit mask of TXFTIE field.
	USART_CR3_TXFTIE_Msk = 0x800000
	// Bit TXFTIE.
	USART_CR3_TXFTIE = 0x800000
	// Position of WUFIE field.
	USART_CR3_WUFIE_Pos = 0x16
	// Bit mask of WUFIE field.
	USART_CR3_WUFIE_Msk = 0x400000
	// Bit WUFIE.
	USART_CR3_WUFIE = 0x400000
	// Position of WUS field.
	USART_CR3_WUS_Pos = 0x14
	// Bit mask of WUS field.
	USART_CR3_WUS_Msk = 0x300000
	// Position of SCARCNT field.
	USART_CR3_SCARCNT_Pos = 0x11
	// Bit mask of SCARCNT field.
	USART_CR3_SCARCNT_Msk = 0xe0000
	// Position of DEP field.
	USART_CR3_DEP_Pos = 0xf
	// Bit mask of DEP field.
	USART_CR3_DEP_Msk = 0x8000
	// Bit DEP.
	USART_CR3_DEP = 0x8000
	// Position of DEM field.
	USART_CR3_DEM_Pos = 0xe
	// Bit mask of DEM field.
	USART_CR3_DEM_Msk = 0x4000
	// Bit DEM.
	USART_CR3_DEM = 0x4000
	// Position of DDRE field.
	USART_CR3_DDRE_Pos = 0xd
	// Bit mask of DDRE field.
	USART_CR3_DDRE_Msk = 0x2000
	// Bit DDRE.
	USART_CR3_DDRE = 0x2000
	// Position of OVRDIS field.
	USART_CR3_OVRDIS_Pos = 0xc
	// Bit mask of OVRDIS field.
	USART_CR3_OVRDIS_Msk = 0x1000
	// Bit OVRDIS.
	USART_CR3_OVRDIS = 0x1000
	// Position of ONEBIT field.
	USART_CR3_ONEBIT_Pos = 0xb
	// Bit mask of ONEBIT field.
	USART_CR3_ONEBIT_Msk = 0x800
	// Bit ONEBIT.
	USART_CR3_ONEBIT = 0x800
	// Position of CTSIE field.
	USART_CR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	USART_CR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	USART_CR3_CTSIE = 0x400
	// Position of CTSE field.
	USART_CR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	USART_CR3_CTSE_Msk = 0x200
	// Bit CTSE.
	USART_CR3_CTSE = 0x200
	// Position of RTSE field.
	USART_CR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	USART_CR3_RTSE_Msk = 0x100
	// Bit RTSE.
	USART_CR3_RTSE = 0x100
	// Position of DMAT field.
	USART_CR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	USART_CR3_DMAT_Msk = 0x80
	// Bit DMAT.
	USART_CR3_DMAT = 0x80
	// Position of DMAR field.
	USART_CR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	USART_CR3_DMAR_Msk = 0x40
	// Bit DMAR.
	USART_CR3_DMAR = 0x40
	// Position of SCEN field.
	USART_CR3_SCEN_Pos = 0x5
	// Bit mask of SCEN field.
	USART_CR3_SCEN_Msk = 0x20
	// Bit SCEN.
	USART_CR3_SCEN = 0x20
	// Position of NACK field.
	USART_CR3_NACK_Pos = 0x4
	// Bit mask of NACK field.
	USART_CR3_NACK_Msk = 0x10
	// Bit NACK.
	USART_CR3_NACK = 0x10
	// Position of HDSEL field.
	USART_CR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	USART_CR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	USART_CR3_HDSEL = 0x8
	// Position of IRLP field.
	USART_CR3_IRLP_Pos = 0x2
	// Bit mask of IRLP field.
	USART_CR3_IRLP_Msk = 0x4
	// Bit IRLP.
	USART_CR3_IRLP = 0x4
	// Position of IREN field.
	USART_CR3_IREN_Pos = 0x1
	// Bit mask of IREN field.
	USART_CR3_IREN_Msk = 0x2
	// Bit IREN.
	USART_CR3_IREN = 0x2
	// Position of EIE field.
	USART_CR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	USART_CR3_EIE_Msk = 0x1
	// Bit EIE.
	USART_CR3_EIE = 0x1

	// BRR: Baud rate register
	// Position of BRR_4_15 field.
	USART_BRR_BRR_4_15_Pos = 0x4
	// Bit mask of BRR_4_15 field.
	USART_BRR_BRR_4_15_Msk = 0xfff0
	// Position of BRR_0_3 field.
	USART_BRR_BRR_0_3_Pos = 0x0
	// Bit mask of BRR_0_3 field.
	USART_BRR_BRR_0_3_Msk = 0xf

	// GTPR: Guard time and prescaler register
	// Position of GT field.
	USART_GTPR_GT_Pos = 0x8
	// Bit mask of GT field.
	USART_GTPR_GT_Msk = 0xff00
	// Position of PSC field.
	USART_GTPR_PSC_Pos = 0x0
	// Bit mask of PSC field.
	USART_GTPR_PSC_Msk = 0xff

	// RTOR: Receiver timeout register
	// Position of BLEN field.
	USART_RTOR_BLEN_Pos = 0x18
	// Bit mask of BLEN field.
	USART_RTOR_BLEN_Msk = 0xff000000
	// Position of RTO field.
	USART_RTOR_RTO_Pos = 0x0
	// Bit mask of RTO field.
	USART_RTOR_RTO_Msk = 0xffffff

	// RQR: Request register
	// Position of TXFRQ field.
	USART_RQR_TXFRQ_Pos = 0x4
	// Bit mask of TXFRQ field.
	USART_RQR_TXFRQ_Msk = 0x10
	// Bit TXFRQ.
	USART_RQR_TXFRQ = 0x10
	// Position of RXFRQ field.
	USART_RQR_RXFRQ_Pos = 0x3
	// Bit mask of RXFRQ field.
	USART_RQR_RXFRQ_Msk = 0x8
	// Bit RXFRQ.
	USART_RQR_RXFRQ = 0x8
	// Position of MMRQ field.
	USART_RQR_MMRQ_Pos = 0x2
	// Bit mask of MMRQ field.
	USART_RQR_MMRQ_Msk = 0x4
	// Bit MMRQ.
	USART_RQR_MMRQ = 0x4
	// Position of SBKRQ field.
	USART_RQR_SBKRQ_Pos = 0x1
	// Bit mask of SBKRQ field.
	USART_RQR_SBKRQ_Msk = 0x2
	// Bit SBKRQ.
	USART_RQR_SBKRQ = 0x2
	// Position of ABRRQ field.
	USART_RQR_ABRRQ_Pos = 0x0
	// Bit mask of ABRRQ field.
	USART_RQR_ABRRQ_Msk = 0x1
	// Bit ABRRQ.
	USART_RQR_ABRRQ = 0x1

	// ISR: Interrupt & status register
	// Position of TXFT field.
	USART_ISR_TXFT_Pos = 0x1b
	// Bit mask of TXFT field.
	USART_ISR_TXFT_Msk = 0x8000000
	// Bit TXFT.
	USART_ISR_TXFT = 0x8000000
	// Position of RXFT field.
	USART_ISR_RXFT_Pos = 0x1a
	// Bit mask of RXFT field.
	USART_ISR_RXFT_Msk = 0x4000000
	// Bit RXFT.
	USART_ISR_RXFT = 0x4000000
	// Position of TCBGT field.
	USART_ISR_TCBGT_Pos = 0x19
	// Bit mask of TCBGT field.
	USART_ISR_TCBGT_Msk = 0x2000000
	// Bit TCBGT.
	USART_ISR_TCBGT = 0x2000000
	// Position of RXFF field.
	USART_ISR_RXFF_Pos = 0x18
	// Bit mask of RXFF field.
	USART_ISR_RXFF_Msk = 0x1000000
	// Bit RXFF.
	USART_ISR_RXFF = 0x1000000
	// Position of TXFE field.
	USART_ISR_TXFE_Pos = 0x17
	// Bit mask of TXFE field.
	USART_ISR_TXFE_Msk = 0x800000
	// Bit TXFE.
	USART_ISR_TXFE = 0x800000
	// Position of REACK field.
	USART_ISR_REACK_Pos = 0x16
	// Bit mask of REACK field.
	USART_ISR_REACK_Msk = 0x400000
	// Bit REACK.
	USART_ISR_REACK = 0x400000
	// Position of TEACK field.
	USART_ISR_TEACK_Pos = 0x15
	// Bit mask of TEACK field.
	USART_ISR_TEACK_Msk = 0x200000
	// Bit TEACK.
	USART_ISR_TEACK = 0x200000
	// Position of WUF field.
	USART_ISR_WUF_Pos = 0x14
	// Bit mask of WUF field.
	USART_ISR_WUF_Msk = 0x100000
	// Bit WUF.
	USART_ISR_WUF = 0x100000
	// Position of RWU field.
	USART_ISR_RWU_Pos = 0x13
	// Bit mask of RWU field.
	USART_ISR_RWU_Msk = 0x80000
	// Bit RWU.
	USART_ISR_RWU = 0x80000
	// Position of SBKF field.
	USART_ISR_SBKF_Pos = 0x12
	// Bit mask of SBKF field.
	USART_ISR_SBKF_Msk = 0x40000
	// Bit SBKF.
	USART_ISR_SBKF = 0x40000
	// Position of CMF field.
	USART_ISR_CMF_Pos = 0x11
	// Bit mask of CMF field.
	USART_ISR_CMF_Msk = 0x20000
	// Bit CMF.
	USART_ISR_CMF = 0x20000
	// Position of BUSY field.
	USART_ISR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	USART_ISR_BUSY_Msk = 0x10000
	// Bit BUSY.
	USART_ISR_BUSY = 0x10000
	// Position of ABRF field.
	USART_ISR_ABRF_Pos = 0xf
	// Bit mask of ABRF field.
	USART_ISR_ABRF_Msk = 0x8000
	// Bit ABRF.
	USART_ISR_ABRF = 0x8000
	// Position of ABRE field.
	USART_ISR_ABRE_Pos = 0xe
	// Bit mask of ABRE field.
	USART_ISR_ABRE_Msk = 0x4000
	// Bit ABRE.
	USART_ISR_ABRE = 0x4000
	// Position of UDR field.
	USART_ISR_UDR_Pos = 0xd
	// Bit mask of UDR field.
	USART_ISR_UDR_Msk = 0x2000
	// Bit UDR.
	USART_ISR_UDR = 0x2000
	// Position of EOBF field.
	USART_ISR_EOBF_Pos = 0xc
	// Bit mask of EOBF field.
	USART_ISR_EOBF_Msk = 0x1000
	// Bit EOBF.
	USART_ISR_EOBF = 0x1000
	// Position of RTOF field.
	USART_ISR_RTOF_Pos = 0xb
	// Bit mask of RTOF field.
	USART_ISR_RTOF_Msk = 0x800
	// Bit RTOF.
	USART_ISR_RTOF = 0x800
	// Position of CTS field.
	USART_ISR_CTS_Pos = 0xa
	// Bit mask of CTS field.
	USART_ISR_CTS_Msk = 0x400
	// Bit CTS.
	USART_ISR_CTS = 0x400
	// Position of CTSIF field.
	USART_ISR_CTSIF_Pos = 0x9
	// Bit mask of CTSIF field.
	USART_ISR_CTSIF_Msk = 0x200
	// Bit CTSIF.
	USART_ISR_CTSIF = 0x200
	// Position of LBDF field.
	USART_ISR_LBDF_Pos = 0x8
	// Bit mask of LBDF field.
	USART_ISR_LBDF_Msk = 0x100
	// Bit LBDF.
	USART_ISR_LBDF = 0x100
	// Position of TXE field.
	USART_ISR_TXE_Pos = 0x7
	// Bit mask of TXE field.
	USART_ISR_TXE_Msk = 0x80
	// Bit TXE.
	USART_ISR_TXE = 0x80
	// Position of TC field.
	USART_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	USART_ISR_TC_Msk = 0x40
	// Bit TC.
	USART_ISR_TC = 0x40
	// Position of RXNE field.
	USART_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	USART_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	USART_ISR_RXNE = 0x20
	// Position of IDLE field.
	USART_ISR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	USART_ISR_IDLE_Msk = 0x10
	// Bit IDLE.
	USART_ISR_IDLE = 0x10
	// Position of ORE field.
	USART_ISR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	USART_ISR_ORE_Msk = 0x8
	// Bit ORE.
	USART_ISR_ORE = 0x8
	// Position of NF field.
	USART_ISR_NF_Pos = 0x2
	// Bit mask of NF field.
	USART_ISR_NF_Msk = 0x4
	// Bit NF.
	USART_ISR_NF = 0x4
	// Position of FE field.
	USART_ISR_FE_Pos = 0x1
	// Bit mask of FE field.
	USART_ISR_FE_Msk = 0x2
	// Bit FE.
	USART_ISR_FE = 0x2
	// Position of PE field.
	USART_ISR_PE_Pos = 0x0
	// Bit mask of PE field.
	USART_ISR_PE_Msk = 0x1
	// Bit PE.
	USART_ISR_PE = 0x1

	// ICR: Interrupt flag clear register
	// Position of WUCF field.
	USART_ICR_WUCF_Pos = 0x14
	// Bit mask of WUCF field.
	USART_ICR_WUCF_Msk = 0x100000
	// Bit WUCF.
	USART_ICR_WUCF = 0x100000
	// Position of CMCF field.
	USART_ICR_CMCF_Pos = 0x11
	// Bit mask of CMCF field.
	USART_ICR_CMCF_Msk = 0x20000
	// Bit CMCF.
	USART_ICR_CMCF = 0x20000
	// Position of UDRCF field.
	USART_ICR_UDRCF_Pos = 0xd
	// Bit mask of UDRCF field.
	USART_ICR_UDRCF_Msk = 0x2000
	// Bit UDRCF.
	USART_ICR_UDRCF = 0x2000
	// Position of EOBCF field.
	USART_ICR_EOBCF_Pos = 0xc
	// Bit mask of EOBCF field.
	USART_ICR_EOBCF_Msk = 0x1000
	// Bit EOBCF.
	USART_ICR_EOBCF = 0x1000
	// Position of RTOCF field.
	USART_ICR_RTOCF_Pos = 0xb
	// Bit mask of RTOCF field.
	USART_ICR_RTOCF_Msk = 0x800
	// Bit RTOCF.
	USART_ICR_RTOCF = 0x800
	// Position of CTSCF field.
	USART_ICR_CTSCF_Pos = 0x9
	// Bit mask of CTSCF field.
	USART_ICR_CTSCF_Msk = 0x200
	// Bit CTSCF.
	USART_ICR_CTSCF = 0x200
	// Position of LBDCF field.
	USART_ICR_LBDCF_Pos = 0x8
	// Bit mask of LBDCF field.
	USART_ICR_LBDCF_Msk = 0x100
	// Bit LBDCF.
	USART_ICR_LBDCF = 0x100
	// Position of TCBGTCF field.
	USART_ICR_TCBGTCF_Pos = 0x7
	// Bit mask of TCBGTCF field.
	USART_ICR_TCBGTCF_Msk = 0x80
	// Bit TCBGTCF.
	USART_ICR_TCBGTCF = 0x80
	// Position of TCCF field.
	USART_ICR_TCCF_Pos = 0x6
	// Bit mask of TCCF field.
	USART_ICR_TCCF_Msk = 0x40
	// Bit TCCF.
	USART_ICR_TCCF = 0x40
	// Position of TXFECF field.
	USART_ICR_TXFECF_Pos = 0x5
	// Bit mask of TXFECF field.
	USART_ICR_TXFECF_Msk = 0x20
	// Bit TXFECF.
	USART_ICR_TXFECF = 0x20
	// Position of IDLECF field.
	USART_ICR_IDLECF_Pos = 0x4
	// Bit mask of IDLECF field.
	USART_ICR_IDLECF_Msk = 0x10
	// Bit IDLECF.
	USART_ICR_IDLECF = 0x10
	// Position of ORECF field.
	USART_ICR_ORECF_Pos = 0x3
	// Bit mask of ORECF field.
	USART_ICR_ORECF_Msk = 0x8
	// Bit ORECF.
	USART_ICR_ORECF = 0x8
	// Position of NCF field.
	USART_ICR_NCF_Pos = 0x2
	// Bit mask of NCF field.
	USART_ICR_NCF_Msk = 0x4
	// Bit NCF.
	USART_ICR_NCF = 0x4
	// Position of FECF field.
	USART_ICR_FECF_Pos = 0x1
	// Bit mask of FECF field.
	USART_ICR_FECF_Msk = 0x2
	// Bit FECF.
	USART_ICR_FECF = 0x2
	// Position of PECF field.
	USART_ICR_PECF_Pos = 0x0
	// Bit mask of PECF field.
	USART_ICR_PECF_Msk = 0x1
	// Bit PECF.
	USART_ICR_PECF = 0x1

	// RDR: Receive data register
	// Position of RDR field.
	USART_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	USART_RDR_RDR_Msk = 0x1ff

	// TDR: Transmit data register
	// Position of TDR field.
	USART_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	USART_TDR_TDR_Msk = 0x1ff

	// PRESC: Prescaler register
	// Position of PRESCALER field.
	USART_PRESC_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	USART_PRESC_PRESCALER_Msk = 0xf
)

// Constants for SPI1: Serial peripheral interface/Inter-IC sound
const (
	// CR1: control register 1
	// Position of BIDIMODE field.
	SPI_CR1_BIDIMODE_Pos = 0xf
	// Bit mask of BIDIMODE field.
	SPI_CR1_BIDIMODE_Msk = 0x8000
	// Bit BIDIMODE.
	SPI_CR1_BIDIMODE = 0x8000
	// Position of BIDIOE field.
	SPI_CR1_BIDIOE_Pos = 0xe
	// Bit mask of BIDIOE field.
	SPI_CR1_BIDIOE_Msk = 0x4000
	// Bit BIDIOE.
	SPI_CR1_BIDIOE = 0x4000
	// Position of CRCEN field.
	SPI_CR1_CRCEN_Pos = 0xd
	// Bit mask of CRCEN field.
	SPI_CR1_CRCEN_Msk = 0x2000
	// Bit CRCEN.
	SPI_CR1_CRCEN = 0x2000
	// Position of CRCNEXT field.
	SPI_CR1_CRCNEXT_Pos = 0xc
	// Bit mask of CRCNEXT field.
	SPI_CR1_CRCNEXT_Msk = 0x1000
	// Bit CRCNEXT.
	SPI_CR1_CRCNEXT = 0x1000
	// Position of DFF field.
	SPI_CR1_DFF_Pos = 0xb
	// Bit mask of DFF field.
	SPI_CR1_DFF_Msk = 0x800
	// Bit DFF.
	SPI_CR1_DFF = 0x800
	// Position of RXONLY field.
	SPI_CR1_RXONLY_Pos = 0xa
	// Bit mask of RXONLY field.
	SPI_CR1_RXONLY_Msk = 0x400
	// Bit RXONLY.
	SPI_CR1_RXONLY = 0x400
	// Position of SSM field.
	SPI_CR1_SSM_Pos = 0x9
	// Bit mask of SSM field.
	SPI_CR1_SSM_Msk = 0x200
	// Bit SSM.
	SPI_CR1_SSM = 0x200
	// Position of SSI field.
	SPI_CR1_SSI_Pos = 0x8
	// Bit mask of SSI field.
	SPI_CR1_SSI_Msk = 0x100
	// Bit SSI.
	SPI_CR1_SSI = 0x100
	// Position of LSBFIRST field.
	SPI_CR1_LSBFIRST_Pos = 0x7
	// Bit mask of LSBFIRST field.
	SPI_CR1_LSBFIRST_Msk = 0x80
	// Bit LSBFIRST.
	SPI_CR1_LSBFIRST = 0x80
	// Position of SPE field.
	SPI_CR1_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI_CR1_SPE_Msk = 0x40
	// Bit SPE.
	SPI_CR1_SPE = 0x40
	// Position of BR field.
	SPI_CR1_BR_Pos = 0x3
	// Bit mask of BR field.
	SPI_CR1_BR_Msk = 0x38
	// Position of MSTR field.
	SPI_CR1_MSTR_Pos = 0x2
	// Bit mask of MSTR field.
	SPI_CR1_MSTR_Msk = 0x4
	// Bit MSTR.
	SPI_CR1_MSTR = 0x4
	// Position of CPOL field.
	SPI_CR1_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI_CR1_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI_CR1_CPOL = 0x2
	// Position of CPHA field.
	SPI_CR1_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI_CR1_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI_CR1_CPHA = 0x1

	// CR2: control register 2
	// Position of RXDMAEN field.
	SPI_CR2_RXDMAEN_Pos = 0x0
	// Bit mask of RXDMAEN field.
	SPI_CR2_RXDMAEN_Msk = 0x1
	// Bit RXDMAEN.
	SPI_CR2_RXDMAEN = 0x1
	// Position of TXDMAEN field.
	SPI_CR2_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	SPI_CR2_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	SPI_CR2_TXDMAEN = 0x2
	// Position of SSOE field.
	SPI_CR2_SSOE_Pos = 0x2
	// Bit mask of SSOE field.
	SPI_CR2_SSOE_Msk = 0x4
	// Bit SSOE.
	SPI_CR2_SSOE = 0x4
	// Position of NSSP field.
	SPI_CR2_NSSP_Pos = 0x3
	// Bit mask of NSSP field.
	SPI_CR2_NSSP_Msk = 0x8
	// Bit NSSP.
	SPI_CR2_NSSP = 0x8
	// Position of FRF field.
	SPI_CR2_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SPI_CR2_FRF_Msk = 0x10
	// Bit FRF.
	SPI_CR2_FRF = 0x10
	// Position of ERRIE field.
	SPI_CR2_ERRIE_Pos = 0x5
	// Bit mask of ERRIE field.
	SPI_CR2_ERRIE_Msk = 0x20
	// Bit ERRIE.
	SPI_CR2_ERRIE = 0x20
	// Position of RXNEIE field.
	SPI_CR2_RXNEIE_Pos = 0x6
	// Bit mask of RXNEIE field.
	SPI_CR2_RXNEIE_Msk = 0x40
	// Bit RXNEIE.
	SPI_CR2_RXNEIE = 0x40
	// Position of TXEIE field.
	SPI_CR2_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	SPI_CR2_TXEIE_Msk = 0x80
	// Bit TXEIE.
	SPI_CR2_TXEIE = 0x80
	// Position of DS field.
	SPI_CR2_DS_Pos = 0x8
	// Bit mask of DS field.
	SPI_CR2_DS_Msk = 0xf00
	// Position of FRXTH field.
	SPI_CR2_FRXTH_Pos = 0xc
	// Bit mask of FRXTH field.
	SPI_CR2_FRXTH_Msk = 0x1000
	// Bit FRXTH.
	SPI_CR2_FRXTH = 0x1000
	// Position of LDMA_RX field.
	SPI_CR2_LDMA_RX_Pos = 0xd
	// Bit mask of LDMA_RX field.
	SPI_CR2_LDMA_RX_Msk = 0x2000
	// Bit LDMA_RX.
	SPI_CR2_LDMA_RX = 0x2000
	// Position of LDMA_TX field.
	SPI_CR2_LDMA_TX_Pos = 0xe
	// Bit mask of LDMA_TX field.
	SPI_CR2_LDMA_TX_Msk = 0x4000
	// Bit LDMA_TX.
	SPI_CR2_LDMA_TX = 0x4000

	// SR: status register
	// Position of RXNE field.
	SPI_SR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPI_SR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPI_SR_RXNE = 0x1
	// Position of TXE field.
	SPI_SR_TXE_Pos = 0x1
	// Bit mask of TXE field.
	SPI_SR_TXE_Msk = 0x2
	// Bit TXE.
	SPI_SR_TXE = 0x2
	// Position of CHSIDE field.
	SPI_SR_CHSIDE_Pos = 0x2
	// Bit mask of CHSIDE field.
	SPI_SR_CHSIDE_Msk = 0x4
	// Bit CHSIDE.
	SPI_SR_CHSIDE = 0x4
	// Position of UDR field.
	SPI_SR_UDR_Pos = 0x3
	// Bit mask of UDR field.
	SPI_SR_UDR_Msk = 0x8
	// Bit UDR.
	SPI_SR_UDR = 0x8
	// Position of CRCERR field.
	SPI_SR_CRCERR_Pos = 0x4
	// Bit mask of CRCERR field.
	SPI_SR_CRCERR_Msk = 0x10
	// Bit CRCERR.
	SPI_SR_CRCERR = 0x10
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x5
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x20
	// Bit MODF.
	SPI_SR_MODF = 0x20
	// Position of OVR field.
	SPI_SR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	SPI_SR_OVR_Msk = 0x40
	// Bit OVR.
	SPI_SR_OVR = 0x40
	// Position of BSY field.
	SPI_SR_BSY_Pos = 0x7
	// Bit mask of BSY field.
	SPI_SR_BSY_Msk = 0x80
	// Bit BSY.
	SPI_SR_BSY = 0x80
	// Position of TIFRFE field.
	SPI_SR_TIFRFE_Pos = 0x8
	// Bit mask of TIFRFE field.
	SPI_SR_TIFRFE_Msk = 0x100
	// Bit TIFRFE.
	SPI_SR_TIFRFE = 0x100
	// Position of FRLVL field.
	SPI_SR_FRLVL_Pos = 0x9
	// Bit mask of FRLVL field.
	SPI_SR_FRLVL_Msk = 0x600
	// Position of FTLVL field.
	SPI_SR_FTLVL_Pos = 0xb
	// Bit mask of FTLVL field.
	SPI_SR_FTLVL_Msk = 0x1800

	// DR: data register
	// Position of DR field.
	SPI_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	SPI_DR_DR_Msk = 0xffff

	// CRCPR: CRC polynomial register
	// Position of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Msk = 0xffff

	// RXCRCR: RX CRC register
	// Position of RxCRC field.
	SPI_RXCRCR_RxCRC_Pos = 0x0
	// Bit mask of RxCRC field.
	SPI_RXCRCR_RxCRC_Msk = 0xffff

	// TXCRCR: TX CRC register
	// Position of TxCRC field.
	SPI_TXCRCR_TxCRC_Pos = 0x0
	// Bit mask of TxCRC field.
	SPI_TXCRCR_TxCRC_Msk = 0xffff

	// I2SCFGR: configuration register
	// Position of CHLEN field.
	SPI_I2SCFGR_CHLEN_Pos = 0x0
	// Bit mask of CHLEN field.
	SPI_I2SCFGR_CHLEN_Msk = 0x1
	// Bit CHLEN.
	SPI_I2SCFGR_CHLEN = 0x1
	// Position of DATLEN field.
	SPI_I2SCFGR_DATLEN_Pos = 0x1
	// Bit mask of DATLEN field.
	SPI_I2SCFGR_DATLEN_Msk = 0x6
	// Position of CKPOL field.
	SPI_I2SCFGR_CKPOL_Pos = 0x3
	// Bit mask of CKPOL field.
	SPI_I2SCFGR_CKPOL_Msk = 0x8
	// Bit CKPOL.
	SPI_I2SCFGR_CKPOL = 0x8
	// Position of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Pos = 0x4
	// Bit mask of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Msk = 0x30
	// Position of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Pos = 0x7
	// Bit mask of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Msk = 0x80
	// Bit PCMSYNC.
	SPI_I2SCFGR_PCMSYNC = 0x80
	// Position of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Pos = 0x8
	// Bit mask of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Msk = 0x300
	// Position of SE2 field.
	SPI_I2SCFGR_SE2_Pos = 0xa
	// Bit mask of SE2 field.
	SPI_I2SCFGR_SE2_Msk = 0x400
	// Bit SE2.
	SPI_I2SCFGR_SE2 = 0x400
	// Position of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Pos = 0xb
	// Bit mask of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Msk = 0x800
	// Bit I2SMOD.
	SPI_I2SCFGR_I2SMOD = 0x800

	// I2SPR: prescaler register
	// Position of I2SDIV field.
	SPI_I2SPR_I2SDIV_Pos = 0x0
	// Bit mask of I2SDIV field.
	SPI_I2SPR_I2SDIV_Msk = 0xff
	// Position of ODD field.
	SPI_I2SPR_ODD_Pos = 0x8
	// Bit mask of ODD field.
	SPI_I2SPR_ODD_Msk = 0x100
	// Bit ODD.
	SPI_I2SPR_ODD = 0x100
	// Position of MCKOE field.
	SPI_I2SPR_MCKOE_Pos = 0x9
	// Bit mask of MCKOE field.
	SPI_I2SPR_MCKOE_Msk = 0x200
	// Bit MCKOE.
	SPI_I2SPR_MCKOE = 0x200

	// HWCFGR: hardware configuration register
	// Position of CRCCFG field.
	SPI_HWCFGR_CRCCFG_Pos = 0x0
	// Bit mask of CRCCFG field.
	SPI_HWCFGR_CRCCFG_Msk = 0xf
	// Position of I2SCFG field.
	SPI_HWCFGR_I2SCFG_Pos = 0x4
	// Bit mask of I2SCFG field.
	SPI_HWCFGR_I2SCFG_Msk = 0xf0
	// Position of I2SCKCFG field.
	SPI_HWCFGR_I2SCKCFG_Pos = 0x8
	// Bit mask of I2SCKCFG field.
	SPI_HWCFGR_I2SCKCFG_Msk = 0xf00
	// Position of DSCFG field.
	SPI_HWCFGR_DSCFG_Pos = 0xc
	// Bit mask of DSCFG field.
	SPI_HWCFGR_DSCFG_Msk = 0xf000
	// Position of NSSCFG field.
	SPI_HWCFGR_NSSCFG_Pos = 0x10
	// Bit mask of NSSCFG field.
	SPI_HWCFGR_NSSCFG_Msk = 0xf0000

	// VERR: EXTI IP Version register
	// Position of MINREV field.
	SPI_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	SPI_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	SPI_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	SPI_VERR_MAJREV_Msk = 0xf0

	// IPIDR: EXTI Identification register
	// Position of IPID field.
	SPI_IPIDR_IPID_Pos = 0x0
	// Bit mask of IPID field.
	SPI_IPIDR_IPID_Msk = 0xffffffff

	// SIDR: EXTI Size ID register
	// Position of SID field.
	SPI_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	SPI_SIDR_SID_Msk = 0xffffffff
)

// Constants for ADC: Analog to Digital Converter instance 1
const (
	// ISR: ADC interrupt and status register
	// Position of CCRDY field.
	ADC_ISR_CCRDY_Pos = 0xd
	// Bit mask of CCRDY field.
	ADC_ISR_CCRDY_Msk = 0x2000
	// Bit CCRDY.
	ADC_ISR_CCRDY = 0x2000
	// Position of EOCAL field.
	ADC_ISR_EOCAL_Pos = 0xb
	// Bit mask of EOCAL field.
	ADC_ISR_EOCAL_Msk = 0x800
	// Bit EOCAL.
	ADC_ISR_EOCAL = 0x800
	// Position of AWD3 field.
	ADC_ISR_AWD3_Pos = 0x9
	// Bit mask of AWD3 field.
	ADC_ISR_AWD3_Msk = 0x200
	// Bit AWD3.
	ADC_ISR_AWD3 = 0x200
	// Position of AWD2 field.
	ADC_ISR_AWD2_Pos = 0x8
	// Bit mask of AWD2 field.
	ADC_ISR_AWD2_Msk = 0x100
	// Bit AWD2.
	ADC_ISR_AWD2 = 0x100
	// Position of AWD1 field.
	ADC_ISR_AWD1_Pos = 0x7
	// Bit mask of AWD1 field.
	ADC_ISR_AWD1_Msk = 0x80
	// Bit AWD1.
	ADC_ISR_AWD1 = 0x80
	// Position of OVR field.
	ADC_ISR_OVR_Pos = 0x4
	// Bit mask of OVR field.
	ADC_ISR_OVR_Msk = 0x10
	// Bit OVR.
	ADC_ISR_OVR = 0x10
	// Position of EOS field.
	ADC_ISR_EOS_Pos = 0x3
	// Bit mask of EOS field.
	ADC_ISR_EOS_Msk = 0x8
	// Bit EOS.
	ADC_ISR_EOS = 0x8
	// Position of EOC field.
	ADC_ISR_EOC_Pos = 0x2
	// Bit mask of EOC field.
	ADC_ISR_EOC_Msk = 0x4
	// Bit EOC.
	ADC_ISR_EOC = 0x4
	// Position of EOSMP field.
	ADC_ISR_EOSMP_Pos = 0x1
	// Bit mask of EOSMP field.
	ADC_ISR_EOSMP_Msk = 0x2
	// Bit EOSMP.
	ADC_ISR_EOSMP = 0x2
	// Position of ADRDY field.
	ADC_ISR_ADRDY_Pos = 0x0
	// Bit mask of ADRDY field.
	ADC_ISR_ADRDY_Msk = 0x1
	// Bit ADRDY.
	ADC_ISR_ADRDY = 0x1

	// IER: ADC interrupt enable register
	// Position of CCRDYIE field.
	ADC_IER_CCRDYIE_Pos = 0xd
	// Bit mask of CCRDYIE field.
	ADC_IER_CCRDYIE_Msk = 0x2000
	// Bit CCRDYIE.
	ADC_IER_CCRDYIE = 0x2000
	// Position of EOCALIE field.
	ADC_IER_EOCALIE_Pos = 0xb
	// Bit mask of EOCALIE field.
	ADC_IER_EOCALIE_Msk = 0x800
	// Bit EOCALIE.
	ADC_IER_EOCALIE = 0x800
	// Position of AWD3IE field.
	ADC_IER_AWD3IE_Pos = 0x9
	// Bit mask of AWD3IE field.
	ADC_IER_AWD3IE_Msk = 0x200
	// Bit AWD3IE.
	ADC_IER_AWD3IE = 0x200
	// Position of AWD2IE field.
	ADC_IER_AWD2IE_Pos = 0x8
	// Bit mask of AWD2IE field.
	ADC_IER_AWD2IE_Msk = 0x100
	// Bit AWD2IE.
	ADC_IER_AWD2IE = 0x100
	// Position of AWD1IE field.
	ADC_IER_AWD1IE_Pos = 0x7
	// Bit mask of AWD1IE field.
	ADC_IER_AWD1IE_Msk = 0x80
	// Bit AWD1IE.
	ADC_IER_AWD1IE = 0x80
	// Position of OVRIE field.
	ADC_IER_OVRIE_Pos = 0x4
	// Bit mask of OVRIE field.
	ADC_IER_OVRIE_Msk = 0x10
	// Bit OVRIE.
	ADC_IER_OVRIE = 0x10
	// Position of EOSIE field.
	ADC_IER_EOSIE_Pos = 0x3
	// Bit mask of EOSIE field.
	ADC_IER_EOSIE_Msk = 0x8
	// Bit EOSIE.
	ADC_IER_EOSIE = 0x8
	// Position of EOCIE field.
	ADC_IER_EOCIE_Pos = 0x2
	// Bit mask of EOCIE field.
	ADC_IER_EOCIE_Msk = 0x4
	// Bit EOCIE.
	ADC_IER_EOCIE = 0x4
	// Position of EOSMPIE field.
	ADC_IER_EOSMPIE_Pos = 0x1
	// Bit mask of EOSMPIE field.
	ADC_IER_EOSMPIE_Msk = 0x2
	// Bit EOSMPIE.
	ADC_IER_EOSMPIE = 0x2
	// Position of ADRDYIE field.
	ADC_IER_ADRDYIE_Pos = 0x0
	// Bit mask of ADRDYIE field.
	ADC_IER_ADRDYIE_Msk = 0x1
	// Bit ADRDYIE.
	ADC_IER_ADRDYIE = 0x1

	// CR: ADC control register
	// Position of ADCAL field.
	ADC_CR_ADCAL_Pos = 0x1f
	// Bit mask of ADCAL field.
	ADC_CR_ADCAL_Msk = 0x80000000
	// Bit ADCAL.
	ADC_CR_ADCAL = 0x80000000
	// Position of ADVREGEN field.
	ADC_CR_ADVREGEN_Pos = 0x1c
	// Bit mask of ADVREGEN field.
	ADC_CR_ADVREGEN_Msk = 0x10000000
	// Bit ADVREGEN.
	ADC_CR_ADVREGEN = 0x10000000
	// Position of ADSTP field.
	ADC_CR_ADSTP_Pos = 0x4
	// Bit mask of ADSTP field.
	ADC_CR_ADSTP_Msk = 0x10
	// Bit ADSTP.
	ADC_CR_ADSTP = 0x10
	// Position of ADSTART field.
	ADC_CR_ADSTART_Pos = 0x2
	// Bit mask of ADSTART field.
	ADC_CR_ADSTART_Msk = 0x4
	// Bit ADSTART.
	ADC_CR_ADSTART = 0x4
	// Position of ADDIS field.
	ADC_CR_ADDIS_Pos = 0x1
	// Bit mask of ADDIS field.
	ADC_CR_ADDIS_Msk = 0x2
	// Bit ADDIS.
	ADC_CR_ADDIS = 0x2
	// Position of ADEN field.
	ADC_CR_ADEN_Pos = 0x0
	// Bit mask of ADEN field.
	ADC_CR_ADEN_Msk = 0x1
	// Bit ADEN.
	ADC_CR_ADEN = 0x1

	// CFGR1: ADC configuration register 1
	// Position of AWDCH1CH field.
	ADC_CFGR1_AWDCH1CH_Pos = 0x1a
	// Bit mask of AWDCH1CH field.
	ADC_CFGR1_AWDCH1CH_Msk = 0x7c000000
	// Position of AWD1EN field.
	ADC_CFGR1_AWD1EN_Pos = 0x17
	// Bit mask of AWD1EN field.
	ADC_CFGR1_AWD1EN_Msk = 0x800000
	// Bit AWD1EN.
	ADC_CFGR1_AWD1EN = 0x800000
	// Position of AWD1SGL field.
	ADC_CFGR1_AWD1SGL_Pos = 0x16
	// Bit mask of AWD1SGL field.
	ADC_CFGR1_AWD1SGL_Msk = 0x400000
	// Bit AWD1SGL.
	ADC_CFGR1_AWD1SGL = 0x400000
	// Position of CHSELRMOD field.
	ADC_CFGR1_CHSELRMOD_Pos = 0x15
	// Bit mask of CHSELRMOD field.
	ADC_CFGR1_CHSELRMOD_Msk = 0x200000
	// Bit CHSELRMOD.
	ADC_CFGR1_CHSELRMOD = 0x200000
	// Position of DISCEN field.
	ADC_CFGR1_DISCEN_Pos = 0x10
	// Bit mask of DISCEN field.
	ADC_CFGR1_DISCEN_Msk = 0x10000
	// Bit DISCEN.
	ADC_CFGR1_DISCEN = 0x10000
	// Position of AUTOFF field.
	ADC_CFGR1_AUTOFF_Pos = 0xf
	// Bit mask of AUTOFF field.
	ADC_CFGR1_AUTOFF_Msk = 0x8000
	// Bit AUTOFF.
	ADC_CFGR1_AUTOFF = 0x8000
	// Position of WAIT field.
	ADC_CFGR1_WAIT_Pos = 0xe
	// Bit mask of WAIT field.
	ADC_CFGR1_WAIT_Msk = 0x4000
	// Bit WAIT.
	ADC_CFGR1_WAIT = 0x4000
	// Position of CONT field.
	ADC_CFGR1_CONT_Pos = 0xd
	// Bit mask of CONT field.
	ADC_CFGR1_CONT_Msk = 0x2000
	// Bit CONT.
	ADC_CFGR1_CONT = 0x2000
	// Position of OVRMOD field.
	ADC_CFGR1_OVRMOD_Pos = 0xc
	// Bit mask of OVRMOD field.
	ADC_CFGR1_OVRMOD_Msk = 0x1000
	// Bit OVRMOD.
	ADC_CFGR1_OVRMOD = 0x1000
	// Position of EXTEN field.
	ADC_CFGR1_EXTEN_Pos = 0xa
	// Bit mask of EXTEN field.
	ADC_CFGR1_EXTEN_Msk = 0xc00
	// Position of EXTSEL field.
	ADC_CFGR1_EXTSEL_Pos = 0x6
	// Bit mask of EXTSEL field.
	ADC_CFGR1_EXTSEL_Msk = 0x1c0
	// Position of ALIGN field.
	ADC_CFGR1_ALIGN_Pos = 0x5
	// Bit mask of ALIGN field.
	ADC_CFGR1_ALIGN_Msk = 0x20
	// Bit ALIGN.
	ADC_CFGR1_ALIGN = 0x20
	// Position of RES field.
	ADC_CFGR1_RES_Pos = 0x3
	// Bit mask of RES field.
	ADC_CFGR1_RES_Msk = 0x18
	// Position of SCANDIR field.
	ADC_CFGR1_SCANDIR_Pos = 0x2
	// Bit mask of SCANDIR field.
	ADC_CFGR1_SCANDIR_Msk = 0x4
	// Bit SCANDIR.
	ADC_CFGR1_SCANDIR = 0x4
	// Position of DMACFG field.
	ADC_CFGR1_DMACFG_Pos = 0x1
	// Bit mask of DMACFG field.
	ADC_CFGR1_DMACFG_Msk = 0x2
	// Bit DMACFG.
	ADC_CFGR1_DMACFG = 0x2
	// Position of DMAEN field.
	ADC_CFGR1_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	ADC_CFGR1_DMAEN_Msk = 0x1
	// Bit DMAEN.
	ADC_CFGR1_DMAEN = 0x1

	// CFGR2: ADC configuration register 2
	// Position of CKMODE field.
	ADC_CFGR2_CKMODE_Pos = 0x1e
	// Bit mask of CKMODE field.
	ADC_CFGR2_CKMODE_Msk = 0xc0000000
	// Position of LFTRIG field.
	ADC_CFGR2_LFTRIG_Pos = 0x1d
	// Bit mask of LFTRIG field.
	ADC_CFGR2_LFTRIG_Msk = 0x20000000
	// Bit LFTRIG.
	ADC_CFGR2_LFTRIG = 0x20000000
	// Position of TOVS field.
	ADC_CFGR2_TOVS_Pos = 0x9
	// Bit mask of TOVS field.
	ADC_CFGR2_TOVS_Msk = 0x200
	// Bit TOVS.
	ADC_CFGR2_TOVS = 0x200
	// Position of OVSS field.
	ADC_CFGR2_OVSS_Pos = 0x5
	// Bit mask of OVSS field.
	ADC_CFGR2_OVSS_Msk = 0x1e0
	// Position of OVSR field.
	ADC_CFGR2_OVSR_Pos = 0x2
	// Bit mask of OVSR field.
	ADC_CFGR2_OVSR_Msk = 0x1c
	// Position of OVSE field.
	ADC_CFGR2_OVSE_Pos = 0x0
	// Bit mask of OVSE field.
	ADC_CFGR2_OVSE_Msk = 0x1
	// Bit OVSE.
	ADC_CFGR2_OVSE = 0x1

	// SMPR: ADC sampling time register
	// Position of SMP1 field.
	ADC_SMPR_SMP1_Pos = 0x0
	// Bit mask of SMP1 field.
	ADC_SMPR_SMP1_Msk = 0x7
	// Position of SMP2 field.
	ADC_SMPR_SMP2_Pos = 0x4
	// Bit mask of SMP2 field.
	ADC_SMPR_SMP2_Msk = 0x70
	// Position of SMPSEL field.
	ADC_SMPR_SMPSEL_Pos = 0x8
	// Bit mask of SMPSEL field.
	ADC_SMPR_SMPSEL_Msk = 0x7ffff00

	// AWD1TR: watchdog threshold register
	// Position of HT1 field.
	ADC_AWD1TR_HT1_Pos = 0x10
	// Bit mask of HT1 field.
	ADC_AWD1TR_HT1_Msk = 0xfff0000
	// Position of LT1 field.
	ADC_AWD1TR_LT1_Pos = 0x0
	// Bit mask of LT1 field.
	ADC_AWD1TR_LT1_Msk = 0xfff

	// AWD2TR: watchdog threshold register
	// Position of HT2 field.
	ADC_AWD2TR_HT2_Pos = 0x10
	// Bit mask of HT2 field.
	ADC_AWD2TR_HT2_Msk = 0xfff0000
	// Position of LT2 field.
	ADC_AWD2TR_LT2_Pos = 0x0
	// Bit mask of LT2 field.
	ADC_AWD2TR_LT2_Msk = 0xfff

	// CHSELR: channel selection register
	// Position of CHSEL field.
	ADC_CHSELR_CHSEL_Pos = 0x0
	// Bit mask of CHSEL field.
	ADC_CHSELR_CHSEL_Msk = 0x7ffff

	// CHSELR_1: channel selection register CHSELRMOD = 1 in ADC_CFGR1
	// Position of SQ1 field.
	ADC_CHSELR_1_SQ1_Pos = 0x0
	// Bit mask of SQ1 field.
	ADC_CHSELR_1_SQ1_Msk = 0xf
	// Position of SQ2 field.
	ADC_CHSELR_1_SQ2_Pos = 0x4
	// Bit mask of SQ2 field.
	ADC_CHSELR_1_SQ2_Msk = 0xf0
	// Position of SQ3 field.
	ADC_CHSELR_1_SQ3_Pos = 0x8
	// Bit mask of SQ3 field.
	ADC_CHSELR_1_SQ3_Msk = 0xf00
	// Position of SQ4 field.
	ADC_CHSELR_1_SQ4_Pos = 0xc
	// Bit mask of SQ4 field.
	ADC_CHSELR_1_SQ4_Msk = 0xf000
	// Position of SQ5 field.
	ADC_CHSELR_1_SQ5_Pos = 0x10
	// Bit mask of SQ5 field.
	ADC_CHSELR_1_SQ5_Msk = 0xf0000
	// Position of SQ6 field.
	ADC_CHSELR_1_SQ6_Pos = 0x14
	// Bit mask of SQ6 field.
	ADC_CHSELR_1_SQ6_Msk = 0xf00000
	// Position of SQ7 field.
	ADC_CHSELR_1_SQ7_Pos = 0x18
	// Bit mask of SQ7 field.
	ADC_CHSELR_1_SQ7_Msk = 0xf000000
	// Position of SQ8 field.
	ADC_CHSELR_1_SQ8_Pos = 0x1c
	// Bit mask of SQ8 field.
	ADC_CHSELR_1_SQ8_Msk = 0xf0000000

	// AWD3TR: watchdog threshold register
	// Position of HT3 field.
	ADC_AWD3TR_HT3_Pos = 0x10
	// Bit mask of HT3 field.
	ADC_AWD3TR_HT3_Msk = 0xfff0000
	// Position of LT3 field.
	ADC_AWD3TR_LT3_Pos = 0x0
	// Bit mask of LT3 field.
	ADC_AWD3TR_LT3_Msk = 0xfff

	// DR: ADC group regular conversion data register
	// Position of REGULARDATA field.
	ADC_DR_REGULARDATA_Pos = 0x0
	// Bit mask of REGULARDATA field.
	ADC_DR_REGULARDATA_Msk = 0xffff

	// AWD2CR: ADC analog watchdog 2 configuration register
	// Position of AWD2CH field.
	ADC_AWD2CR_AWD2CH_Pos = 0x0
	// Bit mask of AWD2CH field.
	ADC_AWD2CR_AWD2CH_Msk = 0x7ffff

	// AWD3CR: ADC analog watchdog 3 configuration register
	// Position of AWD3CH field.
	ADC_AWD3CR_AWD3CH_Pos = 0x0
	// Bit mask of AWD3CH field.
	ADC_AWD3CR_AWD3CH_Msk = 0x7ffff

	// CALFACT: ADC calibration factors register
	// Position of CALFACT field.
	ADC_CALFACT_CALFACT_Pos = 0x0
	// Bit mask of CALFACT field.
	ADC_CALFACT_CALFACT_Msk = 0x7f

	// CCR: ADC common control register
	// Position of PRESC field.
	ADC_CCR_PRESC_Pos = 0x12
	// Bit mask of PRESC field.
	ADC_CCR_PRESC_Msk = 0x3c0000
	// Position of VREFEN field.
	ADC_CCR_VREFEN_Pos = 0x16
	// Bit mask of VREFEN field.
	ADC_CCR_VREFEN_Msk = 0x400000
	// Bit VREFEN.
	ADC_CCR_VREFEN = 0x400000
	// Position of TSEN field.
	ADC_CCR_TSEN_Pos = 0x17
	// Bit mask of TSEN field.
	ADC_CCR_TSEN_Msk = 0x800000
	// Bit TSEN.
	ADC_CCR_TSEN = 0x800000
	// Position of VBATEN field.
	ADC_CCR_VBATEN_Pos = 0x18
	// Bit mask of VBATEN field.
	ADC_CCR_VBATEN_Msk = 0x1000000
	// Bit VBATEN.
	ADC_CCR_VBATEN = 0x1000000

	// HWCFGR6: Hardware Configuration Register
	// Position of CHMAP20 field.
	ADC_HWCFGR6_CHMAP20_Pos = 0x0
	// Bit mask of CHMAP20 field.
	ADC_HWCFGR6_CHMAP20_Msk = 0x1f
	// Position of CHMAP21 field.
	ADC_HWCFGR6_CHMAP21_Pos = 0x8
	// Bit mask of CHMAP21 field.
	ADC_HWCFGR6_CHMAP21_Msk = 0x1f00
	// Position of CHMAP22 field.
	ADC_HWCFGR6_CHMAP22_Pos = 0x10
	// Bit mask of CHMAP22 field.
	ADC_HWCFGR6_CHMAP22_Msk = 0x1f0000
	// Position of CHMAP23 field.
	ADC_HWCFGR6_CHMAP23_Pos = 0x18
	// Bit mask of CHMAP23 field.
	ADC_HWCFGR6_CHMAP23_Msk = 0x1f000000

	// HWCFGR5: Hardware Configuration Register
	// Position of CHMAP19 field.
	ADC_HWCFGR5_CHMAP19_Pos = 0x0
	// Bit mask of CHMAP19 field.
	ADC_HWCFGR5_CHMAP19_Msk = 0x1f
	// Position of CHMAP18 field.
	ADC_HWCFGR5_CHMAP18_Pos = 0x8
	// Bit mask of CHMAP18 field.
	ADC_HWCFGR5_CHMAP18_Msk = 0x1f00
	// Position of CHMAP17 field.
	ADC_HWCFGR5_CHMAP17_Pos = 0x10
	// Bit mask of CHMAP17 field.
	ADC_HWCFGR5_CHMAP17_Msk = 0x1f0000
	// Position of CHMAP16 field.
	ADC_HWCFGR5_CHMAP16_Pos = 0x18
	// Bit mask of CHMAP16 field.
	ADC_HWCFGR5_CHMAP16_Msk = 0x1f000000

	// HWCFGR4: Hardware Configuration Register
	// Position of CHMAP15 field.
	ADC_HWCFGR4_CHMAP15_Pos = 0x0
	// Bit mask of CHMAP15 field.
	ADC_HWCFGR4_CHMAP15_Msk = 0x1f
	// Position of CHMAP14 field.
	ADC_HWCFGR4_CHMAP14_Pos = 0x8
	// Bit mask of CHMAP14 field.
	ADC_HWCFGR4_CHMAP14_Msk = 0x1f00
	// Position of CHMAP13 field.
	ADC_HWCFGR4_CHMAP13_Pos = 0x10
	// Bit mask of CHMAP13 field.
	ADC_HWCFGR4_CHMAP13_Msk = 0x1f0000
	// Position of CHMAP12 field.
	ADC_HWCFGR4_CHMAP12_Pos = 0x18
	// Bit mask of CHMAP12 field.
	ADC_HWCFGR4_CHMAP12_Msk = 0x1f000000

	// HWCFGR3: Hardware Configuration Register
	// Position of CHMAP11 field.
	ADC_HWCFGR3_CHMAP11_Pos = 0x0
	// Bit mask of CHMAP11 field.
	ADC_HWCFGR3_CHMAP11_Msk = 0x1f
	// Position of CHMAP10 field.
	ADC_HWCFGR3_CHMAP10_Pos = 0x8
	// Bit mask of CHMAP10 field.
	ADC_HWCFGR3_CHMAP10_Msk = 0x1f00
	// Position of CHMAP9 field.
	ADC_HWCFGR3_CHMAP9_Pos = 0x10
	// Bit mask of CHMAP9 field.
	ADC_HWCFGR3_CHMAP9_Msk = 0x1f0000
	// Position of CHMAP8 field.
	ADC_HWCFGR3_CHMAP8_Pos = 0x18
	// Bit mask of CHMAP8 field.
	ADC_HWCFGR3_CHMAP8_Msk = 0x1f000000

	// HWCFGR2: Hardware Configuration Register
	// Position of CHMAP7 field.
	ADC_HWCFGR2_CHMAP7_Pos = 0x0
	// Bit mask of CHMAP7 field.
	ADC_HWCFGR2_CHMAP7_Msk = 0x1f
	// Position of CHMAP6 field.
	ADC_HWCFGR2_CHMAP6_Pos = 0x8
	// Bit mask of CHMAP6 field.
	ADC_HWCFGR2_CHMAP6_Msk = 0x1f00
	// Position of CHMAP5 field.
	ADC_HWCFGR2_CHMAP5_Pos = 0x10
	// Bit mask of CHMAP5 field.
	ADC_HWCFGR2_CHMAP5_Msk = 0x1f0000
	// Position of CHMAP4 field.
	ADC_HWCFGR2_CHMAP4_Pos = 0x18
	// Bit mask of CHMAP4 field.
	ADC_HWCFGR2_CHMAP4_Msk = 0x1f000000

	// HWCFGR1: Hardware Configuration Register
	// Position of CHMAP3 field.
	ADC_HWCFGR1_CHMAP3_Pos = 0x0
	// Bit mask of CHMAP3 field.
	ADC_HWCFGR1_CHMAP3_Msk = 0x1f
	// Position of CHMAP2 field.
	ADC_HWCFGR1_CHMAP2_Pos = 0x8
	// Bit mask of CHMAP2 field.
	ADC_HWCFGR1_CHMAP2_Msk = 0x1f00
	// Position of CHMAP1 field.
	ADC_HWCFGR1_CHMAP1_Pos = 0x10
	// Bit mask of CHMAP1 field.
	ADC_HWCFGR1_CHMAP1_Msk = 0x1f0000
	// Position of CHMAP0 field.
	ADC_HWCFGR1_CHMAP0_Pos = 0x18
	// Bit mask of CHMAP0 field.
	ADC_HWCFGR1_CHMAP0_Msk = 0x1f000000

	// HWCFGR0: Hardware Configuration Register
	// Position of NUM_CHAN_24 field.
	ADC_HWCFGR0_NUM_CHAN_24_Pos = 0x0
	// Bit mask of NUM_CHAN_24 field.
	ADC_HWCFGR0_NUM_CHAN_24_Msk = 0xf
	// Position of EXTRA_AWDS field.
	ADC_HWCFGR0_EXTRA_AWDS_Pos = 0x4
	// Bit mask of EXTRA_AWDS field.
	ADC_HWCFGR0_EXTRA_AWDS_Msk = 0xf0
	// Position of OVS field.
	ADC_HWCFGR0_OVS_Pos = 0x8
	// Bit mask of OVS field.
	ADC_HWCFGR0_OVS_Msk = 0xf00

	// VERR: EXTI IP Version register
	// Position of MINREV field.
	ADC_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	ADC_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	ADC_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	ADC_VERR_MAJREV_Msk = 0xf0

	// IPIDR: EXTI Identification register
	// Position of IPID field.
	ADC_IPIDR_IPID_Pos = 0x0
	// Bit mask of IPID field.
	ADC_IPIDR_IPID_Msk = 0xffffffff

	// SIDR: EXTI Size ID register
	// Position of SID field.
	ADC_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	ADC_SIDR_SID_Msk = 0xffffffff
)

// Constants for COMP: COMP1
const (
	// COMP1_CSR: Comparator 1 control and status register
	// Position of EN field.
	COMP1_COMP1_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	COMP1_COMP1_CSR_EN_Msk = 0x1
	// Bit EN.
	COMP1_COMP1_CSR_EN = 0x1
	// Position of INMSEL field.
	COMP1_COMP1_CSR_INMSEL_Pos = 0x4
	// Bit mask of INMSEL field.
	COMP1_COMP1_CSR_INMSEL_Msk = 0xf0
	// Position of INPSEL field.
	COMP1_COMP1_CSR_INPSEL_Pos = 0x8
	// Bit mask of INPSEL field.
	COMP1_COMP1_CSR_INPSEL_Msk = 0x300
	// Position of WINMODE field.
	COMP1_COMP1_CSR_WINMODE_Pos = 0xb
	// Bit mask of WINMODE field.
	COMP1_COMP1_CSR_WINMODE_Msk = 0x800
	// Bit WINMODE.
	COMP1_COMP1_CSR_WINMODE = 0x800
	// Position of WINOUT field.
	COMP1_COMP1_CSR_WINOUT_Pos = 0xe
	// Bit mask of WINOUT field.
	COMP1_COMP1_CSR_WINOUT_Msk = 0x4000
	// Bit WINOUT.
	COMP1_COMP1_CSR_WINOUT = 0x4000
	// Position of POLARITY field.
	COMP1_COMP1_CSR_POLARITY_Pos = 0xf
	// Bit mask of POLARITY field.
	COMP1_COMP1_CSR_POLARITY_Msk = 0x8000
	// Bit POLARITY.
	COMP1_COMP1_CSR_POLARITY = 0x8000
	// Position of HYST field.
	COMP1_COMP1_CSR_HYST_Pos = 0x10
	// Bit mask of HYST field.
	COMP1_COMP1_CSR_HYST_Msk = 0x30000
	// Position of PWRMODE field.
	COMP1_COMP1_CSR_PWRMODE_Pos = 0x12
	// Bit mask of PWRMODE field.
	COMP1_COMP1_CSR_PWRMODE_Msk = 0xc0000
	// Position of BLANKSEL field.
	COMP1_COMP1_CSR_BLANKSEL_Pos = 0x14
	// Bit mask of BLANKSEL field.
	COMP1_COMP1_CSR_BLANKSEL_Msk = 0x1f00000
	// Position of VALUE field.
	COMP1_COMP1_CSR_VALUE_Pos = 0x1e
	// Bit mask of VALUE field.
	COMP1_COMP1_CSR_VALUE_Msk = 0x40000000
	// Bit VALUE.
	COMP1_COMP1_CSR_VALUE = 0x40000000
	// Position of LOCK field.
	COMP1_COMP1_CSR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	COMP1_COMP1_CSR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	COMP1_COMP1_CSR_LOCK = 0x80000000

	// COMP2_CSR: Comparator 2 control and status register
	// Position of EN field.
	COMP1_COMP2_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	COMP1_COMP2_CSR_EN_Msk = 0x1
	// Bit EN.
	COMP1_COMP2_CSR_EN = 0x1
	// Position of INMSEL field.
	COMP1_COMP2_CSR_INMSEL_Pos = 0x4
	// Bit mask of INMSEL field.
	COMP1_COMP2_CSR_INMSEL_Msk = 0xf0
	// Position of INPSEL field.
	COMP1_COMP2_CSR_INPSEL_Pos = 0x8
	// Bit mask of INPSEL field.
	COMP1_COMP2_CSR_INPSEL_Msk = 0x300
	// Position of WINMODE field.
	COMP1_COMP2_CSR_WINMODE_Pos = 0xb
	// Bit mask of WINMODE field.
	COMP1_COMP2_CSR_WINMODE_Msk = 0x800
	// Bit WINMODE.
	COMP1_COMP2_CSR_WINMODE = 0x800
	// Position of WINOUT field.
	COMP1_COMP2_CSR_WINOUT_Pos = 0xe
	// Bit mask of WINOUT field.
	COMP1_COMP2_CSR_WINOUT_Msk = 0x4000
	// Bit WINOUT.
	COMP1_COMP2_CSR_WINOUT = 0x4000
	// Position of POLARITY field.
	COMP1_COMP2_CSR_POLARITY_Pos = 0xf
	// Bit mask of POLARITY field.
	COMP1_COMP2_CSR_POLARITY_Msk = 0x8000
	// Bit POLARITY.
	COMP1_COMP2_CSR_POLARITY = 0x8000
	// Position of HYST field.
	COMP1_COMP2_CSR_HYST_Pos = 0x10
	// Bit mask of HYST field.
	COMP1_COMP2_CSR_HYST_Msk = 0x30000
	// Position of PWRMODE field.
	COMP1_COMP2_CSR_PWRMODE_Pos = 0x12
	// Bit mask of PWRMODE field.
	COMP1_COMP2_CSR_PWRMODE_Msk = 0xc0000
	// Position of BLANKSEL field.
	COMP1_COMP2_CSR_BLANKSEL_Pos = 0x14
	// Bit mask of BLANKSEL field.
	COMP1_COMP2_CSR_BLANKSEL_Msk = 0x1f00000
	// Position of VALUE field.
	COMP1_COMP2_CSR_VALUE_Pos = 0x1e
	// Bit mask of VALUE field.
	COMP1_COMP2_CSR_VALUE_Msk = 0x40000000
	// Bit VALUE.
	COMP1_COMP2_CSR_VALUE = 0x40000000
	// Position of LOCK field.
	COMP1_COMP2_CSR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	COMP1_COMP2_CSR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	COMP1_COMP2_CSR_LOCK = 0x80000000
)

// Constants for SYSCFG_VREFBUF: System configuration controller
const (
	// CFGR1: SYSCFG configuration register 1
	// Position of I2C_PAx_FMP field.
	SYSCFG_CFGR1_I2C_PAx_FMP_Pos = 0x16
	// Bit mask of I2C_PAx_FMP field.
	SYSCFG_CFGR1_I2C_PAx_FMP_Msk = 0xc00000
	// Position of I2C2_FMP field.
	SYSCFG_CFGR1_I2C2_FMP_Pos = 0x15
	// Bit mask of I2C2_FMP field.
	SYSCFG_CFGR1_I2C2_FMP_Msk = 0x200000
	// Bit I2C2_FMP.
	SYSCFG_CFGR1_I2C2_FMP = 0x200000
	// Position of I2C1_FMP field.
	SYSCFG_CFGR1_I2C1_FMP_Pos = 0x14
	// Bit mask of I2C1_FMP field.
	SYSCFG_CFGR1_I2C1_FMP_Msk = 0x100000
	// Bit I2C1_FMP.
	SYSCFG_CFGR1_I2C1_FMP = 0x100000
	// Position of I2C_PBx_FMP field.
	SYSCFG_CFGR1_I2C_PBx_FMP_Pos = 0x10
	// Bit mask of I2C_PBx_FMP field.
	SYSCFG_CFGR1_I2C_PBx_FMP_Msk = 0xf0000
	// Position of UCPD2_STROBE field.
	SYSCFG_CFGR1_UCPD2_STROBE_Pos = 0xa
	// Bit mask of UCPD2_STROBE field.
	SYSCFG_CFGR1_UCPD2_STROBE_Msk = 0x400
	// Bit UCPD2_STROBE.
	SYSCFG_CFGR1_UCPD2_STROBE = 0x400
	// Position of UCPD1_STROBE field.
	SYSCFG_CFGR1_UCPD1_STROBE_Pos = 0x9
	// Bit mask of UCPD1_STROBE field.
	SYSCFG_CFGR1_UCPD1_STROBE_Msk = 0x200
	// Bit UCPD1_STROBE.
	SYSCFG_CFGR1_UCPD1_STROBE = 0x200
	// Position of BOOSTEN field.
	SYSCFG_CFGR1_BOOSTEN_Pos = 0x8
	// Bit mask of BOOSTEN field.
	SYSCFG_CFGR1_BOOSTEN_Msk = 0x100
	// Bit BOOSTEN.
	SYSCFG_CFGR1_BOOSTEN = 0x100
	// Position of IR_MOD field.
	SYSCFG_CFGR1_IR_MOD_Pos = 0x6
	// Bit mask of IR_MOD field.
	SYSCFG_CFGR1_IR_MOD_Msk = 0xc0
	// Position of IR_POL field.
	SYSCFG_CFGR1_IR_POL_Pos = 0x5
	// Bit mask of IR_POL field.
	SYSCFG_CFGR1_IR_POL_Msk = 0x20
	// Bit IR_POL.
	SYSCFG_CFGR1_IR_POL = 0x20
	// Position of PA11_PA12_RMP field.
	SYSCFG_CFGR1_PA11_PA12_RMP_Pos = 0x4
	// Bit mask of PA11_PA12_RMP field.
	SYSCFG_CFGR1_PA11_PA12_RMP_Msk = 0x10
	// Bit PA11_PA12_RMP.
	SYSCFG_CFGR1_PA11_PA12_RMP = 0x10
	// Position of MEM_MODE field.
	SYSCFG_CFGR1_MEM_MODE_Pos = 0x0
	// Bit mask of MEM_MODE field.
	SYSCFG_CFGR1_MEM_MODE_Msk = 0x3

	// CFGR2: SYSCFG configuration register 1
	// Position of LOCKUP_LOCK field.
	SYSCFG_CFGR2_LOCKUP_LOCK_Pos = 0x0
	// Bit mask of LOCKUP_LOCK field.
	SYSCFG_CFGR2_LOCKUP_LOCK_Msk = 0x1
	// Bit LOCKUP_LOCK.
	SYSCFG_CFGR2_LOCKUP_LOCK = 0x1
	// Position of SRAM_PARITY_LOCK field.
	SYSCFG_CFGR2_SRAM_PARITY_LOCK_Pos = 0x1
	// Bit mask of SRAM_PARITY_LOCK field.
	SYSCFG_CFGR2_SRAM_PARITY_LOCK_Msk = 0x2
	// Bit SRAM_PARITY_LOCK.
	SYSCFG_CFGR2_SRAM_PARITY_LOCK = 0x2
	// Position of PVD_LOCK field.
	SYSCFG_CFGR2_PVD_LOCK_Pos = 0x2
	// Bit mask of PVD_LOCK field.
	SYSCFG_CFGR2_PVD_LOCK_Msk = 0x4
	// Bit PVD_LOCK.
	SYSCFG_CFGR2_PVD_LOCK = 0x4
	// Position of ECC_LOCK field.
	SYSCFG_CFGR2_ECC_LOCK_Pos = 0x3
	// Bit mask of ECC_LOCK field.
	SYSCFG_CFGR2_ECC_LOCK_Msk = 0x8
	// Bit ECC_LOCK.
	SYSCFG_CFGR2_ECC_LOCK = 0x8
	// Position of SRAM_PEF field.
	SYSCFG_CFGR2_SRAM_PEF_Pos = 0x8
	// Bit mask of SRAM_PEF field.
	SYSCFG_CFGR2_SRAM_PEF_Msk = 0x100
	// Bit SRAM_PEF.
	SYSCFG_CFGR2_SRAM_PEF = 0x100

	// VREFBUF_CSR: VREFBUF control and status register
	// Position of ENVR field.
	SYSCFG_VREFBUF_CSR_ENVR_Pos = 0x0
	// Bit mask of ENVR field.
	SYSCFG_VREFBUF_CSR_ENVR_Msk = 0x1
	// Bit ENVR.
	SYSCFG_VREFBUF_CSR_ENVR = 0x1
	// Position of HIZ field.
	SYSCFG_VREFBUF_CSR_HIZ_Pos = 0x1
	// Bit mask of HIZ field.
	SYSCFG_VREFBUF_CSR_HIZ_Msk = 0x2
	// Bit HIZ.
	SYSCFG_VREFBUF_CSR_HIZ = 0x2
	// Position of VRR field.
	SYSCFG_VREFBUF_CSR_VRR_Pos = 0x3
	// Bit mask of VRR field.
	SYSCFG_VREFBUF_CSR_VRR_Msk = 0x8
	// Bit VRR.
	SYSCFG_VREFBUF_CSR_VRR = 0x8
	// Position of VRS field.
	SYSCFG_VREFBUF_CSR_VRS_Pos = 0x4
	// Bit mask of VRS field.
	SYSCFG_VREFBUF_CSR_VRS_Msk = 0x70

	// VREFBUF_CCR: VREFBUF calibration control register
	// Position of TRIM field.
	SYSCFG_VREFBUF_CCR_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	SYSCFG_VREFBUF_CCR_TRIM_Msk = 0x3f

	// ITLINE0: interrupt line 0 status register
	// Position of WWDG field.
	SYSCFG_ITLINE0_WWDG_Pos = 0x0
	// Bit mask of WWDG field.
	SYSCFG_ITLINE0_WWDG_Msk = 0x1
	// Bit WWDG.
	SYSCFG_ITLINE0_WWDG = 0x1

	// ITLINE1: interrupt line 1 status register
	// Position of PVDOUT field.
	SYSCFG_ITLINE1_PVDOUT_Pos = 0x0
	// Bit mask of PVDOUT field.
	SYSCFG_ITLINE1_PVDOUT_Msk = 0x1
	// Bit PVDOUT.
	SYSCFG_ITLINE1_PVDOUT = 0x1

	// ITLINE2: interrupt line 2 status register
	// Position of TAMP field.
	SYSCFG_ITLINE2_TAMP_Pos = 0x0
	// Bit mask of TAMP field.
	SYSCFG_ITLINE2_TAMP_Msk = 0x1
	// Bit TAMP.
	SYSCFG_ITLINE2_TAMP = 0x1
	// Position of RTC field.
	SYSCFG_ITLINE2_RTC_Pos = 0x1
	// Bit mask of RTC field.
	SYSCFG_ITLINE2_RTC_Msk = 0x2
	// Bit RTC.
	SYSCFG_ITLINE2_RTC = 0x2

	// ITLINE3: interrupt line 3 status register
	// Position of FLASH_ITF field.
	SYSCFG_ITLINE3_FLASH_ITF_Pos = 0x0
	// Bit mask of FLASH_ITF field.
	SYSCFG_ITLINE3_FLASH_ITF_Msk = 0x1
	// Bit FLASH_ITF.
	SYSCFG_ITLINE3_FLASH_ITF = 0x1
	// Position of FLASH_ECC field.
	SYSCFG_ITLINE3_FLASH_ECC_Pos = 0x1
	// Bit mask of FLASH_ECC field.
	SYSCFG_ITLINE3_FLASH_ECC_Msk = 0x2
	// Bit FLASH_ECC.
	SYSCFG_ITLINE3_FLASH_ECC = 0x2

	// ITLINE4: interrupt line 4 status register
	// Position of RCC field.
	SYSCFG_ITLINE4_RCC_Pos = 0x0
	// Bit mask of RCC field.
	SYSCFG_ITLINE4_RCC_Msk = 0x1
	// Bit RCC.
	SYSCFG_ITLINE4_RCC = 0x1

	// ITLINE5: interrupt line 5 status register
	// Position of EXTI0 field.
	SYSCFG_ITLINE5_EXTI0_Pos = 0x0
	// Bit mask of EXTI0 field.
	SYSCFG_ITLINE5_EXTI0_Msk = 0x1
	// Bit EXTI0.
	SYSCFG_ITLINE5_EXTI0 = 0x1
	// Position of EXTI1 field.
	SYSCFG_ITLINE5_EXTI1_Pos = 0x1
	// Bit mask of EXTI1 field.
	SYSCFG_ITLINE5_EXTI1_Msk = 0x2
	// Bit EXTI1.
	SYSCFG_ITLINE5_EXTI1 = 0x2

	// ITLINE6: interrupt line 6 status register
	// Position of EXTI2 field.
	SYSCFG_ITLINE6_EXTI2_Pos = 0x0
	// Bit mask of EXTI2 field.
	SYSCFG_ITLINE6_EXTI2_Msk = 0x1
	// Bit EXTI2.
	SYSCFG_ITLINE6_EXTI2 = 0x1
	// Position of EXTI3 field.
	SYSCFG_ITLINE6_EXTI3_Pos = 0x1
	// Bit mask of EXTI3 field.
	SYSCFG_ITLINE6_EXTI3_Msk = 0x2
	// Bit EXTI3.
	SYSCFG_ITLINE6_EXTI3 = 0x2

	// ITLINE7: interrupt line 7 status register
	// Position of EXTI4 field.
	SYSCFG_ITLINE7_EXTI4_Pos = 0x0
	// Bit mask of EXTI4 field.
	SYSCFG_ITLINE7_EXTI4_Msk = 0x1
	// Bit EXTI4.
	SYSCFG_ITLINE7_EXTI4 = 0x1
	// Position of EXTI5 field.
	SYSCFG_ITLINE7_EXTI5_Pos = 0x1
	// Bit mask of EXTI5 field.
	SYSCFG_ITLINE7_EXTI5_Msk = 0x2
	// Bit EXTI5.
	SYSCFG_ITLINE7_EXTI5 = 0x2
	// Position of EXTI6 field.
	SYSCFG_ITLINE7_EXTI6_Pos = 0x2
	// Bit mask of EXTI6 field.
	SYSCFG_ITLINE7_EXTI6_Msk = 0x4
	// Bit EXTI6.
	SYSCFG_ITLINE7_EXTI6 = 0x4
	// Position of EXTI7 field.
	SYSCFG_ITLINE7_EXTI7_Pos = 0x3
	// Bit mask of EXTI7 field.
	SYSCFG_ITLINE7_EXTI7_Msk = 0x8
	// Bit EXTI7.
	SYSCFG_ITLINE7_EXTI7 = 0x8
	// Position of EXTI8 field.
	SYSCFG_ITLINE7_EXTI8_Pos = 0x4
	// Bit mask of EXTI8 field.
	SYSCFG_ITLINE7_EXTI8_Msk = 0x10
	// Bit EXTI8.
	SYSCFG_ITLINE7_EXTI8 = 0x10
	// Position of EXTI9 field.
	SYSCFG_ITLINE7_EXTI9_Pos = 0x5
	// Bit mask of EXTI9 field.
	SYSCFG_ITLINE7_EXTI9_Msk = 0x20
	// Bit EXTI9.
	SYSCFG_ITLINE7_EXTI9 = 0x20
	// Position of EXTI10 field.
	SYSCFG_ITLINE7_EXTI10_Pos = 0x6
	// Bit mask of EXTI10 field.
	SYSCFG_ITLINE7_EXTI10_Msk = 0x40
	// Bit EXTI10.
	SYSCFG_ITLINE7_EXTI10 = 0x40
	// Position of EXTI11 field.
	SYSCFG_ITLINE7_EXTI11_Pos = 0x7
	// Bit mask of EXTI11 field.
	SYSCFG_ITLINE7_EXTI11_Msk = 0x80
	// Bit EXTI11.
	SYSCFG_ITLINE7_EXTI11 = 0x80
	// Position of EXTI12 field.
	SYSCFG_ITLINE7_EXTI12_Pos = 0x8
	// Bit mask of EXTI12 field.
	SYSCFG_ITLINE7_EXTI12_Msk = 0x100
	// Bit EXTI12.
	SYSCFG_ITLINE7_EXTI12 = 0x100
	// Position of EXTI13 field.
	SYSCFG_ITLINE7_EXTI13_Pos = 0x9
	// Bit mask of EXTI13 field.
	SYSCFG_ITLINE7_EXTI13_Msk = 0x200
	// Bit EXTI13.
	SYSCFG_ITLINE7_EXTI13 = 0x200
	// Position of EXTI14 field.
	SYSCFG_ITLINE7_EXTI14_Pos = 0xa
	// Bit mask of EXTI14 field.
	SYSCFG_ITLINE7_EXTI14_Msk = 0x400
	// Bit EXTI14.
	SYSCFG_ITLINE7_EXTI14 = 0x400
	// Position of EXTI15 field.
	SYSCFG_ITLINE7_EXTI15_Pos = 0xb
	// Bit mask of EXTI15 field.
	SYSCFG_ITLINE7_EXTI15_Msk = 0x800
	// Bit EXTI15.
	SYSCFG_ITLINE7_EXTI15 = 0x800

	// ITLINE8: interrupt line 8 status register
	// Position of UCPD1 field.
	SYSCFG_ITLINE8_UCPD1_Pos = 0x0
	// Bit mask of UCPD1 field.
	SYSCFG_ITLINE8_UCPD1_Msk = 0x1
	// Bit UCPD1.
	SYSCFG_ITLINE8_UCPD1 = 0x1
	// Position of UCPD2 field.
	SYSCFG_ITLINE8_UCPD2_Pos = 0x1
	// Bit mask of UCPD2 field.
	SYSCFG_ITLINE8_UCPD2_Msk = 0x2
	// Bit UCPD2.
	SYSCFG_ITLINE8_UCPD2 = 0x2

	// ITLINE9: interrupt line 9 status register
	// Position of DMA1_CH1 field.
	SYSCFG_ITLINE9_DMA1_CH1_Pos = 0x0
	// Bit mask of DMA1_CH1 field.
	SYSCFG_ITLINE9_DMA1_CH1_Msk = 0x1
	// Bit DMA1_CH1.
	SYSCFG_ITLINE9_DMA1_CH1 = 0x1

	// ITLINE10: interrupt line 10 status register
	// Position of DMA1_CH2 field.
	SYSCFG_ITLINE10_DMA1_CH2_Pos = 0x0
	// Bit mask of DMA1_CH2 field.
	SYSCFG_ITLINE10_DMA1_CH2_Msk = 0x1
	// Bit DMA1_CH2.
	SYSCFG_ITLINE10_DMA1_CH2 = 0x1
	// Position of DMA1_CH3 field.
	SYSCFG_ITLINE10_DMA1_CH3_Pos = 0x1
	// Bit mask of DMA1_CH3 field.
	SYSCFG_ITLINE10_DMA1_CH3_Msk = 0x2
	// Bit DMA1_CH3.
	SYSCFG_ITLINE10_DMA1_CH3 = 0x2

	// ITLINE11: interrupt line 11 status register
	// Position of DMAMUX field.
	SYSCFG_ITLINE11_DMAMUX_Pos = 0x0
	// Bit mask of DMAMUX field.
	SYSCFG_ITLINE11_DMAMUX_Msk = 0x1
	// Bit DMAMUX.
	SYSCFG_ITLINE11_DMAMUX = 0x1
	// Position of DMA1_CH4 field.
	SYSCFG_ITLINE11_DMA1_CH4_Pos = 0x1
	// Bit mask of DMA1_CH4 field.
	SYSCFG_ITLINE11_DMA1_CH4_Msk = 0x2
	// Bit DMA1_CH4.
	SYSCFG_ITLINE11_DMA1_CH4 = 0x2
	// Position of DMA1_CH5 field.
	SYSCFG_ITLINE11_DMA1_CH5_Pos = 0x2
	// Bit mask of DMA1_CH5 field.
	SYSCFG_ITLINE11_DMA1_CH5_Msk = 0x4
	// Bit DMA1_CH5.
	SYSCFG_ITLINE11_DMA1_CH5 = 0x4
	// Position of DMA1_CH6 field.
	SYSCFG_ITLINE11_DMA1_CH6_Pos = 0x3
	// Bit mask of DMA1_CH6 field.
	SYSCFG_ITLINE11_DMA1_CH6_Msk = 0x8
	// Bit DMA1_CH6.
	SYSCFG_ITLINE11_DMA1_CH6 = 0x8
	// Position of DMA1_CH7 field.
	SYSCFG_ITLINE11_DMA1_CH7_Pos = 0x4
	// Bit mask of DMA1_CH7 field.
	SYSCFG_ITLINE11_DMA1_CH7_Msk = 0x10
	// Bit DMA1_CH7.
	SYSCFG_ITLINE11_DMA1_CH7 = 0x10

	// ITLINE12: interrupt line 12 status register
	// Position of ADC field.
	SYSCFG_ITLINE12_ADC_Pos = 0x0
	// Bit mask of ADC field.
	SYSCFG_ITLINE12_ADC_Msk = 0x1
	// Bit ADC.
	SYSCFG_ITLINE12_ADC = 0x1
	// Position of COMP1 field.
	SYSCFG_ITLINE12_COMP1_Pos = 0x1
	// Bit mask of COMP1 field.
	SYSCFG_ITLINE12_COMP1_Msk = 0x2
	// Bit COMP1.
	SYSCFG_ITLINE12_COMP1 = 0x2
	// Position of COMP2 field.
	SYSCFG_ITLINE12_COMP2_Pos = 0x2
	// Bit mask of COMP2 field.
	SYSCFG_ITLINE12_COMP2_Msk = 0x4
	// Bit COMP2.
	SYSCFG_ITLINE12_COMP2 = 0x4

	// ITLINE13: interrupt line 13 status register
	// Position of TIM1_CCU field.
	SYSCFG_ITLINE13_TIM1_CCU_Pos = 0x0
	// Bit mask of TIM1_CCU field.
	SYSCFG_ITLINE13_TIM1_CCU_Msk = 0x1
	// Bit TIM1_CCU.
	SYSCFG_ITLINE13_TIM1_CCU = 0x1
	// Position of TIM1_TRG field.
	SYSCFG_ITLINE13_TIM1_TRG_Pos = 0x1
	// Bit mask of TIM1_TRG field.
	SYSCFG_ITLINE13_TIM1_TRG_Msk = 0x2
	// Bit TIM1_TRG.
	SYSCFG_ITLINE13_TIM1_TRG = 0x2
	// Position of TIM1_UPD field.
	SYSCFG_ITLINE13_TIM1_UPD_Pos = 0x2
	// Bit mask of TIM1_UPD field.
	SYSCFG_ITLINE13_TIM1_UPD_Msk = 0x4
	// Bit TIM1_UPD.
	SYSCFG_ITLINE13_TIM1_UPD = 0x4
	// Position of TIM1_BRK field.
	SYSCFG_ITLINE13_TIM1_BRK_Pos = 0x3
	// Bit mask of TIM1_BRK field.
	SYSCFG_ITLINE13_TIM1_BRK_Msk = 0x8
	// Bit TIM1_BRK.
	SYSCFG_ITLINE13_TIM1_BRK = 0x8

	// ITLINE14: interrupt line 14 status register
	// Position of TIM1_CC field.
	SYSCFG_ITLINE14_TIM1_CC_Pos = 0x0
	// Bit mask of TIM1_CC field.
	SYSCFG_ITLINE14_TIM1_CC_Msk = 0x1
	// Bit TIM1_CC.
	SYSCFG_ITLINE14_TIM1_CC = 0x1

	// ITLINE15: interrupt line 15 status register
	// Position of TIM2 field.
	SYSCFG_ITLINE15_TIM2_Pos = 0x0
	// Bit mask of TIM2 field.
	SYSCFG_ITLINE15_TIM2_Msk = 0x1
	// Bit TIM2.
	SYSCFG_ITLINE15_TIM2 = 0x1

	// ITLINE16: interrupt line 16 status register
	// Position of TIM3 field.
	SYSCFG_ITLINE16_TIM3_Pos = 0x0
	// Bit mask of TIM3 field.
	SYSCFG_ITLINE16_TIM3_Msk = 0x1
	// Bit TIM3.
	SYSCFG_ITLINE16_TIM3 = 0x1

	// ITLINE17: interrupt line 17 status register
	// Position of TIM6 field.
	SYSCFG_ITLINE17_TIM6_Pos = 0x0
	// Bit mask of TIM6 field.
	SYSCFG_ITLINE17_TIM6_Msk = 0x1
	// Bit TIM6.
	SYSCFG_ITLINE17_TIM6 = 0x1
	// Position of DAC field.
	SYSCFG_ITLINE17_DAC_Pos = 0x1
	// Bit mask of DAC field.
	SYSCFG_ITLINE17_DAC_Msk = 0x2
	// Bit DAC.
	SYSCFG_ITLINE17_DAC = 0x2
	// Position of LPTIM1 field.
	SYSCFG_ITLINE17_LPTIM1_Pos = 0x2
	// Bit mask of LPTIM1 field.
	SYSCFG_ITLINE17_LPTIM1_Msk = 0x4
	// Bit LPTIM1.
	SYSCFG_ITLINE17_LPTIM1 = 0x4

	// ITLINE18: interrupt line 18 status register
	// Position of TIM7 field.
	SYSCFG_ITLINE18_TIM7_Pos = 0x0
	// Bit mask of TIM7 field.
	SYSCFG_ITLINE18_TIM7_Msk = 0x1
	// Bit TIM7.
	SYSCFG_ITLINE18_TIM7 = 0x1
	// Position of LPTIM2 field.
	SYSCFG_ITLINE18_LPTIM2_Pos = 0x1
	// Bit mask of LPTIM2 field.
	SYSCFG_ITLINE18_LPTIM2_Msk = 0x2
	// Bit LPTIM2.
	SYSCFG_ITLINE18_LPTIM2 = 0x2

	// ITLINE19: interrupt line 19 status register
	// Position of TIM14 field.
	SYSCFG_ITLINE19_TIM14_Pos = 0x0
	// Bit mask of TIM14 field.
	SYSCFG_ITLINE19_TIM14_Msk = 0x1
	// Bit TIM14.
	SYSCFG_ITLINE19_TIM14 = 0x1

	// ITLINE20: interrupt line 20 status register
	// Position of TIM15 field.
	SYSCFG_ITLINE20_TIM15_Pos = 0x0
	// Bit mask of TIM15 field.
	SYSCFG_ITLINE20_TIM15_Msk = 0x1
	// Bit TIM15.
	SYSCFG_ITLINE20_TIM15 = 0x1

	// ITLINE21: interrupt line 21 status register
	// Position of TIM16 field.
	SYSCFG_ITLINE21_TIM16_Pos = 0x0
	// Bit mask of TIM16 field.
	SYSCFG_ITLINE21_TIM16_Msk = 0x1
	// Bit TIM16.
	SYSCFG_ITLINE21_TIM16 = 0x1

	// ITLINE22: interrupt line 22 status register
	// Position of TIM17 field.
	SYSCFG_ITLINE22_TIM17_Pos = 0x0
	// Bit mask of TIM17 field.
	SYSCFG_ITLINE22_TIM17_Msk = 0x1
	// Bit TIM17.
	SYSCFG_ITLINE22_TIM17 = 0x1

	// ITLINE23: interrupt line 23 status register
	// Position of I2C1 field.
	SYSCFG_ITLINE23_I2C1_Pos = 0x0
	// Bit mask of I2C1 field.
	SYSCFG_ITLINE23_I2C1_Msk = 0x1
	// Bit I2C1.
	SYSCFG_ITLINE23_I2C1 = 0x1

	// ITLINE24: interrupt line 24 status register
	// Position of I2C2 field.
	SYSCFG_ITLINE24_I2C2_Pos = 0x0
	// Bit mask of I2C2 field.
	SYSCFG_ITLINE24_I2C2_Msk = 0x1
	// Bit I2C2.
	SYSCFG_ITLINE24_I2C2 = 0x1

	// ITLINE25: interrupt line 25 status register
	// Position of SPI1 field.
	SYSCFG_ITLINE25_SPI1_Pos = 0x0
	// Bit mask of SPI1 field.
	SYSCFG_ITLINE25_SPI1_Msk = 0x1
	// Bit SPI1.
	SYSCFG_ITLINE25_SPI1 = 0x1

	// ITLINE26: interrupt line 26 status register
	// Position of SPI2 field.
	SYSCFG_ITLINE26_SPI2_Pos = 0x0
	// Bit mask of SPI2 field.
	SYSCFG_ITLINE26_SPI2_Msk = 0x1
	// Bit SPI2.
	SYSCFG_ITLINE26_SPI2 = 0x1

	// ITLINE27: interrupt line 27 status register
	// Position of USART1 field.
	SYSCFG_ITLINE27_USART1_Pos = 0x0
	// Bit mask of USART1 field.
	SYSCFG_ITLINE27_USART1_Msk = 0x1
	// Bit USART1.
	SYSCFG_ITLINE27_USART1 = 0x1

	// ITLINE28: interrupt line 28 status register
	// Position of USART2 field.
	SYSCFG_ITLINE28_USART2_Pos = 0x0
	// Bit mask of USART2 field.
	SYSCFG_ITLINE28_USART2_Msk = 0x1
	// Bit USART2.
	SYSCFG_ITLINE28_USART2 = 0x1

	// ITLINE29: interrupt line 29 status register
	// Position of USART3 field.
	SYSCFG_ITLINE29_USART3_Pos = 0x0
	// Bit mask of USART3 field.
	SYSCFG_ITLINE29_USART3_Msk = 0x1
	// Bit USART3.
	SYSCFG_ITLINE29_USART3 = 0x1
	// Position of USART4 field.
	SYSCFG_ITLINE29_USART4_Pos = 0x1
	// Bit mask of USART4 field.
	SYSCFG_ITLINE29_USART4_Msk = 0x2
	// Bit USART4.
	SYSCFG_ITLINE29_USART4 = 0x2
	// Position of USART5 field.
	SYSCFG_ITLINE29_USART5_Pos = 0x2
	// Bit mask of USART5 field.
	SYSCFG_ITLINE29_USART5_Msk = 0x4
	// Bit USART5.
	SYSCFG_ITLINE29_USART5 = 0x4

	// ITLINE30: interrupt line 30 status register
	// Position of USART2 field.
	SYSCFG_ITLINE30_USART2_Pos = 0x0
	// Bit mask of USART2 field.
	SYSCFG_ITLINE30_USART2_Msk = 0x1
	// Bit USART2.
	SYSCFG_ITLINE30_USART2 = 0x1

	// ITLINE31: interrupt line 31 status register
	// Position of RNG field.
	SYSCFG_ITLINE31_RNG_Pos = 0x0
	// Bit mask of RNG field.
	SYSCFG_ITLINE31_RNG_Msk = 0x1
	// Bit RNG.
	SYSCFG_ITLINE31_RNG = 0x1
	// Position of AES field.
	SYSCFG_ITLINE31_AES_Pos = 0x1
	// Bit mask of AES field.
	SYSCFG_ITLINE31_AES_Msk = 0x2
	// Bit AES.
	SYSCFG_ITLINE31_AES = 0x2
)

// Constants for TAMP: Tamper and backup registers
const (
	// CR1: control register 1
	// Position of TAMP1E field.
	TAMP_CR1_TAMP1E_Pos = 0x0
	// Bit mask of TAMP1E field.
	TAMP_CR1_TAMP1E_Msk = 0x1
	// Bit TAMP1E.
	TAMP_CR1_TAMP1E = 0x1
	// Position of TAMP2E field.
	TAMP_CR1_TAMP2E_Pos = 0x1
	// Bit mask of TAMP2E field.
	TAMP_CR1_TAMP2E_Msk = 0x2
	// Bit TAMP2E.
	TAMP_CR1_TAMP2E = 0x2
	// Position of ITAMP1E field.
	TAMP_CR1_ITAMP1E_Pos = 0x10
	// Bit mask of ITAMP1E field.
	TAMP_CR1_ITAMP1E_Msk = 0x10000
	// Bit ITAMP1E.
	TAMP_CR1_ITAMP1E = 0x10000
	// Position of ITAMP3E field.
	TAMP_CR1_ITAMP3E_Pos = 0x12
	// Bit mask of ITAMP3E field.
	TAMP_CR1_ITAMP3E_Msk = 0x40000
	// Bit ITAMP3E.
	TAMP_CR1_ITAMP3E = 0x40000
	// Position of ITAMP4E field.
	TAMP_CR1_ITAMP4E_Pos = 0x13
	// Bit mask of ITAMP4E field.
	TAMP_CR1_ITAMP4E_Msk = 0x80000
	// Bit ITAMP4E.
	TAMP_CR1_ITAMP4E = 0x80000
	// Position of ITAMP5E field.
	TAMP_CR1_ITAMP5E_Pos = 0x14
	// Bit mask of ITAMP5E field.
	TAMP_CR1_ITAMP5E_Msk = 0x100000
	// Bit ITAMP5E.
	TAMP_CR1_ITAMP5E = 0x100000
	// Position of ITAMP6E field.
	TAMP_CR1_ITAMP6E_Pos = 0x15
	// Bit mask of ITAMP6E field.
	TAMP_CR1_ITAMP6E_Msk = 0x200000
	// Bit ITAMP6E.
	TAMP_CR1_ITAMP6E = 0x200000

	// CR2: control register 2
	// Position of TAMP1NOER field.
	TAMP_CR2_TAMP1NOER_Pos = 0x0
	// Bit mask of TAMP1NOER field.
	TAMP_CR2_TAMP1NOER_Msk = 0x1
	// Bit TAMP1NOER.
	TAMP_CR2_TAMP1NOER = 0x1
	// Position of TAMP2NOER field.
	TAMP_CR2_TAMP2NOER_Pos = 0x1
	// Bit mask of TAMP2NOER field.
	TAMP_CR2_TAMP2NOER_Msk = 0x2
	// Bit TAMP2NOER.
	TAMP_CR2_TAMP2NOER = 0x2
	// Position of TAMP1MSK field.
	TAMP_CR2_TAMP1MSK_Pos = 0x10
	// Bit mask of TAMP1MSK field.
	TAMP_CR2_TAMP1MSK_Msk = 0x10000
	// Bit TAMP1MSK.
	TAMP_CR2_TAMP1MSK = 0x10000
	// Position of TAMP2MSK field.
	TAMP_CR2_TAMP2MSK_Pos = 0x11
	// Bit mask of TAMP2MSK field.
	TAMP_CR2_TAMP2MSK_Msk = 0x20000
	// Bit TAMP2MSK.
	TAMP_CR2_TAMP2MSK = 0x20000
	// Position of TAMP1TRG field.
	TAMP_CR2_TAMP1TRG_Pos = 0x18
	// Bit mask of TAMP1TRG field.
	TAMP_CR2_TAMP1TRG_Msk = 0x1000000
	// Bit TAMP1TRG.
	TAMP_CR2_TAMP1TRG = 0x1000000
	// Position of TAMP2TRG field.
	TAMP_CR2_TAMP2TRG_Pos = 0x19
	// Bit mask of TAMP2TRG field.
	TAMP_CR2_TAMP2TRG_Msk = 0x2000000
	// Bit TAMP2TRG.
	TAMP_CR2_TAMP2TRG = 0x2000000

	// FLTCR: TAMP filter control register
	// Position of TAMPFREQ field.
	TAMP_FLTCR_TAMPFREQ_Pos = 0x0
	// Bit mask of TAMPFREQ field.
	TAMP_FLTCR_TAMPFREQ_Msk = 0x7
	// Position of TAMPFLT field.
	TAMP_FLTCR_TAMPFLT_Pos = 0x3
	// Bit mask of TAMPFLT field.
	TAMP_FLTCR_TAMPFLT_Msk = 0x18
	// Position of TAMPPRCH field.
	TAMP_FLTCR_TAMPPRCH_Pos = 0x5
	// Bit mask of TAMPPRCH field.
	TAMP_FLTCR_TAMPPRCH_Msk = 0x60
	// Position of TAMPPUDIS field.
	TAMP_FLTCR_TAMPPUDIS_Pos = 0x7
	// Bit mask of TAMPPUDIS field.
	TAMP_FLTCR_TAMPPUDIS_Msk = 0x80
	// Bit TAMPPUDIS.
	TAMP_FLTCR_TAMPPUDIS = 0x80

	// IER: TAMP interrupt enable register
	// Position of TAMP1IE field.
	TAMP_IER_TAMP1IE_Pos = 0x0
	// Bit mask of TAMP1IE field.
	TAMP_IER_TAMP1IE_Msk = 0x1
	// Bit TAMP1IE.
	TAMP_IER_TAMP1IE = 0x1
	// Position of TAMP2IE field.
	TAMP_IER_TAMP2IE_Pos = 0x1
	// Bit mask of TAMP2IE field.
	TAMP_IER_TAMP2IE_Msk = 0x2
	// Bit TAMP2IE.
	TAMP_IER_TAMP2IE = 0x2
	// Position of ITAMP1IE field.
	TAMP_IER_ITAMP1IE_Pos = 0x10
	// Bit mask of ITAMP1IE field.
	TAMP_IER_ITAMP1IE_Msk = 0x10000
	// Bit ITAMP1IE.
	TAMP_IER_ITAMP1IE = 0x10000
	// Position of ITAMP3IE field.
	TAMP_IER_ITAMP3IE_Pos = 0x12
	// Bit mask of ITAMP3IE field.
	TAMP_IER_ITAMP3IE_Msk = 0x40000
	// Bit ITAMP3IE.
	TAMP_IER_ITAMP3IE = 0x40000
	// Position of ITAMP4IE field.
	TAMP_IER_ITAMP4IE_Pos = 0x13
	// Bit mask of ITAMP4IE field.
	TAMP_IER_ITAMP4IE_Msk = 0x80000
	// Bit ITAMP4IE.
	TAMP_IER_ITAMP4IE = 0x80000
	// Position of ITAMP5IE field.
	TAMP_IER_ITAMP5IE_Pos = 0x14
	// Bit mask of ITAMP5IE field.
	TAMP_IER_ITAMP5IE_Msk = 0x100000
	// Bit ITAMP5IE.
	TAMP_IER_ITAMP5IE = 0x100000
	// Position of ITAMP6IE field.
	TAMP_IER_ITAMP6IE_Pos = 0x15
	// Bit mask of ITAMP6IE field.
	TAMP_IER_ITAMP6IE_Msk = 0x200000
	// Bit ITAMP6IE.
	TAMP_IER_ITAMP6IE = 0x200000

	// SR: TAMP status register
	// Position of TAMP1F field.
	TAMP_SR_TAMP1F_Pos = 0x0
	// Bit mask of TAMP1F field.
	TAMP_SR_TAMP1F_Msk = 0x1
	// Bit TAMP1F.
	TAMP_SR_TAMP1F = 0x1
	// Position of TAMP2F field.
	TAMP_SR_TAMP2F_Pos = 0x1
	// Bit mask of TAMP2F field.
	TAMP_SR_TAMP2F_Msk = 0x2
	// Bit TAMP2F.
	TAMP_SR_TAMP2F = 0x2
	// Position of ITAMP1F field.
	TAMP_SR_ITAMP1F_Pos = 0x10
	// Bit mask of ITAMP1F field.
	TAMP_SR_ITAMP1F_Msk = 0x10000
	// Bit ITAMP1F.
	TAMP_SR_ITAMP1F = 0x10000
	// Position of ITAMP3F field.
	TAMP_SR_ITAMP3F_Pos = 0x12
	// Bit mask of ITAMP3F field.
	TAMP_SR_ITAMP3F_Msk = 0x40000
	// Bit ITAMP3F.
	TAMP_SR_ITAMP3F = 0x40000
	// Position of ITAMP4F field.
	TAMP_SR_ITAMP4F_Pos = 0x13
	// Bit mask of ITAMP4F field.
	TAMP_SR_ITAMP4F_Msk = 0x80000
	// Bit ITAMP4F.
	TAMP_SR_ITAMP4F = 0x80000
	// Position of ITAMP5F field.
	TAMP_SR_ITAMP5F_Pos = 0x14
	// Bit mask of ITAMP5F field.
	TAMP_SR_ITAMP5F_Msk = 0x100000
	// Bit ITAMP5F.
	TAMP_SR_ITAMP5F = 0x100000
	// Position of ITAMP6F field.
	TAMP_SR_ITAMP6F_Pos = 0x15
	// Bit mask of ITAMP6F field.
	TAMP_SR_ITAMP6F_Msk = 0x200000
	// Bit ITAMP6F.
	TAMP_SR_ITAMP6F = 0x200000
	// Position of ITAMP7F field.
	TAMP_SR_ITAMP7F_Pos = 0x16
	// Bit mask of ITAMP7F field.
	TAMP_SR_ITAMP7F_Msk = 0x400000
	// Bit ITAMP7F.
	TAMP_SR_ITAMP7F = 0x400000

	// MISR: TAMP masked interrupt status register
	// Position of TAMP1MF field.
	TAMP_MISR_TAMP1MF_Pos = 0x0
	// Bit mask of TAMP1MF field.
	TAMP_MISR_TAMP1MF_Msk = 0x1
	// Bit TAMP1MF.
	TAMP_MISR_TAMP1MF = 0x1
	// Position of TAMP2MF field.
	TAMP_MISR_TAMP2MF_Pos = 0x1
	// Bit mask of TAMP2MF field.
	TAMP_MISR_TAMP2MF_Msk = 0x2
	// Bit TAMP2MF.
	TAMP_MISR_TAMP2MF = 0x2
	// Position of ITAMP1MF field.
	TAMP_MISR_ITAMP1MF_Pos = 0x10
	// Bit mask of ITAMP1MF field.
	TAMP_MISR_ITAMP1MF_Msk = 0x10000
	// Bit ITAMP1MF.
	TAMP_MISR_ITAMP1MF = 0x10000
	// Position of ITAMP3MF field.
	TAMP_MISR_ITAMP3MF_Pos = 0x12
	// Bit mask of ITAMP3MF field.
	TAMP_MISR_ITAMP3MF_Msk = 0x40000
	// Bit ITAMP3MF.
	TAMP_MISR_ITAMP3MF = 0x40000
	// Position of ITAMP4MF field.
	TAMP_MISR_ITAMP4MF_Pos = 0x13
	// Bit mask of ITAMP4MF field.
	TAMP_MISR_ITAMP4MF_Msk = 0x80000
	// Bit ITAMP4MF.
	TAMP_MISR_ITAMP4MF = 0x80000
	// Position of ITAMP5MF field.
	TAMP_MISR_ITAMP5MF_Pos = 0x14
	// Bit mask of ITAMP5MF field.
	TAMP_MISR_ITAMP5MF_Msk = 0x100000
	// Bit ITAMP5MF.
	TAMP_MISR_ITAMP5MF = 0x100000
	// Position of ITAMP6MF field.
	TAMP_MISR_ITAMP6MF_Pos = 0x15
	// Bit mask of ITAMP6MF field.
	TAMP_MISR_ITAMP6MF_Msk = 0x200000
	// Bit ITAMP6MF.
	TAMP_MISR_ITAMP6MF = 0x200000

	// SCR: TAMP status clear register
	// Position of CTAMP1F field.
	TAMP_SCR_CTAMP1F_Pos = 0x0
	// Bit mask of CTAMP1F field.
	TAMP_SCR_CTAMP1F_Msk = 0x1
	// Bit CTAMP1F.
	TAMP_SCR_CTAMP1F = 0x1
	// Position of CTAMP2F field.
	TAMP_SCR_CTAMP2F_Pos = 0x1
	// Bit mask of CTAMP2F field.
	TAMP_SCR_CTAMP2F_Msk = 0x2
	// Bit CTAMP2F.
	TAMP_SCR_CTAMP2F = 0x2
	// Position of CITAMP1F field.
	TAMP_SCR_CITAMP1F_Pos = 0x10
	// Bit mask of CITAMP1F field.
	TAMP_SCR_CITAMP1F_Msk = 0x10000
	// Bit CITAMP1F.
	TAMP_SCR_CITAMP1F = 0x10000
	// Position of CITAMP3F field.
	TAMP_SCR_CITAMP3F_Pos = 0x12
	// Bit mask of CITAMP3F field.
	TAMP_SCR_CITAMP3F_Msk = 0x40000
	// Bit CITAMP3F.
	TAMP_SCR_CITAMP3F = 0x40000
	// Position of CITAMP4F field.
	TAMP_SCR_CITAMP4F_Pos = 0x13
	// Bit mask of CITAMP4F field.
	TAMP_SCR_CITAMP4F_Msk = 0x80000
	// Bit CITAMP4F.
	TAMP_SCR_CITAMP4F = 0x80000
	// Position of CITAMP5F field.
	TAMP_SCR_CITAMP5F_Pos = 0x14
	// Bit mask of CITAMP5F field.
	TAMP_SCR_CITAMP5F_Msk = 0x100000
	// Bit CITAMP5F.
	TAMP_SCR_CITAMP5F = 0x100000
	// Position of CITAMP6F field.
	TAMP_SCR_CITAMP6F_Pos = 0x15
	// Bit mask of CITAMP6F field.
	TAMP_SCR_CITAMP6F_Msk = 0x200000
	// Bit CITAMP6F.
	TAMP_SCR_CITAMP6F = 0x200000
	// Position of CITAMP7F field.
	TAMP_SCR_CITAMP7F_Pos = 0x16
	// Bit mask of CITAMP7F field.
	TAMP_SCR_CITAMP7F_Msk = 0x400000
	// Bit CITAMP7F.
	TAMP_SCR_CITAMP7F = 0x400000

	// BKP0R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP0R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP0R_BKP_Msk = 0xffffffff

	// BKP1R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP1R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP1R_BKP_Msk = 0xffffffff

	// BKP2R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP2R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP2R_BKP_Msk = 0xffffffff

	// BKP3R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP3R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP3R_BKP_Msk = 0xffffffff

	// BKP4R: TAMP backup register
	// Position of BKP field.
	TAMP_BKP4R_BKP_Pos = 0x0
	// Bit mask of BKP field.
	TAMP_BKP4R_BKP_Msk = 0xffffffff

	// HWCFGR2: TAMP hardware configuration register 2
	// Position of PTIONREG_OUT field.
	TAMP_HWCFGR2_PTIONREG_OUT_Pos = 0x0
	// Bit mask of PTIONREG_OUT field.
	TAMP_HWCFGR2_PTIONREG_OUT_Msk = 0xff
	// Position of TRUST_ZONE field.
	TAMP_HWCFGR2_TRUST_ZONE_Pos = 0x8
	// Bit mask of TRUST_ZONE field.
	TAMP_HWCFGR2_TRUST_ZONE_Msk = 0xf00

	// HWCFGR1: TAMP hardware configuration register 1
	// Position of BACKUP_REGS field.
	TAMP_HWCFGR1_BACKUP_REGS_Pos = 0x0
	// Bit mask of BACKUP_REGS field.
	TAMP_HWCFGR1_BACKUP_REGS_Msk = 0xff
	// Position of TAMPER field.
	TAMP_HWCFGR1_TAMPER_Pos = 0x8
	// Bit mask of TAMPER field.
	TAMP_HWCFGR1_TAMPER_Msk = 0xf00
	// Position of ACTIVE_TAMPER field.
	TAMP_HWCFGR1_ACTIVE_TAMPER_Pos = 0xc
	// Bit mask of ACTIVE_TAMPER field.
	TAMP_HWCFGR1_ACTIVE_TAMPER_Msk = 0xf000
	// Position of INT_TAMPER field.
	TAMP_HWCFGR1_INT_TAMPER_Pos = 0x10
	// Bit mask of INT_TAMPER field.
	TAMP_HWCFGR1_INT_TAMPER_Msk = 0xffff0000

	// VERR: EXTI IP Version register
	// Position of MINREV field.
	TAMP_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	TAMP_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	TAMP_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	TAMP_VERR_MAJREV_Msk = 0xf0

	// IPIDR: EXTI Identification register
	// Position of IPID field.
	TAMP_IPIDR_IPID_Pos = 0x0
	// Bit mask of IPID field.
	TAMP_IPIDR_IPID_Msk = 0xffffffff

	// SIDR: EXTI Size ID register
	// Position of SID field.
	TAMP_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	TAMP_SIDR_SID_Msk = 0xffffffff
)

// Constants for UCPD1: USB Power Delivery interface
const (
	// CFG1: UCPD configuration register
	// Position of HBITCLKDIV field.
	UCPD_CFG1_HBITCLKDIV_Pos = 0x0
	// Bit mask of HBITCLKDIV field.
	UCPD_CFG1_HBITCLKDIV_Msk = 0x3f
	// Position of IFRGAP field.
	UCPD_CFG1_IFRGAP_Pos = 0x6
	// Bit mask of IFRGAP field.
	UCPD_CFG1_IFRGAP_Msk = 0x7c0
	// Position of TRANSWIN field.
	UCPD_CFG1_TRANSWIN_Pos = 0xb
	// Bit mask of TRANSWIN field.
	UCPD_CFG1_TRANSWIN_Msk = 0xf800
	// Position of PSC_USBPDCLK field.
	UCPD_CFG1_PSC_USBPDCLK_Pos = 0x11
	// Bit mask of PSC_USBPDCLK field.
	UCPD_CFG1_PSC_USBPDCLK_Msk = 0xe0000
	// Position of RXORDSETEN field.
	UCPD_CFG1_RXORDSETEN_Pos = 0x14
	// Bit mask of RXORDSETEN field.
	UCPD_CFG1_RXORDSETEN_Msk = 0x1ff00000
	// Position of TXDMAEN field.
	UCPD_CFG1_TXDMAEN_Pos = 0x1d
	// Bit mask of TXDMAEN field.
	UCPD_CFG1_TXDMAEN_Msk = 0x20000000
	// Bit TXDMAEN.
	UCPD_CFG1_TXDMAEN = 0x20000000
	// Position of RXDMAEN field.
	UCPD_CFG1_RXDMAEN_Pos = 0x1e
	// Bit mask of RXDMAEN field.
	UCPD_CFG1_RXDMAEN_Msk = 0x40000000
	// Bit RXDMAEN.
	UCPD_CFG1_RXDMAEN = 0x40000000
	// Position of UCPDEN field.
	UCPD_CFG1_UCPDEN_Pos = 0x1f
	// Bit mask of UCPDEN field.
	UCPD_CFG1_UCPDEN_Msk = 0x80000000
	// Bit UCPDEN.
	UCPD_CFG1_UCPDEN = 0x80000000

	// CFG2: UCPD configuration register 2
	// Position of RXFILTDIS field.
	UCPD_CFG2_RXFILTDIS_Pos = 0x0
	// Bit mask of RXFILTDIS field.
	UCPD_CFG2_RXFILTDIS_Msk = 0x1
	// Bit RXFILTDIS.
	UCPD_CFG2_RXFILTDIS = 0x1
	// Position of RXFILT2N3 field.
	UCPD_CFG2_RXFILT2N3_Pos = 0x1
	// Bit mask of RXFILT2N3 field.
	UCPD_CFG2_RXFILT2N3_Msk = 0x2
	// Bit RXFILT2N3.
	UCPD_CFG2_RXFILT2N3 = 0x2
	// Position of FORCECLK field.
	UCPD_CFG2_FORCECLK_Pos = 0x2
	// Bit mask of FORCECLK field.
	UCPD_CFG2_FORCECLK_Msk = 0x4
	// Bit FORCECLK.
	UCPD_CFG2_FORCECLK = 0x4
	// Position of WUPEN field.
	UCPD_CFG2_WUPEN_Pos = 0x3
	// Bit mask of WUPEN field.
	UCPD_CFG2_WUPEN_Msk = 0x8
	// Bit WUPEN.
	UCPD_CFG2_WUPEN = 0x8

	// CFG3: UCPD configuration register 3
	// Position of TRIM1_NG_CCRPD field.
	UCPD_CFG3_TRIM1_NG_CCRPD_Pos = 0x0
	// Bit mask of TRIM1_NG_CCRPD field.
	UCPD_CFG3_TRIM1_NG_CCRPD_Msk = 0xf
	// Position of TRIM1_NG_CC1A5 field.
	UCPD_CFG3_TRIM1_NG_CC1A5_Pos = 0x4
	// Bit mask of TRIM1_NG_CC1A5 field.
	UCPD_CFG3_TRIM1_NG_CC1A5_Msk = 0x1f0
	// Position of TRIM1_NG_CC3A0 field.
	UCPD_CFG3_TRIM1_NG_CC3A0_Pos = 0x9
	// Bit mask of TRIM1_NG_CC3A0 field.
	UCPD_CFG3_TRIM1_NG_CC3A0_Msk = 0x1e00
	// Position of TRIM2_NG_CCRPD field.
	UCPD_CFG3_TRIM2_NG_CCRPD_Pos = 0x10
	// Bit mask of TRIM2_NG_CCRPD field.
	UCPD_CFG3_TRIM2_NG_CCRPD_Msk = 0xf0000
	// Position of TRIM2_NG_CC1A5 field.
	UCPD_CFG3_TRIM2_NG_CC1A5_Pos = 0x14
	// Bit mask of TRIM2_NG_CC1A5 field.
	UCPD_CFG3_TRIM2_NG_CC1A5_Msk = 0x1f00000
	// Position of TRIM2_NG_CC3A0 field.
	UCPD_CFG3_TRIM2_NG_CC3A0_Pos = 0x19
	// Bit mask of TRIM2_NG_CC3A0 field.
	UCPD_CFG3_TRIM2_NG_CC3A0_Msk = 0x1e000000

	// CR: UCPD control register
	// Position of TXMODE field.
	UCPD_CR_TXMODE_Pos = 0x0
	// Bit mask of TXMODE field.
	UCPD_CR_TXMODE_Msk = 0x3
	// Position of TXSEND field.
	UCPD_CR_TXSEND_Pos = 0x2
	// Bit mask of TXSEND field.
	UCPD_CR_TXSEND_Msk = 0x4
	// Bit TXSEND.
	UCPD_CR_TXSEND = 0x4
	// Position of TXHRST field.
	UCPD_CR_TXHRST_Pos = 0x3
	// Bit mask of TXHRST field.
	UCPD_CR_TXHRST_Msk = 0x8
	// Bit TXHRST.
	UCPD_CR_TXHRST = 0x8
	// Position of RXMODE field.
	UCPD_CR_RXMODE_Pos = 0x4
	// Bit mask of RXMODE field.
	UCPD_CR_RXMODE_Msk = 0x10
	// Bit RXMODE.
	UCPD_CR_RXMODE = 0x10
	// Position of PHYRXEN field.
	UCPD_CR_PHYRXEN_Pos = 0x5
	// Bit mask of PHYRXEN field.
	UCPD_CR_PHYRXEN_Msk = 0x20
	// Bit PHYRXEN.
	UCPD_CR_PHYRXEN = 0x20
	// Position of PHYCCSEL field.
	UCPD_CR_PHYCCSEL_Pos = 0x6
	// Bit mask of PHYCCSEL field.
	UCPD_CR_PHYCCSEL_Msk = 0x40
	// Bit PHYCCSEL.
	UCPD_CR_PHYCCSEL = 0x40
	// Position of ANASUBMODE field.
	UCPD_CR_ANASUBMODE_Pos = 0x7
	// Bit mask of ANASUBMODE field.
	UCPD_CR_ANASUBMODE_Msk = 0x180
	// Position of ANAMODE field.
	UCPD_CR_ANAMODE_Pos = 0x9
	// Bit mask of ANAMODE field.
	UCPD_CR_ANAMODE_Msk = 0x200
	// Bit ANAMODE.
	UCPD_CR_ANAMODE = 0x200
	// Position of CCENABLE field.
	UCPD_CR_CCENABLE_Pos = 0xa
	// Bit mask of CCENABLE field.
	UCPD_CR_CCENABLE_Msk = 0xc00
	// Position of DBATTEN field.
	UCPD_CR_DBATTEN_Pos = 0xf
	// Bit mask of DBATTEN field.
	UCPD_CR_DBATTEN_Msk = 0x8000
	// Bit DBATTEN.
	UCPD_CR_DBATTEN = 0x8000
	// Position of FRSRXEN field.
	UCPD_CR_FRSRXEN_Pos = 0x10
	// Bit mask of FRSRXEN field.
	UCPD_CR_FRSRXEN_Msk = 0x10000
	// Bit FRSRXEN.
	UCPD_CR_FRSRXEN = 0x10000
	// Position of FRSTX field.
	UCPD_CR_FRSTX_Pos = 0x11
	// Bit mask of FRSTX field.
	UCPD_CR_FRSTX_Msk = 0x20000
	// Bit FRSTX.
	UCPD_CR_FRSTX = 0x20000
	// Position of RDCH field.
	UCPD_CR_RDCH_Pos = 0x12
	// Bit mask of RDCH field.
	UCPD_CR_RDCH_Msk = 0x40000
	// Bit RDCH.
	UCPD_CR_RDCH = 0x40000
	// Position of CC1TCDIS field.
	UCPD_CR_CC1TCDIS_Pos = 0x14
	// Bit mask of CC1TCDIS field.
	UCPD_CR_CC1TCDIS_Msk = 0x100000
	// Bit CC1TCDIS.
	UCPD_CR_CC1TCDIS = 0x100000
	// Position of CC2TCDIS field.
	UCPD_CR_CC2TCDIS_Pos = 0x15
	// Bit mask of CC2TCDIS field.
	UCPD_CR_CC2TCDIS_Msk = 0x200000
	// Bit CC2TCDIS.
	UCPD_CR_CC2TCDIS = 0x200000

	// IMR: UCPD Interrupt Mask Register
	// Position of TXISIE field.
	UCPD_IMR_TXISIE_Pos = 0x0
	// Bit mask of TXISIE field.
	UCPD_IMR_TXISIE_Msk = 0x1
	// Bit TXISIE.
	UCPD_IMR_TXISIE = 0x1
	// Position of TXMSGDISCIE field.
	UCPD_IMR_TXMSGDISCIE_Pos = 0x1
	// Bit mask of TXMSGDISCIE field.
	UCPD_IMR_TXMSGDISCIE_Msk = 0x2
	// Bit TXMSGDISCIE.
	UCPD_IMR_TXMSGDISCIE = 0x2
	// Position of TXMSGSENTIE field.
	UCPD_IMR_TXMSGSENTIE_Pos = 0x2
	// Bit mask of TXMSGSENTIE field.
	UCPD_IMR_TXMSGSENTIE_Msk = 0x4
	// Bit TXMSGSENTIE.
	UCPD_IMR_TXMSGSENTIE = 0x4
	// Position of TXMSGABTIE field.
	UCPD_IMR_TXMSGABTIE_Pos = 0x3
	// Bit mask of TXMSGABTIE field.
	UCPD_IMR_TXMSGABTIE_Msk = 0x8
	// Bit TXMSGABTIE.
	UCPD_IMR_TXMSGABTIE = 0x8
	// Position of HRSTDISCIE field.
	UCPD_IMR_HRSTDISCIE_Pos = 0x4
	// Bit mask of HRSTDISCIE field.
	UCPD_IMR_HRSTDISCIE_Msk = 0x10
	// Bit HRSTDISCIE.
	UCPD_IMR_HRSTDISCIE = 0x10
	// Position of HRSTSENTIE field.
	UCPD_IMR_HRSTSENTIE_Pos = 0x5
	// Bit mask of HRSTSENTIE field.
	UCPD_IMR_HRSTSENTIE_Msk = 0x20
	// Bit HRSTSENTIE.
	UCPD_IMR_HRSTSENTIE = 0x20
	// Position of TXUNDIE field.
	UCPD_IMR_TXUNDIE_Pos = 0x6
	// Bit mask of TXUNDIE field.
	UCPD_IMR_TXUNDIE_Msk = 0x40
	// Bit TXUNDIE.
	UCPD_IMR_TXUNDIE = 0x40
	// Position of RXNEIE field.
	UCPD_IMR_RXNEIE_Pos = 0x8
	// Bit mask of RXNEIE field.
	UCPD_IMR_RXNEIE_Msk = 0x100
	// Bit RXNEIE.
	UCPD_IMR_RXNEIE = 0x100
	// Position of RXORDDETIE field.
	UCPD_IMR_RXORDDETIE_Pos = 0x9
	// Bit mask of RXORDDETIE field.
	UCPD_IMR_RXORDDETIE_Msk = 0x200
	// Bit RXORDDETIE.
	UCPD_IMR_RXORDDETIE = 0x200
	// Position of RXHRSTDETIE field.
	UCPD_IMR_RXHRSTDETIE_Pos = 0xa
	// Bit mask of RXHRSTDETIE field.
	UCPD_IMR_RXHRSTDETIE_Msk = 0x400
	// Bit RXHRSTDETIE.
	UCPD_IMR_RXHRSTDETIE = 0x400
	// Position of RXOVRIE field.
	UCPD_IMR_RXOVRIE_Pos = 0xb
	// Bit mask of RXOVRIE field.
	UCPD_IMR_RXOVRIE_Msk = 0x800
	// Bit RXOVRIE.
	UCPD_IMR_RXOVRIE = 0x800
	// Position of RXMSGENDIE field.
	UCPD_IMR_RXMSGENDIE_Pos = 0xc
	// Bit mask of RXMSGENDIE field.
	UCPD_IMR_RXMSGENDIE_Msk = 0x1000
	// Bit RXMSGENDIE.
	UCPD_IMR_RXMSGENDIE = 0x1000
	// Position of TYPECEVT1IE field.
	UCPD_IMR_TYPECEVT1IE_Pos = 0xe
	// Bit mask of TYPECEVT1IE field.
	UCPD_IMR_TYPECEVT1IE_Msk = 0x4000
	// Bit TYPECEVT1IE.
	UCPD_IMR_TYPECEVT1IE = 0x4000
	// Position of TYPECEVT2IE field.
	UCPD_IMR_TYPECEVT2IE_Pos = 0xf
	// Bit mask of TYPECEVT2IE field.
	UCPD_IMR_TYPECEVT2IE_Msk = 0x8000
	// Bit TYPECEVT2IE.
	UCPD_IMR_TYPECEVT2IE = 0x8000
	// Position of FRSEVTIE field.
	UCPD_IMR_FRSEVTIE_Pos = 0x14
	// Bit mask of FRSEVTIE field.
	UCPD_IMR_FRSEVTIE_Msk = 0x100000
	// Bit FRSEVTIE.
	UCPD_IMR_FRSEVTIE = 0x100000

	// SR: UCPD Status Register
	// Position of TXIS field.
	UCPD_SR_TXIS_Pos = 0x0
	// Bit mask of TXIS field.
	UCPD_SR_TXIS_Msk = 0x1
	// Bit TXIS.
	UCPD_SR_TXIS = 0x1
	// Position of TXMSGDISC field.
	UCPD_SR_TXMSGDISC_Pos = 0x1
	// Bit mask of TXMSGDISC field.
	UCPD_SR_TXMSGDISC_Msk = 0x2
	// Bit TXMSGDISC.
	UCPD_SR_TXMSGDISC = 0x2
	// Position of TXMSGSENT field.
	UCPD_SR_TXMSGSENT_Pos = 0x2
	// Bit mask of TXMSGSENT field.
	UCPD_SR_TXMSGSENT_Msk = 0x4
	// Bit TXMSGSENT.
	UCPD_SR_TXMSGSENT = 0x4
	// Position of TXMSGABT field.
	UCPD_SR_TXMSGABT_Pos = 0x3
	// Bit mask of TXMSGABT field.
	UCPD_SR_TXMSGABT_Msk = 0x8
	// Bit TXMSGABT.
	UCPD_SR_TXMSGABT = 0x8
	// Position of HRSTDISC field.
	UCPD_SR_HRSTDISC_Pos = 0x4
	// Bit mask of HRSTDISC field.
	UCPD_SR_HRSTDISC_Msk = 0x10
	// Bit HRSTDISC.
	UCPD_SR_HRSTDISC = 0x10
	// Position of HRSTSENT field.
	UCPD_SR_HRSTSENT_Pos = 0x5
	// Bit mask of HRSTSENT field.
	UCPD_SR_HRSTSENT_Msk = 0x20
	// Bit HRSTSENT.
	UCPD_SR_HRSTSENT = 0x20
	// Position of TXUND field.
	UCPD_SR_TXUND_Pos = 0x6
	// Bit mask of TXUND field.
	UCPD_SR_TXUND_Msk = 0x40
	// Bit TXUND.
	UCPD_SR_TXUND = 0x40
	// Position of RXNE field.
	UCPD_SR_RXNE_Pos = 0x8
	// Bit mask of RXNE field.
	UCPD_SR_RXNE_Msk = 0x100
	// Bit RXNE.
	UCPD_SR_RXNE = 0x100
	// Position of RXORDDET field.
	UCPD_SR_RXORDDET_Pos = 0x9
	// Bit mask of RXORDDET field.
	UCPD_SR_RXORDDET_Msk = 0x200
	// Bit RXORDDET.
	UCPD_SR_RXORDDET = 0x200
	// Position of RXHRSTDET field.
	UCPD_SR_RXHRSTDET_Pos = 0xa
	// Bit mask of RXHRSTDET field.
	UCPD_SR_RXHRSTDET_Msk = 0x400
	// Bit RXHRSTDET.
	UCPD_SR_RXHRSTDET = 0x400
	// Position of RXOVR field.
	UCPD_SR_RXOVR_Pos = 0xb
	// Bit mask of RXOVR field.
	UCPD_SR_RXOVR_Msk = 0x800
	// Bit RXOVR.
	UCPD_SR_RXOVR = 0x800
	// Position of RXMSGEND field.
	UCPD_SR_RXMSGEND_Pos = 0xc
	// Bit mask of RXMSGEND field.
	UCPD_SR_RXMSGEND_Msk = 0x1000
	// Bit RXMSGEND.
	UCPD_SR_RXMSGEND = 0x1000
	// Position of RXERR field.
	UCPD_SR_RXERR_Pos = 0xd
	// Bit mask of RXERR field.
	UCPD_SR_RXERR_Msk = 0x2000
	// Bit RXERR.
	UCPD_SR_RXERR = 0x2000
	// Position of TYPECEVT1 field.
	UCPD_SR_TYPECEVT1_Pos = 0xe
	// Bit mask of TYPECEVT1 field.
	UCPD_SR_TYPECEVT1_Msk = 0x4000
	// Bit TYPECEVT1.
	UCPD_SR_TYPECEVT1 = 0x4000
	// Position of TYPECEVT2 field.
	UCPD_SR_TYPECEVT2_Pos = 0xf
	// Bit mask of TYPECEVT2 field.
	UCPD_SR_TYPECEVT2_Msk = 0x8000
	// Bit TYPECEVT2.
	UCPD_SR_TYPECEVT2 = 0x8000
	// Position of TYPEC_VSTATE_CC1 field.
	UCPD_SR_TYPEC_VSTATE_CC1_Pos = 0x10
	// Bit mask of TYPEC_VSTATE_CC1 field.
	UCPD_SR_TYPEC_VSTATE_CC1_Msk = 0x30000
	// Position of TYPEC_VSTATE_CC2 field.
	UCPD_SR_TYPEC_VSTATE_CC2_Pos = 0x12
	// Bit mask of TYPEC_VSTATE_CC2 field.
	UCPD_SR_TYPEC_VSTATE_CC2_Msk = 0xc0000
	// Position of FRSEVT field.
	UCPD_SR_FRSEVT_Pos = 0x14
	// Bit mask of FRSEVT field.
	UCPD_SR_FRSEVT_Msk = 0x100000
	// Bit FRSEVT.
	UCPD_SR_FRSEVT = 0x100000

	// ICR: UCPD Interrupt Clear Register
	// Position of TXMSGDISCCF field.
	UCPD_ICR_TXMSGDISCCF_Pos = 0x1
	// Bit mask of TXMSGDISCCF field.
	UCPD_ICR_TXMSGDISCCF_Msk = 0x2
	// Bit TXMSGDISCCF.
	UCPD_ICR_TXMSGDISCCF = 0x2
	// Position of TXMSGSENTCF field.
	UCPD_ICR_TXMSGSENTCF_Pos = 0x2
	// Bit mask of TXMSGSENTCF field.
	UCPD_ICR_TXMSGSENTCF_Msk = 0x4
	// Bit TXMSGSENTCF.
	UCPD_ICR_TXMSGSENTCF = 0x4
	// Position of TXMSGABTCF field.
	UCPD_ICR_TXMSGABTCF_Pos = 0x3
	// Bit mask of TXMSGABTCF field.
	UCPD_ICR_TXMSGABTCF_Msk = 0x8
	// Bit TXMSGABTCF.
	UCPD_ICR_TXMSGABTCF = 0x8
	// Position of HRSTDISCCF field.
	UCPD_ICR_HRSTDISCCF_Pos = 0x4
	// Bit mask of HRSTDISCCF field.
	UCPD_ICR_HRSTDISCCF_Msk = 0x10
	// Bit HRSTDISCCF.
	UCPD_ICR_HRSTDISCCF = 0x10
	// Position of HRSTSENTCF field.
	UCPD_ICR_HRSTSENTCF_Pos = 0x5
	// Bit mask of HRSTSENTCF field.
	UCPD_ICR_HRSTSENTCF_Msk = 0x20
	// Bit HRSTSENTCF.
	UCPD_ICR_HRSTSENTCF = 0x20
	// Position of TXUNDCF field.
	UCPD_ICR_TXUNDCF_Pos = 0x6
	// Bit mask of TXUNDCF field.
	UCPD_ICR_TXUNDCF_Msk = 0x40
	// Bit TXUNDCF.
	UCPD_ICR_TXUNDCF = 0x40
	// Position of RXORDDETCF field.
	UCPD_ICR_RXORDDETCF_Pos = 0x9
	// Bit mask of RXORDDETCF field.
	UCPD_ICR_RXORDDETCF_Msk = 0x200
	// Bit RXORDDETCF.
	UCPD_ICR_RXORDDETCF = 0x200
	// Position of RXHRSTDETCF field.
	UCPD_ICR_RXHRSTDETCF_Pos = 0xa
	// Bit mask of RXHRSTDETCF field.
	UCPD_ICR_RXHRSTDETCF_Msk = 0x400
	// Bit RXHRSTDETCF.
	UCPD_ICR_RXHRSTDETCF = 0x400
	// Position of RXOVRCF field.
	UCPD_ICR_RXOVRCF_Pos = 0xb
	// Bit mask of RXOVRCF field.
	UCPD_ICR_RXOVRCF_Msk = 0x800
	// Bit RXOVRCF.
	UCPD_ICR_RXOVRCF = 0x800
	// Position of RXMSGENDCF field.
	UCPD_ICR_RXMSGENDCF_Pos = 0xc
	// Bit mask of RXMSGENDCF field.
	UCPD_ICR_RXMSGENDCF_Msk = 0x1000
	// Bit RXMSGENDCF.
	UCPD_ICR_RXMSGENDCF = 0x1000
	// Position of TYPECEVT1CF field.
	UCPD_ICR_TYPECEVT1CF_Pos = 0xe
	// Bit mask of TYPECEVT1CF field.
	UCPD_ICR_TYPECEVT1CF_Msk = 0x4000
	// Bit TYPECEVT1CF.
	UCPD_ICR_TYPECEVT1CF = 0x4000
	// Position of TYPECEVT2CF field.
	UCPD_ICR_TYPECEVT2CF_Pos = 0xf
	// Bit mask of TYPECEVT2CF field.
	UCPD_ICR_TYPECEVT2CF_Msk = 0x8000
	// Bit TYPECEVT2CF.
	UCPD_ICR_TYPECEVT2CF = 0x8000
	// Position of FRSEVTCF field.
	UCPD_ICR_FRSEVTCF_Pos = 0x14
	// Bit mask of FRSEVTCF field.
	UCPD_ICR_FRSEVTCF_Msk = 0x100000
	// Bit FRSEVTCF.
	UCPD_ICR_FRSEVTCF = 0x100000

	// TX_ORDSET: UCPD Tx Ordered Set Type Register
	// Position of TXORDSET field.
	UCPD_TX_ORDSET_TXORDSET_Pos = 0x0
	// Bit mask of TXORDSET field.
	UCPD_TX_ORDSET_TXORDSET_Msk = 0xfffff

	// TX_PAYSZ: UCPD Tx Paysize Register
	// Position of TXPAYSZ field.
	UCPD_TX_PAYSZ_TXPAYSZ_Pos = 0x0
	// Bit mask of TXPAYSZ field.
	UCPD_TX_PAYSZ_TXPAYSZ_Msk = 0x3ff

	// TXDR: UCPD Tx Data Register
	// Position of TXDATA field.
	UCPD_TXDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	UCPD_TXDR_TXDATA_Msk = 0xff

	// RX_ORDSET: UCPD Rx Ordered Set Register
	// Position of RXORDSET field.
	UCPD_RX_ORDSET_RXORDSET_Pos = 0x0
	// Bit mask of RXORDSET field.
	UCPD_RX_ORDSET_RXORDSET_Msk = 0x7
	// Position of RXSOP3OF4 field.
	UCPD_RX_ORDSET_RXSOP3OF4_Pos = 0x3
	// Bit mask of RXSOP3OF4 field.
	UCPD_RX_ORDSET_RXSOP3OF4_Msk = 0x8
	// Bit RXSOP3OF4.
	UCPD_RX_ORDSET_RXSOP3OF4 = 0x8
	// Position of RXSOPKINVALID field.
	UCPD_RX_ORDSET_RXSOPKINVALID_Pos = 0x4
	// Bit mask of RXSOPKINVALID field.
	UCPD_RX_ORDSET_RXSOPKINVALID_Msk = 0x70

	// RX_PAYSZ: UCPD Rx Paysize Register
	// Position of RXPAYSZ field.
	UCPD_RX_PAYSZ_RXPAYSZ_Pos = 0x0
	// Bit mask of RXPAYSZ field.
	UCPD_RX_PAYSZ_RXPAYSZ_Msk = 0x3ff

	// RXDR: UCPD Receive Data Register
	// Position of RXDATA field.
	UCPD_RXDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	UCPD_RXDR_RXDATA_Msk = 0xff

	// RX_ORDEXT1: UCPD Rx Ordered Set Extension Register
	// Position of RXSOPX1 field.
	UCPD_RX_ORDEXT1_RXSOPX1_Pos = 0x0
	// Bit mask of RXSOPX1 field.
	UCPD_RX_ORDEXT1_RXSOPX1_Msk = 0xfffff

	// RX_ORDEXT2: UCPD Rx Ordered Set Extension Register
	// Position of RXSOPX2 field.
	UCPD_RX_ORDEXT2_RXSOPX2_Pos = 0x0
	// Bit mask of RXSOPX2 field.
	UCPD_RX_ORDEXT2_RXSOPX2_Msk = 0xfffff

	// IPVER: UCPD IP ID register
	// Position of IPVER field.
	UCPD_IPVER_IPVER_Pos = 0x0
	// Bit mask of IPVER field.
	UCPD_IPVER_IPVER_Msk = 0xffffffff

	// IPID: UCPD IP ID register
	// Position of IPID field.
	UCPD_IPID_IPID_Pos = 0x0
	// Bit mask of IPID field.
	UCPD_IPID_IPID_Msk = 0xffffffff

	// MID: UCPD IP ID register
	// Position of IPID field.
	UCPD_MID_IPID_Pos = 0x0
	// Bit mask of IPID field.
	UCPD_MID_IPID_Msk = 0xffffffff
)

// Constants for LPTIM1: Low power timer
const (
	// ISR: Interrupt and Status Register
	// Position of DOWN field.
	LPTIM_ISR_DOWN_Pos = 0x6
	// Bit mask of DOWN field.
	LPTIM_ISR_DOWN_Msk = 0x40
	// Bit DOWN.
	LPTIM_ISR_DOWN = 0x40
	// Position of UP field.
	LPTIM_ISR_UP_Pos = 0x5
	// Bit mask of UP field.
	LPTIM_ISR_UP_Msk = 0x20
	// Bit UP.
	LPTIM_ISR_UP = 0x20
	// Position of ARROK field.
	LPTIM_ISR_ARROK_Pos = 0x4
	// Bit mask of ARROK field.
	LPTIM_ISR_ARROK_Msk = 0x10
	// Bit ARROK.
	LPTIM_ISR_ARROK = 0x10
	// Position of CMPOK field.
	LPTIM_ISR_CMPOK_Pos = 0x3
	// Bit mask of CMPOK field.
	LPTIM_ISR_CMPOK_Msk = 0x8
	// Bit CMPOK.
	LPTIM_ISR_CMPOK = 0x8
	// Position of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Pos = 0x2
	// Bit mask of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Msk = 0x4
	// Bit EXTTRIG.
	LPTIM_ISR_EXTTRIG = 0x4
	// Position of ARRM field.
	LPTIM_ISR_ARRM_Pos = 0x1
	// Bit mask of ARRM field.
	LPTIM_ISR_ARRM_Msk = 0x2
	// Bit ARRM.
	LPTIM_ISR_ARRM = 0x2
	// Position of CMPM field.
	LPTIM_ISR_CMPM_Pos = 0x0
	// Bit mask of CMPM field.
	LPTIM_ISR_CMPM_Msk = 0x1
	// Bit CMPM.
	LPTIM_ISR_CMPM = 0x1

	// ICR: Interrupt Clear Register
	// Position of DOWNCF field.
	LPTIM_ICR_DOWNCF_Pos = 0x6
	// Bit mask of DOWNCF field.
	LPTIM_ICR_DOWNCF_Msk = 0x40
	// Bit DOWNCF.
	LPTIM_ICR_DOWNCF = 0x40
	// Position of UPCF field.
	LPTIM_ICR_UPCF_Pos = 0x5
	// Bit mask of UPCF field.
	LPTIM_ICR_UPCF_Msk = 0x20
	// Bit UPCF.
	LPTIM_ICR_UPCF = 0x20
	// Position of ARROKCF field.
	LPTIM_ICR_ARROKCF_Pos = 0x4
	// Bit mask of ARROKCF field.
	LPTIM_ICR_ARROKCF_Msk = 0x10
	// Bit ARROKCF.
	LPTIM_ICR_ARROKCF = 0x10
	// Position of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Pos = 0x3
	// Bit mask of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Msk = 0x8
	// Bit CMPOKCF.
	LPTIM_ICR_CMPOKCF = 0x8
	// Position of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Pos = 0x2
	// Bit mask of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Msk = 0x4
	// Bit EXTTRIGCF.
	LPTIM_ICR_EXTTRIGCF = 0x4
	// Position of ARRMCF field.
	LPTIM_ICR_ARRMCF_Pos = 0x1
	// Bit mask of ARRMCF field.
	LPTIM_ICR_ARRMCF_Msk = 0x2
	// Bit ARRMCF.
	LPTIM_ICR_ARRMCF = 0x2
	// Position of CMPMCF field.
	LPTIM_ICR_CMPMCF_Pos = 0x0
	// Bit mask of CMPMCF field.
	LPTIM_ICR_CMPMCF_Msk = 0x1
	// Bit CMPMCF.
	LPTIM_ICR_CMPMCF = 0x1

	// IER: Interrupt Enable Register
	// Position of DOWNIE field.
	LPTIM_IER_DOWNIE_Pos = 0x6
	// Bit mask of DOWNIE field.
	LPTIM_IER_DOWNIE_Msk = 0x40
	// Bit DOWNIE.
	LPTIM_IER_DOWNIE = 0x40
	// Position of UPIE field.
	LPTIM_IER_UPIE_Pos = 0x5
	// Bit mask of UPIE field.
	LPTIM_IER_UPIE_Msk = 0x20
	// Bit UPIE.
	LPTIM_IER_UPIE = 0x20
	// Position of ARROKIE field.
	LPTIM_IER_ARROKIE_Pos = 0x4
	// Bit mask of ARROKIE field.
	LPTIM_IER_ARROKIE_Msk = 0x10
	// Bit ARROKIE.
	LPTIM_IER_ARROKIE = 0x10
	// Position of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Pos = 0x3
	// Bit mask of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Msk = 0x8
	// Bit CMPOKIE.
	LPTIM_IER_CMPOKIE = 0x8
	// Position of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Pos = 0x2
	// Bit mask of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Msk = 0x4
	// Bit EXTTRIGIE.
	LPTIM_IER_EXTTRIGIE = 0x4
	// Position of ARRMIE field.
	LPTIM_IER_ARRMIE_Pos = 0x1
	// Bit mask of ARRMIE field.
	LPTIM_IER_ARRMIE_Msk = 0x2
	// Bit ARRMIE.
	LPTIM_IER_ARRMIE = 0x2
	// Position of CMPMIE field.
	LPTIM_IER_CMPMIE_Pos = 0x0
	// Bit mask of CMPMIE field.
	LPTIM_IER_CMPMIE_Msk = 0x1
	// Bit CMPMIE.
	LPTIM_IER_CMPMIE = 0x1

	// CFGR: Configuration Register
	// Position of ENC field.
	LPTIM_CFGR_ENC_Pos = 0x18
	// Bit mask of ENC field.
	LPTIM_CFGR_ENC_Msk = 0x1000000
	// Bit ENC.
	LPTIM_CFGR_ENC = 0x1000000
	// Position of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Pos = 0x17
	// Bit mask of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Msk = 0x800000
	// Bit COUNTMODE.
	LPTIM_CFGR_COUNTMODE = 0x800000
	// Position of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Pos = 0x16
	// Bit mask of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Msk = 0x400000
	// Bit PRELOAD.
	LPTIM_CFGR_PRELOAD = 0x400000
	// Position of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Pos = 0x15
	// Bit mask of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Msk = 0x200000
	// Bit WAVPOL.
	LPTIM_CFGR_WAVPOL = 0x200000
	// Position of WAVE field.
	LPTIM_CFGR_WAVE_Pos = 0x14
	// Bit mask of WAVE field.
	LPTIM_CFGR_WAVE_Msk = 0x100000
	// Bit WAVE.
	LPTIM_CFGR_WAVE = 0x100000
	// Position of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Pos = 0x13
	// Bit mask of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Msk = 0x80000
	// Bit TIMOUT.
	LPTIM_CFGR_TIMOUT = 0x80000
	// Position of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Pos = 0x11
	// Bit mask of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Msk = 0x60000
	// Position of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Pos = 0xd
	// Bit mask of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Msk = 0xe000
	// Position of PRESC field.
	LPTIM_CFGR_PRESC_Pos = 0x9
	// Bit mask of PRESC field.
	LPTIM_CFGR_PRESC_Msk = 0xe00
	// Position of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Pos = 0x6
	// Bit mask of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Msk = 0xc0
	// Position of CKFLT field.
	LPTIM_CFGR_CKFLT_Pos = 0x3
	// Bit mask of CKFLT field.
	LPTIM_CFGR_CKFLT_Msk = 0x18
	// Position of CKPOL field.
	LPTIM_CFGR_CKPOL_Pos = 0x1
	// Bit mask of CKPOL field.
	LPTIM_CFGR_CKPOL_Msk = 0x6
	// Position of CKSEL field.
	LPTIM_CFGR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	LPTIM_CFGR_CKSEL_Msk = 0x1
	// Bit CKSEL.
	LPTIM_CFGR_CKSEL = 0x1

	// CR: Control Register
	// Position of RSTARE field.
	LPTIM_CR_RSTARE_Pos = 0x4
	// Bit mask of RSTARE field.
	LPTIM_CR_RSTARE_Msk = 0x10
	// Bit RSTARE.
	LPTIM_CR_RSTARE = 0x10
	// Position of COUNTRST field.
	LPTIM_CR_COUNTRST_Pos = 0x3
	// Bit mask of COUNTRST field.
	LPTIM_CR_COUNTRST_Msk = 0x8
	// Bit COUNTRST.
	LPTIM_CR_COUNTRST = 0x8
	// Position of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Pos = 0x2
	// Bit mask of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Msk = 0x4
	// Bit CNTSTRT.
	LPTIM_CR_CNTSTRT = 0x4
	// Position of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Pos = 0x1
	// Bit mask of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Msk = 0x2
	// Bit SNGSTRT.
	LPTIM_CR_SNGSTRT = 0x2
	// Position of ENABLE field.
	LPTIM_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPTIM_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	LPTIM_CR_ENABLE = 0x1

	// CMP: Compare Register
	// Position of CMP field.
	LPTIM_CMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	LPTIM_CMP_CMP_Msk = 0xffff

	// ARR: Autoreload Register
	// Position of ARR field.
	LPTIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	LPTIM_ARR_ARR_Msk = 0xffff

	// CNT: Counter Register
	// Position of CNT field.
	LPTIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	LPTIM_CNT_CNT_Msk = 0xffff

	// CFGR2: LPTIM configuration register 2
	// Position of IN2SEL field.
	LPTIM_CFGR2_IN2SEL_Pos = 0x4
	// Bit mask of IN2SEL field.
	LPTIM_CFGR2_IN2SEL_Msk = 0x30
	// Position of IN1SEL field.
	LPTIM_CFGR2_IN1SEL_Pos = 0x0
	// Bit mask of IN1SEL field.
	LPTIM_CFGR2_IN1SEL_Msk = 0x3
)

// Constants for HDMI_CEC: HDMI-CEC
const (
	// CEC_CR: CEC control register
	// Position of CECEN field.
	CEC_CEC_CR_CECEN_Pos = 0x0
	// Bit mask of CECEN field.
	CEC_CEC_CR_CECEN_Msk = 0x1
	// Bit CECEN.
	CEC_CEC_CR_CECEN = 0x1
	// Position of TXSOM field.
	CEC_CEC_CR_TXSOM_Pos = 0x1
	// Bit mask of TXSOM field.
	CEC_CEC_CR_TXSOM_Msk = 0x2
	// Bit TXSOM.
	CEC_CEC_CR_TXSOM = 0x2
	// Position of TXEOM field.
	CEC_CEC_CR_TXEOM_Pos = 0x2
	// Bit mask of TXEOM field.
	CEC_CEC_CR_TXEOM_Msk = 0x4
	// Bit TXEOM.
	CEC_CEC_CR_TXEOM = 0x4

	// CEC_CFGR: This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
	// Position of SFT field.
	CEC_CEC_CFGR_SFT_Pos = 0x0
	// Bit mask of SFT field.
	CEC_CEC_CFGR_SFT_Msk = 0x7
	// Position of RXTOL field.
	CEC_CEC_CFGR_RXTOL_Pos = 0x3
	// Bit mask of RXTOL field.
	CEC_CEC_CFGR_RXTOL_Msk = 0x8
	// Bit RXTOL.
	CEC_CEC_CFGR_RXTOL = 0x8
	// Position of BRESTP field.
	CEC_CEC_CFGR_BRESTP_Pos = 0x4
	// Bit mask of BRESTP field.
	CEC_CEC_CFGR_BRESTP_Msk = 0x10
	// Bit BRESTP.
	CEC_CEC_CFGR_BRESTP = 0x10
	// Position of BREGEN field.
	CEC_CEC_CFGR_BREGEN_Pos = 0x5
	// Bit mask of BREGEN field.
	CEC_CEC_CFGR_BREGEN_Msk = 0x20
	// Bit BREGEN.
	CEC_CEC_CFGR_BREGEN = 0x20
	// Position of LBPEGEN field.
	CEC_CEC_CFGR_LBPEGEN_Pos = 0x6
	// Bit mask of LBPEGEN field.
	CEC_CEC_CFGR_LBPEGEN_Msk = 0x40
	// Bit LBPEGEN.
	CEC_CEC_CFGR_LBPEGEN = 0x40
	// Position of BRDNOGEN field.
	CEC_CEC_CFGR_BRDNOGEN_Pos = 0x7
	// Bit mask of BRDNOGEN field.
	CEC_CEC_CFGR_BRDNOGEN_Msk = 0x80
	// Bit BRDNOGEN.
	CEC_CEC_CFGR_BRDNOGEN = 0x80
	// Position of SFTOPT field.
	CEC_CEC_CFGR_SFTOPT_Pos = 0x8
	// Bit mask of SFTOPT field.
	CEC_CEC_CFGR_SFTOPT_Msk = 0x100
	// Bit SFTOPT.
	CEC_CEC_CFGR_SFTOPT = 0x100
	// Position of OAR field.
	CEC_CEC_CFGR_OAR_Pos = 0x10
	// Bit mask of OAR field.
	CEC_CEC_CFGR_OAR_Msk = 0x7fff0000
	// Position of LSTN field.
	CEC_CEC_CFGR_LSTN_Pos = 0x1f
	// Bit mask of LSTN field.
	CEC_CEC_CFGR_LSTN_Msk = 0x80000000
	// Bit LSTN.
	CEC_CEC_CFGR_LSTN = 0x80000000

	// CEC_TXDR: CEC Tx data register
	// Position of TXD field.
	CEC_CEC_TXDR_TXD_Pos = 0x0
	// Bit mask of TXD field.
	CEC_CEC_TXDR_TXD_Msk = 0xff

	// CEC_RXDR: CEC Rx Data Register
	// Position of RXD field.
	CEC_CEC_RXDR_RXD_Pos = 0x0
	// Bit mask of RXD field.
	CEC_CEC_RXDR_RXD_Msk = 0xff

	// CEC_ISR: CEC Interrupt and Status Register
	// Position of RXBR field.
	CEC_CEC_ISR_RXBR_Pos = 0x0
	// Bit mask of RXBR field.
	CEC_CEC_ISR_RXBR_Msk = 0x1
	// Bit RXBR.
	CEC_CEC_ISR_RXBR = 0x1
	// Position of RXEND field.
	CEC_CEC_ISR_RXEND_Pos = 0x1
	// Bit mask of RXEND field.
	CEC_CEC_ISR_RXEND_Msk = 0x2
	// Bit RXEND.
	CEC_CEC_ISR_RXEND = 0x2
	// Position of RXOVR field.
	CEC_CEC_ISR_RXOVR_Pos = 0x2
	// Bit mask of RXOVR field.
	CEC_CEC_ISR_RXOVR_Msk = 0x4
	// Bit RXOVR.
	CEC_CEC_ISR_RXOVR = 0x4
	// Position of BRE field.
	CEC_CEC_ISR_BRE_Pos = 0x3
	// Bit mask of BRE field.
	CEC_CEC_ISR_BRE_Msk = 0x8
	// Bit BRE.
	CEC_CEC_ISR_BRE = 0x8
	// Position of SBPE field.
	CEC_CEC_ISR_SBPE_Pos = 0x4
	// Bit mask of SBPE field.
	CEC_CEC_ISR_SBPE_Msk = 0x10
	// Bit SBPE.
	CEC_CEC_ISR_SBPE = 0x10
	// Position of LBPE field.
	CEC_CEC_ISR_LBPE_Pos = 0x5
	// Bit mask of LBPE field.
	CEC_CEC_ISR_LBPE_Msk = 0x20
	// Bit LBPE.
	CEC_CEC_ISR_LBPE = 0x20
	// Position of RXACKE field.
	CEC_CEC_ISR_RXACKE_Pos = 0x6
	// Bit mask of RXACKE field.
	CEC_CEC_ISR_RXACKE_Msk = 0x40
	// Bit RXACKE.
	CEC_CEC_ISR_RXACKE = 0x40
	// Position of ARBLST field.
	CEC_CEC_ISR_ARBLST_Pos = 0x7
	// Bit mask of ARBLST field.
	CEC_CEC_ISR_ARBLST_Msk = 0x80
	// Bit ARBLST.
	CEC_CEC_ISR_ARBLST = 0x80
	// Position of TXBR field.
	CEC_CEC_ISR_TXBR_Pos = 0x8
	// Bit mask of TXBR field.
	CEC_CEC_ISR_TXBR_Msk = 0x100
	// Bit TXBR.
	CEC_CEC_ISR_TXBR = 0x100
	// Position of TXEND field.
	CEC_CEC_ISR_TXEND_Pos = 0x9
	// Bit mask of TXEND field.
	CEC_CEC_ISR_TXEND_Msk = 0x200
	// Bit TXEND.
	CEC_CEC_ISR_TXEND = 0x200
	// Position of TXUDR field.
	CEC_CEC_ISR_TXUDR_Pos = 0xa
	// Bit mask of TXUDR field.
	CEC_CEC_ISR_TXUDR_Msk = 0x400
	// Bit TXUDR.
	CEC_CEC_ISR_TXUDR = 0x400
	// Position of TXERR field.
	CEC_CEC_ISR_TXERR_Pos = 0xb
	// Bit mask of TXERR field.
	CEC_CEC_ISR_TXERR_Msk = 0x800
	// Bit TXERR.
	CEC_CEC_ISR_TXERR = 0x800
	// Position of TXACKE field.
	CEC_CEC_ISR_TXACKE_Pos = 0xc
	// Bit mask of TXACKE field.
	CEC_CEC_ISR_TXACKE_Msk = 0x1000
	// Bit TXACKE.
	CEC_CEC_ISR_TXACKE = 0x1000

	// CEC_IER: CEC interrupt enable register
	// Position of RXBRIE field.
	CEC_CEC_IER_RXBRIE_Pos = 0x0
	// Bit mask of RXBRIE field.
	CEC_CEC_IER_RXBRIE_Msk = 0x1
	// Bit RXBRIE.
	CEC_CEC_IER_RXBRIE = 0x1
	// Position of RXENDIE field.
	CEC_CEC_IER_RXENDIE_Pos = 0x1
	// Bit mask of RXENDIE field.
	CEC_CEC_IER_RXENDIE_Msk = 0x2
	// Bit RXENDIE.
	CEC_CEC_IER_RXENDIE = 0x2
	// Position of RXOVRIE field.
	CEC_CEC_IER_RXOVRIE_Pos = 0x2
	// Bit mask of RXOVRIE field.
	CEC_CEC_IER_RXOVRIE_Msk = 0x4
	// Bit RXOVRIE.
	CEC_CEC_IER_RXOVRIE = 0x4
	// Position of BREIE field.
	CEC_CEC_IER_BREIE_Pos = 0x3
	// Bit mask of BREIE field.
	CEC_CEC_IER_BREIE_Msk = 0x8
	// Bit BREIE.
	CEC_CEC_IER_BREIE = 0x8
	// Position of SBPEIE field.
	CEC_CEC_IER_SBPEIE_Pos = 0x4
	// Bit mask of SBPEIE field.
	CEC_CEC_IER_SBPEIE_Msk = 0x10
	// Bit SBPEIE.
	CEC_CEC_IER_SBPEIE = 0x10
	// Position of LBPEIE field.
	CEC_CEC_IER_LBPEIE_Pos = 0x5
	// Bit mask of LBPEIE field.
	CEC_CEC_IER_LBPEIE_Msk = 0x20
	// Bit LBPEIE.
	CEC_CEC_IER_LBPEIE = 0x20
	// Position of RXACKIE field.
	CEC_CEC_IER_RXACKIE_Pos = 0x6
	// Bit mask of RXACKIE field.
	CEC_CEC_IER_RXACKIE_Msk = 0x40
	// Bit RXACKIE.
	CEC_CEC_IER_RXACKIE = 0x40
	// Position of ARBLSTIE field.
	CEC_CEC_IER_ARBLSTIE_Pos = 0x7
	// Bit mask of ARBLSTIE field.
	CEC_CEC_IER_ARBLSTIE_Msk = 0x80
	// Bit ARBLSTIE.
	CEC_CEC_IER_ARBLSTIE = 0x80
	// Position of TXBRIE field.
	CEC_CEC_IER_TXBRIE_Pos = 0x8
	// Bit mask of TXBRIE field.
	CEC_CEC_IER_TXBRIE_Msk = 0x100
	// Bit TXBRIE.
	CEC_CEC_IER_TXBRIE = 0x100
	// Position of TXENDIE field.
	CEC_CEC_IER_TXENDIE_Pos = 0x9
	// Bit mask of TXENDIE field.
	CEC_CEC_IER_TXENDIE_Msk = 0x200
	// Bit TXENDIE.
	CEC_CEC_IER_TXENDIE = 0x200
	// Position of TXUDRIE field.
	CEC_CEC_IER_TXUDRIE_Pos = 0xa
	// Bit mask of TXUDRIE field.
	CEC_CEC_IER_TXUDRIE_Msk = 0x400
	// Bit TXUDRIE.
	CEC_CEC_IER_TXUDRIE = 0x400
	// Position of TXERRIE field.
	CEC_CEC_IER_TXERRIE_Pos = 0xb
	// Bit mask of TXERRIE field.
	CEC_CEC_IER_TXERRIE_Msk = 0x800
	// Bit TXERRIE.
	CEC_CEC_IER_TXERRIE = 0x800
	// Position of TXACKIE field.
	CEC_CEC_IER_TXACKIE_Pos = 0xc
	// Bit mask of TXACKIE field.
	CEC_CEC_IER_TXACKIE_Msk = 0x1000
	// Bit TXACKIE.
	CEC_CEC_IER_TXACKIE = 0x1000
)

// Constants for DAC: DAC
const (
	// CR: DAC control register
	// Position of EN1 field.
	DAC_CR_EN1_Pos = 0x0
	// Bit mask of EN1 field.
	DAC_CR_EN1_Msk = 0x1
	// Bit EN1.
	DAC_CR_EN1 = 0x1
	// Position of TEN1 field.
	DAC_CR_TEN1_Pos = 0x1
	// Bit mask of TEN1 field.
	DAC_CR_TEN1_Msk = 0x2
	// Bit TEN1.
	DAC_CR_TEN1 = 0x2
	// Position of TSEL1 field.
	DAC_CR_TSEL1_Pos = 0x2
	// Bit mask of TSEL1 field.
	DAC_CR_TSEL1_Msk = 0x3c
	// Position of WAVE1 field.
	DAC_CR_WAVE1_Pos = 0x6
	// Bit mask of WAVE1 field.
	DAC_CR_WAVE1_Msk = 0xc0
	// Position of MAMP1 field.
	DAC_CR_MAMP1_Pos = 0x8
	// Bit mask of MAMP1 field.
	DAC_CR_MAMP1_Msk = 0xf00
	// Position of DMAEN1 field.
	DAC_CR_DMAEN1_Pos = 0xc
	// Bit mask of DMAEN1 field.
	DAC_CR_DMAEN1_Msk = 0x1000
	// Bit DMAEN1.
	DAC_CR_DMAEN1 = 0x1000
	// Position of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Pos = 0xd
	// Bit mask of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Msk = 0x2000
	// Bit DMAUDRIE1.
	DAC_CR_DMAUDRIE1 = 0x2000
	// Position of CEN1 field.
	DAC_CR_CEN1_Pos = 0xe
	// Bit mask of CEN1 field.
	DAC_CR_CEN1_Msk = 0x4000
	// Bit CEN1.
	DAC_CR_CEN1 = 0x4000
	// Position of EN2 field.
	DAC_CR_EN2_Pos = 0x10
	// Bit mask of EN2 field.
	DAC_CR_EN2_Msk = 0x10000
	// Bit EN2.
	DAC_CR_EN2 = 0x10000
	// Position of TEN2 field.
	DAC_CR_TEN2_Pos = 0x11
	// Bit mask of TEN2 field.
	DAC_CR_TEN2_Msk = 0x20000
	// Bit TEN2.
	DAC_CR_TEN2 = 0x20000
	// Position of TSEL2 field.
	DAC_CR_TSEL2_Pos = 0x12
	// Bit mask of TSEL2 field.
	DAC_CR_TSEL2_Msk = 0x3c0000
	// Position of WAVE2 field.
	DAC_CR_WAVE2_Pos = 0x16
	// Bit mask of WAVE2 field.
	DAC_CR_WAVE2_Msk = 0xc00000
	// Position of MAMP2 field.
	DAC_CR_MAMP2_Pos = 0x18
	// Bit mask of MAMP2 field.
	DAC_CR_MAMP2_Msk = 0xf000000
	// Position of DMAEN2 field.
	DAC_CR_DMAEN2_Pos = 0x1c
	// Bit mask of DMAEN2 field.
	DAC_CR_DMAEN2_Msk = 0x10000000
	// Bit DMAEN2.
	DAC_CR_DMAEN2 = 0x10000000
	// Position of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Pos = 0x1d
	// Bit mask of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Msk = 0x20000000
	// Bit DMAUDRIE2.
	DAC_CR_DMAUDRIE2 = 0x20000000
	// Position of CEN2 field.
	DAC_CR_CEN2_Pos = 0x1e
	// Bit mask of CEN2 field.
	DAC_CR_CEN2_Msk = 0x40000000
	// Bit CEN2.
	DAC_CR_CEN2 = 0x40000000

	// SWTRGR: DAC software trigger register
	// Position of SWTRIG1 field.
	DAC_SWTRGR_SWTRIG1_Pos = 0x0
	// Bit mask of SWTRIG1 field.
	DAC_SWTRGR_SWTRIG1_Msk = 0x1
	// Bit SWTRIG1.
	DAC_SWTRGR_SWTRIG1 = 0x1
	// Position of SWTRIG2 field.
	DAC_SWTRGR_SWTRIG2_Pos = 0x1
	// Bit mask of SWTRIG2 field.
	DAC_SWTRGR_SWTRIG2_Msk = 0x2
	// Bit SWTRIG2.
	DAC_SWTRGR_SWTRIG2 = 0x2

	// DHR12R1: DAC channel1 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Msk = 0xfff

	// DHR12L1: DAC channel1 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Msk = 0xfff0

	// DHR8R1: DAC channel1 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Msk = 0xff

	// DHR12R2: DAC channel2 12-bit right aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Msk = 0xfff

	// DHR12L2: DAC channel2 12-bit left aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Pos = 0x4
	// Bit mask of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Msk = 0xfff0

	// DHR8R2: DAC channel2 8-bit right-aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Msk = 0xff

	// DHR12RD: Dual DAC 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Msk = 0xfff
	// Position of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Pos = 0x10
	// Bit mask of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Msk = 0xfff0000

	// DHR12LD: DUAL DAC 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Msk = 0xfff0
	// Position of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Pos = 0x14
	// Bit mask of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Msk = 0xfff00000

	// DHR8RD: DUAL DAC 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Msk = 0xff
	// Position of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Pos = 0x8
	// Bit mask of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Msk = 0xff00

	// DOR1: DAC channel1 data output register
	// Position of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Pos = 0x0
	// Bit mask of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Msk = 0xfff

	// DOR2: DAC channel2 data output register
	// Position of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Pos = 0x0
	// Bit mask of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Msk = 0xfff

	// SR: DAC status register
	// Position of DMAUDR1 field.
	DAC_SR_DMAUDR1_Pos = 0xd
	// Bit mask of DMAUDR1 field.
	DAC_SR_DMAUDR1_Msk = 0x2000
	// Bit DMAUDR1.
	DAC_SR_DMAUDR1 = 0x2000
	// Position of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Pos = 0xe
	// Bit mask of CAL_FLAG1 field.
	DAC_SR_CAL_FLAG1_Msk = 0x4000
	// Bit CAL_FLAG1.
	DAC_SR_CAL_FLAG1 = 0x4000
	// Position of BWST1 field.
	DAC_SR_BWST1_Pos = 0xf
	// Bit mask of BWST1 field.
	DAC_SR_BWST1_Msk = 0x8000
	// Bit BWST1.
	DAC_SR_BWST1 = 0x8000
	// Position of DMAUDR2 field.
	DAC_SR_DMAUDR2_Pos = 0x1d
	// Bit mask of DMAUDR2 field.
	DAC_SR_DMAUDR2_Msk = 0x20000000
	// Bit DMAUDR2.
	DAC_SR_DMAUDR2 = 0x20000000
	// Position of CAL_FLAG2 field.
	DAC_SR_CAL_FLAG2_Pos = 0x1e
	// Bit mask of CAL_FLAG2 field.
	DAC_SR_CAL_FLAG2_Msk = 0x40000000
	// Bit CAL_FLAG2.
	DAC_SR_CAL_FLAG2 = 0x40000000
	// Position of BWST2 field.
	DAC_SR_BWST2_Pos = 0x1f
	// Bit mask of BWST2 field.
	DAC_SR_BWST2_Msk = 0x80000000
	// Bit BWST2.
	DAC_SR_BWST2 = 0x80000000

	// CCR: DAC calibration control register
	// Position of OTRIM1 field.
	DAC_CCR_OTRIM1_Pos = 0x0
	// Bit mask of OTRIM1 field.
	DAC_CCR_OTRIM1_Msk = 0x1f
	// Position of OTRIM2 field.
	DAC_CCR_OTRIM2_Pos = 0x10
	// Bit mask of OTRIM2 field.
	DAC_CCR_OTRIM2_Msk = 0x1f0000

	// MCR: DAC mode control register
	// Position of MODE1 field.
	DAC_MCR_MODE1_Pos = 0x0
	// Bit mask of MODE1 field.
	DAC_MCR_MODE1_Msk = 0x7
	// Position of MODE2 field.
	DAC_MCR_MODE2_Pos = 0x10
	// Bit mask of MODE2 field.
	DAC_MCR_MODE2_Msk = 0x70000

	// SHSR1: DAC Sample and Hold sample time register 1
	// Position of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Pos = 0x0
	// Bit mask of TSAMPLE1 field.
	DAC_SHSR1_TSAMPLE1_Msk = 0x3ff

	// SHSR2: DAC Sample and Hold sample time register 2
	// Position of TSAMPLE2 field.
	DAC_SHSR2_TSAMPLE2_Pos = 0x0
	// Bit mask of TSAMPLE2 field.
	DAC_SHSR2_TSAMPLE2_Msk = 0x3ff

	// SHHR: DAC Sample and Hold hold time register
	// Position of THOLD1 field.
	DAC_SHHR_THOLD1_Pos = 0x0
	// Bit mask of THOLD1 field.
	DAC_SHHR_THOLD1_Msk = 0x3ff
	// Position of THOLD2 field.
	DAC_SHHR_THOLD2_Pos = 0x10
	// Bit mask of THOLD2 field.
	DAC_SHHR_THOLD2_Msk = 0x3ff0000

	// SHRR: DAC Sample and Hold refresh time register
	// Position of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Pos = 0x0
	// Bit mask of TREFRESH1 field.
	DAC_SHRR_TREFRESH1_Msk = 0xff
	// Position of TREFRESH2 field.
	DAC_SHRR_TREFRESH2_Pos = 0x10
	// Bit mask of TREFRESH2 field.
	DAC_SHRR_TREFRESH2_Msk = 0xff0000

	// IP_HWCFGR0: DAC IP Hardware Configuration Register
	// Position of DUAL field.
	DAC_IP_HWCFGR0_DUAL_Pos = 0x0
	// Bit mask of DUAL field.
	DAC_IP_HWCFGR0_DUAL_Msk = 0xf
	// Position of LFSR field.
	DAC_IP_HWCFGR0_LFSR_Pos = 0x4
	// Bit mask of LFSR field.
	DAC_IP_HWCFGR0_LFSR_Msk = 0xf0
	// Position of TRIANGLE field.
	DAC_IP_HWCFGR0_TRIANGLE_Pos = 0x8
	// Bit mask of TRIANGLE field.
	DAC_IP_HWCFGR0_TRIANGLE_Msk = 0xf00
	// Position of SAMPLE field.
	DAC_IP_HWCFGR0_SAMPLE_Pos = 0xc
	// Bit mask of SAMPLE field.
	DAC_IP_HWCFGR0_SAMPLE_Msk = 0xf000
	// Position of OR_CFG field.
	DAC_IP_HWCFGR0_OR_CFG_Pos = 0x10
	// Bit mask of OR_CFG field.
	DAC_IP_HWCFGR0_OR_CFG_Msk = 0xff0000

	// VERR: EXTI IP Version register
	// Position of MINREV field.
	DAC_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	DAC_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	DAC_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	DAC_VERR_MAJREV_Msk = 0xf0

	// IPIDR: EXTI Identification register
	// Position of IPID field.
	DAC_IPIDR_IPID_Pos = 0x0
	// Bit mask of IPID field.
	DAC_IPIDR_IPID_Msk = 0xffffffff

	// SIDR: EXTI Size ID register
	// Position of SID field.
	DAC_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	DAC_SIDR_SID_Msk = 0xffffffff
)

// Constants for I2C1: Inter-integrated circuit
const (
	// CR1: Control register 1
	// Position of PE field.
	I2C_CR1_PE_Pos = 0x0
	// Bit mask of PE field.
	I2C_CR1_PE_Msk = 0x1
	// Bit PE.
	I2C_CR1_PE = 0x1
	// Position of TXIE field.
	I2C_CR1_TXIE_Pos = 0x1
	// Bit mask of TXIE field.
	I2C_CR1_TXIE_Msk = 0x2
	// Bit TXIE.
	I2C_CR1_TXIE = 0x2
	// Position of RXIE field.
	I2C_CR1_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	I2C_CR1_RXIE_Msk = 0x4
	// Bit RXIE.
	I2C_CR1_RXIE = 0x4
	// Position of ADDRIE field.
	I2C_CR1_ADDRIE_Pos = 0x3
	// Bit mask of ADDRIE field.
	I2C_CR1_ADDRIE_Msk = 0x8
	// Bit ADDRIE.
	I2C_CR1_ADDRIE = 0x8
	// Position of NACKIE field.
	I2C_CR1_NACKIE_Pos = 0x4
	// Bit mask of NACKIE field.
	I2C_CR1_NACKIE_Msk = 0x10
	// Bit NACKIE.
	I2C_CR1_NACKIE = 0x10
	// Position of STOPIE field.
	I2C_CR1_STOPIE_Pos = 0x5
	// Bit mask of STOPIE field.
	I2C_CR1_STOPIE_Msk = 0x20
	// Bit STOPIE.
	I2C_CR1_STOPIE = 0x20
	// Position of TCIE field.
	I2C_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	I2C_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	I2C_CR1_TCIE = 0x40
	// Position of ERRIE field.
	I2C_CR1_ERRIE_Pos = 0x7
	// Bit mask of ERRIE field.
	I2C_CR1_ERRIE_Msk = 0x80
	// Bit ERRIE.
	I2C_CR1_ERRIE = 0x80
	// Position of DNF field.
	I2C_CR1_DNF_Pos = 0x8
	// Bit mask of DNF field.
	I2C_CR1_DNF_Msk = 0xf00
	// Position of ANFOFF field.
	I2C_CR1_ANFOFF_Pos = 0xc
	// Bit mask of ANFOFF field.
	I2C_CR1_ANFOFF_Msk = 0x1000
	// Bit ANFOFF.
	I2C_CR1_ANFOFF = 0x1000
	// Position of TXDMAEN field.
	I2C_CR1_TXDMAEN_Pos = 0xe
	// Bit mask of TXDMAEN field.
	I2C_CR1_TXDMAEN_Msk = 0x4000
	// Bit TXDMAEN.
	I2C_CR1_TXDMAEN = 0x4000
	// Position of RXDMAEN field.
	I2C_CR1_RXDMAEN_Pos = 0xf
	// Bit mask of RXDMAEN field.
	I2C_CR1_RXDMAEN_Msk = 0x8000
	// Bit RXDMAEN.
	I2C_CR1_RXDMAEN = 0x8000
	// Position of SBC field.
	I2C_CR1_SBC_Pos = 0x10
	// Bit mask of SBC field.
	I2C_CR1_SBC_Msk = 0x10000
	// Bit SBC.
	I2C_CR1_SBC = 0x10000
	// Position of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Pos = 0x11
	// Bit mask of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Msk = 0x20000
	// Bit NOSTRETCH.
	I2C_CR1_NOSTRETCH = 0x20000
	// Position of WUPEN field.
	I2C_CR1_WUPEN_Pos = 0x12
	// Bit mask of WUPEN field.
	I2C_CR1_WUPEN_Msk = 0x40000
	// Bit WUPEN.
	I2C_CR1_WUPEN = 0x40000
	// Position of GCEN field.
	I2C_CR1_GCEN_Pos = 0x13
	// Bit mask of GCEN field.
	I2C_CR1_GCEN_Msk = 0x80000
	// Bit GCEN.
	I2C_CR1_GCEN = 0x80000
	// Position of SMBHEN field.
	I2C_CR1_SMBHEN_Pos = 0x14
	// Bit mask of SMBHEN field.
	I2C_CR1_SMBHEN_Msk = 0x100000
	// Bit SMBHEN.
	I2C_CR1_SMBHEN = 0x100000
	// Position of SMBDEN field.
	I2C_CR1_SMBDEN_Pos = 0x15
	// Bit mask of SMBDEN field.
	I2C_CR1_SMBDEN_Msk = 0x200000
	// Bit SMBDEN.
	I2C_CR1_SMBDEN = 0x200000
	// Position of ALERTEN field.
	I2C_CR1_ALERTEN_Pos = 0x16
	// Bit mask of ALERTEN field.
	I2C_CR1_ALERTEN_Msk = 0x400000
	// Bit ALERTEN.
	I2C_CR1_ALERTEN = 0x400000
	// Position of PECEN field.
	I2C_CR1_PECEN_Pos = 0x17
	// Bit mask of PECEN field.
	I2C_CR1_PECEN_Msk = 0x800000
	// Bit PECEN.
	I2C_CR1_PECEN = 0x800000

	// CR2: Control register 2
	// Position of PECBYTE field.
	I2C_CR2_PECBYTE_Pos = 0x1a
	// Bit mask of PECBYTE field.
	I2C_CR2_PECBYTE_Msk = 0x4000000
	// Bit PECBYTE.
	I2C_CR2_PECBYTE = 0x4000000
	// Position of AUTOEND field.
	I2C_CR2_AUTOEND_Pos = 0x19
	// Bit mask of AUTOEND field.
	I2C_CR2_AUTOEND_Msk = 0x2000000
	// Bit AUTOEND.
	I2C_CR2_AUTOEND = 0x2000000
	// Position of RELOAD field.
	I2C_CR2_RELOAD_Pos = 0x18
	// Bit mask of RELOAD field.
	I2C_CR2_RELOAD_Msk = 0x1000000
	// Bit RELOAD.
	I2C_CR2_RELOAD = 0x1000000
	// Position of NBYTES field.
	I2C_CR2_NBYTES_Pos = 0x10
	// Bit mask of NBYTES field.
	I2C_CR2_NBYTES_Msk = 0xff0000
	// Position of NACK field.
	I2C_CR2_NACK_Pos = 0xf
	// Bit mask of NACK field.
	I2C_CR2_NACK_Msk = 0x8000
	// Bit NACK.
	I2C_CR2_NACK = 0x8000
	// Position of STOP field.
	I2C_CR2_STOP_Pos = 0xe
	// Bit mask of STOP field.
	I2C_CR2_STOP_Msk = 0x4000
	// Bit STOP.
	I2C_CR2_STOP = 0x4000
	// Position of START field.
	I2C_CR2_START_Pos = 0xd
	// Bit mask of START field.
	I2C_CR2_START_Msk = 0x2000
	// Bit START.
	I2C_CR2_START = 0x2000
	// Position of HEAD10R field.
	I2C_CR2_HEAD10R_Pos = 0xc
	// Bit mask of HEAD10R field.
	I2C_CR2_HEAD10R_Msk = 0x1000
	// Bit HEAD10R.
	I2C_CR2_HEAD10R = 0x1000
	// Position of ADD10 field.
	I2C_CR2_ADD10_Pos = 0xb
	// Bit mask of ADD10 field.
	I2C_CR2_ADD10_Msk = 0x800
	// Bit ADD10.
	I2C_CR2_ADD10 = 0x800
	// Position of RD_WRN field.
	I2C_CR2_RD_WRN_Pos = 0xa
	// Bit mask of RD_WRN field.
	I2C_CR2_RD_WRN_Msk = 0x400
	// Bit RD_WRN.
	I2C_CR2_RD_WRN = 0x400
	// Position of SADD field.
	I2C_CR2_SADD_Pos = 0x0
	// Bit mask of SADD field.
	I2C_CR2_SADD_Msk = 0x3ff

	// OAR1: Own address register 1
	// Position of OA1_0 field.
	I2C_OAR1_OA1_0_Pos = 0x0
	// Bit mask of OA1_0 field.
	I2C_OAR1_OA1_0_Msk = 0x1
	// Bit OA1_0.
	I2C_OAR1_OA1_0 = 0x1
	// Position of OA1_7_1 field.
	I2C_OAR1_OA1_7_1_Pos = 0x1
	// Bit mask of OA1_7_1 field.
	I2C_OAR1_OA1_7_1_Msk = 0xfe
	// Position of OA1_8_9 field.
	I2C_OAR1_OA1_8_9_Pos = 0x8
	// Bit mask of OA1_8_9 field.
	I2C_OAR1_OA1_8_9_Msk = 0x300
	// Position of OA1MODE field.
	I2C_OAR1_OA1MODE_Pos = 0xa
	// Bit mask of OA1MODE field.
	I2C_OAR1_OA1MODE_Msk = 0x400
	// Bit OA1MODE.
	I2C_OAR1_OA1MODE = 0x400
	// Position of OA1EN field.
	I2C_OAR1_OA1EN_Pos = 0xf
	// Bit mask of OA1EN field.
	I2C_OAR1_OA1EN_Msk = 0x8000
	// Bit OA1EN.
	I2C_OAR1_OA1EN = 0x8000

	// OAR2: Own address register 2
	// Position of OA2 field.
	I2C_OAR2_OA2_Pos = 0x1
	// Bit mask of OA2 field.
	I2C_OAR2_OA2_Msk = 0xfe
	// Position of OA2MSK field.
	I2C_OAR2_OA2MSK_Pos = 0x8
	// Bit mask of OA2MSK field.
	I2C_OAR2_OA2MSK_Msk = 0x700
	// Position of OA2EN field.
	I2C_OAR2_OA2EN_Pos = 0xf
	// Bit mask of OA2EN field.
	I2C_OAR2_OA2EN_Msk = 0x8000
	// Bit OA2EN.
	I2C_OAR2_OA2EN = 0x8000

	// TIMINGR: Timing register
	// Position of SCLL field.
	I2C_TIMINGR_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_TIMINGR_SCLL_Msk = 0xff
	// Position of SCLH field.
	I2C_TIMINGR_SCLH_Pos = 0x8
	// Bit mask of SCLH field.
	I2C_TIMINGR_SCLH_Msk = 0xff00
	// Position of SDADEL field.
	I2C_TIMINGR_SDADEL_Pos = 0x10
	// Bit mask of SDADEL field.
	I2C_TIMINGR_SDADEL_Msk = 0xf0000
	// Position of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Pos = 0x14
	// Bit mask of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Msk = 0xf00000
	// Position of PRESC field.
	I2C_TIMINGR_PRESC_Pos = 0x1c
	// Bit mask of PRESC field.
	I2C_TIMINGR_PRESC_Msk = 0xf0000000

	// TIMEOUTR: Status register 1
	// Position of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Pos = 0x0
	// Bit mask of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Msk = 0xfff
	// Position of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Pos = 0xc
	// Bit mask of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Msk = 0x1000
	// Bit TIDLE.
	I2C_TIMEOUTR_TIDLE = 0x1000
	// Position of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Pos = 0xf
	// Bit mask of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Msk = 0x8000
	// Bit TIMOUTEN.
	I2C_TIMEOUTR_TIMOUTEN = 0x8000
	// Position of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Pos = 0x10
	// Bit mask of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Msk = 0xfff0000
	// Position of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Pos = 0x1f
	// Bit mask of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Msk = 0x80000000
	// Bit TEXTEN.
	I2C_TIMEOUTR_TEXTEN = 0x80000000

	// ISR: Interrupt and Status register
	// Position of ADDCODE field.
	I2C_ISR_ADDCODE_Pos = 0x11
	// Bit mask of ADDCODE field.
	I2C_ISR_ADDCODE_Msk = 0xfe0000
	// Position of DIR field.
	I2C_ISR_DIR_Pos = 0x10
	// Bit mask of DIR field.
	I2C_ISR_DIR_Msk = 0x10000
	// Bit DIR.
	I2C_ISR_DIR = 0x10000
	// Position of BUSY field.
	I2C_ISR_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	I2C_ISR_BUSY_Msk = 0x8000
	// Bit BUSY.
	I2C_ISR_BUSY = 0x8000
	// Position of ALERT field.
	I2C_ISR_ALERT_Pos = 0xd
	// Bit mask of ALERT field.
	I2C_ISR_ALERT_Msk = 0x2000
	// Bit ALERT.
	I2C_ISR_ALERT = 0x2000
	// Position of TIMEOUT field.
	I2C_ISR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	I2C_ISR_TIMEOUT_Msk = 0x1000
	// Bit TIMEOUT.
	I2C_ISR_TIMEOUT = 0x1000
	// Position of PECERR field.
	I2C_ISR_PECERR_Pos = 0xb
	// Bit mask of PECERR field.
	I2C_ISR_PECERR_Msk = 0x800
	// Bit PECERR.
	I2C_ISR_PECERR = 0x800
	// Position of OVR field.
	I2C_ISR_OVR_Pos = 0xa
	// Bit mask of OVR field.
	I2C_ISR_OVR_Msk = 0x400
	// Bit OVR.
	I2C_ISR_OVR = 0x400
	// Position of ARLO field.
	I2C_ISR_ARLO_Pos = 0x9
	// Bit mask of ARLO field.
	I2C_ISR_ARLO_Msk = 0x200
	// Bit ARLO.
	I2C_ISR_ARLO = 0x200
	// Position of BERR field.
	I2C_ISR_BERR_Pos = 0x8
	// Bit mask of BERR field.
	I2C_ISR_BERR_Msk = 0x100
	// Bit BERR.
	I2C_ISR_BERR = 0x100
	// Position of TCR field.
	I2C_ISR_TCR_Pos = 0x7
	// Bit mask of TCR field.
	I2C_ISR_TCR_Msk = 0x80
	// Bit TCR.
	I2C_ISR_TCR = 0x80
	// Position of TC field.
	I2C_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	I2C_ISR_TC_Msk = 0x40
	// Bit TC.
	I2C_ISR_TC = 0x40
	// Position of STOPF field.
	I2C_ISR_STOPF_Pos = 0x5
	// Bit mask of STOPF field.
	I2C_ISR_STOPF_Msk = 0x20
	// Bit STOPF.
	I2C_ISR_STOPF = 0x20
	// Position of NACKF field.
	I2C_ISR_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	I2C_ISR_NACKF_Msk = 0x10
	// Bit NACKF.
	I2C_ISR_NACKF = 0x10
	// Position of ADDR field.
	I2C_ISR_ADDR_Pos = 0x3
	// Bit mask of ADDR field.
	I2C_ISR_ADDR_Msk = 0x8
	// Bit ADDR.
	I2C_ISR_ADDR = 0x8
	// Position of RXNE field.
	I2C_ISR_RXNE_Pos = 0x2
	// Bit mask of RXNE field.
	I2C_ISR_RXNE_Msk = 0x4
	// Bit RXNE.
	I2C_ISR_RXNE = 0x4
	// Position of TXIS field.
	I2C_ISR_TXIS_Pos = 0x1
	// Bit mask of TXIS field.
	I2C_ISR_TXIS_Msk = 0x2
	// Bit TXIS.
	I2C_ISR_TXIS = 0x2
	// Position of TXE field.
	I2C_ISR_TXE_Pos = 0x0
	// Bit mask of TXE field.
	I2C_ISR_TXE_Msk = 0x1
	// Bit TXE.
	I2C_ISR_TXE = 0x1

	// ICR: Interrupt clear register
	// Position of ALERTCF field.
	I2C_ICR_ALERTCF_Pos = 0xd
	// Bit mask of ALERTCF field.
	I2C_ICR_ALERTCF_Msk = 0x2000
	// Bit ALERTCF.
	I2C_ICR_ALERTCF = 0x2000
	// Position of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Pos = 0xc
	// Bit mask of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Msk = 0x1000
	// Bit TIMOUTCF.
	I2C_ICR_TIMOUTCF = 0x1000
	// Position of PECCF field.
	I2C_ICR_PECCF_Pos = 0xb
	// Bit mask of PECCF field.
	I2C_ICR_PECCF_Msk = 0x800
	// Bit PECCF.
	I2C_ICR_PECCF = 0x800
	// Position of OVRCF field.
	I2C_ICR_OVRCF_Pos = 0xa
	// Bit mask of OVRCF field.
	I2C_ICR_OVRCF_Msk = 0x400
	// Bit OVRCF.
	I2C_ICR_OVRCF = 0x400
	// Position of ARLOCF field.
	I2C_ICR_ARLOCF_Pos = 0x9
	// Bit mask of ARLOCF field.
	I2C_ICR_ARLOCF_Msk = 0x200
	// Bit ARLOCF.
	I2C_ICR_ARLOCF = 0x200
	// Position of BERRCF field.
	I2C_ICR_BERRCF_Pos = 0x8
	// Bit mask of BERRCF field.
	I2C_ICR_BERRCF_Msk = 0x100
	// Bit BERRCF.
	I2C_ICR_BERRCF = 0x100
	// Position of STOPCF field.
	I2C_ICR_STOPCF_Pos = 0x5
	// Bit mask of STOPCF field.
	I2C_ICR_STOPCF_Msk = 0x20
	// Bit STOPCF.
	I2C_ICR_STOPCF = 0x20
	// Position of NACKCF field.
	I2C_ICR_NACKCF_Pos = 0x4
	// Bit mask of NACKCF field.
	I2C_ICR_NACKCF_Msk = 0x10
	// Bit NACKCF.
	I2C_ICR_NACKCF = 0x10
	// Position of ADDRCF field.
	I2C_ICR_ADDRCF_Pos = 0x3
	// Bit mask of ADDRCF field.
	I2C_ICR_ADDRCF_Msk = 0x8
	// Bit ADDRCF.
	I2C_ICR_ADDRCF = 0x8

	// PECR: PEC register
	// Position of PEC field.
	I2C_PECR_PEC_Pos = 0x0
	// Bit mask of PEC field.
	I2C_PECR_PEC_Msk = 0xff

	// RXDR: Receive data register
	// Position of RXDATA field.
	I2C_RXDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	I2C_RXDR_RXDATA_Msk = 0xff

	// TXDR: Transmit data register
	// Position of TXDATA field.
	I2C_TXDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	I2C_TXDR_TXDATA_Msk = 0xff
)

// Constants for RTC: Real-time clock
const (
	// TR: time register
	// Position of PM field.
	RTC_TR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TR_PM = 0x400000
	// Position of HT field.
	RTC_TR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_TR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TR_HU_Msk = 0xf0000
	// Position of MNT field.
	RTC_TR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_TR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TR_MNU_Msk = 0xf00
	// Position of ST field.
	RTC_TR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TR_ST_Msk = 0x70
	// Position of SU field.
	RTC_TR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TR_SU_Msk = 0xf

	// DR: date register
	// Position of YT field.
	RTC_DR_YT_Pos = 0x14
	// Bit mask of YT field.
	RTC_DR_YT_Msk = 0xf00000
	// Position of YU field.
	RTC_DR_YU_Pos = 0x10
	// Bit mask of YU field.
	RTC_DR_YU_Msk = 0xf0000
	// Position of WDU field.
	RTC_DR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_DR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_DR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_DR_MT_Msk = 0x1000
	// Bit MT.
	RTC_DR_MT = 0x1000
	// Position of MU field.
	RTC_DR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_DR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_DR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_DR_DT_Msk = 0x30
	// Position of DU field.
	RTC_DR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_DR_DU_Msk = 0xf

	// SSR: sub second register
	// Position of SS field.
	RTC_SSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_SSR_SS_Msk = 0xffff

	// ICSR: initialization and status register
	// Position of ALRAWF field.
	RTC_ICSR_ALRAWF_Pos = 0x0
	// Bit mask of ALRAWF field.
	RTC_ICSR_ALRAWF_Msk = 0x1
	// Bit ALRAWF.
	RTC_ICSR_ALRAWF = 0x1
	// Position of ALRBWF field.
	RTC_ICSR_ALRBWF_Pos = 0x1
	// Bit mask of ALRBWF field.
	RTC_ICSR_ALRBWF_Msk = 0x2
	// Bit ALRBWF.
	RTC_ICSR_ALRBWF = 0x2
	// Position of WUTWF field.
	RTC_ICSR_WUTWF_Pos = 0x2
	// Bit mask of WUTWF field.
	RTC_ICSR_WUTWF_Msk = 0x4
	// Bit WUTWF.
	RTC_ICSR_WUTWF = 0x4
	// Position of SHPF field.
	RTC_ICSR_SHPF_Pos = 0x3
	// Bit mask of SHPF field.
	RTC_ICSR_SHPF_Msk = 0x8
	// Bit SHPF.
	RTC_ICSR_SHPF = 0x8
	// Position of INITS field.
	RTC_ICSR_INITS_Pos = 0x4
	// Bit mask of INITS field.
	RTC_ICSR_INITS_Msk = 0x10
	// Bit INITS.
	RTC_ICSR_INITS = 0x10
	// Position of RSF field.
	RTC_ICSR_RSF_Pos = 0x5
	// Bit mask of RSF field.
	RTC_ICSR_RSF_Msk = 0x20
	// Bit RSF.
	RTC_ICSR_RSF = 0x20
	// Position of INITF field.
	RTC_ICSR_INITF_Pos = 0x6
	// Bit mask of INITF field.
	RTC_ICSR_INITF_Msk = 0x40
	// Bit INITF.
	RTC_ICSR_INITF = 0x40
	// Position of INIT field.
	RTC_ICSR_INIT_Pos = 0x7
	// Bit mask of INIT field.
	RTC_ICSR_INIT_Msk = 0x80
	// Bit INIT.
	RTC_ICSR_INIT = 0x80
	// Position of RECALPF field.
	RTC_ICSR_RECALPF_Pos = 0x10
	// Bit mask of RECALPF field.
	RTC_ICSR_RECALPF_Msk = 0x10000
	// Bit RECALPF.
	RTC_ICSR_RECALPF = 0x10000

	// PRER: prescaler register
	// Position of PREDIV_A field.
	RTC_PRER_PREDIV_A_Pos = 0x10
	// Bit mask of PREDIV_A field.
	RTC_PRER_PREDIV_A_Msk = 0x7f0000
	// Position of PREDIV_S field.
	RTC_PRER_PREDIV_S_Pos = 0x0
	// Bit mask of PREDIV_S field.
	RTC_PRER_PREDIV_S_Msk = 0x7fff

	// WUTR: wakeup timer register
	// Position of WUT field.
	RTC_WUTR_WUT_Pos = 0x0
	// Bit mask of WUT field.
	RTC_WUTR_WUT_Msk = 0xffff

	// CR: control register
	// Position of WUCKSEL field.
	RTC_CR_WUCKSEL_Pos = 0x0
	// Bit mask of WUCKSEL field.
	RTC_CR_WUCKSEL_Msk = 0x7
	// Position of TSEDGE field.
	RTC_CR_TSEDGE_Pos = 0x3
	// Bit mask of TSEDGE field.
	RTC_CR_TSEDGE_Msk = 0x8
	// Bit TSEDGE.
	RTC_CR_TSEDGE = 0x8
	// Position of REFCKON field.
	RTC_CR_REFCKON_Pos = 0x4
	// Bit mask of REFCKON field.
	RTC_CR_REFCKON_Msk = 0x10
	// Bit REFCKON.
	RTC_CR_REFCKON = 0x10
	// Position of BYPSHAD field.
	RTC_CR_BYPSHAD_Pos = 0x5
	// Bit mask of BYPSHAD field.
	RTC_CR_BYPSHAD_Msk = 0x20
	// Bit BYPSHAD.
	RTC_CR_BYPSHAD = 0x20
	// Position of FMT field.
	RTC_CR_FMT_Pos = 0x6
	// Bit mask of FMT field.
	RTC_CR_FMT_Msk = 0x40
	// Bit FMT.
	RTC_CR_FMT = 0x40
	// Position of ALRAE field.
	RTC_CR_ALRAE_Pos = 0x8
	// Bit mask of ALRAE field.
	RTC_CR_ALRAE_Msk = 0x100
	// Bit ALRAE.
	RTC_CR_ALRAE = 0x100
	// Position of ALRBE field.
	RTC_CR_ALRBE_Pos = 0x9
	// Bit mask of ALRBE field.
	RTC_CR_ALRBE_Msk = 0x200
	// Bit ALRBE.
	RTC_CR_ALRBE = 0x200
	// Position of WUTE field.
	RTC_CR_WUTE_Pos = 0xa
	// Bit mask of WUTE field.
	RTC_CR_WUTE_Msk = 0x400
	// Bit WUTE.
	RTC_CR_WUTE = 0x400
	// Position of TSE field.
	RTC_CR_TSE_Pos = 0xb
	// Bit mask of TSE field.
	RTC_CR_TSE_Msk = 0x800
	// Bit TSE.
	RTC_CR_TSE = 0x800
	// Position of ALRAIE field.
	RTC_CR_ALRAIE_Pos = 0xc
	// Bit mask of ALRAIE field.
	RTC_CR_ALRAIE_Msk = 0x1000
	// Bit ALRAIE.
	RTC_CR_ALRAIE = 0x1000
	// Position of ALRBIE field.
	RTC_CR_ALRBIE_Pos = 0xd
	// Bit mask of ALRBIE field.
	RTC_CR_ALRBIE_Msk = 0x2000
	// Bit ALRBIE.
	RTC_CR_ALRBIE = 0x2000
	// Position of WUTIE field.
	RTC_CR_WUTIE_Pos = 0xe
	// Bit mask of WUTIE field.
	RTC_CR_WUTIE_Msk = 0x4000
	// Bit WUTIE.
	RTC_CR_WUTIE = 0x4000
	// Position of TSIE field.
	RTC_CR_TSIE_Pos = 0xf
	// Bit mask of TSIE field.
	RTC_CR_TSIE_Msk = 0x8000
	// Bit TSIE.
	RTC_CR_TSIE = 0x8000
	// Position of ADD1H field.
	RTC_CR_ADD1H_Pos = 0x10
	// Bit mask of ADD1H field.
	RTC_CR_ADD1H_Msk = 0x10000
	// Bit ADD1H.
	RTC_CR_ADD1H = 0x10000
	// Position of SUB1H field.
	RTC_CR_SUB1H_Pos = 0x11
	// Bit mask of SUB1H field.
	RTC_CR_SUB1H_Msk = 0x20000
	// Bit SUB1H.
	RTC_CR_SUB1H = 0x20000
	// Position of BKP field.
	RTC_CR_BKP_Pos = 0x12
	// Bit mask of BKP field.
	RTC_CR_BKP_Msk = 0x40000
	// Bit BKP.
	RTC_CR_BKP = 0x40000
	// Position of COSEL field.
	RTC_CR_COSEL_Pos = 0x13
	// Bit mask of COSEL field.
	RTC_CR_COSEL_Msk = 0x80000
	// Bit COSEL.
	RTC_CR_COSEL = 0x80000
	// Position of POL field.
	RTC_CR_POL_Pos = 0x14
	// Bit mask of POL field.
	RTC_CR_POL_Msk = 0x100000
	// Bit POL.
	RTC_CR_POL = 0x100000
	// Position of OSEL field.
	RTC_CR_OSEL_Pos = 0x15
	// Bit mask of OSEL field.
	RTC_CR_OSEL_Msk = 0x600000
	// Position of COE field.
	RTC_CR_COE_Pos = 0x17
	// Bit mask of COE field.
	RTC_CR_COE_Msk = 0x800000
	// Bit COE.
	RTC_CR_COE = 0x800000
	// Position of ITSE field.
	RTC_CR_ITSE_Pos = 0x18
	// Bit mask of ITSE field.
	RTC_CR_ITSE_Msk = 0x1000000
	// Bit ITSE.
	RTC_CR_ITSE = 0x1000000
	// Position of TAMPTS field.
	RTC_CR_TAMPTS_Pos = 0x19
	// Bit mask of TAMPTS field.
	RTC_CR_TAMPTS_Msk = 0x2000000
	// Bit TAMPTS.
	RTC_CR_TAMPTS = 0x2000000
	// Position of TAMPOE field.
	RTC_CR_TAMPOE_Pos = 0x1a
	// Bit mask of TAMPOE field.
	RTC_CR_TAMPOE_Msk = 0x4000000
	// Bit TAMPOE.
	RTC_CR_TAMPOE = 0x4000000
	// Position of TAMPALRM_PU field.
	RTC_CR_TAMPALRM_PU_Pos = 0x1d
	// Bit mask of TAMPALRM_PU field.
	RTC_CR_TAMPALRM_PU_Msk = 0x20000000
	// Bit TAMPALRM_PU.
	RTC_CR_TAMPALRM_PU = 0x20000000
	// Position of TAMPALRM_TYPE field.
	RTC_CR_TAMPALRM_TYPE_Pos = 0x1e
	// Bit mask of TAMPALRM_TYPE field.
	RTC_CR_TAMPALRM_TYPE_Msk = 0x40000000
	// Bit TAMPALRM_TYPE.
	RTC_CR_TAMPALRM_TYPE = 0x40000000
	// Position of OUT2EN field.
	RTC_CR_OUT2EN_Pos = 0x1f
	// Bit mask of OUT2EN field.
	RTC_CR_OUT2EN_Msk = 0x80000000
	// Bit OUT2EN.
	RTC_CR_OUT2EN = 0x80000000

	// WPR: write protection register
	// Position of KEY field.
	RTC_WPR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	RTC_WPR_KEY_Msk = 0xff

	// CALR: calibration register
	// Position of CALP field.
	RTC_CALR_CALP_Pos = 0xf
	// Bit mask of CALP field.
	RTC_CALR_CALP_Msk = 0x8000
	// Bit CALP.
	RTC_CALR_CALP = 0x8000
	// Position of CALW8 field.
	RTC_CALR_CALW8_Pos = 0xe
	// Bit mask of CALW8 field.
	RTC_CALR_CALW8_Msk = 0x4000
	// Bit CALW8.
	RTC_CALR_CALW8 = 0x4000
	// Position of CALW16 field.
	RTC_CALR_CALW16_Pos = 0xd
	// Bit mask of CALW16 field.
	RTC_CALR_CALW16_Msk = 0x2000
	// Bit CALW16.
	RTC_CALR_CALW16 = 0x2000
	// Position of CALM field.
	RTC_CALR_CALM_Pos = 0x0
	// Bit mask of CALM field.
	RTC_CALR_CALM_Msk = 0x1ff

	// SHIFTR: shift control register
	// Position of ADD1S field.
	RTC_SHIFTR_ADD1S_Pos = 0x1f
	// Bit mask of ADD1S field.
	RTC_SHIFTR_ADD1S_Msk = 0x80000000
	// Bit ADD1S.
	RTC_SHIFTR_ADD1S = 0x80000000
	// Position of SUBFS field.
	RTC_SHIFTR_SUBFS_Pos = 0x0
	// Bit mask of SUBFS field.
	RTC_SHIFTR_SUBFS_Msk = 0x7fff

	// TSTR: time stamp time register
	// Position of SU field.
	RTC_TSTR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TSTR_SU_Msk = 0xf
	// Position of ST field.
	RTC_TSTR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TSTR_ST_Msk = 0x70
	// Position of MNU field.
	RTC_TSTR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TSTR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_TSTR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TSTR_MNT_Msk = 0x7000
	// Position of HU field.
	RTC_TSTR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TSTR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_TSTR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TSTR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_TSTR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TSTR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TSTR_PM = 0x400000

	// TSDR: time stamp date register
	// Position of WDU field.
	RTC_TSDR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_TSDR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_TSDR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_TSDR_MT_Msk = 0x1000
	// Bit MT.
	RTC_TSDR_MT = 0x1000
	// Position of MU field.
	RTC_TSDR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_TSDR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_TSDR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_TSDR_DT_Msk = 0x30
	// Position of DU field.
	RTC_TSDR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_TSDR_DU_Msk = 0xf

	// TSSSR: timestamp sub second register
	// Position of SS field.
	RTC_TSSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_TSSSR_SS_Msk = 0xffff

	// ALRMAR: alarm A register
	// Position of MSK4 field.
	RTC_ALRMAR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMAR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMAR_MSK4 = 0x80000000
	// Position of WDSEL field.
	RTC_ALRMAR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMAR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMAR_WDSEL = 0x40000000
	// Position of DT field.
	RTC_ALRMAR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMAR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMAR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMAR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMAR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMAR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMAR_MSK3 = 0x800000
	// Position of PM field.
	RTC_ALRMAR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMAR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMAR_PM = 0x400000
	// Position of HT field.
	RTC_ALRMAR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMAR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMAR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMAR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMAR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMAR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMAR_MSK2 = 0x8000
	// Position of MNT field.
	RTC_ALRMAR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMAR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMAR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMAR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMAR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMAR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMAR_MSK1 = 0x80
	// Position of ST field.
	RTC_ALRMAR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMAR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMAR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMAR_SU_Msk = 0xf

	// ALRMASSR: alarm A sub second register
	// Position of MASKSS field.
	RTC_ALRMASSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMASSR_MASKSS_Msk = 0xf000000
	// Position of SS field.
	RTC_ALRMASSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMASSR_SS_Msk = 0x7fff

	// ALRMBR: alarm B register
	// Position of MSK4 field.
	RTC_ALRMBR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMBR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMBR_MSK4 = 0x80000000
	// Position of WDSEL field.
	RTC_ALRMBR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMBR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMBR_WDSEL = 0x40000000
	// Position of DT field.
	RTC_ALRMBR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMBR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMBR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMBR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMBR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMBR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMBR_MSK3 = 0x800000
	// Position of PM field.
	RTC_ALRMBR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMBR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMBR_PM = 0x400000
	// Position of HT field.
	RTC_ALRMBR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMBR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMBR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMBR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMBR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMBR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMBR_MSK2 = 0x8000
	// Position of MNT field.
	RTC_ALRMBR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMBR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMBR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMBR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMBR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMBR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMBR_MSK1 = 0x80
	// Position of ST field.
	RTC_ALRMBR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMBR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMBR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMBR_SU_Msk = 0xf

	// ALRMBSSR: alarm B sub second register
	// Position of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Msk = 0xf000000
	// Position of SS field.
	RTC_ALRMBSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMBSSR_SS_Msk = 0x7fff

	// SR: status register
	// Position of ALRAF field.
	RTC_SR_ALRAF_Pos = 0x0
	// Bit mask of ALRAF field.
	RTC_SR_ALRAF_Msk = 0x1
	// Bit ALRAF.
	RTC_SR_ALRAF = 0x1
	// Position of ALRBF field.
	RTC_SR_ALRBF_Pos = 0x1
	// Bit mask of ALRBF field.
	RTC_SR_ALRBF_Msk = 0x2
	// Bit ALRBF.
	RTC_SR_ALRBF = 0x2
	// Position of WUTF field.
	RTC_SR_WUTF_Pos = 0x2
	// Bit mask of WUTF field.
	RTC_SR_WUTF_Msk = 0x4
	// Bit WUTF.
	RTC_SR_WUTF = 0x4
	// Position of TSF field.
	RTC_SR_TSF_Pos = 0x3
	// Bit mask of TSF field.
	RTC_SR_TSF_Msk = 0x8
	// Bit TSF.
	RTC_SR_TSF = 0x8
	// Position of TSOVF field.
	RTC_SR_TSOVF_Pos = 0x4
	// Bit mask of TSOVF field.
	RTC_SR_TSOVF_Msk = 0x10
	// Bit TSOVF.
	RTC_SR_TSOVF = 0x10
	// Position of ITSF field.
	RTC_SR_ITSF_Pos = 0x5
	// Bit mask of ITSF field.
	RTC_SR_ITSF_Msk = 0x20
	// Bit ITSF.
	RTC_SR_ITSF = 0x20

	// MISR: masked interrupt status register
	// Position of ALRAMF field.
	RTC_MISR_ALRAMF_Pos = 0x0
	// Bit mask of ALRAMF field.
	RTC_MISR_ALRAMF_Msk = 0x1
	// Bit ALRAMF.
	RTC_MISR_ALRAMF = 0x1
	// Position of ALRBMF field.
	RTC_MISR_ALRBMF_Pos = 0x1
	// Bit mask of ALRBMF field.
	RTC_MISR_ALRBMF_Msk = 0x2
	// Bit ALRBMF.
	RTC_MISR_ALRBMF = 0x2
	// Position of WUTMF field.
	RTC_MISR_WUTMF_Pos = 0x2
	// Bit mask of WUTMF field.
	RTC_MISR_WUTMF_Msk = 0x4
	// Bit WUTMF.
	RTC_MISR_WUTMF = 0x4
	// Position of TSMF field.
	RTC_MISR_TSMF_Pos = 0x3
	// Bit mask of TSMF field.
	RTC_MISR_TSMF_Msk = 0x8
	// Bit TSMF.
	RTC_MISR_TSMF = 0x8
	// Position of TSOVMF field.
	RTC_MISR_TSOVMF_Pos = 0x4
	// Bit mask of TSOVMF field.
	RTC_MISR_TSOVMF_Msk = 0x10
	// Bit TSOVMF.
	RTC_MISR_TSOVMF = 0x10
	// Position of ITSMF field.
	RTC_MISR_ITSMF_Pos = 0x5
	// Bit mask of ITSMF field.
	RTC_MISR_ITSMF_Msk = 0x20
	// Bit ITSMF.
	RTC_MISR_ITSMF = 0x20

	// SCR: status clear register
	// Position of CALRAF field.
	RTC_SCR_CALRAF_Pos = 0x0
	// Bit mask of CALRAF field.
	RTC_SCR_CALRAF_Msk = 0x1
	// Bit CALRAF.
	RTC_SCR_CALRAF = 0x1
	// Position of CALRBF field.
	RTC_SCR_CALRBF_Pos = 0x1
	// Bit mask of CALRBF field.
	RTC_SCR_CALRBF_Msk = 0x2
	// Bit CALRBF.
	RTC_SCR_CALRBF = 0x2
	// Position of CWUTF field.
	RTC_SCR_CWUTF_Pos = 0x2
	// Bit mask of CWUTF field.
	RTC_SCR_CWUTF_Msk = 0x4
	// Bit CWUTF.
	RTC_SCR_CWUTF = 0x4
	// Position of CTSF field.
	RTC_SCR_CTSF_Pos = 0x3
	// Bit mask of CTSF field.
	RTC_SCR_CTSF_Msk = 0x8
	// Bit CTSF.
	RTC_SCR_CTSF = 0x8
	// Position of CTSOVF field.
	RTC_SCR_CTSOVF_Pos = 0x4
	// Bit mask of CTSOVF field.
	RTC_SCR_CTSOVF_Msk = 0x10
	// Bit CTSOVF.
	RTC_SCR_CTSOVF = 0x10
	// Position of CITSF field.
	RTC_SCR_CITSF_Pos = 0x5
	// Bit mask of CITSF field.
	RTC_SCR_CITSF_Msk = 0x20
	// Bit CITSF.
	RTC_SCR_CITSF = 0x20

	// HWCFGR: hardware configuration register
	// Position of ALARMB field.
	RTC_HWCFGR_ALARMB_Pos = 0x0
	// Bit mask of ALARMB field.
	RTC_HWCFGR_ALARMB_Msk = 0xf
	// Position of WAKEUP field.
	RTC_HWCFGR_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	RTC_HWCFGR_WAKEUP_Msk = 0xf0
	// Position of SMOOTH_CALIB field.
	RTC_HWCFGR_SMOOTH_CALIB_Pos = 0x8
	// Bit mask of SMOOTH_CALIB field.
	RTC_HWCFGR_SMOOTH_CALIB_Msk = 0xf00
	// Position of TIMESTAMP field.
	RTC_HWCFGR_TIMESTAMP_Pos = 0xc
	// Bit mask of TIMESTAMP field.
	RTC_HWCFGR_TIMESTAMP_Msk = 0xf000
	// Position of OPTIONREG_OUT field.
	RTC_HWCFGR_OPTIONREG_OUT_Pos = 0x10
	// Bit mask of OPTIONREG_OUT field.
	RTC_HWCFGR_OPTIONREG_OUT_Msk = 0xff0000
	// Position of TRUST_ZONE field.
	RTC_HWCFGR_TRUST_ZONE_Pos = 0x18
	// Bit mask of TRUST_ZONE field.
	RTC_HWCFGR_TRUST_ZONE_Msk = 0xf000000

	// VERR: EXTI IP Version register
	// Position of MINREV field.
	RTC_VERR_MINREV_Pos = 0x0
	// Bit mask of MINREV field.
	RTC_VERR_MINREV_Msk = 0xf
	// Position of MAJREV field.
	RTC_VERR_MAJREV_Pos = 0x4
	// Bit mask of MAJREV field.
	RTC_VERR_MAJREV_Msk = 0xf0

	// IPIDR: EXTI Identification register
	// Position of IPID field.
	RTC_IPIDR_IPID_Pos = 0x0
	// Bit mask of IPID field.
	RTC_IPIDR_IPID_Msk = 0xffffffff

	// SIDR: EXTI Size ID register
	// Position of SID field.
	RTC_SIDR_SID_Pos = 0x0
	// Bit mask of SID field.
	RTC_SIDR_SID_Msk = 0xffffffff
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER: Interrupt Set Enable Register
	// Position of SETENA field.
	NVIC_ISER_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER_SETENA_Msk = 0xffffffff

	// ICER: Interrupt Clear Enable Register
	// Position of CLRENA field.
	NVIC_ICER_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER_CLRENA_Msk = 0xffffffff

	// ISPR: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR_SETPEND_Msk = 0xffffffff

	// ICPR: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR_CLRPEND_Msk = 0xffffffff

	// IPR0: Interrupt Priority Register 0
	// Position of PRI_0 field.
	NVIC_IPR0_PRI_0_Pos = 0x0
	// Bit mask of PRI_0 field.
	NVIC_IPR0_PRI_0_Msk = 0xff
	// Position of PRI_1 field.
	NVIC_IPR0_PRI_1_Pos = 0x8
	// Bit mask of PRI_1 field.
	NVIC_IPR0_PRI_1_Msk = 0xff00
	// Position of PRI_2 field.
	NVIC_IPR0_PRI_2_Pos = 0x10
	// Bit mask of PRI_2 field.
	NVIC_IPR0_PRI_2_Msk = 0xff0000
	// Position of PRI_3 field.
	NVIC_IPR0_PRI_3_Pos = 0x18
	// Bit mask of PRI_3 field.
	NVIC_IPR0_PRI_3_Msk = 0xff000000

	// IPR1: Interrupt Priority Register 1
	// Position of PRI_4 field.
	NVIC_IPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	NVIC_IPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	NVIC_IPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	NVIC_IPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	NVIC_IPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	NVIC_IPR1_PRI_6_Msk = 0xff0000
	// Position of PRI_7 field.
	NVIC_IPR1_PRI_7_Pos = 0x18
	// Bit mask of PRI_7 field.
	NVIC_IPR1_PRI_7_Msk = 0xff000000

	// IPR2: Interrupt Priority Register 2
	// Position of PRI_8 field.
	NVIC_IPR2_PRI_8_Pos = 0x0
	// Bit mask of PRI_8 field.
	NVIC_IPR2_PRI_8_Msk = 0xff
	// Position of PRI_9 field.
	NVIC_IPR2_PRI_9_Pos = 0x8
	// Bit mask of PRI_9 field.
	NVIC_IPR2_PRI_9_Msk = 0xff00
	// Position of PRI_10 field.
	NVIC_IPR2_PRI_10_Pos = 0x10
	// Bit mask of PRI_10 field.
	NVIC_IPR2_PRI_10_Msk = 0xff0000
	// Position of PRI_11 field.
	NVIC_IPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	NVIC_IPR2_PRI_11_Msk = 0xff000000

	// IPR3: Interrupt Priority Register 3
	// Position of PRI_12 field.
	NVIC_IPR3_PRI_12_Pos = 0x0
	// Bit mask of PRI_12 field.
	NVIC_IPR3_PRI_12_Msk = 0xff
	// Position of PRI_13 field.
	NVIC_IPR3_PRI_13_Pos = 0x8
	// Bit mask of PRI_13 field.
	NVIC_IPR3_PRI_13_Msk = 0xff00
	// Position of PRI_14 field.
	NVIC_IPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	NVIC_IPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	NVIC_IPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	NVIC_IPR3_PRI_15_Msk = 0xff000000

	// IPR4: Interrupt Priority Register 4
	// Position of PRI_16 field.
	NVIC_IPR4_PRI_16_Pos = 0x0
	// Bit mask of PRI_16 field.
	NVIC_IPR4_PRI_16_Msk = 0xff
	// Position of PRI_17 field.
	NVIC_IPR4_PRI_17_Pos = 0x8
	// Bit mask of PRI_17 field.
	NVIC_IPR4_PRI_17_Msk = 0xff00
	// Position of PRI_18 field.
	NVIC_IPR4_PRI_18_Pos = 0x10
	// Bit mask of PRI_18 field.
	NVIC_IPR4_PRI_18_Msk = 0xff0000
	// Position of PRI_19 field.
	NVIC_IPR4_PRI_19_Pos = 0x18
	// Bit mask of PRI_19 field.
	NVIC_IPR4_PRI_19_Msk = 0xff000000

	// IPR5: Interrupt Priority Register 5
	// Position of PRI_20 field.
	NVIC_IPR5_PRI_20_Pos = 0x0
	// Bit mask of PRI_20 field.
	NVIC_IPR5_PRI_20_Msk = 0xff
	// Position of PRI_21 field.
	NVIC_IPR5_PRI_21_Pos = 0x8
	// Bit mask of PRI_21 field.
	NVIC_IPR5_PRI_21_Msk = 0xff00
	// Position of PRI_22 field.
	NVIC_IPR5_PRI_22_Pos = 0x10
	// Bit mask of PRI_22 field.
	NVIC_IPR5_PRI_22_Msk = 0xff0000
	// Position of PRI_23 field.
	NVIC_IPR5_PRI_23_Pos = 0x18
	// Bit mask of PRI_23 field.
	NVIC_IPR5_PRI_23_Msk = 0xff000000

	// IPR6: Interrupt Priority Register 6
	// Position of PRI_24 field.
	NVIC_IPR6_PRI_24_Pos = 0x0
	// Bit mask of PRI_24 field.
	NVIC_IPR6_PRI_24_Msk = 0xff
	// Position of PRI_25 field.
	NVIC_IPR6_PRI_25_Pos = 0x8
	// Bit mask of PRI_25 field.
	NVIC_IPR6_PRI_25_Msk = 0xff00
	// Position of PRI_26 field.
	NVIC_IPR6_PRI_26_Pos = 0x10
	// Bit mask of PRI_26 field.
	NVIC_IPR6_PRI_26_Msk = 0xff0000
	// Position of PRI_27 field.
	NVIC_IPR6_PRI_27_Pos = 0x18
	// Bit mask of PRI_27 field.
	NVIC_IPR6_PRI_27_Msk = 0xff000000

	// IPR7: Interrupt Priority Register 7
	// Position of PRI_28 field.
	NVIC_IPR7_PRI_28_Pos = 0x0
	// Bit mask of PRI_28 field.
	NVIC_IPR7_PRI_28_Msk = 0xff
	// Position of PRI_29 field.
	NVIC_IPR7_PRI_29_Pos = 0x8
	// Bit mask of PRI_29 field.
	NVIC_IPR7_PRI_29_Msk = 0xff00
	// Position of PRI_30 field.
	NVIC_IPR7_PRI_30_Pos = 0x10
	// Bit mask of PRI_30 field.
	NVIC_IPR7_PRI_30_Msk = 0xff0000
	// Position of PRI_31 field.
	NVIC_IPR7_PRI_31_Pos = 0x18
	// Bit mask of PRI_31 field.
	NVIC_IPR7_PRI_31_Msk = 0xff000000
)

// Constants for MPU: Memory protection unit
const (
	// TYPER: MPU type register
	// Position of SEPARATE field.
	MPU_TYPER_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPER_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPER_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPER_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPER_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPER_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPER_IREGION_Msk = 0xff0000

	// CTRL: MPU control register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU region number register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU region base address register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU region attribute and size register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x3e
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000
)

// Constants for STK: SysTick timer
const (
	// CSR: SysTick control and status register
	// Position of ENABLE field.
	STK_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	STK_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	STK_CSR_ENABLE = 0x1
	// Position of TICKINT field.
	STK_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	STK_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	STK_CSR_TICKINT = 0x2
	// Position of CLKSOURCE field.
	STK_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	STK_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	STK_CSR_CLKSOURCE = 0x4
	// Position of COUNTFLAG field.
	STK_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	STK_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	STK_CSR_COUNTFLAG = 0x10000

	// RVR: SysTick reload value register
	// Position of RELOAD field.
	STK_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	STK_RVR_RELOAD_Msk = 0xffffff

	// CVR: SysTick current value register
	// Position of CURRENT field.
	STK_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	STK_CVR_CURRENT_Msk = 0xffffff

	// CALIB: SysTick calibration value register
	// Position of TENMS field.
	STK_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	STK_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	STK_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	STK_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	STK_CALIB_SKEW = 0x40000000
	// Position of NOREF field.
	STK_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	STK_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	STK_CALIB_NOREF = 0x80000000
)

// Constants for SCB: System control block
const (
	// CPUID: CPUID base register
	// Position of Revision field.
	SCB_CPUID_Revision_Pos = 0x0
	// Bit mask of Revision field.
	SCB_CPUID_Revision_Msk = 0xf
	// Position of PartNo field.
	SCB_CPUID_PartNo_Pos = 0x4
	// Bit mask of PartNo field.
	SCB_CPUID_PartNo_Msk = 0xfff0
	// Position of Architecture field.
	SCB_CPUID_Architecture_Pos = 0x10
	// Bit mask of Architecture field.
	SCB_CPUID_Architecture_Msk = 0xf0000
	// Position of Variant field.
	SCB_CPUID_Variant_Pos = 0x14
	// Bit mask of Variant field.
	SCB_CPUID_Variant_Msk = 0xf00000
	// Position of Implementer field.
	SCB_CPUID_Implementer_Pos = 0x18
	// Bit mask of Implementer field.
	SCB_CPUID_Implementer_Msk = 0xff000000

	// ICSR: Interrupt control and state register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x7f000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000

	// VTOR: Vector table offset register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application interrupt and reset control register
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// Position of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Pos = 0xf
	// Bit mask of ENDIANESS field.
	SCB_AIRCR_ENDIANESS_Msk = 0x8000
	// Bit ENDIANESS.
	SCB_AIRCR_ENDIANESS = 0x8000
	// Position of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Pos = 0x10
	// Bit mask of VECTKEYSTAT field.
	SCB_AIRCR_VECTKEYSTAT_Msk = 0xffff0000

	// SCR: System control register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// Position of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Pos = 0x4
	// Bit mask of SEVEONPEND field.
	SCB_SCR_SEVEONPEND_Msk = 0x10
	// Bit SEVEONPEND.
	SCB_SCR_SEVEONPEND = 0x10

	// CCR: Configuration and control register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// Position of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Pos = 0x3
	// Bit mask of UNALIGN__TRP field.
	SCB_CCR_UNALIGN__TRP_Msk = 0x8
	// Bit UNALIGN__TRP.
	SCB_CCR_UNALIGN__TRP = 0x8
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200

	// SHPR2: System handler priority registers
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System handler priority registers
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000
)
